PRO abbruch,x,a,y,ps=ps,portrait=portrait,landscape=landscape
;+
; NAME:
;	abbruch
;
; PURPOSE:
;	This procedure calculates the analogous neutron detection signal.
;
; CATEGORY:
;	Instrument.
;
; CALLING SEQUENCE:
;
;	ABBRUCH, X, A, Y
;
;
; INPUTS:
;   X   :
;   A(0): factor,
;   A(1): t0,
;   A(2): sigma
;   A(3): capture_ratio,
;   A(4): gamma_ratio,
;   A(5): gamma_exp,
;   Y   :
;
; OPTIONAL INPUTS:
;	none
;	
; KEYWORD PARAMETERS:
;	none
;
; OUTPUTS:
;	?
;
; OPTIONAL OUTPUTS:
;	none
;
; COMMON BLOCKS:
;	none
;
; SIDE EFFECTS:
;	none?
;
; RESTRICTIONS:
;	none?
;
; PROCEDURE:
;	no foobar superfloatation method
;
; EXAMPLE:
;
; MODIFICATION HISTORY:
; 	Written by:	Thomas Hansen, May 1997.
;	May, 1997	Documentation
;
;-

take_datp,datp
w=x*0.

FUNCT,x,[a(0)*(1-a(3)),a(1),a(2),0,0,0],y
FOR i=a(1)/4,a(1),a(1)/100. DO BEGIN
  FUNCT,x,[a(0)*a(3),i,a(2),0,0,0],w
  y = y+w/100.
ENDFOR
FOR i=3*a(1)/4,a(1),a(1)/100. DO BEGIN
  FUNCT,x,[a(0)*a(3),i,a(2),0,0,0],w
  y = y+w/100.
ENDFOR
y=y+a(0)*a(4)/x^a(5)
IF KEYWORD_SET(ps) THEN BEGIN
  IF NOT KEYWORD_SET(portrait) THEN portrait=0 ELSE landscape=0
  IF NOT KEYWORD_SET(landscape) THEN landscape=0
  i=1
  WHILE y(i) LE y(i-1) AND i LT N_ELEMENTS(y) DO i = i+1
  IF NOT (i LT N_ELEMENTS(y)) THEN i=0
  SET_PLOT,'ps'
  DEVICE,FILENAME='anode.ps',portrait=portrait,landscape=landscape
  PLOT,x,y,$
    TITLE='Signal histogram for detector anode '+systime(),$
    YRANGE=[0,max(y(i:N_ELEMENTS(y)-1))],$
    YTITLE='Number of counts',$
    XTITLE='Signal amplitude',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,4)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,4)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,4)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,4)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,4)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,4)
  DEVICE,/CLOSE
  SET_PLOT,'x'
ENDIF
mod_datp,datp,'w_tit','Signal histogram for detector anode'
mod_datp,datp,'other_tit','hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,4)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,4)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,4)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,4)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,4)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,4)
take_datp,datp
END
pro adam,n1,n2,cen,sbox,back,spin,fac

; n1-n2 are the scan numbers
; cen is the centre of the region to be summed in x-pixel
; sbox is the number of pixels to the left and right included in the sum region
; i.e if cen=119 and sbox=2 and back=3 we sum from 117 to 121 and the background
; is 122 to 124
; spin is either 'u' or 'd'
; fac is just a normalization constant

wav=4.4063

close,1
close,2
close,10
i=0
fsize=intarr(n2-n1+1)

for f=n1,n2 do begin
  text=strtrim(string(f),2)
  name2='lee_align_1D_'+text+'_'+spin+'.par'
  openr,2,name2
  print,'opening ',name2
  dum='xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'

   while not EOF(2) do begin
     readf,2,dum
     print,dum
     i=i+1
   endwhile

  print,'number of points for ',f,'= ',i
  fsize(f-n1)=i
  close,2
  i=0
endfor

print,'total number of all points = ',total(fsize)

data=fltarr(4,total(fsize))
all=fltarr(256,total(fsize))
count=0
for f=n1,n2 do begin

  text=strtrim(string(f),2)
  name2='lee_align_1D_'+text+'_'+spin+'.par'
  name1='lee_align_1D_'+text+'_'+spin

  openr,1,name1
  openr,2,name2

  dat=intarr(256,fsize(f-n1))
  dat2=intarr(256,fsize(f-n1))
  par=fltarr(7,fsize(f-n1))
  
  readf,1,dat
  readf,2,par
  left=cen-sbox
  right=cen+sbox
  leftb=right+1
  rightb=leftb+back-1
  sum=total(dat(left:right,*),1)
  sumerr=sqrt(sum)

  if (back gt 0) then begin
    sumb=total(dat(leftb:rightb,*),1)
    sumberr=sqrt(sumb)
  endif else begin
    sumb=0
    sumberr=0
  endelse

  sumberr=sqrt(sumb)
  ssum=sum-sumb
  ssumerr=sqrt(sum+sumb)
  ferr=ssumerr/ssum

  r=ssum/(par(3,*)*sin(par(0,*)*!pi/180.)*fac)

  for k=0,fsize(f-n1)-1 do begin
    for l=0,255 do begin
      dat2(l,k)=dat(l,k)/(par(2,k)*sin(par(0,k)*!pi/180.)*fac)
    endfor
  endfor

  rerr=r*ferr
  q=sin(par(0,*)*!pi/180.)*4*!pi/wav
  start=total(fsize(0:(f-n1)))-fsize(f-n1)
  finish=total(fsize(0:(f-n1)))-1
  data(0,start:finish)=q
  data(1,start:finish)=r
  data(2,start:finish)=rerr
  data(3,start:finish)=q*0.04
  all(0:255,start:finish)=dat2
  close,1
  close,2
endfor

window,0,retain=2,xsize=470,ysize=500
plot,/ylog,data(0,*),data(1,*),xtitle='q(A^-1)',ytitle='Reflectivity',psym=7
oploterr,data(0,*),data(1,*),data(2,*)

window,1,retain=2,xsize=470,ysize=500
plot,data(0,*),data(1,*)*data(0,*)^4,xtitle='q(A^-1)',ytitle='Reflectivity',psym=7
oploterr,data(0,*),data(1,*),data(2,*)




all=all(112:126,*)
window,2,retain=2,xsize=470,ysize=500
n=30
m1=max(all)
m2=min(all)
ll=fltarr(n+1)

for i=0,n do begin 
	ll(i)=m2+float(i)*(((m1-m2))/float(n+1))
endfor

print,m2,m1
print,ll
loadct,5
gamma_ct,0.302
contour,all,levels=ll,c_colors=indgen(10)*25
print,data
oname='scan'+strtrim(string(n1),2)+'-'+strtrim(string(n2),2)+'-'+spin+'.dat'
print,'saving data in file: ',oname

print,'opening file'
openw,10,oname
printf,10,'box = ',left,right,'   back = ',leftb,rightb,'   fac = ',fac
;writeu,10,'fart '
printf,10,data,format='(f10.8,2x,f10.8,2x,f10.8,2x,f10.8)'

close,10
end
;------------------------------------------------------------------------------
;******************************************************************************
;
	FUNCTION add_xyz, w_in, zpo=zpo, xyz=xyz, nopo=nopo, ex

;For D7 data only. 
;
;adds the X, Y and Z measurements together. Must be performed on raw data, i.e.
;before calling normalise.pro
;
;KEYWORDS:
; /zpo: (default)
;	three non-flip measurements are added together to give one
;	three flip measurements are also added together. Dimensions:
;		w_in(nspectra,6,nruns) -> w_out(nspectra,2,nruns)
;
; /xyz:
;	after separately adding together the non-flip and flip measurements, 
;	the sums are then copied into the X and Y phases. Dimensions:
;		w_in(nspectra,6,nruns) -> w_out(nspectra,6,nruns)
;
; /nopo:
;	add all flip phases together to obtain a single measurement. Then copy 
;	sum into the Z1, X and Y phases. Dimensions:
;		w_in(nspectra,6,nruns) -> w_out(nspectra,6,nruns)
; (the argument ex is obsolete kept for backwards compatability)
;
;DIMENSIONS: (see above)
;
;COMMAND SYNTAX:
; w2=add_xyz(w1[,/zpo][,/xyz][,/nopo])
;
; (optional keywords shown in square brackets)
;							KHA,JRS 18/4/02
;------------------------------------------------------------------------------
;******************************************************************************


	COMMON c_lamp_access, inst

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start add_xyz:'

	take_datp, datp

	expand=0
	IF(N_ELEMENTS(ex) GT 0) THEN expand=ex
	IF KEYWORD_SET(zpo) THEN expand=0
	IF KEYWORD_SET(xyz) THEN expand=1
	IF KEYWORD_SET(nopo) THEN expand=2

;-------------------------------------------------------------------------------
;Check dimensions of input arrays

	IF (inst NE 'D7') THEN BEGIN
		PRINT,'add_xyz: Error - instrument must be D7'
		GOTO, finished
	ENDIF

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw

	par=datp.p
	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nruns=FIX(par(3))
	TOF=FIX(par(8))

	IF (N_ELEMENTS(expand) EQ 0) THEN expand=0

	IF (iprint GT 0) THEN BEGIN
		PRINT,'TOF=',TOF
		PRINT,'nspectra=',nspectra
		PRINT,'nphases=',nphases
		PRINT,'nruns=',nruns
		PRINT,'expand=',expand
	ENDIF

	e_in=datp.e
	n_in=datp.n
	y_in=datp.y

	errstring=''
	IF (TOF EQ 1) THEN errstring='data must be no-TOF'
	IF (nphases NE 6) THEN errstring='data must be XYZ'
	IF (expand NE 0 AND expand NE 1 AND expand NE 2) THEN errstring='expand must be 0,1 or 2'
	IF (nspectra NE 64 OR N_ELEMENTS(e_in) GT 1) THEN errstring='data must be raw, i.e. not normalised'
	IF (errstring NE '') THEN BEGIN
		PRINT,'Add_xyz: Error - ',errstring
		GOTO, finished
	ENDIF

	IF (sw(0) EQ 3) THEN nruns=sw(3)
		
;-------------------------------------------------------------------------------
;Perform addition

	IF (expand EQ 0) THEN w_out=FLTARR(nspectra,2,nruns) $
			ELSE w_out=w_in
	n_out=n_in

	IF (expand LE 1) THEN BEGIN
		w_out(*,0,*)=w_in(*,0,*)+w_in(*,2,*)+w_in(*,4,*)
		w_out(*,1,*)=w_in(*,1,*)+w_in(*,3,*)+w_in(*,5,*)
		n_out(*,1,*)=n_in(*,1,*)+n_in(*,3,*)+n_in(*,5,*)
		n_out(*,2,*)=n_in(*,2,*)+n_in(*,4,*)+n_in(*,6,*)
	ENDIF ELSE BEGIN
		w_out(*,0,*)=TOTAL(w_in,2)
		i = INTARR(5)
		w_out(*,1:5,*)=w_out(*,i,*)
		n_out(*,1,*)=TOTAL(n_in,2)
		n_out(*,2:6,*)=n_out(*,i+1,*)
	ENDELSE

	IF (expand EQ 0) THEN BEGIN
		n_out(*,3:6,*)=0.
		y_out=y_in(0:1)
		mod_datp, datp, "y", y_out
		datp.p(2)=2.
		IF (N_ELEMENTS(datp.pv) GT 1) THEN datp.pv(2,*)=2.
	ENDIF ELSE IF (expand EQ 1) THEN BEGIN
		w_out(*,2:3,*)=w_out(*,0:1,*)
		w_out(*,4:5,*)=w_out(*,0:1,*)
		n_out(*,3:4,*)=n_out(*,1:2,*)
		n_out(*,5:6,*)=n_out(*,1:2,*)
	ENDIF

	datp.n=n_out

	IF (iprint GT 0) THEN PRINT,'End of Addition section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	s=datp.other_tit & i=RSTRPOS(s,' ') & n=STRLEN(s) & numor=STRMID(s,i+1,n-1)
        IF (nruns EQ 1) THEN IF (STRPOS(numor,'>') EQ -1) THEN numor=STRTRIM(STRING(FIX(par(0))),2)

	CASE expand OF
		0: key = '/zpo'
		1: key = '/xyz'
		2: key = '/nopo'
	ENDCASE

	IF (STRPOS(s,' -cc') EQ -1) THEN $	; data not previously concatenated
		datp.other_tit='D7 #'+numor+' -ax('+key+')' $
	ELSE datp.other_tit=datp.other_tit+' -ax('+key+')'

	IF (expand EQ 0) THEN s='Z,X and Y added together'
	IF (expand EQ 1) THEN s='Z,X and Y added together and copied to X and Y'
	IF (expand EQ 2) THEN s='all phases added together and expanded back'
	PRINT,'add_xyz: '+s

finished:
	IF (iprint GT 0) THEN PRINT,'End Add_xyz:'

	give_datp, datp

	RETURN, w_out
	END
PRO alignloop,s,n1,truecolors=truecolors,noplot=noplot,x1=x1,y1=y1,e1=e1,r0=r0,s0=s0,wset=wset,$
                   errlim=errlim,errcalcs=errcalcs,limits=limits,exclusions=exclusion
;+
; NAME:
;	alignloop
;
; PURPOSE:
;	This procedure creates the relative efficiencies of a PSD and a reconstituted powder pattern from a detector scan on a vanadium sample
;
; CATEGORY:
;	Instrument.
;
; CALLING SEQUENCE:
;	alignloop,s,n1,truecolors=truecolors,noplot=noplot,x1=x1,y1=y1,e1=e1,r0=r0,s0=s0,wset=wset,errlim=errlim,errcalcs=errcalcs,limits=limits,exclusions=exclusion
;
; INPUTS:
;   s		:	Workspace (2D array, nd * steps elements, as defined in LAMP, normally a 2theta scan over a vanadium)
;	n1		:	Starting detector cell number, will be set to relative efficiency of 1
;
; OPTIONAL INPUTS:
;	none
;	
; KEYWORD PARAMETERS:
;	truecolors	:	?
;	noplot		:	no plotting output, accelerates computing
;	x1			:	?
;	y1			:	?
;	e1			:	?
;	r0			:	?
;	s0			:	?
;	wset		:	window to be used for plotting output
;	errlim		:	not used
;	errcalcs	:	?
;	limits		:	?
;	exclusion	:	?
;
; OUTPUTS:
;	none
;
; OPTIONAL OUTPUTS:
;	none
;
; COMMON BLOCKS:
;	none
;
; SIDE EFFECTS:
;	none
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
; 	methods of error calculation are set according to  "Statistics for nuclear and particle physicists" by L.Lyon that can be found 
; 	in the ILL library (number 5 68)
; 	each calculation is commented 
;
; EXAMPLE:
;	(in LAMP)
;	RDSET,inst='D20',base="Loc Cycle 005" 
;	flag,/nor,/noint,/nobad,/flp,/noeff,/noang
;	w1=RDRUN(19512)
;   ALIGNLOOP(w1,800,x1=x,y1=y,e1=e,s0=s,r0=r)
;
; MODIFICATION HISTORY:
; 	Written by:		Steffen Metzger,	August 1998.
;	Modified by:	Thomas C Hansen,	November 2000 (weighted error calculations)
;
;-
	tmp=where (s eq 0,cnt)
	IF cnt gt 0 THEN s(tmp)=1
	qcompare2allcells,s,n1,int=y1,xx=x1,sig=e1,/nopr;,/plot,/true
	nbofcells=N_ELEMENTS(s(*,0))
	r0=DBLARR(nbofcells)
	IF NOT keyword_SET(plot) THEN plot=0 ELSE wset=1
	IF NOT keyword_SET(exclusions) THEN exclusions=0 
	s0=DBLarr(nbofcells)
	r0(n1)=1L
	list=[n1]
	treated=BYTARR(nbofcells)
	errcalcs=INTARR(nbofcells)
	treated(n1)=1
	seen=treated
	factor=intarr(1600)
	FOR counter=1L,nbofcells-1 DO BEGIN
	  	seen(x1)=1  
	  	cells=where(seen AND NOT treated)
	  	index=cells-x1(0)
	  	minerr=min(ABS(cells-n1),n2) 
	  	n2=x1(index(n2(0)))
	  	list=[list,n2]
	  	treated(n2)=1
	  	qcompare2allcells,s,n2,int=y2,xx=x2,sig=e2,/nopr,exclusions=exclusions
	  	IF min([y1,y2]) le 0 THEN print,"ERROR occured"
	  	xmin=min([x1,x2])
	  	xmax=max([x1,x2])
	  	IF NOT KEYWORD_SET(noplot) THEN BEGIN
	    	colors,color,truecolors=truecolors,/noprint
	    	IF KEYWORD_SET(wset) THEN wset,0 ELSE window,0,xsi=800,title='Compare parts of efficiency corrections ',ysi=400
	    	plot,x1,y1,back=color(4),color=color(0),yrange=[min([y1,y2]),max([y1,y2])<1.2],xstyle=1,xr=[xmin,xmax],title=STRCOMPRESS(n2)  ;black
	    	oplot,where(r0 NE 0),r0(where(r0 NE 0)),color=color(0),psy=7   ;green
	    	oplot,x2,y2,color=color(0) ;blue
	  	ENDIF
		cmin=max([min(x1),min(x2)])
		cmax=min([max(x1),max(x2)])
		i1=where(x1 ge cmin and x1 le cmax AND x1 NE n1,comcount)
		i2=where(x2 ge cmin and x2 le cmax AND x2 NE n1)
		com=x1(i1)
		tmp=where(y1(i1)/y2(i2) EQ 0,count)
		IF count GE 1 THEN BEGIN
			print,'Ratio = 0 : ',com(tmp(0)),', ... ('+STRCOMPRESS(count,/RE)+')'
		ENDIF
		ratio=y1(i1)/y2(i2)                                 		;	ratio of arrays at a certain index
		sigm=ratio*SQRT((e1(i1)/y1(i1))^2+(e2(i2)/y2(i2))^2)		;	error calculation in non-linear situation
		okay=where(ratio NE 0 AND sigm NE 0,okcount)
		;	r0(n2)=(TOTAL(ratio(okay)))/okcount								;	mean of ratios, if angles below beamstop are excluded the formula of the weighted mean 
		r0(n2)=TOTAL((ratio(okay))/(sigm(okay))^2)/TOTAL(1./(sigm(okay))^2)	;	can be used  
		;	s0(n2)=SQRT(TOTAL(((sigm(okay))/okcount)^2))					;	rror calculation in linear situation, for weighted mean 
	  	s0(n2)=SQRT(1/TOTAL((1/sigm(okay))^2))								;	has to be used
		IF NOT KEYWORD_SET(noplot) THEN BEGIN
			IF KEYWORD_SET(wset) THEN wset,1 ELSE window,1,title='Efficiency compared to neighbours',ysi=380,xsi=800
			plot,com,ratio,back=color(4),color=color(0),yst=1,yrange=[r0(n2)*.9,r0(n2)*1.1],xstyle=1,xr=[xmin,xmax],title=STRCOMPRESS(n2)
			oplot,com,ratio+sigm,color=color(0)
			oplot,com,ratio-sigm,color=color(0)
			wset,0
		ENDIF
		IF NOT KEYWORD_SET(noprint) THEN BEGIN
	   		print,FORMAT="(2I5,' : ',2G14.6)",counter,n2,r0(n2),s0(n2)
		ENDIF
		xx=com
		y2(i2)=y2(i2)*r0(n2)                                    	;	array is aligned
		e2(i2)=y2(i2)*SQRT((e2(i2)/y2(i2))^2+(s0(n2)/r0(n2))^2)		;	error calculation in non-linear situation
		factor(com)=factor(com)+1
		y1(i1)= (factor(com)*y1(i1)+y2(i2))/(factor(com)+1)   		;	mean of aligned array and reference array which has the weight of the 
		                                                      		;	number of already aligned arrays
		e1(i1)=SQRT((e1(i1)*factor(com)/(factor(com)+1))^2 + ((e2(i2))/(factor(com)+1))^2)   ;	error calculation in linear situation
		tmp=where(x2 LT min(x1) OR x2 GT max(x1),count)       		;	*** new elements ... ****
		IF count GE 1 THEN BEGIN
			IF min(x2(tmp)) EQ 0 THEN BEGIN
				PRINT,'Cell 0 ...!'
			ENDIF
	 		x1=[x1,x2(tmp)]
	 		y1=[y1,y2(tmp)]
	 		e1=[e1,e2(tmp)]
	 		tmp=sort(x1)
	 		x1=x1(tmp)
	 		y1=y1(tmp)
	 		e1=e1(tmp)
		ENDIF
	ENDFOR
END
;	*********
;	*********
	pro alpha
;	*********
;	*********

;GIVE THE FILE NAMES
;*******************
 print ,''
 infile=''
 read,' Name of data  file: ',infile
 alphaf=''
 read,' Name of alpha file: ',alphaf
 print ,''

;OPEN THE FILES
;**************
 on_ioerror,mis1
 openr,u1,infile,/get_lun
 on_ioerror,mis2
 openr,u2,alphaf,/get_lun

;READ DATA FILE ----> .ima , .gel , LAMPbin
;**************
 print,' Reading data file '+infile+ '  ...'
 on_ioerror,mis3
 offset=bytarr(158)
 data  =intarr(4000,2000)
 idx   =strpos(infile,'LAMP')
 if idx lt 0 then readu,u1,offset,data
 if idx ge 0 then readu,u1,       data
 close,u1
 if !D.name eq 'X' then begin
		device,retain=2
 		w1=congrid(data,128,64) > 0
		window,1,xsize=512,ysize=512,title='RAW DATA'
 		shade_surf,w1
 		endif

;READ ALPHA FILE
;***************
 print,' Reading alpha file '+alphaf+ '  ...'
 on_ioerror,mis4
 alpha  =intarr(4000,2000)
 readu,u2,alpha
 close,u2

;CORRECTION
;**********
 print,' Start correction ...'
 s=size(data)
 if s(s(0)+1) eq 2 then begin
 
	index=where ( data lt 0 )
	
	data =long  ( data )
	
	if index(0) ge 0 then data(index)=65536+ data(index)
	index=0
 endif
 data=temporary(data)*alpha/100
 data=fix(data)
 if !D.name eq 'X' then begin
 		w1=congrid(data,128,64) > 0
		window,2,xsize=512,ysize=512,title='CORRECTED DATA'
 		shade_surf,w1
 		endif
 
;WRITE RESULT
;************
 pos=0 & idx=0
 while  pos ge 0 do begin
 	pos=strpos(infile,'/',idx)
 	if  pos ge 0 then idx=pos+1
 endwhile
 
 outfile=strmid(infile,idx,50)+'_cor'
 print,' Writing result to ',outfile+ '  integer*2(4000,2000)  ...'
 on_ioerror,mis5
 openw ,u,outfile,/get_lun
 writeu,u,data
 close ,u
 print,string(7b)
 if !D.name eq 'X' then read,' OK ?: ',infile
 
return

mis1:print,string(7b),'? Error opening data  file'
return
mis2:print,string(7b),'? Error opening alpha file'
return
mis3:print,string(7b),'? Error reading data  file'
return
mis4:print,string(7b),'? Error reading alpha file'
return
mis5:print,string(7b),'? Error writing result file'
return

end

;	****
;	****
;	MAIN
;	****
;	****

!quiet=1
 print ,''
 print ,''
 print ,' Data Correction Module for LADI  (C. Wilkinson & D. Richard)'
 print ,''
 print ,''

 alpha
 exit
; end
 
PRO amon,n1,n2,water,dnf,rnf,qq

dpr=180./!pi
peak=212
gap=11
lam=5.0
l=0
k=0
data_blead,n1,datnf,monx,y,mm,q,th,san0,dan0,dett,nx,t0
m1=long(1)
m2=long(1)
ymin=61
ymax=214
z=size(datnf)


dnf=fltarr(z(1),(n2-n1+1))
san=fltarr((n2-n1+1))
dan=fltarr((n2-n1+1))
qq=fltarr((n2-n1+1))
mon=fltarr((n2-n1+1))
print,'size= ',((n2-n1+1)),z(1)

for i=0,(n2-n1) do begin
  
  print,'iiiiiiiiii',i,l,i+n1
  data_blead,n1+i,datnf,m1,y,mm,q,th,s,d,dett,nx,time
  if (l eq 0) then monnf0=float(m1)
  print,'total nf',total(float(datnf))

  dnf(*,l)=total(float(datnf(*,*)),2)/(time*water)
  print,'total dnf',total(dnf(*,l))
  print,'san dan time',s,d,time
  san(l)=s & dan(l)=d & mon(l)=m2
  qq(l)= 4.*!pi*sin(san(l)/dpr)/lam   
  l=l+1
endfor


fnf=total(dnf(peak-(gap-1)/2:peak+(gap-1)/2,*),1)
bnf=total(dnf(peak-(gap-1)/2-gap:peak-(gap-1)/2-1,*),1)

print,peak-(gap-1)/2-gap,peak-(gap-1)/2-1,peak-(gap-1)/2,peak+(gap-1)/2

rnf=(fnf-bnf)



end
pro anal,db,ref,fac,water,q,r,bg,w5,x5,e5,chop
;help,db,ref,water


; db is the direct beam run
; ref is the reflection run
; water is the x effiency of the detector
; q is the array of q(A^-1)
; r is the range over which to sum the intensity
; bg is the range to sum the background either side of r
; w5 is the output reflectivity with the q (x5) and error (e4)
; fac is the normalisation factor for w2 reflection data ie
; divide the ref data by this to make it normalised to the direct beam




ref1=ref
ref2=ref
db1=db
db2=db
edb=db
ere=ref

z=size(db)
print,z(2)

a=max(total(db,2),b)
f1=b-(r-1)/2
f2=b+(r-1)/2
print,'db peak at: ',b
for i=0,z(2)-1 do db1(*,i)=db(*,i)/water
print,'done water correction'

; subtract background from direct beam
if (bg gt 0) then begin
 for i=0,z(2)-1 do db2(*,i)=db1(*,i)-(mean(db1(f1-1-bg:f1-1,i))+mean(db1(f2+1:f2+1+bg,i)))/2
endif else begin
 db2=db1
endelse

print,'done background correction',f1-1-bg,f1-1,f1,f2,f2+1,f2+1+bg


a=max(total(ref(*,40:z(2)-1),2),c)
ff1=c-(r-1)/2
ff2=c+(r-1)/2
for i=0,z(2)-1 do ref1(*,i)=ref(*,i)/(water*fac)


; subtract background from reflected beam
if (bg gt 0) then begin
  for i=0,z(2)-1 do ref2(*,i)=ref1(*,i)-(mean(ref1(ff1-1-bg:ff1-1,i))+mean(ref1(ff2+1:ff2+1+bg,i)))/2
endif else begin
 ref2=ref1
endelse

print,'reflection peak at ',c




r=total(ref2(ff1:ff2,*),1)
d=total(db2(f1:f2,*),1)
dbb=d
rb=r


;errors for direct beam background
if (bg gt 0) then begin
  dbb=(sqrt(total(db1(f1-1-bg:f1-1),1)+total(db1(f2+1:f2+1+bg),1)))/(2.*bg)
endif else begin
  dbb=0
endelse

ed=sqrt(d+dbb^2)

;errors for reflected beam background
if (bg gt 0) then begin
  rb=(sqrt(total(ref1(ff1-1-bg:ff1-1),1)+total(ref1(ff2+1:ff2+1+bg),1)))/(2.*bg)
endif else begin
  rb=0
endelse


er=sqrt(((sqrt(r*fac)/fac))^2+rb^2)

;help,r & help,d & help,er & help,ed

reff=r
ereff=r

for i=0,z(2)-1 do begin
;  print,'raw',i,r(i),d(i)
  if ((r(i) gt 0.) and (d(i) gt 0.)) then begin
    reff(i)=r(i)/d(i)
    
    ereff(i)=reff(i)*sqrt((er(i)/r(i))^2+(ed(i)/d(i))^2) 
;    print,'good point',i,r(i),d(i),reff(i),ereff(i),ereff(i)/(reff(i)*alog(10.))
  endif else begin
    print,'Youve made a bad point there'
    ereff(i)=0
    reff(i)=1e-9
;    print,' bum point',i,ereff(i),reff(i)
  endelse
endfor


; unlogged data for reflectivity is in reff, q is q and error is ereff

;help,reff & help,ereff
w5=alog10(reff(chop:z(2)-1)) & x5=q(chop:z(2)-1) & e5=ereff(chop:z(2)-1)/(reff(chop:z(2)-1)*alog(10.))

return
end


PRO anf10scan,nu1,nu2,w10,x10,e10,w11,x11,e11,w12,x12,e12,w13,x13,e13

; f1-f2 is the foreground range and b1-b2 is background range
; back=0 means no background is taken

f1=175 & f2=215 & b1=160 & b2=165
lam=5.3

back=1

;normalize by time or monitor  for monitor set norm='monitor'
norm='time'

;for det=3400mm

; direct beam dan value is d0
d0=0.922
;direct beam hits pixel p0
p0=193.862


xpixels=286
mmpp=1.0357
dpr=180./!pi
pcen=138.98

points=(nu2-nu1+1)
hpoints=fix((float(nu2-nu1)+1.5)/2.)

print,points,hpoints,nu1,nu2

w10=fltarr(hpoints)
e10=fltarr(hpoints)
x10=fltarr(hpoints)
w11=fltarr(hpoints)
e11=fltarr(hpoints)
x11=fltarr(hpoints)

w12=fltarr(hpoints)
e12=fltarr(hpoints)
x12=fltarr(hpoints)





water=fltarr(xpixels)
close,3


;  open water correction file created by awater.pro
openr,3,'water_LAMPascii'

for  i=0,xpixels-1 do begin
  readf,3,a,b,c
  water(i)=b
endfor

k=0
for l=0,points-1,2 do begin
  num=l+nu1
  data_read,num,w1,w2,y,m,q,th,s,d,dett,nx,time
  if norm eq 'time' then norm_fac=time
  if norm eq 'monitor' then norm_fac=w2/1000.
  
if back eq 1 then begin

  w10(k)=total(w1(f1:f2)/(norm_fac*water(f1:f2)))-total(w1(b1:b2)*(f2-f1+1)/((b2-b1+1)*norm_fac*water(b1:b2)))
  e10(k)= sqrt(total(w1(f1:f2))/(norm_fac^2.)+ total(w1(b1:b2))*(f2-f1+1)^2/((b2-b1+1)^2*norm_fac^2.))

endif else begin

  w10(k)=total(w1(f1:f2)/(norm_fac*water(f1:f2)))
  e10(k)= sqrt(total(w1(f1:f2)))/norm_fac

endelse
;find peak
numersum=0.
denomsum=0.
for i=f1,f2 do begin
     numer=w1(i)*float(i)
     denom=w1(i)
     numersum=numer+numersum
     denomsum=denom+denomsum
endfor

pr=numersum/denomsum

th=(d+dpr*atan((pcen-pr)*mmpp/dett))/2-(d0+dpr*atan((pcen-p0)*mmpp/dett))/2
print,'calculated theta= ',th

;calculate q from the calculated theta
  x10(k)=4*!pi*sin(th/dpr)/lam
k=k+1
endfor

k=0
for l=1,points-1,2 do begin
  num=l+nu1
  data_read,num,w1,w2,y,m,q,th,s,d,dett,nx,time
  if norm eq 'time' then norm_fac=time
  if norm eq 'monitor' then norm_fac=w2/1000.
if back eq 1 then begin

  w11(k)=total(w1(f1:f2)/(norm_fac*water(f1:f2)))-total(w1(b1:b2)*(f2-f1+1)/((b2-b1+1)*norm_fac*water(b1:b2)))
  e11(k)= sqrt(total(w1(f1:f2))/(norm_fac^2.)+ total(w1(b1:b2))*(f2-f1+1)^2/((b2-b1+1)^2*norm_fac^2.))

endif else begin

  w11(k)=total(w1(f1:f2)/(norm_fac*water(f1:f2)))
  e11(k)= sqrt(total(w1(f1:f2)))/norm_fac

endelse




;find peak
numersum=0.
denomsum=0.
for i=f1,f2 do begin
     numer=w1(i)*float(i)
     denom=w1(i)
     numersum=numer+numersum
     denomsum=denom+denomsum
endfor

pr=numersum/denomsum

th=(d+dpr*atan((pcen-pr)*mmpp/dett))/2-(d0+dpr*atan((pcen-p0)*mmpp/dett))/2
print,'calculated theta= ',th

;calculate q from the calculated theta
  x11(k)=4*!pi*sin(th/dpr)/lam
k=k+1
endfor

;illumination normalisation

ef10=e10/w10
ef11=e11/w11
w10=w10*x10(0)/(w10(0)*x10)
e10=w10*ef10
w11=w11*x10(0)/(w11(0)*x11)
e11=w11*ef11

w12=(w10-w11)/(w11+w10)
x12=x10
e12=w12*sqrt((sqrt(e11^2+e10^2)/(w10-w11))^2+(sqrt(e11^2+e10^2)/(w11+w10))^2)

w13=w10/w11
e13=w13*sqrt((e10/w10)^2+(e11/w11)^2)
x13=x10
print,points,hpoints,nu1,nu2

end
PRO HOUSE                             ;Define a procedure to draw a house.
house_x = [0, 16, 16, 8, 0, 0, 16, 16, 8, 0];X coordinates of 10 vertices. First 5 are front face, second 5 are back face. The range is 0 to 16.
house_y = [0, 0, 10, 16, 10, 0, 0, 10, 16, 10];The corresponding y values range from 0 to 16.
house_z = [54, 54, 54, 54, 54, 30, 30, 30, 30, 30];The z values range from 30 to 54.
min_x = -4 & max_x = 20.      ;Define max and min xy values to scale. Slightly larger than data range.
!X.S = [-(-4), 1.]/(20 - (-4));Set x data scale to range from -4 to 20. 
!Y.S = !X.S                          ;Same for y.
!Z.S = [-10, 1.]/(70 - 10)   ;The z range is from 10 to 70. 
face = [INDGEN(5), 0]           ;Indices of front face.
PLOTS, house_x[face], house_y[face], $
   house_z[face], /T3D, /DATA;Draw front face.
PLOTS, house_x[face + 5], house_y[face + 5], $
   house_z[face + 5], /T3D, /DATA;Draw back face.
FOR I = 0, 4 DO PLOTS, [house_x[i], house_x[i + 5]], $
   [house_y[i], house_y[i + 5]], $
   [house_z[i], house_z[i + 5]], /T3D, /DATA;Connecting lines from front to back.
XYOUTS, house_x[3], house_y[3], Z = house_z[3], 'Front', $
   /T3D, /DATA, SIZE = 2      ;Annotate front peak.
XYOUTS, house_x[8], house_y[8], Z = house_z[8], 'Back', $
   /T3D, /DATA, SIZE = 2      ;Annotate back.
END                                      ;End of house procedure.

;The HOUSE procedure could be called from the IDL command line to produce a number of different plots. For example:
;T3D, /RESET & HOUSE              ;Set up no rotation, scale, and draw house.
;H = [0.5, 0.5, 0.5]              ;Create a handy constant.
;T3D, /RESET, TRANS = -H, ROT = [30, 30, 0] & $
;T3D, TR = H & HOUSE              ;Straight projection after rotating 30 degrees about x and y axes. 
;T3D, /RESET, TRANS = -H, ROT=[0, 0, 0], OBLIQUE=[.5, -45] & $
;T3D, TR = H & HOUSE              ;No rotation, oblique projection, z factor = 0.5, angle = 45. 
;T3D, /RESET, TR=-H, ROT=[-6, 6, 0], PERS=4 & $
;T3D, TR=H & HOUSE;Rotate 6 degrees about x and y, then apply perspective.
PRO animfield, xr, yr, zr, u, v, w, arrows=arrows,$
               nvecs=nvecs,size=size,$
               sx=sx,sy=sy,sz=sz, scale=scale,$
               probe=probe,nframes=nframes,$
               xtimes=xtimes,ytimes=ytimes,len=len
;+
;field2d,charge,(-.5,1.5,.1],(-.5,1.5,.1],(-.5,1.5,.1],u,v,w,sx=sx,sy=sy,sz=sz
;field2d,electrodes,(50,120,10],(380,420,10],(-1.5,1.5,1.],u,v,w,sx=sx,sy=sy,sz=sz,/prog
;SCALE3, X=(-2,2],Y=(-2,2],Z=(-2,2],ax=40,az=0
;flow3,u,v,w,arrowsize=.02,sx=sx,sy=sy,sz=sz
;-
IF NOT KEYWORD_SET(len) THEN len=2.
xsize=ABS(xr(1)-xr(0))
ysize=ABS(yr(1)-yr(0))
zsize=ABS(zr(1)-zr(0))
IF NOT KEYWORD_SET(xtimes) THEN xtimes=2
IF NOT KEYWORD_SET(ztimes) THEN ztimes=1
IF NOT KEYWORD_SET(sx) THEN sx=0
IF NOT KEYWORD_SET(sy) THEN sy=0
IF NOT KEYWORD_SET(sz) THEN sz=0
IF KEYWORD_SET(nvecs) THEN BEGIN
  sx=0
  sy=0
  sz=0
ENDIF ELSE nvecs=0
IF NOT KEYWORD_SET(scale) THEN scale=[0,MAX([N_ELEMENTS(u(*,0,0)),N_ELEMENTS(u(0,*,0)),N_ELEMENTS(u(0,0,*))])]
IF NOT KEYWORD_SET(arrows) THEN arrows=200
ASPECT=FLOAT(xsize)/FLOAT(ysize)
IF NOT KEYWORD_SET(size) THEN sizx=400 ELSE sizx=size
sizy=sizx
WINDOW, /FREE, XSIZE=sizx, YSIZE=sizy, COLORS=-16
IF NOT KEYWORD_SET ( nframes ) THEN nframes = 160
XINTERANIMATE, SET=[sizx, sizy, nframes] 
FOR i = 0, nframes - 1 DO BEGIN 
    SCALE3, X=scale,Y=scale,Z=scale,AX=i*ROUND(xtimes)*360./nframes,AZ=i*ROUND(ztimes)*360./nframes 
    ERASE 
    PRINT,'Frame',i,', AX=',i*ROUND(xtimes)*360./nframes,', AZ=',i*ROUND(ztimes)*360./nframes
    IF KEYWORD_SET(nvecs) THEN BEGIN
      flow3,u,v,w,arrowsize=.02,nvecs=nvecs,len=len
    ENDIF ELSE BEGIN
      flow3,u,v,w,arrowsize=.02,sx=sx,sy=sy,sz=sz,len=len
    ENDELSE
    SCALE3,AX=i*720./nframes,AZ=i*360./nframes 
    XINTERANIMATE, FRAME=i, WINDOW=!D.WINDOW
ENDFOR 
WDELETE
XINTERANIMATE
END
pro anode,det,rdata

xp=0l
xm=0l
ym=0l
yp=0l


chan=1l
time=1l
data=lonarr(25000,4)
rdata=lonarr(25000,2)
close,3
xsize=286
ysize=276
det=lonarr(286,276)
xx=216
xd=20
yy=460
yd=20

for n=0,9 do begin
f=strtrim(string(n),2)
print,'zill open','/users/d17/rawdata.'+f
openr,3,'/users/d17/rawdata.'+f

print,'opened file','/users/d17/rawdata.'+f
neut=0
reader=0


while (eof(3) eq 0) do begin

   readf,3,chan,time
;   print,chan,time
   if(chan ne 0) then begin
   
     if(chan eq 11) then rdata(reader,0)=1
     if(chan eq 12) then rdata(reader,0)=2
     if(chan eq 21) then rdata(reader,0)=4
     if(chan eq 22) then rdata(reader,0)=8     
     rdata(reader,1)=time   
     reader=reader+1
   endif
end

for i=0,reader do begin

   if ((rdata(i,0)+rdata(i+1,0)+rdata(i+2,0)+rdata(i+3,0) eq 15) and $
       (max([rdata(i,1),rdata(i+1,1),rdata(i+2,1),rdata(i+3,1)])- $
       min([rdata(i,1),rdata(i+1,1),rdata(i+2,1),rdata(i+3,1)])) $
       lt 1000) then begin

      for k=0,3 do begin
        if(rdata(i+k,0) eq 1) then xp=rdata(i+k,1)
        if(rdata(i+k,0) eq 2) then xm=rdata(i+k,1)
        if(rdata(i+k,0) eq 4) then yp=rdata(i+k,1)
        if(rdata(i+k,0) eq 8) then ym=rdata(i+k,1)
      end
        data(neut,0)=xp
        data(neut,1)=xm
        data(neut,2)=yp
        data(neut,3)=ym
        neut=neut+1
        
        ;if(neut lt 21)then begin
        ;print,xp,xm,yp,ym,rdata(i,0),rdata(i+1,0),rdata(i+2,0),rdata(i+3,0)
        ;endif
       i=i+4

    endif

end


print,'xpos',moment(data(0:neut-1,0)-data(0:neut-1,1))
print,'ypos',moment(data(0:neut-1,2)-data(0:neut-1,3))


;window,1
;plot,data(*,0),data(*,1),psym=6
;window,2
;plot,data(*,2),data(*,3),psym=6
;window,3
;plot,data(*,0)+data(*,1),data(*,2)+data(*,3),psym=4

print,'good neuts= ',neut,' total cathodes read= ',reader
print,'cathodes/4 =',reader/4.

xsize=286
ysize=276
print,total(det)

xdel=270
ydel=550
xf=2
yf=4
posx=(data(*,0)-data(*,1)+xdel)/xf
posy=(data(*,2)-data(*,3)+ydel)/yf
help,posx,posy,det
flag=0

for i=0,neut-1 do begin

    if (posx(i) ge 0 and posx(i) lt xsize and posy(i) ge 0 and posy(i) lt ysize) then $
    det(posx(i),posy(i))= det(posx(i),posy(i))+1
endfor




close,3

endfor

;window,1
;plot,data(*,0),data(*,1),psym=6
;window,2
;plot,data(*,2),data(*,3),psym=6
;window,3
;plot,d


end
PRO anth2th,nu1,nu2,w10,x10,e10


f1=210 & f2=230 & b1=190 & b2=209
lam=5.97
saml=10.
beam=0.7
p0=199.105
d0=0.9904


xpixels=286
mmpp=1.04
dpr=180./!pi
pcen=136.94
pp0=142.3
;d0=0
points=((nu2-nu1+1))
print,points,nu1,nu2
san=fltarr(points)
dan=fltarr(points)
th=fltarr(points)
w10=fltarr(points)
e10=fltarr(points)
x10=fltarr(points)
water=fltarr(xpixels)
close,3


;  open water correction file created by awater.pro
openr,3,'water_LAMPascii'

for  i=0,xpixels-1 do begin
  readf,3,a,b,c
  water(i)=b
endfor


for k=0,points-1 do begin
  num=k+nu1

   
  data_read,num,w1,w2,y,m,q,t,s,d,dett,nx,time
  san(k)=s
  dan(k)=d
  foot=saml*sin(s/dpr)
  w10(k)=total(w1(f1:f2)/(time*water(f1:f2)))-total(w1(b1:b2)*(f2-f1+1)/((b2-b1+1)*time*water(b1:b2)))
  e10(k)= sqrt(total(w1(f1:f2))/(time^2.)+ total(w1(b1:b2))*(f2-f1+1)^2/((b2-b1+1)^2*time^2.))

;find peak
  
numersum=0.
denomsum=0.
for i=f1,f2 do begin
	numer=w1(i)*float(i)
	denom=w1(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
;print,'db stuff:', numersum,denomsum
pr=numersum/denomsum
;print,'fitted ref peak at: ',(pr)


th(k)=(d+dpr*atan((pcen-pr)*mmpp/dett))/2.-(d0+dpr*atan((pcen-p0)*mmpp/dett))/2.
;print,'calculated theta= ',th

;calculate q from the calculated theta
  x10(k)=4*!pi*sin(th(k)/dpr)/lam
endfor
print,th
help,th
print,'det dist=',dett
print,'time= ',time

end
PRO apol,n1,n2,dnf,df,rnf,rf,qq

dpr=180./!pi
peak=212
gap=11
lam=5.0
l=0
k=0
data_read,n1,datnf,monx,y,mm,q,th,san0,dan0,dett,nx
m1=long(1)
m2=long(1)

z=size(datnf)

df=fltarr(z(1),(n2-n1+1)/2)
dnf=fltarr(z(1),(n2-n1+1)/2)
san=fltarr((n2-n1+1)/2)
dan=fltarr((n2-n1+1)/2)
qq=fltarr((n2-n1+1)/2)
mon=fltarr((n2-n1+1)/2)
print,'size= ',((n2-n1+1)/2),z(1)

for i=0,(n2-n1),2 do begin
  
  print,'iiiiiiiiii',i,l,i+n1
  data_read,n1+i,datnf,m1,y,mm,q,th,s,d,dett,nx
  if (l eq 0) then monnf0=float(m1)
  print,'monitor nf',float(m1),monnf0,total(fix(datnf))
  dnf(*,l)=total(float(datnf),2)*float(m1)/monnf0
  
  data_read,n1+i+1,datf,m2,y,mm,q,th,s,d,dett,nx
  if (l eq 0) then monf0=float(m2)
  df(*,l)=total(float(datf),2)*float(m2)/monf0
  print,'monitor f',float(m2),monf0,total(fix(datf))
  print,'san dan mon',s,d,m2
  san(l)=s & dan(l)=d & mon(l)=m2
  qq(l)= 4.*!pi*sin(san(l)/dpr)/lam   
  l=l+1
endfor


fnf=total(dnf(peak-(gap-1)/2:peak+(gap-1)/2,*),1)
bnf=total(dnf(peak-(gap-1)/2-gap:peak-(gap-1)/2-1,*),1)
ff=total(df(peak-(gap-1)/2:peak+(gap-1)/2,*),1)
bf=total(df(peak-(gap-1)/2-gap:peak-(gap-1)/2-1,*),1)

print,peak-(gap-1)/2-gap,peak-(gap-1)/2-1,peak-(gap-1)/2,peak+(gap-1)/2

rnf=(fnf-bnf)*sin(san0/dpr)/((fnf(0)-bnf(0))*sin(san))
rf=(ff-bf)*sin(san0/dpr)/((ff(0)-bf(0))*sin(san))


end
pro arne2,first,last

XICUTE,"W1=RDRUN("+STRING(first)+")"
XICUTE,"W2=W1"
XICUTE,"PRINT,REFORM(N2(0,0,*),2)"
FOR i=first+1,last DO BEGIN
  XICUTE,"N=N2"
  XICUTE,"W1=RDRUN("+STRING(i)+")"
  XICUTE,"W2=W2+W1"
  XICUTE,"N2=N+N1"
  XICUTE,"PRINT,REFORM(N2(0,0,*),2)"
ENDFOR
XICUTE,"W3=sumscan(2)"
XICUTE,"W3=W3/("+STRING(last-first+1.)+")"
XICUTE,"E3=E3/("+STRING(last-first+1.)+")"
XICUTE,"N3=N3/("+STRING(last-first+1.)+")"
XICUTE,"W2=W2/("+STRING(last-first+1.)+")"
XICUTE,"E2=E2/("+STRING(last-first+1.)+")"
XICUTE,"N2=N2/("+STRING(last-first+1.)+")"
END
pro arne,first,last

XICUTE,"W1=RDRUN("+STRING(first)+")"
XICUTE,"W2=sumscan(1)"
XICUTE,"W3=W2"

FOR i=first+1,last DO BEGIN
  XICUTE,"W1=RDRUN("+STRING(i)+")"
  XICUTE,"W2=sumscan(1)"
  XICUTE,"W3=W3+W2"
ENDFOR
XICUTE,"W3=W3/("+STRING(last-first+1.)+")"
XICUTE,"E3=E3/("+STRING(last-first+1.)+")"
XICUTE,"N3=N3/("+STRING(last-first+1.)+")"
END
function arrows,u,v,n,length,nsteps=nsteps
on_error,2                      ;Return to caller if an error occurs
su=size(u)
nx=su[1]
ny=su[2]

IF NOT KEYWORD_SET(NSTEPS) THEN NSTEPS=10
lmax=sqrt(max(u^2+v^2))		;Max vector length
lth=1.*length/lmax/nsteps
xt=randomu(seed,n)		;Starting position
yt=randomu(seed,n)
x=fltarr(n,nsteps+3,2)
x[0,0,0]=xt
x[0,0,1]=yt
for i=1,nsteps-1 do begin
 xt[0]=(nx-1)*x[*,i-1,0]
 yt[0]=(ny-1)*x[*,i-1,1]
 ut=vel_mybi(u,xt,yt)
 vt=vel_mybi(v,xt,yt)
 x[0,i,0]=x[*,i-1,0]+ut*lth
 x[0,i,1]=x[*,i-1,1]+vt*lth
end
ARRHEAD,X
return,x<1.0>0.0
end
pro asansan,w1,x1

; program to set san=theta without using the dan coder

;calsan

; that should get it to within 0.02 degrees

dbdan=1.
danmax=1.5
danstep=0.1
danmin=-1.5
count=10
mmpp=1.0213
dpr=180./!pi
pcen=139.98
range=5


mv,'san',0
mv,'trs',5

  

; scan dan


mv,'san',0.
points=floor(((danmax-danmin)/danstep)+1)

dant=fltarr(points)
ppr=fltarr(points)

for i=0,points-1 do begin
  dan=danmin+float(i)*danstep
  mv,'dan',dan
  m=DIAL_MAD_READ('motors')
  det=m(15)
  print,'moved dan to ',m(16), (m(16)-dan)
  prc=pcen+(det*m(16))/(dpr*mmpp)
  
  print,'expected reflection pixel: ',prc

 
  co,count,'t n'
   d17data,data
   s=size(data)
   if s(0) gt 1 then data=total(data,2)

   d=max(data,pr)
  
   print,'db pixel maximum:',pr

   yy=gaussfit(findgen(s(1)),data,a)
   print,'gaussfit centre: ',a(1)
   ppr(i)=a(1)
    
   print,'db pixel fit:',ppr(i)
   dant(i)=m(16)
endfor



z=poly_fit(tan(dant/dpr),ppr,1,yout,yband,sigma,corr)

plot,tan(dant/dpr),ppr,psym=2,xtitle='tan(dan)',ytitle='pixel fit',$
yrange=[min(ppr)-1,max(ppr)+1]
xout=dant
oplot,tan(dant/dpr),yout

w1=yout-ppr
x1=tan(dant/dpr)
print,'calculated pcen:  ',z(0),mean(yband)
print,'calculated gradient:',z(1)
mmppc=(det/z(1))
print,'calculated mmpp based on this gradient:',mmppc
print,'present mmpp= ',mmpp
;print,'percentage difference: ', ((mmppc-mmpp)*100.)/mmpp

;print,'sigma',sigma

;print,'yerrors on fit',yband

end







pro ascii2dat,parameter

list=findfile('*_LAMPascii')
print,'These files will be copied to *.dat:'
print,list
for i=0, N_ELEMENTS(list)-1 Do BEGIN
  SPAWN,'cp '+list(i) +' '+STRMID(list(i),0,STRPOS(list(i),'_LAMP'))+'.dat'
ENDFOR
END
;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION average, w_in1, w_in2

; takes the weighted average of two workspaces
;						KHA, 25/2/97
;-------------------------------------------------------------------------------
;*******************************************************************************

	take_datp, dat1
	take_datp, dat2, /third

	e_in1=dat1.e
	e_in2=dat2.e

	z1=WHERE(e_in1 EQ 0.,nz1)
	IF (nz1 NE 0) THEN e_in1(z1)=1.
	z2=WHERE(e_in2 EQ 0.,nz2)
	IF (nz2 NE 0) THEN e_in2(z2)=1.

	w_out=(w_in1/e_in1^2+w_in2/e_in2^2)/(1./e_in1^2+1./e_in2^2)
	e_out=1./sqrt(1./e_in1^2+1./e_in2^2)

	IF (nz1 NE 0) THEN e_in1(z1)=0.
	IF (nz2 NE 0) THEN e_in2(z2)=0.

	IF (nz1 NE 0) THEN BEGIN
		w_out(z1)=w_in2(z1)
		e_out(z1)=e_in2(z1)
	ENDIF
	IF (nz2 NE 0) THEN BEGIN
		w_out(z2)=w_in1(z2)
		e_out(z2)=e_in1(z2)
	ENDIF

	datp=dat1

	mod_datp, datp, "e", e_out

	give_datp, datp

	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION background, sample = sam, empty = emp, cadmium = cdm, $
		 T = T, muR = muR, MS_file = MC_file0

; For D7 data only:
; Performs background subtraction of normalised data.
;
;ARGUMENTS:
; sample	: workspace containing sample runs (required)
; empty		: workspace containing empty runs (required)
; cadmium	: workspace contaoning of cadmium runs (optional)
; T		: sample transmission (default: T = 1)
; muR		: muR parameter required for Hewat-type angular transmission
;		  correction
; MS_file	: Output file from MSCATT for monte-carlo correction
;
; N.B. Specify either T for a normal background subtraction or muR for
;      an angular dependent background subtraction - NOT BOTH
;
;DIMENSIONS:
;  TOF:	w_in = w_out(nchannels,nspectra*nphases) - only deals with 1 run
;NOTOF:	w_in = w_out(nspectra,nphases,nruns)     - unless nruns = 1
;
;COMMAND SYNTAX:
; w4 = background(sample = w1,empty = w2[,cadmium = w3][,T = <T>]
;                     [,muR = <muR>][,MS_file = <filename>])
;
; (optional keywords/arguments shown in square brackets)
; 
;							JRS 21/5/02
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint = 0			;iprint = 1 -> show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start background:'

	IF(N_ELEMENTS(MC_file0) GT 0) THEN mscatt = 1 ELSE mscatt = 0
			

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces and setup output workspace

	IF (N_ELEMENTS(sam) EQ 0 OR N_ELEMENTS(emp) EQ 0) THEN BEGIN
		PRINT,'Background: ERROR - Both sample and background wkspace' $
		     +' numbers must be included'
		GOTO, finished
	ENDIF
	
	w_in1 = sam 
	take_datp, dat1
	w_in2 = emp
	take_datp, dat2, /third	
	IF(N_ELEMENTS(cdm) LT 2) THEN BEGIN
		cad = 0 
		w_in3 = 0.*w_in2
	ENDIF ELSE BEGIN
		cad  =  1
		w_in3  =  cdm
		take_datp, dat3, /fourth
	ENDELSE
	
; check dimensions of input arrays
	
	sw1 = SIZE(w_in1)
	sw2 = SIZE(w_in2)
	sw3 = SIZE(w_in3)
	e_in1 = dat1.e
	e_in2 = dat2.e
	IF(cad GT 0) THEN e_in3 = dat3.e ELSE e_in3 = 0.*e_in2
	se1 = SIZE(e_in1)
	se2 = SIZE(e_in2)
	se3 = SIZE(e_in3)	
	IF((TOTAL(sw1-sw2) NE 0) OR (TOTAL(sw1-sw3) NE 0) OR $
	   (TOTAL(sw2-sw3) NE 0) OR (TOTAL(se1-sw3) NE 0) OR $
	   (TOTAL(se2-sw3) NE 0) OR (TOTAL(se3-sw3) NE 0))THEN BEGIN
		PRINT,'Background: ERROR - Input arrays must be the same size'
		GOTO, finished
	ENDIF
	
	par1 = dat1.p
	par2 = dat2.p
	IF (cad GT 0) THEN par3 = dat3.p
	parv2 = dat2.pv
	IF (cad GT 0) THEN parv3 = dat3.pv
	TOF       = FIX(par1(8))
	nchannels = FIX(par1(6))
	nspectra  = FIX(par1(1))
	nphases   = FIX(par1(2))
	nruns     = FIX(par1(3))

; put all workspaces into 4d array
	
	w_in = FLTARR(3,nspectra,nphases,nruns) & e_in = w_in
	IF TOF EQ 1 THEN BEGIN
		w_in = FLTARR(3,nchannels,nspectra*nphases,nruns)
		e_in  =  w_in
	ENDIF
	w_in(0,*,*,*)  =  w_in1 & e_in(0,*,*,*)  =  e_in1
	w_in(1,*,*,*)  =  w_in2 & e_in(1,*,*,*)  =  e_in2
	w_in(2,*,*,*)  =  w_in3 & e_in(2,*,*,*)  =  e_in3
	
	IF (TOF EQ 0 AND nphases EQ 1) THEN BEGIN
		w_in = reform(w_in,3,nspectra,nphases,nruns)
		e_in = reform(e_in,3,nspectra,nphases,nruns)
	ENDIF

	IF (nruns EQ 1) OR (N_ELEMENTS(dat1.z) LE 1) THEN $
		x_in = dat1.x ELSE x_in = dat1.z
	y_in = dat1.y	

	IF (iprint GT 0) THEN BEGIN
		PRINT,'TOF       = ',TOF
		PRINT,'Nchannels = ',nchannels
		PRINT,'Nspectra  = ',nspectra
		PRINT,'Nphases   = ',nphases
		PRINT,'Nruns     = ',nruns
	ENDIF
	
	IF (iprint GT 0)THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
; Perform Backgound Subtraction

	IF N_ELEMENTS(T) GT 0 AND (N_ELEMENTS(muR) GT 0 OR mscatt EQ 1) THEN BEGIN 
		PRINT,'Background: ERROR - specify only one of T, muR or'
		PRINT,'		   an MSCATT correction file.'
		GOTO, finished
	ENDIF
	IF N_ELEMENTS(muR) GT 0 AND (N_ELEMENTS(T) GT 0 OR mscatt EQ 1) THEN BEGIN 
		PRINT,'Background: ERROR - specify only one of T, muR or'
		PRINT,'		   an MSCATT correction file.'
		GOTO, finished
	ENDIF
	IF N_ELEMENTS(muR) GT 0 THEN BEGIN 
		correct  =  1
		PRINT,'Background: muR = ',muR,' (Hewat)'
	ENDIF
	IF N_ELEMENTS(T) EQ 0 AND N_ELEMENTS(muR) EQ 0 AND mscatt EQ 0 THEN BEGIN
		muR = 1
		correct  =  0
		PRINT,'Background: T = 1 (simple)'
	ENDIF
	IF N_ELEMENTS(T) GT 0 THEN BEGIN 
		muR = T
		correct  =  0
		PRINT,'Background: T = ',muR,' (simple)'
	ENDIF
	IF (mscatt EQ 1) THEN correct  =  2	

        tarr = 0.*w_in1
	IF (TOF EQ 0) AND(nphases EQ 1) THEN tarr = REFORM(tarr, nspectra, 1, nruns)

	CASE correct OF
	0:BEGIN
		muR = FLOAT(muR)
		tarr = tarr+muR
	  END

	1:BEGIN
		muR = FLOAT(muR)
		a = 1.7133			; a1
		b = -0.0368			; b1
		c = -0.0927			; a2
		d = -0.375			; b2
		IF (TOF EQ 0) THEN x_hew = x_in*!pi/180. ELSE x_hew = y_in*!pi/180.
		FOR i = 0,(nspectra*(TOF*nphases + 1 - TOF) -1) DO BEGIN
			IF TOF EQ 1 THEN $
			tarr(*,i,*) = exp(-(a+b*sin(x_hew(i)/2)^2)*muR- $
				           (c+d*sin(x_hew(i)/2)^2)*muR^2) $
			ELSE $
			tarr(i,*,*) = exp(-(a+b*sin(x_hew(i)/2)^2)*muR- $
				           (c+d*sin(x_hew(i)/2)^2)*muR^2)
		ENDFOR
	END

; TOF MSCATT option is not yet implemented

2:	BEGIN	
		nMC = 1
		IF N_ELEMENTS(MC_file0) EQ 1 THEN BEGIN
			corr_MC = 1
			MC_file = STRARR(nMC)
			MC_file(0) = MC_file0
			PRINT,'Background: correction with mscatt file:'
			PRINT,'          ',MC_file(0)
		ENDIF ELSE BEGIN
			corr_MC = 1
			nMC = N_ELEMENTS(MC_file0)
			MC_file = MC_file0
			PRINT,'Background: correction with mscatt files:'
			FOR i = 0,nMC-1 DO PRINT,'          ',MC_file(i)
		ENDELSE
		tarr = FLTARR(nspectra,nphases,nruns)
		IF nphases EQ 2 THEN MC = FLTARR(4,32) ELSE MC = FLTARR(8,32)
		FOR irun = 0,nMC-1 DO BEGIN
			IF iprint GT 0 THEN PRINT,'Opening MC file: ',MC_file(irun)
			OPENR, 1, MC_file(irun), ERROR = err
			IF (err NE 0) THEN BEGIN
				PRINT, !ERR_STRING
				GOTO, finished
			ENDIF
			found = -1
			line = ''
			IF(nphases EQ 6) THEN look = 'R(X)nf' ELSE look = 'Rnf'
			WHILE (found EQ -1) DO BEGIN
				READF, 1, line
				found = STRPOS(line,look)
			ENDWHILE
			READF, 1, MC
			CLOSE, 1
			FOR i = 0,nphases-1 DO tarr(*,i,irun) = 1./MC(i+2,*)
		ENDFOR
		IF nruns GT 1 THEN BEGIN
			IF nMC EQ 1 THEN $
			FOR irun = 1,nruns-1 DO tarr[*,*,irun] = tarr[*,*,0] $
			ELSE IF (nruns GT 2 AND nMC EQ 2) THEN BEGIN	
				FOR irun = nruns-1,1,-1 DO $
				MC0[*,*,irun] = tarr[*,*,0] + (tarr[*,*,1] - $
				tarr[*,*,0])*FLOAT(irun)/FLOAT(nruns-1)
			ENDIF
		ENDIF
		IF iprint GT 0 THEN BEGIN
			PRINT,'MS_Array  =  :'
			PRINT,1./tarr
		ENDIF
	END
	ENDCASE

	w_out  =  (1./tarr)*(w_in[0,*,*,*] - w_in[2,*,*,*]) - $
	                    (w_in[1,*,*,*] - w_in[2,*,*,*])
	e_out  =  SQRT((e_in[0,*,*,*]/tarr)^2 + $
	                e_in[1,*,*,*]^2+((1. - 1./tarr)*e_in[2,*,*,*])^2)

        IF iprint GT 0 THEN PRINT,'End of background subtraction section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	IF (TOF EQ 0) AND (nphases EQ 1) THEN BEGIN
		w_out0 = FLTARR(nspectra,nruns)	& e_out0 = w_out0
		w_out0[*,*] = w_out[*,0,*]
		e_out0[*,*] = e_out[*,0,*]
	ENDIF ELSE BEGIN
		w_out0 = w_out
		e_out0 = e_out
	ENDELSE
	
	dat1.e = e_out0

	s = dat2.other_tit & i = STRPOS(s,' ') & n = RSTRPOS(s,' ')
	bgnumor = STRMID(s,i+1,n-i-1)
	IF nruns NE 1 THEN $
	bgnumor = '#'+STRTRIM(STRING(LONG(parv2[0,0])),2)+':' $
	             +STRTRIM(STRING(LONG(parv2[0,nruns-1])),2)
        IF (nruns EQ 1) AND (STRPOS(bgnumor,'>') EQ -1) THEN $
	bgnumor = 'emp:#'+STRTRIM(STRING(LONG(par2[0])),2)	
	IF cad GT 0 THEN BEGIN
		s = dat3.other_tit & i = STRPOS(s,' ') & n = RSTRPOS(s,' ')
		cdnumor = STRMID(s,i+1,n-i-1)
        	IF (nruns EQ 1 AND STRPOS(cdnumor,'>') EQ -1) THEN $
		cdnumor = '#'+STRTRIM(STRING(LONG(par3[0])),2)
		IF nruns NE 1 THEN $
		cdnumor = 'cad:#'+STRTRIM(STRING(LONG(parv3[0,0])),2)+':' $
		                 +STRTRIM(STRING(LONG(parv3[0,nruns-1])),2)
	ENDIF ELSE BEGIN
		cdnumor = 'no cd'
	ENDELSE
	
	IF mscatt EQ 0 THEN BEGIN
		muRs = STRTRIM(STRING(muR),2)
muR0:		n = STRLEN(muRs)	& i = RSTRPOS(muRs,'0')
		IF i EQ n-1 THEN BEGIN
			muRs = STRMID(muRs,0,n-1)
			GOTO, muR0
		ENDIF
		mss = ''
		IF correct EQ 1 THEN hew  =  'muR=' ELSE hew  =  'T='
		muRs  =  hew + muRs
	ENDIF ELSE BEGIN
		muRs = ''
	 	mss = 'MS:' + MC_file0
	ENDELSE
		params = muRs+mss

	dat1.other_tit = dat1.other_tit+' -bg('+bgnumor+','+cdnumor+','+params+')'

finished:

	IF iprint GT 0 THEN PRINT,'End background:'
	give_datp, dat1
	RETURN, w_out0

	END
FUNCTION bacon,w,wmax=wmax,wmin=wmin,xmin=xmin,xmax=xmax,xrange=xrange,wrange=wrange,$
             eps=eps,noprint=noprint,printer=printer,error=error,contour=contour,$
             noscreen=noscreen,par=par,nofit=nofit,color=color,nobg=nobg

;+
; NAME:
;	BACON
;
; PURPOSE:
;	Data output (plot, print, fit) for Prof. G. Bacon.
;
; CATEGORY:
;	Special user
;
; CALLING SEQUENCE:
;	BACON, W
;
; INPUTS:
;	W:	Workspace.
;
; OPTIONAL INPUTS:
;	none.
;	
; KEYWORD PARAMETERS: See also psplot!
;	NOPLOT :	no plot.
;	WR     :	workspace value range, e.g., [min(w),max(w)]
;       PAR    : 	parameter indices.
;
; OUTPUTS:
;	hardcopy of plot, fit and data
;
; OPTIONAL OUTPUTS:
;	none
;
; COMMON BLOCKS:
;	none
;
; SIDE EFFECTS:
;	none
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
;	none.
;
; EXAMPLE:
;
;  W6 = RDRUN(9135)
;  W7 = W6 & BACON, W7, /NOP, WR = [17, 24],PAR = [17, 18]
;
; MODIFICATION HISTORY:
; 	Written by:	Thomas Hansen, June 1997.
;	May,  1998	Documentation
;	July, 1998	Anti-bug and slight changes
;	April,2001	Trying to make it work again ....
;-

take_datp,datp
	

mon=TOTAL(datp.n(0,0,*))/N_ELEMENTS(datp.n(0,0,*))
ner=1/(datp.n(0,0,*)/ SQRT(datp.n(0,0,*) + 1.))^2
FOR i=0,N_ELEMENTS(datp.n(0,0,*))-1 DO BEGIN
 	w(*,i)   =      w(*,i)/datp.n(0,0,i)*mon
	;help,datp.e,datp.n,w,mon,ner
	datp.e(*,i)   = datp.e(*,i)/datp.n(0,0,i)*mon + w(*,i)*ner(i)
	datp.n(0,0,i)= mon
ENDFOR

IF N_ELEMENTS(w(0,*)) GT datp.p(1)  THEN BEGIN
  ww=fltarr(N_ELEMENTS(w(*,0)),datp.p(1))
  xx=fltarr(N_ELEMENTS(w(*,0)),datp.p(1))
  ee=fltarr(N_ELEMENTS(w(*,0)),datp.p(1))
  nn=fltarr(datp.p(1))
  yy=fltarr(datp.p(1))
  pv=fltarr(N_ELEMENTS(datp.pv(*,0)),datp.p(1))
  FOR i=0,datp.p(1)-1 DO BEGIN
    ww(*,i)=TOTAL     (w  (*,WHERE(datp.pv(2,*) EQ i+1,count)),2)
    ee(*,i)=TOTAL(datp.e  (*,WHERE(datp.pv(2,*) EQ i+1,count)),2)/SQRT(count)
    nn(  i)=TOTAL(datp.n    (WHERE(datp.pv(2,*) EQ i+1,count)))
    index=WHERE(datp.pv(2,*) EQ i+1,count)
    yy(  i)=      datp.y  (index(0))
    xx(*,i)=      datp.x(*,index(0))
    pv(*,i)=      datp.pv(*,index(0))
    pv(5,i)= TOTAL(datp.pv(5,(WHERE(datp.pv(2,*) EQ i+1,count))))   
  ENDFOR

  w=ww
  mod_datp,datp,'e',ee  	
  mod_datp,datp,'x',xx  	
  mod_datp,datp,'y',yy  	
  mod_datp,datp,'n',nn  	
  mod_datp,datp,'pv',pv  
ENDIF	

IF NOT KEYWORD_SET(xmax)   THEN xmax=max(datp.x)
IF NOT KEYWORD_SET(xmin)   THEN xmin=min(datp.x)
IF NOT KEYWORD_SET(xrange) THEN xrange=[xmin,xmax]
index=WHERE(datp.x(*,0) GE xrange(0) AND datp.x(*,0) LE xrange(1),count)
w=w(index,*)
mod_datp,datp,'x',datp.x(index,*)
mod_datp,datp,'e',datp.e(index,*)
IF NOT KEYWORD_SET(wmax)   THEN wmax=max(w)
IF NOT KEYWORD_SET(wmin)   THEN wmin=0.
IF NOT KEYWORD_SET(wmin)   THEN IF  KEYWORD_SET(nobg) THEN wmin=min(w)
IF NOT KEYWORD_SET(wrange) THEN wrange=[wmin,wmax]

SET_PLOT,'ps'
filename=strcompress(string(round(datp.p(29))),/remove_all)+'_multi.ps'
IF KEYWORD_SET(eps) THEN eps=1 ELSE eps=0
DEVICE,FILENAME=filename,$
  /LANDSCAPE,XSIZE=25,YSIZE=15,YOFFSET=25,XOFFSET=5;,$
  ;BITS_PER_PIXEL=256;,/COLOR,encapsulated=eps
IF N_ELEMENTS(w(0,*)) GT 1 THEN BEGIN
    IF NOT KEYWORD_SET(color) THEN BEGIN
      SURFACE,w,datp.x,datp.y        ,$
          zRANGE  = wrange, $
          xRANGE  = xrange, $
          TITLE   =datp.w_tit+' '+datp.other_tit ,CHARSIZE=0.7
    ENDIF ELSE BEGIN
      SHADE_SURF,w,datp.x,datp.y        ,$
          zRANGE  = wrange, $
          xRANGE  = xrange, $
          TITLE   =datp.w_tit +' '+datp.other_tit,CHARSIZE=0.7 
   ENDELSE
ENDIF 
DEVICE,/CLOSE
IF NOT KEYWORD_SET(color) THEN BEGIN
  IF NOT KEYWORD_SET(printer) THEN line='$lp '+filename ELSE line='$lp -d'+printer+' '+filename
ENDIF ELSE line='$lp -d'+color+' '+filename
if NOT keyword_set(noprint) THEN  BEGIN
  PRINT,line
  XICUTE,line 
ENDIF


SET_PLOT,'X'
f=newfit(w,xx=datp.x,np=2,nbg=3,int=int,width=width,pos=pos,bg=bg,/pv,/print,initialit=10,iterations=5,/plot)


SET_PLOT,'ps'
!P.LINESTYLE=0
!p.thick=1
!p.psym=0
!p.symsize=0.6
filename=strcompress(string(round(datp.p(29))),/remove_all)+'_single.ps'
DEVICE,FILENAME=filename,$
  /LANDSCAPE,XSIZE=25,YSIZE=15,YOFFSET=25,XOFFSET=5;,$
  ;BITS_PER_PIXEL=256;,/COLOR,encapsulated=eps
FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
  subtitle=datp.other_tit+'-'+strcompress(i,/remove_all)
  IF KEYWORD_SET(par) THEN FOR j=0,N_ELEMENTS(par)-1 DO BEGIN
    subtitle=subtitle+', '+strmid(datp.par_txt(par(j)),0,4)+strmid(strcompress(string(datp.pv(par(j),i))),0,6)
  ENDFOR
    IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN BEGIN
       PLOT,datp.x(*,i),w(*,i),$
         yRANGE     = wrange, $
         xRANGE     = xrange, $
         TITLE      =datp.w_tit,$
         SUBTITLE   =subtitle,$
         xTITLE     =datp.x_tit,$
         yTITLE     =datp.z_tit,symsize=0.6,psym=7
   ENDIF ELSE BEGIN
       PLOT,datp.x,w(*,i),$
       yRANGE     = wrange, $
       xRANGE     = xrange, $
       TITLE      =datp.w_tit,$
       SUBTITLE   =subtitle,$
       xTITLE     =datp.x_tit,$
       yTITLE     =datp.z_tit,symsize=0.6,psym=7
   ENDELSE
   IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN BEGIN
       PLOT,datp.x(*,i),f(*,i),$
         yRANGE     = wrange, $
         xRANGE     = xrange, $
         TITLE      =datp.w_tit,$
         SUBTITLE   =subtitle,$
         xTITLE     =datp.x_tit,$
         yTITLE     =datp.z_tit,symsize=0.6,/noerase
   ENDIF ELSE BEGIN
       PLOT,datp.x,f(*,i),$
       yRANGE     = wrange, $
       xRANGE     = xrange, $
       TITLE      =datp.w_tit,$
       SUBTITLE   =subtitle,$
       xTITLE     =datp.x_tit,$
       yTITLE     =datp.z_tit,symsize=0.6,/noerase
   ENDELSE
  IF KEYWORD_SET(error) THEN OPLOTERR,datp.x(*,i<(N_ELEMENTS(datp.x(0,*))-1)),w(*,i),datp.e(*,i),3 
ENDFOR
DEVICE,/CLOSE
IF NOT KEYWORD_SET(printer) THEN line='$lp '+filename ELSE line='$lp -d'+printer+' '+filename
if NOT keyword_set(noprint) THEN  BEGIN
  PRINT,line
  XICUTE,line 
ENDIF

SET_PLOT,'X'
IF NOT KEYWORD_SET(noscreen) THEN BEGIN
  IF N_ELEMENTS(w(0,*)) GT 1 THEN BEGIN
    SURFACE,w,datp.x,datp.y,$
          zRANGE  = wrange, $
          xRANGE  = xrange, $
          TITLE   =datp.other_tit
  ENDIF 
  FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
    subtitle=datp.other_tit+'-'+strcompress(i,/remove_all)
    IF KEYWORD_SET(par) THEN FOR j=0,N_ELEMENTS(par)-1 DO BEGIN
      subtitle=subtitle+', '+strmid(datp.par_txt(par(j)),0,4)+strmid(strcompress(string(datp.pv(par(j),i))),0,6)
    ENDFOR
    IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN BEGIN
       PLOT,datp.x(*,i),w(*,i),$
         yRANGE     = wrange, $
         xRANGE     = xrange, $
         TITLE      =datp.w_tit,$
         SUBTITLE   =subtitle,$
         xTITLE     =datp.x_tit,$
         yTITLE     =datp.z_tit,symsize=0.6,psym=7
   ENDIF ELSE BEGIN
       PLOT,datp.x,w(*,i),$
       yRANGE     = wrange, $
       xRANGE     = xrange, $
       TITLE      =datp.w_tit,$
       SUBTITLE   =subtitle,$
       xTITLE     =datp.x_tit,$
       yTITLE     =datp.z_tit,symsize=0.6,psym=7
   ENDELSE
   IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN BEGIN
       PLOT,datp.x(*,i),f(*,i),$
         yRANGE     = wrange, $
         xRANGE     = xrange, $
         TITLE      =datp.w_tit,$
         SUBTITLE   =subtitle,$
         xTITLE     =datp.x_tit,$
         yTITLE     =datp.z_tit,symsize=0.6,/noerase
   ENDIF ELSE BEGIN
       PLOT,datp.x,f(*,i),$
       yRANGE     = wrange, $
       xRANGE     = xrange, $
       TITLE      =datp.w_tit,$
       SUBTITLE   =subtitle,$
       xTITLE     =datp.x_tit,$
       yTITLE     =datp.z_tit,symsize=0.6,/noerase
   ENDELSE
   IF KEYWORD_SET(error) THEN OPLOTERR,datp.x(*,i<(N_ELEMENTS(datp.x(0,*))-1)),w(*,i),datp.e(*,i),3 
  ENDFOR
ENDIF


filename=strcompress(string(round(datp.p(29))),/remove_all)+'.fit'
OPENW,fit,filename,/get_lun
PRINTF,fit,datp.w_tit
PRINT,datp.w_tit
printf,fit,datp.other_tit
print,datp.other_tit
help,datp.pv,datp.n
Printf,fit,'Time/step (sec):',datp.pv(5,0),'     Monitor/step (counts):',datp.n(0)
Print,'Time/step (sec):',datp.pv(5,0),'     Monitor/step (counts):',datp.n(0)
Printf,fit
Printf,fit,'Pos1/deg   Area1   FWHM1   Pos2/deg   Area2   FWHM2    A1/A2   BGmin   BGmax'
Print,'Pos1/deg Area1(cnts/deg) FWHM1 Pos2/deg Area2(cnts/deg) FWHM2  A1/A2  BG'
FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
    FWHM1=width(i,0);SQRT(2.*ALOG(2.)*a(2,0,i))
    FWHM2=width(i,1);SQRT(2.*ALOG(2.)*a(2,1,i))
    Area1=int(i,0);a(0,0,i)*FWHM1
    Area2=int(i,1);a(0,1,i)*FWHM2
    IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN BEGIN
      printf,fit,format='(f8.3,f10.1,f7.3,f8.3,f10.1,f7.3,f10.4,f9.1,f9.1)',$
	pos(i,0),Area1,FWHM1,pos(i,1),Area2,FWHM2,Area1/Area2,$
        MIN(bg(i,0)+bg(i,1)*datp.x(*,i)+bg(i,2)*datp.x(*,i)^2),$
        MAX(bg(i,0)+bg(i,1)*datp.x(*,i)+bg(i,2)*datp.x(*,i)^2)
      print,format='(f7.3,f9.1,f6.3,f7.3,f9.1,f6.3,f6.2,f9.1)',pos(i,0),Area1,$
	FWHM1,pos(i,1),Area2,FWHM2,Area1/Area2,$
        MIN(bg(i,0)+bg(i,1)*datp.x(*)+bg(i,2)*datp.x(*)^2),$
        MAX(bg(i,0)+bg(i,1)*datp.x(*)+bg(i,2)*datp.x(*)^2)
    ENDIF ELSE BEGIN
      printf,fit,format='(f8.3,f10.1,f7.3,f8.3,f10.1,f7.3,f10.4,f9.1,f9.1)',$
	pos(i,0),Area1,FWHM1,pos(i,1),Area2,FWHM2,Area1/Area2,$
        MIN(bg(i,0)+bg(i,1)*datp.x(*)+bg(i,2)*datp.x(*)^2),$
        MAX(bg(i,0)+bg(i,1)*datp.x(*)+bg(i,2)*datp.x(*)^2)
      print,format='(f7.3,f9.1,f6.3,f7.3,f9.1,f6.3,f6.2,f9.1)',pos(i,0),Area1,$
	FWHM1,pos(i,1),Area2,FWHM2,Area1/Area2,$
        MIN(bg(i,0)+bg(i,1)*datp.x(*)+bg(i,2)*datp.x(*)^2),$
        MAX(bg(i,0)+bg(i,1)*datp.x(*)+bg(i,2)*datp.x(*)^2)
    ENDELSE 

ENDFOR
flush,fit
close,fit
free_lun,fit

IF NOT KEYWORD_SET(printer) THEN line='$lp '+filename ELSE line='$lp -d'+printer+' '+filename
if NOT keyword_set(noprint) THEN  BEGIN
  PRINT,line
  XICUTE,line 
ENDIF

FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
  filename=strcompress(string(round(datp.p(29))),/remove_all)+'_'+strcompress(string(i),/remove_all)+'.dat'
  OPENW,dat,filename,/get_lun
  subtitle=datp.other_tit+'-'+strcompress(i,/remove_all)
  IF KEYWORD_SET(par) THEN FOR j=0,N_ELEMENTS(par)-1 DO BEGIN
    subtitle=subtitle+', '+strmid(datp.par_txt(par(j)),0,4)+strmid(strcompress(string(datp.pv(par(j),i))),0,6)
  ENDFOR
  FOR j=0,N_ELEMENTS(w(*,0))-1 DO BEGIN
    IF (j MOD 60) EQ 0 THEN BEGIN ; lj1_d20
      PRINTF,dat,datp.w_tit
      PRINTF,dat,subtitle
      Printf,dat,'Time:',datp.pv(5,i)*1e6,' sec     Monitor:',datp.n(i)
      Printf,dat
      Printf,dat,'      2*Theta      Counts       Error'  
    ENDIF 
    
    IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN BEGIN
      PRINTF,dat,datp.x(j,i),w(j,i),datp.e(j,i)
    ENDIF ELSE BEGIN
      PRINTF,dat,datp.x(j),w(j,i),datp.e(j,i)
    ENDELSE 
  ENDFOR
  flush,dat
  close,dat
  free_lun,dat
  PRINT,filename,' created'
  if NOT keyword_set(noprint) THEN  BEGIN
	PRINT,'Printer cooldown loop'
  	FOR j=0.,2000000. DO jj=sin(j)
  	IF NOT KEYWORD_SET(printer) THEN line='$lp '+filename ELSE line='$lp -d'+printer+' '+filename
  	PRINT,line
  	XICUTE,line 
  ENDIF
ENDFOR

give_datp,datp
RETURN,f
END
function bad,n1,stop=n2,sensitivity=sens,zero=zerostat,low=lowstat,high=highstat,m=mstat,w=wstat

common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
, cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
, shf_in6 , cal_d20 , ang_d20 , inf_d20 , bad_d20 ,flag_d20, wav_d20, psd_d20  $
, inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5  , inf_in6
			   
zerostat=fltarr(1600)
lowstat=fltarr(1600)
highstat=fltarr(1600)
mstat=fltarr(1600)
wstat=fltarr(1600)
IF NOT KEYWORD_SET(sens) THEN sens=3
NbOfZeroCounters=0
lambda  =P_LAMBDA()
badname =strcompress(n1,/re)+'.bad'
print,"File containing bad cells : ",badname," "
OPENW,bad,badname,/get_lun
n0=n1
IF NOT KEYWORD_SET(n2) THEN n2=999999
datp=1
counter=0
hole=1
for numor = long(n1), LONG(n2) do begin
  flag,/soft,old=flag_restore,/noprint,/eff,/nobad,/noang,/noint,/nowav,/flp,/nonor,/nocor
  w=rdrun(numor,datp=datp)
  flag,/soft,new=flag_restore,/noprint
  counter=counter + N_ELEMENTS(w(0,*))
		nodata=0
  WHILE n_elements(w) le 1 DO BEGIN 
			IF nodata EQ 0 THEN nomore=numor
		 IF NOT KEYWORD_SET(wait) THEN BEGIN
			  nodata=nodata+1
			  print,'No data for ',numor
			  numor=numor+1
			ENDIF ELSE BEGIN
			 IF nodata EQ 0 THEN BEGIN
			   print,'Waiting for ',numor,' since ',systime()
			   numor=nomore
      WAIT,wait*60
      FLUSH,bad
      mod_datp,datp,'x',indgen(1600)
      mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
      mod_datp,datp,'p',[n1,numor-1]
      mod_datp,datp,'e',error
      mod_datp,datp,'n',0
      mod_datp,datp,'y',y
      mod_datp,datp,'w_tit','Deviation from expected counting rate'
      mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n2)
      mod_datp,datp,'y_tit','factor'
      mod_datp,datp,'x_tit','cell'
      give_datp,datp
				ENDIF
				nodata=1
			ENDELSE
   flag,/soft,old=flag_restore,/noprint,/eff,/nobad,/noang,/noint,/nowav,/flp,/nonor,/nocor
   w=rdrun(numor,datp=datp)
   flag,/soft,new=flag_restore,/noprint
   counter=counter + N_ELEMENTS(w(0,*))
			IF n_elements(w) le 1 AND nodata GE hole THEN BEGIN
			 numor=nomore
    print,'No more numors from ',numor
    CLOSE,bad
				FREE_LUN,bad
				PRINT,badname ,' written'
				flag,new=flag_restore,/noprint
    mod_datp,datp,'x',indgen(1600)
    mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
    mod_datp,datp,'p',[n1,numor-1]
    mod_datp,datp,'e',error
    mod_datp,datp,'n',0
    mod_datp,datp,'y',y
    mod_datp,datp,'w_tit','Deviation from expected counting rate'
    mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n2)
    mod_datp,datp,'y_tit','factor'
    mod_datp,datp,'x_tit','cell'
    give_datp,datp
		  RETURN,deviation
   ENDIF
  ENDWHILE
  j=WHERE(cal_d20)
  FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN w(j,i)=w(j,i)/cal_d20(j) 
  ENDFOR
		IF KEYWORD_SET(wait) AND nodata EQ 1 THEN BEGIN
		ENDIF
		index=WHERE(datp.n EQ 1.95646080e+07,counts)
  IF counts GE 1 THEN datp.n(index) =0

  WOUT=w
  EE=datp.e
  
  zerocounters= WHERE(TOTAL(REFORM(wout,N_ELEMENTS(wout(*,0)),N_ELEMENTS(wout(0,*))),2) LE 0)
  tmp=N_ELEMENTS(ZeroCounters)
		NbOfZeroCounters=tmp
  print,''
  print,'Numor ',numor
  printf,bad,''
  printf,bad,'Numor ',numor
  IF NbOfZeroCounters GE 1 THEN PRINT,' Zero ', STRMID(ZeroCounters(0:13<N_ELEMENTS(ZeroCounters)-1),8,4)
  IF NbOfZeroCounters GE 1 THEN PRINTf,bad,' Zero ', STRMID(ZeroCounters(0:13<N_ELEMENTS(ZeroCounters)-1),8,4)
  tmp=0*ZeroCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN FOR i=0,NbOfZeroCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ ZeroCounters(i) THEN tmp(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN BEGIN
    ind=where(tmp,count)
    IF count GE 1 THEN PRINT,' excl.', STRMID(ZeroCounters(ind),8,4)
    IF count GE 1 THEN PRINTf,bad,' excl.', STRMID(ZeroCounters(ind),8,4)
  ENDIF
  IF NbOfZeroCounters GE 1 THEN zerostat(ZeroCounters)=zerostat(ZeroCounters)+1
  tmp=TOTAL(REFORM(w,N_ELEMENTS(w(*,0)),N_ELEMENTS(w(0,*))),2)
  ind=findgen(N_ELEMENTS(tmp)-4)+2

  smoothed=tmp
  smoothed(ind)=2./3.*(tmp(ind-1)+tmp(ind-1))-(tmp(ind-2)+tmp(ind-2))/6.>0

  sigm=TOTAL(REFORM(EE,N_ELEMENTS(EE(*,0)),N_ELEMENTS(EE(0,*))),2)/SQRT(N_ELEMENTS(EE(0,*)))
  tmp1=tmp-sens*sigm
  tmp2=tmp+sens*sigm

  MCounters=2+WHERE(tmp2(ind) LT (tmp1(ind-2)+tmp1(ind+2))/2./1.00 AND tmp1(ind-1)/1.00 GT (3.*tmp2(ind-2)+tmp2(ind+2))/4. AND tmp1(ind+1)/1.00 GT (tmp2(ind-2)+3.*tmp2(ind+2))/4.,NbOfMCounters)
  IF NbOfMCounters GE 2 THEN MCounters=MCounters(SORT((tmp(MCounters+2)+tmp(MCounters+1)+tmp(MCounters)+tmp(MCounters-1)+tmp(MCounters-2))/((tmp(MCounters+1)+tmp(MCounters-1))/2.-tmp(MCounters))))
  IF NbOfMCounters GE 1 THEN PRINT,' "M"  ', STRMID(MCounters(0:13<N_ELEMENTS(MCounters)-1),8,4)
  IF NbOfMCounters GE 1 THEN PRINTf,bad,' "M"  ', STRMID(MCounters(0:13<N_ELEMENTS(MCounters)-1),8,4)
  tmp0=0*MCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN FOR i=0,NbOfMCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ MCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
    IF count GE 1 THEN PRINT,' excl.', STRMID(MCounters(ind0),8,4)
    IF count GE 1 THEN PRINTf,bad,' excl.', STRMID(MCounters(ind0),8,4)
  ENDIF
  IF NbOfMCounters GE 1 THEN Mstat(MCounters)=Mstat(MCounters)+1

  WCounters=2+WHERE(tmp1(ind)/1.00 GT (tmp2(ind-2)+tmp2(ind+2))/2. AND tmp2(ind-1) LT (3.*tmp1(ind-2)+tmp1(ind+2))/4./1.00 AND tmp2(ind+1) LT (tmp1(ind-2)+3.*tmp1(ind+2))/4./1.00,NbOfWCounters)
  IF NbOfWCounters GE 2 THEN WCounters=WCounters(SORT((tmp(WCounters+2)+tmp(WCounters+1)+tmp(WCounters)+tmp(WCounters-1)+tmp(WCounters-2))/(tmp(WCounters)-(tmp(WCounters+1)+tmp(WCounters-1))/2.)))
  IF NbOfWCounters GE 1 THEN PRINT,' "W"  ', STRMID(WCounters(0:13<N_ELEMENTS(WCounters)-1),8,4)
  IF NbOfWCounters GE 1 THEN PRINTf,bad,' "W"  ', STRMID(WCounters(0:13<N_ELEMENTS(WCounters)-1),8,4)
  tmp0=0*WCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN FOR i=0,NbOfWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ WCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
    IF count GE 1 THEN PRINT,' excl.', STRMID(WCounters(ind0),8,4)
    IF count GE 1 THEN PRINTf,bad,' excl.', STRMID(WCounters(ind0),8,4)
  ENDIF
  IF NbOfWCounters GE 1 THEN Wstat(WCounters)=Wstat(WCounters)+1

  ind=findgen(N_ELEMENTS(tmp)-4)+2

  LowCounters =2+WHERE(tmp(ind) LT (smoothed(ind)-4.*SQRT(smoothed(ind)>0))-ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.-ABS(tmp(ind-1)-tmp(ind+1))/2. AND tmp(ind) GT 0,NbOfLowCounters)
  IF NbOfLowCounters GE 2 THEN LowCounters=LowCounters(SORT(smoothed(LowCounters)/(smoothed(LowCounters)-tmp(LowCounters))))
  IF NbOfLowCounters GE 1 THEN PRINT,' Low  ', STRMID(LowCounters(0:13<N_ELEMENTS(LowCounters)-1),8,4)
  IF NbOfLowCounters GE 1 THEN PRINTf,bad,' Low  ', STRMID(LowCounters(0:13<N_ELEMENTS(LowCounters)-1),8,4)
  tmp0=0*LoWCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN FOR i=0,NbOfLoWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ LoWCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
    IF count GE 1 THEN PRINT,' excl.', STRMID(LoWCounters(ind0),8,4)
    IF count GE 1 THEN PRINTf,bad,' excl.', STRMID(LoWCounters(ind0),8,4)
  ENDIF
  IF NbOfLoWCounters GE 1 THEN LoWstat(LoWCounters)=LoWstat(LoWCounters)+1

  HighCounters =2+WHERE(tmp(ind) GT (smoothed(ind)+4.*SQRT(smoothed(ind)>0))+ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.+ABS(tmp(ind-1)-tmp(ind+1))/2.,NbOfHighCounters)
  IF NbOfHighCounters GE 2 THEN HighCounters=HighCounters(SORT(smoothed(HighCounters)/tmp((HighCounters)-smoothed(HighCounters))))
  IF NbOfHighCounters GE 1 THEN PRINT,' High ', STRMID(HighCounters(0:13<N_ELEMENTS(HighCounters)-1),8,4)
  IF NbOfHighCounters GE 1 THEN PRINTf,bad,' High ', STRMID(HighCounters(0:13<N_ELEMENTS(HighCounters)-1),8,4)
  tmp0=0*HighCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN FOR i=0,NbOfHighCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ HighCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
    IF count GE 1 THEN PRINT,' excl.', STRMID(HighCounters(ind0),8,4)
    IF count GE 1 THEN PRINTf,bad,' excl.', STRMID(HighCounters(ind0),8,4)
  ENDIF
  IF NbOfHighCounters GE 1 THEN Highstat(HighCounters)=Highstat(HighCounters)+1
  
  ind=indgen(N_ELEMENTS(tmp))
  IF N_ELEMENTS(deviation) EQ 0 THEN BEGIN
    deviation=7.*tmp(ind)/(tmp(ind)+tmp((ind-1)>0)+tmp((ind+1)<(N_ELEMENTS(tmp)-1))+tmp((ind-2)>0)+tmp((ind+2)<(N_ELEMENTS(tmp)-1))+tmp((ind-3)>0)+tmp((ind+3)<(N_ELEMENTS(tmp)-1)))
    error    =2.*sigm(ind)/(tmp((ind-1)>0)+tmp((ind+1)<(N_ELEMENTS(tmp)-1)))+2.*tmp(ind)/(tmp((ind-1)>0)+tmp((ind+1)<(N_ELEMENTS(tmp)-1)))^2*(sigm((ind-1)>0)+sigm((ind+1)<(N_ELEMENTS(tmp)-1)))
  ENDIF ELSE BEGIN
    deviation=[[deviation], [7.*tmp(ind)/(tmp(ind)+tmp((ind-1)>0)+tmp((ind+1)<(N_ELEMENTS(tmp)-1))+tmp((ind-2)>0)+tmp((ind+2)<(N_ELEMENTS(tmp)-1))+tmp((ind-3)>0)+tmp((ind+3)<(N_ELEMENTS(tmp)-1)))]]
    error    =[[error    ], [2.*sigm(ind)/(tmp((ind-1)>0)+tmp((ind+1)<(N_ELEMENTS(tmp)-1)))+2.*tmp(ind)/(tmp((ind-1)>0)+tmp((ind+1)<(N_ELEMENTS(tmp)-1)))^2*(sigm((ind-1)>0)+sigm((ind+1)<(N_ELEMENTS(tmp)-1)))]]
  ENDELSE
  FLUSH,bad
ENDFOR
CLOSE,bad
FREE_LUN,bad
PRINT,badname ,' written'
mod_datp,datp,'x',indgen(1600)
mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
help,n1,numor
mod_datp,datp,'p',[n1,numor-1]
mod_datp,datp,'e',error
mod_datp,datp,'n',0
mod_datp,datp,'y',y
mod_datp,datp,'w_tit','Deviation from expected counting rate'
mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n2)
mod_datp,datp,'y_tit','factor'
mod_datp,datp,'x_tit','cell'
give_datp,datp

return,deviation
END

;+
; NAME:
;	BAD
;
; PURPOSE:
;	Detection of bad cells in a range of numors.
;
; CATEGORY:
;	Instrument
;
; CALLING SEQUENCE:
;	BAD, N1, N2
;
; INPUTS:
;	N1:	first numor.
;
; OPTIONAL INPUTS:
;	N2: last numor..
;	
; KEYWORD PARAMETERS: See also psplot!
;	SENSITIVITY:	sensitivity in multiples of sigma (default 3).
;	ZERO: will contain zero-counting cells.
;	LOW: will contain low-counting cells.
;	HIGH: will contain high-counting cells.
;	M: will contain "M"-counting cells.
;	W: will contain "W"-counting cells.
;
; OUTPUTS:
;	onscreen plot
;	relative deviation from expected counting rate
;
; OPTIONAL OUTPUTS:
;	cell numbers by keywords, see above.
;
; COMMON BLOCKS:
;	Calibration
;
; SIDE EFFECTS:
;	none
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
;	no foobar superfloatation method.
;
; EXAMPLE:
;
; MODIFICATION HISTORY:
; 	Written by:	Thomas Hansen, April 1998.
;	May, 1998	Documentation
;-
;*******************************************************************************

	PRO beamcentre, w_in0, px, py

;	Finds the beam centre position from a transmission run. Called from
;	prime_cell.pro

;						JRS 2/3/00

;-------------------------------------------------------------------------------

	iprint=0        ; if iprint>0, show debugging messages

        IF (iprint GT 0) THEN PRINT,'Start beamcentre:'

        TAKE_DATP, datp

;-------------------------------------------------------------------------------
;define run parameters
;
	m_in0=datp.n	; monitor counts
        x_in0=datp.x    ; x-pixels
        y_in0=datp.y    ; y-pixels
        z_in0=datp.z    ; arbitrary number
        e_in0=datp.e	; errors
        par=datp.p
	
	se=SIZE(e_in0)
	sw=SIZE(w_in0)

	FOR i=0,se(0) DO IF (se(i) NE sw(i)) THEN GOTO, seterr
	GOTO, noseterr
seterr:
	IF (iprint GT 0) THEN PRINT,'bemacentre: No error bars defined for w_in. Use sqrt'
	e_in0=SQRT(w_in0)
noseterr:
	IF (sw(0) EQ 0) THEN BEGIN
		PRINT,'beamcentre: Error - workspace is empty'
		GOTO, finished
	ENDIF

	IF (sw(0) EQ 3) THEN BEGIN
		PRINT,'beamcentre: Error - don`t use concatenated runs'
		GOTO, finished
	ENDIF

	nspectra=sw(1)
	IF (iprint GT 0) THEN PRINT,'nspectra=',nspectra

;-------------------------------------------------------------------------------
; find beam centre

	w_bufx=FLTARR(nspectra)
	w_bufy=FLTARR(nspectra)
	e_bufx=FLTARR(nspectra)
	e_bufy=FLTARR(nspectra)
	w_bufx=total(w_in0,2)
	w_bufy=total(w_in0,1)
	e_bufx=sqrt(total(e_in0^2,2))
	e_bufy=sqrt(total(e_in0^2,1))

	fitgauss, x_in0, w_bufx, e_bufx, MIN(x_in0), MAX(x_in0), A, dA
	fitgauss, y_in0, w_bufy, e_bufy, MIN(y_in0), MAX(y_in0), B, dB

;-------------------------------------------------------------------------------
finished:
	IF (iprint GT 0) THEN PRINT,'Beamcentre finished'

	datp.p(13)=A(2)
	datp.p(14)=B(2)
	px=A(2)
	py=B(2)

	GIVE_DATP, datp

	END

	



;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION bin, w_in, ibin

; Bins points in the x-axis of a 1-d data set by an integer multiple, ibin. 
;
;						KHA, 1/12/97
;-------------------------------------------------------------------------------
;*******************************************************************************

	take_datp, datp

	x_in=datp.x
	e_in=datp.e

	s=SIZE(w_in)
	IF (s(0) NE 1) THEN BEGIN
		PRINT,'remove: Error - workspace must be 1-dimensional'
		return,w_in
	ENDIF

	nin=s(1)
	nout=nin/ibin
	rbin=FLOAT(ibin)

	w_out=FLTARR(nout)
	x_out=FLTARR(nout)
	e_out=FLTARR(nout)
	iout=0
	FOR i=0,nin-ibin,ibin DO BEGIN
		w_out(iout)=TOTAL(w_in(i:i+ibin-1))/rbin
		x_out(iout)=TOTAL(x_in(i:i+ibin-1))/rbin
		e_out(iout)=SQRT(TOTAL(e_in(i:i+ibin-1)^2))/rbin
		iout=iout+1
	ENDFOR

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out

finished:
	give_datp, datp

	RETURN, w_out
	END
;------------------------------------------------------------------------------
;******************************************************************************
;
	FUNCTION binq, w_in, dQ=dQ, qb

;Interpolates data along the x-axis to regular steps with point spacing dQ. 
;
;ARGUMENTS:
; dQ	:desired constant Q-bin width
; (qb is obsolete, kept for backwards compatability)
;
;DIMENSIONS:
; w_in(nspectra) -> w_out(nQ)
;
;COMMAND SYNTAX:
; w2=binq(w1,dQ=<dQ>)
;						KHA,JRS 14/8/00
;------------------------------------------------------------------------------
;******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start binq:'

	take_datp, datp

	IF(N_ELEMENTS(qb) GT 0) THEN dQ=qb
	
;-------------------------------------------------------------------------------
;Check dimensions of input workspace and setup output workspace

	sw=SIZE(w_in)
	if (sw(0) ne 1) and (sw(0) ne 2) then return,w_in
	par=datp.p

	nx_in=sw(1)
	IF (sw(0) EQ 2) THEN ny=sw(2) ELSE ny=1

	e_in=datp.e
	x_in=datp.x
	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'
;-------------------------------------------------------------------------------
;Rebin to constant Q

	Qmax=x_in(nx_in-1)
	nx_out=Qmax/dQ+1
	x_out=INDGEN(nx_out)*dQ

	w_out=FLTARR(nx_out,ny)	& w_out(*,*)=0.
	e_out=FLTARR(nx_out,ny)	& e_out(*,*)=-1.
	wsum=FLTARR(ny)
	e2sum=FLTARR(ny)

	i0=0
	FOR iQ=0,nx_out-1 DO BEGIN
		Q0=x_out(iQ)
		wsum(*)=0.
		e2sum(*)=0.
		n=0
		FOR i=i0,nx_in-1 DO BEGIN
			Q=x_in(i)
			IF (ABS(Q-Q0) LT dQ/2.) THEN BEGIN
				wsum(*)=wsum(*)+w_in(i,*)
				e2sum(*)=e2sum(*)+e_in(i,*)^2
				n=n+1
			ENDIF ELSE IF (Q GE Q0+dQ/2.) THEN GOTO, endloop
		ENDFOR
endloop:	i0=i
		IF (n GT 0) THEN BEGIN
			w_out(iQ,*)=wsum/n
			e_out(iQ,*)=sqrt(e2sum)/n
		ENDIF
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of "rebin to constant Q" section'

;-------------------------------------------------------------------------------
;Remove undefined points

	buf=e_out(*,0)
	i=WHERE(e_out GE 0.,n)

	x_out=x_out(i)
	w_buf=FLTARR(n,ny)
	e_buf=FLTARR(n,ny)
	FOR iy=0,ny-1 DO BEGIN
		w_buf(*,iy)=w_out(i,iy)
		e_buf(*,iy)=e_out(i,iy)
	ENDFOR
	w_out=w_buf
	e_out=e_buf

	IF (iprint GT 0) THEN PRINT,'End of "remove undefined points" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	dQs=STRTRIM(STRING(dQ),2) & np=RSTRPOS(dQs,'.')+3 & dQs=STRMID(dQs,0,np)
	PRINT,'binq: data binned to dQ='+dQs
finished:

	mod_datp, datp, "e", e_out
	mod_datp, datp, "x", x_out

	datp.other_tit=datp.other_tit+' -bq('+dQs+')'

	IF (iprint GT 0) THEN PRINT,'End binq:'

	give_datp, datp

	RETURN, w_out
	END
function biny, win ,by
;******* ****
;**
;** Group ordinates by by (DR 2001)
;** CALL: Wi=biny(wj [,2])

dim =SIZE(win)

IF dim(0) eq 2 THEN IF dim(2) GE 4 THEN BEGIN

	IF n_elements(by) ne 1 THEN by=2
	by=by>2<(dim(2)/2)

	wout =FLTARR( dim(1) ,dim(2)/by )
	yout =FLTARR( dim(2)/by)

;	Take all parameters
;	**** *** **********
	TAKE_DATP,P
	r=0
	IF n_elements(P.e) eq n_elements(win) THEN BEGIN
		r=1 & P.e=P.e^2 & eout=wout & ENDIF

	FOR i=0,dim(2)/by-1 DO BEGIN
	    j=i*by
	    wout(*,i)= total(win(*,j:j+by-1),2)/by
	    yout(i)  = total(P.Y(  j:j+by-1)  )/by
	    IF r  THEN eout (*,i)= total(P.e(*,j:j+by-1),2)
	ENDFOR
	
;	Give back parameters
;	**** **** **********
	P.Y_TIT  =P.Y_TIT+' (binY*'+strtrim(string(by),2)+')'
	MOD_DATP ,P,'Y',yout	;P.Y=yout is the normal formulation but it
				;d'nt work (because the size changed)

	IF r THEN MOD_DATP ,P,'E',SQRT(eout)/by

	GIVE_DATP,P		;Give back

	RETURN,wout
ENDIF

P_MUS ,'mus_cannon'
RETURN, win
END

pro bip

openr,6,'data_d17b.'

time1=intarr(200000)
time2=intarr(200000)
;tot1=intarr(200000)
time3=intarr(200000)
time4=intarr(200000)
;tot2=intarr(200000)
timea=intarr(200000)
;hit1=intarr(200000)
;hit2=intarr(200000)
;hit3=intarr(200000)
;hit4=intarr(200000)
;hita=intarr(200000)
ll=fltarr(10)
picture=intarr(1000,400)



d1=0
d2=0
d3=0
d4=0
d5=0
d6=0
d7=0
d8=0
d9=0
d10=0


rejected=0.

i=0.0
num=0.0
ix=0.0
while ( NOT eof(6) AND (i LT 200000)) do begin


readf,6,d1,d2,d3,d4,d5,d6,d7,d8,d9,d10
ix=ix+1
;put the values into time and hit arrays inside the loop otherwise we make statistics on 
;un-rejected data



if( (d5 EQ 1) AND (d6 EQ 1) AND (d7 EQ 1) AND (d8 EQ 1) and (d9 EQ 1)) then begin

	
;	x=d1-d2+200
;	y=d3-d4+400
	y=d1-d2+200
	x=d4-d3+400
	if((x GE 0) AND (x LT 1000) AND (y GE 0) AND (y LT 1000)$
        and (d1+d2 GE 0) AND (d1+d2 LT 400) AND (d3+d4 GE 0) AND (d3+d4 LT 1000)) then begin
		picture(x,y)=picture(x,y) +1
		time1(i)=d1
		time2(i)=d2
		time3(i)=d3
		time4(i)=d4
		timea(i)=d10
;		hit1(i)=d5
;		hit2(i)=d6
;		hit3(i)=d7
;		hit4(i)=d8
;		hita(i)=d9
		i=i+1
	endif	         
	
        endif else begin
		rejected=rejected+1
	endelse

end
close,6
num=i
print,'number read in: ',ix
print,'good ones: ',num
print,'rejected: ',rejected,' = ', 100.*rejected/ix,' %'






tot1=intarr(num)
tot2=intarr(num)

for i=0.0,num-1 do begin
  tot1(i)=time1(i)+time2(i)
  tot2(i)=time3(i)+time4(i)
;  print,i,tot1(i),tot2(i),time1(i)-time2(i),time3(i)-time4(i)
endfor




loadct,5
window,0,retain=2,xsize=400,ysize=400
;plot,time3,time4,PSYM=3,/NOdata,color=256,xstyle=1,ystyle=1,xrange=[470,700],yrange=[400,610]

plot,time3,time4,PSYM=3,color=69,xrange=[0,600],yrange=[0,600]
window,1,retain=2,xsize=400,ysize=400
plot,time1,time2,PSYM=3,color=120,xrange=[0,200],yrange=[0,200]
window,2,retain=2,xsize=400,ysize=400
plot,(time1+time2),(time3+time4),PSYM=3,color=150

print,'TEST ',min(time1)
print,'TEST ',min(time2)
print,'TEST ',min(time3)
print,'TEST ',min(time4)

; probability distributions of delay sums

  result=moment(tot1)
  tit=' mean= '+string(result(0))+'  rms= '
  tit2=string(sqrt(result(1)))+' skewness='+string(result(2))
  tit=tit+tit2
  print,'mean time1+time2: ',result(0)
  print,'rms  time1+time2: ',sqrt(result(1))
  print,'skew time1+time2: ',result(2)
  print,'min  time1+time2: ',min(tot1)
  print,'max time1+time2: ',max(tot1)
  
  

  nn=(max(tot1)-min(tot1))
  b=1.0
  window,3,retain=2,xsize=550,ysize=400
  x=fltarr(nn)
  x=findgen(nn)*b+min(tot1)+b/2.
  plot,x,histogram(tot1,binsize=b), $
  color=120,title=tit,xtitle='time1+time2',$
  charsize=.6

  result=moment(tot2)
  tit=' mean= '+string(result(0))+'  rms= '
  tit2=string(sqrt(result(1)))+' skewness='+string(result(2))
  tit=tit+tit2
  print,'mean time3+time4: ',result(0)
  print,'rms  time3+time4: ',sqrt(result(1))
  print,'skew time3+time4: ',result(2)
  print,'min  time3+time4: ',min(tot2)
  print,'max  time3+time4: ',max(tot2)
  
  
  nn=(max(tot2)-min(tot2))
  b=1.0
  window,4,retain=2,xsize=550,ysize=400
  x=fltarr(nn)
  x=findgen(nn)*b+min(tot2)+b/2
  plot,x,histogram(tot2,binsize=b),$
  color=69,title=tit,xtitle='time3+time4',$
  charsize=.6



;window,1,xsize=400,ysize=400
;plot,timea,xrange=[0,2000],yrange=[110,125]


m1=max(picture)
m2=min(picture)
m3=total(picture)
print,'total counts: ',m3
print,'min counts: ',m2
print,'max counts: ',m1
print,'rejected neutron = ',rejected

n=9

for i=0,n do begin 
	ll(i)=m2+float(i)*((float(m1-m2))/float(n+1))
	
endfor


window,3,retain=2,xsize=2000,ysize=2000
contour,picture,levels=ll,c_colors=indgen(10)*25
;xrange=[0,610],yrange=[270,410]
end ;of procedure bip
pro blap,pic2,picture
close,4
close,3
openr,3,'data.'
xdim=600
ydim=1200

picture=fltarr(xdim,ydim)

i=1
x=1
y=1



xmin=1000000
xmax=-1000000
ymin=1000000
ymax=-1000000

while (not eof(3) and i lt 50000) do begin

  i=i+1
  readf,3,y,x
  if (x lt xmin ) then xmin=x
  if (x gt xmax ) then xmax=x
  if (y lt ymin ) then ymin=y
  if (y gt ymax ) then ymax=y
  
  x=x
  y=y+880
 if ((x le xdim) and (x ge 1) and (y le ydim) and (y ge 1))then begin
  picture(x,y)=picture(x,y)+1 
 endif
endwhile

bfac=1.2
picture=reverse(picture)
pic2=congrid(picture,(xdim/bfac),(ydim/bfac))
pic2=pic2*bfac*bfac
pic2=smooth(pic2,5)
m1=max(pic2)
m2=min(pic2)
m3=total(pic2)
print,'total counts: ',m3
print,'min counts: ',m2
print,'max counts: ',m1
print,'xmax: ',xmax
print,'xmin: ',xmin
print,'ymin: ',ymin
print,'ymax: ',ymax

n=9
ll=fltarr(n+1)
for i=0,n do begin 
	ll(i)=m2+float(i)*(((m1-m2))/float(n+1))
endfor
print,ll


loadct,5
gamma_ct,0.302

;,c_colors=indgen(10)*25,levels=ll
;window,0,retain=2,xsize=1000,ysize=1000
;contour,pic2,levels=ll,c_colors=indgen(10)*25
window,1,retain=2,xsize=470,ysize=900
tv,fix((pic2*256/max(picture)))
window,2,retain=2,xsize=470,ysize=500
plot,total(pic2,1)
window,3,retain=2,xsize=470,ysize=500
plot,total(pic2,2)


openw,4,'picture'
printf,4,picture
close,4
close,3

end
function bobit,name
loadct,3
print,'cuicui'
XBIN=40
YBIN=39
TSLICE=500
det=intarr(XBIN,YBIN,TSLICE)

print,name
openr,3,name
readf,3,det
close,3

w=det

return,w
end 
pro bobtof,name
loadct,3

XBIN=35
YBIN=34
TSLICE=500
det=intarr(XBIN,YBIN,TSLICE)

print,name
openr,3,name
readf,3,det
close,3

;window,0,retain=2
;plot,total(total(det,1),1)

;window,1,xsize=200,ysize=200,retain=2
;tvscl,congrid(total(det,3),200,200)

;window,2,retain=2,xsize=200,ysize=200
;for i=1,TSLICE-1 do tvscl,congrid(det(*,*,i),200,200)
;surface,total(det,1)
m1=max(total(det,3))
m2=min(total(det,3))
m3=total(det)
print,'total counts: ',m3
print,'min counts: ',m2
print,'max counts: ',m1


m=19
ll=m2+indgen(m)*((float(m1-m2))/float(m+1))
window,3,retain=2
;,xsize=500,ysize=1000

contour,(total(det,3)),levels=ll,c_colors=indgen(15)*37
;,xrange=[0,525],yrange=[0,1053]
xloadct




end ; test_tof
pro macro_blap, stop_butt,mot,nm,min,max,nn
on_error, 2

on_error, 2
common dialshare2 & common madshare & common colours
common alphabet
;max=6.5
;min=1.0
;nn=100
numb=100
;nm=2
;mot='san'
s=fltarr(nn)
for ii=0,n_elements(s)-1 do begin
  r=randomu(seed,10)
  a=r(3)*(max-min)+min
  b=mot+' '+string(a)
  mad,b
  wait,.5
  while (mad_status(t_nother) eq 'POSITIONNING' ) do i=i
  wait,0.5       
if  stop_macro(stop_butt) then  return
  aa=get_mad_pos(act)
  print,a,act(nm), a-act(nm)
  s(ii)=a-act(nm)
  result=moment(s)
  tit=string(ii)+' mean= '+string(result(0))+'  rms= '
  tit2=string(sqrt(result(1)))+' skewness='+string(result(2))
  tit=tit+tit2
  b=(max(s)-min(s))/numb
  window,0
  x=fltarr(numb)
  x=findgen(numb)*b+min(s)+b/2
  plot,x,histogram(s,min=min(s),max=max(s),binsize=b),$
  color=green,title=tit,xtitle=mot+' error' 

;if  stop_macro(stop_butt) then  return
;	a=get_mad_nother(t_nother)
;	if t_nother.cstate_flags ne 0 then begin
;		print, t_nother.cstate_flags
;		c= mad_status(t_nother)
;		print, c
;	endif
endfor

end
function makemask,w,cenx,ceny,radius


arx = findgen(64)#(fltarr(64)+1)
ary = transpose(arx)
w_out = w
;TAKE_DATP,P
list = where(((arx-cenx)^2+(ary-ceny)^2) lt radius^2,count)
if (count ne 0) then w_out(list) = 0 else print, 'fuckit'
;GIVE_DATP,P
return, w_out
end
function bsnorm, w_in
;******* *****
;**
;** Normalize W_in with monitor spectrum for in10, in16, in13

    w_out=float(w_in)
    s    =size (w_in)

;** Check for consistancies
    if (s(0) gt 0) and (s(0) lt 3) then begin 
	TAKE_DATP,P
	sp=size(P.n)
	P.n=P.n>1
;**	Normalize
	if s(0) eq 2 then begin
          if (s(1) eq sp(1)) or sp(0) eq 0 then $
			for i =0,s(2)-1 do w_out(0,i)=w_out(*,i)/P.n $
	  else		for i =0,s(2)-1 do w_out(0,i)=w_out(*,i)/P.n(i)
	endif
	if s(0) eq 1 then 		   w_out     =w_out     /P.n

;**	Errors
	IF n_elements(P.e) eq n_elements(w_in) then begin
	if s(0) eq 2 then begin
          if (s(1) eq sp(1)) or sp(0) eq 0 then $
			for i =0,s(2)-1 do P.e(0,i)  =P.e(*,i)/P.n $
	  else		for i =0,s(2)-1 do P.e(0,i)  =P.e(*,i)/P.n(i)
	endif
	if s(0) eq 1 then 		   P.e       =P.e     /P.n
	ENDIF
	
	P.n(*)=1
	P.x_tit=P.x_tit+' normalized'
	GIVE_DATP,P
    endif

return,w_out
end
PRO bundle,fil,resf,a,b,c

y=fltarr(10000)
x=fltarr(10000)
e=fltarr(10000)
d=fltarr(10000)
dq=fltarr(10000)

ny=fltarr(10000)
nx=fltarr(10000)
nee=fltarr(10000)
ndq=fltarr(10000)
;resf=2.

xx='xxxxx'
print,fil
openr,unit,fil,/get_lun

while strmid(xx,1,3) ne 'wat' do begin
  readf,unit,xx
  print,xx
;  print,'looking for wat',strmid(xx,1,3)
endwhile

readf,unit,xx
print,xx

k=.00001 & l=.000001 & m=.000001 & n=.000001

i=0
while  not eof(unit) do begin
if i eq 0 then print,'start read data'

readf,unit,k,l,m,n
print,k,l,m,n
 
 x(i)=k & y(i)=l & e(i)=m & dq(i)=n
 i=i+1
endwhile

num=i
print,'total number inthe beginning: ',num


c=0
itt=4
tot=num

for k=0,itt do begin
 blim=0
 c=0
 num=tot
 new=0
 pairs=0
 print,'itteration: ',k+1

; weight data by errors

for i=0,num do begin

  if (x(c+1)-x(c) lt dq(c)/resf and x(c+1) ne 0) then begin
     ny(new)=(y(c+1)/e(c+1)^2.+y(c)/e(c)^2.)/((e(c+1)^(-2.)+e(c)^(-2.)))
     nee(new)=(sqrt(e(c)^2.+e(c+1)^2.))/2
     nx(new)=(x(c)+x(c+1))/2.
     ndq(new)=(dq(c)+dq(c+1))/2.
     pairs=pairs+1
     print,'found a pair:'
     c=c+1
     tot=tot-1
     blim=0
  endif else begin
     ny(new)=y(c)
     nx(new)=x(c)
     nee(new)=e(c)
     ndq(new)=dq(c)
  endelse
new=new+1 
c=c+1

endfor
 y=ny
 x=nx
 e=nee
 dq=ndq

 print,'tot num,new,pairs:',tot,num,new,pairs
 if (blim eq 0) then itt=1
endfor

a=alog10(ny(0:tot-1)) & b=nx(0:tot-1) & c=(nee(0:tot-1)/ny(0:tot-1))/alog(10)
;a=ny & b=nx & c=nee

free_lun,unit


while (((i=strpos(fil,'out'))) ne -1) do strput,fil,'aft',i


title='spanner'
nb=2.07
print,fil
openw,unit,fil,/get_lun
printf,unit,'"AFIT"'
printf,unit,'"'+title+'"'
printf,unit,format='(f4.2)',nb
printf,format='(i3)',unit,tot
for i=0,tot-2 do begin

 printf,unit,format='(g10.4,10x,g10.4,10x,g10.4)',nx(i),ny(i),nee(i)
endfor

close,unit
free_lun,unit

while (((i=strpos(fil,'aft'))) ne -1) do strput,fil,'dat',i
print,fil
openw,unit,fil,/get_lun
for i=0,tot-1 do begin
 printf,unit,nx(i),'	',ny(i),'	',nee(i)
endfor
close,unit
free_lun,unit

return
print,!stime
end
;------------------------------------------------------------------------------
; This code is used to run a Dial speaking to the instrument without GEORGE guy
;------------------------------------------------------------------------------

; FUNCTION DialNewValue   GET  A VALUE FROM THE INSTRUMENT
; FUNCTION DialControl 	  SEND A COMMAND TO THE INSTRUMENT
; FUNCTION DialOn 	  NORMALY USED FOR INTERRUPT IN GEORGE
; PRO      DialTag 	  SET OR GET A DIAL PROPERTY
; PRO      DialStart	  TIE A DIAL TO THE CLOCK
; PRO      DialStop	  DETACH A DIAL FROM THE CLOCK
; PRO      DialModValue	  ADD or CHANGE DIMENSION OF A DIAL PROPERTY
; PRO      DialInit	  READ   A DIAL FROM FILE AND PUT IN MEMORY
; PRO      DialMacro	  EXECUTE THE MACRO OF A NON-ACTIVE DIAL
; PRO      DialClear	  REMOVE A DIAL FROM MEMORY
; PRO      DialWset       NORMALY USED TO SELECT MAIN-PLOT-WINDOW IN GEORGE
; PRO      DialsFrequency NORMALY USED TO GIVE THE SAME FREQUENCY TO A GROUP OF DIALS

; MATLAB tips: DD=CALL_FUNCTION('dial_'+DD.origin+'_macro',DD)
;             ii =EXECUTE('DD='+dial)
;             mat= 1 in by_timer
;             value='                                               ',/dynamic_resize
;--------------------------------------------------------------------------------------
FUNCTION DialNewValue, tope,NAME=name,d=dnum,SETVALUE=setvalue, COMMENT=ctxt, TYPE=tipe
;******* ************
;**	 GET A VALUE FROM THE INSTRUMENT
	 common noGeorge,DD, Widg
	 
CATCH,stat
if stat ne 0 then begin catch,/cancel & print,!err_string & return,'error' & endif
if n_elements(tope) ne 1 then if n_elements(tipe) ne 1 then tipe=DD.type
if n_elements(tope) eq 1 then if n_elements(tipe) ne 1 then tipe=tope
IF DD.generic eq 'lamp'  then begin
   CASE strlowcase(tipe) of
   'flagus':	V=0
   'status':	V='Idle'
   'log':	V=''
   ELSE:	V=0
   ENDCASE
ENDIF else $
   V= CALL_FUNCTION('dial_'+DD.generic+'_read',tipe)    ;...GET A VALUE FROM INSTRUMENT
if keyword_set(setvalue) then DialModValue, V, tag='VALUE'
return,V
END

;--------------------------------------------------------------------------------------
FUNCTION DialControl, command, d=dnum ,check=check ,name=nome
;******* ***********
;**	 SEND A COMMAND TO THE INSTRUMENT
	 common noGeorge,DD, Widg

CATCH,stat
if stat ne 0 then begin catch,/cancel   & print,!err_string  & return,'error' & endif
if n_elements(check) ne 1 then check=0. & V=0
IF DD.generic ne 'lamp' then $
  V= CALL_FUNCTION('dial_'+DD.generic+'_send','',check,command)$;SEND COMMAND TO INSTRU
ELSE ii=EXECUTE(command(0))
return,V
END

;--------------------------------------------------------------------------------------
FUNCTION DialOn, dial, d=dnum
;******* ******
;**	 NORMALY USED FOR INTERRUPT IN GEORGE
return,1
END

;--------------------------------------------------------------------------------------
PRO DialTag, name, d=dnum, TAG=tag, SET=setv, GET=getv
;** *******
;** SET OR GET A DIAL PROPERTY
    common noGeorge,DD, Widg

BY_SWITCH,/STORE, NEWNUM=dnum,NEWNAME=name
getv=0
IF n_elements(tag)  eq 0 then getv=DD else ii=execute('getv=DD.'+tag)           ;...GET
IF n_elements(setv) gt 0 then DialModValue, setv, TAG=tag                       ;...SET
BY_SWITCH,/RESTORE
END

;--------------------------------------------------------------------------------------
PRO DialStart, name, d=dnum
;** *********
;** TIE A DIAL TO THE CLOCK
    common noGeorge,DD, Widg

BY_SWITCH,/STORE, NEWNUM=dnum,NEWNAME=name
DialModValue, systime(1), TAG='BYSTART'
DD.onoff=1 & widget_control,bad_id=ii,Widg(DD.number+3),TIMER=.1     ;...SET TIME EVENT
BY_SWITCH,/RESTORE
END

;--------------------------------------------------------------------------------------
PRO DialStop, name, d=dnum
;** ********
;** DETACH A DIAL FROM THE CLOCK
    common noGeorge,DD, Widg
    
DialTag, name, d=dnum, TAG='ONOFF', SET=0
END

;--------------------------------------------------------------------------------------
PRO DialModValue, val, NAME=name, d=dnum ,tag=TAG
;** ************
;** ADD or CHANGE DIMENSION OF A DIAL PROPERTY
    common noGeorge,DD, Widg
    
      sv =SIZE(val)
      if n_elements(TAG) ne 1 then TAG='VALUE' else TAG=strupcase(TAG)
      tlist=strupcase(tag_names(DD))
      idx=WHERE(tlist eq TAG) & sz =[0,0,0]
      if idx(0) ge 0 then ii=execute('sz=SIZE(DD.'+TAG+')')
      if (sz(sz(0)+1) ne sv(sv(0)+1)) or (sz(sz(0)+1) eq 8) or $
         (sz(0) ne sv(0)) or (sz(sz(0)+2) ne sv(sv(0)+2)) then begin
	 elsa = ''
	 for k=0,n_elements(tlist)-1 do begin
          CASE tlist(k) of
           TAG:
           ELSE:      elsa =elsa+','+tlist(k)+':DD.'+tlist(k)
          ENDCASE
	 endfor
                 ii=execute('DD={'+TAG+':val'+ elsa +'}') ;...RECONSTRUCT THE STRUCTURE
      endif else ii=execute('DD.' +TAG+'=val')            ;...OR SIMPLY MODIFY THE  TAG
END

;--------------------------------------------------------------------------------------
PRO DialInit, name, d=dnum, path=pth, restore=rest, new=newed, herits=diaH, nostart=nos
;** ********
;** READ A DIAL FROM FILE AND PUT IN MEMORY
    common noGeorge,DD, Widg

IF n_tags(DD) ge 3 then begin if n_elements(name) ne 1 then name=DD.name
			kp=DD.number & endif else kp=0
DIAL_BYGEORGE, name, nostart=nos, new=newed                            ;...GET THE DIAL
BY_SWITCH,LOAD=kp
END

;--------------------------------------------------------------------------------------
PRO DialMacro, name, d=dnum, Si=di
;** *********
;** EXECUTE THE MACRO OF A NON-ACTIVE DIAL
    common noGeorge,DD, Widg

BY_SWITCH,/STORE, NEWNUM=dnum,NEWNAME=name
call_procedure,'dial_' +DD.origin+'_macro',DD                     ;...EXECUTE THE MACRO
BY_SWITCH,/RESTORE
END

;--------------------------------------------------------------------------------------
PRO DialClear, name, d=dnum
;** *********
;** REMOVE A DIAL FROM MEMORY
    common noGeorge,DD, Widg

BY_SWITCH,/CLEAR, NEWNUM=dnum,NEWNAME=name
END

;--------------------------------------------------------------------------------------
PRO DialWset, Activity=activity
;** ********
;** NORMALY USED TO SELECT MAIN PLOT WINDOW IN GEORGE
    Wset,0L
END

;--------------------------------------------------------------------------------------
PRO DialsFrequency, GET=getv, SET=setv, STOP=stop, START=stort, DURATION=lim, SENS=sens
;** **************
;** NORMALY USED TO GIVE THE SAME FREQUENCY TO A GROUP OF DIALS IN GEORGE

getv=0.
END
;-------------------------------- End of User library ---------------------------------
;-------------------------------- End of User library ---------------------------------

;--------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------

;--------------------------------  Internal routines  ---------------------------------
;--------------------------------  Internal routines  ---------------------------------

; PRO      by_switch	  SWITCH ROUND THE DIALS WHEN INVOLVED
; PRO      by_timer	  THE CLOCK HANDLER
; PRO      by_stop	  STOP ALL DIALS
; PRO      dial_byGeorge  CALLED BY "DialInit" TO READ A DIAL FILE


PRO by_switch,LOAD=lod ,SAVE=sav,STORE=sto ,RESTORE=res,NEWNUM=dnu,NEWNAME=nam,$
              CLEAR=clr,STOP=stp,GETNUM=gnu
;** *********
;** SWITCH ROUND THE DIALS WHEN INVOLVED
    common noGeorge,DD, Widg
    common bygeorge,d0 ,d1 ,d2 ,d3 ,d4 ,d5 ,d6 ,d7 ,d8 ,d9 ,d10,$
                    d11,d12,d13,d14,d15,d16,d17,d18,d19,d20,names,pile

IF n_elements(names) eq 0 then begin d0={ONOFF:0,NUMBER:0,NAME:''}   & d1 =d0 & d11=d1
	d2 =d1 & d3 =d1 & d4 =d1 & d5 =d1 & d6 =d1 & d7 =d1 & d8 =d1 & d9 =d1 & d10=d1
	d12=d1 & d13=d1 & d14=d1 & d15=d1 & d16=d1 & d17=d1 & d18=d1 & d19=d1 & d20=d1
	names=strarr(21) & pile='' & ENDIF

IF n_elements(nam)  eq 1 then begin
		    idx=where(names eq strlowcase(nam))
		    if idx(0) gt 0 then lod=idx(0) else IF keyword_set(sto) then lod=0
ENDIF
IF n_elements(dnu)  eq 1           then lod=dnu

if n_tags    (DD)   lt 3 then DD=d0 & sd=strtrim(string(DD.number),2)

same=0 & if n_elements(lod) ne 1 then same=1 else if lod eq DD.number then same=1

;---SWITCHES---
IF keyword_set(clr) then begin if same then idx=DD.number else idx=lod
		    r=EXECUTE('d'+strtrim(string(idx),2)+'.ONOFF=0')
		    if same then DD.onoff=0 & names(idx)='' & same=1    & ENDIF
 
IF keyword_set(stp) then FOR k=1,20 do r=EXECUTE('d'+strtrim(string(k),2)+'.ONOFF=0')
IF keyword_set(stp) then DD.onoff=0

IF keyword_set(gnu) then begin if n_elements(lod) eq 1 then gnu=lod $
		               else begin idx=where(names(1:*) eq '')+1
			                  if idx(0) eq 0 then gnu=20 else gnu=idx(0)
			       endelse  & same=1 & ENDIF

IF keyword_set(sto) then pile=[pile,sd]

IF keyword_set(sav) then begin names(DD.number)= DD.name
			       r=EXECUTE('d'+sd+'=DD') & ENDIF

IF     not same     then begin names(DD.number)= DD.name
			       r=EXECUTE('d'+sd+'=temporary(DD)')
			       r=EXECUTE('DD=d'+strtrim(string(lod),2)) & ENDIF

IF keyword_set(res) then BEGIN nn=n_elements(pile)-1
		    IF nn gt 0 then BEGIN sg=pile(nn) & pile=pile(0:nn-1)
		       IF sg ne sd then BEGIN
		               names(DD.number)= DD.name
		               r=EXECUTE('d'+sd+'=temporary(DD)')
			       r=EXECUTE('DD=d'+sg)    & ENDIF & ENDIF & ENDIF
END



PRO by_timer, event
;** ********
;** THE CLOCK HANDLER
    common noGeorge,DD, Widg
BYs=0
IF Widg(0) gt 0 then begin widget_control,event.id,get_uvalue=uv
		MAT=0 ;MAT=0 for Idl, mat=1 for Matlab
		if (DD.number ne uv(0)) then $
		 if MAT then begin BY_SWITCH,/STORE,NEWNUM=uv(0) & BYs=1
		 endif  else BY_SWITCH,LOAD=uv(0)
ENDIF
WHILE ((DD.frequency gt 0) and (DD.onoff)) do begin T1=systime(1)

	CALL_PROCEDURE,'dial_'+DD.origin+'_macro',DD

	if n_elements(DD.value) eq 1 then if (DD.value(0) ne '') then $
			 val=' Val=' + string(DD.value) else val='' else val=''

	if (DD.history   eq 1) then if (DD.value(0) ne '')   then begin
		openw,u,'dial_'+DD.name+'.his',/get_lun,/APPEND
		printf,u,DD.value & free_lun,u & endif
	  
	T2=systime(1)
	if  DD.duration  gt 0. then if (T2-DD.bystart) gt DD.duration then DD.onoff=0
       
	T1=(DD.frequency-float((T2-T1)))>0.01
	if (DD.frequency gt 0.) and (DD.onoff) then $
		if Widg(0) gt 0 then begin
		   widget_control,Widg(1),bad_id=ii,set_value=strmid(!stime,12,11)$
		                             +' Freq='+strtrim(string(DD.frequency),2)+val
		   widget_control,Widg(2), set_value=strupcase(DD.name)
		   widget_control,Widg(uv(0)+3),timer=T1
		   if BYs then    BY_SWITCH,/RESTORE
		   BYs=0 & return
		endif else wait,T1
ENDWHILE
if BYs then BY_SWITCH,/RESTORE
END

PRO by_stop, event
;** *******
;** STOP ALL DIALS
    common noGeorge,DD, Widg

BY_SWITCH,/STOP
if n_elements(event) gt 0 then widget_control,event.top,/destroy
END

PRO map	   & common noGeorge,DD, Widg & widget_control,Widg(0),bad_id=ii,map=1 & END
PRO nomap  & common noGeorge,DD, Widg & widget_control,Widg(0),bad_id=ii,map=0 & END
;** *****

PRO dial_byGeorge, name, nostart=nostart, new=newed
;** *************
;** CALLED BY "DialInit" TO READ A DIAL FILE
    common noGeorge,DD, Widg
    
!quiet=1 & dnum=1 & if n_elements(name) eq 0 then name='bygeorge'
IF n_elements(newed) eq 0 then newed=name

BY_SWITCH,/SAVE
BY_SWITCH, GETNUM=dnum, NEWNAME=newed
dial ='dial_'+name
DD   ={INIT:0,ONOFF:0}

IF name ne 'bygeorge' then ii =EXECUTE('DD='+dial+'()') else II=1
                                IF (not II) then RETURN

tags =['NAME','VALUE','UNIT','GENERIC','TYPE','ORIGIN','PATH']
defs =[ newed,   ''  ,  ''  ,  'mad'  ,'data', name   ,  ''  ]
tagi =['NUMBER','ONOFF','PLOT','WUPDATE','HISTORY','INIT']
defi =[ dnum   ,   1   ,   1  ,    0    ,    0    ,  0   ]
tagr =['ERROR','UPPERLIM','LOWERLIM','FREQUENCY','DURATION']
defr =[   0.  ,    0.    ,    0.    ,     1.    ,    0.    ]

tlist= strupcase(tag_names(DD))
FOR i= 0,n_elements(tags)-1 do begin  idx=WHERE(tlist eq tags(i))
    if idx(0) eq -1 then DialModValue,defs(i),tag=tags(i) & ENDFOR
FOR i= 0,n_elements(tagi)-1 do begin  idx=WHERE(tlist eq tagi(i))
    if idx(0) eq -1 then DialModValue,defi(i),tag=tagi(i) & ENDFOR
FOR i= 0,n_elements(tagr)-1 do begin  idx=WHERE(tlist eq tagr(i))
    if idx(0) eq -1 then DialModValue,defr(i),tag=tagr(i) & ENDFOR

DD.name=newed

if (!D.flags and 65536) ne 0 then begin
  if xregistered('ByGeorge') le 0 then begin Widg=lonarr(24)
  	Widg(0)  =widget_base  (Title="By George !",/column,event_pro='by_timer',map=0)
	bod      =widget_base  (Widg(0),/row)
	Widg(2)  =widget_label (bod    ,value='----- '+strupcase(newed)+' -----' )
	bid      =widget_button(bod    ,value='stop'       ,event_pro='by_stop' )
	for i=0,20 do Widg(3+i)=widget_label (bod    ,value='', uvalue=i)

	bod      =widget_base  (Widg(0),/row)
	Widg(1)  =widget_label (bod    ,value=' ',/dynamic_resize)

	widget_control,Widg(0),/realize
	XMANAGER,'ByGeorge',Widg(0),event_handler='by_timer',/no_block
  endif
  IF keyword_set(nostart) then DD.onoff=0 else if DD.onoff then DialStart
  BY_SWITCH,/SAVE

endif else begin Widg=0 & BY_TIMER & BY_STOP & endelse
END

PRO  byGeorge, name, nostart=nostart, new=newed
dial_byGeorge, name, nostart=nostart, new=newed
END
pro calib_d20,w,filename,eff=cal_d20,ang=ang_d20,NOEFF=noeff,NOANG=noang
;
; Macro (started 28/10/96 by TH.HANSEN) in order to effectuate an efficiency calibration and/or 
; angle calibration
;
; Last modification 17-Feb-97 by Th.Hansen
;
take_datp,datp
x=datp.x
e=datp.e
nd = n_elements(w(*,0,0))

IF ( long(datp.p(38)) MOD 4) MOD 2 ne 0  THEN noeff=1
IF ( long(datp.p(38)) MOD 4)   / 2 ne 0  THEN noang=1
IF nd eq n_elements(w(*,0,0)) THEN cell=indgen(nd) ELSE cell=ROUND((datp.x(*,0)-datp.x(0,0))*10.0)
IF n_elements(ang_d20) eq 0 THEN ang_d20=findgen(nd)
IF n_elements(cal_d20) eq 0 THEN BEGIN
  line=' '
  ang_d20=findgen(nd)
  on_ioerror,misd20
  in=-1
  ok=0
  IF NOT KEYWORD_SET(filename) THEN filename=P_LAMBDA()+'/CALIBRATION/d20.cal' $
                               ELSE filename=P_LAMBDA()+'/CALIBRATION/'+filename
  PRINT,'Calibration by ',filename
  OPENR,in,filename,/get_lun
  cal_d20=fltarr(nd)
  READF,in,line
  print,line
  nd_cal=1600
  ang_d20=findgen(nd_cal)
  cal_d20=fltarr(nd_cal)
  READF,in,ang_d20,cal_d20
  ang_d20=ang_d20-ang_d20(0)
  ok=1
  misd20: IF in gt 0 THEN FREE_LUN,in
  IF ok eq 0 THEN cal_d20=0 ; no calibration
  IF ok eq 0 THEN PRINT,'no calibration effectuated!' ; ELSE plot,cal_d20
ENDIF
IF n_elements(cal_d20) ge n_elements(w(*,0)) THEN BEGIN 
  IF not keyword_set(noeff) THEN BEGIN
    datp.p(38) = datp.p(38)+1.
    w = float (w)
    FOR j=0,n_elements(w(*,0))-1 DO IF cal_d20(cell(j)) eq 0.0 THEN print,'Cell no.',cell(j),' okay? Probably parasite affected! Use PRETREAT,w,cell!'
  ENDIF
  IF not keyword_set(noang) THEN datp.p(38) = datp.p(38)+2.
  FOR i=0,n_elements(w(0,*))-1 DO FOR j=0,n_elements(w(*,0))-1 DO BEGIN
    IF not keyword_set(noeff) THEN IF cal_d20(cell(j)) ne 0.0 THEN BEGIN
      w(j,i)=w(j,i)*cal_d20(cell(j))
      e(j,i)=e(j,i)*cal_d20(cell(j))
    ENDIF
    IF not keyword_set(noang) AND i lt n_elements(x(0,*)) THEN x(j,i)=x(0,i)+ang_d20(cell(j))
  ENDFOR
ENDIF ELSE BEGIN
  noang=1
  noeff=1
ENDELSE
datp.x = x
datp.e = e
give_datp,datp
END
function mean_and_var, x

on_error, 2
nx = n_elements(x)
if nx le 1 then $
  begin
    if nx eq 0 then BEGIN
		  mean=0
			var=0 
		ENDIF else BEGIN
		  mean=x
      var=x*x/(x+1)
		ENDELSE
  endif else begin 
    mean = total(x) / nx
    resid = x - mean
    r2 = total(resid^2)  
    var1 = r2 / (nx-1.0)
    var2 = (r2 - (total(resid)^2)/nx)/(nx-1.0)
    var =  (var1 + var2)/2.0
  endelse
return, [mean, var]
end


;******************************************************************************
FUNCTION caliscan,w,eff=eff,frac=frac,noplot=noplot,noprint=noprint,steps=steps,$
                    low=low,high=high,bad=bad,moreoutput=moreoutput
;+
; NAME:
;	caliscan
;
; PURPOSE:
;	This procedure creates the relative efficiencies of a PSD and a reconstituted powder pattern from a detector scan on a vanadium sample
;
; CATEGORY:
;	Instrument.
;
; CALLING SEQUENCE:
;	CALISCAN,w,eff=eff,frac=frac,noplot=noplot,noprint=noprint,steps=steps,low=low,high=high,bad=bad,moreoutput=moreoutput
;
; INPUTS:
;   w		:	Workspace (2D array, nd * steps elements, as defined in LAMP, normally a 2theta scan over a vanadium)
;
; OPTIONAL INPUTS:
;	none
;	
; KEYWORD PARAMETERS:
;	eff			:	relative efficiencies of the detector cells, only output parameter, becomes a 1D vector of nd elements
;	frac		:	?
;	noplot		:	must be set if no plotting output is wanted
;	noprint		:	must be set if no output in the output file caliscan.out is wanted
;	steps:		:	?
;	low			:	lower limit of counting rates to be taken into account for the computing
;	high		:	higher limit of counting rates to be taken into account for the computing
;	bad			:	?
;	moreoutput	:	produces more output (relative efficiencies) in caliscan.out if set

; OUTPUTS:
;	The reconstituted powder pattern
;
; OPTIONAL OUTPUTS:
;	none
;
; COMMON BLOCKS:
;	none
;
; SIDE EFFECTS:
;	none
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
;	First loop: compare for each cell count rate with all other cells having counted at same positions
;	Second loop: choose the best correlation
;
; EXAMPLE:
;	RDSET,inst='D20',base="Loc Cycle 005" 
;	flag,/nor,/noint,/nobad,/flp,/noeff,/noang
;	w1=RDRUN(19512)
;   w2=CALISCAN(w1,eff=w3,low=22,high=32,/moreoutput)
;
; MODIFICATION HISTORY:
; 	Written by:		Thomas Hansen,	1997.
;	Modified by:	Thomas Hansen,	November 2000	(more output options, plot in window 1)
;
;-

TAKE_DATP,datp
IF NOT KEYWORD_SET(noplot) THEN window,1,xsize=1600,ysize=640
IF NOT KEYWORD_SET(noprint) THEN openw,output,'caliscan.out',/get_lun
IF NOT KEYWORD_SET(noprint) THEN printf,output
IF NOT KEYWORD_SET(noprint) THEN printf,output,'Calibration Scan - Version 2.1.0 beta'
IF NOT KEYWORD_SET(steps) THEN steps=N_ELEMENTS(UNIQ(datp.y))
IF NOT KEYWORD_SET(frac) THEN frac =N_ELEMENTS(w(0,*))/steps
frac=ROUND(frac)
IF frac LE 0 THEN frac=1
steps=N_ELEMENTS(w(0,*))/frac
IF NOT KEYWORD_SET(noprint) THEN printf,output,steps,' steps a ' ,frac,' acquisitions'
w=w(*,0:frac*steps-1)                 ; truncates interrupted scans
cells=N_ELEMENTS(w(*,0))
IF NOT KEYWORD_SET(noprint) THEN  flush,output

IF NOT KEYWORD_SET(noprint)  THEN printf,output
IF NOT KEYWORD_SET(noprint)  THEN printf,output,"************** Counting error calculation (standard deviations) *********"
IF NOT KEYWORD_SET(noprint)  THEN  flush,output
IF frac GT 1 THEN BEGIN
  sdeviation=FLTARR(cells,steps,2)
  FOR i=0,cells-1 DO BEGIN
    FOR j=0,steps-1 DO sdeviation(i,j,*)=mean_and_var(w(i,j*frac:(j+1)*frac-1)) 
  ENDFOR                             ; i=cells
  ave =     sdeviation(*,*,0)
  sdeviation=sqrt(sdeviation(*,*,1))
ENDIF ELSE BEGIN
  ave=w
  sdeviation=datp.e
  IF N_ELEMENTS(datp.e) NE N_ELEMENTS(W) THEN sdeviation=float(w)/SQRT(w+1.)
ENDELSE

NbOfBadCells = 0
IF KEYWORD_SET(bad) THEN BEGIN
  IF N_ELEMENTS(bad) LE 1 THEN BEGIN
	  IF STRING(ROUND(bad)) EQ STRING(ROUND(1)) THEN BEGIN
		  bad=P_LAMBDA()+'/BAD_CELLS/d20.bad' 
		ENDIF ELSE BEGIN
		  bad=STRING(bad)
		ENDELSE
		printF,output,'Reading bad cells from ',bad
		OPENR,badfile,bad,/get_lun
		READF,badfile,NbOfBadCells
		NbOfBadCells=ROUND(NbOfBadCells)
		printF,output,NbOfBadCells,' bad cells'
		IF NbOfBadCells GE 1 THEN BEGIN
		  bad=INTARR(NbOfBadCells)
			READF,badfile,bad
    ENDIF ELSE NbOfBadCells=0
  ENDIF ELSE NbOfBadCells=N_ELEMENTS(bad)
	IF NbOfBadCells GE 1 THEN PRINTF,output,'Bad Cells:  ',bad
ENDIF

plotflag=0
IF NOT KEYWORD_SET(noprint) THEN printf,output
IF NOT KEYWORD_SET(noprint) THEN printf,output,"************** Calculation of relative Efficiencies *******************"
IF NOT KEYWORD_SET(noprint) THEN flush,output
celleff   =fltarr(cells,cells)
cellefferr=fltarr(cells,cells)
cellrelerr=fltarr(cells,cells)
IF NOT KEYWORD_SET(low) THEN low=min(ave)>1.
IF NOT KEYWORD_SET(high) THEN high=max(ave)
FOR i=0,cells-1 DO BEGIN
	;IF NOT KEYWORD_SET(noprint) AND KEYWORD_SET(moreoutput) THEN printf,output,"--> Cell ",i
	;IF NOT KEYWORD_SET(noprint) AND KEYWORD_SET(moreoutput) THEN flush,output
	;print,i
	;  tmp=   min([cells,i+steps])
	;  thrdind=indgen(tmp)
	;  thrdind=thrdind(max([0,i-steps+1]):tmp-1)
	;  thrdind=thrdind(WHERE(thrdind NE i,thrdcnt))
	;  FOR jj=0,thrdcnt-1 DO BEGIN
	;    j=thrdind(jj)
  	FOR j=((i-steps+1)>0),i-1 DO BEGIN
    	kmin=max([j-i,0])
   	 	kmax=min([steps,steps+j-i])-1
   		eff=fltarr(steps)
    	err=fltarr(steps)
    	index=INDGEN(kmax-kmin+1)+kmin-j+i
    	secind=(WHERE((ave(j,index) GT low AND ave(j,index) LT high) AND (ave(i,index) GT low AND ave(i,index) LT high),count)) ; only valid steps for i AND j
		;IF NOT KEYWORD_SET(noprint) AND KEYWORD_SET(moreoutput) THEN printf,output,"---> step ",j,count
		;IF NOT KEYWORD_SET(noprint) AND KEYWORD_SET(moreoutput) THEN flush,output
    	IF count GT 0 THEN BEGIN
      		index=index(secind)                                   ; only valid steps for i AND j
      		eff(index)=eff(index)+ ave(i,index-i+j)/ ave(j,index)        ; ######### here was the great mistake! ########
      		err(index)=err(index)+(ave(i,index-i+j)*sdeviation(j,index)+ave(j,index)*sdeviation(i,index-i+j))/ave(j,index)/ave(j,index)
      		index=index(SORT(err(index)/eff(index)))
      		newerr=fltarr(count)
      		neweff=fltarr(count)
      		ind=indgen(count)
      		FOR k=0,count-1 DO BEGIN
        		neweff(k)=TOTAL(eff(index(0:k)))/FLOAT(k+1)
        		newerr(k)=TOTAL(err(index(0:k)))/FLOAT(k+1)/(FLOAT(k+1)/SQRT(k+1))
      		ENDFOR
      		minerr=min(newerr/neweff,k)
      		cellrelerr(i,j) =minerr
      		cellrelerr(j,i) =minerr
      		celleff(i,j)    =neweff(k)
      		cellefferr(i,j) =newerr(k)
      		IF neweff(k) NE 0 THEN celleff(j,i)=1./neweff(k) ELSE print,i,j,k,neweff(k)
      		cellefferr(j,i) =celleff(j,i)*minerr
			IF NOT KEYWORD_SET(noprint) AND KEYWORD_SET(moreoutput) THEN printf,output,i,j,celleff(i,j),cellefferr(i,j)
    	ENDIF 
		;IF NOT KEYWORD_SET(noprint) AND KEYWORD_SET(moreoutput) THEN printf,output,i,celleff(i,(i-2)>0:(i-1)>0),celleff(i,(i+1)<(cells-1):(i+2)<(cells-1))
  	ENDFOR                            ; j=min(cells,i+steps) 
  	plotindex=WHERE(celleff(i,*) GT 0,plotcount)
  	IF NOT KEYWORD_SET(noplot) AND plotcount GT 0 THEN BEGIN
  		IF plotflag EQ 0 THEN PLOT, plotindex,celleff(i,plotindex),xr=[0,1600],yr=[0.8,1.2] ELSE PLOT, plotindex,celleff(i,plotindex),xr=[0,1600],yr=[0.8,1.2],/NOERASE
  		plotflag=1
  	ENDIF
ENDFOR                            ; i=cells

PRINTF,output,'Cells out of limits:',ROUND(WHERE(TOTAL(cellefferr,1) EQ 0))
IF NbOfBadCells GE 1 THEN BEGIN
  celleff(bad,*)=celleff(bad,*)*0
  cellefferr(bad,*)=cellefferr(bad,*)*0
  cellrelerr(bad,*)=cellrelerr(bad,*)*0
  celleff(*,bad)=celleff(*,bad)*0
  cellefferr(*,bad)=cellefferr(*,bad)*0
  cellrelerr(*,bad)=cellrelerr(*,bad)*0
ENDIF
PRINTF,output,'Cells bad or out of limits: ',ROUND(WHERE(TOTAL(cellefferr,1) EQ 0))

;openw,effdat,'celleff.out',/get_lun
;printf,effdat,cells,cells
;printf,effdat,celleff
;printf,effdat,cellefferr
;printf,effdat,cellrelerr
;close,effdat
;free_lun,effdat

IF NOT KEYWORD_SET(noprint)  THEN printf,output
IF NOT KEYWORD_SET(noprint)  THEN printf,output,"*******************************************************************"
IF NOT KEYWORD_SET(noprint)  THEN printf,output,"************* Looking up best efficiency correlation **************"
minerr=fltarr(cells)
minind=intarr(cells)
med =REFORM(ave,cells*steps)
med=med(SORT(med))
med=med(cells*steps/2)
;print,'med',med
totave=TOTAL(ave(*,*),2)/N_ELEMENTS(ave(0,*))
FOR i=0,cells-1 DO BEGIN
  index=where(cellrelerr(i,*),count)          ; AND (ABS(celleff(i,*)-1.) LT 0.1),count)
  IF count GE 1 THEN BEGIN
    cellrelerr(i,index)=cellrelerr(i,index)*(ABS(celleff(i,index)-1.)+1.)*(ABS(totave(index)-med)*ABS(totave(i)-med)+med)
    minerr(i)=min(cellrelerr(i,index),j)
    ;print,i,totave(i),index(j),totave(index(j)),cellrelerr(i,index(j)),celleff(i,index(j)),cellefferr(i,index(j))
    j=index(j)
    minind(i)=j
  ENDIF 
ENDFOR
index=where(minerr,count)
minerr=min(minerr(index),i)
i=index(i)
j=minind(i)
;print,"min. error ",minerr, " for pair ",i,j
IF NOT KEYWORD_SET(noprint)  THEN flush,output
printf,output
printf,output,"************* Looked up best efficiency correlation ***************"
printf,output,"*******************************************************************"

printf,output,"********* Powder pattern reconstitution ***************"
pattern=fltarr(cells+steps-1)
error=  fltarr(cells+steps-1)
overlap=fltarr(cells+steps-1)
twotheta=findgen(cells+steps-1)*.1+datp.x(0,0)
newpattern=fltarr(cells+steps-1)
newerror=  fltarr(cells+steps-1)
patterncell=fltarr(cells+steps-1,steps)
eff=fltarr(cells)
err=fltarr(cells)
num=fltarr(cells)
start=i
n=0
oldeff=1
olderr=0
preceff=1
precerr=0
flag=intarr(cells)
flagref=intarr(1600)
refcount=0
count=cells
k=j
WHILE (n LT cells) AND (count GT 0) DO BEGIN
  eff(i)   =oldeff*preceff 
  err(i)   =olderr*preceff+oldeff*precerr  
  printf,output
  printf,output,'################################################################################'
	 printf,output,i,k,celleff(i,k),celleff(k,i),preceff
  printf,output,i,eff(i),err(i),ROUND(num(i)+1),k,preceff
  flush,output
  num(i)=num(i)+1
; ########## look for further references #############
  tmp=(1 EQ 1)
	 tmparr=fltarr(2*(steps-1))
	 tmparr(0)=eff(i)
	 tmpcounter=1
  WHILE refcount GT 0 AND tmp DO BEGIN   
    index=WHERE((cellefferr(i,*) NE 0.) AND (flag(*) EQ 1) AND (flagref(*) EQ 0),count)
    minerr=min(cellrelerr(i,index),k)
    k=index(k)
    refcount=count-1
    flagref(k)=1
    preceff=eff(k)
    precerr=err(k)                                          
    oldeff=celleff(i,k)
    olderr=cellefferr(i,k)
    neweff   = celleff(i,k)    * eff(k)
    neweff   =(neweff + num(i) * eff(i))/(num(i)+1)
    tmparr(tmpcounter)=neweff
		  newerr=mean_and_var(tmparr(0:tmpcounter))
		  newerr=SQRT(newerr(1)/(num(i)+1.))	
;   newerr   = cellefferr(i,k) * eff(k) + celleff(i,k) * err(k) 
;   newerr   =(newerr + num(i) * err(i))/(num(i)+1)/((num(i)+1)/sqrt((num(i)+2)))
    tmp=    ((newerr/neweff) LT (err(i)/eff(i)))
    nottmp= ((newerr/neweff) GE (err(i)/eff(i)))
    err(i)=tmp*newerr+(NOTtmp)*err(i)
    eff(i)=tmp*neweff+(NOTtmp)*eff(i)
    num(i)=num(i)+tmp*1
    printf,output,i,neweff,newerr,ROUND(num(i)),k,eff(k)
		  tmpcounter=tmpcounter+1
  ENDWHILE
; ########################################### Powder Pattern Reconstitution #######################################################
  index=indgen(steps)+i
  newpattern(index)  =(overlap(index)*pattern(index)+ ave(i,*)/eff(i))/(overlap(index)+1)
  tmp=patterncell(index,*) ;######### already ##############
 	tmp=[[tmp],[REFORM(ave(i,*)/eff(i),N_ELEMENTS(ave(i,*)))]]  
  tmparr=FLTARR(2,steps)
	 FOR tmpcounter=0,steps-1 DO BEGIN
		  tmptmp=WHERE(tmp(tmpcounter,*) NE 0,tmptmptmp)
	   IF tmptmptmp GT 0 THEN BEGIN
				  tmpvec=tmp(tmpcounter,tmptmp) 
	  	  tmpvec=REFORM(tmpvec,N_ELEMENTS(tmpvec))
	     tmparr(*,tmpcounter)=mean_and_var(tmpvec)
				ENDIF ELSE BEGIN
				  print,'Alert: Cell',i,' has no contribution for step',tmpcounter 
				ENDELSE
  ENDFOR
  newerror(index)=SQRT(tmparr(1,*)/(overlap(index)+1.))
; newerror  (i:i+steps-1)  =(overlap(i:i+steps-1)*  error(i:i+steps-1)+(err(i)*ave(i,*)+eff(i)*sdeviation(i,*))                 /eff(i)/eff(i))/(overlap(i:i+steps-1)+1)/((overlap(i:i+steps-1)+1)/sqrt((overlap(i:i+steps-1)+2)))
; newerror  (i:i+steps-1)  =(overlap(i:i+steps-1)*  error(i:i+steps-1)+(ABS(newpattern(i:i+steps-1)-pattern(i:i+steps-1)))/eff(i)/eff(i))/(overlap(i:i+steps-1)+1)/((overlap(i:i+steps-1)+1)/sqrt((overlap(i:i+steps-1)+2)))
; index =i+WHERE((ave(i,*) GT low AND ave(i,*) LT high) AND ((pattern(i:i+steps-1) EQ 0) OR ((newerror(i:i+steps-1)/newpattern(i:i+steps-1)) LE (error(i:i+steps-1)/pattern(i:i+steps-1)))),count)
  index =i+WHERE(newerror(index) NE 0 AND ((pattern(index) EQ 0) OR ((newerror(index)/newpattern(index)) LE (error(index)/pattern(index)))),count)
  printf,output,newpattern(i:i+(steps-1<5))
  printf,output,newerror  (i:i+(steps-1<5))
  printf,output,   pattern(i:i+(steps-1<5))
  printf,output,   error  (i:i+(steps-1<5))
  IF count GT 0 THEN BEGIN
    overlap(index)=overlap(index)+1
    pattern(index)=newpattern(index)
    error(index)  =newerror(index)
    patterncell(index,index-i)=pattern(index)
    printf,output,'Using',i,index(0:N_ELEMENTS(index)-1<4)
    IF NOT KEYWORD_SET(noplot) THEN BEGIN
  		PLOT,twotheta(WHERE(pattern)),pattern(WHERE(pattern)),xrange=[min(twotheta),max(twotheta)],yrange=[low,high],psym=3
	  	OPLOTERR,twotheta(WHERE(pattern)),pattern(WHERE(pattern)),error(WHERE(pattern)),3
    ENDIF
  ENDIF ELSE printf,output,'Not using',i
  out=pattern
  flag(i)=1
  n=n+1
  IF n LT cells THEN BEGIN
    ; #################### look for successor of cell i #######################################################
    index=WHERE((cellefferr(i,*) NE 0.) AND (flag(*) NE 1),count)
    ;print,n,count,' good successors'
    IF count EQ 0 THEN BEGIN
      index=WHERE(TOTAL(cellefferr,2) AND (flag(*) NE 1),count)
      ;PRINT,n,count,' -',index
      IF count NE 0 THEN BEGIN
        flagsum=intarr(N_ELEMENTS(index))
        for l=0,N_ELEMENTS(index)-1 DO flagsum(l)=TOTAL(flag ((index(l)-steps)>0: ( (index(l)+steps)<cells) -1)) 
        secind=(WHERE(flagsum,count))
        IF count NE 0 THEN BEGIN
          maxref=max(flagsum,j)
          j=index(j)
          ;PRINT,n,count,j
        ENDIF ELSE BEGIN
          n=(count EQ 0)*cells + (count NE 0)*n
          PRINTf,output,n,count,' The End - Not considered cells:',WHERE(flag(*) NE 1,count)
        ENDELSE
      ENDIF ELSE BEGIN
        n=(count EQ 0)*cells + (count NE 0)*n
        PRINTf,output,n,count,' Another End - Not considered cells:',WHERE(flag(*) NE 1,count)
      ENDELSE
    ENDIF ELSE BEGIN
      minerr=min(cellrelerr(i,index),j)
      j=index(j)
    ENDELSE
    ; ############## look for first and best reference ################
    IF count NE 0 THEN BEGIN
      flagref=intarr(1600)
      index=WHERE((cellefferr(j,*) NE 0.) AND (flag(*) EQ 1),count)
      IF count GT 0 THEN BEGIN
        minerr=min(cellrelerr(j,index),k)
        k=index(k)
        refcount=count-1
        flagref(k)=1
        oldeff=celleff(j,k)
        olderr=cellefferr(j,k)
        preceff=eff(k)
        precerr=err(k)
        i=j
      ENDIF
    ENDIF
  ENDIF
ENDWHILE

w_tit=datp.w_tit
mod_datp,datp,'w_tit',w_tit+": resulting diffractogram"
mod_datp,datp,'y_tit',"counting rate per single ACQ"
mod_datp,datp,'x',twotheta
mod_datp,datp,'e',error
mod_datp,datp,'n',overlap
give_datp,datp
openw,pat,'pattern.out',/get_lun
printf,pat,cells+steps-1
printf,pat,twotheta,pattern,error,overlap
printf,pat,w_tit+": resulting diffractogram"
printf,pat,datp.other_tit
printf,pat,datp.x_tit,"counting rate per single ACQ"
close,pat
free_lun,pat
;ploterr,twotheta,pattern,error
IF KEYWORD_SET(eff) THEN BEGIN
  mod_datp,datp,'w_tit',w_tit+": resulting efficiencies"
  mod_datp,datp,'x_tit',"cell number"
  mod_datp,datp,'y_tit',"efficiency 1/alpha"
  mod_datp,datp,'x',indgen(cells)
  mod_datp,datp,'e',err
  mod_datp,datp,'n',num
  give_datp,datp,/third
ENDIF
openw,effdat,'eff.out',/get_lun
printf,effdat,cells
printf,effdat,indgen(cells),eff,err,num
printf,effdat,w_tit+": resulting efficiencies"
printf,effdat,datp.other_tit
printf,effdat,"cell number"
printf,effdat,"efficiency 1/alpha"
close,effdat
free_lun,effdat
IF NOT KEYWORD_SET(noprint) THEN close,output
IF NOT KEYWORD_SET(noprint) THEN free_lun,output
RETURN,out
END
pro calsan
print,'Starting calibration of san....'
prin=0
dpr=180./!pi


count=10
;rdan=2.3

dbtrs=5
range=2.
points=15.
shif=2
nx=1.
pcen=138.98/nx
mmpp=1.0357*nx 


;  use existing value of san for the calibration unless it is zero

   m=DIAL_MAD_READ('motors')
   if (m(2) lt 0.4) then begin
     san=0.4
   endif else begin
     san=m(2)
   endelse
   det=m(15)
   rdan=2.5*3400./det
   dbdan=rdan-2.*san   

   print,'Taking a run with the direct beam'

   mv,'dan',dbdan
   mv,'dan',dbdan
   mv,'trs',dbtrs
   mv,'san',0

   co,count,'t n'
   
   m=DIAL_MAD_READ('motors')
   d0=m(16)
   print,'dan error was dan-true=',dbdan-d0
   d17data,data
   s=size(data)
   if s(0) gt 1 then data=total(data,2)
   d=max(data,p0)


   yy=gaussfit(findgen(s(1)),data,a)
   pp0=a(1)
   print,'direct beam pixel fit:',pp0
   
   
;   take a run at the peak and calculate th

   print,'Taking a run with a reflection'

   mv,'trs',-.5
   mv,'trs',0.
   mv,'san ',0.0
   mv,'san',san
   mv,'dan',rdan
   mv,'dan',rdan
   co,count,'t n'
   m=DIAL_MAD_READ('motors')
   wait,.2
   dr=m(16)
   print,'dan error was dan-true=',rdan-dr
   d17data,data
   s=size(data)
   if s(0) gt 1 then data=total(data,2)
   d=max(data,pr)

   yy=gaussfit(findgen(s(1)),data,a)
   ppr=a(1)
   print,'reflection pixel maximum fit:',ppr
   print,'reflection pixel gauss fit:',a(1)


   ; now calculate th
   
   det=m(15)
   th=(dr+dpr*atan((pcen-ppr)*mmpp/det))/2-(d0+dpr*atan((pcen-pp0)*mmpp/det))/2

   print,'found theta is: ',th,' deg.'
   
   sanstr=strtrim(string(th),2)
   d17mad,'par set san '+sanstr
   

   print,'..and set san to that value'
   print,' your error (san-th) was :',san-th,' deg.'

;put motors back for reflection condition

   mv,'dan',rdan
   mv,'trs',-0.5
   mv,'trs',0
   mv,'san',san

end
;pro calth
pro th,n1,n2,tt

data_read,n1,w1,mon,y,m,q,th,san,d0,det,nx


data_read,n2,w2,mon,y,m,q,th,san,dr,det,nx


a=max(total(w1,2),p0)

b=max(total(w2,2),pr)

step=5

k=0.
kk=0.
print,'com direct :',p0-step,p0+step
for i=p0-step,p0+step do begin
  k=k+total(w1(i,*),2)
  kk=kk+total(w1(i,*),2)*float(i)

endfor

pp0=kk/k


l=0.
ll=0.
for i=pr-step,pr+step do begin
  l=l+total(w2(i,*),2)
  ll=ll+total(w2(i,*),2)*i
endfor
ppr=ll/l


dpr=180./!pi

pcen=135.79/nx
mmpp=1.04*nx

print,'det: ',det,' X grouping: ',nx
print,'detector centre: ',pcen,' mmpp: ',mmpp
print,'reflection dan: ',dr,' direct beam dan: ',d0
print,'reflection pixel:',ppr,' direct pixel:',pp0

print,'ref th= ',(dr+dpr*atan((pcen-ppr)*mmpp/det))/2-(d0+dpr*atan((pcen-pp0)*mmpp/det))/2
tt=(dr+dpr*atan((pcen-ppr)*mmpp/det))/2-(d0+dpr*atan((pcen-pp0)*mmpp/det))/2
return
end


pro calth_event,event
;** ************
;**
	COMMON local,nparams,whatwid
	
	pars=intarr(nparams)
        
      	wWidget =  Event.top

        WIDGET_CONTROL,event.id,get_uvalue=gv

        if(gv eq 'quit')then widget_control,event.top,/destroy

        if(gv eq 'do')then begin
	FOR i=0,nparams-1 DO BEGIN
          Widget_Control, whatwid(i), GET_VALUE=gv
	  pars(i)=STRTRIM(gv,2)
	  
        ENDFOR
	
	th,pars(0),pars(1),tt
	Widget_Control, whatwid(nparams-1), SET_VALUE=strtrim(string(tt),2)
	endif

end

pro send_command, event,i
;** ************
;**
	Widget_Control, event.id, GET_VALUE=gv
	gv=STRTRIM(gv,2)
;	command=fix(gv)
	  
	print, gv

end

PRO calth
COMMON local,nparams,whatwid
nparams=3
whatwid=intarr(nparams)
result='xxx'
param=intarr(nparams)
                param_text=STRARR(nparams)
		param_text(0) ='Direct beam numor'
		param_text(1) ='Reflection numor'
		param_text(2) ='Calculated theta'
		
		
		
                D17S_BASE_4=Widget_Base(UNAME='D17S_BASE_4',TITLE="Enter Values" $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
		D17S_BASE_0=Widget_Base(D17S_BASE_4,UNAME='D17S_BASE_0' $
			,SPACE=3,XPAD=3,YPAD=3,/ROW)
		D17S_BASE_1=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_1' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)




		D17S_BASE_2=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_2' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
		D17S_BASE_3=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_3' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)

                gbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='gbutton' $
			, value='Do it',uvalue='do')
		fbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='fbutton' $
			, value='Quit',uvalue='quit')
			
		
				
			
		FOR i=0,nparams-1 DO BEGIN 
  			name= 'D17S_LABEL_'+STRTRIM(STRING(i+1),2) 
  			dummy = Widget_Label(D17S_BASE_2, UNAME=name,XOFFSET=3   $ 
     	 		,YOFFSET=3, SCR_YSIZE=33,/ALIGN_LEFT ,VALUE=param_text(i) $
			,FONT=ft_smaller)
  	  	ENDFOR
		

		
		FOR i=0,nparams-1 DO BEGIN 
  			name='D17S_VALUE_'+STRTRIM(STRING(i+1),2) 
  			 whatwid(i)= Widget_Text(D17S_BASE_3, UNAME=name ,FRAME=1  $ 
     			,XOFFSET=3 ,YOFFSET=3 ,SCR_XSIZE=100 ,SCR_YSIZE=29 $
			,/EDITABLE ,VALUE=STRTRIM(STRING(param(i)),2) $
			,FONT=ft_smaller) 
  	  	ENDFOR


		Widget_Control,/REALIZE,D17S_BASE_3
		loadct, 5
		XMANAGER, 'calth',D17S_BASE_0,/JUST_REG

end
pro catalog, path , year_trim , inst ,return_cat ,return_mod ,return_fix
;** *******
;** Used by the TOUCH_BASE interface.
;** This procedure returns a catalog of data-file series formatted as follow:
;**	"004278 004862 16-JAN-95 exper_nam1"
;**	"004863 004901 21-FEB-95 exper_nam2"
;**	   .
;**	   .
;**	   .
;** The lenght of numors is defined by the Magic-number in CUSTOMIZE (6 in this case).
;** The date is 9 char length.
;** The experiment name is 10 char length.

;** return_mod=1 if TOUCH_BASE must add the sub_directory "inst" to the path (path/inst)
;**      else =0 (NOTE:in CUSTOMIZE, if a database label contains the string "Cycle" then LAMP does the same)
;** return_fix(0) is a prefix for numors or '' (ex: spec004863)
;** return_fix(1) is a suffix for numors or '' (ex: spec004863.dat)

;** path is defined in TOUCH_MANAGE but generaly you have to change its content.
;** inst is the choosen format(or instrument).
;** year_trim is "963" for the third cycle of 1996.

;THE FOLLOWING CODE IS USED AT I.L.L.
;*** ********* **** ** **** ** ******
;SPAWN,'cat '+path+'/DATA_CATALOG |grep " '+year_trim + ' " |grep " '+inst+' "' ,return_cat
;return_mod   =1
;return_fix(0)=''
;return_fix(1)=''

;THE FOLLOWING CODE IS USED AT H.M.I.
;*** ********* **** ** **** ** ******
;return_mod   = 0
;return_fix(0)='V5_'
;return_fix(1)='.dat'
;path	      ='[PAPPAS.LOCAL_DATA]'
;return_cat   = ['04278 04862 16-JAN-97 exper_nam1',
;		 '04863 04901 21-FEB-97 exper_nam2'] ;See that magic-number=5

PRINT,string(7b)+' YOU MAY UPDATE catalog.pro IN THE DIRECTORY lamp/lamp_mac !!!!!!'
PRINT,string(7b)+' THE PUZZLE ...'
end
PRO cathod_3d,x,y,a,f,ps=ps,shade=shade,portrait=portrait,landscape=landscape,noclet=noclet
;a0 factor,
;a1 t0,
;a2 sigma
;a3 capture_ratio,
;a4 gamma_ratio,
;a5 gamma_exp,
;a6 trace/cell_width,
;a7 NO_CLET=0/CLET=1

take_datp,datp
start_angle = 5.
stop_angle  = 85.
step_angle  = 10.
start = .05
stop  = .95
step  = .1
inside_counter=ABS((stop-start)/step)*ABS((stop_angle-start_angle)/step_angle)
IF KEYWORD_SET(noclet) THEN BEGIN
  start = start-a(6)
  stop  = stop +a(6)
ENDIF
x=x(*,0)
y=findgen(ABS((stop-start)/step))*step+start
counter=ABS((stop-start)/step)*ABS((stop_angle-start_angle)/step_angle)
IF KEYWORD_SET(noclet) THEN clet=' without CLET ' ELSE clet=' with CLET '
IF KEYWORD_SET(noclet) THEN name='3d_cathod_pure.ps' ELSE name='3d_cathod_clet.ps'
IF KEYWORD_SET(noclet) THEN a=[a,0.] ELSE a=[a,1.] 
f=fltarr(N_ELEMENTS(x(*,0)),N_ELEMENTS(y(*,0)))
w=x*0.0

FOR j = 0,ABS((stop-start)/step)-1 DO BEGIN
FOR   i = start_angle,stop_angle,step_angle DO BEGIN
    project  = SIN(i/180.*!PI)*a(6)
    tt       = a(1) * (min([y(j),project/2.]) + min([(1.-y(j)),project/2.])) / project
    abbruch,x,[a(0),tt,a(2:5)],w
    ;print,i,j,tt
    f(*,j) = f(*,j) + w/inside_counter
  ENDFOR
ENDFOR
IF KEYWORD_SET(ps) THEN BEGIN
  IF NOT KEYWORD_SET(portrait) THEN portrait=0 ELSE landscape=0
  IF NOT KEYWORD_SET(landscape) THEN landscape=0
  i=1
  ff=total(f,2)
  xdim = N_ELEMENTS(x)
  ydim = N_ELEMENTS(y)
  WHILE ff(i) LE ff(i-1) AND i LT N_ELEMENTS(ff) DO i = i+1
  IF NOT (i LT N_ELEMENTS(ff)) THEN i=0
  SET_PLOT,'ps'
  DEVICE,FILENAME=name,/COLOR,BITS_PER_PIXEL=256,portrait=portrait,landscape=landscape
  IF KEYWORD_SET(shade) THEN $
  SHADE_SURF,f(i-1:xdim-1,0:ydim-1),x(i-1:xdim-1),y,$
    TITLE='3D-Amplitude histogram for detector cathod'+clet+systime(),$
    xRANGE=[0,max(x)],$
    ZRANGE=[0,max(f(i:N_ELEMENTS(f(*,0))-1,*))],$
    ZTITLE='Number of counts',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5) $
  ELSE $
  SURFACE,f(i-1:xdim-1,0:ydim-1),x(i-1:xdim-1),y,$
    TITLE='3D-Amplitude histogram for detector cathod'+clet+systime(),$
    xRANGE=[0,max(x)],$
    ZRANGE=[0,max(f(i:N_ELEMENTS(f(*,0))-1,*))],$
    ZTITLE='Number of counts',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5) 

  DEVICE,/CLOSE
  SET_PLOT,'x'
ENDIF
mod_datp,datp,'w_tit','3D-Amplitude histogram for detector cathod'+clet+systime()
mod_datp,datp,'other_tit','hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,4)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
give_datp,datp
END
PRO cathod,x,a,y,ps=ps,portrait=portrait,landscape=landscape,noclet=noclet,$
           left=left,right=right,counts=counts
;a0 factor,
;a1 t0,
;a2 sigma
;a3 capture_ratio,
;a4 gamma_ratio,
;a5 gamma_exp,
;a6 trace/cell_width,
;a7 NO_CLET=0/CLET=1

take_datp,datp
w=x*0.0
y=x*0.0
start_angle =  5.0
stop_angle  = 85.0
step_angle  =  10.0
start = .05
stop  = .95
step  = .10
;inside_counter=ABS((stop-start)/step)*(ABS((stop_angle-start_angle)/step_angle))
inside_counter=ABS((stop-start)/step)*(ABS((stop_angle-start_angle)/step_angle))^2
print,'Steps: ',inside_counter
IF KEYWORD_SET(noclet) THEN BEGIN
  start = start-a(6)
  stop  = stop +a(6)
ENDIF
counter=ABS((stop-start)/step)*ABS((stop_angle-start_angle)/step_angle)
IF KEYWORD_SET(noclet) THEN clet =' without CLET ' ELSE clet =' with CLET '
IF KEYWORD_SET(noclet) THEN name ='cathod_pure.ps' ELSE name ='cathod_clet.ps'
IF KEYWORD_SET(noclet) THEN a    = [a(0:6), 0.]    ELSE a    = [a(0:6), 1.] 
counts=fltarr(N_ELEMENTS(x))
canals=N_ELEMENTS(w)
IF KEYWORD_SET(right) THEN k_right=where(x GE right)
IF KEYWORD_SET(left)  THEN k_left =where(x GE left)
FOR j = start,      stop,      step       DO BEGIN
  FOR   i = start_angle,stop_angle,step_angle DO FOR   ii= start_angle,stop_angle,step_angle DO BEGIN
  ;FOR   i = start_angle,stop_angle,step_angle DO BEGIN
    project  = SIN(i/180.*!PI)*a(6) ; *SIN(ii/180.*!PI)
    tt       = a(1) * (min([(j+project/2.),1.]) - max([(j-project/2.),0.])) / project
    IF tt GE 0. THEN BEGIN
      abbruch,x,[a(0),tt,a(2:5)],w
      y=y+w/inside_counter
      I_mid = fltarr(canals)
      FOR l=0,canals-1 DO I_mid(l)=total(w(l:canals-1)*x(l:canals-1))/x(l)
      I_left = 0.
      IF KEYWORD_SET(left) THEN BEGIN
        tt_left       = a(1) * (-min([j-project/2.,0.])) / project
        IF (tt_left) GT (0) THEN BEGIN 
          abbruch,x,[a(0),tt_left,a(2:5)],w_left
          ;FOR k=0,canals-1 DO IF x(k) GE left THEN I_left = I_left + w_left(k) * x(k) / left 
          I_left= total(w_left(k_left) * x(k_left))/left
        ENDIF ELSE I_left=0.
      ENDIF
      I_right = 0.
      IF KEYWORD_SET(right) THEN BEGIN
        tt_right       = a(1) * (max([j+project/2.-1.,0.])) / project
        IF (tt_right) GT (0) THEN BEGIN
          abbruch,x,[a(0),tt_right,a(2:5)],w_right
          ;FOR k=0,canals-1 DO IF x(k) GE right THEN I_right = I_right + w_right(k) * x(k) / right 
          I_right= total(w_right(k_right) * x(k_right))/right
        ENDIF ELSE I_right=0.
        IF KEYWORD_SET(left) THEN BEGIN
          PRINT,j,i,ii,project,tt
          ;PRINT,i,j,project,tt
          ;PRINT,' ',tt_left,I_left,tt_right,I_right
        ENDIF
      ENDIF
      signals=fltarr(canals)
      FOR k=0, canals-1 DO signals(k) = TOTAL (w (k:canals-1))/inside_counter/canals
      ;count_flag = fltarr(canals)
      ;count_flag(where((I_mid GT I_left) AND (I_mid GT I_right))) = 1.
      ;counts = counts + count_flag * signals
      counts = counts + I_mid/(I_mid+I_left+I_right) * signals
      ;IF KEYWORD_SET(right) THEN print,I_mid(k_right)/(I_mid(k_right)+I_left+I_right)
      ;IF KEYWORD_SET(right) THEN plot,x,I_mid(k_right)/(I_mid(k_right)+I_left+I_right),yrange=[0,1]
      plot,x,I_mid/(I_mid+I_left+I_right) * signals ;,yrange=[0,1]
    ENDIF
  ENDFOR
  ;plot,x,counts,yrange=[0,1000]
ENDFOR
IF KEYWORD_SET(ps) THEN BEGIN
  IF NOT KEYWORD_SET(portrait) THEN portrait=0 ELSE landscape=0
  IF NOT KEYWORD_SET(landscape) THEN landscape=0
  i=1
  WHILE y(i) LE y(i-1) AND i LT N_ELEMENTS(y) DO i = i+1
  IF NOT (i LT N_ELEMENTS(y)) THEN i=0
  SET_PLOT,'ps'
  DEVICE,FILENAME=name,portrait=portrait,landscape=landscape
  PLOT,x,y,$
    TITLE='Amplitude histogram for detector cathod'+clet+systime(),$
    YRANGE=[0,max(y(i:N_ELEMENTS(y)-1))],$
    YTITLE='Number of counts',$
    XTITLE='Signal amplitude',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
  DEVICE,/CLOSE
  SET_PLOT,'x'
ENDIF
mod_datp,datp,'w_tit','Amplitude histogram for detector cathod'+clet+systime()
mod_datp,datp,'other_tit','hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,4)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
give_datp,datp
END
PRO cellno,i
;+
; PURPOSE: 
; This little procedure prints out the corresponding box- and amplifier-number for a given PSD-cell on D20
; INPUT:
; PSD cell number
; OUTPUT:
; Prints out a line in the basic IDL terminal window
; EXAMPLE: 
; cellno,120
;-
print,'cell',i,', box',i/32,', ampli',(i mod 32)*(((i/32) mod 2)ne 0)+(31 - i mod 32)*(((i/32) mod 2) eq 0)

END
pro cell,s,cell,_extra=extra,index=index,counts=counts,$
             noplot=noplot,oplot=oplot,error=error

index=indgen(N_ELEMENTS(s(0,*)))+cell
counts=s(cell,*)
IF NOT KEYWORD_SET (noplot) THEN BEGIN
  IF KEYWORD_SET(oplot) THEN BEGIN
    oplot,index,counts,_extra=extra
  ENDIF ELSE plot,index,counts,_extra=extra
  IF KEYWORD_SET(error) THEN BEGIN
    oplot,index,counts+SQRT(counts),psym=3,_extra=extra
    oplot,index,counts-SQRT(counts),psym=3,_extra=extra
  ENDIF
ENDIF
end
pro chopper_visu


; Written by F. Descamps 1999

loadct,4

;Opens the window 
window,0,xsize=600,ysize=400,title='Chopper Visu D17b',retain=2
erase,32

histo1=intarr(1000)
histo2=intarr(1000)
ite=0

while(get_kbrd(0) NE 'q') do begin

; gets the parameters

rpm1=700
rpm2=700
phase1=180.00
phase2=180.00
pres1=10
pres2=10
phi1long=ite*2;
phi2long=571;

l1phi=0.3;
l2phi=0.25;



phi1=fix((float(phi1long)*float(rpm1)*6.0/24000000.0)*1000/l1phi)+500
phi2=fix((float(phi2long)*float(rpm2)*6.0/24000000.0)*1000/l2phi)+500

if(phi1 GE 0) AND (phi1 LT 1000) then histo1(phi1)=histo1(phi1)+1
if(phi2 GE 0) AND (phi2 LT 1000) then histo2(phi2)=histo2(phi2)+1

if(ite EQ 100) then begin
; display the parameters


polyfill,[400,595,595,400],[5,5,395,395],color=48,/device
plots,[400,595,595],[5,5,395],color=0,/device,thick=3
plots,[595,400,400],[395,395,5],color=64,/device,thick=3
; chopper1

xyouts,410,370,'Chopper 1 status',/device,charthick=2,charsize=1.5,color=219
xyouts,415,350,'Speed'+string( rpm1)+' rpm',/device,charthick=1,charsize=1.1,color=219
xyouts,415,335,'Phase'+string( phase1)+' deg',/device,charthick=1,charsize=1.1,color=219
xyouts,415,320,'Precision'+string( pres1)+' mdeg',/device,charthick=1,charsize=1.1,color=219

xyouts,410,200,'Chopper 2 status',/device,charthick=2,charsize=1.5,color=219
xyouts,415,170,'Speed'+string( rpm2)+' rpm',/device,charthick=1,charsize=1.1,color=219
xyouts,415,155,'Phase'+string( phase2)+' deg',/device,charthick=1,charsize=1.1,color=219
xyouts,415,140,'Precision'+string( pres2)+' mdeg',/device,charthick=1,charsize=1.1,color=219


polyfill,[420,575,575,420],[15,15,55,55],color=127,/device
polyfill,[420,575,575,420],[55,55,95,95],color=95,/device



; converts data into histo bin


phi1=fix((float(phi1long)*float(rpm1)*6.0/24000000.0)*1000/l1phi)+500
phi2=fix((float(phi2long)*float(rpm2)*6.0/24000000.0)*1000/l2phi)+500



if(phi1 GE 0) AND (phi1 LT 1000) then histo1(phi1)=histo1(phi1)+1
if(phi2 GE 0) AND (phi2 LT 1000) then histo2(phi2)=histo2(phi2)+1

plot,(indgen(1000)-500)/1000.0*l1phi,histo1,position=[30,230,385,395],/device,/noerase,xstyle=1,ystyle=4
plot,(indgen(1000)-500)/1000.0*l2phi,histo2,position=[30,30,385,205],/device,/noerase,xstyle=1,ystyle=4
ite=0
end;
ite=ite+1
end;



end; chopper visupro chores,d,dd,T,p,res,trans,lam

;   macro to calculate the transmission and fractional resolution for a
;given TOF distance D, chopper period T, separation DD and phase angle p




lmin=0.
lmax=39.
nn=300
k=3956.


dl=(lmax-lmin)/nn

res=fltarr(nn)
trans=fltarr(nn)
lam=findgen(nn)*dl+lmin

for i=0,nn-1  do begin
  dt=(dd*(lmin+i*dl)/k)+(p/360.)*T
  res(i)=dt/(d*(lmin+i*dl)/k)
  trans(i)=dt/T
endfor

end





PRO clreff
common calibration
inf_d20=0
print,'List of calibration files cleared, will be re-created and re-read'
END

PRO clrbad
common calibration
common d20
psd_d20=['empty']
print,'List of bad_cells files cleared, will be re-created and re-read'
END

PRO clear
;+
; NAME:
;	CLEAR
;
; PURPOSE:
;	Resets automatic efficiency and angular correction file and bad cells
;   To be used whenever a new calibration file is provided during an open
;   LAMP session for a D20 experiment in order to take into account these
;   new files for any new data read in. It avoids restarting LAMP.
;   Attention: Any data already read in in a workspace has been corrected
;   according to the previous list of correction files.
;
; CATEGORY:
;	User
;
; CALLING SEQUENCE:
;	clear
;
; INPUTS:
;	none
;
; OPTIONAL INPUTS:
;	none.
;	
; KEYWORD PARAMETERS: 
;   none
;
; OUTPUTS:
;	none
;
; OPTIONAL OUTPUTS:
;	none
;
; COMMON BLOCKS:
;	none
;
; SIDE EFFECTS:
;	none
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
;	clreff and clrbad
;
; EXAMPLE:
;  clear
;
; MODIFICATION HISTORY:
; 	Written by:	Thomas Hansen
;	September, 2002	comments
;-
clreff
clrbad
END
PRO clet_compare, a=a,cp=cathod_pure, cc=cathod_clet,$
                  cp3d=cathod_pure_3d, cc3d=cathod_clet_3d, $
                  sp=signal_pure,sc=signal_clet,x=x,yc=y_clet,yp=y_pure,$
                  ps=ps,portrait=portrait,landscape=landscape,$
                  left=left,right=right,counts=counts
;a0 factor,
;a1 t0,
;a2 sigma
;a3 capture_ratio,
;a4 gamma_ratio,
;a5 gamma_exp,
;a6 trace/cell_width,
;a7 NO_CLET=0/CLET=1

IF NOT KEYWORD_SET(x)         THEN x=(findgen(100)+1)/1.
IF NOT KEYWORD_SET(a)         THEN a=[3450,106,10.,.27,240,3.5,1.4]
IF NOT KEYWORD_SET(ps)        THEN ps=0
IF NOT KEYWORD_SET(portrait)  THEN portrait=0 ELSE landscape=0
IF NOT KEYWORD_SET(landscape) THEN landscape=0
IF NOT KEYWORD_SET(left)      THEN left=0
IF NOT KEYWORD_SET(right)     THEN right=0
IF NOT KEYWORD_SET(counts)    THEN counts=0

cathod,x,a,cathod_clet,ps=ps,landscape=landscape,portrait=portrait
cathod,x,a,cathod_pure,ps=ps,landscape=landscape,portrait=portrait,/noclet,left=left,right=right,counts=counts

y=cathod_pure
IF KEYWORD_SET(ps) THEN BEGIN
  i=1
  WHILE y(i) LE y(i-1) AND i LT N_ELEMENTS(y) DO i = i+1
  IF NOT (i LT N_ELEMENTS(y)) THEN i=0
  SET_PLOT,'ps'
  DEVICE,FILENAME='cathod.ps',portrait=portrait,landscape=landscape
  PLOT,x,y,$
    TITLE='Amplitude histogram for detector cathod with/without CLET '+systime(),$
    YRANGE=[0,max(y(i:N_ELEMENTS(y)-1))],$
    YTITLE='Number of counts',$
    XTITLE='Signal amplitude',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
  yy=cathod_clet
  PLOT,x,yy,/noerase,$
    TITLE='Amplitude histogram for detector cathod with/without CLET '+systime(),$
    YRANGE=[0,max(y(i:N_ELEMENTS(y)-1))],$
    YTITLE='Number of counts',$
    XTITLE='Signal amplitude',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
  DEVICE,/CLOSE
  SET_PLOT,'x'
ENDIF

signal_clet=signal_cathod(cathod_clet,a,x=x,ps=ps,landscape=landscape,portrait=portrait)
signal_pure=signal_cathod(cathod_pure,a,x=x,ps=ps,landscape=landscape,portrait=portrait)

y=signal_pure
IF KEYWORD_SET(ps) THEN BEGIN
  SET_PLOT,'ps'
  DEVICE,FILENAME='signal.ps',portrait=portrait,landscape=landscape
  PLOT,x,y,$
    TITLE='Integrated counts for detector cathod with/without CLET'+systime(),$
    YRANGE=[0,max(y)],$ 
    YTITLE='Number of counts',$
    XTITLE='Threshold',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
  yy=signal_clet
  PLOT,x,yy,/NOERASE,$
    TITLE='Integrated counts for detector cathod with/without CLET'+systime(),$
    YRANGE=[0,max(y)],$ 
    YTITLE='Number of counts',$
    XTITLE='Threshold',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
  DEVICE,/CLOSE
  SET_PLOT,'x'
ENDIF

cathod_3d,x,y_clet,a,cathod_clet3d, ps=ps,landscape=landscape,portrait=portrait
cathod_3d,x,y_pure,a,cathod_pure_3d,ps=ps,landscape=landscape,portrait=portrait,/noclet

END
PRO click,w,xrange=xrange,yrange=yrange

take_datp,datp
IF NOT KEYWORD_SET(xrange) THEN xrange=[min(datp.x),max(datp.x)]
IF NOT KEYWORD_SET(yrange) THEN yrange=[min(w),max(w)]
colors,color
Window,1,title='Click outside the plotrange to stop!'
;help,datp.x,w
plot,datp.x,w,xstyle=1,ystyle=1,back=color(4),col=color(0),xr=xrange,yr=yrange
x1=!x.crange(0)
x2=!x.crange(1)
y1=!y.crange(0)
y2=!y.crange(1)
x=x1
y=y1
REPEAT BEGIN 
  CURSOR,x,y,/DOWN 
  IF x GE x1 AND x LE x2 AND y GE y1 AND y LE y2 THEN BEGIN
    print,x,w(WHERE(round(10.*x) EQ round(10.*datp.x)))
    PLOTS,[x,x],[y,w(WHERE(round(10.*x) EQ round(10.*datp.x)))],COLOR=COLOR(2)
    xyouts,x,y,STRCOMPRESS(x)+STRCOMPRESS(w(WHERE(round(10.*x) EQ round(10.*datp.x)))),COLOR=COLOR(1),CHARSIZE=.8 
  ENDIF
ENDREP UNTIL x LT x1 OR x GT x2 OR y LT y1 OR y GT y2 

END
PRO colors,color,TRUECOLORs=truecolors,noprint=noprint,pseudo=pseudo

color=intarr(8)
mydevice=!D.NAME
IF mydevice EQ 'PS' OR mydevice EQ 'TEK' THEN DEVICE,/COLOR
IF mydevice EQ 'TEK' THEN DEVICE,/TEK4100
IF mydevice EQ 'PS' OR mydevice EQ 'X' OR mydevice EQ 'TEK' THEN BEGIN
  TVLCT,red,green,blue,/get
  IF NOT KEYWORD_SET(noprint) THEN PRINT,'Color bits : ',N_ELEMENTS(red)
  TVLCT,[0,255,0,0,255,255,0],[0,0,255,0,255,0,255],[0,0,0,255,0,255,255]
  white=255
  color=[indgen(4),255,indgen(3)+4]
ENDIF ELSE BEGIN
  IF mydevice EQ 'MAC' THEN BEGIN
    TVLCT,red,green,blue,/get
    bit=LONG(N_ELEMENTS(red))
    IF NOT KEYWORD_SET(noprint) THEN PRINT,'Color bits : ',N_ELEMENTS(red)
    white=bit^3-1
    IF NOT KEYWORD_SET(noprint) THEN print,white
    color=[0,bit-1,bit^2-bit,bit^3-bit^2,white,bit^2-1,white-(bit^2-bit),white-bit+1]
    IF NOT KEYWORD_SET(noprint) THEN print,color
  ENDIF ELSE PRINT,mydevice, ' not yet supported!'
ENDELSE
IF KEYWORD_SET(TRUECOLORS) THEN BEGIN
    TVLCT,red,green,blue,/get
    bit=LONG(N_ELEMENTS(red))
    IF NOT KEYWORD_SET(noprint) THEN PRINT,'Color bits : ',N_ELEMENTS(red)
    white=bit^3-1
    IF NOT KEYWORD_SET(noprint) THEN print,white
    color=[0,bit-1,bit^2-bit,bit^3-bit^2,white,bit^2-1,white-(bit^2-bit),white-bit+1]
    IF NOT KEYWORD_SET(noprint) THEN print,color
ENDIF
IF KEYWORD_SET(pseudo) THEN BEGIN
  TVLCT,red,green,blue,/get
  IF NOT KEYWORD_SET(noprint) THEN PRINT,'Color bits : ',N_ELEMENTS(red)
  TVLCT,[0,255,0,0,255,255,0,255],[0,0,255,0,255,0,255,255],[0,0,0,255,0,255,255,255]
  white=7
  color=[indgen(4),7,indgen(3)+4]
ENDIF
IF NOT KEYWORD_SET(noprint) THEN PRINT,'black-red-green-blue-white-yellow-magenta-cyan',STRCOMPRESS(color)

END
FUNCTION combi, w1, w2, dim

take_datp,p1
take_datp,p2,/third

cells=N_ELEMENTS(w1(*,0,0))
inner=N_ELEMENTS(w1(0,*,0))
outer=N_ELEMENTS(w1(0,0,*))

IF N_PARAMS() LT 3 THEN BEGIN
  dim=2
		IF outer GT 1 THEN dim=3
ENDIF

IF dim EQ 1 THEN BEGIN
  print,'Concatenation in one dimensions (funny)'
  w =[w1   ,w2   ]
  e =[p1.e ,p2.e ]
  x =[p1.x ,p2.x ]
  pv= p1.pv
  n = p1.n 
  y = p1.y 
  z = p1.z 
ENDIF ELSE BEGIN
  IF dim EQ 2 THEN BEGIN
    print,'Concatenation in two dimensions (normal)'
    w =[[w1   ],[w2   ]]
    e =[[p1.e ],[p2.e ]]
    x =[[p1.x ],[p2.x ]]
    pv=[[p1.pv],[p2.pv]]
    y =[ p1.y  , p2.y  ]
    n =[ p1.n  , p2.n  ]
    z =[[p1.z ],[p2.z] ]
  ENDIF ELSE BEGIN
    print,'Concatenation in three dimensions (extravagant)'
    w =[[[w1   ]],[[w2   ]]]
    e =[[[p1.e ]],[[p2.e ]]]
    x =[[[p1.x ]],[[p2.x ]]]
    pv=[[[p1.pv]],[[p2.pv]]]
    y =[[ p1.y  ],[ p2.y  ]]
    n =[[ p1.n  ],[ p2.n  ]]
    z =[[[p1.z ]],[[p2.z ]]]
  ENDELSE
ENDELSE
help,w,x,y,z,n,e,pv
mod_datp,p1,'x' ,x
mod_datp,p1,'y' ,y
mod_datp,p1,'z' ,z
mod_datp,p1,'n' ,n
mod_datp,p1,'e' ,e
mod_datp,p1,'pv',pv
give_datp,p1
RETURN,w
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION components, w_in0, Schaerpf=Schaerpf

;For D7 data only
;
;Separates data taken with Z or XYZ polarisation analysis into
;the constituent components: 
;
;index
; 0: total
; 1: incoherent
; 2: coherent + isotope-incoherent
; 3: paramagnetic (average of spin-flip and non-spin-flip paramagnetic)
; 4: non-spin-flip paramagnetic
; 5: spin-flip paramagnetic
;
;KEYWORD:
; /Schaerpf	:use original Schaerpf expressions for component separation
;
;DIMENSIONS:
; No-TOF: w_in(32,nphases,nruns) -> w_out(32,ncomponents,nruns)
; TOF:    w_in(128,nspectra*nphases)   -> w_out(128,nspectra*ncomponents)
;
;COMMAND SYNTAX:
; w3=components(w2,[,/Schaerpf])
; 
; (optional keywords shown in square brackets)
;							KHA,JRS 17/3/00
;-------------------------------------------------------------------------------
;*******************************************************************************


	iprint=0	; if iprint>0, show debugging messages

	IF KEYWORD_SET(Schaerpf) THEN Schaerpf=1 ELSE Schaerpf=0

	IF(iprint GT 0) THEN BEGIN
		IF(Schaerpf EQ 1) THEN PRINT,'Components: using original Schaerpf expressions' $
				  ELSE PRINT,'Components: using standard expressions'
	ENDIF

	IF (iprint GT 0) THEN PRINT,'Start components:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	sw=SIZE(w_in0)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in0)=',sw

	par=datp.p
	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nruns=FIX(par(3))
	TOF=FIX(par(8))
	nchannels=FIX(par(6))
	chw=par(7)

	IF (nphases EQ 2) THEN ncomps=3 ELSE ncomps=nphases

	IF (nruns EQ 1) THEN x_in=datp.x ELSE x_in=datp.z
	y_in=datp.y
	e_in0=datp.e

	se=SIZE(e_in0)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in0)=',sw
		PRINT,'        SIZE(e_in0)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	IF (TOF EQ 0) THEN BEGIN
		IF (nphases EQ 1) THEN BEGIN
			w_in=FLTARR(nspectra,nphases,nruns)	& e_in=w_in
			w_in(*,0,*)=w_in0(*,*)
			e_in(*,0,*)=e_in0(*,*)
		ENDIF ELSE BEGIN
			w_in=w_in0
			e_in=e_in0
		ENDELSE
	ENDIF ELSE BEGIN
		w_in=REFORM(w_in0,nchannels,nspectra,nphases)
		e_in=REFORM(e_in0,nchannels,nspectra,nphases)
	ENDELSE

	IF (iprint GT 0) THEN BEGIN
		PRINT,'TOF=',TOF
		PRINT,'nspectra=',nspectra
		PRINT,'nphases=',nphases
		PRINT,'nchannels=',nchannels
		PRINT,'nruns=',nruns
		PRINT,'ncomps=',ncomps
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Separate components

	IF (iprint GT 0) THEN PRINT,'TOF=',TOF

; No-TOF: w_in(32,nphases,nruns) -> w_out(32,ncomponents,nruns)
; TOF:    w_in(128,nspectra*nphases)   -> w_out(128,nspectra*ncomponents)
;
; 0: total
; 1: incoherent
; 2: coherent + isotope-incoherent
; 3: paramagnetic (average of spin-flip and non-spin-flip paramagnetic)
; 4: non-spin-flip paramagnetic
; 5: spin-flip paramagnetic
;
; Schaerpf expressions:
;	 Mnf=2*(2*Znf-Xnf-Ynf) \
;	 Mfl=2*(Xfl+Yfl-2*Zfl) / => M=weighted average of Mnf and Mfl
;	  SI=(3*Zfl-Xfl-Yfl)*3/2
;	C+II=Znf-Zsf+SI/3
;
; Expressions used here:
;	 Mnf, Mfl and M the same
;	 Tnf=Znf+Xnf+Ynf
;	 Tfl=Zfl+Xfl+Yfl
;	  SI=Tfl/2-M
;	C+II=(2*Tnf-Tfl)/6

	IF (TOF EQ 0) THEN BEGIN
		w_out=FLTARR(nspectra,ncomps,nruns)	& e_out=w_out
		IF (nphases EQ 1) THEN w_out=w_in $
		ELSE IF (nphases EQ 2) THEN BEGIN
			w_out(*,0,*)=total(w_in,2)
			e_out(*,0,*)=sqrt(total(e_in^2,2))
			w_out(*,1,*)=1.5*w_in(*,1,*)
			e_out(*,1,*)=1.5*e_in(*,1,*)
			w_out(*,2,*)=w_in(*,0,*)-w_in(*,1,*)/2.
			e_out(*,2,*)=sqrt(e_in(*,0,*)^2+(e_in(*,1,*)/2.)^2)
		ENDIF ELSE BEGIN
			magsf=FLTARR(32,nruns)	& dmagsf=magsf	; spin-flip magnetic
			magsf=2.*(w_in(*,3,*)+w_in(*,5,*)-2.*w_in(*,1,*))
			dmagsf=2.*sqrt(e_in(*,3,*)^2+e_in(*,5,*)^2+(2.*e_in(*,1,*))^2)
			magnf=FLTARR(32,nruns)	& dmagnf=magnf	; non-spin-flip magnetic
			magnf=2.*(2.*w_in(*,0,*)-w_in(*,2,*)-w_in(*,4,*))
			dmagnf=2.*sqrt((2.*e_in(*,0,*))^2+e_in(*,2,*)^2+e_in(*,4,*)^2)
			zsf=WHERE(dmagsf EQ 0.,nzsf)
			IF (nzsf NE 0) THEN dmagsf(zsf)=1.
			znf=WHERE(dmagnf EQ 0.,nznf)
			IF (nznf NE 0) THEN dmagnf(znf)=1.
			mag=(magsf/dmagsf^2+magnf/dmagnf^2)/(1./dmagsf^2+1./dmagnf^2)
			dmag=1./sqrt(1./dmagsf^2+1./dmagnf^2)
			IF (nzsf NE 0) THEN dmagsf(zsf)=0.
			IF (nznf NE 0) THEN dmagnf(znf)=0.
			IF (nzsf NE 0) THEN BEGIN
				mag(zsf)=magnf(zsf)
				dmag(zsf)=dmagnf(zsf)
			ENDIF
			IF (nznf NE 0) THEN BEGIN
				mag(znf)=magsf(znf)
				dmag(znf)=dmagsf(znf)
			ENDIF
			IF (Schaerpf) THEN BEGIN
				inc=(3.*w_in(*,1,*)-w_in(*,3,*)-w_in(*,5,*))*3./2.
				dinc=sqrt((3.*e_in(*,1,*))^2+e_in(*,3,*)^2+e_in(*,5,*)^2)*3./2.
				coh=w_in(*,0,*)-w_in(*,1,*)+inc/3.
				dcoh=sqrt(e_in(*,0,*)^2+e_in(*,1,*)^2+(dinc/3.)^2)
			ENDIF ELSE BEGIN
				Tnf=w_in(*,0,*)+w_in(*,2,*)+w_in(*,4,*)
				dTnf=sqrt(e_in(*,0,*)^2+e_in(*,2,*)^2+e_in(*,4,*)^2)
				Tfl=w_in(*,1,*)+w_in(*,3,*)+w_in(*,5,*)
				dTfl=sqrt(e_in(*,1,*)^2+e_in(*,3,*)^2+e_in(*,5,*)^2)
				inc=Tfl/2.-mag 
				dinc=sqrt((dTfl/2.)^2+dmag^2)
				coh=(2.*Tnf-Tfl)/6.
				dcoh=sqrt((2.*dTnf)^2+dTfl^2)/6.
			ENDELSE
			w_out(*,0,*)=total(w_in,2)/3.
			e_out(*,0,*)=sqrt(total(e_in^2,2))/3.
			w_out(*,1,*)=inc
			e_out(*,1,*)=dinc
			w_out(*,2,*)=coh
			e_out(*,2,*)=dcoh
			w_out(*,3,*)=mag	& e_out(*,3,*)=dmag
			w_out(*,4,*)=magnf	& e_out(*,4,*)=dmagnf
			w_out(*,5,*)=magsf	& e_out(*,5,*)=dmagsf
		ENDELSE
	ENDIF ELSE BEGIN
		w_out=FLTARR(nchannels,nspectra,ncomps)	& e_out=w_out
		IF (nphases EQ 1) THEN w_out=w_in $
		ELSE IF (nphases EQ 2) THEN BEGIN
			w_out(*,*,0)=total(w_in,3)
			e_out(*,*,0)=sqrt(total(e_in^2,3))
			w_out(*,*,1)=1.5*w_in(*,*,1)
			e_out(*,*,1)=1.5*e_in(*,*,1)
			w_out(*,*,2)=w_in(*,*,0)-w_in(*,*,1)/2.
			e_out(*,*,2)=sqrt(e_in(*,*,0)^2+(e_in(*,*,1)/2.)^2)
		ENDIF ELSE BEGIN
			magsf=FLTARR(nchannels,nspectra)	& dmagsf=magsf	; spin-flip paramagnetic
			magsf=2.*(w_in(*,*,3)+w_in(*,*,5)-2.*w_in(*,*,1))
			dmagsf=2.*sqrt(e_in(*,*,3)^2+e_in(*,*,5)^2+(2.*e_in(*,*,1))^2)
			magnf=FLTARR(nchannels,nspectra)	& dmagnf=magnf	; non-spin-flip paramagnetic
			magnf=2.*(2.*w_in(*,*,0)-w_in(*,*,2)-w_in(*,*,4))
			dmagnf=2.*sqrt((2.*e_in(*,*,0))^2+e_in(*,*,2)^2+e_in(*,*,4)^2)
			zsf=WHERE(dmagsf EQ 0.,nzsf)
			IF (nzsf NE 0) THEN dmagsf(zsf)=1.
			znf=WHERE(dmagnf EQ 0.,nznf)
			IF (nznf NE 0) THEN dmagnf(znf)=1.
			mag=(magsf/dmagsf^2+magnf/dmagnf^2)/(1./dmagsf^2+1./dmagnf^2)
			dmag=1./sqrt(1./dmagsf^2+1./dmagnf^2)
			IF (nzsf NE 0) THEN dmagsf(zsf)=0.
			IF (nznf NE 0) THEN dmagnf(znf)=0.
			IF (nzsf NE 0) THEN BEGIN
				mag(zsf)=magnf(zsf)
				dmag(zsf)=dmagnf(zsf)
			ENDIF
			IF (nznf NE 0) THEN BEGIN
				mag(znf)=magsf(znf)
				dmag(znf)=dmagsf(znf)
			ENDIF
			Tnf=w_in(*,*,0)+w_in(*,*,2)+w_in(*,*,4)
			dTnf=sqrt(e_in(*,*,0)^2+e_in(*,*,2)^2+e_in(*,*,4)^2)
			Tfl=w_in(*,*,1)+w_in(*,*,3)+w_in(*,*,5)
			dTfl=sqrt(e_in(*,*,1)^2+e_in(*,*,3)^2+e_in(*,*,5)^2)
			w_out(*,*,0)=total(w_in,3)/3.
			e_out(*,*,0)=sqrt(total(e_in^2,3))/3.
			w_out(*,*,1)=Tfl/2.-mag
			e_out(*,*,1)=sqrt((dTfl/2.)^2+dmag^2)
			w_out(*,*,2)=(2.*Tnf-Tfl)/6.
			e_out(*,*,2)=sqrt((2.*dTnf)^2+dTfl^2)/6.
			w_out(*,*,3)=mag	& e_out(*,*,3)=dmag
			w_out(*,*,4)=magnf	& e_out(*,*,4)=dmagnf
			w_out(*,*,5)=magsf	& e_out(*,*,5)=dmagsf
		ENDELSE
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'End of Component Separation section'

;-------------------------------------------------------------------------------
;Rezero detectors and check dimensions of output data

	IF (TOF EQ 0) THEN BEGIN
		FOR irun=0,nruns-1 DO BEGIN
			zeroed=WHERE(e_in(*,0,irun) LT -0.9, nz)
			IF (nz NE 0) THEN BEGIN
				w_out(zeroed,*,irun)=0.
				e_out(zeroed,*,irun)=-1.
			ENDIF
		ENDFOR
	ENDIF ELSE BEGIN
		w_buf=INTARR(nchannels,nspectra)*0
		FOR i=0,nphases-1 DO BEGIN
			zeroed=WHERE(e_in(*,*,i) LE -1.,n)
			IF (n GT 0) THEN w_buf(zeroed)=1
		ENDFOR
		zeroed=WHERE(w_buf EQ 1,nz)
		IF (iprint GT 0) THEN PRINT,nz/nchannels,' zeroed spectra'
		IF (nz GT 0) THEN FOR i=0,nphases-1 DO BEGIN
			w_buf=w_out(*,*,i)	& e_buf=e_out(*,*,i)
			w_buf(zeroed)=0.	& e_buf(zeroed)=-1.
			w_out(*,*,i)=w_buf	& e_out(*,*,i)=e_buf
		ENDFOR
	ENDELSE

	IF (TOF EQ 1) THEN BEGIN
		w_out=REFORM(w_out,nchannels,nspectra*ncomps)
		e_out=REFORM(e_out,nchannels,nspectra*ncomps)
		y_buf=y_in(0:nspectra-1)
		IF (ncomps EQ 3) THEN y_out=[y_buf,y_buf,y_buf]
		IF (ncomps EQ 6) THEN y_out=[y_buf,y_buf,y_buf,y_buf,y_buf,y_buf]
	ENDIF

	w_out=w_out
	e_out=e_out

	IF (iprint GT 0) THEN PRINT,'End of "Rezero detectors" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.p(2)=FLOAT(ncomps)
	IF(TOF EQ 1) THEN mod_datp, datp, "y", y_out
	IF (nphases EQ 2) THEN mod_datp, datp, "e", e_out $
			ELSE datp.e=e_out
	IF (TOF EQ 1 AND nphases EQ 6) THEN mod_datp, datp, "y", y_in(0:ncomps*nspectra-1)

	datp.w_tit='component of '+STRTRIM(datp.w_tit,2)
	datp.other_tit=datp.other_tit+' -co'
	PRINT,'Components: components separated'

finished:
	IF (iprint GT 0) THEN PRINT,'End Components:'

	give_datp, datp

	RETURN, w_out
	END
function concatd20,w1,w2

COMMON C_LAMP_INFO

take_datp,d1,w=two
take_datp,d2,w=three
print,two,three
d=d1
w=[[w1],[w2]]
x=[[d1.x],[d2.x]]
pv=[[d1.pv],[d2.pv]]
n=[[[d1.n]],[[d2.n]]]
y=[d1.y,d2.y]
e=[[d1.e],[d2.e]]
mod_datp,d,'x',x
mod_datp,d,'e',e
mod_datp,d,'n',n
mod_datp,d,'y',y
mod_datp,d,'pv',pv
d.w_tit=d.w_tit+' concat.'
give_datp,d
return,w
end
;------------------------------------------------------------------------------
;******************************************************************************
;
	FUNCTION concatenate, w1, w2

;For D7 data only
;
;concatenates two workspaces. Must be performed on raw data, i.e.
;before calling normalise.pro
;
;DIMENSIONS
; any - but first n-1 out of n dimensions must be equal in w1 and w2
; eg 	w1(nspectra,nphases,nrun1)
;	w2(nspectra,nphases,nrun2) -> w3(nspectra,nphases,nrun1+nrun2)
;
;COMMAND SYNTAX:
; w3=concatenate(w1,w2)
;
;						KHA,JRS  21/5/02
;------------------------------------------------------------------------------
;******************************************************************************

	COMMON c_lamp_access, inst

	IF (inst NE 'D7') THEN BEGIN
		PRINT,'concatenate: Error - instrument must be D7'
		GOTO, finished
	ENDIF

	iprint = 0

;------------------------------------------------------------------------------
; Inspect and prepare input workspaces

	take_datp, dat1
	take_datp, dat2, /third

	x1=dat1.x	& x2=dat2.x
	y1=dat1.y	& y2=dat2.y
	z1=dat1.z	& z2=dat2.z
	n1=dat1.n	& n2=dat2.n	
	p1=dat1.p	& p2=dat2.p	
	pv1=dat1.pv	& pv2=dat2.pv
	e_in1=dat1.e	& e_in2=dat2.e

	nspectra1=FIX(p1[1])	& nspectra2=FIX(p2[1])
	nphases1=FIX(p1[2])	& nphases2=FIX(p2[2])
	nruns1=FIX(p1[3])	& nruns2=FIX(p2[3])
	TOF1=FIX(p1[8])		& TOF2=FIX(p2[8])

	IF (nspectra1 NE nspectra2) OR $
	   (nphases1 NE nphases2) THEN BEGIN
		PRINT,'Concatenate: Error in dimensions:'
		PRINT,'par(w1)=',p1
		PRINT,'par(w2)=',p2
		GOTO, finished
	ENDIF

	IF (nspectra1 NE 64 AND TOF1 EQ 0) OR (N_ELEMENTS(e_in1) GT 1) $
	OR (nspectra2 NE 64 AND TOF2 EQ 0) OR (N_ELEMENTS(e_in2) GT 1) $
	OR (nspectra1 NE 66 AND TOF1 EQ 1) OR (nspectra2 NE 66 AND TOF2 EQ 1) THEN BEGIN
		PRINT,'Concatenate: Error - data must be raw, i.e. not normalised'
		GOTO, finished
	ENDIF

	nspectra = nspectra1
	nphases  = nphases1
	tof      = tof1
	IF tof EQ 1 THEN nphases=1

	s1 = size(w1)	& s2 = size(w2)
	IF iprint GT 0 THEN PRINT,'size(w1) = ',s1
	IF iprint GT 0 THEN PRINT,'size(w2) = ',s2

	IF (nphases1 EQ 1) AND (s1[0] EQ 2) THEN nruns1 = s1[2] $
		ELSE IF s1[0] EQ 3 THEN nruns1 = s1[3] $
		ELSE nruns1 = 1
	IF (nphases2 EQ 1) AND (s2[0] EQ 2) THEN nruns2 = s2[2] $
		ELSE IF s2[0] EQ 3 THEN nruns2 = s2[3] $
		ELSE nruns2 = 1
	IF tof EQ 1 THEN BEGIN
		IF s1[0] EQ 2 THEN nruns1 = 1 ELSE nruns1 = s1[3]
		IF s2[0] EQ 2 THEN nruns2 = 1 ELSE nruns2 = s2[3]
	ENDIF

	IF iprint GT 0 THEN PRINT,'nruns1=',nruns1,'nruns2=',nruns2
	IF iprint GT 0 THEN PRINT,'Concatenate: End of "check arguments and dimensions" section'

;------------------------------------------------------------------------------
; Perform concatenation

	IF nruns1 EQ 1 THEN BEGIN
		IF nruns2 EQ 1 THEN BEGIN
			IF (tof EQ 0) THEN z_out=[[x1],[x2]] ELSE z_out=[[y1],[y2]]
			pv_out=[[p1],[p2]]
		ENDIF ELSE BEGIN
			IF tof EQ 0 THEN z_out=[[x1],[z2]] ELSE z_out=[[y1],[z2]]
			pv_out=[[p1],[pv2]]
		ENDELSE
	ENDIF ELSE BEGIN
		IF nruns2 EQ 1 THEN BEGIN
			IF (tof EQ 0) THEN z_out=[[z1],[[x2]]] ELSE z_out=[[z1],[y2]]
			pv_out=[[pv1],[p2]]
		ENDIF ELSE BEGIN
			z_out=[[z1],[z2]]
			pv_out=[[pv1],[pv2]]
		ENDELSE
	ENDELSE

	n_out=[[[n1]],[[n2]]]
	IF (tof EQ 0) AND (nphases EQ 1) THEN w_out = [[w1],[w2]] $
					 ELSE w_out = [[[w1]],[[w2]]]

	nruns = nruns1 + nruns2
	datp = dat1
	datp.p(3) = FLOAT(nruns)

	IF (tof EQ 0) AND (nphases EQ 1) THEN BEGIN
		y_out = REFORM(FIX(pv_out(0,*)),nruns)
		mod_datp, datp, "y", y_out
	ENDIF
	IF iprint GT 0 THEN PRINT, 'Concatenate: End of concatenation section'

;-------------------------------------------------------------------------------
; Return data and parameters

	mod_datp, datp, "z", z_out
	mod_datp, datp, "n", n_out
	mod_datp, datp, "pv", pv_out

	IF nruns1 EQ 1 THEN BEGIN
		runs1 = STRTRIM(STRING(LONG(p1[0])),2)
		r1='1 run'
	ENDIF ELSE BEGIN
		runs1 = STRTRIM(STRING(LONG(pv1[0,0])),2)+':'+STRTRIM(STRING(LONG(pv1[0,nruns1-1])),2)
		r1=STRTRIM(STRING(nruns1),2)+' runs'
	ENDELSE
	IF (nruns2 EQ 1) THEN BEGIN
		runs2 = STRTRIM(STRING(LONG(p2[0])),2)
		r2='1 run'
	ENDIF ELSE BEGIN
		runs2 = STRTRIM(STRING(LONG(pv2[0,0])),2)+':'+STRTRIM(STRING(LONG(pv2[0,nruns2-1])),2)
		r2=STRTRIM(STRING(nruns2),2)+' runs'
	ENDELSE

	PRINT,'Concatenate: '+r1+' and '+r2+' concatenated to give '+STRTRIM(STRING(nruns),2)+' runs'
	datp.other_tit='D7 #'+runs1+','+runs2+' -cc'

	give_datp, datp

finished:
	RETURN, w_out
	END
function concat,n,n2,cells=cells,noprint=noprint
;
; Macro (started 28/10/96 by TH.HANSEN) 
; Effectuates a concatenating reading of multiple numors
; Adapted to the special case of D20 (already multiple diagrams in one numor).
; Creates a TWO-dimensional array whilst RDAND may create THREE-dimensional arrays
;
;      Modification 19-Jun-97 by Th.Hansen
; Last Modification 27-Aug-97 by Th.Hansen: keyword cells - reads only a part of each diagram
;
IF n_params() ge 1 THEN BEGIN
  IF N_PARAMS() GE 2 THEN n=n+indgen(n2-n+1)
  datp = 0
  w    = 0
  e    = 0
  x    = 0
  pv   = 0
  nn   = 0
  n = long (REFORM (n,n_elements(n)))
  FOR i=0,n_elements(n)-1 DO BEGIN
    wtmp = rdrun(n(i))
    take_datp,datptmp
    IF NOT KEYWORD_SET(noprint) THEN PRINT,STRMID(datptmp.other_tit+' '+datptmp.w_tit,0,79)
    IF n_elements(w) le 1 THEN BEGIN
      IF KEYWORD_SET(cells) THEN w= wtmp(cells,*) ELSE w=wtmp
      wt  = datptmp.w_tit		                ; choose a common title!
      IF i eq 0 THEN ot  = datptmp.other_tit	; choose a common title!
      p   = datptmp.p		                    ; if there are differences in p, no concatenation possible
      pt  = datptmp.par_txt
      pv  = datptmp.pv
      IF KEYWORD_SET(cells) THEN e= datptmp.e(cells,*) ELSE e   = datptmp.e
      nn  = datptmp.n
      IF KEYWORD_SET(cells) THEN x   = datptmp.x(cells,*) ELSE x   = datptmp.x
      y   = datptmp.y		
      z   = datptmp.z
      xt  = datptmp.x_tit
      yt  = datptmp.y_tit
      zt  = datptmp.z_tit
      t   = datptmp.time
;      IF n_elements(x) ne n_elements(wtmp)  THEN BEGIN        ; one-dimensional x-array for not-scanning detector
;        xtmptmp=wtmp*0.0
;        FOR j=0,n_elements(wtmp(0,*))-1 DO xtmptmp(*,j)=x(*)
;	    x=xtmptmp
;      ENDIF
;      IF n_elements(y) ne n_elements(wtmp) THEN BEGIN
;        ytmptmp=wtmp*0.0
;        FOR j=0,n_elements(wtmp(*,0))-1 DO ytmptmp(j,*)=y(*)
;	    y=ytmptmp
;      ENDIF
    ENDIF ELSE BEGIN
      IF KEYWORD_SET(cells) THEN wtmp= wtmp(cells,*) 
      IF KEYWORD_SET(cells) THEN etmp = datptmp.e(cells,*) ELSE etmp = datptmp.e
      IF KEYWORD_SET(cells) THEN xtmp = datptmp.x(cells,*) ELSE xtmp = datptmp.x
      ytmp = datptmp.y
      ntmp = datptmp.n
       ; *** one-dimensional x-array for not-scanning detector has to become two-dimensional if 2theta values change
      tmp=WHERE((x(0,*) EQ xtmp(0,*)) EQ 1,cnt)
      IF cnt NE N_ELEMENTS(x(0,*)) AND n_elements(x) ne n_elements(wtmp)  THEN BEGIN  ; make precedent x-array 2-dim     
        xtmptmp=w*0.0
        FOR j=0,n_elements(w(0,*))-1 DO xtmptmp(*,j)=x(*)
	    x=xtmptmp
      ENDIF
      IF cnt NE N_ELEMENTS(x(0,*)) OR N_ELEMENTS(x(0,*)) GT 1 THEN BEGIN ; make recently read x-array 2-dim
        IF n_elements(xtmp) ne n_elements(wtmp) THEN BEGIN
          xtmptmp=wtmp*0.0
          FOR j=0,n_elements(wtmp(0,*))-1 DO xtmptmp(*,j)=xtmp(*)
	      xtmp=xtmptmp
        ENDIF
      ENDIF
;      IF n_elements(ytmp) ne n_elements(wtmp) THEN BEGIN
;        ytmptmp=wtmp*0.0
;        FOR j=0,n_elements(wtmp(*,0))-1 DO ytmptmp(j,*)=ytmp(*)
;	    ytmp=ytmptmp
;      ENDIF
      IF n_elements(w(*,0)) gt n_elements(wtmp(*,0)) THEN BEGIN     ; different number of PSD-cells - should not happen ...
        PRINT,'WARNING: Different number of PSD-cells for different numors - should not happen ...'
        PRINT,'         Solution: Use option /int for interpolation of bad cells in flag (type flag,/int)!'
        wtmp=[wtmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
        etmp=[etmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
        xtmp=[xtmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
        ytmp=[ytmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
      ENDIF
      IF n_elements(w(*,0)) lt n_elements(wtmp(*,0)) THEN BEGIN
        PRINT,'WARNING: Different number of PSD-cells for different numors - should not happen ...'
        PRINT,'         Solution: Use option /int for interpolation of bad cells in flag (type flag,/int)!'
        w   =[w,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
        e   =[e,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
        x   =[x,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
        y   =[y,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
      ENDIF
;help,w,wtmp
;help,y,ytmp
      w =   [[w] ,[wtmp      ]]
      e   = [[e] ,[etmp      ]]
      IF cnt NE N_ELEMENTS(x(0,*)) OR N_ELEMENTS(x(0,*)) GT 1 THEN x   = [[x] ,[xtmp      ]]
      y   = [y ,ytmp      ]
      pv  = [[pv],[datptmp.pv]]
      nn  = [ [[nn]] , [[ntmp]]       ]
    ENDELSE
  ENDFOR
  tmp=WHERE((pv(*,0) NE pv(*,N_ELEMENTS(pv(0,*))-1)) EQ 1,cnt)
  PRINT,'Possible scan parameters:'
  PRINT,STRMID(STRING(100+tmp),10,2)+' '+pt(tmp)+STRING((pv(tmp,0)))+STRING((pv(tmp,N_ELEMENTS(pv(0,*))-1)))
  mod_datp,datptmp,'w_tit', wt
  mod_datp,datptmp,'other_tit', ot+strcompress(string(round(n(i-1))))
  mod_datp,datptmp,'p', p
  mod_datp,datptmp,'par_txt', pt
  mod_datp,datptmp,'pv', pv
  mod_datp,datptmp,'e', e
  mod_datp,datptmp,'n', nn
  mod_datp,datptmp,'x', x
  mod_datp,datptmp,'y', y
  mod_datp,datptmp,'z', z
  mod_datp,datptmp,'x_tit', xt
  mod_datp,datptmp,'y_tit', yt
  mod_datp,datptmp,'z_tit', zt
  mod_datp,datptmp,'time', t
  PRINT,'Time:',t
  give_datp,datptmp  
ENDIF
return,w
END

FUNCTION concdef,W1,W2
      Wold=W1
      Wout=W2
      take_datp,datpold
      take_datp,datpout,/second
      datp=datpout
      newy=datpout.y
      oldy=datpold.y
      xout=datpout.x
      oldx=datpold.x
      datp=datpout
      Eold=datpold.e
      Yold=oldy
      Xold=oldx
      IF MIN(newy) LT MIN(oldy) THEN y1=MIN(oldy) ELSE y1=MIN(newy)
      IF MAX(newy) LT MAX(oldy) THEN y2=MAX(newy) ELSE y2=MAX(oldy)
      PRINT,'Cells ',MIN(oldy),' to',MAX(oldy),' and',MIN(newy),' to',MAX(newy)
      PRINT,'Overlap between cells',y1,' to',y2
      oldyi=WHERE(oldy GT y1 AND oldy LT y2,oldyc)
      newyi=WHERE(newy GT y1 AND newy LT y2,newyc)
      PRINT,'overlap: ',oldyc,' cells from previous and',newyc,' from new data '
      stepwidth=[0.01,0.001,0.0001]
      steps=20
      squaredeviation=FLTARR(steps)
      scale=FLTARR(steps)
      IF oldyc*newyc GT 0 THEN BEGIN
        FOR counter=0,2 DO BEGIN
          step=0
          FOR shift=-stepwidth(counter)*9.5,stepwidth(counter)*9.5,stepwidth(counter) DO BEGIN
            xout=newx+shift
            IF MIN(xout) LT MIN(oldx) THEN x1=MIN(oldx) ELSE x1=MIN(xout)
            IF MAX(xout) LT MAX(oldx) THEN x2=MAX(xout) ELSE x2=MAX(oldx)
            oldi=WHERE(oldx GT x1 AND oldx LT x2,oldc)
            newi=WHERE(xout GT x1 AND xout LT x2,newc)
            IF oldc*newc*oldyc*newyc GT 0 THEN BEGIN
              overlap=[oldx(oldi),xout(newi)]
              overlap=overlap(SORT(overlap))
              oldtmp=FLTARR(oldyc,oldc)
              newtmp=FLTARR(newyc,newc)
              FOR j=0,oldyc-1 DO oldtmp(j,*)=Wold(j,oldi)
              FOR j=0,newyc-1 DO newtmp(j,*)=Wout(j,newi)
              oldinterpolated=FLTARR(oldyc+newyc,oldc+newc)
              newinterpolated=FLTARR(oldyc+newyc,oldc+newc)
              FOR j=0,oldyc-1 DO oldinterpolated(j,*) = INTERPOL(Wold(oldyi(j),*), oldx, overlap)
              FOR j=0,newyc-1 DO newinterpolated(j,*) = INTERPOL(Wout(newyi(j),*), xout, overlap)
              index=WHERE(oldinterpolated GT 0,elements)
              scale(step)=TOTAL(TOTAL(newinterpolated,1)/TOTAL(oldinterpolated,1))/N_ELEMENTS(newinterpolated(0,*))
              deviation=newinterpolated/scale(step)-oldinterpolated
              deviation=deviation*deviation
              squaredeviation(step)=TOTAL(deviation)/N_ELEMENTS(deviation)
              step=step+1
            ENDIF
          ENDFOR
          PRINT,'Least square deviation: ',MIN(squaredeviation,step),', shift:',(step-9.5)*stepwidth(counter),', scale:',scale(step) 
          shift=(step-9.5)*stepwidth(counter) 
          newx=newx+shift
        ENDFOR
        Wnew=[[Wold],[fltarr(N_ELEMENTS(Wold(*,0)),N_elements(Wout(0,*)))]]
        Enew=[[Eold],[fltarr(N_ELEMENTS(Wold(*,0)),N_elements(Wout(0,*)))]]
        FOR y=0,N_ELEMENTS(newy)-1 DO BEGIN
          index=WHERE(oldy EQ newy(y), exists)
          IF exists EQ 0 THEN BEGIN
            Wnew=[Wnew,FLTARR(1,N_ELEMENTS(Wnew(0,*)))]
            Enew=[Enew,FLTARR(1,N_ELEMENTS(Wnew(0,*)))]
            index=N_ELEMENTS(Wnew(*,0))-1
            oldy=[oldy,newy(y)]
          ENDIF
          Wnew(index,N_ELEMENTS(Wold(0,*)):N_ELEMENTS(Wnew(0,*))-1)=Wout(y,*)/scale(step)
          Enew(index,N_ELEMENTS(Wold(0,*)):N_ELEMENTS(Wnew(0,*))-1)=datp.e(y,*)/scale(step)
        ENDFOR
        sorted=SORT([oldx,newx])
        FOR y=0,N_ELEMENTS(oldy)-1 DO BEGIN
          Wnew(y,*)=Wnew(y,sorted)
          Enew(y,*)=Enew(y,sorted)
        ENDFOR
        sorted=SORT([oldy])
        oldy=oldy(sorted)
        FOR y=0,N_ELEMENTS([oldx,newx])-1 DO BEGIN
          Wnew(*,y)=Wnew(sorted,y)
          Enew(*,y)=Enew(sorted,y)
        ENDFOR
        x1=MIN([oldx,newx])
        x2=MAX([oldx,newx])
        x1=CEIL (x1*100.)/100.
        x2=FLOOR(x2*100.)/100.
        PRINT,'Interpolate for',x1,' to',x2,', new X from',MIN(Xold),' to',MAX(Xold)
        Yold=oldy
        Xold=FINDGEN(ROUND(100.*(x2-x1))+1)/100.+x1
        Wold=FLTARR(N_ELEMENTS(Yold),N_ELEMENTS(Xold))
        Eold=Wold
        Xtmp=[oldx,newx]
        Xtmp=Xtmp(SORT(Xtmp))
        FOR j=0,N_ELEMENTS(Wnew(*,0))-1 DO Wold(j,*) = INTERPOL(Wnew(j,*), Xtmp, Xold)
        FOR j=0,N_ELEMENTS(Wnew(*,0))-1 DO Eold(j,*) = INTERPOL(Enew(j,*), Xtmp, Xold)
        plotd,Wold,Yold,pos(i),e,datp=datp,threshold,bg=bg,max=max,/nop,x=Xold
  ENDIF	
  mod_datp,datp,'y',Yold
  mod_datp,datp,'x',Xold
  Eold=ROTATE(Eold,180)
  Wold=ROTATE(Wold,180)
  mod_datp,datp,'e',Eold
  give_datp,datp
RETURN,Wold
END


pro co,value,tm


valstr=strtrim(string(value),2)
dummy=dial_mad_send('',0,'run '+valstr+' '+tm,'')
print,'sent command: run '+valstr+' ',tm
   
wait,.2
stat=DIAL_MAD_READ('status')
 stat=strtrim(stat,2)
 while stat eq 'COUNTING' do begin
  stat=DIAL_MAD_READ('status')
  stat=strtrim(stat,2)
 endwhile
wait,2.2
end


function corel,wkin ,sigma=sigma
;******* *****
;**
;** Standard deviation over spectra:return sigma/Error or sigma if keyword_set
;** -------- --------- ---- -------

wkout =0
dim   =SIZE(wkin)					

If dim(1) gt 1 then $
	Case dim(0) of
			
		2 : Begin		  		  
		      np    =dim(2)			;Get number of runs
		      wkmean=TOTAL(wkin,2) / np		;Get mean values
		      wkout =wkmean * 0				      
		      For i =0,np-1 do $
			  wkout = (wkin(*,i)  -wkmean)^2 + wkout  
			   			 	;This is SIGMA^2
		    End	
			     
		3 : Begin     						     
		      np    =dim(3)			;Get number of runs
		      wkmean=TOTAL(wkin,3) / np		;Get mean values
		      wkout =wkmean * 0				      
		      For i =0,np-1 do $
			  wkout = (wkin(*,*,i)-wkmean)^2 + wkout  
			      				;This is SIGMA^2
		    End							     
		
		else :return,wkout
	Endcase
	f=.5/np
	if keyword_set(sigma) then    $ 
	     wkout =Sqrt(wkout/(np-1))$			;Return SIGMA
	else wkout =Sqrt(wkout/(np-1)/(wkmean>f))	;Return SIGMA/Error
						    
Return ,wkout
End							  
;-------------------------------------------------------------------------------
;*******************************************************************************
;
;	FUNCTION corr_tof, w_in, det_eff=efficiency,frameoverlap=frameoverlap, $
;		 bkgd_trans=bkgd_trans, ana_eff=ana_eff, ef1, fr1, bg1
;
;For IN4, IN5, IN6 and D7 data.
;
;KEYWORDS:
; /det_eff	 : corrects for energy-variation of detector efficiency
; /frameoverlap: subtracts a t^-4 tail from the beginning
;			of the time frame
; /bkgd_trans  : subtracts a flat background in each detector,
;			found using a moving filter (For IN4, IN5 and IN6 only)
; /ana_eff	 : correct for energy dependence of analyser transmission
;			(For D7 only)
; (ef1, fr1, and bg1 are obsolete and kept for backwards compatability)	
;
;DIMENSIONS
;   w_in=w_out(nchannels,nphases*nspectra)
;
;COMMAND SYNTAX
;   w6=corr_tof(w5[,/det_eff][,/frameoverlap][,/bkgd_trans][,/ana_eff])
;
;   (optional keywords shown in square brackets)
;
;						KHA,JRS 7/8/00
;
;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION corr_tof_tof, w_in, efficiency, frameoverlap, bkgd

	COMMON c_lamp_access, inst
	COMMON printing, iprint, outstring

	IF (iprint GT 0) THEN PRINT,'Start corr_tof_tof:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace and energy parameters

	par=datp.p

	lambda=par(21)
	chw=par(18)
	chel=par(9)	   ; elastic channel (if IN5, for high-angle detectors)
	L2=par(27)*1000.	  ; sample-detector distance (mm)
	IF (inst EQ 'IN5') THEN BEGIN
		L2det=L2	  ; sample-detector distance (mm)
		L2mul=L2det-300.	; sample-multidetector distance
	ENDIF ELSE IF (inst EQ 'IN6') THEN $
		par(14)=1.	; rep period multiplier is 1 on IN6

	period=par(13)*par(14)	; repetition period (mcs)

	IF (N_ELEMENTS(efficiency) NE 0) THEN corr_e=efficiency ELSE corr_e=0
	IF (N_ELEMENTS(frameoverlap) NE 0) THEN corr_f=frameoverlap ELSE corr_f=0
	IF (N_ELEMENTS(bkgd) NE 0) THEN corr_b=bkgd ELSE corr_b=0

	IF (iprint GT 0) THEN BEGIN
		PRINT,'lambda=',lambda,'A, chw=',chw,'mcs, chel=',chel
		PRINT,' L2=',L2,'mm period=',period,'mcs'
		PRINT,' corr_e=',corr_e,' corr_f=',corr_f,' corr_b=',corr_b
	ENDIF

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	nchannels=sw(1)
	IF (sw(0) EQ 1) THEN nspectra=1	 ELSE $
	IF (sw(0) EQ 2) THEN nspectra=sw(2) ELSE return,w_in

	IF (iprint GT 0) THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	x_in=datp.x
	y_in=datp.y
	e_in=datp.e

	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN e_in=SQRT(w_in)

	IF(iprint GT 0) THEN PRINT,'corr_tof: End of check dimensions section'

;-------------------------------------------------------------------------------------
;   Set constants and prepare output arrays

	const1=5.22697	; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571   ; E(meV)=const2*k(A^-1)^2 for neutron
	const3=3.956076	 ; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066	; E(meV)=const4/lambda(A)^2 for neutron

	w_out=w_in
	e_out=e_in
	x_out=FLTARR(nchannels)
	y_out=y_in

	Ei=const4/lambda^2
	Vi=SQRT(Ei/const1)

	Tsam=chel*chw-L2/Vi

	IF (inst EQ 'IN5') THEN BEGIN
		cheldet=chel	  & Teldet=L2det/Vi
		timedet=chw*FLOAT(x_in-cheldet)+Teldet
		Efdet=const1*(L2det/timedet)^2
		Epsdet=Ei-Efdet
		chelmul=chel-300./Vi	& Telmul=L2mul/Vi
		timemul=chw*FLOAT(x_in-chelmul)+Telmul
		Efmul=const1*(L2mul/timemul)^2
		Epsmul=Ei-Efmul
	ENDIF ELSE BEGIN
		Tel=L2/Vi
		time=chw*FLOAT(x_in-chel)+Tel
		Ef=const1*(L2/time)^2
		Eps=Ei-Ef
		wave=SQRT(const4/Ef)
	ENDELSE

;-------------------------------------------------------------------------------------
;   Perform background correction

	IF (corr_b EQ 1) THEN BEGIN
		iw=10
		FOR ispec=0,nspectra-1 DO BEGIN
			S=w_out(*,ispec)
			Ss=SMOOTH(S,2*iw+1)
			bkgd=MIN(Ss(iw:nchannels-iw-1))>0.
			IF (iprint GT 0) THEN PRINT,'ispec=',ispec,' bkgd=',bkgd
			w_out(*,ispec)=S-bkgd
		ENDFOR
	ENDIF

	IF (iprint GT 0) THEN PRINT,'corr_tof_tof: End of background correction section'
;-------------------------------------------------------------------------------------
;   Prepare for frame overlap correction

	IF (corr_f EQ 1) THEN BEGIN
		nfit=10
		ifit1=nchannels-nfit
		ifit2=nchannels-1
		IF (inst EQ 'IN5') THEN BEGIN
			Tdet=chw*(FLOAT(x_in(ifit1)+x_in(ifit2))/2.-cheldet)+Teldet
			time1det=timedet+period
			Tmul=chw*(FLOAT(x_in(ifit1)+x_in(ifit2))/2.-chelmul)+Telmul
			time1mul=timemul+period
		ENDIF ELSE BEGIN
			T=chw*(FLOAT(x_in(ifit1)+x_in(ifit2))/2.-chel)+Tel ; mean time of integrating region
			time1=time+period   ; frame-overlap time-of-flight
		ENDELSE
	ENDIF ELSE BEGIN
		T=0.	& time1=0.
		Tdet=0. & time1det=0.
		Tmul=0. & time1mul=0.
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'corr_tof_tof: End of frame overlap correction section'
;-------------------------------------------------------------------------------------
;   Prepare for detector efficiency correction

	IF (corr_e EQ 0) THEN BEGIN
		eff=1.
		effdet=1.
		effmul=1.
	ENDIF ELSE BEGIN
		IF (inst EQ 'IN5') THEN BEGIN   ; use expressions for D7
			effdet=(1.-exp(-5.6/SQRT(Efdet)))/(1.-exp(-5.6/SQRT(Ei)))
			effmul=(1.-exp(-5.6/SQRT(Efmul)))/(1.-exp(-5.6/SQRT(Ei)))
		ENDIF ELSE IF (inst EQ 'IN6') THEN BEGIN ; use expressions from Y. Blanc's report
			eff=0.94*(1.-EXP(-0.363*wave)) & i=WHERE(wave GE 4., n)
			IF (n GT 0) THEN eff(i)=EXP(-0.00625*wave(i))*(1.-EXP(-0.363*wave(i)))
			eff0=EXP(-0.00625*lambda)*(1.-EXP(-0.363*lambda))
			eff=eff/eff0	; normalise to 1 at elastic peak
		ENDIF ELSE $		; use expressions for D7
		eff=(1.-exp(-5.6/SQRT(Ef)))/(1.-exp(-5.6/SQRT(Ei)))
	ENDELSE

;-------------------------------------------------------------------------------------
;   Perform frame-overlap and detector efficiency corrections

	FOR ispec=0,nspectra-1 DO BEGIN
		S=w_out(*,ispec)	& dS=e_out(*,ispec)
	  	IF (inst EQ 'IN5') THEN BEGIN
			IF (y_in(ispec) LE 10.) THEN BEGIN
				T=Tmul & time1=time1mul & eff=effmul
			ENDIF ELSE BEGIN
				T=Tdet & time1=time1det & eff=effdet
			ENDELSE
		ENDIF
		IF (corr_f EQ 1) THEN BEGIN
			Y=TOTAL(S(ifit1:ifit2),1)/FLOAT(nfit)
			A=Y*T^4 & S=S-A/time1^4
		ENDIF
		w_out(*,ispec)=S/eff
		e_out(*,ispec)=dS/eff
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'corr_tof_tof: End of main section'
;-------------------------------------------------------------------------------------

	datp.other_tit=datp.other_tit+' -ct('+STRTRIM(STRING(corr_e),2) $
	  +','+STRTRIM(STRING(corr_f),2)+','+STRTRIM(STRING(corr_b),2)+')'

	IF (corr_e EQ 0) THEN estring='no det eff corr' ELSE estring='with det eff corr'
	IF (corr_f EQ 0) THEN fstring='no frame overlap corr' ELSE fstring='with frame overlap corr'
	IF (corr_b EQ 0) THEN bstring='no bkgd corr' ELSE bstring='with bkgd corr'
	outstring=estring+', '+fstring+', '+bstring

	give_datp, datp

finished:
	IF (iprint GT 0) THEN PRINT,'End corr_tof_tof:'

	RETURN, w_out
	END


;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION corr_tof_d7, w_in, ieff, iover, itrans

	COMMON c_lamp
	COMMON printing, iprint, outstring

	IF (iprint GT 0) THEN PRINT,'Start corr_tof_d7:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input file and energy parameters
	
	trans_file=FILEPATH('transmission.dat',ROOT_DIR=lamp_macro+'/D7')

;analyser transmission from H2 experiment of Mompean

	rmlp=0	; rmlp=0 => leave last point as it is
		; rmlp=1 => remove last point (set = neighbouring point)
	par=datp.p

	lambda=par(4)
	freq=par(5)
	chw=par(7)
	chel=par(9)

	IF (iprint GT 0) THEN PRINT,'lambda=',lambda,' chel=',chel
	IF (iprint GT 0) THEN PRINT,'freq=',freq,'rpm   chw=',chw,'mcs'

	TOF=FIX(par(8))
	IF (TOF NE 1) THEN BEGIN
		PRINT,' corr_tof_d7: Error - workspace data is not in TOF'
		return,w_in
	ENDIF

	IF (freq LE 0. OR freq GT 12000.) THEN BEGIN
		PRINT,'corr_tof_d7: freq=0 in workspace parameters. Assume 8000rpm'
		freq=8000.
	ENDIF

	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nchannels=FIX(par(6))

	sw=SIZE(w_in)

	IF (iprint GT 0) THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	y_in=datp.y
	e_in=datp.e

	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in)=',sw
		PRINT,'	  SIZE(e_in)=',se
		PRINT,'	- must be the same size'
		return,w_in
	ENDIF

	zeroed=WHERE(e_in LE -1.,n) ; zeroed channels
	IF (iprint GT 0) THEN PRINT,n/nchannels,' zeroed spectra'

	eff0=0
	IF (N_ELEMENTS(ieff) NE 0) THEN eff0=ieff
	trans0=0
	IF (N_ELEMENTS(itrans) NE 0) THEN trans0=itrans
	over0=0
	IF (N_ELEMENTS(iover) NE 0) THEN over0=iover

	IF (iprint GT 0) THEN BEGIN
		PRINT,'efficiency=',eff0
		PRINT,'transmission=',trans0
		PRINT,'overlap=',over0
	ENDIF

	IF (eff0 EQ 0 AND trans0 EQ 0 AND over0 EQ 0) THEN BEGIN
		return,w_in
	ENDIF

	IF (iprint GT 0) THEN PRINT,'corr_tof_d7: End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------------
;   Set constants and prepare arrays

	eff=FLTARR(nchannels)
	wave=FLTARR(nchannels)

	const1=5.22697	; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571   ; E(meV)=const2*Q(A^-1)^2 for neutron
	const3=3.956076	 ; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066	; E(meV)=const4/lambda(A)^2 for neutron

	L2=1500.0	 ; sample-detector distance (mm)

	Ei=const4/lambda^2
	Vi=SQRT(Ei/const1)
	Tel=L2/Vi

	time=chw*FLOAT(INDGEN(nchannels)-chel)+Tel
	Ef=const1*(L2/time)^2

	eff=(1.-exp(-5.6/SQRT(Ef)))/(1.-exp(-5.6/SQRT(Ei)))

	wave=SQRT(const4/Ef)

	IF (over0 EQ 1) THEN BEGIN
		IF (freq LE 0.) THEN BEGIN
			PRINT,'Corr_tof_d7: Error - freq =< 0'
			return,w_in
		ENDIF
		freq=freq/60.	 ; convert to Hz
		period=1.E+06/freq  ; period in mcs
		period=period/4.	; since there are four slits in chopper disk
		nfit=10	   ; no.of points for fit of y=A*t^-4
		ifit1=nchannels-nfit
		ifit2=nchannels-2
		T=chw*(FLOAT(ifit1+ifit2)/2.-chel)+Tel ; mean time of integrating region
		time1=time+period   ; frame-overlap time-of-flight
	ENDIF

	IF (iprint GT 0) THEN BEGIN
		PRINT,'lambda=',lambda,' Ei=',Ei,' freq=',freq,' chw=',chw
		PRINT,'Ef=',Ef
		PRINT,'eff=',eff
		PRINT,'wave=',wave
	ENDIF

	IF (iprint GT 0) THEN PRINT,'corr_tof_d7: End of "Set constants etc." section'

;-------------------------------------------------------------------------------
;Open and read from input file

	line=''

	npts=136
	A=FLTARR(3,npts)
	OPENR, 1, trans_file, ERROR=err
	IF (err NE 0) THEN PRINT, !ERR_STRING
	READF, 1, A
	CLOSE, 1
	Wax=FLTARR(npts)	& Trx=Wax   & dTrx=Wax
	Wax(*)=A(0,*)	 & Trx(*)=A(1,*) & dTrx(*)=A(2,*)
	coeff=POLY_FIT(Wax,Trx,9)
	trans1=INTERPOL(Trx,Wax,wave)
	trans2=FLOAT(POLY(wave,coeff))
	i1=0	& i2=0
	FOR i=1,nchannels-1 DO BEGIN
		IF (wave(i-1) LT 2.4) AND (wave(i) GE 2.4) THEN i1=i
		IF (wave(i-1) LT 3.5) AND (wave(i) GE 3.5) THEN i2=i
		IF (wave(i-1) LE lambda) AND (wave(i) GT lambda) THEN i0=i
	ENDFOR
	trans=trans2
	trans(i1:i2)=trans1(i1:i2)	; interpolate to get bump and dip
			  		; at lambda=2.5 to 3 Angstrom
	transm=trans(i0)+(lambda-wave(i0)) $
			*(trans(i0+1)-trans(i0))/(wave(i0+1)-wave(i0))
	trans=trans/transm

	IF (iprint GT 0) THEN BEGIN
		PRINT,' ichannel  wavelength  transmission  efficiency'
		FOR i=0,nchannels-1 DO PRINT, i, wave(i), trans(i), eff(i)
	ENDIF

	IF (iprint GT 0) THEN PRINT,'corr_tof_d7: End of "read from input files" section'

;-------------------------------------------------------------------------------
;Perform correction


	S=FLTARR(nchannels) & dS=S
	w_out=w_in
	e_out=e_in

	IF (rmlp EQ 1) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'Corr_tof: Setting last pt = next-last point'
		w_out(nchannels-1,*)=w_out(nchannels-2,*)
		e_out(nchannels-1,*)=e_out(nchannels-2,*)
	ENDIF

	Ecorr=FLTARR(nchannels) & Ecorr(*)=1.

	IF (eff0 EQ 1) THEN Ecorr=Ecorr/eff

	IF (trans0 EQ 1) THEN Ecorr=Ecorr/trans
	IF (iprint NE 0) THEN print, 'nphases*nspectra-1',nphases*nspectra-1

	FOR ispec=0,nphases*nspectra-1 DO BEGIN
		S=w_out(*,ispec)	& dS=e_out(*,ispec)
		IF (over0 EQ 1) THEN BEGIN
			Y=TOTAL(S(ifit1:ifit2),1)/FLOAT(nfit)
			A=Y*T^4
			IF (iprint GT 0 AND ispec EQ 0) THEN BEGIN
				PRINT,'channel	time	wave	S	fr_ovlp	 eff	 trans'
				FOR i=0,nchannels-1 DO $
				PRINT, FORMAT='(I4,2F10.3,4F10.6)', i, time(i), wave(i), $
				S(i), A/time1(i)^4, eff(i), trans(i)
			ENDIF
			S=S-A/time1^4
	  	ENDIF
		w_out(*,ispec)=S*Ecorr
		e_out(*,ispec)=dS*Ecorr
	ENDFOR

	IF(n GT 0) THEN BEGIN
		w_out(zeroed)=0.	& e_out(zeroed)=-1.
		ENDIF

	IF (iprint GT 0) THEN PRINT,'corr_tof_d7: End of Correction section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.e=e_out

	datp.other_tit=datp.other_tit+' -ct('+STRTRIM(STRING(eff0),2) $
	  +','+STRTRIM(STRING(over0),2)+','+STRTRIM(STRING(trans0),2)+')'

	IF (eff0 EQ 0) THEN estring='no det eff corr' ELSE estring='with det eff corr'
	IF (over0 EQ 0) THEN fstring='no frame ovlp corr' ELSE fstring='with frame ovlp corr'
	IF (trans0 EQ 0) THEN tstring='no ana trans corr' ELSE tstring='with ana trans corr'
	outstring=estring+', '+fstring+', '+tstring

finished:
	IF (iprint GT 0) THEN PRINT,'End corr_tof_d7:'

	give_datp, datp

	RETURN, w_out
	END

;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION corr_tof, w_in, det_eff=efficiency,frameoverlap=frameoverlap, $
		 bkgd_trans=bkgd_trans, ana_eff=ana_eff, ef1, fr1, bg1

	COMMON c_lamp_access, inst
	COMMON c_lamp
	COMMON printing, iprint, outstring

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start corr_tof:'
	IF(N_ELEMENTS(ef1) GT 0) THEN efficiency=ef1
	IF(N_ELEMENTS(fr1) GT 0) THEN frameoverlap=fr1
	IF(N_ELEMENTS(bg1) GT 0) THEN BEGIN
		ana_eff=bg1
		bkgd_trans=1
	ENDIF

;-------------------------------------------------------------------------------
;Check instrument name and call appropriate function

	IF (inst EQ 'IN4' OR inst EQ 'IN5' OR inst EQ 'IN6') THEN $
		w_out=corr_tof_tof(w_in,efficiency,frameoverlap,bkgd_trans) $
	ELSE IF (inst EQ 'D7') THEN $
		w_out=corr_tof_d7(w_in,efficiency,frameoverlap,ana_eff) $
	ELSE BEGIN
		PRINT,'corr_tof: Error - instrument must be IN4, IN5, IN6 or D7'
		return,w_in
	ENDELSE

;-------------------------------------------------------------------------------
;Return parameters and exit

	PRINT,'corr_tof: '+outstring

finished:
	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION corr_xyz, w_in0, filenum=iFR, fudge = fudge, frn

;For D7 polarisation analysis data only
;
;Corrects for finite polarization using a previously measured quartz run
;
;ARGUMENTS:
; filenum	: numor(s) of flipping ratio file(s) to use:
;		  e.g. filenum=27134 to use the file "quartz_27134.dat'
;		       filenum=[27134,27135,27136] to use multiple files
; fudge		: Specifies an array of fudgefactors (for depolarization 
;		  corrections) for each spectrum
;
;DIMENSIONS:
; TOF   -> w_in=w_out(nchannels,nspectra*nphases)
; NOTOF -> w_in=w_out(nspectra,nphases,nruns)
;
;COMMAND SYNTAX 
;	w2=corr_xyz(w1,filenum=<filenum>[,temp=<temp>])
;
;							KHA,JRS 27/6/02
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint = 0	; if iprint>0, show debugging messages

	IF iprint GT 0 THEN PRINT,'Start corr_xyz:'
	ON_IOERROR, finished

	take_datp, datp

	IF N_ELEMENTS(frn) GT 0 THEN iFR  = frn
	IF N_ELEMENTS(tmp) GT 0 THEN temp = tmp

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	sw = SIZE(w_in0)
	IF iprint GT 0 THEN PRINT, 'SIZE(w_in0) = ', sw

	par       = datp.p
	nspectra  = FIX(par[1])
	nphases   = FIX(par[2])
	nruns     = FIX(par[3])
	nchannels = FIX(par[6])
	TOF       = FIX(par[8])

	IF iprint GT 0 THEN BEGIN
		PRINT,'TOF=',TOF
		PRINT,'nspectra=',nspectra
		PRINT,'nphases=',nphases
		PRINT,'nruns=',nruns
	ENDIF

	IF nruns EQ 1 THEN x_in = datp.x ELSE x_in = datp.z
	y_in  = datp.y
	e_in0 = datp.e

	se = SIZE(e_in0)
	IF (se[0] NE sw[0]) OR (se[1] NE sw[1]) THEN BEGIN
		PRINT,'Error - SIZE(w_in0) = ',sw
		PRINT,'        SIZE(e_in0) = ',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	IF (TOF EQ 0) AND (nphases EQ 1) THEN BEGIN
		w_in = FLTARR(nspectra,nphases,nruns)
		e_in = FLTARR(nspectra,nphases,nruns)
		w_in[*,0,*] = w_in0[*,*]
		e_in[*,0,*] = e_in0[*,*]
	ENDIF ELSE BEGIN
		w_in = w_in0
		e_in = e_in0
	ENDELSE

	nFR = N_ELEMENTS(iFR)
	FR_file = STRARR(nFR)
	corr_FR = 1

	CASE nFR OF
	0: BEGIN
		PRINT, 'Corr_xyz: no flipping ratio correction'
		iFR = 0
		corr_FR = 0
	   END
	1: BEGIN
		PRINT,'Corr_xyz: performing FR correction with quartz file:'
		FR_file[0] = 'quartz_'+STRTRIM(STRING(iFR),2)+'.dat'
		junk = FINDFILE(FR_file(0), COUNT = co)
		IF co EQ 0 THEN BEGIN
			FR_file[0] = '/home/vis/d7/lambda/QUARTZFILES/'+FR_file[0]
			junk = FINDFILE(FR_file(0), COUNT = co)
			IF co EQ 0 THEN PRINT, !ERR_STRING
		ENDIF
		PRINT,'          ',FR_file[0]
	   END
	ELSE: BEGIN
		PRINT,'Corr_xyz: performing FR correction with quartz files:'
		FOR i = 0, nFR - 1 DO BEGIN
			FR_file[i] = 'quartz_' + STRTRIM(STRING(iFR(i)),2) + '.dat'
			junk = FINDFILE(FR_file(i),COUNT = co)
			IF co EQ 0 THEN BEGIN
				FR_file[i] = '/home/vis/d7/lambda/QUARTZFILES/' + FR_file[i]
				junk=FINDFILE(FR_file[i],COUNT = co)
				IF co EQ 0 THEN PRINT, !ERR_STRING
			ENDIF
			PRINT,'          ',FR_file[i]
		ENDFOR
	   END
	ENDCASE

	IF iprint GT 0 THEN BEGIN
		PRINT,'nruns   = ',nruns
		PRINT,'corr_FR = ', corr_FR, ' nFR = ', nFR
	ENDIF

	IF (nruns EQ 1) AND (nFR GT 1) THEN BEGIN
		PRINT,'Corr_xyz: Error - w_in contains data from only one run,'
		PRINT,'          but more than one FRfile is given'
		GOTO, finished
	ENDIF

	IF iprint GT 0 THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Open and read from input files

	line=''

	IF corr_FR EQ 1 THEN BEGIN
		num = FLTARR(5)
		Flip  = FLTARR(nspectra,nphases/2,nruns)
		dFlip = FLTARR(nspectra,nphases/2,nruns)

		FOR irun =0, nFR - 1 DO BEGIN
			IF iprint GT 0 THEN PRINT,'Opening FR file: ',FR_file[irun]
			OPENR, lun, FR_file[irun], ERROR=err, /GET_LUN
			IF err NE 0 THEN BEGIN
				PRINT, !ERR_STRING
				GOTO, finished
			ENDIF
			FOR i = 0,2 DO READF, lun, line
			line = line + ' -1'
			READS, line, num
			IF (num[4] GT -1.1) AND (num[4] LT -0.9) THEN BEGIN
				F = FLTARR(4,32)
				IF nphases EQ 6 THEN BEGIN
					PRINT,'Corr_xyz: Error - only 2 quartz phases in file'
					GOTO, finished
				ENDIF
			ENDIF ELSE BEGIN
				F = FLTARR(8,32)
				IF (nphases EQ 2) AND (iprint GT 0) THEN $
					PRINT,'Corr_xyz: Taking Z quartz phase for FR correction'
			ENDELSE
			POINT_LUN, lun, 0
			FOR i = 0, 1 DO READF, lun, line
			READF, lun, F
			CLOSE, lun
			iphase = INDGEN(nphases/2)*2
			 Flip[*,iphase/2,irun] = TRANSPOSE(F[2+iphase,*])
			dFlip[*,iphase/2,irun] = TRANSPOSE(F[3+iphase,*])
		ENDFOR

		IF nruns GT 1 THEN BEGIN
			inrun = INTARR(nruns)
			IF nFR EQ 1 THEN BEGIN
				 Flip[*,*,0:nruns-1] =  Flip[*,*,inrun]
				dFlip[*,*,0:nruns-1] = dFlip[*,*,inrun]
			ENDIF ELSE IF (nruns GT 2) AND (nFR EQ 2) THEN BEGIN
				FOR irun=nruns-1,1,-1 DO BEGIN
					Flip[*,*,irun] =  Flip[*,*,0] +  (Flip[*,*,1] - $
					Flip[*,*,0])*FLOAT(irun)/FLOAT(nruns-1)
				       dFlip[*,*,irun] = dFlip[*,*,0] + (dFlip[*,*,1] - $
				       dFlip[*,*,0])*FLOAT(irun)/FLOAT(nruns-1)
				ENDFOR
			ENDIF
		ENDIF
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of "read from input files" section'

;-------------------------------------------------------------------------------
;Perform correction

	IF (N_ELEMENTS(fudge) GT 0) AND (corr_FR EQ 1) THEN BEGIN
		i = INDGEN(32)
		 Flip[i,*,*] = fudge[i]*Flip[i,*,*]
		dFlip[i,*,*] = fudge[i]*dFlip[i,*,*]
	ENDIF

	w_out = w_in
	e_out = e_in

	IF (TOF EQ 0) THEN BEGIN
		w_out = FLTARR(nspectra,nphases,nruns)
		e_out = FLTARR(nspectra,nphases,nruns)
		iphase = INDGEN(nphases/2)*2
		R0  = w_in[*,iphase,*]
		R1  = w_in[*,iphase + 1,*]
		F   = Flip[*,iphase/2,*]
		dR0 = e_in[*,iphase,*]
		dR1 = e_in[*,iphase + 1,*]
		dF  = dFlip[*,iphase/2,*]	
		w_out[*,iphase,*]     = R0 + (R0 - R1)/(F - 1.)
		e_out[*,iphase,*]     = SQRT((dR0*F/(F - 1))^2 + $
		     		        (dF*(R0 - R1)/(F - 1.)^2)^2)
		w_out[*,iphase + 1,*] = R1 - (R0 - R1)/(F - 1.)
		e_out[*,iphase + 1,*] = SQRT((dR1*F/(F-1))^2 + $
		     		        (dF*(R0 - R1)/(F - 1.)^2)^2)
		ispec = INDGEN(nspectra)
		i = WHERE(w_in[ispec,0,0] EQ 0. AND e_in[ispec,0,0] LT 0., nz)
		IF nz NE 0 THEN w_out[i,*,*] = 0.
		IF nz NE 0 THEN e_out[i,*,*] = -1.
	ENDIF ELSE BEGIN
		w_out  = FLTARR(nchannels,nphases*nspectra)
		e_out  = FLTARR(nchannels,nphases*nspectra)
		iphase = INDGEN(nphases/2)*2
		ispec  = INDGEN(nspectra,nphases)
		R0  = w_in[*,REFORM(ispec[*,iphase])]
		R1  = w_in[*,REFORM(ispec[*,iphase + 1])]
		dR0 = e_in[*,REFORM(ispec[*,iphase])]
		dR1 = e_in[*,REFORM(ispec[*,iphase + 1])]
		ones = FLTARR(nchannels) + 1.0
		F   = ones # Flip[*,iphase/2]
		dF  = ones # dFlip[*,iphase/2]	
		
		w_out[*,REFORM(ispec[*,iphase])]   = R0 + (R0 - R1)/(F - 1.)
		e_out[*,REFORM(ispec[*,iphase])]   = SQRT((dR0*F/(F - 1.))^2 + $
		     		    		     (dF*(R0 - R1)/(F - 1.)^2)^2)
		w_out[*,REFORM(ispec[*,iphase+1])] = R1 - (R0 - R1)/(F - 1.)
		e_out[*,REFORM(ispec[*,iphase+1])] = SQRT((dR1*F/(F - 1))^2 + $
		     		        	     (dF*(R0 - R1)/(F - 1.)^2)^2)
		ispec = INDGEN(nspectra)
		i = WHERE(TOTAL(w_in(*,ispec),1) EQ 0.)
		is = [iphase*nspectra + i, (iphase + 1)*nspectra + i]
		w_out[*,i] = 0.
		e_out[*,i] = -1.
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'End of Correction section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	IF (TOF EQ 0 AND nphases EQ 1) THEN BEGIN
		w_out0=FLTARR(nspectra,nruns)	& e_out0=w_out0
		w_out0(*,*)=w_out(*,0,*)
		e_out0(*,*)=e_out(*,0,*)
	ENDIF ELSE BEGIN
		w_out0=w_out
		e_out0=e_out
	ENDELSE
	datp.e=e_out0
	datp.z_tit='Intensity (arb. units)'

	IF (corr_FR EQ 0) THEN FRs='0' ELSE FRs=STRTRIM(STRING(iFR(0)),2)
	IF (nFR GT 1) THEN FOR i=1,nFR-1 DO FRs=FRs+'+'+STRTRIM(STRING(iFR(i)),2)

	datp.other_tit=datp.other_tit+' -cx('+FRs+')'

finished:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'End corr_xyz:'

	give_datp, datp

	RETURN, w_out0
	END
; Cosmos
; version 2, Aug 2002
; written by Mark Laver
; interprets raw data from D17 runs
;  version 2 : uses errors instead of min/max values
; fundamental changes from d17tof :
;  errors = sqrt(count + 1)
;  angle / tof distance correction

; declare global variables
pro init_vars

; declare global variables
common global, widget_id, options
common table_head, table_labels
common analysis, constants, anal
common water, water_file, water_array
common direct, direct1_files, direct2_files, direct3_files, direct1_array, direct2_array, direct3_array, direct1_params, direct2_params, direct3_params
common waits, waittime
common dialogtxt, warnings

widget_id = { main:0L, datapath:0L, waterrun:0L, table:0L, columns:0L, filldown:0L, fillinc:0L, clear:0L, insertrow:0L, insertno:0L, calopt:0L, detopt:0L, macopt:0L,$
 save:0L, reset:0L, quit:0L, go:0L, calc:0L, foregd:0L, backgdleft:0L, backgdright:0L, lambda:0L, normalise:0L, backmeth:0L, group:0L, groupvar:0L, plotgraph:0L, $
verbose:0L, calc_cancel:0L, calc_ok:0L, detect:0L, usefulx:0L, searchx:0L, searchy:0L, detect_cancel:0L, detect_ok:0L, mach:0L, poff:0L, d0:0L, openoff:0L, pixelwidth:0L, $ 
mach_cancel:0L, mach_ok:0L, column:0L, colthirdang:0L, colinstrbackgd:0L, column_cancel:0L, column_ok:0L, dialogue:0L, dialogue_text:0L, dialogue_cancel:0L, dialogue_ok:0L, $
plot:0L, plot_area:0L, plot_close:0L }
options = { optstruct, path:'', waterrun:'', rowno:20L, lambda:'2.2, 19', foregd:'13', backgdleft:'10', backgdright:'10',$
normalise:0, backmeth:0, group:0, groupvar:2., plotgraph:0, verbose:0, usefulx:'30, 255', searchx:'', searchy:'auto',$
poff:279.4, d0:4.1685, openoff:1.02, pixelwidth:1.0213, colthirdang:0, colinstrbackgd:0 }

table_labels = [ 'Direct 1', 'Direct 2', 'Reflect 1', 'Reflect 2', 'Factor', 'Theta 1', 'Theta 2', 'Out file', 'Out LAMP' ]

constants = { chopsep:85e-3, chopwin:45., interslit:3500., pixels_x:286L, pixels_y:276L, pixels_t:500L, planckperkg:3.956e-7 }
anal = { quit:0, row:0L, usefulx:lonarr(2), searchx:lonarr(2), searchy:lonarr(2), foregd:lonarr(1), backgdleft:lonarr(2), backgdright:lonarr(2), lambda:fltarr(2) }

water_file = strarr(1)
water_array = make_array(constants.pixels_x, /float, value = 1.)

waittime = { none:0.05, short:0.1, long:2. }

warnings = strarr(1)

; define (other) global structures
temppar = { parameters, monitor:0L, runtime:0., dan:0., san:0., size_x:0L, size_t:0L, x_min:0L, x_max:0L, openangle:0., period:0., slits:0., tofd:0., delay:0., channelwidth:0., pixeldensity:0L }

direct1_files = strarr(1)
direct2_files = strarr(1)
direct3_files = strarr(1)
direct1_array = lonarr(constants.pixels_x, constants.pixels_t)
direct2_array = lonarr(constants.pixels_x, constants.pixels_t)
direct3_array = lonarr(constants.pixels_x, constants.pixels_t)
direct1_params = { parameters }
direct2_params = { parameters }
direct3_params = { parameters }

return
end


; append datasets [ x, err_x, y, err_y ]
function anal_append, array1, array2
return, transpose([ transpose(array1), transpose(array2) ])
end


; subtract averaged background on array [ x, t ] with error [ x, t ]
pro anal_backgroundaverage, arr, err, mask

for i = 0, n_elements(arr[0, *]) - 1 do begin
	background = mean(arr[mask, i])
	arr[*, i] = arr[*, i] - background
	err[*, i] = sqrt(err[*, i]^2 + abs(background)) ; add error in quadrature
endfor

return
end


; searches for peak in array, returning thresholds of peak
function anal_peaksearchbasic, array

result = lonarr(2)
temp2 = max(array, temp1)
result[0] = temp1 ; start at maximum
temp2 = (temp2 + min(array)) / 2. ; threshold of peak
while (array[result[0]] ge temp2) and (result[0] gt 0) do result[0] = result[0] - 1
result[1] = temp1
while (array[result[1]] ge temp2) and (result[1] lt n_elements(array) - 1) do result[1] = result[1] + 1

return, result
end


; refined search for peak in array using previous search and foreground range (0 is no range) and guess, returning peak centre
function anal_peaksearchrefined, array, search, foregd

temp = max(array[search[0]:search[1]], guess_new)
guess_new = guess_new + search[0]
repeat begin
guess_old = guess_new
low = (guess_old - fix((1. + foregd) / 2.)) > search[0]
high = ((guess_old + fix((1. + foregd) / 2.)) < search[1]) > (low + 1)
; calculated weighted mean
temp = total(array[low:high])
if temp gt 0. then guess_new = round(total(array[low:high] * (lindgen(high - low + 1) + low)) / temp)
endrep until guess_old eq guess_new

return, guess_new
end


; sort dataset [ x, err_x, y, err_y ] by x value
function anal_sort, dataset
result = dataset[*, sort(dataset[0, *])]
return, result
end


; normalise 1D array
function array_norm, array
return, array / (mean(array))
end


; convert number to string as printed
function str_make, value
return, strcompress(string(value, /print), /remove_all)
end


; separate string into a 1D array of component strings (separator is ',' or ':', keeping the separator at the front of each string)
function str_split, original

w = where((byte(original) eq (byte(','))[0]) or (byte(original) eq (byte(':'))[0]), count)
arr = strarr(count + 1)
spos = strlen(original)
for i = 0, count - 1 do begin
	arr[count - i] = strmid(original, w[count - i - 1], spos - w[count - i - 1])
	spos = w[count - i - 1]
endfor
arr[0] = strmid(original, 0, spos)

return, arr
end


; convert string to string plus number (floating or integer)
pro str_value, original, remainder, value, floating = f, integer = i

pos = strlen(original) - 1

on_ioerror, str_value_exit

while pos ge 0 do begin
if keyword_set(i) then value = long(strmid(original, pos, strlen(original) - pos)) else value = float(strmid(original, pos, strlen(original) - pos))
pos = pos - 1
end

str_value_exit:
if keyword_set(i) then value = long(strmid(original, pos + 1, strlen(original) - pos - 1)) else value = float(strmid(original, pos + 1, strlen(original) - pos - 1))
remainder = strmid(original, 0, pos + 1)

return
end


; 0
; -----------------------------------------------------------------------------
; 1


; calculate angle offset for flat detector surface
function anal_calcangleoffset, peakpos, xoff, density, distance
common global, widget_id, options
common analysis, constants, anal
return, atan(((peakpos + xoff) * density - (constants.pixels_x / 2.)) * (options.pixelwidth / 1000.), distance)
end


; returns factor to multiply dataset 1 [ x, err x, y, err y ] in order to match dataset 2
function anal_factor, array_a, array_b, linear = l, spline = s

result = fltarr(2)

; sort arrays
a = anal_sort(array_a)
b = anal_sort(array_b)
; extract cross over, returning zero if no cross over
overa = where(a[0, *] ge min(b[0, *]), count)
if count gt 0 then a = a[*, overa] else return, result
b = b[*, where(b[0, *] le max(a[0, *]))]
; produce interpolation arrays
if keyword_set(l) then begin
inter = interpol(a[2, *], a[0, *], b[0, *])
endif else begin
deriv = spl_init(a[0, *], a[2, *])
inter = spl_interp(a[0, *], a[2, *], deriv, b[0, *])
endelse
; find factor using sum of least squares
result[0] = total(b[2, *] * inter) / float(total(inter * inter))
result[1] = result[0]

return, result
end


; close open subwindows
pro close_subwins
common global, widget_id, options

if widget_id.calc ne 0 then widget_control, widget_id.calc, /destroy
if widget_id.detect ne 0 then widget_control, widget_id.detect, /destroy
if widget_id.mach ne 0 then widget_control, widget_id.mach, /destroy
if widget_id.column ne 0 then widget_control, widget_id.column, /destroy

return
end


; add text to dialogue window
pro dialogue_add, txt
common global, widget_id, options

if widget_id.dialogue ne 0 then begin
widget_control, widget_id.dialogue_text, get_value = textarr
textarr = [textarr, txt]
if n_elements(textarr) ge 30 then widget_control, widget_id.dialogue_text, set_text_top_line = n_elements(textarr) - 30, set_value = textarr else widget_control, widget_id.dialogue_text, set_value = textarr
endif

return
end


; add final warning to dialogue window
pro dialogue_warn, txt
common dialogtxt, warnings
common analysis, constants, anal

dialogue_add, ' Warning : ' + txt
temp = ' Row ' + str_make(anal.row) + ': ' + txt
warnings = [warnings, temp]

return
end


; clear requested
pro ev_clear
common global, widget_id

select = widget_info(widget_id.table, /table_select)
widget_control, widget_id.table, set_value = strarr(abs(select[2]-select[0])+1, abs(select[3]-select[1])+1), /use_table_select

end


; insert row requested
pro ev_insertrow
common global, widget_id

widget_control, widget_id.insertno, get_value = no
if no gt 0 then widget_control, widget_id.table, insert_rows = no, /use_table_select else widget_control, widget_id.insertno, set_value = 0L

end


; quit requested
pro ev_quit
common global, widget_id

if dialog_message('Are you sure you want to quit?', /cancel, /default_cancel, dialog_parent = widget_id.main, title = 'Cosmos : Warning') eq 'OK' then widget_control, widget_id.main, /destroy
end


; update calculation options
pro ev_updatecalc
common global, widget_id, options

widget_control, widget_id.foregd, get_value = txtarr1
options.foregd = txtarr1[0]
widget_control, widget_id.backgdleft, get_value = txtarr2
options.backgdleft = txtarr2[0]
widget_control, widget_id.backgdright, get_value = txtarr3
options.backgdright = txtarr3[0]
widget_control, widget_id.lambda, get_value = txtarr4
options.lambda = txtarr4[0]
widget_control, widget_id.normalise, get_value = val
options.normalise = val
widget_control, widget_id.backmeth, get_value = val
options.backmeth = val
widget_control, widget_id.group, get_value = val
options.group = val
widget_control, widget_id.groupvar, get_value = flt
options.groupvar = flt
widget_control, widget_id.plotgraph, get_value = val
options.plotgraph = val
widget_control, widget_id.verbose, get_value = val
options.verbose = val
widget_control, widget_id.calc, /destroy

end


; update detection range options
pro ev_updatedetect
common global, widget_id, options
common water, water_file, water_array

widget_control, widget_id.usefulx, get_value = txtarr1
options.usefulx = txtarr1[0]
widget_control, widget_id.searchx, get_value = txtarr2
options.searchx = txtarr2[0]
widget_control, widget_id.searchy, get_value = txtarr3
options.searchy = txtarr3[0]
widget_control, widget_id.detect, /destroy
water_file = strarr(1)

end


; update machine options
pro ev_updatemach
common global, widget_id, options

if dialog_message('Changing the offsets may have serious consequences.' + string(10b) + 'Are you sure you want to do this?', /cancel, /default_cancel, dialog_parent = widget_id.mach, title = 'Cosmos : Warning') eq 'OK' then begin
widget_control, widget_id.poff, get_value = val
options.poff = val
widget_control, widget_id.d0, get_value = val
options.d0 = val
widget_control, widget_id.openoff, get_value = val
options.openoff = val
widget_control, widget_id.pixelwidth, get_value = val
options.pixelwidth = val
endif
widget_control, widget_id.mach, /destroy

end


; window closed
pro ev_winclose, window_id
common global, widget_id
case window_id of
widget_id.calc : widget_id.calc = 0
widget_id.detect : widget_id.detect = 0
widget_id.mach : widget_id.mach = 0
widget_id.column : widget_id.column = 0
widget_id.dialogue : widget_id.dialogue = 0
widget_id.plot : widget_id.plot = 0
else :
endcase

end


; write to lamp
pro lamp_write, workspace, array, row

if (workspace ge 1) and (workspace le 23) then begin
common c_lamp_w, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, w23, wtb, wintb, w_in, w_out, w_buf, w_min, w_max, w_numor
common c_lamp_x, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x_in, x_out, x_buf
common c_lamp_y, y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15, y16, y17, y18, y19, y20, y21, y22, y23, y_in, y_out, y_buf
common c_lamp_z, z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23, z_in, z_out, z_buf
common c_lamp_e, e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e_in, e_out, e_buf
common c_lamp_n, n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n_in, n_out, n_buf
common c_lamp_p, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, npars, p_in, p_out, p_buf, par_txt, par_txt_all
common c_lamp_pv, pv0, pv1, pv2, pv3, pv4, pv5, pv6, pv7, pv8, pv9, pv10, pv11, pv12, pv13, pv14, pv15, pv16, pv17, pv18, pv19, pv20, pv21, pv22, pv23, pv_in, pv_out, pv_buf
common c_lamp_par, par1, par2, par3, par4, par5, par6, par7, par8, par9, par10, par11, par12, par13, par14, par15, par16, par17, par18, par19, par20, par21, par22, par23
common c_lamp_tit, x_tit, y_tit, z_tit, w_tit, other_tit, head_tit
dialogue_add, ' Writing to LAMP workspace w' + str_make(workspace)
wrksp = str_make(workspace)
write_x = reform(array[0, *])
write_w = reform(array[2, *])
write_e = reform(array[3, *])
write_wmin = min(write_w)
write_wmax = max(write_w)
temp = execute('x' + wrksp + ' = write_x')
temp = execute('y' + wrksp + ' = 0')
temp = execute('z' + wrksp + ' = 0')
temp = execute('w' + wrksp + ' = write_w')
temp = execute('w_max[' + wrksp + '] = write_wmax')
temp = execute('w_min[' + wrksp + '] = write_wmin')
temp = execute('e' + wrksp + ' = write_e')
temp = execute('n' + wrksp + ' = 0')
temp = execute('p' + wrksp + ' = 0')
temp = execute('par' + wrksp + ' = 0')
temp = execute('pv' + wrksp + ' = 0')
temp = execute('w_tit[' + wrksp + '] = "Reflectivity output from Cosmos, row ' + str_make(row) + '"')
temp = execute('x_tit[' + wrksp + '] = "q"')
temp = execute('y_tit[' + wrksp + '] = ""')
temp = execute('z_tit[' + wrksp + '] = ""')
temp = execute('other_tit[' + wrksp + '] = ""')
endif

return
end


; get main window options
pro main_getvars
common global, widget_id, options

widget_control, widget_id.datapath, get_value = temp
options.path = temp[0]
widget_control, widget_id.waterrun, get_value = temp
options.waterrun = temp[0]

return
end


; add graph to plot window, returning wait time to allow user to freeze plot
function plot_add, array, row
common global, widget_id, options
common waits, waittime

waitval = waittime.none
if widget_id.plot ne 0 then begin
widget_control, widget_id.plot_close, get_value = textarr
if textarr[0] eq ' Freeze ' then begin
widget_control, widget_id.plot_area, get_value = win_id
wset, win_id
pts = where((array[2, *] - array[3, *]) gt 0., num)
if num gt 0 then begin
	plot, reform(array[0, pts]), alog10(reform(array[2, pts])), title = 'Row ' + str_make(row), xtitle = 'q', /ynozero, ytitle = 'log( Reflectivity )'
	errplot, reform(array[0, pts]), alog10(reform(array[2, pts] - array[3, pts])), alog10(reform(array[2, pts] + array[3, pts]))
endif else begin
	erase
	xyouts, 200, 300, 'Empty plot for row ' + str_make(row), /device
endelse
waitval = waittime.long
endif
endif

return, waitval
end


; finish plot window
pro plot_finish
common global, widget_id, options

if widget_id.plot ne 0 then widget_control, widget_id.plot_close, set_value = ' Close '

return
end


; save options and table values
pro save_vars
common global, widget_id, options
common table_head, table_labels

save_name = 'cosmos_defaults'
print_name = 'cosmos_table.csv'
openw, save_lun, save_name, error = temp, /get_lun
if temp eq 0 then begin
on_ioerror, save_exit
widget_control, widget_id.table, get_value = table
; check for blank rows - blank[i] = -1 if row is blank
blanks = intarr(n_elements(table[0,*]))
for i = 0, (n_elements(table[0,*]) - 1) do begin
	temp2 = where(table[*,i] ne '', temp)
	if temp le 0 then blanks[i] = -1
endfor
save_rows = where(blanks ne -1, count)
save_options = options
if count ne 0 then begin
	save_table = strarr(n_elements(table_labels), count)
	for i = 0, (count - 1) do begin
	save_table[*, i] = table[*, save_rows[i]]
	endfor
	save_options.rowno = n_elements(save_table[0,*])
endif else save_options.rowno = 0
save_tags = strlowcase(tag_names(save_options))
; write options
printf, save_lun, 'Options'
for i = 0, (n_tags(save_options) - 1) do begin
	printf, save_lun, '' ; spacer
	printf, save_lun, save_tags[i]
	printf, save_lun, save_options.(i)
endfor
if save_options.rowno ne 0 then begin
	printf, save_lun, '' ; spacer
	printf, save_lun, 'Table'
	for i = 0, (n_elements(save_table[0,*]) - 1) do begin
		for j = 0, (n_elements(save_table[*,0]) - 1) do printf, save_lun, save_table[j,i]
	endfor
endif
close, save_lun
free_lun, save_lun

; save printable table for user in .csv format
openw, print_lun, print_name, error = temp, /get_lun
if temp eq 0 then begin
printf, print_lun, 'Table from Cosmos at ' + systime(0) + ':' + string(13b)
if save_options.rowno ne 0 then begin
	frmt = '($,' + str_make(n_elements(table_labels) - 1) + '(a, ","), a, a2)'
	printf, print_lun, format = frmt, table_labels, string(13b) + string(10b)
	for i = 0, (n_elements(save_table[0,*]) - 1) do printf, print_lun, format = frmt, save_table[*,i], string(13b) + string(10b)
endif
printf, print_lun, string(13b) ; spacer
printf, print_lun, 'Options:' + string(13b)
for i = 0, (n_tags(save_options) - 1) do printf, print_lun, format = '($, a, ",", a, a2)', save_tags[i], save_options.(i), string(13b) + string(10b)
close, print_lun
free_lun, print_lun
endif

endif

save_exit:
return
end


; outputs string corresponding to theta value
function str_formtheta, angle
case angle of
-1 : str = 'san'
-2 : str = 'dan'
else : str = str_make(angle)
endcase
return, str
end


; parse input string, returning array
function str_parse, original, float = f, integer = i,  flt_range = fr, int_range = ir, string_set = s

substrs = str_split(original)
if keyword_set(f) then begin
	str_value, substrs[n_elements(substrs) - 1], remainder, value, /floating
	array = [ value ]
	return, array
endif
if keyword_set(i) then begin
	str_value, substrs[n_elements(substrs) - 1], remainder, value, /integer
	array = [ value ]
	return, array
endif
if keyword_set(fr) or keyword_set(ir) then begin
	if n_elements(substrs) eq 1 then begin
		if keyword_set(ir) then begin
			str_value, substrs[0], remainder, value, /integer
			array = [ value, -1L ]
			return, array
		endif else begin
			str_value, substrs[0], remainder, value, /floating
			array = [ value, -1.]
			return, array
		endelse
	endif else begin
		if keyword_set(ir) then begin
			str_value, substrs[n_elements(substrs) - 2], remainder, int1, /integer
			str_value, substrs[n_elements(substrs) - 1], remainder, int2, /integer
			array = [ int1, int2 ]
			return, array
		endif else begin
			str_value, substrs[n_elements(substrs) - 2], remainder, flt1, /floating
			str_value, substrs[n_elements(substrs) - 1], remainder, flt2, /floating
			array = [ flt1, flt2 ]
			return, array
		endelse
	endelse
endif
; default or string_set
array = [ substrs[0] ]
curstr = 1
str_value, substrs[0], rempre, intpre, /integer
while curstr lt n_elements(substrs) do begin
str_value, substrs[curstr], remcur, intcur, /integer
remcur = strmid(remcur, 1, strlen(remcur) - 1)
if (strmid(substrs[curstr], 0, 1) eq ':') and (rempre eq remcur) then begin
	if intcur gt intpre then begin
		for i = intpre + 1, intcur do array = [ array, strcompress(remcur + string(i), /remove_all) ]
	endif
endif else array = [ array, strmid(substrs[curstr], 1, strlen(substrs[curstr]) - 1) ] ; ','
curstr = curstr + 1
rempre = remcur
intpre = intcur
end

return, array
end


; updates table labels
pro table_labelupdate
common global, widget_id, options
common table_head, table_labels

if options.colthirdang eq 0 then begin
	if options.colinstrbackgd eq 0 then table_labels = [ 'Direct 1', 'Direct 2', 'Reflect 1', 'Reflect 2', 'Factor', 'Theta 1', 'Theta 2', 'Out file', 'Out LAMP' ] else table_labels = [ 'Direct 1', 'Direct 2', 'Reflect 1', 'Reflect 2', 'Instr 1', 'Instr 2', 'Factor', 'Theta 1', 'Theta 2', 'Out file', 'Out LAMP' ]
endif else begin
	if options.colinstrbackgd eq 0 then table_labels = [ 'Direct 1', 'Direct 2', 'Direct 3', 'Reflect 1', 'Reflect 2', 'Reflect 3', 'Factor 1-2', 'Factor 2-3', 'Theta 1', 'Theta 2', 'Theta 3', 'Out file', 'Out LAMP' ] else table_labels = [ 'Direct 1', 'Direct 2', 'Direct 3', 'Reflect 1', 'Reflect 2', 'Reflect 3', 'Instr 1', 'Instr 2', 'Instr 3', 'Factor 1-2', 'Factor 2-3', 'Theta 1', 'Theta 2', 'Theta 3', 'Out file', 'Out LAMP' ]
endelse

return
end


; 1
; -----------------------------------------------------------------------------
; 2


; subtract fitted background
pro anal_backgroundfit, arr, err, mask, str

tsize = n_elements(arr[0, *])
xsize = n_elements(arr[*, 0])
tlim = tsize - 1
fit = fltarr(2, tsize)

for i = 0, tlim do begin
	fit(*, i) = linfit(mask, arr[mask, i])
	background = findgen(xsize) * fit[1, i] + fit[0, i] ; 1D array in x
	arr[*, i] = arr[*, i] - background
	err[*, i] = sqrt(err[*, i]^2 + abs(background)) ; add error in quadrature
endfor

dialogue_add, ' Background fitted to ' + str + ' runs with regression factors  y = a x + b  :'
dialogue_add, string(9b) + 'min' + string([9b, 9b]) + 'max'
dialogue_add, '  a' + string(9b) + str_make(min(fit[1, *])) + string(9b) + str_make(max(fit[1, *]))
dialogue_add, '  b' + string(9b) + str_make(min(fit[0, *])) + string(9b) + str_make(max(fit[0, *]))

return
end


; groups data using bundle algorithm (cf bundle.pro)
pro anal_bundle, result, resf

; unpackage data for bundle module
x = result[0, *] ; q values
y = result[2, *] ; reflectivity values
e = result[3, *] ; error on reflectivity values
dq = result[1, *] ; resolution of q values

; arrays to store grouped data
ny = fltarr(1000)
nx = fltarr(1000)
nee = fltarr(1000)
ndq = fltarr(1000)

dialogue_add, ' Grouping data using bundle : (factor ' + str_make(resf) + ')'

; number of elements in data
tot = n_elements(x) - 1

i = 1
repeat begin

c = 0 ; address to data
num = tot - 1
new = 0 ; address to grouped data
pairs = 0

while c lt num do begin
	if ((x[c + 1] - x[c]) lt (dq[c] / resf)) and (x[c + 1] ne 0) then begin
		ny[new] = (y[c + 1] / e[c + 1]^2. + y[c] / e[c]^2.) / (e[c + 1]^(-2.) + e[c]^(-2.))
		nee[new] = sqrt(e[c]^2. + e[c + 1]^2.) / 2.
		nx[new] = (x[c] + x[c + 1]) / 2.
		ndq[new] = (x[c + 1] + dq[c + 1] - x[c] + dq[c]) / 2.
		pairs = pairs + 1
		c = c + 2
		tot = tot - 1
	endif else begin
		ny[new] = y[c]
		nx[new] = x[c]
		nee[new] = e[c]
		ndq[new] = dq[c]
		c = c + 1
	endelse
	new = new + 1
end

y = ny
x = nx
e = nee
dq = ndq

dialogue_add, '  ' + str_make(pairs) + ' pairs found on iteration ' + str_make(i)
i = i + 1
endrep until pairs eq 0

result = fltarr(4, tot)
result[0, *] = nx[0 : tot - 1]
result[1, *] = ndq[0 : tot - 1]
result[2, *] = ny[0 : tot - 1]
result[3, *] = nee[0 : tot - 1]

return
end


; calculate corrected angle for flat detector surface
function anal_correctangle, angle, dirpeakpos, refpeakpos, dirxoff, refxoff, density, dirdist, refdist
return, (2. * angle - anal_calcangleoffset(dirpeakpos, dirxoff, density, dirdist) + anal_calcangleoffset(refpeakpos, refxoff, density, refdist)) / 2.
end


; calculate corrected time of flight distance for flat detector surface
function anal_correctdistance, peakpos, xoff, density, distance
return, distance / cos(anal_calcangleoffset(peakpos, xoff, density, distance))
; no correction
; return, distance
end


; create dialogue box
pro dialogue_create
common global, widget_id, options
common dialogtxt, warnings

if widget_id.dialogue eq 0 then begin
if options.verbose eq 0 then begin
; create dialogue window
widget_id.dialogue = widget_base(/base_align_center, /col, group_leader = widget_id.main, title = 'Cosmos')
widget_id.dialogue_text = widget_text(widget_id.dialogue, /frame, /scroll, value = 'Starting calculation...', xsize = '64', ysize = '32')
panel1 = widget_base(widget_id.dialogue, /align_right, /grid_layout, /row)
widget_id.dialogue_cancel = widget_button(panel1, value = ' Abandon ')
widget_id.dialogue_ok = widget_button(panel1, value = ' Quiet ')

widget_control, widget_id.dialogue, /realize
xmanager, 'Cosmos', widget_id.dialogue, cleanup = 'ev_winclose', event_handler = 'ev_poll', /no_block
warnings = strarr(1)
endif

endif else begin
if options.verbose eq 0 then begin
widget_control, widget_id.dialogue_text, set_value = 'Starting calculation...'
widget_control, widget_id.dialogue_cancel, sensitive = 1
widget_control, widget_id.dialogue_ok, set_value = ' Quiet '
widget_control, widget_id.dialogue, show = 1
warnings = strarr(1)
endif else widget_control, widget_id.dialogue, /destroy
endelse

return
end


; finish dialogue window
pro dialogue_finish
common global, widget_id, options
common dialogtxt, warnings

if n_elements(warnings) le 1 then dialogue_add, 'No warnings found during calculation.' else warnings[0] = 'Warnings found :'
dialogue_add, warnings
if widget_id.dialogue ne 0 then begin
widget_control, widget_id.dialogue_cancel, sensitive = 0
widget_control, widget_id.dialogue_ok, set_value = ' Close '
endif

return
end


; fill down requested
; any numbers found in top row of selected cells are incremented down table
; increment can be of floating type only for factor and theta
pro ev_filldown
common global, widget_id
common table_head, table_labels

select = widget_info(widget_id.table, /table_select)
if (select[0] ne -1) and ((select[3] - select[1]) gt 0) then begin

; get values for selected cells
; note USE_TABLE_SELECT keyword does not work!!
; produces segmentation and bus errors
; use at your peril!!
widget_control, widget_id.table, get_value = cells, sensitive = 0
widget_control, widget_id.fillinc, get_value = inc_req

for column = select[0], select[2] do begin

; obtain tag name of current column
tag_name = table_labels[column]

if (strpos(tag_name, 'Theta') ne -1) or (strpos(tag_name, 'Factor') ne -1) then inc_act = float(inc_req) else inc_act = long(inc_req)

str = strcompress(cells[column, select[1]], /remove_all)
split = str_split(str)

for row = select[1] + 1, select[3] do begin
cells[column, row] = ''

if float(inc_act) eq 0. then cells[column, row] = str else begin

for i = 0, n_elements(split) - 1 do begin
	if (strpos(tag_name, 'Theta') ne -1) or (strpos(tag_name, 'Factor') ne -1) then str_value, split[i], remainder, value, /floating else str_value, split[i], remainder, value, /integer
	cells[column, row] = cells[column, row] + remainder + str_make(value + (inc_act * (row - select[1])))
endfor

endelse

cells[column, row] = strcompress(cells[column, row], /remove_all)

endfor
endfor

widget_control, widget_id.table, set_value = cells, sensitive = 1

endif
end


; open calculation options window requested
pro ev_opencalcwindow
common global, widget_id, options

if widget_id.calc eq 0 then begin

; create calculation options window
widget_id.calc = widget_base(/base_align_center, /col, group_leader = widget_id.main, title = 'Calculation Options')
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
widget_id.foregd = cw_field(panel1, /column, title = 'Foreground Range', value = options.foregd, xsize = '16')
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
temp = widget_label(widget_id.calc, value = 'Background Range')
panel2 = widget_base(widget_id.calc, col = 2, /grid_layout)
widget_id.backgdleft = cw_field(panel2, /column, title = 'Left', value = options.backgdleft, xsize = '10')
widget_id.backgdright = cw_field(panel2, /column, title = 'Right', value = options.backgdright, xsize = '10')
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
widget_id.lambda = cw_field(panel1, /column, title = 'Lambda Range', value = options.lambda, xsize = '16')
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
widget_id.normalise = cw_bgroup(panel1, [' Runtime  ', ' Monitor '], /exclusive, label_top = ' Normalise ', /row, set_value = options.normalise)
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
widget_id.backmeth = cw_bgroup(panel1, [' Average  ', ' Fit '], /exclusive, label_top = ' Background Method ', /row, set_value = options.backmeth)
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
panel2 = widget_base(panel1, col = 2)
widget_id.group = cw_bgroup(panel2, [' Bundle ', ' None '], /col, /exclusive, label_top = ' Grouping ', set_value = options.group)
widget_id.groupvar = cw_field(panel2, /column, /floating, title = string(10b) + 'Factor:', value = options.groupvar, xsize = 8)
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
widget_id.plotgraph = cw_bgroup(panel1, ' Plot Graphs ', /nonexclusive, /row, set_value = options.plotgraph)
panel1 = widget_base(widget_id.calc, /base_align_center, /col, /frame, xsize = 350)
widget_id.verbose = cw_bgroup(panel1, [' Verbose  ', ' Quiet '], /exclusive, /row, set_value = options.verbose)
panel1 = widget_base(widget_id.calc, /align_right, /grid_layout, /row)
widget_id.calc_cancel = widget_button(panel1, value = ' Cancel ')
widget_id.calc_ok = widget_button(panel1, value = ' OK ')

widget_control, widget_id.calc, /realize
xmanager, 'Cosmos', widget_id.calc, cleanup = 'ev_winclose', event_handler = 'ev_poll', /no_block

endif else widget_control, widget_id.calc, show = 1

end


; open column options window requested
pro ev_opencolumnwindow
common global, widget_id, options

if widget_id.column eq 0 then begin

widget_id.column = widget_base(/base_align_center, /col, group_leader = widget_id.main, title = 'Setup Columns')
panel1 = widget_base(widget_id.column, /base_align_center, /col, /frame, xsize = 300)
widget_id.colthirdang = cw_bgroup(panel1, ' Third Angle ', /nonexclusive, /row, set_value = options.colthirdang)
panel1 = widget_base(widget_id.column, /base_align_center, /col, /frame, xsize = 300)
widget_id.colinstrbackgd = cw_bgroup(panel1, ' Instrument Backgrounds ', /nonexclusive, /row, set_value = options.colinstrbackgd)
panel1 = widget_base(widget_id.column, /align_right, /grid_layout, /row)
widget_id.column_cancel = widget_button(panel1, value = ' Cancel ')
widget_id.column_ok = widget_button(panel1, value = ' OK ')

widget_control, widget_id.column, /realize
xmanager, 'Cosmos', widget_id.column, cleanup = 'ev_winclose', event_handler = 'ev_poll', /no_block

endif else widget_control, widget_id.column, show = 1

end


; open detection options window requested
pro ev_opendetectwindow
common global, widget_id, options

if widget_id.detect eq 0 then begin

; create detection options window
widget_id.detect = widget_base(/base_align_center, /col, group_leader = widget_id.main, title = 'Detector Ranges')
panel1 = widget_base(widget_id.detect, /base_align_center, /col, /frame, xsize = 280)
widget_id.usefulx = cw_field(panel1, /column, title = ' Useful Range in x ', value = options.usefulx, xsize = 16)
panel1 = widget_base(widget_id.detect, /base_align_center, /col, /frame, xsize = 280)
temp = widget_label(panel1, value = ' Search Range For Peak ')
widget_id.searchx = cw_field(panel1, title = ' x: ', value = options.searchx, xsize = 16)
widget_id.searchy = cw_field(panel1, title = ' t: ', value = options.searchy, xsize = 16)
panel1 = widget_base(widget_id.detect, /align_right, /grid_layout, /row)
widget_id.detect_cancel = widget_button(panel1, value = ' Cancel ')
widget_id.detect_ok = widget_button(panel1, value = ' OK ')

widget_control, widget_id.detect, /realize
xmanager, 'Cosmos', widget_id.detect, cleanup = 'ev_winclose', event_handler = 'ev_poll', /no_block

endif else widget_control, widget_id.detect, show = 1

end


; open machine options window requested
pro ev_openmachwindow
common global, widget_id, options

if widget_id.mach eq 0 then begin

; create machine options window
widget_id.mach = widget_base(/base_align_center, /col, group_leader = widget_id.main, title = 'Machine Options')
panel1 = widget_base(widget_id.mach, /base_align_center, /grid_layout, /col, /frame)
widget_id.poff = cw_field(panel1, /floating, title = '    Offset Poff: ', value = options.poff, xsize = 8)
widget_id.d0 = cw_field(panel1, /floating, title = '      Offset d0: ', value = options.d0, xsize = 8)
widget_id.openoff = cw_field(panel1, /floating, title = ' Opening Offset: ', value = options.openoff, xsize = 8)
widget_id.pixelwidth = cw_field(panel1, /floating, title = '    Pixel Width: ', value = options.pixelwidth, xsize = 8)
panel1 = widget_base(widget_id.mach, /align_right, /grid_layout, /row)
widget_id.mach_cancel = widget_button(panel1, value = ' Cancel ')
widget_id.mach_ok = widget_button(panel1, value = ' OK ')

widget_control, widget_id.mach, /realize
xmanager, 'Cosmos', widget_id.mach, cleanup = 'ev_winclose', event_handler = 'ev_poll', /no_block

endif else widget_control, widget_id.mach, show = 1

end


; freeze or close button pressed on plot window
pro ev_plotevent
common global, widget_id, options
common analysis, constants, anal

widget_control, widget_id.plot_close, get_value = textarr
widget_control, widget_id.plot_close, /clear_events
if textarr eq ' Freeze ' then plot_finish else widget_control, widget_id.plot, /destroy

end


; save requested
pro ev_save

; update main window options
main_getvars

; save to file
save_vars

; save to readable file
save_vars

end


; update column labels request
pro ev_updatecolumns
common global, widget_id, options
common table_head, table_labels

if dialog_message('Changing the column setup will cause distortion of table data.' + string(10b) + 'Are you sure you want to continue?', /cancel, /default_cancel, dialog_parent = widget_id.column, title = 'Cosmos : Warning') eq 'OK' then begin

widget_control, widget_id.colthirdang, get_value = val
options.colthirdang = val
widget_control, widget_id.colinstrbackgd, get_value = val
options.colinstrbackgd = val

widget_control, widget_id.table, get_value = table

table_labelupdate
widget_control, widget_id.table, column_labels = table_labels, table_xsize = n_elements(table_labels)

if n_elements(table[*, 0]) lt n_elements(table_labels) then table = [ table, strarr(n_elements(table_labels) - n_elements(table[*, 0]), n_elements(table[0, *])) ] else table = table[0 : n_elements(table_labels) - 1, *]

widget_control, widget_id.table, set_value = table

endif

widget_control, widget_id.column, /destroy

end


; write to file
pro file_write, outfile, result, direct1, direct2, direct3, reflect1, reflect2, reflect3, instr1, instr2, instr3, theta1, theta2, theta3, water_file, aft = keyaft, dat = keydat, out = keyout, raw = keyraw
common global, widget_id, options
common analysis, constants, anal

outname = str_sep(outfile, '.', /remove_all)
outname = outname[0]
if outname eq '' then begin
	if strlen(reflect1[0]) gt 1 then outname = reflect1[0] else outname = 'cosmos' + str_make(anal.row)
endif
if keyword_set(keyaft) then outfile = outname + '.aft'
if keyword_set(keydat) then outfile = outname + '.dat'
if keyword_set(keyraw) then outfile = outname + '.raw'
if keyword_set(keyout) then outfile = outname + '.out'
openw, write_lun, outfile, error = temp1, /get_lun
if temp1 eq 0 then begin
on_ioerror, write_exit
dialogue_add, ' Writing to file ' + outfile
if keyword_set(keyout) then begin
printf, write_lun, ' Direct beam 1: ', direct1
printf, write_lun, ' Reflect beam 1: ', reflect1
printf, write_lun, ' Instrument background 1: ', instr1
printf, write_lun, ' Theta 1: ', str_formtheta(theta1)
printf, write_lun, ' Direct beam 2: ', direct2
printf, write_lun, ' Reflect beam 2: ', reflect2
printf, write_lun, ' Instrument background 2: ', instr2
printf, write_lun, ' Theta 2: ', str_formtheta(theta2)
printf, write_lun, ' Direct beam 3: ', direct3
printf, write_lun, ' Reflect beam 3: ', reflect3
printf, write_lun, ' Instrument background 3: ', instr3
printf, write_lun, ' Theta 3: ', str_formtheta(theta3)
printf, write_lun, ' Water: ', water_file
printf, write_lun, ' Foreground: ', options.foregd
printf, write_lun, ' Background:  Left: ', options.backgdleft
printf, write_lun, '             Right: ', options.backgdright
printf, write_lun, ' Lambda Range: ', options.lambda
printf, write_lun, ' Useful Pixel Range: ', options.usefulx
printf, write_lun, ' Search Range, x: ', options.searchx
printf, write_lun, ' Search Range, t: ', options.searchy
printf, write_lun, '' ; spacer
printf, write_lun, string(9b) + 'q' + string(9b) + '   refl' + string([9b, 9b]) + 'refl err' + string(9b) + 'q res'
for i = 0, n_elements(result[0, *]) - 1 do printf, write_lun, result[0, i], result[2, i], result[3, i], result[1, i]
endif else if keyword_set(keyaft) then begin
printf, write_lun, 'AFIT' + string(13b)
if strlen(reflect1[0]) gt 0 then printf, write_lun, 'Results for reflect beam ' + reflect1[0] + string(13b) else printf, write_lun, 'Cosmos Results' + string(13b)
printf, write_lun, format = '($,f4.2,a2)', 2.07, string(13b) + string(10b)
printf, write_lun, format = '($,i0,a2)', n_elements(result[0, *]), string(13b) + string(10b)
for i = 0, n_elements(result[0, *]) - 1 do printf, write_lun, format = '($,g10.4,10x,g10.4,10x,g10.4,a2)', result[0, i], result[2, i], result[3, i], string(13b) + string(10b)
endif else if keyword_set(keydat) then begin
for i = 0, n_elements(result[0, *]) - 1 do printf, write_lun, result[0, i], string(9b), result[2, i], string(9b), result[3, i], string(13b)
endif else begin
for i = 0, n_elements(result[0, *]) - 1 do printf, write_lun, result[0, i], string(9b), result[2, i], string(9b), result[3, i], string(9b), result[1, i]
endelse
close, write_lun
free_lun, write_lun
endif
write_exit:

return
end


; load options and table values
function load_vars
common global, widget_id, options
common table_head, table_labels

load_name = 'cosmos_defaults'
openr, load_lun, load_name, error = temp, /get_lun
if temp eq 0 then begin
; on_ioerror, load_exit
load_options = { optstruct }
temp = ''
readf, load_lun, temp ; 'Options'
if temp eq 'Options' then begin
	; read options
	for i = 0, (n_tags(load_options) - 1) do begin
		readf, load_lun, temp ; spacer
		readf, load_lun, temp ; tag
		var = load_options.(i)
		readf, load_lun, var
		load_options.(i) = var
	endfor
endif else load_options = options
options = load_options
; update table labels
table_labelupdate
if options.rowno lt 20 then table = strarr(n_elements(table_labels), 20) else table = strarr(n_elements(table_labels), options.rowno)
if options.rowno gt 0 then begin
	readf, load_lun, temp ; ''
	readf, load_lun, temp ; 'Table'
	if temp eq 'Table' then begin
		for i = 0, (options.rowno - 1) do begin
			for j = 0, (n_elements(table[*,0]) - 1) do begin
				readf, load_lun, temp
				table[j,i] = temp
			endfor
		endfor
	endif
endif
close, load_lun
free_lun, load_lun
options.rowno = n_elements(table[0,*])
endif else begin
load_exit:
table = strarr(n_elements(table_labels), 20)
options.rowno = 20
endelse
return, table
end


; create plot window
pro plot_create
common global, widget_id, options

if widget_id.plot eq 0 then begin
if options.plotgraph ne 0 then begin
widget_id.plot = widget_base(/base_align_center, /col, group_leader = widget_id.main, title = 'Cosmos')
widget_id.plot_area = widget_draw(widget_id.plot, /frame, xsize = 700, ysize = 500, retain = 2)
panel1 = widget_base(widget_id.plot, /align_right, /row)
widget_id.plot_close = widget_button(panel1, value = ' Freeze ')

widget_control, widget_id.plot, /realize

widget_control, widget_id.plot_area, get_value = win_id
wset, win_id
xyouts, 200, 300, 'Waiting for data...', /device

xmanager, 'Cosmos', widget_id.plot, cleanup = 'ev_winclose', event_handler = 'ev_poll', /no_block
endif

endif else begin
if options.plotgraph ne 0 then begin
widget_control, widget_id.plot_close, set_value = ' Freeze '
widget_control, widget_id.plot, show = 1
endif else widget_control, widget_id.plot, /destroy
endelse

return
end


; reads from raw data files (specified by array of strings), returning
;  summed detector counts (int array (x, t))
;  parameters :
;   params.monitor : summed monitor counts (long) which is 0 if no files found
;   params.runtime : summed runtime (seconds) (float)
;   params.dan : detector angle (dan) (degrees) (float)
;   params.san : sample angle (san) (degrees) float)
;   params.size_x : number of pixels in x direction (long)
;   params.size_t : number of time channels (long)
;   params.x_min : lower limit of pixels used
;   params.x_max : upper limit of pixels used
;   params.tofd : time of flight distance (float)
;   params.delay : time delay (float)
;   params.channelwidth : channel width (float)
;   params.pixeldensity : pixel density
pro raw_read, files, counts, params
common global, widget_id, options
common analysis, constants, anal

flag_defined = 0
for f = 0, n_elements(files) - 1 do begin
on_ioerror, raw_read_exit1
if files[f] ne '' then begin
if (str_make(long(files[f])) eq files[f]) and (strlen(files[f]) lt 6) then begin
	file_name = '000000'
	strput, file_name, files[f], 6 - strlen(files[f])
endif else begin
raw_read_exit1:
	file_name = files[f]
endelse
file_name = options.path + file_name

on_ioerror, raw_read_exit2

openr, raw_lun, file_name, error = tempval, /get_lun
if tempval eq 0 then begin
dialogue_add, ' Reading ' + file_name
tempstr = ''
; read in 34 lines of text
for i = 1, 34 do readf, raw_lun, tempstr
; read 1st set of parameters
par1 = fltarr(128)
readf, raw_lun, par1
; read 2 line spacer
for i = 1, 2 do readf, raw_lun, tempstr
; read 2nd set of parameters
par2 = fltarr(256)
readf, raw_lun, par2
; useful parameter information :
;  params1[ ] :
;   2 : run time (in tenths of a second)
;   4 : total monitor counts
;   94 : number of channels
;   95 : channel width (micro seconds)
;   96 : tof delay (micro seconds)
;   97 : x1
;   98 : x2
;   99 : y1
;   100 : y2
;   101 : nx, detector grouping factor in x (ie nx = 1 => base detector has 286 pixels in x, nx = 2 => base detector has 144 pixels in x)
;   102 : ny, detector grouping factor in y (ny = 1 => 276 pixels)
;  params2[ ] :
;   2 : san, sample angle
;   15 : sample to detector distance (millimetres)
;   16 : dan, detector angle
;   40 : requested chopper 1 speed (revs / min)
;   41 : requested chopper 1 phase (degrees)
;   42 : requested chopper 2 speed
;   43 : requested chopper 2 phase
;   44 : actual chopper 1 speed
;   45 : actual chopper 1 phase
;   46 : actual chopper 2 speed
;   47 : actual chopper 2 phase
;   93 : slit value
;   95 : slit value
temppar = { parameters }
temppar.monitor = long(par1[4])
temppar.runtime = float(par1[2] / 10.)
temppar.dan = float(par2[16])
temppar.san = float(par2[2])
temppar.size_x = long(par1[98] - par1[97] + 1)
temppar.size_t = long(par1[94])
temppar.x_min = long(par1[97])
temppar.x_max = long(par1[98])
temppar.slits = (par2[93] + par2[95]) / 2.
temppar.tofd = float(par2[15] * 1e-3) + options.d0 - (constants.chopsep / 2.)
temppar.openangle = constants.chopwin - (par2[47] - par2[45]) - options.openoff
temppar.period = 60. / par2[44]
tempdelayangle = (options.poff - temppar.openangle) / 2.
temppar.delay = par1[96] * 1e-6 - (tempdelayangle / 360.) * temppar.period
temppar.channelwidth = par1[95] * 1e-6
temppar.pixeldensity = par1[101]
size_y = long(par1[100] - par1[99] + 1)
if flag_defined eq 0 then begin
	params = temppar
	params.monitor = 0l
	params.runtime = 0.
	counts = lonarr(temppar.size_x, temppar.size_t)
	flag_defined = 1
endif
; compare with old parameters and output warning if different
if abs(temppar.dan - params.dan) gt 0.1 then dialogue_warn, 'Variation in detector angle detected between files.'
if abs(temppar.san - params.san) gt 0.1 then dialogue_warn, 'Variation in sample angle detected between files.'
if (temppar.size_x ne params.size_x) or (temppar.size_t ne params.size_t) then dialogue_add, '  Error : Unable to read file. Incompatible data array dimensions.' else begin

; augment parameters
params.monitor = params.monitor + temppar.monitor
params.runtime = params.runtime + temppar.runtime
; read 3 line spacer
for i = 1, 3 do readf, raw_lun, tempstr
; read total number of pixels in detector
readf, raw_lun, tempvar
; construct detector array of specified size
if size_y le 1 then detarr = lonarr(params.size_x, params.size_t) else detarr = lonarr(size_y, params.size_x, params.size_t)
; read detector data
readf, raw_lun, detarr

; augment counts
if size_y le 1 then counts = counts + detarr else counts = counts + total(detarr, 1)

endelse
close, raw_lun
free_lun, raw_lun
endif
endif
raw_read_exit2 :
endfor

if flag_defined eq 0 then begin
	counts = fltarr(constants.pixels_x, constants.pixels_t)
	params = { parameters }
	params.monitor = 0
	params.runtime = 0.
	params.size_x = constants.pixels_x
	params.size_t = constants.pixels_t
endif
return
end


; parse 'theta' string, returning float between 0 and 360 or -1 for san (default), -2 for dan
function str_theta, string
case strlowcase(string) of
'' : value = -1.
'san' : value = -1.
'dan' : value = -2.
else : value = ((str_parse(string, /float) mod 360) + 360.) mod 360 ; ensure 0 < value < 360
endcase
return, value
end


; 2
; -----------------------------------------------------------------------------
; 3


; read direct beam files, using previously read values if any
pro direct_read, newfiles, cntdir, pardir, runno
common direct, direct1_files, direct2_files, direct3_files, direct1_array, direct2_array, direct3_array, direct1_params, direct2_params, direct3_params

case runno of
1 : temp2 = direct1_files
2 : temp2 = direct2_files
3 : temp2 = direct3_files
endcase
temp1 = where(newfiles ne temp2, count) ; compare existing direct files
if count gt 0 then begin ; read new direct files
	raw_read, newfiles, counts, params
	case runno of
	1 : begin
		direct1_files = newfiles
		direct1_array = counts
		direct1_params = params
	end
	2 : begin
		direct2_files = newfiles
		direct2_array = counts
		direct2_params = params
	end
	3 : begin
		direct3_files = newfiles
		direct3_array = counts
		direct3_params = params
	end
	endcase
endif
; return appropriate values
case runno of
1 : begin
	cntdir = direct1_array
	pardir = direct1_params
end
2 : begin
	cntdir = direct2_array
	pardir = direct2_params
end
3 : begin
	cntdir = direct3_array
	pardir = direct3_params
end
endcase

return
end


; 3
; -----------------------------------------------------------------------------
; 4


; analyze run, returning array (q, q res, reflectivity, reflectivity err) or -1 if error
function anal_run, direct, reflect, instr, theta, runno
common global, widget_id, options
common analysis, constants, anal
common water, water_file, water_array

; local variables :
;  tsize, xsize ; size of count arrays
;  trangedir, trangeref, xrangedir, xrangeref ; ranges for peak searching
;  xlim ; useful limits of detector
;  peakdir, peakref ; centre of peaks in x direction
;  fgdsizedir, fgdsizeref ; size of foreground window
;  fgddir, fgdref ; ranges of foreground
;  bgddir, bgdref ; arrays of background pixels
;  bgddirno, bgdrefno ; number of background pixels
;  angle_centre ; angle to centre of detector
;  angle_bragg ; Bragg angle

; read data
direct_read, direct, cntdir, pardir, runno
if (pardir.monitor le 0) and (pardir.runtime le 0) then begin
	dialogue_add, ' Error: No direct counts read. Unable to calculate for run ' + str_make(runno) + '.'
	return, -1
endif
raw_read, reflect, cntref, parref
raw_read, instr, cntins, parins
; detector size consistency
if (parref.monitor le 0) and (parref.runtime le 0) then begin ; assume direct beam only required
	dialogue_warn, 'No reflect beam read (run ' + str_make(runno) + '). Calculating for direct beam only...'
	cntref = cntdir
	cntdir = fltarr(n_elements(cntref[*, 0]), n_elements(cntref[0, *]))
	cntins = fltarr(n_elements(cntref[*, 0]), n_elements(cntref[0, *]))
	parref = pardir
endif
tsize = n_elements(cntref[0, *])
xsize = n_elements(cntref[*, 0])
if n_elements(cntdir) ne n_elements(cntref) then begin
	dialogue_add, ' Warning : Incompatible size of data array for direct runs. Resizing...'
	cntdir = congrid(cntdir, xsize, tsize, /minus_one, /interp)
endif
if n_elements(cntref) ne n_elements(cntins) then begin
	if parins.monitor gt 0 then dialogue_add, ' Warning : Incompatible size of data array for instrument background runs. Resizing...'
	cntins = congrid(cntins, xsize, tsize, /minus_one, /interp)
endif

; errors (arrays of floats formed)
cntdir = float(cntdir)
cntref = float(cntref)
cntins = float(cntins)
cntdir_err = sqrt(cntdir + 1.)
cntref_err = sqrt(cntref + 1.)
cntins_err = sqrt(cntins + 1.)

; normalise to direct beam
if options.normalise eq 0 then begin ; runtime
	if float(pardir.runtime) le 0. then begin
		dialogue_warn, 'Unable to normalise. Direct beam runtime read as ' + str_make(pardir.runtime) + '.'
		temp1 = 1.
		temp2 = 1.
	endif else begin
		temp1 = parref.runtime / float(pardir.runtime)
		temp2 = parins.runtime / float(pardir.runtime)
	endelse
endif else begin ; monitor
	if float(pardir.monitor) le 0. then begin
		dialogue_warn, 'Unable to normalise. Direct beam monitor read as ' + str_make(pardir.monitor) + '.'
		temp1 = 1.
		temp2 = 1.
	endif else begin
		temp1 = parref.monitor / float(pardir.monitor)
		temp2 = parins.monitor / float(pardir.monitor)
	endelse
endelse
cntref = cntref / temp1
cntref_err = cntref_err / temp1
if (parins.monitor gt 0) or (parins.runtime gt 0) then begin
	cntins = cntins / temp2
	cntins_err = cntins_err / temp2
	; subtract instrument backgrounds
	cntref = cntref - cntins
	cntref_err = sqrt(cntref_err^2 + cntins_err^2) ; add errors in quadrature
	cntdir = cntdir - cntins
	cntdir_err = sqrt(cntdir_err^2 + cntins_err^2)
endif

; water correction
for i = 0, tsize - 1 do begin
cntdir[*, i] = cntdir[*, i] / water_array[pardir.x_min:pardir.x_max]
cntdir_err[*, i] = cntdir_err[*, i] / water_array[pardir.x_min:pardir.x_max]
cntref[*, i] = cntref[*, i] / water_array[pardir.x_min:pardir.x_max]
cntref_err[*, i] = cntref_err[*, i] / water_array[pardir.x_min:pardir.x_max]
endfor

; useful limits
xlim = [ (anal.usefulx[0] - pardir.x_min) > 0L, (anal.usefulx[1] - pardir.x_min) < (xsize - 1) ] ; assumes x_min/max same for direct and reflect runs

; search for peak
if anal.searchy[1] lt 0 then begin ; 'auto' option
	; range as default in previous version of d17tof
	trangedir = [ tsize / 2, tsize - 1 ]
	trangeref = [ tsize / 2, tsize - 1 ]
	; optional code to use for peak search in time:
	; trangedir = anal_peaksearchbasic(total(cntdir, 1)) ; total counts as function of t
	; trangeref = anal_peaksearchbasic(total(cntref, 1))
	dialogue_add, ' Auto search : Search area for peak in time channels found as :'
	dialogue_add, '  Direct beam  : ' + str_make(trangedir[0]) + ' to ' + str_make(trangedir[1])
	dialogue_add, '  Reflect beam : ' + str_make(trangeref[0]) + ' to ' + str_make(trangeref[1])
endif else begin
	trangedir = anal.searchy
	trangeref = anal.searchy
endelse
if anal.searchx[1] lt 0 then begin ; 'auto' option
	xrangedir = anal_peaksearchbasic(total(cntdir, 2)) ; total counts as function of x
	xrangeref = anal_peaksearchbasic(total(cntref, 2))
	dialogue_add, ' Auto search : Search area for peak in x (pixels) found as :'
	dialogue_add, '  Direct beam  : ' + str_make(xrangedir[0]) + ' to ' + str_make(xrangedir[1])
	dialogue_add, '  Reflect beam : ' + str_make(xrangeref[0]) + ' to ' + str_make(xrangeref[1])
endif else begin
	xrangedir = anal.searchx
	xrangeref = anal.searchx
endelse
xrangedir = [ xrangedir[0] > xlim[0], xrangedir[1] < xlim[1] ]
xrangeref = [ xrangeref[0] > xlim[0], xrangeref[1] < xlim[1] ]

; check foreground window size
if anal.foregd[0] le 0 then begin ; 'auto' foreground
	temp1 = anal_peaksearchbasic(total(cntdir, 2))
	fgdsizedir = temp1[1] - temp1[0]
	temp1 = anal_peaksearchbasic(total(cntref, 2))
	fgdsizeref = temp1[1] - temp1[0]
endif else begin
	fgdsizedir = anal.foregd[0]
	fgdsizeref = anal.foregd[0]
endelse

; refine search in x direction
peakdir = anal_peaksearchrefined(total(cntdir[*, trangedir[0]:trangedir[1]], 2), xrangedir, fgdsizedir)
peakref = anal_peaksearchrefined(total(cntref[*, trangeref[0]:trangeref[1]], 2), xrangeref, fgdsizeref)

; foreground and background ranges
fgddir = lonarr(2)
fgddir[0:1] = [ (peakdir - fix((fgdsizedir - 1) / 2.)) > xlim[0], (peakdir + fix((fgdsizedir - 1) / 2.)) < xlim[1] ]
fgdref = lonarr(2)
fgdref[0:1] = [ (peakref - fix((fgdsizeref - 1) / 2.)) > xlim[0], (peakref + fix((fgdsizeref - 1) / 2.)) < xlim[1] ]
bgddir = intarr(xsize) ; mask for background
bgdref = intarr(xsize)
if (anal.backgdleft[0] le 0L) and (anal.backgdleft[1] lt 0L) then begin ; 'auto' left background
	if fgddir[0] gt xlim[0] then bgddir[xlim[0] : fgddir[0] - 1] = 1
	if fgdref[0] gt xlim[0] then bgdref[xlim[0] : fgdref[0] - 1] = 1
endif else begin
	temp1 = fgddir[0] - (anal.backgdleft[1] > 0L) - 1
	if (temp1 ge xlim[0]) and (anal.backgdleft[0] gt 0) then bgddir[ (temp1 - anal.backgdleft[0] + 1) > xlim[0] : temp1 ] = 1
	temp1 = fgdref[0] - (anal.backgdleft[1] > 0L) - 1
	if (temp1 ge xlim[0]) and (anal.backgdleft[0] gt 0) then bgdref[ (temp1 - anal.backgdleft[0] + 1) > xlim[0] : temp1 ] = 1
endelse
if (anal.backgdright[0] le 0L) and (anal.backgdright[1] lt 0L) then begin ; 'auto' right background
	if fgddir[1] lt xlim[1] then bgddir[fgddir[1] + 1 : xlim[1] ] = 1
	if fgdref[1] lt xlim[1] then bgdref[fgdref[1] + 1 : xlim[1] ] = 1
endif else begin
	temp1 = fgddir[1] + (anal.backgdright[1] > 0L) + 1
	if (temp1 le xlim[1]) and (anal.backgdright[0] gt 0) then bgddir[ temp1 : (temp1 + anal.backgdright[0] - 1) < xlim[1] ] = 1
	temp1 = fgdref[1] + (anal.backgdright[1] > 0L) + 1
	if (temp1 le xlim[1]) and (anal.backgdright[0] gt 0) then bgdref[ temp1 : (temp1 + anal.backgdright[0] - 1) < xlim[1] ] = 1
endelse

; background arrays
bgddir = where(bgddir eq 1, bgddirno)
if bgddirno le 0 then dialogue_warn, 'No background to subtract on direct runs.'
bgdref = where(bgdref eq 1, bgdrefno)
if bgdrefno le 0 then dialogue_warn, 'No background to subtract on reflect runs.'

; output information
dialogue_add, ' Beam sum ranges :' + string(9b) + 'Direct beam' + string(9b) + 'Reflect beam'
dialogue_add, '  Foreground :' + string([9b, 9b]) + str_make(fgddir[0]) + ' ' + str_make(fgddir[1]) + string([9b, 9b]) + str_make(fgdref[0]) + ' ' + str_make(fgdref[1])
dialogue_add, '  Total background :' + string(9b) + str_make(bgddirno) + string([9b, 9b]) + str_make(bgdrefno)

; subtract backgrounds
if options.backmeth eq 0 then begin ; 'average'
if bgddirno gt 0 then anal_backgroundaverage, cntdir, cntdir_err, bgddir
if bgdrefno gt 0 then anal_backgroundaverage, cntref, cntref_err, bgdref
endif else begin ; 'fit'
if bgddirno gt 0 then anal_backgroundfit, cntdir, cntdir_err, bgddir, 'direct'
if bgdrefno gt 0 then anal_backgroundfit, cntref, cntref_err, bgdref, 'reflect'
endelse

; sum over x
cntdir = total(cntdir[fgddir[0] : fgddir[1], *], 1)
cntdir_err = sqrt(total(cntdir_err[fgddir[0] : fgddir[1], *]^2, 1)) ; add errors in quadrature
cntref = total(cntref[fgdref[0] : fgdref[1], *], 1)
cntref_err = sqrt(total(cntref_err[fgdref[0] : fgdref[1], *]^2, 1))

; calculate angle
case theta of
-1. : angle_bragg = parref.san * !pi / 180. ; convert to radians
-2. : begin
	angle_centre = ((parref.dan + pardir.dan) / 2.) * !pi / 180.
	angle_bragg = anal_correctangle(angle_centre, peakdir, peakref, pardir.x_min, parref.x_min, parref.pixeldensity, pardir.tofd, parref.tofd)
	dialogue_add, ' Angle to centre of detector found as ' + str_make(angle_centre * 180. / !pi)
end
else : angle_bragg = theta
endcase
dialogue_add, ' Bragg angle to centre of peak calculated as ' + str_make(angle_bragg * 180. / !pi)

; form lambda[t] (Angstroms) array from reflect runs
temp1 = anal_correctdistance(peakref, parref.x_min, parref.pixeldensity, parref.tofd)
temp2 = abs(temp1 - anal_correctdistance(peakdir, pardir.x_min, pardir.pixeldensity, pardir.tofd))
dialogue_add, ' Difference in corrected TOF distance between direct and reflect beams is ' + str_make(temp2)
if (temp2 / temp1) gt 0.01 then dialogue_warn, ' Row ' + str_make(anal.row) + ': Run no. ' + str_make(runno) + ': Different TOF distances from direct and reflect runs.'
lambda = 1e10 * (constants.planckperkg * ((findgen(tsize) + 0.5) * parref.channelwidth + parref.delay) / temp1)

; write lambda[t] array to file
temp1 = 0
openw, lambda_lun, 'cosmos_lambdaconv' + str_make(runno) + '.dat', error = temp1, /get_lun
if temp1 eq 0 then begin
on_ioerror, lambda_exit
printf, lambda_lun, 'Time Pixel,   Wavelength (Angstroms)'
for i = 0, n_elements(lambda) - 1 do printf, lambda_lun, i, ',', lambda[i]
close, lambda_lun
free_lun, lambda_lun
endif
lambda_exit:

if anal.lambda[1] eq 0 then lambda_range = where(lambda gt 0., result_size) else lambda_range = where((lambda gt anal.lambda[0]) and (lambda lt anal.lambda[1]), result_size)

; calculate q and reflectivity
if result_size gt 0 then begin
err_res = (constants.chopsep + (constants.planckperkg * parref.openangle * parref.period / (360. * lambda[lambda_range] * 1.e-10))) / parref.tofd ; wavelength resolution
err_ray = 2. * atan(parref.slits / constants.interslit) / angle_bragg ; angular resolution
result = fltarr(4, result_size)
result[0, *] = 4. * !pi * sin(angle_bragg) / lambda[lambda_range]
result[1, *] = result[0, *] * sqrt(err_res^2 + err_ray^2)
if max(cntdir[lambda_range]) le 0. then begin
	result[2, *] = cntref[lambda_range]
	result[3, *] = cntref_err[lambda_range]
endif else begin
	result[2, *] = cntref[lambda_range] / cntdir[lambda_range]
	result[3, *] = abs(result[2, *]) * sqrt((cntref_err[lambda_range] / cntref[lambda_range])^2 + (cntdir_err[lambda_range] / cntdir[lambda_range])^2)
endelse
; tidy floating point errors
temp1 = where((finite(result[2, *]) eq 1) and (finite(result[3, *]) eq 1), temp2)
if temp2 gt 0 then result = result[*, temp1] else result = -1
endif else result = -1
return, result
end


; reset requested
pro ev_reset
common global, widget_id, options
common table_head, table_labels

; load variables
table = load_vars()

; update table
widget_control, widget_id.table, column_labels = table_labels, table_xsize = n_elements(table_labels)
widget_control, widget_id.table, set_value = table, table_ysize = n_elements(table[0, *])

; update fields of main window
widget_control, widget_id.datapath, set_value = options.path
widget_control, widget_id.waterrun, set_value = options.waterrun

; close open subwindows
close_subwins

end


; 4
; -----------------------------------------------------------------------------
; 5


; do calculation in background
pro ev_background
common global, widget_id, options
common table_head, table_labels
common analysis, constants, anal
common water, water_file, water_array
common waits, waittime

widget_control, widget_id.table, get_value = table
table = strcompress(table, /remove_all)

if (anal.quit eq 0) and (anal.row lt n_elements(table[0, *])) then begin

dialogue_add, 'Analysing row ' + str_make(anal.row) + '...'
direct3 = strarr(1)
reflect3 = strarr(1)
instr1 = strarr(1)
instr2 = strarr(1)
instr3 = strarr(1)
factor2 = fltarr(1)
theta3 = 0.
for col = 0, n_elements(table[*, 0]) - 1 do begin
case table_labels[col] of
'Direct 1' : direct1 = str_parse(table[col, anal.row], /string_set)
'Direct 2' : direct2 = str_parse(table[col, anal.row], /string_set)
'Direct 3' : direct3 = str_parse(table[col, anal.row], /string_set)
'Reflect 1' : reflect1 = str_parse(table[col, anal.row], /string_set)
'Reflect 2' : reflect2 = str_parse(table[col, anal.row], /string_set)
'Reflect 3' : reflect3 = str_parse(table[col, anal.row], /string_set)
'Instr 1' : instr1 = str_parse(table[col, anal.row], /string_set)
'Instr 2' : instr2 = str_parse(table[col, anal.row], /string_set)
'Instr 3' : instr3 = str_parse(table[col, anal.row], /string_set)
'Factor' : factor1 = str_parse(table[col, anal.row], /float)
'Factor 1-2' : factor1 = str_parse(table[col, anal.row], /float)
'Factor 2-3' : factor2 = str_parse(table[col, anal.row], /float)
'Theta 1' : theta1 = str_theta(table[col, anal.row])
'Theta 2' : theta2 = str_theta(table[col, anal.row])
'Theta 3' : theta3 = str_theta(table[col, anal.row])
'Out file' : begin
	outfile = str_parse(table[col, anal.row], /string_set)
	outfile = outfile[n_elements(outfile) - 1]
end
'Out LAMP' : outlamp = str_parse(table[col, anal.row], /integer)
else :
endcase
endfor

; produce [ qmin, qmax, reflectivity min, reflectivity max ] arrays
if direct1[0] ne '' then res1 = anal_run(direct1, reflect1, instr1, theta1, 1) else res1 = -1
if direct2[0] ne '' then res2 = anal_run(direct2, reflect2, instr2, theta2, 2) else res2 = -1
if direct3[0] ne '' then res3 = anal_run(direct3, reflect3, instr3, theta3, 3) else res3 = -1

rescheck1 = n_elements(res1) gt 1
rescheck2 = n_elements(res2) gt 1
rescheck3 = n_elements(res3) gt 1
factor1 = factor1[0]
factor2 = factor2[0]
; match results
if rescheck1 and rescheck2 then begin
	if factor1 eq 0. then begin
		temp1 = anal_factor(res1, res2)
		if temp1[0] eq 0. then begin
			factor1 = 1.
			dialogue_warn, 'No overlap between run 1 and run 2'
		endif else begin
			factor1 = 1. / mean(temp1)
			dialogue_add, ' Auto factor 1-2 found as ' + str_make(factor1)
		endelse
	endif
endif
if rescheck2 and rescheck3 then begin
	if factor2 eq 0. then begin
		temp1 = anal_factor(res2, res3)
		if temp1[0] eq 0. then begin
			factor2 = 1.
			dialogue_warn, 'No overlap between run 2 and run 3'
		endif else begin
			factor2 = 1. / mean(temp1)
			dialogue_add, ' Auto factor 2-3 found as ' + str_make(factor2)
		endelse
	endif
endif
if rescheck1 and rescheck3 then begin
	if (factor1 * factor2) eq 0. then begin
		temp1 = anal_factor(res1, res3)
		factor2 = 1.
		if temp1[0] eq 0. then begin
			factor1 = 1.
			dialogue_warn, 'No overlap between run 1 and run 3'
		endif else begin
			factor1 = 1. / mean(temp1)
			dialogue_add, ' Auto factor 1-3 found as ' + str_make(factor1)
		endelse
	endif
endif
case (ishft(rescheck1, 2) + ishft(rescheck2, 1) + rescheck3) of
0 : result = -1
1 : result = res3
2 : result = res2
3 : begin
	res3[2:3, *] = res3[2:3, *] * factor2
	result = anal_append(res2, res3)
end
4 : result = res1
5 : begin
	res3[2:3, *] = res3[2:3, *] * factor1 * factor2
	result = anal_append(res1, res3)
end
6 : begin
	res2[2:3, *] = res2[2:3, *] * factor1
	result = anal_append(res1, res2)
end
7 : begin
	res2[2:3, *] = res2[2:3, *] * factor1
	res3[2:3, *] = res3[2:3, *] * factor1 * factor2
	result = anal_append(anal_append(res1, res2), res3)
end
else : result = -1
endcase

if n_elements(result) gt 1 then begin
result = anal_sort(result)

; write unbundled data to .out file
file_write, outfile, result, direct1, direct2, direct3, reflect1, reflect2, reflect3, instr1, instr2, instr3, theta1, theta2, theta3, water_file, /out

; group data
if options.group eq 0 then anal_bundle, result, options.groupvar

; plot
waitplot = plot_add(result, anal.row)

; write bundled data to file(s) and logged bundled data to lamp
if options.group ne 1 then begin
	file_write, outfile, result, direct1, direct2, direct3, reflect1, reflect2, reflect3, instr1, instr2, instr3, theta1, theta2, theta3, water_file, /aft
	file_write, outfile, result, direct1, direct2, direct3, reflect1, reflect2, reflect3, instr1, instr2, instr3, theta1, theta2, theta3, water_file, /dat
endif
pts = where((result[2, *] - result[3, *]) gt 0., temp1)
if temp1 gt 0 then begin
	resultlog = fltarr(4, temp1)
	resultlog[0, *] = reform(result[0, pts])
	resultlog[1, *] = reform(result[1, pts])
	resultlog[2, *] = alog10(reform(result[2, pts]))
	resultlog[3, *] = (alog10(reform(result[2, pts] + result[3, pts])) - alog10(reform(result[2, pts] - result[3, pts]))) / 2.
	lamp_write, outlamp[0], resultlog, anal.row
endif else dialogue_warn, 'Logged dataset empty.'

endif else waitplot = waittime.none

anal.row = anal.row + 1
if widget_id.dialogue ne 0 then waitval = waittime.short > waitplot else waitval = waittime.none > waitplot
widget_control, widget_id.go, timer = waitval

endif else begin

if anal.quit ne 0 then dialogue_add, 'Interrupted at row ' + str_make(anal.row - 1) else dialogue_add, 'End of calculation.'

dialogue_finish
plot_finish
widget_control, widget_id.main, sensitive = 1

endelse

; clear math errors
temp1 = check_math()

end


; setup calculation
pro ev_go
common global, widget_id, options
common table_head, table_labels
common analysis, constants, anal
common water, water_file, water_array
common direct, direct1_files, direct2_files, direct3_files, direct1_array, direct2_array, direct3_array, direct1_params, direct2_params, direct3_params
common waits, waittime

close_subwins
main_getvars
widget_control, widget_id.main, sensitive = 0
plot_create
dialogue_create
anal.quit = 0
; reset direct read files (file path may have changed)
direct1_files = strarr(1)
direct2_files = strarr(1)
direct3_files = strarr(1)

; parse detector ranges
anal.usefulx = str_parse(options.usefulx, /int_range)
if anal.usefulx[0] lt 0L then anal.usefulx[0] = 0L ; lower limit of useful pixels in x direction of detector
if (anal.usefulx[1] gt (constants.pixels_x - 1)) or (anal.usefulx[1] le 0L) then anal.usefulx[1] = (constants.pixels_x - 1) ; upper limit of useful pixels in y direction of detector
anal.usefulx = anal.usefulx[sort(anal.usefulx)]
dialogue_add, 'Useful range in x read as ' + str_make(anal.usefulx[0]) + ' to ' + str_make(anal.usefulx[1])
anal.searchx = str_parse(options.searchx, /int_range)
if anal.searchx[0] lt anal.usefulx[0] then anal.searchx[0] = anal.usefulx[0]
if (anal.searchx[1] gt anal.usefulx[1]) then anal.searchx[1] = anal.usefulx[1]
if anal.searchx[1] gt 0L then begin
	anal.searchx = anal.searchx[sort(anal.searchx)]
	dialogue_add, 'Search range in x read as ' + str_make(anal.searchx[0]) + ' to ' + str_make(anal.searchx[1])
endif ; else 'auto' value -1 has been selected
anal.searchy = str_parse(options.searchy, /int_range)
if anal.searchy[0] lt 0L then anal.searchy[0] = 0L ; lower limit of pixels to search for peak in detector time
if anal.searchy[1] gt (constants.pixels_t - 1) then anal.searchy[1] = (constants.pixels_t - 1) ; upper limit of pixels to search for peak in detector time
if anal.searchy[1] gt 0L then begin
	anal.searchy = anal.searchy[sort(anal.searchy)]
	dialogue_add, 'Search range in y read as ' + str_make(anal.searchy[0]) + ' to ' + str_make(anal.searchy[1])
endif ; else 'auto' value -1 has been selected

; parse calculation ranges
anal.foregd = str_parse(options.foregd, /integer)
if anal.foregd[0] lt 0L then anal.foregd[0] = 0L ; width of foreground (0 is default)
dialogue_add, 'Width of foreground read as ' + str_make(anal.foregd[0])
anal.backgdleft = str_parse(options.backgdleft, /int_range)
if anal.backgdleft[0] lt 0L then anal.backgdleft[0] = 0L ; width of background on left of peak, anal.backgdleft[1] is shift in background (-1 implies no shift), backgd = [0, 0] implies no background
anal.backgdright = str_parse(options.backgdright, /int_range)
if anal.backgdright[0] lt 0L then anal.backgdright[0] = 0L ; width of background on right of peak
dialogue_add, 'Background read as : ' + string(9b) + 'left' + string(9b) + 'right'
dialogue_add, string(9b) + 'Width : ' + string(9b) + str_make(anal.backgdleft[0]) + string(9b) + str_make(anal.backgdright[0])
dialogue_add, string(9b) + 'Shift : ' + string(9b) + str_make(anal.backgdleft[1]) + string(9b) + str_make(anal.backgdright[1])
anal.lambda = str_parse(options.lambda, /flt_range)
if anal.lambda[0] lt 0. then anal.lambda[0] = 0. ; lower limit of wavelength window
if anal.lambda[1] lt 0. then anal.lambda[1] = 0. ; upper limit of wavelength window (0 is no limit)
anal.lambda = anal.lambda[sort(anal.lambda)]
dialogue_add, 'Wavelength range read as ' + str_make(anal.lambda[0]) + ' to ' + str_make(anal.lambda[1])

; water run(s)
temp2 = str_parse(options.waterrun, /string_set)
temp1 = where(temp2 ne water_file, temp3) ; compare existing water file
if temp3 gt 0 then begin
	raw_read, temp2, counts, params
	if params.runtime gt 0 then begin
		water_file = temp2
		dialogue_add, 'Using ' + water_file + ' as water file'
		; total over t and store in water array
		water_array = fltarr(constants.pixels_x)
		water_array[params.x_min : params.x_max] = total(counts, 2)
		water_array[0 : anal.usefulx[0] - 1] = 1.
		water_array[anal.usefulx[0] : anal.usefulx[1]] = array_norm(water_array[anal.usefulx[0] : anal.usefulx[1]])
		water_array[anal.usefulx[1] + 1 : constants.pixels_x - 1] = 1.
		if min(water_array) le 0. then begin
			dialogue_warn, 'Zero efficiency pixels detected in water file.'
			dialogue_add, 'Please redefine useful detector range.'
			water_file = strarr(1)
			anal.quit = 1
		endif
	endif
endif

; clear math errors
temp1 = check_math()

anal.row = 0L
widget_control, widget_id.go, timer = waittime.none

end


; 5
; -----------------------------------------------------------------------------
; 6


; handle gui events
pro ev_poll, event
common global, widget_id, options
common analysis, constants, anal

case event.id of
; main window events
widget_id.columns : ev_opencolumnwindow
widget_id.filldown : ev_filldown
widget_id.fillinc : ev_filldown
widget_id.clear : ev_clear
widget_id.insertrow : ev_insertrow
widget_id.insertno : ev_insertrow
widget_id.calopt : ev_opencalcwindow
widget_id.detopt : ev_opendetectwindow
widget_id.macopt : ev_openmachwindow
widget_id.save : ev_save
widget_id.reset : ev_reset
widget_id.quit : ev_quit
widget_id.go : if strlowcase(tag_names(event, /structure_name)) eq 'widget_timer' then ev_background else ev_go
; calculation window events
widget_id.calc_cancel : widget_control, widget_id.calc, /destroy
widget_id.calc_ok : ev_updatecalc
; detection window events
widget_id.detect_cancel : widget_control, widget_id.detect, /destroy
widget_id.detect_ok : ev_updatedetect
; machine window events
widget_id.mach_cancel : widget_control, widget_id.mach, /destroy
widget_id.mach_ok : ev_updatemach
; column setup window events
widget_id.column_cancel : widget_control, widget_id.column, /destroy
widget_id.column_ok : ev_updatecolumns
; dialogue window events
widget_id.dialogue_cancel : begin
	anal.quit = 1
	widget_control, widget_id.dialogue_cancel, /clear_events
end
widget_id.dialogue_ok : widget_control, widget_id.dialogue, /destroy
; plot window events
widget_id.plot_close : ev_plotevent
else :
endcase

end


; 6
; -----------------------------------------------------------------------------


; initialise - note this procedure must be at end of file so above functions are compiled.
pro cosmos

; initialise variables
init_vars

common global, widget_id, options
common table_head, table_labels

table = load_vars()

; create main window
widget_id.main = widget_base(/base_align_center, /col, title = 'Cosmos')
; path fields
panel1 = widget_base(widget_id.main, /row)
widget_id.datapath = cw_field(panel1, /frame, title = 'Data Path: ', value = options.path, xsize = 12)
temp = widget_base(panel1, xsize = 100)
widget_id.waterrun = cw_field(panel1, /frame, title = 'Water Runs: ', value = options.waterrun, xsize = 12)
temp = widget_base(panel1, xsize = 130)
widget_id.columns = widget_button(panel1, /frame, value  = '  Setup Columns  ')
; panel for table and toolbar
panel1 = widget_base(widget_id.main, /base_align_center, /col, /frame)
; toolbar
panel2 = widget_base(panel1, col = 3)
panel3 = widget_base(panel2, /align_left, /frame, /row)
	widget_id.filldown = widget_button(panel3, value = '  Fill Down  ')
	widget_id.fillinc = cw_field(panel3, /floating, /return_events, title = 'Increment:', value = 0., xsize = 8)
panel3 = widget_base(panel2, xsize = 140)
panel3 = widget_base(panel2, /align_right, /frame, /row)
	widget_id.clear = widget_button(panel3, value =   '    Clear    ')
	panel4 = widget_base(panel3, xsize = 32)
	widget_id.insertrow = widget_button(panel3, value = ' Insert Rows ')
	widget_id.insertno = cw_field(panel3, /long, /return_events, title = 'No:', value = 0L, xsize = 8)
; table
widget_id.table = widget_table(panel1, alignment = 2, column_labels = table_labels, /editable, /frame, /resizeable_columns, /scroll, value = table, xsize = n_elements(table_labels), x_scroll_size = 9, y_scroll_size = 12, ysize = options.rowno)
; panel for action buttons
panel1 = widget_base(widget_id.main, col = 3)
panel2 = widget_base(panel1, /align_left, /frame, /grid_layout, /row)
widget_id.calopt = widget_button(panel2, value = ' Calculation ' + string(10b) + ' Options ')
widget_id.detopt = widget_button(panel2, value = ' Detector ' + string(10b) + ' Ranges ')
widget_id.macopt = widget_button(panel2, value = ' Machine ' + string(10b) + ' Options ')
temp = widget_base(panel1, xsize = 200)
panel2 = widget_base(panel1, /align_right, /frame, /grid_layout, /row)
widget_id.save = widget_button(panel2, value = ' Save ')
widget_id.reset = widget_button(panel2, value = ' Reset ')
widget_id.quit = widget_button(panel2, value = ' Quit ')
widget_id.go = widget_button(panel2, value = ' Go ')

; open main window
widget_control, widget_id.main, /realize
xmanager, 'Cosmos', widget_id.main, event_handler = 'ev_poll', /no_block

end
; $Id: curvefit.pro,v 1.7 1995/06/15 16:24:13 dave Exp $
function curvefit, x, y, w, a, sigmaa, Function_Name = Function_Name, $
                        itmax=itmax, iter=iter, tol=tol, chi2=chi2, $
                        noderivative=noderivative
; Copyright (c) 1988-1995, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CURVEFIT
;
; PURPOSE:
;       Non-linear least squares fit to a function of an arbitrary 
;       number of parameters.  The function may be any non-linear 
;       function.  If available, partial derivatives can be calculated by 
;       the user function, else this routine will estimate partial derivatives
;       with a forward difference approximation.
;
; CATEGORY:
;       E2 - Curve and Surface Fitting.
;
; CALLING SEQUENCE:
;       Result = CURVEFIT(X, Y, W, A, SIGMAA, FUNCTION_NAME = name, $
;                         ITMAX=ITMAX, ITER=ITER, TOL=TOL, /NODERIVATIVE)
;
; INPUTS:
;       X:  A row vector of independent variables.  This routine does
;		not manipulate or use values in X, it simply passes X
;		to the user-written function.
;
;       Y:  A row vector containing the dependent variable.
;
;       W:  A row vector of weights, the same length as Y.
;               For no weighting,
;               w(i) = 1.0.
;               For instrumental weighting,
;               w(i) = 1.0/y(i), etc.
;
;       A:  A vector, with as many elements as the number of terms, that 
;           contains the initial estimate for each parameter.  If A is double-
;           precision, calculations are performed in double precision, 
;           otherwise they are performed in single precision.
;
; KEYWORDS:
;       FUNCTION_NAME:  The name of the function (actually, a procedure) to 
;       fit.  If omitted, "FUNCT" is used. The procedure must be written as
;       described under RESTRICTIONS, below.
;
;       ITMAX:  Maximum number of iterations. Default = 20.
;       ITER:   The actual number of iterations which were performed
;       TOL:    The convergence tolerance. The routine returns when the
;               relative decrease in chi-squared is less than TOL in an 
;               interation. Default = 1.e-3.
;       CHI2:   The value of chi-squared on exit
;       NODERIVATIVE:   If this keyword is set then the user procedure will not
;               be requested to provide partial derivatives. The partial
;               derivatives will be estimated in CURVEFIT using forward
;               differences. If analytical derivatives are available they
;               should always be used.
;
; OUTPUTS:
;       Returns a vector of calculated values.
;       A:  A vector of parameters containing fit.
;
; OPTIONAL OUTPUT PARAMETERS:
;       Sigmaa:  A vector of standard deviations for the parameters in A.
;
; COMMON BLOCKS:
;       NONE.
;
; SIDE EFFECTS:
;       None.
;
; RESTRICTIONS:
;       The function to be fit must be defined and called FUNCT,
;       unless the FUNCTION_NAME keyword is supplied.  This function,
;       (actually written as a procedure) must accept values of
;       X (the independent variable), and A (the fitted function's
;       parameter values), and return F (the function's value at
;       X), and PDER (a 2D array of partial derivatives).
;       For an example, see FUNCT in the IDL User's Libaray.
;       A call to FUNCT is entered as:
;       FUNCT, X, A, F, PDER
; where:
;       X = Variable passed into CURVEFIT.  It is the job of the user-written
;		function to interpret this variable.
;       A = Vector of NTERMS function parameters, input.
;       F = Vector of NPOINT values of function, y(i) = funct(x), output.
;       PDER = Array, (NPOINT, NTERMS), of partial derivatives of funct.
;               PDER(I,J) = DErivative of function at ith point with
;               respect to jth parameter.  Optional output parameter.
;               PDER should not be calculated if the parameter is not
;               supplied in call. If the /NODERIVATIVE keyword is set in the
;               call to CURVEFIT then the user routine will never need to
;               calculate PDER.
;
; PROCEDURE:
;       Copied from "CURFIT", least squares fit to a non-linear
;       function, pages 237-239, Bevington, Data Reduction and Error
;       Analysis for the Physical Sciences.
;
;       "This method is the Gradient-expansion algorithm which
;       combines the best features of the gradient search with
;       the method of linearizing the fitting function."
;
;       Iterations are performed until the chi square changes by
;       only TOL or until ITMAX iterations have been performed.
;
;       The initial guess of the parameter values should be
;       as close to the actual values as possible or the solution
;       may not converge.
;
; EXAMPLE:  Fit a function of the form f(x) = a * exp(b*x) + c to
;	sample pairs contained in x and y.
;	In this example, a=a(0), b=a(1) and c=a(2).
;	The partials are easily computed symbolicaly:
;		df/da = exp(b*x), df/db = a * x * exp(b*x), and df/dc = 1.0
;
;		Here is the user-written procedure to return F(x) and
;		the partials, given x:
;       pro gfunct, x, a, f, pder	; Function + partials
;	  bx = exp(a(1) * x)
;         f= a(0) * bx + a(2)		;Evaluate the function
;         if N_PARAMS() ge 4 then $	;Return partials?
;		pder= [[bx], [a(0) * x * bx], [replicate(1.0, N_ELEMENTS(y))]]
;       end
;
;         x=findgen(10)			;Define indep & dep variables.
;         y=[12.0, 11.0,10.2,9.4,8.7,8.1,7.5,6.9,6.5,6.1]
;         w=1.0/y			;Weights
;         a=[10.0,-0.1,2.0]		;Initial guess
;         yfit=curvefit(x,y,w,a,sigmaa,function_name='gfunct')
;	  print, 'Function parameters: ', a
;         print, yfit
;       end
;
; MODIFICATION HISTORY:
;       Written, DMS, RSI, September, 1982.
;       Does not iterate if the first guess is good.  DMS, Oct, 1990.
;       Added CALL_PROCEDURE to make the function's name a parameter.
;              (Nov 1990)
;       12/14/92 - modified to reflect the changes in the 1991
;            edition of Bevington (eq. II-27) (jiy-suggested by CreaSo)
;       Mark Rivers, U of Chicago, Feb. 12, 1995
;           - Added following keywords: ITMAX, ITER, TOL, CHI2, NODERIVATIVE
;             These make the routine much more generally useful.
;           - Removed Oct. 1990 modification so the routine does one iteration
;             even if first guess is good. Required to get meaningful output
;             for errors. 
;           - Added forward difference derivative calculations required for 
;             NODERIVATIVE keyword.
;           - Fixed a bug: PDER was passed to user's procedure on first call, 
;             but was not defined. Thus, user's procedure might not calculate
;             it, but the result was then used.
;           
;-
;       on_error,2              ;Return to caller if error
       ;Name of function to fit
       if n_elements(function_name) le 0 then function_name = "FUNCT"
       if n_elements(tol) eq 0 then tol = 1.e-3		;Convergence tolerance
       if n_elements(itmax) eq 0 then itmax = 20	;Maximum # iterations
	type = size(a)
	type = type(type(0)+1)
	double = type eq 5
	if (type ne 4) and (type ne 5) then a = float(a)  ;Make params floating

       ; If we will be estimating partial derivatives then compute machine
       ; precision
       if keyword_set(NODERIVATIVE) then begin
          res = nr_machar(DOUBLE=double)
          eps = sqrt(res.eps)
       endif

       nterms = n_elements(a)   ; # of parameters
       nfree = n_elements(y) - nterms ; Degrees of freedom
       if nfree le 0 then message, 'Curvefit - not enough data points.'
       flambda = 0.001          ;Initial lambda
       diag = lindgen(nterms)*(nterms+1) ; Subscripts of diagonal elements

;      Define the partial derivative array
       if double then pder = dblarr(n_elements(y), nterms) $
	else pder = fltarr(n_elements(y), nterms)
;
       for iter = 1, itmax do begin   ; Iteration loop

;         Evaluate alpha and beta matricies.
          if keyword_set(NODERIVATIVE) then begin
;            Evaluate function and estimate partial derivatives
             call_procedure, Function_name, x, a, yfit
             for term=0, nterms-1 do begin
                p = a       ; Copy current parameters
                ; Increment size for forward difference derivative
                inc = eps * abs(p(term))    
                if (inc eq 0.) then inc = eps
                p(term) = p(term) + inc
                call_procedure, function_name, x, p, yfit1
                pder(0,term) = (yfit1-yfit)/inc
             endfor
          endif else begin
             ; The user`s procedure will return partial derivatives
             call_procedure, function_name, x, a, yfit, pder 
          endelse

          beta = (y-yfit)*w # pder
          alpha = transpose(pder) # (w # (fltarr(nterms)+1)*pder)
          chisq1 = total(w*(y-yfit)^2)/nfree ; Present chi squared.

				; If a good fit, no need to iterate
	  all_done = chisq1 lt total(abs(y))/1e7/NFREE
;
;         Invert modified curvature matrix to find new parameters.

          repeat begin
             c = sqrt(alpha(diag) # alpha(diag))
             array = alpha/c
             array(diag) = array(diag)*(1.+flambda)              
             array = invert(array)
             b = a+ array/c # transpose(beta) ; New params
             call_procedure, function_name, x, b, yfit  ; Evaluate function
             chisqr = total(w*(y-yfit)^2)/nfree         ; New chisqr
	     if all_done then goto, done
             flambda = flambda*10.                      ; Assume fit got worse
          endrep until chisqr le chisq1
;
          flambda = flambda/100.  ; Decrease flambda by factor of 10
          a=b                     ; Save new parameter estimate.
          if ((chisq1-chisqr)/chisq1) le tol then goto,done  ; Finished?
       endfor                        ;iteration loop
;
       message, 'Failed to converge', /INFORMATIONAL
;
done:  sigmaa = sqrt(array(diag)/alpha(diag)) ; Return sigma's
       chi2 = chisqr                          ; Return chi-squared
       return,yfit              ;return result
END
pro d17data,data
  DIMS=lonarr(3)
; get the data structure and read the data array
  d=DIAL_MAD_READ('t_res')
  DIMS(0)=d.par_tof(0)
  DIMS(1)=d.par_tof(4) - d.par_tof(3) +1
  DIMS(2)=d.par_tof(2) - d.par_tof(1) +1
;  if prin eq 1 then print,"Dimensions:",DIMS
  t=DIMS(0) & y=DIMS(1) & x=DIMS(2)
;  print,x,y,t
  data=DIAL_MAD_READ('data')
;  help,data
  data=data(0:x*y*t-1)

	if y eq 1 then begin 
          data=reform(data,x,t)
        endif
        if t eq 1 then begin
          data=reform(data,y,x)
          data=transpose(data)
        endif
;   help,data
;  data is in array data(x,y) for mono and data(x,t) for tof
wait,.2
end
;d17flip,coil,first,last,step,count

pro fit_parabola, xp,yp, bestfit, xymin
;** ************
	s=SIZE(xp)	& np=s(1)
	dx=xp(1)-xp(0)

	A0=INT_TABULATED(xp,yp)
	A1=INT_TABULATED(xp,yp*xp)
	A2=INT_TABULATED(xp,yp*xp^2)

	x1=xp(0)	& x2=xp(np-1)
	d1=x2-x1
	d2=(x2^2-x1^2)/2.
	d3=(x2^3-x1^3)/3.
	d4=(x2^4-x1^4)/4.
	d5=(x2^5-x1^5)/5.

	A=[[d3,d2,d1],[d4,d3,d2],[d5,d4,d3]]
	B=[A0,A1,A2]
	R=CRAMER(A,B)

	bestfit=R(0)*xp^2+R(1)*xp+R(2)
	x0=-0.5*R(1)/R(0)
	ymin=R(0)*x0^2+R(1)*x0+R(2)
        print,'in fit'
	xymin=[x0,ymin]
END
 
pro d17flip,coil,first,last,step,count,flux,cur,er


; coil is the number of the coil to be scanned
; first last and step define the current range in the scan
;count is the time to count each point
;xmin, xmax define the area of the detector in x to sum over

;dummy runs
co,2,'t n'
d17data,data
wait,.5
co,2,'t n'
wait,.5
d17data,data

range=5
points=fix((float(last)-float(first))/float(step))+1
print,'points in scan = ',points

cur=fltarr(points)
flux=fltarr(points)
er=fltarr(points)
cur=findgen(points)*step+float(first)
print,cur
print,count,float(count)
for i=0,points-1 do begin
  
  mv,'b'+strtrim(string(coil),2),cur(i)
  wait,1 
  co,count,' t n'
  wait,1  
  d17data,data
  wait,1
  b=size(data)
  if b(0) gt 1 then dat=total(data,2)
  a=max(dat,c)
  print,a,c
  xmin=c-range & xmax=c+range
  print,a,c,xmin,xmax
  fer=sqrt(float(total(dat(xmin:xmax))))/float(total(dat(xmin:xmax)))
  flux(i)=float(total(dat(xmin:xmax)))/float(count)
  er(i)=fer*flux(i)  
  print,cur(i),flux(i),er(i)
  plot, cur, flux, PSYM=2, XRANGE=[float(first),float(last)], $
  YRANGE=[0,MAX(flux)], XTITLE='b'+strtrim(string(coil),2), $
  YTITLE='Count Rate', TITLE=' scan of '+strtrim(string(coil),2)
  ERRPLOT, cur, flux-er, flux+er
endfor
print,'fit'
fit_parabola, cur,flux, bestfit, xymin
print,'did'
OPLOT, cur, bestfit, PSYM=0, LINESTYLE=0
print,'bestfit= ',xymin

mv,'b'+strtrim(string(coil),2),xymin(0)
end
pro d17mad,command
 dummy=dial_mad_send('',0,command,'')
 wait,.2
end
; MONO.PRO: Monochomatic data analysis for D17
;---------------------------------------------
; (Stephen Brown, 16/09/2001)

; Notes: This programme calculates the reflectivity against q for monochromatic
; data. This is done by dividing the reflected and direct beam intensities for
; various combinations of polariser/analyser (up to 4 in total). Because 
; monochromatic data usually consists of a large number of numors, once the
; data is loaded it is stored in heap structures to allow the analysis to 
; be repeated using different parameters. Most of the analysis is accomplished 
; using "fpeak" (which finds intensity of a peak) and "analysis" (which does
; everything else). 

; Most common blocks in the programme are used to store the widget id's
; for the user interface. The important common blocks (with regards to calcs.)
; are "COMMON detector", which contains the "useful area of detector" (xmin,xmax)
; and an array of 4 elements pointing to the approximate position of the reflected
; beam for each of the 4 possible polariser/analyser combinations; and 
; "COMMON loaded_data" which contains pointers to the loaded data. 

;===============================================================================
; Function to get an integer. numstring is the string containing the integer.
; errstr should containt the a string with the name of the field that is being
; entered (e.g 'Direct Beam, 1st Numor') this is used to display an error
; message if something goes wrong (in which case -1 is returned).
; The key word MAX_VALUE allows a maximum value to be specified. If not then
; the max value is the largest positive integer that can be stored in a signed
; long integer. The keyword ALLOW_EMPTY allows the field to be empty. If it
; is empty then 0 is returned rather than the ususal -1 (error). The keyword
; QUIET stops the printing out of error messages. -1 is still returned to 
; signal error, though. This keyword is used to disable the error messages
; that are used when getting integers from fields in the main window so that
; this routine may be used to get integers from other windows.
;===============================================================================
FUNCTION getint,numstring,errstr,MAX_VALUE=maxval,ALLOW_EMPTY=allow,QUIET=qu

; If the max value is not set then set to largest +ve integer that can be
; stored in a signed long integer i.e 2^31-1 
	IF NOT KEYWORD_SET(maxval) THEN maxval=LONG(2)^LONG(31)-LONG(1)
; If the ALLOW_EMPTY keyword is set then the minimum value is zero
; (default for empty field) otherwise the default is 1
	IF KEYWORD_SET(allow) THEN minval=0 ELSE minval=1

	temp=STRCOMPRESS(numstring,/REMOVE_ALL)
; check for empty field
	IF temp EQ '' THEN BEGIN
; Only print out error if field is not allowed to be empty
		IF NOT KEYWORD_SET(allow) THEN BEGIN
; Only print out error message if QUIET keyword isn't set
			IF NOT KEYWORD_SET(qu) THEN $
				msgwin,errstr+': Field Empty! Field must be an integer [1,'+$
				STRTRIM(STRING(maxval),1)+'].',/ERROR
			RETURN,-1
; otherwise return 0 (String empty)
		ENDIF ELSE RETURN,0
	END
; convert to byte array
	temp=BYTE(temp)

; check for illegal caharcters and return error if necessary
	FOR i=0,N_ELEMENTS(temp)-1 DO BEGIN
		IF (temp[i] LT 48B) OR (temp[i] GT 57B) THEN BEGIN
; Display window and signal error on console.
; Only print out error message if QUIET keyword isn't set
			IF NOT KEYWORD_SET(qu) THEN $
				msgwin,errstr+': Illegal character "'+$
				STRING(temp[i])+'" '+' Field must be an integer [1,'+$
				STRTRIM(STRING(maxval),1)+'].',/ERROR
			RETURN,-1
		END
	END

; If there are no illegal characters then convert to an integer. Check size:
	num=LONG(STRCOMPRESS(numstring,/REMOVE_ALL))
	IF (num GT maxval) OR (num LT minval) THEN BEGIN
; Only print out error message if QUIET keyword isn't set
		IF NOT KEYWORD_SET(qu) THEN $
			msgwin,errstr+': Value '+numstring+' out of range. '+$
			' Must be an integer [1,'+STRTRIM(STRING(maxval),1)+'].'$
			,/ERROR
		RETURN,-1
	END
; Everything's okay so just convert the string to an integer
	RETURN,num
END

;===============================================================================
; getfloat. Simple function to return a  float from a string. Minimum 
; amount of error detection is done, i.e it only signals an error if the 
; function FLOAT(...) fails. This is done to stop a silly IDL error message
; coming up on the console making the programme look unprofessional as if it had 
; been written by ILL stagiare. Returns NaN (IEEE 'Not a number') on conversion
; error. Keywords MIN_VALUE and MAX_VALUE specify the minimum and maximum 
; respectively.
;===============================================================================
FUNCTION getfloat,str,MIN_VALUE=minval,MAX_VALUE=maxval

	ON_IOERROR,bad_float

; convert
	number=FLOAT(str)

; If we get here then everything has converted, but is the range correct?
; check this only if the relevant keyword is specified
	IF KEYWORD_SET(maxval) THEN $ 
		IF (number GT maxval) THEN RETURN,!VALUES.F_NAN
	IF KEYWORD_SET(minval) THEN $
		IF (number LT minval) THEN RETURN,!VALUES.F_NAN

	RETURN,number

; If number <=0.0 or IO_ERROR then return NaN
bad_float:
	RETURN,!VALUES.F_NAN
END


;===============================================================================
; Procedure to display a message (msgstr) window with a title (msgtit) supplied
; as an optional keyword.
; Keyword ERROR causes msgwin to print error message (title set to 'Error!'
; and error message printed on console.)
; The keyword NOSENSTIZE stops changes in sensitisation of the main window
; useful if msgwin is called from a child of the main window (such as the
; (modal) direct beam attenuator-correction window. Otherwise msgwin performs
; necessary changes in sensitisation of main window.
;===============================================================================
PRO msgwin,msgstr,TITLE=msgtit,ERROR=err, NOSENSITIZE=noneed

; Common block for base id
COMMON baseid,mono_base,file_base,anal_base

; common block for message okay button
COMMON msgok,butt_msgok

; Common block containing widget id of status label
COMMON status,loadedflag,label_status

; If no title is supplied just set it to default
	IF NOT KEYWORD_SET(msgtit) THEN msgtit='Message'
; If error keyword is supplied then print error message to console and set
; appropriate window title
	IF KEYWORD_SET(err) THEN BEGIN
		PRINT,'****************************'
		PRINT,'Error! Calculations aborted!'
		PRINT,'****************************'
		msgtit = 'Error!'
; set status according to whether data is loaded or not
		IF loadedflag EQ 0 THEN WIDGET_CONTROL,label_status,$
			SET_VALUE='Last operation caused an error. No data is loaded.'$
		ELSE WIDGET_CONTROL,label_status,$
			SET_VALUE='Last operation caused an error. Data is loaded.'
	END

; Window with msgtit TITLE and msgstr message. OK button below
	msg_base = WIDGET_BASE(GROUP_LEADER=mono_base,TITLE=msgtit,/MODAL,/COLUMN)

; work out dimensions of box
	xdim=35
	ydim=FIX(STRLEN(msgstr)/xdim)+1
; make sure its not greater than 30 lines (if it is user can scroll)
	IF ydim GT 30 THEN ydim=30
; display text
	dummy = WIDGET_TEXT(msg_base,VALUE=msgstr,/WRAP,XSIZE=xdim,YSIZE=ydim,/SCROLL)
	butt_msgok = WIDGET_BUTTON(msg_base,VALUE='  OK  ')

; resensitise bases if the NOSENSITIZE keyword isn't set
	IF NOT KEYWORD_SET(noneed) THEN BEGIN
		WIDGET_CONTROL,anal_base,SENSITIVE=1
; only resensitise file base if no data is loaded
		IF NOT loadedflag THEN 	WIDGET_CONTROL,file_base,SENSITIVE=1
	END

	WIDGET_CONTROL,msg_base,/REALIZE
	XMANAGER,'msgwin',msg_base
END

;===============================================================================
; Event handler for message window. Destroys window if ok is pressed.
;===============================================================================
PRO msgwin_event,event

; common block for message base id
COMMON msgok,butt_msgok
;If OK button is pressed destroy widget
	IF event.id EQ butt_msgok THEN WIDGET_CONTROL,event.top,/DESTROY
	
END

;===============================================================================
; Reads a data numor 'num' in directory 'path'. The data is stored in a heap
; stucture which is allocated at the end. The pointer to the struct. is 
; returned in dataptr. The structure contains not only the (1d) data, but 
; also the instrument parameters. 2D data is summed in the y-direction.
;===============================================================================
FUNCTION data_readm,path,num,dataptr

;converts num(int) to 6 digit string with trailing zeroes
;make six digit string of 0's
	name='000000'
;convert num to string and trim all blank spaces
	tempnum=STRTRIM(STRING(num),2)
;put these digits in occupying the last strlen(tempnum) places of name
	STRPUT,name,tempnum,6-STRLEN(tempnum)
; include path in name
	name=path+name

	CLOSE,3
; open file (handle=3) checking for open errors
	OPENR,3,name,ERROR=err
	CATCH,Error_status

	IF (err NE 0) OR (Error_status NE 0) THEN BEGIN
			IF err NE 0 THEN msgwin,'Error opening '+name+' (Check numor and data directory)',/ERROR $
			ELSE msgwin,'"FUNCTION data_readm" : Caught general error in reading file '$
				+name+' (Corrupt numor?)' ,/ERROR
		RETURN,0
	END

	PRINT,'		opened: ',name

; floating point arrays of 128 and 256 elements
	par1 = FLTARR(128)
	par2 = FLTARR(256)

; string array of 34 elements
	txt=SINDGEN(34)
; set all 34 elements to XXX....
	txt[*]='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
; this is used to read individual spacer lines
	txt1=txt[1]

; read in 34 lines of text
	READF,3,txt

; read 128 floats (2nd block of numbers in file, 1st block is ignored by code above)
	READF,3,par1
; read the two line spacer
	READF,3,txt1
	READF,3,txt1
;read 256 numbers 
	READF,3,par2

;output useful information
;print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
	nx=par1(101)

;print,'nx= ',par1(101),' ny= ',par1(102)

;print,'run time= ',runtime,' s',' det= ',par2(15),'dan = ',par2(16)

;dan is the detector angle and dett is the sample-detector distance

; Now we can read the data -first read 3 spacer lines
	READF,3,txt1
	READF,3,txt1
	READF,3,txt1

;read total number pixels in detector
	READF,3,tot

; Array sizes. In monochromatic mode tsize must equal 1. 
	tsize=LONG(par1(94))
; All references to tsize are 1 following this check:
	IF tsize NE 1 THEN BEGIN
		msgwin,'Numor '+STRCOMPRESS(STRING(num),/REMOVE_ALL)+$
		' has multiple time channels! Time of flight numors cannot be analysed by this programme',/ERROR
		RETURN,0
	END

; x and y sizes, and dimensions
	xsize=LONG(par1(98)-par1(97)+1)
	ysize=LONG(par1(100)-par1(99)+1)
	dsize=LONG(xsize*ysize)

;print,'tsize= ',tsize,' detector size= ',dsize
;print,tot
;print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

;signal error if total number of pixels isn't equal to xsize*ysize
; note that the monitor is an extra tsize (=1 for monochromatic) pixels at 
; the end of the data
	IF (tot NE (dsize+LONG(1))) THEN BEGIN
		msgwin,'Error in data array dimensions in numor '+STRCOMPRESS(STRING(num),/REMOVE_ALL)+$
			'. (xsize*ysize not equal to number of pixels).',/ERROR
		RETURN,0
	END


;set up an array of long integers with specified size
	det=LONARR(ysize,xsize)
; set up monitor arrray. tsize=1 for monochromatic mode
	mon=LONARR(tsize)

;read detector data and monitor data from file
	READF,3,det,mon

; convert data to floating point in w1
	w1=FLTARR(xsize)
	IF ysize GT 1 THEN w1[*]=FLOAT(TOTAL(det[*,*],1)) ELSE w1[*]=FLOAT(det[*])

	CLOSE,3
; print total monitor counts and monitor counts per unit time
;print,'total counts in detector = ',total(w1),' (',total(w1)/runtime,')'

; Monitor is just a single pixel in monochromatic mode. Convert to float

	moni=FLOAT(mon[0])

; ATTENUATOR: There are three attenuators of different thickness. These are either
; in (1) or out of (0) the beam. The "attenuator number" is formed as the binary
; of these three 'bits' (e.g. 000 = no attenuators, 010 = 'middle' attenuator in
; et.c.)

	attnum = FIX(par2[101])*4 + FIX(par2[100])*2 + FIX(par2[99])

; stucture to be passed back containing the numor data.
	thedata = {datstruct,detdata:w1,monitor:moni,nx:par1[101],$
		runtime:par1[2]/10.,dan:par2[16],dett:par2[15],tsize:par1[94],$
		xsize:par1[98]-par1[97]+1,ysize:par1[100]-par1[99]+1,$
		os:par2[103],att:attnum,s2:par2[93],s3:par2[95],san:par2[2]}

	dataptr = PTR_NEW(thedata)

	CATCH,/CANCEL
	RETURN,1

END




;===============================================================================
; FUNCTION fpeak: Finds the peak of a 1d array 'arr' using a centre of mass 
; calculation over a width 'fgwidth' around the peak. Errors aree passed
; through the array errarr and propagated through the calculation. Background
; may be subtracted by specifying the vectors 'bgleft' and 'bgright' (which
; have 2 elements [0]=width of LHS/RHS background, [1]= shift). If 'fitbg'
; is 0 (false) then the background is averaged, otherwise it is fitted to a 
; straight line.
; Keyword PEAK_NEAR tells where to do the c.o.m calculation. If not specified
; then the calculation is done about the maximum pixel.
;===============================================================================
FUNCTION fpeak,arr,errarr,fgwidth,bgleft,bgright,fitbg,PEAK_NEAR=near

; Common block containing useful area of detector and approx whereabouts of 
; specular peak (for each polarisation, i.e. up to 4)
COMMON detector,xmin,xmax,refpmean

; If a pixel near the peak is specified then search around this. Otherwise
; search for the maximum.
	IF KEYWORD_SET(near) THEN centre=near ELSE maxval = MAX(arr,centre)

; set sum ranges
	range_low = centre-ROUND(FLOAT(fgwidth)/2.0)
	range_high = centre+ROUND(FLOAT(fgwidth)/2.0)

; Get detector ranges:
; If xmax is zero(=default) then set max_x to the size of the array, otherwise
; set it to the value of xmax
	IF xmax EQ 0 THEN max_x=N_ELEMENTS(arr)-1 ELSE max_x=xmax
; The default of xmin is zero so this does not need to be set
	min_x=xmin

; return with error if out of range when looking for COM
	IF (range_low LT min_x) OR (range_high GT max_x) THEN $
											RETURN,[-1.0,-1.0,-1.0]

; numerator and denom. of Centre of Mass sum
	num = 0.0
	denom = 0.0

; COM calculation
	FOR i=0,range_high-range_low DO BEGIN
; sum up elements in numerator and denominator
		num=num+FLOAT(i)*arr[range_low+i]
		denom=denom+arr[range_low+i]
	ENDFOR

; calc. com
	com = num/denom + range_low

;foreground range: f1:f2
	f1 = ROUND(com - FLOAT(fgwidth-1)/2.0)
	f2 = ROUND(com + FLOAT(fgwidth-1)/2.0)

; return with error if left or right edges are out of detector (i.e. left 
; edge of left backgrond and right edge for right bg-see bg calc. below)
	IF (f1-1-bgleft[0]-bgleft[1] LT min_x) OR $
		(f2+1+bgright[0]+bgright[1] GT max_x) THEN $
											RETURN,[-1.0,-1.0,com]

; create a new array to contain the background corrected data and its error
	newarr = FLTARR(f2-f1+1)
	newerrarr = FLTARR(f2-f1+1)

; An array to store the background to be subtracted for the data over the foreground 
; range [f1:f2]
	background = FLTARR(f2-f1+1)

;*************************************************
; Background subtraction:
;-------------------------------------------------
; If no background to subtract then set all elements of 'background' to 0
	IF (bgleft[0] EQ 0) AND (bgright[0] EQ 0) THEN background[*]=0 $
	ELSE BEGIN
;-------------------------------------------------
; Average if 'fitbg' is false (0)
		IF fitbg EQ 0 THEN BEGIN
; Use RHS only...
			IF (bgleft[0] EQ 0) AND (bgright[0] GT 0) THEN $
				background[*] = MEAN(arr[f2+1+bgright[1]:$
					f2+1+bgright[1]+bgright[0]])
; LHS only...
			IF (bgleft[0] GT 0) AND (bgright[0] EQ 0) THEN $
				background[*] = MEAN(arr[f1-1-bgleft[1]-bgleft[0]:$
					f1-1-bgleft[1]])
; Average over both left and right sides...
			IF (bgleft[0] GT 0) AND (bgright[0] GT 0) THEN $
				background[*] = 0.5*(MEAN(arr[f2+1+bgright[1]:$
					f2+1+bgright[1]+bgright[0]])+MEAN(arr[f1-1-bgleft[1]$
					-bgleft[0]:f1-1-bgleft[1]]))
		ENDIF $
;-------------------------------------------------
; If fitbg is non-zero then fit:
			ELSE BEGIN
; First create an array containing the pixel numbers of all the pixels used in
; the background fit: (bgpixind = "bg pixel index")
; Use RHS only...
			IF (bgleft[0] EQ 0) AND (bgright[0] GT 0) THEN $
				bgpixind =  f2 + 1 + bgright[1]+INDGEN(bgright[0])
; LHS only...
			IF (bgleft[0] GT 0) AND (bgright[0] EQ 0) THEN $
				bgpixind =  f1 - 1 - bgleft[1] - INDGEN(bgleft[0])
; Create pixel indices for both left and right sides by concatenating
; the two series above:
			IF (bgleft[0] GT 0) AND (bgright[0] GT 0) THEN $
				bgpixind = [f1 - 1 - bgleft[1] - INDGEN(bgleft[0]),$
				f2 + 1 + bgright[1]+INDGEN(bgright[0])]

; Remove pixels addressed by bgpixind that index a error pixel equal to 0.0
; (these will cause LINFIT to fuck up)
		bgpixind = bgpixind[WHERE(errarr[bgpixind] GT 0.0)]
; fit the background using the selected pixels in bgpixind and their errors
; Use /DOUBLE to prevent things like underflow.
		shes_well_fit = LINFIT(bgpixind,arr[bgpixind],SDEV=errarr[bgpixind],$
								/DOUBLE)
; generate the background by evaluating the fit in the foreground range [f1:f2]
		background = shes_well_fit[0] + shes_well_fit[1] * (INDGEN(f2-f1+1)+f1)
		END
	END

; Take off background
	newarr[*] = arr[f1:f2] - background[*]
; Error due to background is SQRT(background). Total error is quadrature sum
; of this and the error array.
	newerrarr[*] = SQRT(errarr[f1:f2]^2+background[*])

; Calculate peak intensity and its error by adding up all pixels (total intensity)
	peak_int = TOTAL(newarr)
; Add in quad. errors on individual pixels
	int_err = SQRT(TOTAL(newerrarr[*]^2))

; Return results
	RETURN,[peak_int,int_err,com]
END


;===============================================================================
; THE MAIN ANALYSIS ROUTINE! This routine is called whem the analyse button
; is pressed. All user inputted fields are passed through the structure
; 'user' (defined in mono_event, below). If no data is loadec then this procedure
; first loads all data and a window is displayed to allow the user to check/
; modify the direct beam attenuation. Then the "approximate" position of the
; reflected beam peak is found. This is done because can't simply find max
; of reflected beam data in places where reflectivity is low so need an area
; to look for it. After data is loaded (or if data has already been loaded)
; the analysis is done. First the reflectivity is calculated by using fpeak
; to find the intensity of the direct and reflected beam peaks-these are then 
; divided. Then q (and its resolution) is calculated. Finally the data is stored
; to a file and plotted. The plotted data is first bundled/grouped using
; group_monodata.
;===============================================================================
PRO analysis,user

; Common block for base id's
COMMON baseid,mono_base,file_base,anal_base

; common block for pointers to data. and mean of reflected peaks
COMMON loaded_data,db_data,ref_data,water

; Common block containing widget id of status label
COMMON status,loadedflag,label_status

; Common block for widget id's of DB attenuation correction window
; Also contains the number of the first numor for plotting purposes
COMMON attcorr,plotbase,butt_done_attcorr,butt_redo_attcorr,$
			text_factor_attcorr,butt_correctby,slider_startatt,firstnumor

; common block for message base id (So the plot window can use the same event
; handler as a message window since it also only has an OKAY button to close it)
COMMON msgok,butt_msgok

; Common block containing useful area of detector
COMMON detector,xmin,xmax,refpmean

; number of direct beam numors
	n_dbnumors = user.db_last-user.db_first+1

;----------------------------------------------------
; If there is no data loaded then proceed to load:
	IF NOT loadedflag THEN BEGIN

		PRINT,STRING([10B,10B])+'LOADING DATA FILES'

; Free memory allocated to old data set
		PTR_FREE,db_data,ref_data
		PTR_FREE,water

; Read water file.
		IF user.waterfile GT 0 THEN BEGIN
			PRINT,'Reading water file...'
			WIDGET_CONTROL,label_status,SET_VALUE='Loading data...(Water file)'
			IF NOT data_readm(user.datadir,user.waterfile,numor) THEN RETURN
; store data of water file into an array
			water = numor
		ENDIF ELSE BEGIN
			PRINT,'No water file!'
; create a null pointer - no water correction
			water = PTR_NEW()
		END

; Resize pointer array. n_dbnumors for direct beam. n_dbnumors* polariation
; option for refl. beam
 		db_data = PTRARR(n_dbnumors)
		ref_data = PTRARR(user.pol+1,n_dbnumors)

; array to store maxima of each reflected beam numor
		refmax = FLTARR(user.pol+1,n_dbnumors)

;***********************************************************************************
; This loop reads in the numors for driect and relfected beams.  The position of the
; maximum is found for each of the reflected beam numors

		FOR i=0, n_dbnumors-1 DO BEGIN

			runoftot=STRTRIM(STRING(i+1),1)+'/'+STRTRIM(STRING(n_dbnumors),1)
			PRINT,'Reading data set '+runoftot
			WIDGET_CONTROL,label_status,SET_VALUE='Loading data...('+runoftot+')'

			PRINT,'	Direct Beam file'

; Read in the ith direct beam numor, if error then return
			IF NOT data_readm(user.datadir,i+user.db_first,numor) THEN RETURN

; store pointer to data
			db_data[i]=numor			

			PRINT,'	Reflected beam file(s)'

; Read in the ith reflected beam numors (one for each polarisation=user.pol+1)
; user.pol=0 (unpolarised), 1 (polarised), 2/3 (polarised with analyser)
; user.pol+1=number of refl. numors per direct beam numor
			FOR j=0,user.pol DO BEGIN
				IF NOT data_readm(user.datadir,$
							i*(user.pol+1)+j+user.ref_first,numor) THEN RETURN
; store pointer to data in pointer array
				ref_data[j,i]=numor

; find max of data and store it in refmax ONLY if dan>2.3. Otherwise put -1.0 (not
; a valid pixel) as the max. See later comments concerning finding mean peak value.
; (Do temporary water correction first if necessary). Divide by zero is ignored
; by /NAN keyword
				IF PTR_VALID(water) THEN maxval=MAX((*numor).detdata/(*water).detdata,/NAN,mpix) $
; Invalid water pointer-> no water file loaded-> no water correction
					ELSE maxval=MAX((*numor).detdata,mpix)

				IF (*numor).dan GT 2.3 THEN refmax[j,i]=mpix ELSE refmax[j,i]=-1.0
			ENDFOR

		END

;******************************************************************************* 
; Now correct for any attenuators placed in the direct beam

		PRINT,'Correcting for direct beam attenuation.'
		WIDGET_CONTROL,label_status,SET_VALUE='Correcting for direct beam attenuation.'

; >>>-***- HARDWIRED DEFAULT FACTOR FOR ATTENUATOR EXPONENTIAL -***-<<<
; "magic" factor in exp(...) of attenuator
		magic_factor = 1.0

; store first db numor into a common variable for plottting purposes in direct
; beam attenuation-correction window
		firstnumor = user.db_first

; Window to contain a graph which the user can use to check that attenuators
; are properly corrected for
		!P.MULTI=[0,1,1]
; create a modal window
		plotbase=WIDGET_BASE(GROUP_LEADER=mono_base,/MODAL,$
						TITLE='Direct beam attenuation correction',/COLUMN)
		graph1=WIDGET_DRAW(plotbase,XSIZE=700,YSIZE=300,RETAIN=2)
		subplotbase = WIDGET_BASE(plotbase,/ROW)
		butt_correctby = CW_BGROUP(subplotbase,$
			['Reading attenuator number from numor','Looking for intensity drops'],$
			/EXCLUSIVE,/FRAME,LABEL_LEFT='Deduce attenuator number by:',SET_VALUE=0)
		slider_startatt = WIDGET_SLIDER(subplotbase,MINIMUM=0,MAXIMUM=7,$
			TITLE='Select attenuator to start with.',/FRAME,VALUE=0)
		dummy = WIDGET_LABEL(plotbase,VALUE=$
			'NB: Use of attenuator number in numor file is recommended unless this has not been written')
		dummybase = WIDGET_BASE(plotbase,/ROW,/BASE_ALIGN_CENTER)
		dummy = WIDGET_LABEL(dummybase,VALUE=$
				'Factor in exponential attenuation: EXP(-factor*att_number)')
		text_factor_attcorr = WIDGET_TEXT(dummybase,/EDITABLE,$
				VALUE=STRING(magic_factor),XSIZE=10)
		butt_done_attcorr = WIDGET_BUTTON(dummybase,VALUE='Done')
		butt_redo_attcorr = WIDGET_BUTTON(dummybase,VALUE='Do again')

; realise.
		WIDGET_CONTROL,plotbase,/REALIZE
; desensitize slider since by default it is not needed unless the user
; selects 'Looking for intensity drops' as the method to correct for attenuators
		WIDGET_CONTROL,slider_startatt,SENSITIVE=0

; "simulate" the redo button being pressed. This is done so that we can use the
; event handler for the window to plot the graph as soon as the window is realised
; so the user doesn't have to press a button before seeing a graph. This could
; have been done by setting the /NOTIFY_REALIZE keyword on plotbase to specify
; a procedure to call when the window is created. However the idiots who
; made IDL didn't think to call this procedure in the same way as calling an
; ordinary event handler thus rendering this option impossible. So here is a 
; little fix...
		attcorrwin_event,{id:butt_redo_attcorr}

;  Register: Control will be passed back once the window is closed
; (coz its modal)
		XMANAGER,'attcorrwin',plotbase

;*******************************************************************************
; Find distribution of reflected beam peaks disregarding any numors which may
; contain direct beam spillage (i.e. where dan<2.3 - these are set to -1.0)
; Only do this if the user has not specified an 'override' for this , in which
; case refpmean[j] will be non-zero

; error flag
		badflag=0
		FOR j=0,user.pol DO BEGIN 
; Only bother if refpmean[j] is zero, i.e. if user has not specified peak
; position
			IF refpmean[j] EQ 0.0 THEN BEGIN
				Error_status=0
; error handler
				CATCH,Error_status
; set the error flag to 1 so that a warning can be signalled if this calc
; fails
				IF Error_status NE 0 THEN BEGIN 
					badflag = 1 
					refpmean[j]=0.0
				ENDIF ELSE BEGIN
; Create a temporary array containing all reflected beam numor maximums where
; dan>2.3 (i.e. where max > 0.0 - see check above)
					temparr=refmax[j,WHERE(refmax[j,*] GT 0.0)]
; Calc the distribution of the first HALF of these numors. It is assumed that
; for these the reflectivity is reasonably large and won't be drowned out
; by noise. The mean of this dist. should give an idea as to where to look for
; the specular peak.
					peakdist=MOMENT(temparr[0:FIX(N_ELEMENTS(refmax[j,*])/2.0)])
; store the mean in the COMMON varaible refpmean (4-vector floating array)
					refpmean[j] = peakdist[0]
				END
				CATCH,/CANCEL
			ENDIF
		ENDFOR

; ouput warning message if there was a problem in finding refpmean
		IF badflag EQ 1 THEN BEGIN
; set the loaded data flag to 1 (true)....
			loadedflag=1
			msgwin,'Warning! Unable to find the approximate position of the reflected beam peak for some/all polarisations. You will have to set these manually by pressing the PEAKS/RANGES button before analysing. The approximate reflected beam position is set to zero for all those which failed.',TITLE='Warning!'
; Put 'data loaded' on status label
			WIDGET_CONTROL,label_status,SET_VALUE='Data Loaded. !PLEASE MANUALLY SET REFLECTED BEAM PEAKS!'
; ...but exit the analysis procedure so the user can correct the problem
			RETURN
		END
; Finished loading data, so set loadedflag to true (1).
		loadedflag = 1
	ENDIF
; *****************END OF DATA LOADING*********************

; Put 'data loaded' on status label
	WIDGET_CONTROL,label_status,SET_VALUE='Data Loaded.'

;***********************************************************************************
; Do the data analysis:

	PRINT,'Analysing data...'

; RESULT ARRAYS:
; Arrays for reflectivity versus q (and errors). One for each polarisation.
	reflectivity = FLTARR(user.pol+1,n_dbnumors)
	reflectivity_err = FLTARR(user.pol+1,n_dbnumors)
	q = FLTARR(user.pol+1,n_dbnumors)
	q_res = FLTARR(user.pol+1,n_dbnumors)

;--------------------------
; This loop analysis each set of data (i.e. each direct beam and its reflected
; beam numor(s) (no. of ref. beams depends on polarisation
	FOR i=0,n_dbnumors-1 DO BEGIN

;-------------
; Copy db data into working structure and find Poissonian error
; Normalise and correct for water. Do background subtraction and find peak
		db = *db_data[i]
		dberr = FLTARR(db.xsize)
		dberr = SQRT(db.detdata)

; Normalise to water if a water file was specified (i.e. pointer 'water'
; is valid)
		IF PTR_VALID(water) THEN BEGIN 
			db.detdata = db.detdata/(*water).detdata
			dberr = dberr/(*water).detdata
		END

; Find peak intensity of direct beam
		dbpeak = fpeak(db.detdata,dberr,user.fgwidth,user.bgleft,user.bgright,user.bgsub)
; Signal error if fpeak ran off the detector
		IF dbpeak[0] EQ -1.0 THEN BEGIN
; If dbpeak[2]=-1.0 then failure occured before COM calculation
			IF dbpeak[2] EQ -1.0 THEN msgwin,/ERROR,$
				'"Range outside detector" error in finding centre of mass for direct beam numor '+$
				STRCOMPRESS(STRING(i+user.db_first),/REMOVE_ALL)+$
				'. Try reducing the foreground width (which is used to'+$
				' as the width for the centre of mass calculation) or adjusting the useful detector size in PEAKS/RANGES'$
; If dbpeak[2] NE -1.0 then the COM was found, but when subtracting background
; fpeak ran off the detector. dbpeak[2] contains COM that caused error
			ELSE msgwin,/ERROR,$
				'"Range outside detector" error when finding peak intensity and/or subtracting background for direct beam numor '+$
				STRCOMPRESS(STRING(i+user.db_first),/REMOVE_ALL)+$
				'. Try reducing the foreground  and background widths (shifts) or adjusting the useful detector size in PEAKS/RANGES.'+$
				'(NB: The centre of mass was found at '+STRCOMPRESS($
				STRING(dbpeak[2]),/REMOVE_ALL)+')'
			RETURN
		END


;*******************************************************************
; Loop over all polarisations for reflected beam and do calculations
		FOR j=0,user.pol DO BEGIN
			ref = *ref_data[j,i]
			referr = SQRT(ref.detdata)

; Normalise
			IF user.norm EQ 0 THEN BEGIN
					ref.detdata = ref.detdata/(ref.monitor/db.monitor)
					referr[*] = referr[*]/(ref.monitor/db.monitor)
			ENDIF ELSE BEGIN
					ref.detdata = ref.detdata/(ref.runtime/db.runtime)
					referr[*] = referr[*]/(ref.runtime/db.runtime)
			END

; Normalise to water if a water file was specified
			IF PTR_VALID(water) THEN BEGIN
				ref.detdata = ref.detdata/(*water).detdata
				referr[*] = referr[*]/(*water).detdata[*]
			END
 
; Find reflected peak intensity
			refpeak = fpeak(ref.detdata,referr,user.fgwidth,user.bgleft,$
								user.bgright,user.bgsub,PEAK_NEAR=refpmean[j])

; Signal error if fpeak ran off the detector
			IF refpeak[0] EQ -1.0 THEN BEGIN
; If refpeak[2]=-1.0 then failure occured before COM calculation
				IF refpeak[2] EQ -1.0 THEN msgwin,/ERROR,$
					'"Range outside detector" error in finding centre of mass for reflected beam numor '+$
					STRCOMPRESS(STRING((i*user.pol)+j+user.ref_first),/REMOVE_ALL)+$
					'. Try reducing the foreground width (which is used to'+$
					' as the width for the centre of mass calculation) or adjusting the useful detector size in PEAKS/RANGES'$
; If refpeak[2] NE -1.0 then the COM was found, but when subtracting background
; fpeak ran off the detector. refpeak[2] contains COM that caused error
				ELSE msgwin,/ERROR,$
					'"Range outside detector" error when finding peak intensity and/or subtracting background for reflected beam numor '+$
					STRCOMPRESS(STRING((i*user.pol)+j+user.db_first),/REMOVE_ALL)+$
					'. Try reducing the foreground  and background widths (shifts) or adjusting the useful detector size in PEAKS/RANGES.'+$
					'(NB: The centre of mass was found at '+STRCOMPRESS($
					STRING(refpeak[2]),/REMOVE_ALL)+')'
				RETURN
			END

;-----------------------------
; Calc. Reflectivity and error
;-----------------------------
; Ratio of reflected to direct beam
			reflectivity[j,i] = refpeak[0]/dbpeak[0]
; Combination of fractional errors in quadrature
			reflectivity_err[j,i] = SQRT((refpeak[1]/refpeak[0])^2+$
								(dbpeak[1]/dbpeak[0])^2)*ABS(reflectivity[j,i])

;--------------------------
; Calculate q and its error
;--------------------------
; degrees per radian (convert rad->deg.)
			dpr=180./!PI
			IF (user.qcalc EQ 1) THEN theta = ref.san $
			ELSE BEGIN
; pixel which is at centre of detector (i.e. intersection of detector plane
; and line which is perpendicular to detector plane that passes thru sample
; (NB: nx is a binning factor, usually 1, i.e. 1 pixel per bin)
; !!!!!!!HARDWIRED NUMBER 135.79!!!!!!
				pcen=135.79/db.nx
; millimeters per pixel (note that detector distance, dett is in millimeters)
; !!!!!!!HARDWIRED NUMBER 1.04!!!!!!
				mmpp=1.04*db.nx

; calculation of theta from simple geometry using centre of mass in pixels
; (COM's are in refpeak[2] and dbpeak[2])
				theta=(ref.dan+dpr*ATAN((pcen-refpeak[2])*mmpp/ref.dett))/2-$
					  (db.dan+dpr*ATAN((pcen-dbpeak[2])*mmpp/db.dett))/2
			END

; resolution of theta. This is calculated from the slit openings. It contributes
; to the q-resolution in two ways: 1) As the resolution of theta, 2) As the
; resolution of angles leaving the monochromator. This contributes to the
; wavelength resolution.
; !!!!!!!HARDWIRED NUMBER interslit distance = 3.500!!!!!!
			d_theta=2.*ATAN((db.s2+db.s3)/(3500.0*2.))*dpr

; (Fractional error of wavelength)^2. Note monochr_dspread is fractional
; spread in d-spacings of monochromator crystal. This is in percent (%).
; d_theta/user.monochr_ang is the fractional error in the outgoing angles
			fracerr_lambda = (user.monochr_dspread/100.0)^2 + $
							(d_theta/user.monochr_angle)^2

; Standard formula for q, use the user specified wavelength
			q[j,i] = 4*!PI*SIN(theta/dpr)/user.wavelength

; Resolution for q (combination of fractional errors of wavelength and theta)
; Note that fracerr_lambda is already sqaured (see above)
			q_res[j,i] = SQRT(fracerr_lambda+(d_theta/theta)^2)*ABS(q[j,i])
		
		ENDFOR
; (end of polarisation loop)
;***********************************************************

; Loop to next direct beam numor
	ENDFOR

;----------------------
; Output data
;----------------------

;******PLOT************

; Set number of graphs and size of window according to number of plots 
; (polarisations). Also set titles of windows through graph_titles.
; ('basetitle' is a string describing what polariser/analyser is used.
; the string array, 'graphtitles' is made up of basetitle + a number for
; each polarisation)
	CASE user.pol OF
		0: BEGIN
			!P.MULTI=[0,1,1]
			graph_xsize = 600
			graph_ysize = 400
			basetitle='Unpolarised'
			subtitles = ''
			END
		1: BEGIN
			!P.MULTI=[0,1,2]
			graph_xsize = 600 
			graph_ysize = 300
			basetitle = 'Polarised, no analyser:'
			subtitles = ['+','-']
			END
		2: BEGIN
			!P.MULTI=[0,1,3]
			graph_xsize=600
			graph_ysize=200
			basetitle = 'Polarised, analyser with no +-/-+ distinction:'
			subtitles = ['++','+-','--']
			END
		3: BEGIN
			!P.MULTI=[0,2,2]
			graph_xsize=600
			graph_ysize=400
			basetitle = 'Polarised, analyser with +-/-+ distinction:'
			subtitles = ['++','+-','-+','--']
			END
	ENDCASE

; concatenate base- and sub- titles to create an array of titles- one for
; each polarisation
	graph_titles=basetitle+subtitles

; Set up the plotting base widget
	plotbase = WIDGET_BASE(GROUP_LEADER=mono_base,/COLUMN,$
					TITLE='Plot(s) of Log(reflectivity) versus q')
	graphs = WIDGET_DRAW(plotbase, XSIZE=graph_xsize, YSIZE=graph_ysize,$
				RETAIN=2)
; Use butt_msgok for button (same as for message window)
	butt_msgok = WIDGET_BUTTON(plotbase,VALUE='DONE')
	
;realize
	WIDGET_CONTROL,plotbase,/REALIZE
; Set event handler to message window handler (which looks to see if butt_msgok
; is pressed.
	XMANAGER,'msgwin',plotbase

; Plot the graphs
; x/y axis labels
	!X.TITLE = 'q (Angstroms^-1)'
	!Y.TITLE = 'Log10(Ref)'
	FOR j=0,user.pol DO BEGIN
; Group the data. Combines points that are 'close' within the resolution of q
; Grouped data is x=q, y=log(reflectivity), err_y=error in y
		group_monodata,q[j,*],reflectivity[j,*],reflectivity_err[j,*],$
				q_res[j,*],y,x,err_y

; PLOT:
; get maximum pixel value and index
		maxy=MAX(y,mpix)
; max is max value plus its error bar
		maxy=maxy+err_y[mpix]
; similar for min
		miny=MIN(y,mpix)
		miny=miny-err_y[mpix]
; set plot range accordingly
		!Y.RANGE=[miny,maxy]
; select appropriate title
		!P.TITLE=graph_titles[j]
		PLOTERR,x,y,err_y
	ENDFOR

;*****WRITE TO FILE******

; Create an array of filenames. The user enters a filename, e.g. mono_output.dat
; A file is written for each of the polariser/analyser combinations (up to 4)
; an array of filenames is created for a file '[filename].[extention]' 
; (where [filename] and [extention] are strings containing filename and 
; extention) with the polariser/analyser set up appended to the [filename]. 
; E.g. for a polarisor with no analyser (2 types: +:'spin up'; 
; -:'spin down) the following files are created: [filename]_+.[extention]
; and [filename]_-.[extention]. So for 'mono_output.dat' the files
; 'mono_output_+.dat' and 'mono_output_-.dat' would be created.

; Find the position of the full stop ('.', i.e. [filename]/[extention] 
; delimeter
	stoppos = STRPOS(user.outputfile,'.')
; If there is no full stop-> no extention so set accordingly
	IF stoppos EQ -1 THEN BEGIN
		filename=user.outputfile
		fileext=''
; If there is a full stop then get the filename and extention:
	ENDIF ELSE BEGIN
; extract filename (all characters up to full stop)
		filename=STRMID(user.outputfile,0,stoppos)
; extract extention (all characters from (including) full stop
		fileext=STRMID(user.outputfile,stoppos,STRLEN(user.outputfile)-stoppos)
	END

; Now stick the pol/anal settings to the end of each filename
	CASE user.pol OF
; no polarisation -> simple,
		0: filenames = filename
; Polariser:
		1: filenames = filename + '_'+['+','-']
; Polariser+analyser, but no +-, -+ distinction
		2: filenames = filename + '_'+['++','+-','--']
; Polariser and analyser
		3: filenames = filenames + '_' + ['++','+-','-+','--']
	ENDCASE

; no re-attatch the ext. - if there was one:
	IF fileext NE '' THEN filenames=filenames+fileext

; Write files
	FOR j=0, user.pol DO BEGIN

		PRINT,'Writing data file '+filenames[j]+'...'

; attempt to open file
		CLOSE,10
		OPENW,10,filenames[j],ERROR=err

; Begin an error handler for write errors
		error_status=0
		CATCH,error_status

; Control is passed here on error so first check that no error occured. If so
; output error message and return
		IF (err NE 0) OR (error_status NE 0) THEN BEGIN
; Different messages depending on whether it was an open or write error
			IF err NE 0 THEN BEGIN
				msgwin,/ERROR,'Error opening file: "'+filenames[j]+'".'+$
					'(Check filename?)'+$
					STRING(10B)+'Error message: "'+!ERR_STRING+'".'
				RETURN
			END
			IF error_status NE 0 THEN BEGIN
				msgwin,/ERROR,'Error writing to file: "'+filenames[j]+'".'+$
					STRING(10B)+'Error message: "'+!ERR_STRING+'".'
				RETURN
			END
		ENDIF ELSE BEGIN
; No error so proceed with writing

; Print a little header saying what it is when it was created and how
; many other files (i.e. polarisations) there are in the set
			PRINTF,10,'***Monochromatic data analysis output file**'
			PRINTF,10,'Created:'+SYSTIME(0)
			PRINTF,10,'(File '+STRCOMPRESS(STRING(j+1),/REMOVE_ALL)+$
				' of '+STRCOMPRESS(STRING(user.pol+1),/REMOVE_ALL)+')'

; Print out the parameters used:
; Input files:
			PRINTF,10,'Direct beam numors:'+STRCOMPRESS(STRING(user.db_first),$
				/REMOVE_ALL)+'-'+STRCOMPRESS(STRING(user.db_last),$
				/REMOVE_ALL)
			PRINTF,10,'Reflected beam numors:'+STRCOMPRESS(STRING(user.ref_first),$
				/REMOVE_ALL)+'-'+STRCOMPRESS(STRING(user.ref_last),$
				/REMOVE_ALL)
			PRINTF,10,'Number of polarisations:'+STRCOMPRESS(STRING(user.pol+1),$
				/REMOVE_ALL)
			PRINTF,10,'Water file:'+STRCOMPRESS(STRING(user.waterfile),$
				/REMOVE_ALL)
			PRINTF,10,STRING(10B)
; Analysis options:	
			PRINTF,10,'Foreground width:'+STRCOMPRESS(STRING(user.fgwidth),$
				/REMOVE_ALL)
			PRINTF,10,'Left background [shift,width]: '+$
				STRCOMPRESS(STRING(user.bgleft[0]),/REMOVE_ALL)+','+$
				STRCOMPRESS(STRING(user.bgleft[1]),/REMOVE_ALL)
			PRINTF,10,'Right background [shift,width]: '+$
				STRCOMPRESS(STRING(user.bgright[0]),/REMOVE_ALL)+','+$
				STRCOMPRESS(STRING(user.bgright[1]),/REMOVE_ALL)
			PRINTF,10,'Monochromator angle:'+$
				STRCOMPRESS(STRING(user.monochr_angle),/REMOVE_ALL)
			PRINTF,10,'Monochromator fractional d-spacing:'+$
				STRCOMPRESS(STRING(user.monochr_dspread),/REMOVE_ALL)
			IF user.norm EQ 0 THEN PRINTF,10,'Normalised to monitor' $
				ELSE PRINTF,10,'Normalised to runtime.'
			IF user.bgsub EQ 0 THEN PRINTF,10,'Background was averaged.' $
				ELSE PRINTF,10,'Background was fitted.'
			IF user.qcalc EQ 0 THEN PRINTF,10,'Theta was calculated.' $
				ELSE PRINTF,10,'SAN was used as theta.'

; *!*!*!*! NB: It is important to have the wavelenght on the penultimate line.
; 'bundle.pro' searches for the string 'lam' in the 2nd to 4th characters of a 
; line and discard all lines up to and including that and the next too. 
; Therefore it is important to have this in the file so the data can be 
; read by 'bundle.pro' properly.

; Note that the first part of the string must be ' lam' 
			PRINTF,10,' lambda (Wavelength /Angstroms):'+$
				STRCOMPRESS(STRING(user.wavelength),/REMOVE_ALL)

; Now we're allowed one more line before 'bundle.pro' expects the data
; Indicate what the columns are on this line
			PRINTF,10,'	q	q resolution	reflectivity	ref error'

; Now write data for each point (numor: n_dbnumors in total)
			FOR i=0,n_dbnumors-1 DO PRINTF,10,q[j,i],q_res[j,i],$
					reflectivity[j,i],reflectivity_err[j,i]
		ENDELSE
		CATCH,/CANCEL
	ENDFOR	
; close the file
	CLOSE,10
END

;===============================================================================
; Procedure to group data. Combines data from points which are, within the 
; resolution, too close to each other. Also takes logarithm of the data and
; propagates the errors accordingly
; x = q values. y = Reflectivity values. e = error on reflectivity data
; dq = error on q values
; a = groupd reflectivity. b = groupd q values. c = groupd refl. errors
;===============================================================================
PRO group_monodata,x,y,e,dq,a,b,c

; arrays to store groupd data
	ny=FLTARR(N_ELEMENTS(y))
	nx=FLTARR(N_ELEMENTS(x))
	nee=FLTARR(N_ELEMENTS(e))
	ndq=FLTARR(N_ELEMENTS(dq))


	PRINT,'Bundling nearby data points for plotting:'

; resf = 'Magic' resolution factor. if the difference in q values is less 
; than dq/resf then group the points. With resf=2. data points 
; separated by half the error on q are groupd
	resf=2.

; number of elements in data
	tot=N_ELEMENTS(x)-1

; i counts the number of iterations purely for information on a print statement
	i=1
	
; This loop repeats until the number of pairs found is zero. (NB: It is 
; possible that the number of pairs will not decrease after an iteration.
; In this case data has been groupd, but the resulting point appears close
; to another point. This is why the number of pairs may remain equal to, e.g.
; 1 for the last few iterations
	REPEAT BEGIN

; reset c. c is used as a counter to address the data
		c=0
; set num to the number of elements in the data
		num=tot
; new is used to address the elements of the arrays where the groupd data is stored
		new=0
; counts the number of pairs encountered in each iteration
		pairs=0

; loop through data array
; while c is less than the last element (i.e. up to and including penultimate)
		WHILE c LT num DO BEGIN

; If q values are sufficiently close....
			IF (x(c+1)-x(c) LT dq(c)/resf) AND (x(c+1) ne 0) THEN BEGIN

; ... then group the data. This is done by averaging the q values and reflectivity of
; each point and the errors are obtained by adding in the two errors in quadrature
				ny(new)=(y(c+1)+y(c))/2.
				nee(new)=(sqrt(e(c)^2.+e(c+1)^2.))/2
				nx(new)=(x(c)+x(c+1))/2.
				ndq(new)=(dq(c)+dq(c+1))/2.

; increase number of pairs
				pairs=pairs+1
; increment counter by two because two numbers have been processed
				c=c+2
; decrease the number of data elements by 1: two points have been groupd
				tot=tot-1
			ENDIF ELSE BEGIN
; If no bundling is necessary then just copy the data into the new arrays.
				ny(new)=y(c)
				nx(new)=x(c)
				nee(new)=e(c)
				ndq(new)=dq(c)
; inc. counter by one
				c=c+1
			ENDELSE

;inc. groupd data array counter
			new=new+1
		END

; set old data to new groupd data ready for next iteration
		y=ny
		x=nx
		e=nee
		dq=ndq

		PRINT,pairs,' pairs found on iteration ',i
; increment number of iterations
		i=i+1
	
; stop if no pairs were found
	ENDREP UNTIL pairs eq 0

; Take only the (grouped) reflectivity data that is >0.0 (to prevent error
; when taking log)
	data_ind = WHERE(ny[0:tot-1] GT 0.0)

; return results: Log reflectivity data and calc. error on reflectivity.
; (a=log(reflect.) b=q, c=error on log(refl.)
	a=ALOG10(ny[data_ind]) 
	b=nx[data_ind] 
	c=(nee[data_ind]/ny[data_ind])/ALOG(10)

	RETURN

END

;===============================================================================
; Event handler for Direct beam attenuation correction window. The attenuation
; correction is done using the attenuator number written to the numor 
; (recommeded) or by specifying a start attenuator and looking for drops.
; The user can change the attenuation factor. By pressing the "do again"
; button the user can inspect the graph of intensity versus numor to see
; if it is correct (the intensity should increase continuously as the slits
; are opened). When the user is satisfied the "done" button is pressed and the
; direct beam data are corrected using the selected parameters.
;===============================================================================
PRO attcorrwin_event,event

; Common block for widget id's of DB attenuation correction window
; Also contains the number of the first numor for plotting purposes
COMMON attcorr,plotbase,butt_done_attcorr,butt_redo_attcorr,$
			text_factor_attcorr,butt_correctby,slider_startatt,firstnumor

; common block for pointers to data. and mean of reflected peaks
; Only really need direct beam in this procedure
COMMON loaded_data,db_data,ref_data,water


; If the 'correct by' button was changed then sensitize the 'starting attenuator'
; slider if 'Look for intensity drops' method was chosen. This slider specifies
; which attenuator was in on the first numor. Subsequent attenuators are
; found by looking for attenuator drops and by incrementing the numor number
	WIDGET_CONTROL,butt_correctby,GET_VALUE=sel
	IF event.id EQ butt_correctby THEN BEGIN
		IF sel EQ 1 THEN WIDGET_CONTROL,slider_startatt,SENSITIVE=1 $
		ELSE WIDGET_CONTROL,slider_startatt,SENSITIVE=0
	END

; Return if event doesn't come from one of the buttons or from the realisation
; of the window
	IF (event.id NE butt_done_attcorr) AND (event.id NE butt_redo_attcorr) $
			AND (event.id NE plotbase) THEN RETURN

; array to contain total counts for each db numor, corrected for attenuation
; this is for plotting purposes only
	corr_counts = FLTARR(N_ELEMENTS(db_data))

; total counts of last numor (initialise to 1e-10 to avoid divide by zero on 1st 
; iteration)
	last_count = 1e-10

; starting number of attenuators in beam
	WIDGET_CONTROL,slider_startatt,GET_VALUE=temp
	att = temp[0]

; get magic factor from user and convert to floating point
	WIDGET_CONTROL,text_factor_attcorr,GET_VALUE=temp
	magic_factor = FLOAT(temp[0])

; Loop over all direct beam numors
	FOR i=0,N_ELEMENTS(db_data)-1 DO BEGIN

; sum counts
		counts=TOTAL((*db_data[i]).detdata)

; If user selects "correct by looking for intensity drops"  (see above, sel)
; then do that...
		IF sel EQ 1 THEN BEGIN		
; If there is a large enough drop (factor of 0.8) then an attenuator has been 
; added. Increment attenuator count
			IF counts/last_count LT 0.8 THEN BEGIN
				IF att EQ 7 THEN BEGIN 
; If more than 7 attenuators are found display an error message (NOT using
; the /ERROR keyword and using /NOSENSITIZE so that the main window doesn't
; change its sensitisation).
					msgwin,'Error: an attenuator number greater'+$
					' than 7 was encountered, i.e. too many intensity drops occured.'+$
					' (Try lowering starting attenuator number?)',TITLE='Error',$
					/NOSENSITIZE
					RETURN
				END
				att=att+1
			END
; Otherwise set attenuator from file
		ENDIF ELSE att=(*db_data[i]).att

		fac=(EXP(-1.0*magic_factor*FLOAT(att)))
; attenutator-corrected counts are simply counts divided by exponential
		corr_counts[i]=counts/fac

; correct ACTUAL data only if user is satisfied and pressed 'done' button
		IF event.id EQ butt_done_attcorr THEN $
					(*db_data[i]).detdata[*]=(*db_data[i]).detdata[*]/fac
	
; last counts = current counts for next loop
		last_count = counts

	ENDFOR

; Get rid of window if done
	IF event.id EQ butt_done_attcorr THEN BEGIN 
		WIDGET_CONTROL,event.top,/DESTROY
	END

; Replot if Do again button is pressed or if window is realised
	IF (event.id EQ butt_redo_attcorr) THEN BEGIN
; various labels
		!P.TITLE = 'Plot of total attenuator-corrected counts versus  numor'
		!X.TITLE = 'Numor'
		!Y.TITLE = 'Total (corrected) counts'
		!Y.RANGE = [0.0,MAX(corr_counts)]
		PLOT,INDGEN(N_ELEMENTS(db_data))+firstnumor,corr_counts
	ENDIF
END

;===============================================================================
; Event handler for peaks/ranges window. This gets the values for the useful
; area of the detector and the approx. positions of the reflected beam peaks
; performing the necessary error checks.
;===============================================================================
PRO pixels_event,event

; Common block containg OK button id for peaks/ranges window
COMMON pixelsbutt,butt_pixelsok,text_xmax,text_xmin,text_refp1,text_refp2,$
		text_refp3,text_refp4

; Common block containing useful area of detector and approx whereabouts of 
; specular peak (for each polarisation, i.e. up to 4)
COMMON detector,xmin,xmax,refpmean

; Get values if okay button is pressed
	IF event.id EQ butt_pixelsok THEN BEGIN

; get the contents of the text widgets
		WIDGET_CONTROL,text_xmax,GET_VALUE=xmax_str
		WIDGET_CONTROL,text_xmin,GET_VALUE=xmin_str		
		WIDGET_CONTROL,text_refp1,GET_VALUE=refp1_str
		WIDGET_CONTROL,text_refp2,GET_VALUE=refp2_str
		WIDGET_CONTROL,text_refp3,GET_VALUE=refp3_str
		WIDGET_CONTROL,text_refp4,GET_VALUE=refp4_str

; store strings into array
		refp_str=STRARR(4)
		refp_str=[refp1_str[0],refp2_str[0],refp3_str[0],refp4_str[0]]

; get xmax (temp is used as temporary varaible during conversion)
; (Use QUIET keyword to disable error messages used for the main window)
		temp1=getint(xmax_str[0],'Useful area of detector: Maximum x',$
					MAX_VALUE=1000,/ALLOW_EMPTY,/QUIET)
; return on error
		IF temp1 EQ -1 THEN BEGIN 
			msgwin,'Error: xmax is badly formatted or out of range.'+$
				' Must be integer in range [0,1000].',TITLE='Error!'
			RETURN
		END

; get xmin
		temp2=getint(xmin_str[0],'Useful area of detector: Minimum x',$
					MAX_VALUE=1000,/ALLOW_EMPTY,/QUIET)
; return on error
		IF temp2 EQ -1 THEN BEGIN 
			msgwin,'Error: xmin is badly formatted or out of range.'+$
				' Must be integer in range [0,1000].',TITLE='Error!'
			RETURN
		END


; Check that xmin<xmax (only if neither are zero-the default)
		IF (temp2 GE temp1) AND (temp2 NE 0) AND (temp1 NE 0) THEN BEGIN
			msgwin,'Error minimum x value must be less than maximum!',$
					TITLE='Error!'
			RETURN
		END

; Get approximate specular-peak positions
		temparr=FLTARR(N_ELEMENTS(refp_str))
; range is constrained by xmin, xmax specified by user:
; If xmax=temp1 ne 0 (default) then set this as the maxval, otherwise set
; large value
		IF temp1 NE 0 THEN maxval=temp1 ELSE maxval=1000.0
		FOR i=0,N_ELEMENTS(refp_str)-1 DO BEGIN
; convert to float using maxval=xmax as upper bound. Can't set minvalue to 
; xmin since user can enter 0.0 as default. Check this on line after.
			temparr[i]=getfloat(refp_str[i],MIN_VALUE=0.0,MAX_VALUE=maxval)
; If temparr[i] isn't finite then error occured. Also check that it's greater
; than xmin=temp2 (if temp2 or temparr[i] not = 0 (default))
			IF  (NOT FINITE(temparr[i])) OR $
					((temparr[i] LT FLOAT(temp2)) AND (temp2 NE 0) AND (temparr[i] NE 0.0)) THEN BEGIN
				msgwin,'Error: Specular peak position ('+$
					STRCOMPRESS(STRING(i+1),/REMOVE_ALL)+$
					') is bad or out of range (xmin,xmax).',TITLE='Error!',$
					/NOSENSITIZE
				RETURN
			END
		ENDFOR

; If we get here then all is well! store variables and destroy widget
		xmax=temp1 & xmin=temp2
; Set only those which aren't zero (if there are any)
		ones_to_set=WHERE(temparr GT 0.0)
		IF ones_to_set[0] NE -1 THEN refpmean[ones_to_set]=temparr[ones_to_set]
		WIDGET_CONTROL,event.top,/DESTROY
	ENDIF
END

;===============================================================================
; Event handler for main window. This gets all the text from the text widgets
; and converts them to the appropriate types (integers/floats etc). Numerous
; error checks are made to ensure that the fields are correctly formatted and
; within range. Other checks are performed, eg to check that the number of db
; and ref. numors correspond, given the number of polarisations. If the 
; fields are all okay then the defaults file is written.
;===============================================================================
PRO mono_event,event

; Common block for base id's
COMMON baseid,mono_base,file_base,anal_base

; common block for button id's
COMMON buttons,	butt_quit, butt_anal, butt_reset,butt_pixels

; common blocks for all of the user entered parameters
COMMON textid,text_db_first,text_db_last,text_water,text_lambda,text_output,$
	text_ref_first,text_ref_last,text_foreground,text_bg_left,text_bg_right,$
	text_dir,text_mcr_ang,text_mcr_dspread

COMMON buttid,butt_polarise,butt_normalise,butt_bg,butt_qcalc

; common block for pointers to data. 
COMMON loaded_data,db_data,ref_data,water

; Common block containing widget id of status label
COMMON status,loadedflag,label_status

; Common block containing useful area of detector and approx whereabouts of 
; specular peak (for each polarisation, i.e. up to 4)
COMMON detector,xmin,xmax,refpmean

; Common block containg OK button id for peaks/ranges window and the widget ids
; of the text boxes
COMMON pixelsbutt,butt_pixelsok,text_xmax,text_xmin,text_refp1,text_refp2,$
		text_refp3,text_refp4

; Quit:
	IF event.id EQ butt_quit THEN BEGIN 
; Free memory and destroy main widget
		PTR_FREE,db_data,ref_data
		WIDGET_CONTROL,event.top,/DESTROY
	END

	IF event.id EQ butt_reset THEN BEGIN
; delete data
		PTR_FREE,db_data,ref_data
; pointers are now 'dangling' set them to null pointers for relative safety
		db_data=PTR_NEW()
		ref_data=PTR_NEW()

; set detector ranges xmin,xmax both to 0 (taken to mean defaults, i.e. 
; xmin = 0, xmax=size of array-see PRO fpeak)
		xmin = 0 & xmax = 0

; reset refpmean (mean of specular peak used in centre of mass calc.) to 0.0
; (=default=let PRO analysis look for it)
		refpmean[*]=0.0

; change status window accordingly
		WIDGET_CONTROL,label_status,SET_VALUE='Data reset. No data loaded.'
		loadedflag=0
; resensitise file entry fields
		WIDGET_CONTROL,file_base,SENSITIVE=1
	END

; Peaks/Ranges button
	IF event.id EQ butt_pixels THEN BEGIN

; base widget (modal)
		pixels_base = WIDGET_BASE(GROUP_LEADER=mono_base,/MODAL,$
							TITLE='Pixel ranges/Peaks',/COLUMN)

; Title stuff
		dummy = WIDGET_LABEL(pixels_base,$
				VALUE='NB: To select default (or old value) leave box empty or')
		dummy = WIDGET_LABEL(pixels_base,VALUE=' set to zero. (Defaults in square brackets [])')
		dummy = WIDGET_LABEL(PIXELS_base,VALUE='',YSIZE=10)

; Useful area of detector
		dummy = WIDGET_LABEL(pixels_base,$
							VALUE='Useful area of detector in pixels')
		dumbarse_base = WIDGET_BASE(pixels_base,/FRAME,/ROW)
		dummy = WIDGET_LABEL(dumbarse_base,VALUE='X min [0]')
		text_xmin = WIDGET_TEXT(dumbarse_base,/EDITABLE,XSIZE=4,$
					VALUE=STRCOMPRESS(STRING(xmin),/REMOVE_ALL))
		dummy = WIDGET_LABEL(dumbarse_base,VALUE='X max [size of array]')
		text_xmax = WIDGET_TEXT(dumbarse_base,/EDITABLE,XSIZE=4,$
					VALUE=STRCOMPRESS(STRING(xmax),/REMOVE_ALL))
		dummy = WIDGET_LABEL(PIXELS_base,VALUE='',YSIZE=10)

; "Reflected peak near pixel no." stuff
		dummy = WIDGET_LABEL(pixels_base,$
							VALUE='Specular peak near:')
		dummy = WIDGET_LABEL(pixels_base,VALUE='(NB: 1 for each polarisation')
		dummy = WIDGET_LABEL(pixels_base,VALUE=' [default=automatic search])')

		thickas_base = WIDGET_BASE(pixels_base,COLUMN=4,/FRAME,/BASE_ALIGN_CENTER)

		dummy = WIDGET_LABEL(thickas_base,VALUE='1st')
		text_refp1 = WIDGET_TEXT(thickas_base,/EDITABLE,XSIZE=8,$
					VALUE=STRCOMPRESS(STRING(refpmean[0]),/REMOVE_ALL))
		dummy = WIDGET_LABEL(thickas_base,VALUE='2nd')
		text_refp2 = WIDGET_TEXT(thickas_base,/EDITABLE,XSIZE=8,$
					VALUE=STRCOMPRESS(STRING(refpmean[1]),/REMOVE_ALL))
		dummy = WIDGET_LABEL(thickas_base,VALUE='3rd')
		text_refp3 = WIDGET_TEXT(thickas_base,/EDITABLE,XSIZE=8,$
					VALUE=STRCOMPRESS(STRING(refpmean[2]),/REMOVE_ALL))
		dummy = WIDGET_LABEL(thickas_base,VALUE='4th')
		text_refp4 = WIDGET_TEXT(thickas_base,/EDITABLE,XSIZE=8,$
					VALUE=STRCOMPRESS(STRING(refpmean[3]),/REMOVE_ALL))

; ok button
		butt_pixelsok = WIDGET_BUTTON(pixels_base,VALUE='OK')

;realisation
		WIDGET_CONTROL,pixels_base,/REALIZE
		XMANAGER,'pixels',pixels_base
	END

;Analyse:
	IF event.id EQ butt_anal THEN BEGIN

; desentitise file and analysis bases
		WIDGET_CONTROL,file_base,SENSITIVE=0
		WIDGET_CONTROL,anal_base,SENSITIVE=0

;-----------------------------------------------
; Read in the text widgets and check
;-----------------------------------------------

; Read in text widgets
		WIDGET_CONTROL,text_db_first,GET_VALUE=dbfirst
		WIDGET_CONTROL,text_db_last,GET_VALUE=dblast
		WIDGET_CONTROL,text_water,GET_VALUE=fwater
		WIDGET_CONTROL,text_lambda,GET_VALUE=lambdastr
		WIDGET_CONTROL,text_output,GET_VALUE=output
		WIDGET_CONTROL,text_ref_first,GET_VALUE=reffirst
		WIDGET_CONTROL,text_ref_last,GET_VALUE=reflast
		WIDGET_CONTROL,text_foreground,GET_VALUE=foreground
		WIDGET_CONTROL,text_bg_left,GET_VALUE=bgleft
		WIDGET_CONTROL,text_bg_right,GET_VALUE=bgright
		WIDGET_CONTROL,text_dir,GET_VALUE=dir
		WIDGET_CONTROL,text_mcr_ang,GET_VALUE=mcrang
		WIDGET_CONTROL,text_mcr_dspread,GET_VALUE=mcrdspread
	
; Read in radio button options (integers)
		WIDGET_CONTROL,butt_polarise,GET_VALUE=pol_opt
		WIDGET_CONTROL,butt_normalise,GET_VALUE=norm_opt
		WIDGET_CONTROL,butt_bg,GET_VALUE=bg_opt
		WIDGET_CONTROL,butt_qcalc,GET_VALUE=qcalc_opt

; Convert numor text widgets to numors returning on errors (-1)
; (nb: 999999 is max numor value)
		dbfirst=getint(dbfirst[0],'Direct beam, 1st Numor',MAX_VALUE=999999)	
		IF dbfirst EQ -1 THEN RETURN
		dblast=getint(dblast[0],'Direct beam, last Numor',MAX_VALUE=999999)
		IF dblast EQ -1 THEN RETURN
		reffirst=getint(reffirst[0],'Reflected beam, 1st Numor',MAX_VALUE=999999)
		IF reffirst EQ -1 THEN RETURN
		reflast=getint(reflast[0],'Reflected beam, last Numor',MAX_VALUE=999999)
		IF reflast EQ -1 THEN RETURN
		fwater=getint(fwater[0],'Water (efficiency) file',MAX_VALUE=999999,/ALLOW_EMPTY)
		IF fwater EQ -1 THEN RETURN
	
; If 1st numor greater than last signal error for direct beam
		IF dbfirst GT dblast THEN BEGIN
			msgwin,'Direct beam: 1st Numor ('+$
			STRTRIM(STRING(dbfirst),1)+')  greater than last ('+$
			STRTRIM(STRING(dblast),1)+')!',/ERROR
			RETURN
		END
;...Do similar for reflected beam
		IF reffirst GT reflast THEN BEGIN
			msgwin,'Reflected beam: 1st Numor ('+$
			STRTRIM(STRING(reffirst),1)+')  greater than last ('+$
			STRTRIM(STRING(reflast),1)+')!',/ERROR
			RETURN
		END

; Now check that there are the correct number of reflected numors with
; respect to direct beam numors given the polarisation option
	
; number of ref and db numors
		ndb=dblast-dbfirst+1
		nref=reflast-reffirst+1
	
; pol_opt=0,1,2,3. 0=unpolarised therfore ther are as many reflected as
; direct beam numors (pol_opt+1=1). 1=polarised, so 2 reflected for
; each direct beam (pol_opt+1=2). 2=analyser that only distiguished ++,-- or
; +-/-+ (i.e. 3*) and 3=analyser which distiguishes ++,--,+- and -+.
		IF nref NE ndb*(pol_opt+1) THEN BEGIN
; make a string describing the polarisation options.
			CASE pol_opt OF
				0:polstr='unpolarised'
				1:polstr='polariser - no analyser'
				2:polstr='analyser with no +-,-+ distinction'
				3:polstr='analyser with +-,-+ distinction'
			ENDCASE

; make a string to say whether there are too many/few ref. beam numors
			IF nref GT ndb*(pol_opt+1) THEN too='many' ELSE too='few'
; print out a very long error message (NB STRING([10B,10B]) prints out
; 2 carriage returns.
			msgwin,'Mismatch in number of reflected and direct beam numors!'+$
			STRING([10B,10B])+'For chosen polarsiation options ('+polstr+$
			') there must be '+STRTRIM(STRING(pol_opt+1),1)+' reflected '+$
			'numors per direct beam. You have '+STRTRIM(STRING(nref),1)+$
			' reflected beam numors and '+STRTRIM(STRING(ndb),1)+$
			' direct beam numors. Therfore you have '+$
			STRTRIM(STRING(ABS(nref-ndb*(pol_opt+1))),1)+' too '+$
			too+' reflected beam numors.',/ERROR
			RETURN
		END

; NOW GET THE WAVELENGTH
	
;convert (lambda>0.0 so specify v. small min value, 1e-10
		lambda=getfloat(lambdastr[0],MIN_VALUE=1e-10)

; If lambda is not finite (i.e NaN in this case) then conversion error occured
; or lambda<=0.0
		IF NOT FINITE(lambda) THEN BEGIN
			msgwin,'Bad wavelength."'+lambdastr[0]+'".'+$
			STRING([10B,10B])+'Wavelength should be entered as a floating'+$
			' point in Angstroms. Obviously, wavelength>0.0.',/ERROR
			RETURN
		END

; Get the monochromator angle (exactly same procedure as for wavelength above)
		mcr_ang = getfloat(mcrang[0],MIN_VALUE=1e-10)

		IF NOT FINITE(mcr_ang) THEN BEGIN
			msgwin,'Bad monochromator angle."'+mcrang[0]+'".'+$
			STRING([10B,10B])+'Monochromator angle should be entered as a floating'+$
			' point in degrees (>0.0 deg.).',/ERROR
			RETURN
		END

; Get the percentage d-spacing of the monochromator
		mcr_dspread=getfloat(mcrdspread[0],MIN_VALUE=1e-10)
	
		IF NOT FINITE(mcr_dspread) THEN BEGIN
			msgwin,'Bad d-spacing spread of monochromator."'+mcrdspread[0]+'".'+$
			STRING([10B,10B])+'Fractional d-spacing spread should be entered as a floating'+$
			' point in percent (>0.0%).',/ERROR
			RETURN
		END

; Get foreground width return if error
		foreground=getint(foreground[0],'Foreground width',MAX_VALUE=100)
		IF foreground EQ -1 THEN RETURN

; get background left width and shift formatted as "[width[,shift]]"
; (where [] brackets indicate that the field can be omitted. So shift
; can be omitted and so can width, but there can be no shift if width is omitted
; look for a comma
		commapos = STRPOS(bgleft[0],',')
		CASE commapos OF
; No commas -> check only for width (may also be empty and therefore 0)
; set shift to 0
			-1:BEGIN
				bgleft_width = getint(bgleft[0],'Background left (width)'$
					,MAX_VALUE=100,/ALLOW_EMPTY)
				IF bgleft_width EQ -1 THEN RETURN
				bgleft_shift = 0
				END
; comma in 1st position -> ERROR!
			0:BEGIN
				msgwin,'Badly formatted background left.'+$
					STRING([10B,10B])+'Comma in illegal position. Must be formatted as [width,[shift]] where brackets indicate optional parameters.',/ERROR
				RETURN
				END
; otherwise if comma is in okay position then get both width and shift
			ELSE: BEGIN
				bgleft_width = getint(STRMID(bgleft[0],0,commapos),'Background left (width)',MAX_VALUE=100,/ALLOW_EMPTY)
				IF bgleft_width EQ -1 THEN RETURN
				bgleft_shift = getint(STRMID(bgleft[0],commapos+1,STRLEN(bgleft[0])-commapos-1),'Background left (shift)',MAX_VALUE=100,/ALLOW_EMPTY)
				IF bgleft_shift EQ -1 THEN RETURN
				IF (bgleft_width EQ 0) AND (bgleft_shift GT 0) THEN BEGIN
					msgwin,'Background left: Zero width, but non zero shift! A width must be defined if there is to be a shift.',/ERROR
					RETURN
				END
			END
		ENDCASE

;Now do exactly the same for the right background.
; get background right width and shift formatted as "[width[,shift]]"
; (where [] brackets indicate that the field can be omitted. 
; look for a comma
		commapos = STRPOS(bgright[0],',')
		CASE commapos OF
; No commas -> check only for width (may also be empty and therefore 0)
; set shift to 0
			-1:BEGIN
				bgright_width = getint(bgright[0],'Background right (width)'$
					,MAX_VALUE=100,/ALLOW_EMPTY)
				IF bgright_width EQ -1 THEN RETURN
				bgright_shift = 0
				END
; comma in 1st position -> ERROR!
			0:BEGIN
				msgwin,'Badly formatted background right.'+$
					STRING([10B,10B])+'Comma in illegal position. Must be formatted as [width,[shift]] where brackets indicate optional parameters.',/ERROR
				RETURN
				END
; otherwise if comma is in okay position then get both width and shift
			ELSE: BEGIN
				bgright_width = getint(STRMID(bgright[0],0,commapos),'Background right (width)',MAX_VALUE=100,/ALLOW_EMPTY)
				IF bgright_width EQ -1 THEN RETURN
				bgright_shift = getint(STRMID(bgright[0],commapos+1,STRLEN(bgright[0])-commapos-1),'Background right (shift)',MAX_VALUE=100,/ALLOW_EMPTY)
				IF bgright_shift EQ -1 THEN RETURN
				IF (bgright_width EQ 0) AND (bgright_shift GT 0) THEN BEGIN
					msgwin,'Background right: Zero width, but non zero shift! A width must be defined if there is to be a shift.',/ERROR
					RETURN
				END

			END
		ENDCASE
	
;-------------------------------------
; Now that options have been checked	
; write them to mono_defaults.dat
;-------------------------------------

; attempt to open file
		CLOSE,10
		OPENW,10,'mono_defaults.dat',ERROR=err

; catch write errors
		Error_status=0
		CATCH,Error_status

; This begins the error handler for Error_status (write errors) and err (open
; errors). It sets err to non-zero at the end to signal that the no attempt
; should be made to write to the file
		IF (err NE 0) OR (Error_Status NE 0) THEN BEGIN
; print out warning message
			PRINT,'Warning: Unable to write programme settings to mono_defaults.dat'
			PRINT,'Error:',!ERR_STRING
			PRINT,'This is not a critical error, calculations will proceed.'
; set error flag to non-zero value (1) (so it won't try to write to file)
; (see if statement below)
			err=1
		ENDIF

; only attempt to write if err is zero (no error)
		IF (err EQ 0) THEN BEGIN
			PRINTF,10,'D17 Monochromatic analysis defaults file'
			PRINTF,10,'Direct beam: 1st Numor'
			PRINTF,10,STRCOMPRESS(STRING(dbfirst),/REMOVE_ALL)
			PRINTF,10,'Direct beam: Last Numor'
			PRINTF,10,STRCOMPRESS(STRING(dblast),/REMOVE_ALL)
			PRINTF,10,'Reflected beam: 1st Numor'
			PRINTF,10,STRCOMPRESS(STRING(reffirst),/REMOVE_ALL)	
			PRINTF,10,'Reflected beam: Last Numor'
			PRINTF,10,STRCOMPRESS(STRING(reflast),/REMOVE_ALL)
			PRINTF,10,'Water (efficiency) file'
			PRINTF,10,STRCOMPRESS(STRING(fwater),/REMOVE_ALL)
			PRINTF,10,'Wavelength (Angstroms)'
			PRINTF,10,STRCOMPRESS(STRING(lambda),/REMOVE_ALL)
			PRINTF,10,'Monochromator angle (degrees)'
			PRINTF,10,STRCOMPRESS(STRING(mcr_ang),/REMOVE_ALL)
			PRINTF,10,'Output file name'
			PRINTF,10,STRCOMPRESS(output[0],/REMOVE_ALL)
			PRINTF,10,'Foreground width'
			PRINTF,10,STRCOMPRESS(STRING(foreground),/REMOVE_ALL)
			PRINTF,10,'Background left (width,shift)'
			PRINTF,10,STRCOMPRESS(STRING(bgleft_width)+','+STRING(bgleft_shift),/REMOVE_ALL)
			PRINTF,10,'Background right (width,shift)'
			PRINTF,10,STRCOMPRESS(STRING(bgright_width)+','+STRING(bgright_shift),/REMOVE_ALL)
			PRINTF,10,'Data directory'
			PRINTF,10,STRCOMPRESS(dir[0],/REMOVE_ALL)
			PRINTF,10,'Percentage spread in d-spacing of monochromator'
			PRINTF,10,STRCOMPRESS(STRING(mcr_dspread),/REMOVE_ALL)
			PRINTF,10,'Polarisation option'
			PRINTF,10,STRCOMPRESS(STRING(pol_opt),/REMOVE_ALL)
			PRINTF,10,'Normalisation option'
			PRINTF,10,STRCOMPRESS(STRING(norm_opt),/REMOVE_ALL)
			PRINTF,10,'Background subtraction method'
			PRINTF,10,STRCOMPRESS(STRING(bg_opt),/REMOVE_ALL)
			PRINTF,10,'Q calculation method'
			PRINTF,10,STRCOMPRESS(STRING(qcalc_opt),/REMOVE_ALL)
		ENDIF
		CLOSE,10
		CATCH,/CANCEL

; make a structure containing user input parameters to pass to analysis
		user = {userinput,db_first:dbfirst,db_last:dblast,ref_first:reffirst,$
		ref_last:reflast,waterfile:fwater,wavelength:lambda,$
		outputfile:output[0],datadir:dir,fgwidth:foreground,bgleft:[bgleft_width,$
		bgleft_shift],bgright:[bgright_width,bgright_shift],monochr_angle:mcr_ang,$
		monochr_dspread:mcr_dspread,pol:pol_opt,norm:norm_opt,bgsub:bg_opt,$
		qcalc:qcalc_opt}

; call main analysis routine
		analysis,user

; resensitize base
		WIDGET_CONTROL,anal_base,SENSITIVE=1
		END

END

;===============================================================================
; Main procedure "PRO mono". Loads defaults file. Displays main window.
; 'nuff said.
;===============================================================================
PRO d17mono

; Common block for base ids
COMMON baseid,mono_base,file_base,anal_base

; common block for button id's
COMMON buttons,	butt_quit, butt_anal, butt_reset,butt_pixels

; common blocks for all of the user entered parameters
COMMON textid,text_db_first,text_db_last,text_water,text_lambda,text_output,$
	text_ref_first,text_ref_last,text_foreground,text_bg_left,text_bg_right,$
	text_dir,text_mcr_ang,text_mcr_dspread
COMMON buttid,butt_polarise,butt_normalise,butt_bg,butt_qcalc

; common block for pointers to data.
COMMON loaded_data,db_data,ref_data,water

COMMON status,loadedflag,label_status

; Common block containing useful area of detector
COMMON detector,xmin,xmax,refpmean

;----------------------------------
; Initialisation

; Initialise useful area of detector as 0 (default)
	xmin = 0 & xmax = 0

; refpmean is an array containing the pixel indices of where the specular 
; peak is near. The centre of mass calculation is performed about this
; pixel. NB one pixel for each of the 4 (possible) polarisations
	refpmean=FLTARR(4)
	refpmean[*]=0.0

; Initialise data pointers (stored in common block) as NULL pointers
	db_data = PTR_NEW()
	ref_data = PTR_NEW()
	water = PTR_NEW()

; Set loadedflag to zero (false, no data loaded)
	loadedflag=0

; Gay welcome message
	PRINT,''
	PRINT,'Starting mono.pro. The monochromatic reflectivity analysis programme.'
	PRINT,' * Loading defaults...'

;------------------------------------
; Open defaults file:

	CLOSE,10
	OPENR,10,'mono_defaults.dat',ERROR=err
	
; strings for text widget defaults
	defaults=STRARR(13)
	defaults[*]='         '
; defaults for buttons
	butt_defaults=INTARR(4)
; string for spacers to disregard
	spacer=''
; temp. string to read lines from file
	temp=''

; Error handler:
	Error_status=0
	CATCH,Error_status
; If there was an error used following 'hardwired' defaults
	IF (Error_status NE 0) OR (err NE 0) THEN BEGIN
		PRINT,'Error loading defaults file:',!ERR_STRING
		PRINT,'Setting hardwired defaults.'
; ***********CHANGE HARDWIRED DEFAULTS HERE**************
; (These are only used when there is no defaults file)

; direct beam 1st and last numors
		defaults[0]=''
		defaults[1]=''
; reflected beam 1st and last numors
		defaults[2]=''
		defaults[3]=''
; water file
		defaults[4]=''
; wavelength 
		defaults[5]='5.0'
; monochromator angle (degrees)
		defaults[6]='2.0'
; output file
		defaults[7]='mono_output.dat'
; Foreground
		defaults[8]=''
; Background left and right
		defaults[9]=''
		defaults[10]=''
; data directory
		defaults[11]=''
; percentage spread in d-spacing of monochromator
		defaults[12]='4.0'
; Default buttons, all first choice (0):
		butt_defaults[0]=0 & butt_defaults[1]=0 &butt_defaults[2]=0 & butt_defaults[3]=0
; If an error occured set err to non-zero so it won't try to read the file again
; (see next if statement)
		err=1
	ENDIF

; Try to read the default file if it was successfully opened
	IF err EQ 0 THEN BEGIN
; catch any input errors (e.g. premature end of file)	
;read title line-discard
		READF,10,spacer
		FOR i=0,N_ELEMENTS(defaults)-1 DO BEGIN
; read the spacer
			READF,10,spacer,FORMAT='(A)'
; Can't simply read into defaults[i] because when passed to READF this is
; only a copy. Must use a temp variable (see p177 Building IDL....)
			READF,10,temp,FORMAT='(A)'
			defaults[i]=temp
		ENDFOR
; read default for each button widget
; (now define temp as integer)
		temp=0
		FOR i=0,N_ELEMENTS(butt_defaults)-1 DO BEGIN
			READF,10,spacer
; ditto here, as above
			READF,10,temp
			butt_defaults[i]=FIX(temp)
; Just in case the file is edited and a negative option is put in
; (more checks on butt_defaults are made below)
			IF butt_defaults[i] LT 0 THEN butt_defaults[i]=0
		ENDFOR
; If button default is outside range then set to hardwired default (0)
		IF butt_defaults[0] GT 3 THEN butt_defaults[0]=0
		IF butt_defaults[1] GT 1 THEN butt_defaults[1]=0
		IF butt_defaults[2] GT 1 THEN butt_defaults[2]=0
		IF butt_defaults[3] GT 1 THEN butt_defaults[3]=0
	ENDIF
	
	CLOSE,10	

;end error handling
	CATCH,/CANCEL

;-----------------------------------------------------------
; Below is thc code displaying the main window. The base widget is mono_base
; all other base widgets are simply to put pretty frames around text fields.
; The variable dummy is used as a widget ID for non-interactive widgets
; such as labels and spaces and 'null' widgets (which just pad out columns)
; The only important things are the text widgets "text_[name]" which are
; the IDs for the text entry fields. butt_[name] are buttons. The window
; is arranged into 3 columns and has a total y pixel size of 500
	mono_base = WIDGET_BASE(TITLE = 'D17 : Monochromatic Analysis',/COLUMN)

	dummy = WIDGET_LABEL(mono_base,VALUE='DATA FIELDS')

;Base widget for files
	file_base = WIDGET_BASE(mono_base,COLUMN=3,/FRAME)

; -------------1st Column for file_base
; Direct beam entry stuff
	dummy = WIDGET_LABEL(file_base,VALUE='Direct Beam')
	db_base = WIDGET_BASE(file_base,/FRAME,COLUMN=2,/BASE_ALIGN_CENTER)
	dummy = WIDGET_LABEL(db_base,VALUE='1st Numor',YSIZE=35)
	dummy = WIDGET_LABEL(db_base,VALUE='Last Numor',YSIZE=35)
	text_db_first = WIDGET_TEXT(db_base,/EDITABLE,XSIZE=6,VALUE=defaults[0],SCR_YSIZE=35)
	text_db_last = WIDGET_TEXT(db_base,/EDITABLE,XSIZE=6,VALUE=defaults[1],SCR_YSIZE=35)

	dummy = WIDGET_LABEL(file_base,VALUE='Data directory',SCR_YSIZE=35,/ALIGN_RIGHT)
	dummy = WIDGET_LABEL(file_base,VALUE='Water file',SCR_YSIZE=35,/ALIGN_RIGHT)

; -------------2nd Column for file_base
; REflected beam entry stuff
	dummy = WIDGET_LABEL(file_base,VALUE='Reflected Beam')
	ref_base = WIDGET_BASE(file_base,/FRAME,COLUMN=2,/BASE_ALIGN_CENTER)
	dummy = WIDGET_LABEL(ref_base,VALUE='1st Numor',YSIZE=35)
	dummy = WIDGET_LABEL(ref_base,VALUE='Last Numor',YSIZE=35)
	text_ref_first = WIDGET_TEXT(ref_base,/EDITABLE,XSIZE=6,VALUE=defaults[2],SCR_YSIZE=35)
	text_ref_last = WIDGET_TEXT(ref_base,/EDITABLE,XSIZE=6,VALUE=defaults[3],SCR_YSIZE=35)

;water file
	text_dir = WIDGET_TEXT(file_base,/EDITABLE,XSIZE=15,SCR_YSIZE=35,VALUE=defaults[11])
; Data dir. entry field
	text_water = WIDGET_TEXT(file_base,/EDITABLE,XSIZE=6,/ALIGN_LEFT,SCR_YSIZE=35,VALUE=defaults[4])	
; -------------3rd Column for file_base
; polarisation options
	butt_polarise = CW_BGROUP(file_base,['Unpolarised (1)','Polarised (2)',$
	'Analyser (3)','Analyser +- (4)'],/EXCLUSIVE,LABEL_TOP=$
	'Polarisation options',/FRAME, SET_VALUE=butt_defaults[0])

	dummy = WIDGET_LABEL(file_base,VALUE='',SCR_YSIZE=0)
	dummy = WIDGET_LABEL(file_base,VALUE='',SCR_YSIZE=0)
	dummy = WIDGET_LABEL(file_base,VALUE='',SCR_YSIZE=0)


	dummy = WIDGET_LABEL(mono_base,VALUE='',SCR_YSIZE=10)

	dummy = WIDGET_LABEL(mono_base,VALUE='STATUS')
	stat_base = WIDGET_BASE(mono_base,/FRAME)
	label_status = WIDGET_LABEL(stat_base,VALUE='No data loaded',/ALIGN_CENTER,/DYNAMIC_RESIZE)

	dummy = WIDGET_LABEL(mono_base,VALUE='',SCR_YSIZE=10)

; Base widget for analysis stuff
	dummy = WIDGET_LABEL(mono_base,VALUE='ANALYSIS FIELDS')
	anal_base=WIDGET_BASE(mono_base,COLUMN=3,/FRAME)

; -------------1st Column for anal_base

; normalisation options
	butt_normalise = CW_BGROUP(anal_base,['Monitor','Run time'],/EXCLUSIVE,$
	LABEL_TOP='Normalisation options',/FRAME, SET_VALUE=butt_defaults[1])

; q calc. options
	butt_qcalc = CW_BGROUP(anal_base,['Theta (calculated)','SAN (Instrument)'],/EXCLUSIVE,LABEL_TOP=$
	'Calculate q from:',/FRAME, SET_VALUE=butt_defaults[3])

;wavelength
	dummy = WIDGET_LABEL(anal_base,VALUE='Wavelength (Angst.)')
	text_lambda = WIDGET_TEXT(anal_base,/EDITABLE,XSIZE=5,VALUE=defaults[5])

;output file name
	dummy = WIDGET_LABEL(anal_base,VALUE='Output file')
	text_output = WIDGET_TEXT(anal_base,/EDITABLE,XSIZE=12,VALUE=defaults[7])

; -------------2nd Column for anal_base	


;Foreground
	fg_base = WIDGET_BASE(anal_base,/ROW)
	dummy = WIDGET_LABEL(fg_base,VALUE='Foreground')
	text_foreground = WIDGET_TEXT(fg_base,/EDITABLE,XSIZE=4,VALUE=defaults[8])

	dummy = WIDGET_LABEL(anal_base,VALUE='',YSIZE=0)
	dummy = WIDGET_LABEL(anal_base,VALUE='',YSIZE=0)

; Background
	bg_base = WIDGET_BASE(anal_base,/FRAME,/COLUMN)	
	dummy = WIDGET_LABEL(bg_base,VALUE='Background')
	dummy = WIDGET_LABEL(bg_base,VALUE='Format:"[width[,shift]]"')
	dummy = WIDGET_LABEL(bg_base,VALUE='',YSIZE=5)
	leftbg_base = WIDGET_BASE(bg_base,/ROW)
	dummy = WIDGET_LABEL(leftbg_base,VALUE='Left: ',/ALIGN_RIGHT)
	text_bg_left = WIDGET_TEXT(leftbg_base,/EDITABLE,XSIZE=7,VALUE=defaults[9])
	rightbg_base = WIDGET_BASE(bg_base,/ROW)
	dummy = WIDGET_LABEL(rightbg_base,VALUE='Right: ',/ALIGN_RIGHT)
	text_bg_right = WIDGET_TEXT(rightbg_base,/EDITABLE,XSIZE=7,VALUE=defaults[10])
	dummy = WIDGET_LABEL(anal_base,VALUE='',YSIZE=0)
; Background subtraction method selection
	butt_bg = CW_BGROUP(anal_base,['Average','Fit'],/EXCLUSIVE,$
	LABEL_TOP='Backgroung subtract',/FRAME,SET_VALUE=butt_defaults[2])

; -------------3rd Column for anal_base	

;monochromator base
	dummy = WIDGET_LABEL(anal_base,VALUE='Monochromator')
	mcr_base = WIDGET_BASE(anal_base,/COLUMN,/FRAME)
	dummy = WIDGET_LABEL(mcr_base,VALUE='Angle (deg.)',/ALIGN_CENTER)
	text_mcr_ang = WIDGET_TEXT(mcr_base,/EDITABLE,XSIZE=5,VALUE=defaults[6],/ALIGN_CENTER)
	dummy = WIDGET_LABEL(mcr_base,VALUE='Fractional d-spread (%)',/ALIGN_CENTER)	
	text_mcr_dspread = WIDGET_TEXT(mcr_base,/EDITABLE,XSIZE=5,VALUE=defaults[12],/ALIGN_CENTER)

	dummy = WIDGET_LABEL(anal_base,VALUE='',YSIZE=0)

;Analyse button
	dummy = WIDGET_LABEL(anal_base,VALUE='',YSIZE=10)
; base widget for buttons
	butt_base = WIDGET_BASE(anal_base,/COLUMN)
	butt_anal = WIDGET_BUTTON(butt_base,VALUE='ANALYSE')

; pixel ranges button
	butt_pixels = WIDGET_BUTTON(butt_base,VALUE='  PEAKS/RANGES  ')
; Reset Button
	butt_reset = WIDGET_BUTTON(butt_base,VALUE='RESET')

; "QUIT" button
	butt_quit = WIDGET_BUTTON(butt_base,VALUE='QUIT')


; Realise main window and register event handler PRO mono_event
	WIDGET_CONTROL,mono_base,/REALIZE
	XMANAGER,'mono',mono_base
END
pro d17ratio,count
range=5
;dummy runs
co,2,'t n'
d17data,data
wait,.5
co,2,'t n'
wait,.5
d17data,data
wait,1
d17mad,'par sub flipping ratio'
print,'turning flippers on'
d17mad,'b1 on'
wait,1
d17mad,'b2 on'
wait,2

co,count,' t'
wait,2
d17data,data
wait,2
b=size(data)
if b(0) gt 1 then dat=total(data,2)

a=max(dat,c)
print,'sum range= ',c-range,c+range
on=float(total(dat(c-range:c+range)))

eron=sqrt(on)/on
print,'total rate =',total(float(dat))/float(count)
print,'box counts =',on, '+/- ',eron*on

print,'turning flippers off'
d17mad,'b1 off'
wait,1
d17mad,'b2 off'
wait,2

co,count,' t'
wait,2
d17data,data
wait,2
b=size(data)
if b(0) gt 1 then dat=total(data,2)

a=max(dat,c)
print,'sum range= ',c-range,c+range
off=float(total(dat(c-range:c+range)))
eroff=sqrt(off)/off
print,'sum range= ',c-range,c+range
print,'total rate =',total(float(dat))/float(count)
print,'box counts =',off, '+/- ',eroff*off

ratio=off/on

error=ratio*sqrt(eron^2+eroff^2)

print,'Flipping ratio =',ratio,' +/- ',error

end

;information file on how to enter data is tofinfo.inf
; pro tof    ;;;look for the main program at the bottom!!

;====================================================================================================
; This function takes a string as input an extracts the numors an returns an array of numors. Errors
; are signalled by the flag 'eflag': If this is 0 no error has occured, If it is 1 an error occured.
; The string should be formatted as follows: Individual numors should be punctuated by a plus sign (+)
; ranges of numors can be specified by the min/max numors separated by a comma.
; e.g. 1+5+10,13+20 gives the array of numors: [1,5,10,11,12,13,20]
;====================================================================================================
function getnumors,intlist

; Common block for error flag
common EFLAGS,eflag
	
; array to store numors
	numors=lonarr(1000)
; integer of numor counts
	numor_index=0
	
;convert string to bytes, removing all whitespace add 0 'terminator'
	numlist=[byte(strcompress(intlist,/REMOVE_ALL)),0B]
;index of numlist
	string_index=0
; temporary storage space for an integer of up to 6 digits
	thisnum=bytarr(6)
; index for thisnum-counts number of digits in number	
	count=0
; If true (1) this varaible indicates that the last punctuation was a comma
	comma=0
	
;----------------------------------------------------
; Main loop - loops over string (numlist). Terminates
; when 0 (null) terminator is encountered	
	repeat begin

; read in character
		temp=numlist[string_index]
; increment string index
		string_index=string_index+1
		
; Case block: determines character. If a digit is encountered then it is stored
; in a temporary array until punctuation is encountered. IF a plus is encountered
; then this numor is stored in the list of numors array. If a comma is encountered
; then the number is stored temporarily until the next number (and the following plus
; or terminator) is read, when a range of numors is generated
		case 1 of

;>>>>>>>>> Case: Any ASCII digit: '0' through '9'
; insert digit into thisnum: temporary storage array
		(temp ge 48B) and (temp le 57B): begin	
; If number of digits exceeds 6 then signal numor too big error
			if count eq 6 then begin
				eflag=2
				return,0
			end
; if not then insert digit
			thisnum[count]=temp
; increment counter
			count=count+1
		end
				
;>>>>>>>> Case: '+' or null terminator
; In this case add the previous numor to the list of numors
; or, if there was a comma, add a numor range
		(temp eq 43B) or (temp eq 0B): begin
; If count(=number of digits) is zero then there is no number between punctuation!
			if count eq 0 then begin
; Allow for empty strings -ie only terminator. In which case return special error.
				if (temp eq 0B) and (numor_index eq 0) then begin 
					eflag=4
					return,0
				endif else begin
; otherwise, bog standard formatting cock-up (error 1)
					eflag=1
					return,0
				end
			end
			
; Convert digits stored in thisnum to intger
			rend=long(string(thisnum))

; if value of numor is zero ('0') then signal error
			if rend eq 0 then begin
				eflag=2
				return,0
			end

; If the last punctuation was a comma, then insert a range into the numors array
		if comma then begin
; if end of range is less than beginning then signal error
			if rend lt rbegin then begin
				eflag=5
				return,0
			end
; Put series of integers from rbegin (first numor) to rend (last numor)
			numors[numor_index:(numor_index+rend-rbegin)]=indgen(rend-rbegin+1)+rbegin
; update the numor counter appropriately
			numor_index=numor_index+rend-rbegin+1
; reset comma to false
			comma=0
; reset digit counter
			count=0
; flush string
			thisnum[*]=0
; If no comma then simply insert single numor into array
		endif else begin
			numors[numor_index]=rend
; increment numor index
			numor_index=numor_index+1
; reset counter for next numor
			count=0	
; fluch string
			thisnum[*]=0
			end
		end
		
;>>>>>>>>>> Case: comma ','
		temp eq 44B: begin
; If comma flag is already true (1) then signal formatting error
; (two commas in a row)
		if comma then begin
			eflag=1
			return,0
		end
; otherwise set comma flag to true (1)
		comma=1
; If count(=number of digits) is zero then there is no number
			if count eq 0 then begin
				eflag=1
				return,0
			end
		
; store thisnum (byte array of digits) into 'start of numor range' variable for later use
			rbegin=long(string(thisnum))
; reset digit count
			count=0
; flush string
			thisnum[*]=0
; if value of numor is zero ('0') then signal error
			if rbegin eq 0 then begin
				eflag=2
				return,0
			end
		end
		
; >>>>>>>>>> Case: Illegal character, send error message
		else: begin
			eflag=3
			return,0
		end
		endcase
; Loop back to top unless the terminator is encountered
	endrep until temp eq 0
	
; If we've got this far without returning then there's no error
	eflag=0
; return an array with the numors in
	return,numors[0	:numor_index-1]
end

;********************************************************************************
;converts text widgit strings to appropriate type and checks for errors
;defaults=0,1 according to whether 'def' was entered
;intcheck=0,1 according to whether an integer is expected
;commacheck=0,1,2 according to whether a comma is expected (2=either)
;strcheck=0,1 according to whether a string is expectec
;errcheck1=0 (false),1 (true) according to whether two numbers (ie a range of
; numors) is expected as opposed to just a single number
;errcheck2=0 (false),1 (true) according to whether the field must be completed 
; in order for the calculations to be done.

function convert,txtwid,defaults,intcheck,commacheck,strcheck,errcheck1,errcheck2
common par,par2
common var0,def
common varflag,flag0,flag1,flag2,flag3,flag4,flag5

; parameter to return is an array of 3 strings (possibly to be an array of 3 integers/floats)
valnum=strarr(3)

widget_control,txtwid,get_value=val

valstr=val(0)

valstr=strcompress(valstr,/remove_all)

;signal error flag if a 'def' is given but defaults aren't allowed
if (defaults eq 0) and (valstr eq def) then flag5=1
; if default is set then set valnum (return array) to 1	
if valstr eq def then valnum(0)=1 else $
; else if string_check is true (1) then set the return varaible to the string (valstr)
; NB: Isn't the expression (valstr ne def) redundant since it's already checked as a condition
; to get here, i.e. "if valstr eq def" above
if (valstr ne def) and (strcheck eq 1) then valnum(1)=valstr else begin
; If we're not looking for a string then do the other checks

; look for the position of THE comma
	commapos=strpos(valstr,',')

	if commapos eq -1 then begin
; If there are no commas, but a comma is required then flag an error
		if commacheck eq 1 then flag4=1

; convert the string (which should be a single number, no commas) into a float and
; an integer
		valflt=float(valstr)
		valint=fix(valstr)

; compare the string representation of the converted number. If this is not equal
; to the original string an error has occured 	
		if strpos(string(valflt),valstr) eq -1 then flag2=1
		
; if intcheck=1 (true) and the floating version isn't the same as the integer
; then its not an integer-> signal error flag
		if (intcheck eq 1) and (valint ne valflt) then flag3=1


; If an integer is required return the integer 
		if (intcheck eq 1) and (errcheck1 eq 1) then valnum=[0,valint,0]
; If an integer isn't required then return the floating point
		if (intcheck eq 0) and (errcheck1 eq 1) then valnum=[0,valflt,valflt]
; no range needed
		if (intcheck eq 0) and (errcheck1 eq 0) then valnum(1)=valflt
		if (intcheck eq 1) and (errcheck1 eq 0) then valnum(1)=valint

	endif else begin
; Commas have been found:

; If the comma occupies the first character then user has been painfully stupid.	
		if commacheck eq 0 then flag2=1

; sets valstr (a 3 string array) to: '0', the string between the first character and the comma, the
; string between after the comma and the end.
		valstr=['0',strmid(valstr,0,commapos),strmid(valstr,commapos+1)]

; make arrays of float and integers containing the respective versions of valstr.
		valflt=float(valstr)
		valint=fix(valstr)
	
; check the string versions of the float to the original string. If they aren't equal the user has not 
; entered a number. signal 'Not a number error'
		if (strpos(string(valflt(1)),valstr(1)) eq -1) or (strpos(string(valflt(2)),valstr(2)) eq -1) then flag2=1
; if intcheck=1 (true) and the integers aren't equal to the floats then they aren't integers. Signal 'not int' error
		if (intcheck eq 1) and ((valint(1) ne valflt(1)) or (valint(2) ne valflt(2))) then flag3=1
; If intcheck=1 (true) then return the integers, otherwise return the floats
		if intcheck eq 1 then valnum=valint else valnum=valflt

	endelse

; If errcheck=1 (true) then a range (two numbers) rather than a single number is required.
; This checks to ensure that the first number is smaller than the second, otherwise the
; range is invalid.
; Note the fudge: The range check is not required if integers are being read. This is for the 
; background shift/width which isn't a range. Numor (which are integer) ranges are dealt with by
; another procedure "getnumors"
	if (errcheck1 eq 1) and (intcheck eq 0) then begin

		if valnum(1) gt valnum(2) then flag0=1

	endif

; If errorcheck2=1 (true) then the field must contain a non-zero number. This is the case
; for Direct beam (1), Reflect (1), water, lambda, theta (1) and fac (1). Things like 
; Direct beam (2) are optional and only need to be specified if there is more than one 
; angle of reflection.
	if errcheck2 eq 1 then begin

		if valnum(1) eq 0 then flag1=1

	endif

endelse	

; returns result.
return,valnum

end


;*******************************************************************************************
;calculates factor by which to multiply refb so as to match refa

function factor,refa,refb,qa,qb,errora,errorb

common varbwid,base

xa=qa(sort(qa))
xb=qb(sort(qb))
ya=refa(sort(qa))
yb=refb(sort(qb))
errora=errora(sort(qa))
errorb=errorb(sort(qb))

xaovsub=where(xa ge min(xb))

range=max(xaovsub)-min(xaovsub)

xaov=xa(min(xaovsub):max(xaovsub))

dataa=ya(min(xaovsub):max(xaovsub))
erra=errora(min(xaovsub):max(xaovsub))

datab=fltarr(range)
err2=fltarr(range)
errb=fltarr(range)

numersum=0
denomsum=0

catch,errstat
if errstat ne 0 then begin
	eflag=8
	errormessage,'Incompatible data: check run set order'
	catch,/cancel
endif

for i=1,range-1 do begin
		
	pntabsub=min(where(xb ge xaov(i)))
	pntab=xb(pntabsub)
	databab=yb(pntabsub)
	errbab=errorb(pntabsub)
	pntbesub=max(where(xb lt xaov(i)))
	pntbe=xb(pntbesub)
	databbe=yb(pntbesub)
	errbbe=errorb(pntbesub)
	
	databdiff=databbe-databab

datab(i)=(((pntab-xaov(i))/databdiff)*databbe)+(((xaov(i)-pntbe)/databdiff)*databab)
		errb(i)=sqrt((((pntab-xaov(i))/databdiff)*errbbe)^2+(((xaov(i)-pntbe)/databdiff)*errbab)^2)
	
	if pntab-xaov(i) le xaov(i)-pntbe then begin
		datab(i)=yb(pntabsub)
		errb(i)=errorb(pntabsub)
	endif else begin
		datab(i)=yb(pntbesub)
		errb(i)=errorb(pntbesub)
	endelse
	
	if (dataa(i) gt 1.e-11) and (datab(i) gt 1.e-11) and (erra(i) gt 0.) and (errb(i) gt 0.) then err2(i)=(erra(i)+errb(i))*(erra(i)+errb(i)) else err2(i)=1.e20

	numer=(1/err2(i))*dataa(i)*datab(i)

	denom=(1/err2(i))*datab(i)*datab(i)

	numersum=numersum+numer
	denomsum=denomsum+denom

endfor

catch,/cancel

fac=numersum/denomsum
return,fac

end


;***************************************************************************************************************
;deals with events from TOF window ('pro tof')

pro tof_event,event
common par,par2
common var0,def
common varwid,lab,txt,but,gap
common varbwid,base
common varflag,flag0,flag1,flag2,flag3,flag4,flag5
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3
common varset,norm,bg,r,fil
common varbg,bgrd
common varpath,path

; common block containing the time->lambda conversion array so it can be output
; to a file for each run
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3

; common block for useful xrange of detector and area to find peak in
common detranges,useful,peak_searchx,peak_searchy

; Error flag.
common EFLAGS,eflag

;takes the user value of the widget that cause the event and puts it equal to ev
widget_control,event.id,get_uvalue=ev

;closes all windows if 'quit' is pressed
if ev eq 'quit' then widget_control,base,/destroy

;begins anal2ysis of data if 'done' is pressed
if ev eq 'done' then begin

;flag*=error flags (0=no error, 1=error)
	flag0=0	
	flag1=0	
	flag2=0
	flag3=0
	flag4=0
	flag5=0
	flag6=0

;check*=flag for which run sets were used
	check0=0
	check1=0

;----*----*----*----*----*----*----*----*----*----*----*----*----*----*----
; Lots of repetative code to read in numors and output appropriate errors.
; (Should really be made a little more succinct by making a procedure
;----*----*----*----*----*----*----*----*----*----*----*----*----*----*----

; Read run 3 direct beam----------------------------
	widget_control,txt(2),get_value=val
	dtb3=getnumors(val(0))
; If eflag (error flag) is not zero or 4 (=empty array) then signal error
; empty arrays are allowed for runs 2 and 3 so long as both db and ref are empty
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Direct beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Direct beam'
		return
	end
		
; Read run 3 reflected beam-----------------------
	widget_control,txt(7),get_value=val
	refl3=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Reflected beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Reflected beam'
		return
	end
		
; If only 1 field is entered then signal error
	if ((dtb3[0] eq 0) and (refl3[0] ne 0)) or ((dtb3[0] ne 0) and (refl3[0] eq 0)) then begin 
	errormessage,'Incomplete fields:Run 3 (Enter both DB and REF or neither).'
	return
	end
	
; Read run 2 direct beam-------------------------
	widget_control,txt(1),get_value=val
	dtb2=getnumors(val(0))
; errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Direct beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Direct beam'
		return
	end
		
; Read run 2 reflected beam---------------------
	widget_control,txt(6),get_value=val
	refl2=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Reflected beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Reflected beam'
		return
	end
		
; If only 1 field is entered then signal error
	if ((dtb2[0] eq 0) and (refl2[0] ne 0)) or ((dtb2[0] ne 0) and (refl2[0] eq 0)) then begin 
	errormessage,'Incomplete fields:Run 2 (Enter both DB and REF or neither).'
	return
	end
	
; Read run 1 direct beam-----------------------
	widget_control,txt(0),get_value=val
	dtb1=getnumors(val(0))
; errors: note that eflag=4 (=no numors) is an error for run 1
	if eflag ne 0 then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Direct beam'
		if eflag eq 4 then errormessage,'Missing direct beam numors: Run 1'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Direct beam'
		return
	end
		
; Read run 1 reflected beam
	widget_control,txt(5),get_value=val
	refl1=getnumors(val(0))
; errors: note that eflag=4 (=no numors) is an error for run 1
	if eflag ne 0 then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Reflected beam'
		if eflag eq 4 then errormessage,'Missing reflected beam numors: Run 1'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Reflected beam'
		return
	end

; Read run 1 Instrument background
	widget_control,txt(10),get_value=val
	instbg1=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Instrument background'
		return
	end
	
; Read run 2 Instrument background
	widget_control,txt(11),get_value=val
	instbg2=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Instrument background'
		return
	end
; return error if Inst. BG set, but no direct beam/reflect runs set
	if (instbg2[0] ne 0) and (refl2[0] eq 0) then begin
		errormessage,'Inst. BG set but Direct beam/Reflected beam numors missing: Run 2.'
		return
	end
	
; Read run 3 Instrument background
	widget_control,txt(12),get_value=val
	instbg3=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Instrument background'
		return
	end
; return error if Inst. BG set, but no direct beam/reflect runs set
	if (instbg3[0] ne 0) and (refl3[0] eq 0) then begin
		errormessage,'Inst. BG set but Direct beam/Reflected beam numors missing: Run 3.'
		return
	end	
; read water files
	widget_control,txt(3),get_value=val
; If 'def' is entered then set water=0 so that water file reading code knows to look
; for the default file
	if val[0] eq 'def' then water=0 else begin
		water=getnumors(val[0])
; errors: note that eflag=4 (=no numors) just means use default (signalled by 1st element of array 'water'
; being zero)
		if (eflag ne 0) and (eflag ne 4) then begin
			if eflag eq 1 then errormessage,'Illegal formatting:Water files'
			if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Water files'
			if eflag eq 3 then errormessage,'Illegal character:Water files'
			if eflag eq 5 then errormessage,'Invalid range (end<beginning): Water files'
		return
		end
	endelse
		
	lamda=convert(txt(4),1,0,2,0,1,1)

	path=convert(txt(8),0,0,0,1,0,0)
	
	fil=convert(txt(9),0,0,0,1,0,0)
	
	th1=convert(txt(19),1,0,0,0,0,0)
	th2=convert(txt(20),1,0,0,0,0,0)
	th3=convert(txt(21),1,0,0,0,0,0)
	
	r=convert(txt(13),0,1,0,0,0,0)
; check that foreground width isn't negative
	if r[1] lt 0 then begin
		errormessage,'Negative foreground width!'
		return
	end
	
;*******************************
; Quick sloppy fix coming up...
;*******************************

; convert returns either a single integer, or if a comma is supplied a 3 (for some reason...) array
; with the second and third elements containing the first (width) and second (shift) integers.
; Convert should really return a structure!!
	leftbg=convert(txt(14),0,1,2,0,1,0)
; Code below strips the leading 0 for a 3-array
	leftbg=[leftbg[1],leftbg[2]]
; Unfortunately have to do same sloppy manipulation for right hand side
	rightbg=convert(txt(18),0,1,2,0,1,0)
	rightbg=[rightbg[1],rightbg[2]]
; Now have two background arrays :leftbg[width,shift] rightbg[width,shift]. Concatenate
; these as single bg array to pass to anal2ysis
	bg=[leftbg,rightbg]
; bg[leftwidth,leftshift,rightwidth,rightshift]
; Yeuch.... that was messy

; check that all background shifts/widths to left and right are positive
	if (bg[0] lt 0) or (bg[1] lt 0) or (bg[2] lt 0) or (bg[3] lt 0) then begin
		errormessage,'Negative background width/shift!'
		return
	end
; Now do same for useful area of detector and peak search area:
	useful=convert(txt(22),0,1,2,0,1,0)
	useful=[useful[1],useful[2]]
	if (useful[0] lt 0) or (useful[1] gt 286) then begin
		errormessage,'Useful area of detector outside of physical size (0,286) of detector!'
		return
	end
	peak_searchx=convert(txt(23),0,1,2,0,1,0)
	peak_searchx=[peak_searchx[1],peak_searchx[2]]

	if (peak_searchx[0] lt useful[0]) or (peak_searchx[1] gt useful[1]) then begin
		errormessage,'Peak search x range is outside useful area of detector'
		return
	end

; if y range is set to "def" then set the range to -1,-1 so that the correct
; default range can be put in when the numors are read and their size is known
	widget_control,txt(24),get_value=temp
	if temp[0] EQ 'def' then peak_searchy=[-1,-1] else begin
		peak_searchy=convert(txt(24),0,1,2,0,1,0)
		peak_searchy=[peak_searchy[1],peak_searchy[2]]
		if (peak_searchy[0] lt 0) or (peak_searchy[1] gt 500) then begin
			errormessage,'Peak search y is outside y range (0,500)'
			return
		end
	end
	


	fac1=convert(txt(15),1,0,0,0,0,0)
	fac2=convert(txt(16),1,0,0,0,0,0)
	fac3=convert(txt(17),1,0,0,0,0,0)

;sets variable to the value of button widget in TOF window 
	widget_control,but(0),get_value=norm
	widget_control,but(1),get_value=bgrd


;if any errors in datat then appropriate message is displayed by calling 'pro errormessage'
	if flag0 eq 1 then errormessage,'Invalid ranges'
	if flag1 eq 1 then errormessage,'Incomplete fields'	
	if flag2 eq 1 then errormessage,'Field must be a number'	
	if flag3 eq 1 then errormessage,'Field must be integer'	
	if flag4 eq 1 then errormessage,'Comma expected'	
	if flag5 eq 1 then errormessage,'Default not available'	
	if flag6 eq 1 then errormessage,'Must complete all fields for given run set'	

;if there are no errors then proceed with anal2ysis
	if (flag0 eq 0) and (flag1 eq 0) and (flag2 eq 0) and (flag3 eq 0) and (flag4 eq 0) and (flag5 eq 0) and (flag6 eq 0) then begin

;renders TOF window insensitive
		widget_control,base,sensitive=0
		close,10

; write contents of text widgets (which have been checked above) into the default file tof_defaults.dat
		openw,10,'tof_defaults.dat'
		printf,10,'Direct beam runs (1)'
		widget_control,txt(0),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Direct beam runs (2)'
		widget_control,txt(1),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Direct beam runs (3)'
		widget_control,txt(2),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (1)'
		widget_control,txt(5),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (2)'
		widget_control,txt(6),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (3)'
		widget_control,txt(7),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (1)'
		widget_control,txt(10),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (2)'
		widget_control,txt(11),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (3)'
		widget_control,txt(12),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Water (Efficiency) file'
		widget_control,txt(3),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Wavelength range'
		widget_control,txt(4),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (1)'
		widget_control,txt(19),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (2)'
		widget_control,txt(20),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (3)'
		widget_control,txt(21),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (1)'
		widget_control,txt(15),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (2)'
		widget_control,txt(16),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (3)'
		widget_control,txt(17),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Foreground range'
		widget_control,txt(13),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Left Background range'
		widget_control,txt(14),get_value=tempstring
		printf,10,tempstring		
		printf,10,'Right Background range'
		widget_control,txt(18),get_value=tempstring
		printf,10,tempstring
		printf,10,'Normalisation method'
		printf,10,norm
		printf,10,'Method to determine background'
		printf,10,bgrd
		printf,10,'Output filename'
		widget_control,txt(9),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Data Path'
		widget_control,txt(8),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Useful x range on detector'
		widget_control,txt(22),get_value=tempstring		
		printf,10,tempstring
		printf,10,'X range to find peak in'
		widget_control,txt(23),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Y range to find peak in'
		widget_control,txt(24),get_value=tempstring		
		printf,10,tempstring
		close,10
;if default was selected then use default water file, 'water_LAMPascii'
		if water[0] eq 0 then begin
		
			print,' '
			print,' '
			print,'Reading default Water file, ''water_LAMPascii''...'
			w3=make_array(3,286,type=4)

;check default file exists
			filcheck=findfile('water_LAMPascii',count=checkfil)
			if checkfil eq 0 then begin 
; Default water file does not exist
				print,'Default water file water_LAMPascii does not exist. No water correction!'
				w2=make_array(1,286,type=4)
				w2[*]=1.0
			endif else begin

			close,4
			openr,4,"water_LAMPascii"
     			readf,4,w3
;makes it 1-D array
			w2=w3(1,*)
			close,4
;			print,'min water=',min(w2),'max water= ',max(w2)
			end
		endif else begin
;otherwise call 'pro data_read2' to read water files entered
			print,' '
			print,' '
			print,'Reading Water files...'
			watersum=0
;loop data_read2 for each file and sum detector counts (water)

			for i=0,N_ELEMENTS(water)-1 do begin
				data_read2,water[i],wat
			; return if an error occured during reading
				if eflag ne 0 then return
				watersum=wat+watersum
			endfor
;call 'pro awater' to set the size of the array corresponding to the useful size of the detector
			awater,watersum,w2
		endelse
				
;run set (1) 
		print,' '
		print,' '
		print,'Reading data files for set (1)...'

;form summed direct beam array
		print,' '
		print,'for direct beam...'
		db1sum=0
		db1monsum=0
		db1timesum=0
;loop data_read2 for each file and sum detector counts (db*), monitor counts (db*mon) and runtime (db*time) also take detector angle (dbdan*)
		for i=0,N_ELEMENTS(dtb1)-1 do begin
			data_read2,dtb1[i],db1,db1mon,db1time,dbdan1
		; return if an error occured during reading
			if eflag ne 0 then return
			db1sum=db1+db1sum
			db1monsum=db1mon+db1monsum
			db1timesum=db1time+db1timesum
		endfor

;create error array for summed detector counts
		erdb1=sqrt(db1sum)

; output the time-> lambda conversion array
	CLOSE,10
	OPENW,10,'a1_lambda_convert.dat'
	PRINTF,10,'Pixel,   Wavelength (Angstroms)'
	FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
	CLOSE,10
		
;form summed reflected beam array
		print,' '
		print,'for reflected beam...'
		ref1sum=0
		ref1monsum=0
		ref1timesum=0
; store SAN angles into an array for comparison with calculated value
		san=fltarr(N_ELEMENTS(refl1))
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
		for i=0,N_ELEMENTS(refl1)-1 do begin
			data_read2,refl1[i],ref1,ref1mon,ref1time,refdan1
; store SAN (par2[2]) into sans array
			san[i]=par2[2]
		; return if an error occured during reading
			if eflag ne 0 then return
			ref1sum=ref1+ref1sum
			ref1monsum=ref1mon+ref1monsum
			ref1timesum=ref1time+ref1timesum
		endfor
;create error array for summed detector counts
		erref1=sqrt(ref1sum)

; If ther are instrument backgrounds to be subtracted then read and sum these
		if instbg1[0] ne 0 then begin
;form summed reflected beam array
		print,' '
		print,'for Instrument background...'
		instbg1sum=0
		instbg1monsum=0
		instbg1timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
		for i=0,N_ELEMENTS(instbg1)-1 do begin
			print,instbg1
			data_read2,instbg1[i],instbgd1,instbg1mon,instbg1time,instbgdan1
	; return if an error occured during reading
			if eflag ne 0 then return
			instbg1sum=instbgd1+instbg1sum
			instbg1monsum=instbg1mon+instbg1monsum
			instbg1timesum=instbg1time+instbg1timesum
		endfor
;create error array for summed detector counts
		erinstbg1=sqrt(instbg1sum)
		end

; NORMALISE REFLECTED AND BACKGROUND RUNS TO THE DIRECT BEAM
		print,'Normalising....'		
;(norm=0) normalise summed reflected beam (normref*sum) to runtime 
		if norm eq 0 then begin
			normref1sum=ref1sum*(db1timesum/ref1timesum)
			normerref1sum=(db1timesum/ref1timesum)*erref1
; do same for Instrument backgrounds if they are present
			if instbg1[0] ne 0 then begin
				norminstbg1sum=instbg1sum*(db1timesum/instbg1timesum)
				normerinstbg1sum=(db1timesum/instbg1timesum)*erinstbg1
			end
		endif
;(norm=1) normalise summed reflected beam (normref*sum) to monitor 
		if norm eq 1 then begin
			normref1sum=ref1sum*(db1monsum/ref1monsum)
			normerref1sum=(db1monsum/ref1monsum)*erref1
; do same for Instrument backgrounds if they are present
			if instbg1[0] ne 0 then begin
				norminstbg1sum=instbg1sum*(db1monsum/instbg1monsum)
				normerinstbg1sum=(db1monsum/instbg1monsum)*erinstbg1
			end
		endif

; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg1[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref1sum=normref1sum-norminstbg1sum
			normerref1sum=sqrt(normerref1sum^2+normerinstbg1sum^2)
			db1sum=db1sum-norminstbg1sum
			erdb1=sqrt(erdb1^2+normerinstbg1sum^2)
		end
		
		print,' '
		print,' '
		print,'anal2ysing data files for set (1)...'

;call 'pro anal2' to create Reflectivity data
;returns w*=Reflectivity, x*=q, e*=Reflectivity error, qe*=q resolution
		anal2,db1sum,erdb1,dbdan1,normref1sum,normerref1sum,refdan1,w2,r(1),bg,w5,x5,e5,qe5,lamda,th1	
; if an error was signalled then restart
		if eflag ne 0 then return
;if default factor was selected then use fac1=1
		if fac1(0) eq 1 then fac1(1)=1.

;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th1[1] gt 0.1) or (san[i]-th1[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 1:Difference between calculated theta and SAN of numor '+strtrim(string(refl1[i]),2)+' is greater than 0.1'
			end
		endfor
		
		print,' '
		print,'...done set (1)'

;multiply Ref and Referr by fac
		w5=fac1(1)*w5
		e5=fac1(1)*e5

;find number of points
		z5=size(e5)

;sort data in order of increasing q and call arrays *s
		xs=x5(sort(x5))
		ws=w5(sort(x5))
		es=e5(sort(x5))
		qes=qe5(sort(x5))

;if 2 run sets were entered then 1st element of dtb2 is not zero
		if dtb2[0] ne 0 then begin

;run set (2) 
			print,' '
			print,' '
			print,'Reading data files for set (2)...'
				
			print,' '
			print,'for direct beam...'
			db2sum=0
			db2monsum=0
			db2timesum=0
			for i=0,N_ELEMENTS(dtb2)-1 do begin
				data_read2,dtb2[i],db2,db2mon,db2time,dbdan2
			; return if an error occured during reading
				if eflag ne 0 then return
				db2sum=db2+db2sum
				db2monsum=db2mon+db2monsum
				db2timesum=db2time+db2timesum
			endfor
			erdb2=sqrt(db2sum)

; output the time-> lambda conversion array
		CLOSE,10
		OPENW,10,'a2_lambda_convert.dat'
		PRINTF,10,'Pixel,   Wavelength (Angstroms)'
		FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
		CLOSE,10

			print,' '
			print,'for reflected beam...'
			ref2sum=0
			ref2monsum=0
			ref2timesum=0
			
			san=fltarr(N_ELEMENTS(refl2))
			for i=0,N_ELEMENTS(refl2)-1 do begin
				data_read2,refl2[i],ref2,ref2mon,ref2time,refdan2
				san[i]=par2[2]
			; return if an error occured during reading
				if eflag ne 0 then return
				ref2sum=ref2+ref2sum
				ref2monsum=ref2mon+ref2monsum
				ref2timesum=ref2time+ref2timesum
			endfor
			erref2=sqrt(ref2sum)
			
; If ther are instrument backgrounds to be subtracted then read and sum these
			if instbg2[0] ne 0 then begin
;form summed reflected beam array
			print,' '
			print,'for Instrument background...'
			instbg2sum=0
			instbg2monsum=0
			instbg2timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
			for i=0,N_ELEMENTS(instbg2)-1 do begin
				data_read2,instbg2[i],instbgd2,instbg2mon,instbg2time,instbgdan2
			; return if an error occured during reading
				if eflag ne 0 then return
				instbg2sum=instbgd2+instbg2sum
				instbg2monsum=instbg2mon+instbg2monsum
				instbg2timesum=instbg2time+instbg2timesum
			endfor
;create error array for summed detector counts
			erinstbg2=sqrt(instbg2sum)
			end

			print,'Normalising....'
			if norm eq 0 then begin
				normref2sum=ref2sum*(db2timesum/ref2timesum)
				normerref2sum=(db2timesum/ref2timesum)*erref2
; do same for Instrument backgrounds if they are present
				if instbg2[0] ne 0 then begin
					norminstbg2sum=instbg2sum*(db2timesum/instbg2timesum)
					normerinstbg2sum=(db2timesum/instbg2timesum)*erinstbg2
				end
			endif
			if norm eq 1 then begin
				normref2sum=ref2sum*(db2monsum/ref2monsum)
				normerref2sum=(db2monsum/ref2monsum)*erref2
; do same for Instrument backgrounds if they are present
				if instbg2[0] ne 0 then begin
					norminstbg2sum=instbg2sum*(db2monsum/instbg2monsum)
					normerinstbg2sum=(db2monsum/instbg2monsum)*erinstbg2
				end
			endif	
			
; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg2[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref2sum=normref2sum-norminstbg2sum
			normerref2sum=sqrt(normerref2sum^2+normerinstbg2sum^2)
			db2sum=db2sum-norminstbg2sum
			erdb2=sqrt(erdb2^2+normerinstbg2sum^2)
		end

			print,' '
			print,' '
			print,'anal2ysing data files for set (2)...'

			anal2,db2sum,erdb2,dbdan2,normref2sum,normerref2sum,refdan2,w2,r(1),bg,w6,x6,e6,qe6,lamda,th2
; if an error was signalled then restart
			if eflag ne 0 then return

;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th2[1] gt 0.1) or (san[i]-th2[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 2:Difference between calculated theta and SAN of numor '+strtrim(string(refl2[i]),2)+' is greater than 0.1'
			end
		endfor
			
;if default factor was selected then call 'function factor' to match the Reflectivity curve from set (2) to that of set (1)
			if fac2(0) eq 1 then fac2(1)=factor(w5,w6,x5,x6,e5,e6)
;fac*=0 implies no overlap between the Ref curves
			if fac2(1) eq 0. then begin
				print,' '
				print,'No Overlap between (1) & (2)'
			endif
				
			print,' '
			print,'...done set (2)'

			w6=fac2(1)*w6
			e6=fac2(1)*e6
			z6=size(e6)

;create single arrays combining set (1) and (2) for Ref,q,Referr,qres
			x=fltarr(z5(1)+z6(1))
			w=fltarr(z5(1)+z6(1))
			e=fltarr(z5(1)+z6(1))
			qe=fltarr(z5(1)+z6(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			
			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))
			
		endif
			
;if 3 run sets were entered then 1st element of dtb3 is not 0
		if dtb3[0] ne 0 then begin

;run set (3) 
			print,' '
			print,' '
			print,'Reading data files for set (3)...'

			print,' '
			print,'for direct beam...'
			db3sum=0
			db3monsum=0
			db3timesum=0
			for i=0,N_ELEMENTS(dtb3)-1 do begin
				data_read2,dtb3[i],dbd3,db3mon,db3time,dbdan3
			; return if an error occured during reading
				if eflag ne 0 then return
				db3sum=dbd3+db3sum
				db3monsum=db3mon+db3monsum
				db3timesum=db3time+db3timesum
			endfor
			erdb3=sqrt(db3sum)

; output the time-> lambda conversion array
			CLOSE,10
			OPENW,10,'a3_lambda_convert.dat'
			PRINTF,10,'Pixel,   Wavelength (Angstroms)'
			FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
			CLOSE,10

			print,' '
			print,'for reflected beam...'
			ref3sum=0
			ref3monsum=0
			ref3timesum=0
			
			san=fltarr(N_ELEMENTS(refl3))
			for i=0,N_ELEMENTS(refl3)-1 do begin
				data_read2,refl3[i],ref3,ref3mon,ref3time,refdan3
				san[i]=par2[2]
			; return if an error occured during reading
				if eflag ne 0 then return
				ref3sum=ref3+ref3sum
				ref3monsum=ref3mon+ref3monsum
				ref3timesum=ref3time+ref3timesum
			endfor
			erref3=sqrt(ref3sum)
			
; If ther are instrument backgrounds to be subtracted then read and sum these
			if instbg3[0] ne 0 then begin
;form summed reflected beam array
			print,' '
			print,'for Instrument background...'
			instbg3sum=0
			instbg3monsum=0
			instbg3timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
			for i=0,N_ELEMENTS(instbg3)-1 do begin
				data_read2,instbg3[i],instbgd3,instbg3mon,instbg3time,instbgdan3
			; return if an error occured during reading
				if eflag ne 0 then return
				instbg3sum=instbgd3+instbg3sum
				instbg3monsum=instbg3mon+instbg3monsum
				instbg3timesum=instbg3time+instbg3timesum
			endfor
;create error array for summed detector counts
			erinstbg3=sqrt(instbg3sum)
			end

			print,'Normalising....'

			if norm eq 0 then begin
				normref3sum=ref3sum*(db3timesum/ref3timesum)
				normerref3sum=(db3timesum/ref3timesum)*erref3
; do same for Instrument backgrounds if they are present
				if instbg3[0] ne 0 then begin
					norminstbg3sum=instbg3sum*(db3timesum/instbg3timesum)
					normerinstbg3sum=(db3timesum/instbg3timesum)*erinstbg3
				end

			endif
			if norm eq 1 then begin
				normref3sum=ref3sum*(db3monsum/ref3monsum)
				normerref3sum=(db3monsum/ref3monsum)*erref3
; do same for Instrument backgrounds if they are present
				if instbg3[0] ne 0 then begin
					norminstbg3sum=instbg3sum*(db3monsum/instbg3monsum)
					normerinstbg3sum=(db3monsum/instbg3monsum)*erinstbg3
				end

			endif
			
; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg3[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref3sum=normref3sum-norminstbg3sum
			normerref3sum=sqrt(normerref3sum^2+normerinstbg3sum^2)
			db3sum=db3sum-norminstbg3sum
			erdb3=sqrt(erdb3^2+normerinstbg3sum^2)
		end

			print,' '
			print,' '
			print,'anal2ysing data files for set (3)...'

			anal2,db3sum,erdb3,dbdan3,normref3sum,normerref3sum,refdan3,w2,r(1),bg,w7,x7,e7,qe7,lamda,th3
; if an error was signalled then restart
			if eflag ne 0 then return
			
;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th3[1] gt 0.1) or (san[i]-th3[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 3:Difference between calculated theta and SAN of numor '+strtrim(string(refl3[i]),2)+' is greater than 0.1'
			end
		endfor

;if default factor was selected then call 'function factor' to match the Reflectivity curve from set (3) to that of set (2)
			if fac3(0) eq 1 then fac3(1)=factor(w6,w7,x6,x7,e6,e7)
			if fac3(1) eq 0. then begin
				print,' '
				print,'No Overlap between (2) & (3)'
			endif

			print,' '
			print,'...done set (3)'

			w7=fac3(1)*w7
			e7=fac3(1)*e7
			z7=size(e7)

			x=fltarr(z5(1)+z6(1)+z7(1))
			w=fltarr(z5(1)+z6(1)+z7(1))
			e=fltarr(z5(1)+z6(1)+z7(1))
			qe=fltarr(z5(1)+z6(1)+z7(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			for i=(z5(1)+z6(1)),(z5(1)+z6(1)+z7(1)-1) do begin
				x(i)=x7(i-z5(1)-z6(1))
				w(i)=w7(i-z5(1)-z6(1))
				e(i)=e7(i-z5(1)-z6(1))
				qe(i)=qe7(i-z5(1)-z6(1))
			endfor

			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))

		endif

;remove all bad points from the arrays and call arrays *c (corrected)
		ec=es(where(es))
		qec=qes(where(es))
		xc=xs(where(es))
		wc=ws(where(es))
		
;for the purposes of the output file: If default water file is specified then
; redefine water as a string containing the name of the default water file
		if water[0] eq 0 then water='water_LAMPascii'

;check that output file has a valid name
		catch,outfilcheck
		if outfilcheck ne 0 then begin
;set eflag to non-zero to signal error
			eflag=10
			errormessage,'Invalid output file name: '''+strcompress(string(fil(1)),/remove_all)+''''
			catch,/cancel
		endif

;print data info at top of output file
		close,10
		openw,10,fil(1),width=128
		printf,10,' db1:',dtb1
		printf,10,' ref1:',refl1,' th1:',th1(1),' fac1:',fac1(1)
; only print run 2 stuff if there actually is a run 2
		if dtb2[0] ne 0 then begin
			printf,10,' db2:',dtb2
			printf,10,' ref2:',refl2,' th2:',th2(1),' fac2:',fac2(1)
		end
; only print run3 stuff if there is a run 3
		if dtb3[0] ne 0 then begin
			printf,10,' db3:',dtb3
			printf,10,' ref3:',refl3,' th3:',th3(1),' fac3:',fac3(1)
		end
		printf,10,' water:',water,' lamda:',lamda(1),lamda(2),' fgrd:',r(1),' bgrd:',bg
		
 		close,10
		catch,/cancel
		
;run 'pro endmessage' giving the details of the calculated parameters
		endmessage

;run 'pro output' listing the arrays to the output file and plotting the full Reflectivity curve
		output,xc,wc,ec,qec,fil(1)

	endif		

endif

return

end



;************************************************************************************
;reads data for each file (num,int), gives det counts (w1), monitor counts (w2)
; runtime, detector angle (dan)

pro data_read2,num,w1,w2,runtime,dan


; takes a data numor and opens the file, reads paramter blocks and comes back with
; the lambda array for TOF (lamarr) the detector array (w1) the monitor array (w2)

common EFLAGS,eflag
common vars0,def
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3
common varpath,path
common par,par2

;reset error flag
eflag=0

close,3

; floating point arrays of 128 and 256 elements
par1 = fltarr(128)
par2 = fltarr(256)

; string array of 34 elements
txt=sindgen(34)
; set all 34 elements to XXX....
txt(*)='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
txt1=txt(1)

;converts num(int) to 6 digit string with trailing zeroes
name='000000'				;make six digit string of 0's
tempnum=strtrim(string(num),2)		;convert num to string and trim all blank spaces
strput,name,tempnum,6-strlen(tempnum)	;put these digits in occupying the last strlen(tempnum) places of name
name=path(1)+name			; include path in name

;check to see if numor exists
filcheck=findfile(name,count=checkfil)		
; If not signal error and return
if checkfil eq 0 then begin 
	eflag=7
	errormessage,'File not found: '+name
	return
end

; inform user of status and open file (handle=3)
openr,3,name
print,'opened: ',name

; read in 34 lines of text
readf,3,txt
; output 5th and 26th lines (text)
;print,txt(4)
;print,txt(25)

; read 128 floats (2nd block of numbers in file, 1st block is ignored by code above)
readf,3,par1
; read the two line spacer
readf,3,txt1
readf,3,txt1
;read 256 numbers 
readf,3,par2

; degrees per radian
dpr=180./!pi

;output useful information
;print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
;print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
nx=par1(101)

; print out chopper speeds and openings  nx and ny are the detector grouping factors
; ie base detector is 286*276 if nx=2 and ny=1 then detector is 144*276

;print,'nx= ',par1(101),' ny= ',par1(102)
;print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
;print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
;print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
;print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)

; useful chopper variables openr is the requested chopper opening and opena is the read back value
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))

;!chopper opening offset=1.02!
opena=opena-1.02

; chopper period in seconds
period=60./par2(44)

; chopper delay angle between pickup and centre of projected window
;dela=(284.3-opena)/2.
dela=(282.05-opena)/2.
; delt is the chopper delay time in seconds
delt=(dela/360.)*period

; cht is hardwired chopper separation in m
cht=85.e-3

; chopsam is the sample to mid-chopper distance in meters
chopsam=3.8675-(cht)/2.

; chopmon is the monitor to detector distance
chopmon=.455

; tofd is the time- of flight distance from mid-chopper to detector par2(15) is
; the sample to detector distance in mm
tofd=chopsam+(par2(15)/1000.)

;chanpa is the number of time channels per angstrom for the detector (neutron wavelength) 
chanpa=(tofd/3956.)/(par1(95)*1.e-6)

;chanpam is the number of time channels per angstrom for the monitor (neutron wavelength
chanpam=(chopmon/3956.)/(par1(95)*1.e-6)

; r is the time grouping factor between the monitor and the detector (not used at present
;as we measure the direct beam on the detector and use the monitor just for normalisation

r=chopsam/tofd

; chopper delay in time channels
delchan=delt/(par1(95)*1e-6)

; electronic delay (set by par tof in MAD) in channels
delechan=par1(96)/par1(95)

;printing out useful stuff
;print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
;print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
;print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
;print,'opening      req= ',openr,' opening      act= ',opena
;print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
;print,'     san= ',par2(2),' deg.'
;print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa

runtime=par1(2)/10.

;print,'run time= ',runtime,' s',' det= ',par2(15),'dan = ',par2(16)

;dan is the detector angle and dett is the sample-detector distance
dan=par2(16)
dett=par2(15)

; Now we can read the data -first read 3 spacer lines
readf,3,txt1
readf,3,txt1
readf,3,txt1

;read total number pixels in detector
readf,3,tot

;set size of arrays (usually in TOF ysize is 1 i.e we have xpxels*time channels only)
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize

;signal error if total number of pixels isn't equal to xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'

;print,'tsize= ',tsize,' detector size= ',dsize
;print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

;set up an array of long integers with specified size
det=lonarr(ysize,xsize,tsize)
; usually pixels are summed in physical y direction of detector-> only 2d
if (ysize eq 1) then det=lonarr(xsize,tsize)

; set up monitor arrray. Monitor is basically an extra line of pixels at the end
; of the data
mon=lonarr(tsize)

;2x2 arrays of data
xy=lonarr(xsize,ysize)
xt=lonarr(xsize,tsize)
yt=lonarr(ysize,tsize)

c=1

;read detector data and monitor data from file
readf,3,det

s2=par2(54)
s3=par2(50)

nx=par1(101)

;millimeters per pixel
mmpp=1.03567*nx

;useful area of det in pixels
xminp=16
xmaxp=255
; convert to useful area in mm
xminmm=xminp*mmpp
xmaxmm=xmaxp*mmpp


;make lamda array- conversion between time and wavelength
yy=findgen(tsize)		;generates  floating point array with sequence 0.0,1.0,2.0, e.t.c
lamarr=(yy+delechan-delchan+0.5)/chanpa

; convert data to floating point in w1
w1=float(det)
; add up total monitor counts
w2=par1(4)

close,3
; print total monitor counts and monitor counts per unit time
;print,'total counts in detector = ',total(w1),' (',total(w1)/runtime,')'

return

end


;*********************************************************************************************************
;sets water file (w1) to 1 outside useful area of det and returns w2

pro awater,w1,w2

xsize=286
w2=fltarr(xsize)

;useful area of det (x,y) 37:238,30:248
x1=20 & x2=255
w2=float(total(w1,2))

; normalise water
w2=w2/(mean(w2(x1:x2)))
; set anything outside usefule area to 1
w2(0:x1-1)=1. & w2(x2+1:xsize-1)=1.
;print,'Max water=',max(w2),'Min water=',min(w2)
return

end

;***************************************************************************************************
;calculates theta

function tth,d0,p0,dr,pr,nx,det

dpr=180./!pi

pcen=138.98/nx
mmpp=1.0357*nx

print,' '
print,'pcen= ',pcen
print,'mmpp= ',mmpp, 'dpr= ',dpr,' dr= ',dr,' pr= ',pr,' det= ',det,' d0= ',d0
print,'p0= ',p0

th=abs((dr+dpr*atan((pcen-pr)*mmpp/det))/2.-(d0+dpr*atan((pcen-p0)*mmpp/det))/2.)
print,'calculated theta= ',th


return,th

end


;********************************************************************************************
;anal2yses data, db=direct beam counts, dber=error on direct beam counts, dbdan=detector angle for direct beam, ref=reflected beam counts, refer=error on reflected beam counts, refdan=detector angle for reflected beam, water=detector counts for watef, r=forground range, bg=background range, wdum=Reflectivity, xdum=q, edum=Reflectivity error, qedum=q resolution, lamda=lamda range, th=theta

pro anal2,db,dber,dbdan,ref,refer,refdan,water,rr,bg,wdum,xdum,edum,qedum,lamda,th

wdum=0
xdum=0
edum=0
qedum=0

; Common block for error flag
common EFLAGS,eflag
common par,par2
common vars0,def
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3
common varbg,bgrd

; common block for useful xrange of detector and area to find peak in
common detranges,useful,peak_searchx,peak_searchy

; reset error flag: no errors
eflag=0

; db is the direct beam run
; ref is the reflection run
; water is the x effiency of the detector
; q is the array of q(A^-1)
; rr is the range over which to sum the intensity
; bg is the range to sum the background either side of r
; w5 is the output reflectivity with the q (x5) and error (e4)
; fac is the normalisation factor for w2 reflection data ie
; divide the ref data by this to make it normalised to the direct beam

;print,'TOTALS REF DB',total(ref),total(db)


ref1=ref
ref2=ref
db1=db
db2=db
edb=db
ere=ref

; get useful area of detector from common block variable
xmax=useful[1]
xmin=useful[0]

mmpp=1.0357*nx

catch,erranal2
if erranal2 ne 0 then begin
	errormessage,'Error anal2ysing data: check settings and try again'
	catch,/cancel
endif

;place info of array db (direct beam data) into z.
;z[0]=no dimensions, z[1]=1st dimension, z[2]=2nd dim, z[3]= type
; z[5]=tot. number of elements
z=size(db)
;print,' '
;print,'db size: ',z(2)
;print,'MEAN WATER',mean(water)

;water correction
for i=0,z(2)-1 do begin
	db1(*,i)=db(*,i)/water
	dber(*,i)=dber(*,i)/water
	ref1(*,i)=ref(*,i)/water
	refer(*,i)=refer(*,i)/water
endfor

;print,' '
;print,'done water correction'

;print,'TOTALS REF DB AFTER WATER',total(ref1),total(db1)

; limit area to search peak to user defined values
x1=peak_searchx[0] & x2=peak_searchx[1]

; if "def" is entered in y range then get the values from the size of the data
if peak_searchy[0] eq -1 then begin
	t1=fix(float(z[2])/2.) & t2=z[2]-1 
endif else begin
	t1=peak_searchy[0] & t2=peak_searchy[1]
end

;sum direct beam data along columns:
; restricted range sum
dbtot=total(db1(x1:x2,t1:t2),2)
; whole sum
dbtot2=total(db1,2)
; max. of direct beam data. pixel number is put in dbm
dbtotm=max(dbtot2,dbm)
; add resttricted range offset to dbm
;dbm=dbm+x1
;print,'direct beam peak at: ',dbm

;calculate summation ranges: rr=width of foreground sum
f1=dbm-fix((rr-1)/2)
f2=dbm+fix((rr-1)/2)
;print,'sum ranges for db: ',f1,f2

;Centre Of Mass calculation for db
numersum=0.
denomsum=0.
for i=f1,f2 do begin
	numer=dbtot2(i)*float(i)
	denom=dbtot2(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
;print,'db stuff:', numersum,denomsum
dbcom=numersum/denomsum
;print,'fitted db peak at: ',(dbcom)

;check to see if peak value is near centre of mass if it isn't set it to
; the centre of mass
if fix(dbcom+0.5) ne dbm then dbm=fix(dbcom+0.5)

; redo foreground calculation
f1=dbm-fix((rr-1)/2)
f2=dbm+fix((rr-1)/2)

print,format='("Direct beam sum ranges: Foreground      :",3x,i3,1x,i3)',f1,f2
if bg[0] ne 0 then print,format='(24x,"Background left :",3x,i3,1x,i3)',f1-bg[0]-bg[1],f1-1-bg[1]
if bg[2] ne 0 then print,format='(24x,"Background right:",3x,i3,1x,i3)',f2+bg[2]+bg[3],f2+1+bg[3]
;print,'corrected db peak at: ',dbm

;  finding the peak in the reflection over a limited range 150:230 in x
;and 200 to the max in time channels

reftot=total(ref1(x1:x2,t1:t2),2)
reftot2=total(ref1,2)
reftotm=max(reftot,refm)
refm=refm+x1
;print,'peak in reflection at: ',refm


ff1=refm-fix((rr-1)/2)
ff2=refm+fix((rr-1)/2)
;print,'sum ranges for ref: ',ff1,ff2
;COM for ref
numersum=0.
denomsum=0.

for i=ff1,ff2 do begin
	numer=reftot2(i)*float(i)
	denom=reftot2(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
refcom=numersum/denomsum
;print,'ref stuff:', numersum,denomsum
;print,'ref peak at: ',(refcom)
if fix(refcom+0.5) ne refm then refm=fix(refcom+0.5)
;print,'corrected ref peak at: ',refm
ff1=refm-fix((rr-1)/2)
ff2=refm+fix((rr-1)/2)


print,' '
print,format='("Ref.   beam sum ranges: Foreground      :",3x,i3,1x,i3)',ff1,ff2
if bg[0] ne 0 then print,format='(24x,"Background left :",3x,i3,1x,i3)',ff1-bg[0]-bg[1],ff1-1-bg[1]
if bg[2] ne 0 then print,format='(24x,"Background right:",3x,i3,1x,i3)',ff2+bg[2]+bg[3],ff2+1+bg[3]

;print,'ref peak at: ',(refcom)

;print,'f1 f2 ff1 ff2',f1,f2,ff1,ff2

; Check that background sum isn't outside range of detector. NB For left side bg[0] is width, bg[1] is shift from edge
; of foreground sum. Similar thing for right in bg[2] and bg[3]
if ((f1-bg[0]-bg[1]) lt xmin) or ((f2+bg[2]+bg[3]) gt xmax) or ((ff1-bg[0]-bg[1]) lt xmin) or ((ff2+bg[2]+bg[3]) gt xmax) then begin
  eflag=6
  errormessage,'Outside useful area of detector.Sum over smaller area'
  return
end



subarr=indgen(z(1))
dbb=fltarr(z(1),z(2))
rb=fltarr(z(1),z(2))
ed=fltarr(z(1),z(2))
eb=fltarr(z(1),z(2))
er=fltarr(z(1),z(2))

; bg is the range to sum background over, therefore if this is gt 0 (i.e. there is
; some background to sum over) then do the sum. NB bg[0] is width of left sum
; bg[2] is width of right sum
if (bg[0] gt 0) or (bg[2] gt 0) then begin
; bgrd is the background subtraction option. If this is zero then use summing method
	if bgrd eq 0 then begin
; loop over z[2]= columns of array db (direct beam)
		for i=0,z(2)-1 do begin
		; background of direct beam is mean of counts in sum range
; IF only left background then average only over left
		if (bg[0] gt 0) and (bg[2] eq 0) then begin 
			bkdb=mean(db1(f1-bg[0]-bg[1]:f1-1-bg[1],i))
			bkref=mean(ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i))
		end
; IF only right background then average only over right
		if (bg[0] eq 0) and (bg[2] gt 0) then begin
			bkdb=mean(db1(f2+1+bg[3]:f2+bg[3]+bg[2],i))						
			bkref=mean(ref1(ff2+1+bg[3]:ff2+bg[3]+bg[2],i))
		end
;; IF both background then average over both
		if (bg[0] gt 0) and (bg[2] gt 0) then begin
			bkdb=(mean(db1(f1-bg[0]-bg[1]:f1-1-bg[1],i))+mean(db1(f2+1+bg[3]:f2+bg[3]+bg[2],i)))/2
			bkref=(mean(ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i))+mean(ref1(ff2+1+bg[3]:ff2+bg[3]+bg[2],i)))/2
		end
		; subtract background from direct beam counts
				db2(*,i)=db1(*,i)-bkdb
		; ditto for the reflected beam
				ref2(*,i)=ref1(*,i)-bkref

				dbb(*,i)=sqrt(bkdb)
                                rb(*,i)=sqrt(bkref)
				
				ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)
				er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

		endfor
      
	endif


; If bgrd=1 then the fitting option is chosen for background subtraction
	if bgrd eq 1 then begin
	
; note: Number of background points to use in fit = number at left+number at right=bg[0]+bg[2]
		n_bgpoints=bg[0]+bg[2]
		;subtract backgrd from db
		for i=0,z(2)-1 do begin


; dbgsuarr is an array that will contain the pixel numbers (on the detector) 
; of the pixels to be used in the fit
			dbbgsubarr=intarr(n_bgpoints)
; This array contains the VALUES of the pixels use for fitting
			dbbgarr=fltarr(n_bgpoints,z(2))
			dbbgfit=fltarr(z(1),z(2))

; Now we need the NUMBERS of the pixels that have been requested for use in the fit and also
; their VALUES:
; Subarr contains an array of pixel numbers for the whole detector. Set the pixel NUMBERS
; in dbgsubarr to the pixels selected for fitting. First the left side....
; (NB bg[0]=left width, bg[1]=left shift, f1=left side of foreground range)
			if bg[0] ne 0 then dbbgsubarr(0:bg[0]-1)=subarr(f1-bg[0]-bg[1]:f1-1-bg[1]) 
; ...Now do right hand side. (NB bg[2]=right width,bg[3]=right shift, f2=right hand side
; of foreground
			if bg[2] ne 0 then dbbgsubarr(bg[0]:(n_bgpoints-1))=subarr(f2+1+bg[3]:f2+bg[2]+bg[3]) 

; Now do a similar thing, but this time get the selected pixel VALUES
			if bg[0] ne 0 then dbbgarr(0:bg[0]-1,i)=db1(f1-bg[0]-bg[1]:f1-1-bg[1],i)
			if bg[2] ne 0 then dbbgarr(bg[0]:n_bgpoints-1,i)=db1(f2+1+bg[3]:f2+bg[2]+bg[3],i)

; find the errors on each of the pixel VALUES for use in the least-squares
; fitting process. Size of error array is equal to no. of fitting pixels
			err=fltarr(n_bgpoints)
; loop over number of background fitting pixels and find error by taking sqrt
			for j=0,n_bgpoints-1 do err(j)=sqrt(dbbgarr(j,i)+1)

; least squares fit of background
			dbbgcoeff=linfit(dbbgsubarr,dbbgarr(*,i),sdev=err,chisq=dbchisq,sigma=dbbgerr,/double)
	

; array containing the best fit line of the background
			dbbgfit(*,i)=dbbgcoeff(0)+dbbgcoeff(1)*subarr
; correct data by subtracting the background fit
			db2(*,i)=db1(*,i)-dbbgfit(*,i)
; error on background fit in the SQUARE ROOT of the fit at each point
			dbb(*,i)=sqrt(dbbgfit(*,i))
; to get error on corrected data add in quadrature the errors on the raw data and the background fit
			ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)

		endfor

		;subtract backgrd from ref
		for i=0,z(2)-1 do begin

			refbgsubarr=intarr(n_bgpoints)
			refbgarr=fltarr(n_bgpoints,z(2))
			refbgfit=fltarr(z(1),z(2))

			if bg[0] ne 0 then refbgsubarr(0:bg[0]-1)=subarr(ff1-bg[0]-bg[1]:ff1-1-bg[1]) 
			if bg[2] ne 0 then refbgsubarr(bg[0]:n_bgpoints-1)=subarr(ff2+1+bg[3]:ff2+bg[2]+bg[3]) 

			if bg[0] ne 0 then refbgarr(0:bg[0]-1,i)=ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i)
			if bg[2] ne 0 then refbgarr(bg[0]:n_bgpoints-1,i)=ref1(ff2+1+bg[3]:ff2+bg[2]+bg[3],i)

			err=fltarr(n_bgpoints)
			for j=0,n_bgpoints-1 do err(j)=sqrt(refbgarr(j,i)+1)

			refbgcoeff=linfit(refbgsubarr,refbgarr(*,i),sdev=err,chisq=refchisq,sigma=refbgerr,/double)

			;if refchisq ne 1 then begin
			;refbgcoeff=linfit(refbgsubarr(0:bg-1),refbgarr(0:bg-1,i),sdev=err(0:bg-1),chisq=refchisq,sigma=refbgerr)
			;endif

; Do similar calculation as for direct beam, i.e. take off background. Error in background is sqrt(counts)
; error in corrected data is found by adding in quadrature the errors in raw data and the background errors.
			refbgfit(*,i)=refbgcoeff(0)+refbgcoeff(1)*subarr
			ref2(*,i)=ref1(*,i)-refbgfit(*,i)
			rb(*,i)=sqrt(refbgfit(*,i))
			er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

		endfor

	endif

endif else begin
 
	ref2=ref1
	db2=db1
	ed=dber
	er=refer

endelse

d=total(db2(f1:f2,*),1)
r=total(ref2(ff1:ff2,*),1)

print,' '
if (bg[0] ne 0) and (bg[2] ne 0) then print,'done background correction'

;error calculation
ed=sqrt(total(ed(f1:f2,*)^2,1))
er=sqrt(total(er(ff1:ff2,*)^2,1))

reff=r
ereff=r

dpr=180./!pi

; calculate theta unless specified by user
if th(0) eq 1 then th(1)=tth(dbdan,dbcom,refdan,refcom,nx,dett)

q=4*!pi*sin(th(1)/dpr)/lamarr

for i=0,z(2)-1 do begin
	if (d(i) ne 0.) then begin
		reff(i)=r(i)/d(i)
		ereff(i)=reff(i)*sqrt((er(i)/r(i))^2+(ed(i)/d(i))^2) 
	endif else begin
		ereff(i)=0.
		reff(i)=1.e-11
	endelse
endfor

;resolution (error in q)
etf=((85.e-3)/tofd)+(3956.*opena*period)/(360.*tofd*lamarr)




print,'slit values', par2(93),par2(95)

;if s3 ge s2 then bigslit=s3 else bigslit=s2
;ethf=(bigslit*180)/(th(1)*3.4*!pi)

;s1s2 is the inter-slit distance
s1s2=3500.

ethf=2.*atan((par2(93)+par2(95))/(s1s2*2.))*180./(!pi*th(1))

qe=q*sqrt(etf^2+ethf^2)

;print,etf,ethf,qe/q

; unlogged data for reflectivity is in reff, q is q and error is ereff
if lamda(0) eq 1 then begin

	qmin=(min(q))
	qmax=(max(q))

endif else begin

	qmin=4*!pi*sin(th(1)/dpr)/lamda(2)
	qmax=4*!pi*sin(th(1)/dpr)/lamda(1)

endelse

qrange=where((q ge qmin) and (q le qmax))

wdum=reverse(reff(min(qrange):max(qrange)))
xdum=reverse(q(min(qrange):max(qrange)))
edum=reverse(ereff(min(qrange):max(qrange)))
qedum=reverse(qe(min(qrange):max(qrange)))

catch,/cancel

return
end

;*****************************************************************************************************
; Procedure to group data. Combines data from points which are, within the resolution, too
; close to each other. Also takes logarithm of the data.
; x = q values. y = Reflectivity values. e = error on reflectivity data
; dq = error on q values
; a = groupd reflectivity. b = groupd q values. c = groupd refl. errors
PRO group,x,y,e,dq,a,b,c

; arrays to store groupd data
ny=fltarr(1000)
nx=fltarr(1000)
nee=fltarr(1000)
ndq=fltarr(1000)


print,' '
print,'Bundling nearby data points for plotting:'

; resf = 'Magic' resolution factor. if the difference in q values is less than dq/resf then
; group the points. With resf=2. data points separated by half the error on q are groupd
resf=2.

; number of elements in data
tot=N_ELEMENTS(x)-1

; i counts the number of iterations purely for information on a print statement
	i=1
	
; This loop repeats until the number of pairs found is zero. (NB: It is 
; possible that the number of pairs will not decrease after an iteration.
; In this case data has been groupd, but the resulting point appears close
; to another point. This is why the number of pairs may remain equal to, e.g.
; 1 for the last few iterations
repeat begin

; reset c. c is used as a counter to address the data
 c=0
; set num to the number of elements in the data
 num=tot
; new is used to address the elements of the arrays where the groupd data is stored
 new=0
; counts the number of pairs encountered in each iteration
 pairs=0

; loop through data array
; while c is less than the last element (i.e. up to and including penultimate)
while c lt num do begin

; If q values are sufficiently close....
  if (x(c+1)-x(c) lt dq(c)/resf and x(c+1) ne 0) then begin
; ... then group the data. This is done by averaging the q values and reflectivity of
; each point and the errors are obtained by adding in the two errors in quadrature
     ny(new)=(y(c+1)+y(c))/2.
     nee(new)=(sqrt(e(c)^2.+e(c+1)^2.))/2
     nx(new)=(x(c)+x(c+1))/2.
     ndq(new)=(dq(c)+dq(c+1))/2.

; increase number of pairs
     pairs=pairs+1
; increment counter by two because two numbers have been processed
     c=c+2
; decrease the number of data elements by 1: two points have been groupd
     tot=tot-1
  endif else begin
; If no bundling is necessary then just copy the data into the new arrays.
     ny(new)=y(c)
     nx(new)=x(c)
     nee(new)=e(c)
     ndq(new)=dq(c)
; inc. counter by one
     c=c+1
  endelse

;inc. groupd data array counter
	new=new+1
end

; set old data to new groupd data ready for next iteration
 y=ny
 x=nx
 e=nee
 dq=ndq

	print,pairs,' pairs found on iteration ',i
; increment number of iterations
	i=i+1
	
; stop if no pairs were found
endrep until pairs eq 0

; return results: Log reflectivity data and calc. error on reflectivity.
a=alog10(ny(0:tot-1)) & b=nx(0:tot-1) & c=(nee(0:tot-1)/ny(0:tot-1))/alog(10)

return

end

;*****************************************************************************************************
;outputs to plot and output file

pro output,x,y,e,xe,fil

common varbwid,base

points=size(x)

close,10
openw,10,fil,/append
for i=0,points(1)-1 do begin
	printf,10,x(i),y(i),abs(e(i)),xe(i)
endfor
close,10

plotbase=widget_base(group_leader=base,title='Reflectivity against Q (log plot)',/column)
graph=widget_draw(plotbase,xsize=700,ysize=500,retain=2)
but=widget_button(plotbase,value='OK',uvalue='ok')

widget_control,plotbase,/realize

; negative ref set to 10^-10
y=y > 10.e-10
xe=abs(xe)

nx=fltarr(1000)
ny=fltarr(1000)
ner=fltarr(1000)

; group data. groupd data is nx, ny and ner(new ...)
group,x,y,e,xe,ny,nx,ner

	if N_ELEMENTS(nx) lt 2 then begin
		errormessage,'Data bundled into oblivion!!'
		return
	end
; clip errors to 4. (4 orders of magnitude)
ner=ner<4.

; calc. errors
;errs=e/(y*alog(10.))


  
ploterr,nx,ny,ner
; get rid of negative errors
;errs=abs(errs)

; limits errors to 4 orders of magnitude (on log plot)
;errs=errs<4.
;ploterr,x,alog10(y),errs

xmanager,'message',plotbase

return
end

;**************************************************************************************************
;shows end message window with calculated values
pro endmessage

common varbwid,base
common varwid,lab,txt,but,gap
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3
common varset,norm,bg,r,fil
common varbg,bgrd

res=intarr(50)

if norm eq 0 then nrm='runtime' else nrm='monitor'
if bgrd eq 0 then bgd='average'
if bgrd eq 1 then bgd='fit'

endbase=widget_base(group_leader=base,/floating,title='Finished',column=2)

;column1
res(0)=widget_label(endbase,value='fac1: '+strcompress(string(fac1(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac2: '+strcompress(string(fac2(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac3: '+strcompress(string(fac3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Normalised: '+nrm,/align_left)
res(2)=widget_label(endbase,value='Backgrd used: '+bgd,/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Saved to: '''+strcompress(string(fil(1)),/remove_all)+'''',/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Go again?')
gap(0)=widget_label(endbase,value='',ysize=0)

;column2
res(1)=widget_label(endbase,value='th1: '+strcompress(string(th1(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th2: '+strcompress(string(th2(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th3: '+strcompress(string(th3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Tot. Backgrd: '+strcompress(string(bg[0]+bg[2]),/remove_all),/align_left)
res(2)=widget_label(endbase,value='Foregrd: '+strcompress(string(r(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
endbut1=widget_button(endbase,value='OK',uvalue='ok')
endbut2=widget_button(endbase,value='QUIT',uvalue='quit')

widget_control,endbase,/realize

xmanager,'message',endbase

return
end

;************************************************************************************
;shows error message window
pro errormessage,mes1

common varbwid,base
common EFLAGS,eflag

; If its really an error then display appropriate message
if eflag ne 0 then begin
print,'********************************************************************'
print,'ERROR!! TOF Calculations aborted. Check error message and try again.'
print,'********************************************************************'
errbase=widget_base(group_leader=base,/floating,title='Error Message',/column)
; Otherwise its just a warning
endif else errbase=widget_base(group_leader=base,/floating,title='Warning Message',/column)

mess1=widget_label(errbase,value=mes1)
errbut=widget_button(errbase,value='OK',uvalue='ok')

widget_control,errbase,/realize

xmanager,'message',errbase

return
end

;***********************************************************************************
;handles events from errormessage, endmessage and output
pro message_event,event

common varbwid,base
common varwid,lab,txt,but,gap
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3

widget_control,event.id,get_uvalue=ev,get_value=val

;widget_control,event.top,/destroy

;if ev eq 'yes' then widget_control,base,sensitive=1	

if ev eq 'quit' then widget_control,base,/destroy

if ev eq 'ok' then begin
	widget_control,event.top,/destroy
	widget_control,base,sensitive=1
endif	

return
end

;*************************************************************************
;input TOF window

pro d17tof2
common par,par2
common var0,def
common varbwid,base
common varwid,lab,txt,but,gap

;widget types: lab=label,txt=text,but=button,gap=label(null string)
lab=lonarr(50)
txt=lonarr(50)
but=lonarr(50)
gap=lonarr(50)

;don't show maths errors
!except=0

;defaults that appear in the TOF window
def='def'

; If badflag=0 then the default file (if it exists) is okay
; If badflag=1 then the default file has been found to be corrupted by
; ON_IOERROR below
			badflag=0
;dtb*=direct beam run numbers 
setdefaults:		dtb1=''
			dtb2=''
			dtb3=''

;refl*=reflected beam run numbers
			refl1=''
			refl2=''
			refl3=''

; Instrument background numors
			instbg1=''
			instbg2=''
			instbg3=''
;water=water run numbers (or def)
			water=''

;wavelength range
			lambda='2.1,16'

;th*=theta angle (or def=calculated)
			th1=def
			th2=def
			th3=def

;fac*=factor by which to multiply Reflectivity (or def=calculated such that curves match)
			fac1=def
			fac2=def
			fac3=def

;r=Foreground range
;bg=Background range
			r='11'
			bgl='0'
			bgr='0'

;norm=method by which reflected beam is normalised to direct beam (0=Runtime,1=Monitor)
			norm=1
;bgrd=method by which background rate is determined in range bg (0=left side of peak,1=both sides of peak,2=linear fit calc from both sides of peak)
			bgrd=1

;fil=output file name
			fil='tofdat.out'
;path=path of data runs to be anal2ysed
			path='/users/data/'
; useful x range of detector
			useful='30,239'
; area to search for peak
			peak_searchx='30,239'
			peak_searchy='def'
;check default file exists
			filcheck=findfile('tof_defaults.dat',count=checkfil)			
; if file exists and its not already been found to be corrupt
			if (checkfil ne 0) and (badflag eq 0) then begin
			spacer='XXXXXXX'
			ON_IOERROR, corruptdefs
			close,10
			openr,10,'tof_defaults.dat'
			readf,10,spacer
			readf,10,dtb1
			readf,10,spacer
			readf,10,dtb2
			readf,10,spacer
			readf,10,dtb3
;refl*=reflected beam run numbers
			readf,10,spacer
			readf,10,refl1
			readf,10,spacer
			readf,10,refl2			
			readf,10,spacer
			readf,10,refl3

;instbg8=instrument background numors
			readf,10,spacer
			readf,10,instbg1
			readf,10,spacer
			readf,10,instbg2
			readf,10,spacer
			readf,10,instbg3

;water=water run numbers (or def)
			readf,10,spacer
			readf,10,water

;wavelength range
			readf,10,spacer
			readf,10,lambda

;th*=theta angle (or def=calculated)
			readf,10,spacer
			readf,10,th1
			readf,10,spacer
			readf,10,th2
			readf,10,spacer
			readf,10,th3

;fac*=factor by which to multiply Reflectivity (or def=calculated such that curves match)
			readf,10,spacer
			readf,10,fac1
			readf,10,spacer
			readf,10,fac2			
			readf,10,spacer
			readf,10,fac3
;r=Foreground range
;bg=Background range
			readf,10,spacer
			readf,10,r
; Background
; Left
			readf,10,spacer			
			readf,10,bgl
; Right
			readf,10,spacer
			readf,10,bgr

;norm=method by which reflected beam is normalised to direct beam (0=Runtime,1=Monitor)
			readf,10,spacer
			readf,10,norm
;bgrd=method by which background rate is determined in range bg (0=left side of peak,1=both sides of peak,2=linear fit calc from both sides of peak)
			readf,10,spacer
			readf,10,bgrd

;fil=output file name
			readf,10,spacer
			readf,10,fil
;path=path of data runs to be anal2ysed
			readf,10,spacer
			readf,10,path
; useful xrange of detector
			readf,10,spacer
			readf,10,useful
; area to look for peak
			readf,10,spacer
			readf,10,peak_searchx
			readf,10,spacer
			readf,10,peak_searchy
			close,10
			end
			goto,fine
corruptdefs:
			print,'Corrupted defaults file - ignored. Hardwired defaults set.'
			badflag=1
			goto,setdefaults				
;base window divided into 5 columns
fine: base=widget_base(title='TOF Data for data taken from last cycle 2001 to 2002',uvalue='base',column=6) 

;column 1
gap(10)=widget_label(base,ysize=10,value='')
lab(0)=widget_label(base,value='Run')
lab(1)=widget_label(base,value='set')
gap(0)=widget_label(base,ysize=0,value='')
lab(2)=widget_label(base,value='(1)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(3)=widget_label(base,value='(2)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(4)=widget_label(base,value='(3)  ',/align_right)
gap(23)=widget_label(base,ysize=15,value='')
lab(5)=widget_label(base,value='Water',/align_right)
lab(6)=widget_label(base,value='runs',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
lab(7)=widget_label(base,value='Lamda',/align_right)
lab(8)=widget_label(base,value='range',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
gap(0)=widget_label(base,ysize=0,value='')
lab(9)=widget_label(base,value='Normalise',/align_right)
lab(10)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 2
gap(10)=widget_label(base,ysize=10,value='')
lab(11)=widget_label(base,value='Direct')
lab(12)=widget_label(base,value='runs')
txt(0)=widget_text(base,value=dtb1,xsize=9,/editable,uvalue='int')
txt(1)=widget_text(base,value=dtb2,xsize=9,/editable,uvalue='int')
txt(2)=widget_text(base,value=dtb3,xsize=9,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(3)=widget_text(base,xsize=9,value=water,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(4)=widget_text(base,xsize=9,value=lambda,/editable,uvalue='real')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
but(0)=cw_bgroup(base,['Runtime','Monitor'],set_value=norm,/column,/exclusive,uvalue='norm')
gap(36)=widget_label(base,ysize=30,value='')
lab(11)=widget_label(base,value='Data Path:',/align_right)
lab(11)=widget_label(base,value='Output file:',/align_right)

;column 3
gap(10)=widget_label(base,ysize=10,value='')
lab(13)=widget_label(base,value='Reflect')
lab(14)=widget_label(base,value='runs')
txt(5)=widget_text(base,value=refl1,xsize=9,/editable,uvalue='int')
txt(6)=widget_text(base,value=refl2,xsize=9,/editable,uvalue='int')
txt(7)=widget_text(base,value=refl3,xsize=9,/editable,uvalue='int')
gap(16)=widget_label(base,ysize=16,value='')
lab(15)=widget_label(base,value='Foregrd',/align_right)
lab(16)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=10,value='')
lab(17)=widget_label(base,value='Backgrd',/align_right)
lab(18)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(20)=widget_label(base,ysize=20,value='')
lab(19)=widget_label(base,value='Bkgnd sub:',/align_right)
lab(21)=widget_label(base,value='method',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

txt(8)=widget_text(base,value=path,xsize=9,/editable,uvalue='str')
txt(9)=widget_text(base,value=fil,xsize=9,/editable,uvalue='str')
gap(0)=widget_label(base,ysize=0,value='')

;column 4
gap(10)=widget_label(base,ysize=10,value='')
lab(20)=widget_label(base,value='Instr. Bckgnd.')
lab(23)=widget_label(base,value='runs')
txt(10)=widget_text(base,xsize=4,value=instbg1,/editable,uvalue='real')
txt(11)=widget_text(base,xsize=4,value=instbg2,/editable,uvalue='real')
txt(12)=widget_text(base,xsize=4,value=instbg3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(13)=widget_text(base,xsize=4,value=r,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='left')
txt(14)=widget_text(base,xsize=4,value=bgl,/editable,uvalue='int')
gap(35)=widget_label(base,ysize=0,value='')
but(1)=cw_bgroup(base,['average','fit'],set_value=bgrd,/column,/exclusive,uvalue='bgrd')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=10,value='')
gap(0)=widget_label(base,ysize=0,value='')
but(3)=widget_button(base,value='DO IT',uvalue='done')
gap(0)=widget_label(base,ysize=0,value='')



;column 5
gap(10)=widget_label(base,ysize=10,value='')
lab(21)=widget_label(base,value='Factor')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(15)=widget_text(base,xsize=8,value=fac1,/editable,uvalue='real')
txt(16)=widget_text(base,xsize=8,value=fac2,/editable,uvalue='real')
txt(17)=widget_text(base,xsize=8,value=fac3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=20,value='')
gap(0)=widget_label(base,ysize=22,value='')
gap(6)=widget_label(base,ysize=10,value='')
gap(10)=widget_label(base,ysize=0,value='right')
txt(18)=widget_text(base,xsize=8,value=bgr,/editable,uvalue='int')
gap(40)=widget_label(base,ysize=40,value='')
gap(20)=widget_label(base,ysize=20,value='')
gap(35)=widget_label(base,ysize=35,value='')
but(2)=widget_button(base,value='QUIT',uvalue='quit')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 6
gap(10)=widget_label(base,ysize=10,value='')
lab(22)=widget_label(base,value='Theta')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(19)=widget_text(base,xsize=4,value=th1,/editable,uvalue='real')
txt(20)=widget_text(base,xsize=4,value=th2,/editable,uvalue='real')
txt(21)=widget_text(base,xsize=4,value=th3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')


gap(0)=widget_label(base,ysize=0,value='Detector')
gap(6)=widget_label(base,ysize=0,value='ranges')

drange = widget_base(base,/FRAME,/BASE_ALIGN_CENTER,/COLUMN)
gap(40)=widget_label(drange,value='Useful x range')
txt(22)=widget_text(drange,xsize=8,value=useful,/editable)
gap(6)=widget_label(drange,value='Area to look')
gap(0)=widget_label(drange,value=' for peak')
gap(6)=widget_label(drange,value='(xmin,xmax)')
txt(23)=widget_text(drange,xsize=8,value=peak_searchx,/editable)
gap(6)=widget_label(drange,value='(ymin,ymax)')
txt(24)=widget_text(drange,xsize=8,value=peak_searchy,/editable)

gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;gives the TOF window a margin
baseinfo=widget_info(base,/geometry)
widget_control,base,scr_xsize=baseinfo.scr_xsize+10
widget_control,base,scr_ysize=baseinfo.scr_ysize+10

;creates the TOF window
widget_control,base,/realize

;calls 'pro tof_event'
xmanager,'tof',base

end
;information file on how to enter data is tofinfo.inf
; pro tof    ;;;look for the main program at the bottom!!

;====================================================================================================
; This function takes a string as input an extracts the numors an returns an array of numors. Errors
; are signalled by the flag 'eflag': If this is 0 no error has occured, If it is 1 an error occured.
; The string should be formatted as follows: Individual numors should be punctuated by a plus sign (+)
; ranges of numors can be specified by the min/max numors separated by a comma.
; e.g. 1+5+10,13+20 gives the array of numors: [1,5,10,11,12,13,20]
;====================================================================================================
function getnumors,intlist

; Common block for error flag
common EFLAGS,eflag
	
; array to store numors
	numors=lonarr(1000)
; integer of numor counts
	numor_index=0
	
;convert string to bytes, removing all whitespace add 0 'terminator'
	numlist=[byte(strcompress(intlist,/REMOVE_ALL)),0B]
;index of numlist
	string_index=0
; temporary storage space for an integer of up to 6 digits
	thisnum=bytarr(6)
; index for thisnum-counts number of digits in number	
	count=0
; If true (1) this varaible indicates that the last punctuation was a comma
	comma=0
	
;----------------------------------------------------
; Main loop - loops over string (numlist). Terminates
; when 0 (null) terminator is encountered	
	repeat begin

; read in character
		temp=numlist[string_index]
; increment string index
		string_index=string_index+1
		
; Case block: determines character. If a digit is encountered then it is stored
; in a temporary array until punctuation is encountered. IF a plus is encountered
; then this numor is stored in the list of numors array. If a comma is encountered
; then the number is stored temporarily until the next number (and the following plus
; or terminator) is read, when a range of numors is generated
		case 1 of

;>>>>>>>>> Case: Any ASCII digit: '0' through '9'
; insert digit into thisnum: temporary storage array
		(temp ge 48B) and (temp le 57B): begin	
; If number of digits exceeds 6 then signal numor too big error
			if count eq 6 then begin
				eflag=2
				return,0
			end
; if not then insert digit
			thisnum[count]=temp
; increment counter
			count=count+1
		end
				
;>>>>>>>> Case: '+' or null terminator
; In this case add the previous numor to the list of numors
; or, if there was a comma, add a numor range
		(temp eq 43B) or (temp eq 0B): begin
; If count(=number of digits) is zero then there is no number between punctuation!
			if count eq 0 then begin
; Allow for empty strings -ie only terminator. In which case return special error.
				if (temp eq 0B) and (numor_index eq 0) then begin 
					eflag=4
					return,0
				endif else begin
; otherwise, bog standard formatting cock-up (error 1)
					eflag=1
					return,0
				end
			end
			
; Convert digits stored in thisnum to intger
			rend=long(string(thisnum))

; if value of numor is zero ('0') then signal error
			if rend eq 0 then begin
				eflag=2
				return,0
			end

; If the last punctuation was a comma, then insert a range into the numors array
		if comma then begin
; if end of range is less than beginning then signal error
			if rend lt rbegin then begin
				eflag=5
				return,0
			end
; Put series of integers from rbegin (first numor) to rend (last numor)
			numors[numor_index:(numor_index+rend-rbegin)]=indgen(rend-rbegin+1)+rbegin
; update the numor counter appropriately
			numor_index=numor_index+rend-rbegin+1
; reset comma to false
			comma=0
; reset digit counter
			count=0
; flush string
			thisnum[*]=0
; If no comma then simply insert single numor into array
		endif else begin
			numors[numor_index]=rend
; increment numor index
			numor_index=numor_index+1
; reset counter for next numor
			count=0	
; fluch string
			thisnum[*]=0
			end
		end
		
;>>>>>>>>>> Case: comma ','
		temp eq 44B: begin
; If comma flag is already true (1) then signal formatting error
; (two commas in a row)
		if comma then begin
			eflag=1
			return,0
		end
; otherwise set comma flag to true (1)
		comma=1
; If count(=number of digits) is zero then there is no number
			if count eq 0 then begin
				eflag=1
				return,0
			end
		
; store thisnum (byte array of digits) into 'start of numor range' variable for later use
			rbegin=long(string(thisnum))
; reset digit count
			count=0
; flush string
			thisnum[*]=0
; if value of numor is zero ('0') then signal error
			if rbegin eq 0 then begin
				eflag=2
				return,0
			end
		end
		
; >>>>>>>>>> Case: Illegal character, send error message
		else: begin
			eflag=3
			return,0
		end
		endcase
; Loop back to top unless the terminator is encountered
	endrep until temp eq 0
	
; If we've got this far without returning then there's no error
	eflag=0
; return an array with the numors in
	return,numors[0	:numor_index-1]
end

;********************************************************************************
;converts text widgit strings to appropriate type and checks for errors
;defaults=0,1 according to whether 'def' was entered
;intcheck=0,1 according to whether an integer is expected
;commacheck=0,1,2 according to whether a comma is expected (2=either)
;strcheck=0,1 according to whether a string is expectec
;errcheck1=0 (false),1 (true) according to whether two numbers (ie a range of
; numors) is expected as opposed to just a single number
;errcheck2=0 (false),1 (true) according to whether the field must be completed 
; in order for the calculations to be done.

function convert,txtwid,defaults,intcheck,commacheck,strcheck,errcheck1,errcheck2
common par,par2
common var0,def
common varflag,flag0,flag1,flag2,flag3,flag4,flag5

; parameter to return is an array of 3 strings (possibly to be an array of 3 integers/floats)
valnum=strarr(3)

widget_control,txtwid,get_value=val

valstr=val(0)

valstr=strcompress(valstr,/remove_all)

;signal error flag if a 'def' is given but defaults aren't allowed
if (defaults eq 0) and (valstr eq def) then flag5=1
; if default is set then set valnum (return array) to 1	
if valstr eq def then valnum(0)=1 else $
; else if string_check is true (1) then set the return varaible to the string (valstr)
; NB: Isn't the expression (valstr ne def) redundant since it's already checked as a condition
; to get here, i.e. "if valstr eq def" above
if (valstr ne def) and (strcheck eq 1) then valnum(1)=valstr else begin
; If we're not looking for a string then do the other checks

; look for the position of THE comma
	commapos=strpos(valstr,',')

	if commapos eq -1 then begin
; If there are no commas, but a comma is required then flag an error
		if commacheck eq 1 then flag4=1

; convert the string (which should be a single number, no commas) into a float and
; an integer
		valflt=float(valstr)
		valint=fix(valstr)

; compare the string representation of the converted number. If this is not equal
; to the original string an error has occured 	
		if strpos(string(valflt),valstr) eq -1 then flag2=1
		
; if intcheck=1 (true) and the floating version isn't the same as the integer
; then its not an integer-> signal error flag
		if (intcheck eq 1) and (valint ne valflt) then flag3=1


; If an integer is required return the integer 
		if (intcheck eq 1) and (errcheck1 eq 1) then valnum=[0,valint,0]
; If an integer isn't required then return the floating point
		if (intcheck eq 0) and (errcheck1 eq 1) then valnum=[0,valflt,valflt]
; no range needed
		if (intcheck eq 0) and (errcheck1 eq 0) then valnum(1)=valflt
		if (intcheck eq 1) and (errcheck1 eq 0) then valnum(1)=valint

	endif else begin
; Commas have been found:

; If the comma occupies the first character then user has been painfully stupid.	
		if commacheck eq 0 then flag2=1

; sets valstr (a 3 string array) to: '0', the string between the first character and the comma, the
; string between after the comma and the end.
		valstr=['0',strmid(valstr,0,commapos),strmid(valstr,commapos+1)]

; make arrays of float and integers containing the respective versions of valstr.
		valflt=float(valstr)
		valint=fix(valstr)
	
; check the string versions of the float to the original string. If they aren't equal the user has not 
; entered a number. signal 'Not a number error'
		if (strpos(string(valflt(1)),valstr(1)) eq -1) or (strpos(string(valflt(2)),valstr(2)) eq -1) then flag2=1
; if intcheck=1 (true) and the integers aren't equal to the floats then they aren't integers. Signal 'not int' error
		if (intcheck eq 1) and ((valint(1) ne valflt(1)) or (valint(2) ne valflt(2))) then flag3=1
; If intcheck=1 (true) then return the integers, otherwise return the floats
		if intcheck eq 1 then valnum=valint else valnum=valflt

	endelse

; If errcheck=1 (true) then a range (two numbers) rather than a single number is required.
; This checks to ensure that the first number is smaller than the second, otherwise the
; range is invalid.
; Note the fudge: The range check is not required if integers are being read. This is for the 
; background shift/width which isn't a range. Numor (which are integer) ranges are dealt with by
; another procedure "getnumors"
	if (errcheck1 eq 1) and (intcheck eq 0) then begin

		if valnum(1) gt valnum(2) then flag0=1

	endif

; If errorcheck2=1 (true) then the field must contain a non-zero number. This is the case
; for Direct beam (1), Reflect (1), water, lambda, theta (1) and fac (1). Things like 
; Direct beam (2) are optional and only need to be specified if there is more than one 
; angle of reflection.
	if errcheck2 eq 1 then begin

		if valnum(1) eq 0 then flag1=1

	endif

endelse	

; returns result.
return,valnum

end


;*******************************************************************************************
;calculates factor by which to multiply refb so as to match refa

function factor,refa,refb,qa,qb,errora,errorb

common varbwid,base

xa=qa(sort(qa))
xb=qb(sort(qb))
ya=refa(sort(qa))
yb=refb(sort(qb))
errora=errora(sort(qa))
errorb=errorb(sort(qb))

xaovsub=where(xa ge min(xb))

range=max(xaovsub)-min(xaovsub)

xaov=xa(min(xaovsub):max(xaovsub))

dataa=ya(min(xaovsub):max(xaovsub))
erra=errora(min(xaovsub):max(xaovsub))

datab=fltarr(range)
err2=fltarr(range)
errb=fltarr(range)

numersum=0
denomsum=0

catch,errstat
if errstat ne 0 then begin
	eflag=8
	errormessage,'Incompatible data: check run set order'
	catch,/cancel
endif

for i=1,range-1 do begin
		
	pntabsub=min(where(xb ge xaov(i)))
	pntab=xb(pntabsub)
	databab=yb(pntabsub)
	errbab=errorb(pntabsub)
	pntbesub=max(where(xb lt xaov(i)))
	pntbe=xb(pntbesub)
	databbe=yb(pntbesub)
	errbbe=errorb(pntbesub)
	
	databdiff=databbe-databab

datab(i)=(((pntab-xaov(i))/databdiff)*databbe)+(((xaov(i)-pntbe)/databdiff)*databab)
		errb(i)=sqrt((((pntab-xaov(i))/databdiff)*errbbe)^2+(((xaov(i)-pntbe)/databdiff)*errbab)^2)
	
	if pntab-xaov(i) le xaov(i)-pntbe then begin
		datab(i)=yb(pntabsub)
		errb(i)=errorb(pntabsub)
	endif else begin
		datab(i)=yb(pntbesub)
		errb(i)=errorb(pntbesub)
	endelse
	
	if (dataa(i) gt 1.e-11) and (datab(i) gt 1.e-11) and (erra(i) gt 0.) and (errb(i) gt 0.) then err2(i)=(erra(i)+errb(i))*(erra(i)+errb(i)) else err2(i)=1.e20

	numer=(1/err2(i))*dataa(i)*datab(i)

	denom=(1/err2(i))*datab(i)*datab(i)

	numersum=numersum+numer
	denomsum=denomsum+denom

endfor

catch,/cancel

fac=numersum/denomsum
return,fac

end


;***************************************************************************************************************
;deals with events from TOF window ('pro tof')

pro tof_event,event
common par,par2
common var0,def
common varwid,lab,txt,but,gap
common varbwid,base
common varflag,flag0,flag1,flag2,flag3,flag4,flag5
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3
common varset,norm,bg,r,fil
common varbg,bgrd
common varpath,path

; common block containing the time->lambda conversion array so it can be output
; to a file for each run
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3

; common block for useful xrange of detector and area to find peak in
common detranges,useful,peak_searchx,peak_searchy

; Error flag.
common EFLAGS,eflag

;takes the user value of the widget that cause the event and puts it equal to ev
widget_control,event.id,get_uvalue=ev

;closes all windows if 'quit' is pressed
if ev eq 'quit' then widget_control,base,/destroy

;begins anal2ysis of data if 'done' is pressed
if ev eq 'done' then begin

;flag*=error flags (0=no error, 1=error)
	flag0=0	
	flag1=0	
	flag2=0
	flag3=0
	flag4=0
	flag5=0
	flag6=0

;check*=flag for which run sets were used
	check0=0
	check1=0

;----*----*----*----*----*----*----*----*----*----*----*----*----*----*----
; Lots of repetative code to read in numors and output appropriate errors.
; (Should really be made a little more succinct by making a procedure
;----*----*----*----*----*----*----*----*----*----*----*----*----*----*----

; Read run 3 direct beam----------------------------
	widget_control,txt(2),get_value=val
	dtb3=getnumors(val(0))
; If eflag (error flag) is not zero or 4 (=empty array) then signal error
; empty arrays are allowed for runs 2 and 3 so long as both db and ref are empty
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Direct beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Direct beam'
		return
	end
		
; Read run 3 reflected beam-----------------------
	widget_control,txt(7),get_value=val
	refl3=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Reflected beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Reflected beam'
		return
	end
		
; If only 1 field is entered then signal error
	if ((dtb3[0] eq 0) and (refl3[0] ne 0)) or ((dtb3[0] ne 0) and (refl3[0] eq 0)) then begin 
	errormessage,'Incomplete fields:Run 3 (Enter both DB and REF or neither).'
	return
	end
	
; Read run 2 direct beam-------------------------
	widget_control,txt(1),get_value=val
	dtb2=getnumors(val(0))
; errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Direct beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Direct beam'
		return
	end
		
; Read run 2 reflected beam---------------------
	widget_control,txt(6),get_value=val
	refl2=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Reflected beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Reflected beam'
		return
	end
		
; If only 1 field is entered then signal error
	if ((dtb2[0] eq 0) and (refl2[0] ne 0)) or ((dtb2[0] ne 0) and (refl2[0] eq 0)) then begin 
	errormessage,'Incomplete fields:Run 2 (Enter both DB and REF or neither).'
	return
	end
	
; Read run 1 direct beam-----------------------
	widget_control,txt(0),get_value=val
	dtb1=getnumors(val(0))
; errors: note that eflag=4 (=no numors) is an error for run 1
	if eflag ne 0 then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Direct beam'
		if eflag eq 4 then errormessage,'Missing direct beam numors: Run 1'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Direct beam'
		return
	end
		
; Read run 1 reflected beam
	widget_control,txt(5),get_value=val
	refl1=getnumors(val(0))
; errors: note that eflag=4 (=no numors) is an error for run 1
	if eflag ne 0 then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Reflected beam'
		if eflag eq 4 then errormessage,'Missing reflected beam numors: Run 1'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Reflected beam'
		return
	end

; Read run 1 Instrument background
	widget_control,txt(10),get_value=val
	instbg1=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Instrument background'
		return
	end
	
; Read run 2 Instrument background
	widget_control,txt(11),get_value=val
	instbg2=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Instrument background'
		return
	end
; return error if Inst. BG set, but no direct beam/reflect runs set
	if (instbg2[0] ne 0) and (refl2[0] eq 0) then begin
		errormessage,'Inst. BG set but Direct beam/Reflected beam numors missing: Run 2.'
		return
	end
	
; Read run 3 Instrument background
	widget_control,txt(12),get_value=val
	instbg3=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Instrument background'
		return
	end
; return error if Inst. BG set, but no direct beam/reflect runs set
	if (instbg3[0] ne 0) and (refl3[0] eq 0) then begin
		errormessage,'Inst. BG set but Direct beam/Reflected beam numors missing: Run 3.'
		return
	end	
; read water files
	widget_control,txt(3),get_value=val
; If 'def' is entered then set water=0 so that water file reading code knows to look
; for the default file
	if val[0] eq 'def' then water=0 else begin
		water=getnumors(val[0])
; errors: note that eflag=4 (=no numors) just means use default (signalled by 1st element of array 'water'
; being zero)
		if (eflag ne 0) and (eflag ne 4) then begin
			if eflag eq 1 then errormessage,'Illegal formatting:Water files'
			if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Water files'
			if eflag eq 3 then errormessage,'Illegal character:Water files'
			if eflag eq 5 then errormessage,'Invalid range (end<beginning): Water files'
		return
		end
	endelse
		
	lamda=convert(txt(4),1,0,2,0,1,1)

	path=convert(txt(8),0,0,0,1,0,0)
	
	fil=convert(txt(9),0,0,0,1,0,0)
	
	th1=convert(txt(19),1,0,0,0,0,0)
	th2=convert(txt(20),1,0,0,0,0,0)
	th3=convert(txt(21),1,0,0,0,0,0)
	
	r=convert(txt(13),0,1,0,0,0,0)
; check that foreground width isn't negative
	if r[1] lt 0 then begin
		errormessage,'Negative foreground width!'
		return
	end
	
;*******************************
; Quick sloppy fix coming up...
;*******************************

; convert returns either a single integer, or if a comma is supplied a 3 (for some reason...) array
; with the second and third elements containing the first (width) and second (shift) integers.
; Convert should really return a structure!!
	leftbg=convert(txt(14),0,1,2,0,1,0)
; Code below strips the leading 0 for a 3-array
	leftbg=[leftbg[1],leftbg[2]]
; Unfortunately have to do same sloppy manipulation for right hand side
	rightbg=convert(txt(18),0,1,2,0,1,0)
	rightbg=[rightbg[1],rightbg[2]]
; Now have two background arrays :leftbg[width,shift] rightbg[width,shift]. Concatenate
; these as single bg array to pass to anal2ysis
	bg=[leftbg,rightbg]
; bg[leftwidth,leftshift,rightwidth,rightshift]
; Yeuch.... that was messy

; check that all background shifts/widths to left and right are positive
	if (bg[0] lt 0) or (bg[1] lt 0) or (bg[2] lt 0) or (bg[3] lt 0) then begin
		errormessage,'Negative background width/shift!'
		return
	end
; Now do same for useful area of detector and peak search area:
	useful=convert(txt(22),0,1,2,0,1,0)
	useful=[useful[1],useful[2]]
	if (useful[0] lt 0) or (useful[1] gt 286) then begin
		errormessage,'Useful area of detector outside of physical size (0,286) of detector!'
		return
	end
	peak_searchx=convert(txt(23),0,1,2,0,1,0)
	peak_searchx=[peak_searchx[1],peak_searchx[2]]

	if (peak_searchx[0] lt useful[0]) or (peak_searchx[1] gt useful[1]) then begin
		errormessage,'Peak search x range is outside useful area of detector'
		return
	end

; if y range is set to "def" then set the range to -1,-1 so that the correct
; default range can be put in when the numors are read and their size is known
	widget_control,txt(24),get_value=temp
	if temp[0] EQ 'def' then peak_searchy=[-1,-1] else begin
		peak_searchy=convert(txt(24),0,1,2,0,1,0)
		peak_searchy=[peak_searchy[1],peak_searchy[2]]
		if (peak_searchy[0] lt 0) or (peak_searchy[1] gt 500) then begin
			errormessage,'Peak search y is outside y range (0,500)'
			return
		end
	end
	


	fac1=convert(txt(15),1,0,0,0,0,0)
	fac2=convert(txt(16),1,0,0,0,0,0)
	fac3=convert(txt(17),1,0,0,0,0,0)

;sets variable to the value of button widget in TOF window 
	widget_control,but(0),get_value=norm
	widget_control,but(1),get_value=bgrd


;if any errors in datat then appropriate message is displayed by calling 'pro errormessage'
	if flag0 eq 1 then errormessage,'Invalid ranges'
	if flag1 eq 1 then errormessage,'Incomplete fields'	
	if flag2 eq 1 then errormessage,'Field must be a number'	
	if flag3 eq 1 then errormessage,'Field must be integer'	
	if flag4 eq 1 then errormessage,'Comma expected'	
	if flag5 eq 1 then errormessage,'Default not available'	
	if flag6 eq 1 then errormessage,'Must complete all fields for given run set'	

;if there are no errors then proceed with anal2ysis
	if (flag0 eq 0) and (flag1 eq 0) and (flag2 eq 0) and (flag3 eq 0) and (flag4 eq 0) and (flag5 eq 0) and (flag6 eq 0) then begin

;renders TOF window insensitive
		widget_control,base,sensitive=0
		close,10

; write contents of text widgets (which have been checked above) into the default file tof_defaults.dat
		openw,10,'tof_defaults.dat'
		printf,10,'Direct beam runs (1)'
		widget_control,txt(0),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Direct beam runs (2)'
		widget_control,txt(1),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Direct beam runs (3)'
		widget_control,txt(2),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (1)'
		widget_control,txt(5),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (2)'
		widget_control,txt(6),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (3)'
		widget_control,txt(7),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (1)'
		widget_control,txt(10),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (2)'
		widget_control,txt(11),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (3)'
		widget_control,txt(12),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Water (Efficiency) file'
		widget_control,txt(3),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Wavelength range'
		widget_control,txt(4),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (1)'
		widget_control,txt(19),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (2)'
		widget_control,txt(20),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (3)'
		widget_control,txt(21),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (1)'
		widget_control,txt(15),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (2)'
		widget_control,txt(16),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (3)'
		widget_control,txt(17),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Foreground range'
		widget_control,txt(13),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Left Background range'
		widget_control,txt(14),get_value=tempstring
		printf,10,tempstring		
		printf,10,'Right Background range'
		widget_control,txt(18),get_value=tempstring
		printf,10,tempstring
		printf,10,'Normalisation method'
		printf,10,norm
		printf,10,'Method to determine background'
		printf,10,bgrd
		printf,10,'Output filename'
		widget_control,txt(9),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Data Path'
		widget_control,txt(8),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Useful x range on detector'
		widget_control,txt(22),get_value=tempstring		
		printf,10,tempstring
		printf,10,'X range to find peak in'
		widget_control,txt(23),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Y range to find peak in'
		widget_control,txt(24),get_value=tempstring		
		printf,10,tempstring
		close,10
;if default was selected then use default water file, 'water_LAMPascii'
		if water[0] eq 0 then begin
		
			print,' '
			print,' '
			print,'Reading default Water file, ''water_LAMPascii''...'
			w3=make_array(3,286,type=4)

;check default file exists
			filcheck=findfile('water_LAMPascii',count=checkfil)
			if checkfil eq 0 then begin 
; Default water file does not exist
				print,'Default water file water_LAMPascii does not exist. No water correction!'
				w2=make_array(1,286,type=4)
				w2[*]=1.0
			endif else begin

			close,4
			openr,4,"water_LAMPascii"
     			readf,4,w3
;makes it 1-D array
			w2=w3(1,*)
			close,4
;			print,'min water=',min(w2),'max water= ',max(w2)
			end
		endif else begin
;otherwise call 'pro data_read2' to read water files entered
			print,' '
			print,' '
			print,'Reading Water files...'
			watersum=0
;loop data_read2 for each file and sum detector counts (water)

			for i=0,N_ELEMENTS(water)-1 do begin
				data_read2,water[i],wat
			; return if an error occured during reading
				if eflag ne 0 then return
				watersum=wat+watersum
			endfor
;call 'pro awater' to set the size of the array corresponding to the useful size of the detector
			awater,watersum,w2
		endelse
				
;run set (1) 
		print,' '
		print,' '
		print,'Reading data files for set (1)...'

;form summed direct beam array
		print,' '
		print,'for direct beam...'
		db1sum=0
		db1monsum=0
		db1timesum=0
;loop data_read2 for each file and sum detector counts (db*), monitor counts (db*mon) and runtime (db*time) also take detector angle (dbdan*)
		for i=0,N_ELEMENTS(dtb1)-1 do begin
			data_read2,dtb1[i],db1,db1mon,db1time,dbdan1
		; return if an error occured during reading
			if eflag ne 0 then return
			db1sum=db1+db1sum
			db1monsum=db1mon+db1monsum
			db1timesum=db1time+db1timesum
		endfor

;create error array for summed detector counts
		erdb1=sqrt(db1sum)

; output the time-> lambda conversion array
	CLOSE,10
	OPENW,10,'a1_lambda_convert.dat'
	PRINTF,10,'Pixel,   Wavelength (Angstroms)'
	FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
	CLOSE,10
		
;form summed reflected beam array
		print,' '
		print,'for reflected beam...'
		ref1sum=0
		ref1monsum=0
		ref1timesum=0
; store SAN angles into an array for comparison with calculated value
		san=fltarr(N_ELEMENTS(refl1))
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
		for i=0,N_ELEMENTS(refl1)-1 do begin
			data_read2,refl1[i],ref1,ref1mon,ref1time,refdan1
; store SAN (par2[2]) into sans array
			san[i]=par2[2]
		; return if an error occured during reading
			if eflag ne 0 then return
			ref1sum=ref1+ref1sum
			ref1monsum=ref1mon+ref1monsum
			ref1timesum=ref1time+ref1timesum
		endfor
;create error array for summed detector counts
		erref1=sqrt(ref1sum)

; If ther are instrument backgrounds to be subtracted then read and sum these
		if instbg1[0] ne 0 then begin
;form summed reflected beam array
		print,' '
		print,'for Instrument background...'
		instbg1sum=0
		instbg1monsum=0
		instbg1timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
		for i=0,N_ELEMENTS(instbg1)-1 do begin
			print,instbg1
			data_read2,instbg1[i],instbgd1,instbg1mon,instbg1time,instbgdan1
	; return if an error occured during reading
			if eflag ne 0 then return
			instbg1sum=instbgd1+instbg1sum
			instbg1monsum=instbg1mon+instbg1monsum
			instbg1timesum=instbg1time+instbg1timesum
		endfor
;create error array for summed detector counts
		erinstbg1=sqrt(instbg1sum)
		end

; NORMALISE REFLECTED AND BACKGROUND RUNS TO THE DIRECT BEAM
		print,'Normalising....'		
;(norm=0) normalise summed reflected beam (normref*sum) to runtime 
		if norm eq 0 then begin
			normref1sum=ref1sum*(db1timesum/ref1timesum)
			normerref1sum=(db1timesum/ref1timesum)*erref1
; do same for Instrument backgrounds if they are present
			if instbg1[0] ne 0 then begin
				norminstbg1sum=instbg1sum*(db1timesum/instbg1timesum)
				normerinstbg1sum=(db1timesum/instbg1timesum)*erinstbg1
			end
		endif
;(norm=1) normalise summed reflected beam (normref*sum) to monitor 
		if norm eq 1 then begin
			normref1sum=ref1sum*(db1monsum/ref1monsum)
			normerref1sum=(db1monsum/ref1monsum)*erref1
; do same for Instrument backgrounds if they are present
			if instbg1[0] ne 0 then begin
				norminstbg1sum=instbg1sum*(db1monsum/instbg1monsum)
				normerinstbg1sum=(db1monsum/instbg1monsum)*erinstbg1
			end
		endif

; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg1[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref1sum=normref1sum-norminstbg1sum
			normerref1sum=sqrt(normerref1sum^2+normerinstbg1sum^2)
			db1sum=db1sum-norminstbg1sum
			erdb1=sqrt(erdb1^2+normerinstbg1sum^2)
		end
		
		print,' '
		print,' '
		print,'anal2ysing data files for set (1)...'

;call 'pro anal2' to create Reflectivity data
;returns w*=Reflectivity, x*=q, e*=Reflectivity error, qe*=q resolution
		anal3,db1sum,erdb1,dbdan1,normref1sum,normerref1sum,refdan1,w2,r(1),bg,w5,x5,e5,qe5,lamda,th1,san[0]
; if an error was signalled then restart
		if eflag ne 0 then return
;if default factor was selected then use fac1=1
		if fac1(0) eq 1 then fac1(1)=1.

;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th1[1] gt 0.1) or (san[i]-th1[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 1:Difference between calculated theta and SAN of numor '+strtrim(string(refl1[i]),2)+' is greater than 0.1'
			end
		endfor
		
		print,' '
		print,'...done set (1)'

;multiply Ref and Referr by fac
		w5=fac1(1)*w5
		e5=fac1(1)*e5

;find number of points
		z5=size(e5)

;sort data in order of increasing q and call arrays *s
		xs=x5(sort(x5))
		ws=w5(sort(x5))
		es=e5(sort(x5))
		qes=qe5(sort(x5))

;if 2 run sets were entered then 1st element of dtb2 is not zero
		if dtb2[0] ne 0 then begin

;run set (2) 
			print,' '
			print,' '
			print,'Reading data files for set (2)...'
				
			print,' '
			print,'for direct beam...'
			db2sum=0
			db2monsum=0
			db2timesum=0
			for i=0,N_ELEMENTS(dtb2)-1 do begin
				data_read2,dtb2[i],db2,db2mon,db2time,dbdan2
			; return if an error occured during reading
				if eflag ne 0 then return
				db2sum=db2+db2sum
				db2monsum=db2mon+db2monsum
				db2timesum=db2time+db2timesum
			endfor
			erdb2=sqrt(db2sum)

; output the time-> lambda conversion array
		CLOSE,10
		OPENW,10,'a2_lambda_convert.dat'
		PRINTF,10,'Pixel,   Wavelength (Angstroms)'
		FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
		CLOSE,10

			print,' '
			print,'for reflected beam...'
			ref2sum=0
			ref2monsum=0
			ref2timesum=0
			
			san=fltarr(N_ELEMENTS(refl2))
			for i=0,N_ELEMENTS(refl2)-1 do begin
				data_read2,refl2[i],ref2,ref2mon,ref2time,refdan2
				san[i]=par2[2]
			; return if an error occured during reading
				if eflag ne 0 then return
				ref2sum=ref2+ref2sum
				ref2monsum=ref2mon+ref2monsum
				ref2timesum=ref2time+ref2timesum
			endfor
			erref2=sqrt(ref2sum)
			
; If ther are instrument backgrounds to be subtracted then read and sum these
			if instbg2[0] ne 0 then begin
;form summed reflected beam array
			print,' '
			print,'for Instrument background...'
			instbg2sum=0
			instbg2monsum=0
			instbg2timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
			for i=0,N_ELEMENTS(instbg2)-1 do begin
				data_read2,instbg2[i],instbgd2,instbg2mon,instbg2time,instbgdan2
			; return if an error occured during reading
				if eflag ne 0 then return
				instbg2sum=instbgd2+instbg2sum
				instbg2monsum=instbg2mon+instbg2monsum
				instbg2timesum=instbg2time+instbg2timesum
			endfor
;create error array for summed detector counts
			erinstbg2=sqrt(instbg2sum)
			end

			print,'Normalising....'
			if norm eq 0 then begin
				normref2sum=ref2sum*(db2timesum/ref2timesum)
				normerref2sum=(db2timesum/ref2timesum)*erref2
; do same for Instrument backgrounds if they are present
				if instbg2[0] ne 0 then begin
					norminstbg2sum=instbg2sum*(db2timesum/instbg2timesum)
					normerinstbg2sum=(db2timesum/instbg2timesum)*erinstbg2
				end
			endif
			if norm eq 1 then begin
				normref2sum=ref2sum*(db2monsum/ref2monsum)
				normerref2sum=(db2monsum/ref2monsum)*erref2
; do same for Instrument backgrounds if they are present
				if instbg2[0] ne 0 then begin
					norminstbg2sum=instbg2sum*(db2monsum/instbg2monsum)
					normerinstbg2sum=(db2monsum/instbg2monsum)*erinstbg2
				end
			endif	
			
; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg2[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref2sum=normref2sum-norminstbg2sum
			normerref2sum=sqrt(normerref2sum^2+normerinstbg2sum^2)
			db2sum=db2sum-norminstbg2sum
			erdb2=sqrt(erdb2^2+normerinstbg2sum^2)
		end

			print,' '
			print,' '
			print,'anal2ysing data files for set (2)...'

			anal3,db2sum,erdb2,dbdan2,normref2sum,normerref2sum,refdan2,w2,r(1),bg,w6,x6,e6,qe6,lamda,th2,san[0]
; if an error was signalled then restart
			if eflag ne 0 then return

;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th2[1] gt 0.1) or (san[i]-th2[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 2:Difference between calculated theta and SAN of numor '+strtrim(string(refl2[i]),2)+' is greater than 0.1'
			end
		endfor
			
;if default factor was selected then call 'function factor' to match the Reflectivity curve from set (2) to that of set (1)
			if fac2(0) eq 1 then fac2(1)=factor(w5,w6,x5,x6,e5,e6)
;fac*=0 implies no overlap between the Ref curves
			if fac2(1) eq 0. then begin
				print,' '
				print,'No Overlap between (1) & (2)'
			endif
				
			print,' '
			print,'...done set (2)'

			w6=fac2(1)*w6
			e6=fac2(1)*e6
			z6=size(e6)

;create single arrays combining set (1) and (2) for Ref,q,Referr,qres
			x=fltarr(z5(1)+z6(1))
			w=fltarr(z5(1)+z6(1))
			e=fltarr(z5(1)+z6(1))
			qe=fltarr(z5(1)+z6(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			
			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))
			
		endif
			
;if 3 run sets were entered then 1st element of dtb3 is not 0
		if dtb3[0] ne 0 then begin

;run set (3) 
			print,' '
			print,' '
			print,'Reading data files for set (3)...'

			print,' '
			print,'for direct beam...'
			db3sum=0
			db3monsum=0
			db3timesum=0
			for i=0,N_ELEMENTS(dtb3)-1 do begin
				data_read2,dtb3[i],dbd3,db3mon,db3time,dbdan3
			; return if an error occured during reading
				if eflag ne 0 then return
				db3sum=dbd3+db3sum
				db3monsum=db3mon+db3monsum
				db3timesum=db3time+db3timesum
			endfor
			erdb3=sqrt(db3sum)

; output the time-> lambda conversion array
			CLOSE,10
			OPENW,10,'a3_lambda_convert.dat'
			PRINTF,10,'Pixel,   Wavelength (Angstroms)'
			FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
			CLOSE,10

			print,' '
			print,'for reflected beam...'
			ref3sum=0
			ref3monsum=0
			ref3timesum=0
			
			san=fltarr(N_ELEMENTS(refl3))
			for i=0,N_ELEMENTS(refl3)-1 do begin
				data_read2,refl3[i],ref3,ref3mon,ref3time,refdan3
				san[i]=par2[2]
			; return if an error occured during reading
				if eflag ne 0 then return
				ref3sum=ref3+ref3sum
				ref3monsum=ref3mon+ref3monsum
				ref3timesum=ref3time+ref3timesum
			endfor
			erref3=sqrt(ref3sum)
			
; If ther are instrument backgrounds to be subtracted then read and sum these
			if instbg3[0] ne 0 then begin
;form summed reflected beam array
			print,' '
			print,'for Instrument background...'
			instbg3sum=0
			instbg3monsum=0
			instbg3timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
			for i=0,N_ELEMENTS(instbg3)-1 do begin
				data_read2,instbg3[i],instbgd3,instbg3mon,instbg3time,instbgdan3
			; return if an error occured during reading
				if eflag ne 0 then return
				instbg3sum=instbgd3+instbg3sum
				instbg3monsum=instbg3mon+instbg3monsum
				instbg3timesum=instbg3time+instbg3timesum
			endfor
;create error array for summed detector counts
			erinstbg3=sqrt(instbg3sum)
			end

			print,'Normalising....'

			if norm eq 0 then begin
				normref3sum=ref3sum*(db3timesum/ref3timesum)
				normerref3sum=(db3timesum/ref3timesum)*erref3
; do same for Instrument backgrounds if they are present
				if instbg3[0] ne 0 then begin
					norminstbg3sum=instbg3sum*(db3timesum/instbg3timesum)
					normerinstbg3sum=(db3timesum/instbg3timesum)*erinstbg3
				end

			endif
			if norm eq 1 then begin
				normref3sum=ref3sum*(db3monsum/ref3monsum)
				normerref3sum=(db3monsum/ref3monsum)*erref3
; do same for Instrument backgrounds if they are present
				if instbg3[0] ne 0 then begin
					norminstbg3sum=instbg3sum*(db3monsum/instbg3monsum)
					normerinstbg3sum=(db3monsum/instbg3monsum)*erinstbg3
				end

			endif
			
; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg3[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref3sum=normref3sum-norminstbg3sum
			normerref3sum=sqrt(normerref3sum^2+normerinstbg3sum^2)
			db3sum=db3sum-norminstbg3sum
			erdb3=sqrt(erdb3^2+normerinstbg3sum^2)
		end

			print,' '
			print,' '
			print,'anal2ysing data files for set (3)...'

			anal3,db3sum,erdb3,dbdan3,normref3sum,normerref3sum,refdan3,w2,r(1),bg,w7,x7,e7,qe7,lamda,th3,san[0]
; if an error was signalled then restart
			if eflag ne 0 then return
			
;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th3[1] gt 0.1) or (san[i]-th3[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 3:Difference between calculated theta and SAN of numor '+strtrim(string(refl3[i]),2)+' is greater than 0.1'
			end
		endfor

;if default factor was selected then call 'function factor' to match the Reflectivity curve from set (3) to that of set (2)
			if fac3(0) eq 1 then fac3(1)=factor(w6,w7,x6,x7,e6,e7)
			if fac3(1) eq 0. then begin
				print,' '
				print,'No Overlap between (2) & (3)'
			endif

			print,' '
			print,'...done set (3)'

			w7=fac3(1)*w7
			e7=fac3(1)*e7
			z7=size(e7)

			x=fltarr(z5(1)+z6(1)+z7(1))
			w=fltarr(z5(1)+z6(1)+z7(1))
			e=fltarr(z5(1)+z6(1)+z7(1))
			qe=fltarr(z5(1)+z6(1)+z7(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			for i=(z5(1)+z6(1)),(z5(1)+z6(1)+z7(1)-1) do begin
				x(i)=x7(i-z5(1)-z6(1))
				w(i)=w7(i-z5(1)-z6(1))
				e(i)=e7(i-z5(1)-z6(1))
				qe(i)=qe7(i-z5(1)-z6(1))
			endfor

			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))

		endif

;remove all bad points from the arrays and call arrays *c (corrected)
		ec=es(where(es))
		qec=qes(where(es))
		xc=xs(where(es))
		wc=ws(where(es))
		
;for the purposes of the output file: If default water file is specified then
; redefine water as a string containing the name of the default water file
		if water[0] eq 0 then water='water_LAMPascii'

;check that output file has a valid name
		catch,outfilcheck
		if outfilcheck ne 0 then begin
;set eflag to non-zero to signal error
			eflag=10
			errormessage,'Invalid output file name: '''+strcompress(string(fil(1)),/remove_all)+''''
			catch,/cancel
		endif

;print data info at top of output file
		close,10
		openw,10,fil(1),width=128
		printf,10,' db1:',dtb1
		printf,10,' ref1:',refl1,' th1:',th1(1),' fac1:',fac1(1)
; only print run 2 stuff if there actually is a run 2
		if dtb2[0] ne 0 then begin
			printf,10,' db2:',dtb2
			printf,10,' ref2:',refl2,' th2:',th2(1),' fac2:',fac2(1)
		end
; only print run3 stuff if there is a run 3
		if dtb3[0] ne 0 then begin
			printf,10,' db3:',dtb3
			printf,10,' ref3:',refl3,' th3:',th3(1),' fac3:',fac3(1)
		end
		printf,10,' water:',water,' lamda:',lamda(1),lamda(2),' fgrd:',r(1),' bgrd:',bg
		
 		close,10
		catch,/cancel
		
;run 'pro endmessage' giving the details of the calculated parameters
		endmessage

;run 'pro output' listing the arrays to the output file and plotting the full Reflectivity curve
		output,xc,wc,ec,qec,fil(1)

	endif		

endif

return

end



;************************************************************************************
;reads data for each file (num,int), gives det counts (w1), monitor counts (w2)
; runtime, detector angle (dan)

pro data_read2,num,w1,w2,runtime,dan


; takes a data numor and opens the file, reads paramter blocks and comes back with
; the lambda array for TOF (lamarr) the detector array (w1) the monitor array (w2)

common EFLAGS,eflag
common vars0,def
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3
common varpath,path
common par,par2

;reset error flag
eflag=0

close,3

; floating point arrays of 128 and 256 elements
par1 = fltarr(128)
par2 = fltarr(256)

; string array of 34 elements
txt=sindgen(34)
; set all 34 elements to XXX....
txt(*)='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
txt1=txt(1)

;converts num(int) to 6 digit string with trailing zeroes
name='000000'				;make six digit string of 0's
tempnum=strtrim(string(num),2)		;convert num to string and trim all blank spaces
strput,name,tempnum,6-strlen(tempnum)	;put these digits in occupying the last strlen(tempnum) places of name
name=path(1)+name			; include path in name

;check to see if numor exists
filcheck=findfile(name,count=checkfil)		
; If not signal error and return
if checkfil eq 0 then begin 
	eflag=7
	errormessage,'File not found: '+name
	return
end

; inform user of status and open file (handle=3)
openr,3,name
print,'opened: ',name

; read in 34 lines of text
readf,3,txt
; output 5th and 26th lines (text)
;print,txt(4)
;print,txt(25)

; read 128 floats (2nd block of numbers in file, 1st block is ignored by code above)
readf,3,par1
; read the two line spacer
readf,3,txt1
readf,3,txt1
;read 256 numbers 
readf,3,par2

; degrees per radian
dpr=180./!pi

;output useful information
;print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
;print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
nx=par1(101)

; print out chopper speeds and openings  nx and ny are the detector grouping factors
; ie base detector is 286*276 if nx=2 and ny=1 then detector is 144*276

;print,'nx= ',par1(101),' ny= ',par1(102)
;print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
;print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
;print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
;print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)

; useful chopper variables openr is the requested chopper opening and opena is the read back value
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))

;!chopper opening offset=1.02!
opena=opena-1.02

; chopper period in seconds
period=60./par2(44)

; chopper delay angle between pickup and centre of projected window
;dela=(284.3-opena)/2.

dela=(279.4-opena)/2.
; delt is the chopper delay time in seconds
delt=(dela/360.)*period

; cht is hardwired chopper separation in m
cht=85.e-3

; chopsam is the sample to mid-chopper distance in meters
;chopsam=3.8675-(cht)/2.
chopsam=4.1685-(cht)/2.
; chopmon is the monitor to detector distance
chopmon=.455

; tofd is the time- of flight distance from mid-chopper to detector par2(15) is
; the sample to detector distance in mm
tofd=chopsam+(par2(15)/1000.)

;chanpa is the number of time channels per angstrom for the detector (neutron wavelength) 
chanpa=(tofd/3956.)/(par1(95)*1.e-6)

;chanpam is the number of time channels per angstrom for the monitor (neutron wavelength
chanpam=(chopmon/3956.)/(par1(95)*1.e-6)

; r is the time grouping factor between the monitor and the detector (not used at present
;as we measure the direct beam on the detector and use the monitor just for normalisation

r=chopsam/tofd

; chopper delay in time channels
delchan=delt/(par1(95)*1e-6)

; electronic delay (set by par tof in MAD) in channels
delechan=par1(96)/par1(95)

;printing out useful stuff
;print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
;print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
;print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
;print,'opening      req= ',openr,' opening      act= ',opena
;print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
;print,'     san= ',par2(2),' deg.'
;print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa

runtime=par1(2)/10.

;print,'run time= ',runtime,' s',' det= ',par2(15),'dan = ',par2(16)

;dan is the detector angle and dett is the sample-detector distance
dan=par2(16)
dett=par2(15)

; Now we can read the data -first read 3 spacer lines
readf,3,txt1
readf,3,txt1
readf,3,txt1

;read total number pixels in detector
readf,3,tot

;set size of arrays (usually in TOF ysize is 1 i.e we have xpxels*time channels only)
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize

;signal error if total number of pixels isn't equal to xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'

;print,'tsize= ',tsize,' detector size= ',dsize
;print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

;set up an array of long integers with specified size
det=lonarr(ysize,xsize,tsize)
; usually pixels are summed in physical y direction of detector-> only 2d
if (ysize eq 1) then det=lonarr(xsize,tsize)

; set up monitor arrray. Monitor is basically an extra line of pixels at the end
; of the data
mon=lonarr(tsize)

;2x2 arrays of data
xy=lonarr(xsize,ysize)
xt=lonarr(xsize,tsize)
yt=lonarr(ysize,tsize)

c=1

;read detector data and monitor data from file
readf,3,det

s2=par2(54)
s3=par2(50)

nx=par1(101)

;millimeters per pixel
mmpp=1.0213*nx

;useful area of det in pixels
xminp=16
xmaxp=255
; convert to useful area in mm
xminmm=xminp*mmpp
xmaxmm=xmaxp*mmpp


;make lamda array- conversion between time and wavelength
yy=findgen(tsize)		;generates  floating point array with sequence 0.0,1.0,2.0, e.t.c
lamarr=(yy+delechan-delchan+0.5)/chanpa

; convert data to floating point in w1
w1=float(det)
; add up total monitor counts
w2=par1(4)

close,3
; print total monitor counts and monitor counts per unit time
;print,'total counts in detector = ',total(w1),' (',total(w1)/runtime,')'

return

end


;*********************************************************************************************************
;sets water file (w1) to 1 outside useful area of det and returns w2

pro awater,w1,w2

xsize=286
w2=fltarr(xsize)

;useful area of det (x,y) 37:238,30:248
x1=20 & x2=255
w2=float(total(w1,2))

; normalise water
w2=w2/(mean(w2(x1:x2)))
; set anything outside usefule area to 1
w2(0:x1-1)=1. & w2(x2+1:xsize-1)=1.
;print,'Max water=',max(w2),'Min water=',min(w2)
return

end

;***************************************************************************************************
;calculates theta

function tth,d0,p0,dr,pr,nx,det

dpr=180./!pi

pcen=138.98/nx
mmpp=1.0213*nx

print,' '
print,'pcen= ',pcen
print,'mmpp= ',mmpp, 'dpr= ',dpr,' dr= ',dr,' pr= ',pr,' det= ',det,' d0= ',d0
print,'p0= ',p0

th=abs((dr+dpr*atan((pcen-pr)*mmpp/det))/2.-(d0+dpr*atan((pcen-p0)*mmpp/det))/2.)
print,'calculated theta= ',th


return,th

end


;********************************************************************************************
;anal2yses data, db=direct beam counts, dber=error on direct beam counts, dbdan=detector angle for direct beam, ref=reflected beam counts, refer=error on reflected beam counts, refdan=detector angle for reflected beam, water=detector counts for watef, r=forground range, bg=background range, wdum=Reflectivity, xdum=q, edum=Reflectivity error, qedum=q resolution, lamda=lamda range, th=theta

pro anal3,db,dber,dbdan,ref,refer,refdan,water,rr,bg,wdum,xdum,edum,qedum,lamda,th,san

wdum=0
xdum=0
edum=0
qedum=0

; Common block for error flag
common EFLAGS,eflag
common par,par2
common vars0,def
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3
common varbg,bgrd

; common block for useful xrange of detector and area to find peak in
common detranges,useful,peak_searchx,peak_searchy

; reset error flag: no errors
eflag=0

; db is the direct beam run
; ref is the reflection run
; water is the x effiency of the detector
; q is the array of q(A^-1)
; rr is the range over which to sum the intensity
; bg is the range to sum the background either side of r
; w5 is the output reflectivity with the q (x5) and error (e4)
; fac is the normalisation factor for w2 reflection data ie
; divide the ref data by this to make it normalised to the direct beam

;print,'TOTALS REF DB',total(ref),total(db)


ref1=ref
ref2=ref
db1=db
db2=db
edb=db
ere=ref

; get useful area of detector from common block variable
xmax=useful[1]
xmin=useful[0]

mmpp=1.0213*nx

catch,erranal2
if erranal2 ne 0 then begin
	errormessage,'Error anal2ysing data: check settings and try again'
	catch,/cancel
endif

;place info of array db (direct beam data) into z.
;z[0]=no dimensions, z[1]=1st dimension, z[2]=2nd dim, z[3]= type
; z[5]=tot. number of elements
z=size(db)
;print,' '
;print,'db size: ',z(2)
;print,'MEAN WATER',mean(water)

;water correction
for i=0,z(2)-1 do begin
	db1(*,i)=db(*,i)/water
	dber(*,i)=dber(*,i)/water
	ref1(*,i)=ref(*,i)/water
	refer(*,i)=refer(*,i)/water
endfor

;print,' '
;print,'done water correction'

;print,'TOTALS REF DB AFTER WATER',total(ref1),total(db1)

; limit area to search peak to user defined values
x1=peak_searchx[0] & x2=peak_searchx[1]

; if "def" is entered in y range then get the values from the size of the data
if peak_searchy[0] eq -1 then begin
	t1=fix(float(z[2])/2.) & t2=z[2]-1 
endif else begin
	t1=peak_searchy[0] & t2=peak_searchy[1]
end

;sum direct beam data along columns:
; restricted range sum
dbtot=total(db1(x1:x2,t1:t2),2)
; whole sum
dbtot2=total(db1,2)
; max. of direct beam data. pixel number is put in dbm
dbtotm=max(dbtot2,dbm)
; add resttricted range offset to dbm
;dbm=dbm+x1
;print,'direct beam peak at: ',dbm

;calculate summation ranges: rr=width of foreground sum
f1=dbm-fix((rr-1)/2)
f2=dbm+fix((rr-1)/2)
;print,'sum ranges for db: ',f1,f2

;Centre Of Mass calculation for db
numersum=0.
denomsum=0.
for i=f1,f2 do begin
	numer=dbtot2(i)*float(i)
	denom=dbtot2(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
;print,'db stuff:', numersum,denomsum
dbcom=numersum/denomsum
;print,'fitted db peak at: ',(dbcom)

;check to see if peak value is near centre of mass if it isn't set it to
; the centre of mass
if fix(dbcom+0.5) ne dbm then dbm=fix(dbcom+0.5)

; redo foreground calculation
f1=dbm-fix((rr-1)/2)
f2=dbm+fix((rr-1)/2)

print,format='("Direct beam sum ranges: Foreground      :",3x,i3,1x,i3)',f1,f2
if bg[0] ne 0 then print,format='(24x,"Background left :",3x,i3,1x,i3)',f1-bg[0]-bg[1],f1-1-bg[1]
if bg[2] ne 0 then print,format='(24x,"Background right:",3x,i3,1x,i3)',f2+bg[2]+bg[3],f2+1+bg[3]
;print,'corrected db peak at: ',dbm

;  finding the peak in the reflection over a limited range 150:230 in x
;and 200 to the max in time channels

reftot=total(ref1(x1:x2,t1:t2),2)
reftot2=total(ref1,2)
reftotm=max(reftot,refm)
refm=refm+x1
;print,'peak in reflection at: ',refm


ff1=refm-fix((rr-1)/2)
ff2=refm+fix((rr-1)/2)
;print,'sum ranges for ref: ',ff1,ff2
;COM for ref
numersum=0.
denomsum=0.

for i=ff1,ff2 do begin
	numer=reftot2(i)*float(i)
	denom=reftot2(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
refcom=numersum/denomsum
;print,'ref stuff:', numersum,denomsum
;print,'ref peak at: ',(refcom)
if fix(refcom+0.5) ne refm then refm=fix(refcom+0.5)
;print,'corrected ref peak at: ',refm
ff1=refm-fix((rr-1)/2)
ff2=refm+fix((rr-1)/2)


print,' '
print,format='("Ref.   beam sum ranges: Foreground      :",3x,i3,1x,i3)',ff1,ff2
if bg[0] ne 0 then print,format='(24x,"Background left :",3x,i3,1x,i3)',ff1-bg[0]-bg[1],ff1-1-bg[1]
if bg[2] ne 0 then print,format='(24x,"Background right:",3x,i3,1x,i3)',ff2+bg[2]+bg[3],ff2+1+bg[3]

;print,'ref peak at: ',(refcom)

;print,'f1 f2 ff1 ff2',f1,f2,ff1,ff2

; Check that background sum isn't outside range of detector. NB For left side bg[0] is width, bg[1] is shift from edge
; of foreground sum. Similar thing for right in bg[2] and bg[3]
if ((f1-bg[0]-bg[1]) lt xmin) or ((f2+bg[2]+bg[3]) gt xmax) or ((ff1-bg[0]-bg[1]) lt xmin) or ((ff2+bg[2]+bg[3]) gt xmax) then begin
  eflag=6
  errormessage,'Outside useful area of detector.Sum over smaller area'
  return
end



subarr=indgen(z(1))
dbb=fltarr(z(1),z(2))
rb=fltarr(z(1),z(2))
ed=fltarr(z(1),z(2))
eb=fltarr(z(1),z(2))
er=fltarr(z(1),z(2))

; bg is the range to sum background over, therefore if this is gt 0 (i.e. there is
; some background to sum over) then do the sum. NB bg[0] is width of left sum
; bg[2] is width of right sum
if (bg[0] gt 0) or (bg[2] gt 0) then begin
; bgrd is the background subtraction option. If this is zero then use summing method
	if bgrd eq 0 then begin
; loop over z[2]= columns of array db (direct beam)
		for i=0,z(2)-1 do begin
		; background of direct beam is mean of counts in sum range
; IF only left background then average only over left
		if (bg[0] gt 0) and (bg[2] eq 0) then begin 
			bkdb=mean(db1(f1-bg[0]-bg[1]:f1-1-bg[1],i))
			bkref=mean(ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i))
		end
; IF only right background then average only over right
		if (bg[0] eq 0) and (bg[2] gt 0) then begin
			bkdb=mean(db1(f2+1+bg[3]:f2+bg[3]+bg[2],i))						
			bkref=mean(ref1(ff2+1+bg[3]:ff2+bg[3]+bg[2],i))
		end
;; IF both background then average over both
		if (bg[0] gt 0) and (bg[2] gt 0) then begin
			bkdb=(mean(db1(f1-bg[0]-bg[1]:f1-1-bg[1],i))+mean(db1(f2+1+bg[3]:f2+bg[3]+bg[2],i)))/2
			bkref=(mean(ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i))+mean(ref1(ff2+1+bg[3]:ff2+bg[3]+bg[2],i)))/2
		end
		; subtract background from direct beam counts
				db2(*,i)=db1(*,i)-bkdb
		; ditto for the reflected beam
				ref2(*,i)=ref1(*,i)-bkref

				dbb(*,i)=sqrt(bkdb)
                                rb(*,i)=sqrt(bkref)
				
				ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)
				er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

		endfor
      
	endif


; If bgrd=1 then the fitting option is chosen for background subtraction
	if bgrd eq 1 then begin
	
; note: Number of background points to use in fit = number at left+number at right=bg[0]+bg[2]
		n_bgpoints=bg[0]+bg[2]
		;subtract backgrd from db
		for i=0,z(2)-1 do begin


; dbgsuarr is an array that will contain the pixel numbers (on the detector) 
; of the pixels to be used in the fit
			dbbgsubarr=intarr(n_bgpoints)
; This array contains the VALUES of the pixels use for fitting
			dbbgarr=fltarr(n_bgpoints,z(2))
			dbbgfit=fltarr(z(1),z(2))

; Now we need the NUMBERS of the pixels that have been requested for use in the fit and also
; their VALUES:
; Subarr contains an array of pixel numbers for the whole detector. Set the pixel NUMBERS
; in dbgsubarr to the pixels selected for fitting. First the left side....
; (NB bg[0]=left width, bg[1]=left shift, f1=left side of foreground range)
			if bg[0] ne 0 then dbbgsubarr(0:bg[0]-1)=subarr(f1-bg[0]-bg[1]:f1-1-bg[1]) 
; ...Now do right hand side. (NB bg[2]=right width,bg[3]=right shift, f2=right hand side
; of foreground
			if bg[2] ne 0 then dbbgsubarr(bg[0]:(n_bgpoints-1))=subarr(f2+1+bg[3]:f2+bg[2]+bg[3]) 

; Now do a similar thing, but this time get the selected pixel VALUES
			if bg[0] ne 0 then dbbgarr(0:bg[0]-1,i)=db1(f1-bg[0]-bg[1]:f1-1-bg[1],i)
			if bg[2] ne 0 then dbbgarr(bg[0]:n_bgpoints-1,i)=db1(f2+1+bg[3]:f2+bg[2]+bg[3],i)

; find the errors on each of the pixel VALUES for use in the least-squares
; fitting process. Size of error array is equal to no. of fitting pixels
			err=fltarr(n_bgpoints)
; loop over number of background fitting pixels and find error by taking sqrt
			for j=0,n_bgpoints-1 do err(j)=sqrt(dbbgarr(j,i)+1)

; least squares fit of background
			dbbgcoeff=linfit(dbbgsubarr,dbbgarr(*,i),sdev=err,chisq=dbchisq,sigma=dbbgerr,/double)
	

; array containing the best fit line of the background
			dbbgfit(*,i)=dbbgcoeff(0)+dbbgcoeff(1)*subarr
; correct data by subtracting the background fit
			db2(*,i)=db1(*,i)-dbbgfit(*,i)
; error on background fit in the SQUARE ROOT of the fit at each point
			dbb(*,i)=sqrt(dbbgfit(*,i))
; to get error on corrected data add in quadrature the errors on the raw data and the background fit
			ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)

		endfor

		;subtract backgrd from ref
		for i=0,z(2)-1 do begin

			refbgsubarr=intarr(n_bgpoints)
			refbgarr=fltarr(n_bgpoints,z(2))
			refbgfit=fltarr(z(1),z(2))

			if bg[0] ne 0 then refbgsubarr(0:bg[0]-1)=subarr(ff1-bg[0]-bg[1]:ff1-1-bg[1]) 
			if bg[2] ne 0 then refbgsubarr(bg[0]:n_bgpoints-1)=subarr(ff2+1+bg[3]:ff2+bg[2]+bg[3]) 

			if bg[0] ne 0 then refbgarr(0:bg[0]-1,i)=ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i)
			if bg[2] ne 0 then refbgarr(bg[0]:n_bgpoints-1,i)=ref1(ff2+1+bg[3]:ff2+bg[2]+bg[3],i)

			err=fltarr(n_bgpoints)
			for j=0,n_bgpoints-1 do err(j)=sqrt(refbgarr(j,i)+1)

			refbgcoeff=linfit(refbgsubarr,refbgarr(*,i),sdev=err,chisq=refchisq,sigma=refbgerr,/double)

			;if refchisq ne 1 then begin
			;refbgcoeff=linfit(refbgsubarr(0:bg-1),refbgarr(0:bg-1,i),sdev=err(0:bg-1),chisq=refchisq,sigma=refbgerr)
			;endif

; Do similar calculation as for direct beam, i.e. take off background. Error in background is sqrt(counts)
; error in corrected data is found by adding in quadrature the errors in raw data and the background errors.
			refbgfit(*,i)=refbgcoeff(0)+refbgcoeff(1)*subarr
			ref2(*,i)=ref1(*,i)-refbgfit(*,i)
			rb(*,i)=sqrt(refbgfit(*,i))
			er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

		endfor

	endif

endif else begin
 
	ref2=ref1
	db2=db1
	ed=dber
	er=refer

endelse

d=total(db2(f1:f2,*),1)
r=total(ref2(ff1:ff2,*),1)

print,' '
if (bg[0] ne 0) and (bg[2] ne 0) then print,'done background correction'

;error calculation
ed=sqrt(total(ed(f1:f2,*)^2,1))
er=sqrt(total(er(ff1:ff2,*)^2,1))

reff=r
ereff=r

dpr=180./!pi

; calculate theta unless specified by user
;if th(0) eq 1 then th(1)=tth(dbdan,dbcom,refdan,refcom,nx,dett)
;this version forces th=san
if th(0) eq 1 then th(1)=san

q=4*!pi*sin(th(1)/dpr)/lamarr

for i=0,z(2)-1 do begin
	if (d(i) ne 0.) then begin
		reff(i)=r(i)/d(i)
		ereff(i)=reff(i)*sqrt((er(i)/r(i))^2+(ed(i)/d(i))^2) 
	endif else begin
		ereff(i)=0.
		reff(i)=1.e-11
	endelse
endfor

;resolution (error in q)
etf=((85.e-3)/tofd)+(3956.*opena*period)/(360.*tofd*lamarr)




print,'slit values', par2(93),par2(95)

;if s3 ge s2 then bigslit=s3 else bigslit=s2
;ethf=(bigslit*180)/(th(1)*3.4*!pi)

;s1s2 is the inter-slit distance
s1s2=3500.

ethf=2.*atan((par2(93)+par2(95))/(s1s2*2.))*180./(!pi*th(1))

qe=q*sqrt(etf^2+ethf^2)

;print,etf,ethf,qe/q

; unlogged data for reflectivity is in reff, q is q and error is ereff
if lamda(0) eq 1 then begin

	qmin=(min(q))
	qmax=(max(q))

endif else begin

	qmin=4*!pi*sin(th(1)/dpr)/lamda(2)
	qmax=4*!pi*sin(th(1)/dpr)/lamda(1)

endelse

qrange=where((q ge qmin) and (q le qmax))

wdum=reverse(reff(min(qrange):max(qrange)))
xdum=reverse(q(min(qrange):max(qrange)))
edum=reverse(ereff(min(qrange):max(qrange)))
qedum=reverse(qe(min(qrange):max(qrange)))

catch,/cancel

return
end

;*****************************************************************************************************
; Procedure to group data. Combines data from points which are, within the resolution, too
; close to each other. Also takes logarithm of the data.
; x = q values. y = Reflectivity values. e = error on reflectivity data
; dq = error on q values
; a = groupd reflectivity. b = groupd q values. c = groupd refl. errors
PRO group,x,y,e,dq,a,b,c

; arrays to store groupd data
ny=fltarr(1000)
nx=fltarr(1000)
nee=fltarr(1000)
ndq=fltarr(1000)


print,' '
print,'Bundling nearby data points for plotting:'

; resf = 'Magic' resolution factor. if the difference in q values is less than dq/resf then
; group the points. With resf=2. data points separated by half the error on q are groupd
resf=2.

; number of elements in data
tot=N_ELEMENTS(x)-1

; i counts the number of iterations purely for information on a print statement
	i=1
	
; This loop repeats until the number of pairs found is zero. (NB: It is 
; possible that the number of pairs will not decrease after an iteration.
; In this case data has been groupd, but the resulting point appears close
; to another point. This is why the number of pairs may remain equal to, e.g.
; 1 for the last few iterations
repeat begin

; reset c. c is used as a counter to address the data
 c=0
; set num to the number of elements in the data
 num=tot
; new is used to address the elements of the arrays where the groupd data is stored
 new=0
; counts the number of pairs encountered in each iteration
 pairs=0

; loop through data array
; while c is less than the last element (i.e. up to and including penultimate)
while c lt num do begin

; If q values are sufficiently close....
  if (x(c+1)-x(c) lt dq(c)/resf and x(c+1) ne 0) then begin
; ... then group the data. This is done by averaging the q values and reflectivity of
; each point and the errors are obtained by adding in the two errors in quadrature
     ny(new)=(y(c+1)+y(c))/2.
     nee(new)=(sqrt(e(c)^2.+e(c+1)^2.))/2
     nx(new)=(x(c)+x(c+1))/2.
     ndq(new)=(dq(c)+dq(c+1))/2.

; increase number of pairs
     pairs=pairs+1
; increment counter by two because two numbers have been processed
     c=c+2
; decrease the number of data elements by 1: two points have been groupd
     tot=tot-1
  endif else begin
; If no bundling is necessary then just copy the data into the new arrays.
     ny(new)=y(c)
     nx(new)=x(c)
     nee(new)=e(c)
     ndq(new)=dq(c)
; inc. counter by one
     c=c+1
  endelse

;inc. groupd data array counter
	new=new+1
end

; set old data to new groupd data ready for next iteration
 y=ny
 x=nx
 e=nee
 dq=ndq

	print,pairs,' pairs found on iteration ',i
; increment number of iterations
	i=i+1
	
; stop if no pairs were found
endrep until pairs eq 0

; return results: Log reflectivity data and calc. error on reflectivity.
a=alog10(ny(0:tot-1)) & b=nx(0:tot-1) & c=(nee(0:tot-1)/ny(0:tot-1))/alog(10)

return

end

;*****************************************************************************************************
;outputs to plot and output file

pro output,x,y,e,xe,fil

common varbwid,base

points=size(x)

close,10
openw,10,fil,/append
for i=0,points(1)-1 do begin
	printf,10,x(i),y(i),abs(e(i)),xe(i)
endfor
close,10

plotbase=widget_base(group_leader=base,title='Reflectivity against Q (log plot)',/column)
graph=widget_draw(plotbase,xsize=700,ysize=500,retain=2)
but=widget_button(plotbase,value='OK',uvalue='ok')

widget_control,plotbase,/realize

; negative ref set to 10^-10
y=y > 10.e-10
xe=abs(xe)

nx=fltarr(1000)
ny=fltarr(1000)
ner=fltarr(1000)

; group data. groupd data is nx, ny and ner(new ...)
group,x,y,e,xe,ny,nx,ner

	if N_ELEMENTS(nx) lt 2 then begin
		errormessage,'Data bundled into oblivion!!'
		return
	end
; clip errors to 4. (4 orders of magnitude)
ner=ner<4.

; calc. errors
;errs=e/(y*alog(10.))


  
ploterr,nx,ny,ner
; get rid of negative errors
;errs=abs(errs)

; limits errors to 4 orders of magnitude (on log plot)
;errs=errs<4.
;ploterr,x,alog10(y),errs

xmanager,'message',plotbase

return
end

;**************************************************************************************************
;shows end message window with calculated values
pro endmessage

common varbwid,base
common varwid,lab,txt,but,gap
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3
common varset,norm,bg,r,fil
common varbg,bgrd

res=intarr(50)

if norm eq 0 then nrm='runtime' else nrm='monitor'
if bgrd eq 0 then bgd='average'
if bgrd eq 1 then bgd='fit'

endbase=widget_base(group_leader=base,/floating,title='Finished',column=2)

;column1
res(0)=widget_label(endbase,value='fac1: '+strcompress(string(fac1(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac2: '+strcompress(string(fac2(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac3: '+strcompress(string(fac3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Normalised: '+nrm,/align_left)
res(2)=widget_label(endbase,value='Backgrd used: '+bgd,/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Saved to: '''+strcompress(string(fil(1)),/remove_all)+'''',/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Go again?')
gap(0)=widget_label(endbase,value='',ysize=0)

;column2
res(1)=widget_label(endbase,value='th1: '+strcompress(string(th1(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th2: '+strcompress(string(th2(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th3: '+strcompress(string(th3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Tot. Backgrd: '+strcompress(string(bg[0]+bg[2]),/remove_all),/align_left)
res(2)=widget_label(endbase,value='Foregrd: '+strcompress(string(r(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
endbut1=widget_button(endbase,value='OK',uvalue='ok')
endbut2=widget_button(endbase,value='QUIT',uvalue='quit')

widget_control,endbase,/realize

xmanager,'message',endbase

return
end

;************************************************************************************
;shows error message window
pro errormessage,mes1

common varbwid,base
common EFLAGS,eflag

; If its really an error then display appropriate message
if eflag ne 0 then begin
print,'********************************************************************'
print,'ERROR!! TOF Calculations aborted. Check error message and try again.'
print,'********************************************************************'
errbase=widget_base(group_leader=base,/floating,title='Error Message',/column)
; Otherwise its just a warning
endif else errbase=widget_base(group_leader=base,/floating,title='Warning Message',/column)

mess1=widget_label(errbase,value=mes1)
errbut=widget_button(errbase,value='OK',uvalue='ok')

widget_control,errbase,/realize

xmanager,'message',errbase

return
end

;***********************************************************************************
;handles events from errormessage, endmessage and output
pro message_event,event

common varbwid,base
common varwid,lab,txt,but,gap
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3

widget_control,event.id,get_uvalue=ev,get_value=val

;widget_control,event.top,/destroy

;if ev eq 'yes' then widget_control,base,sensitive=1	

if ev eq 'quit' then widget_control,base,/destroy

if ev eq 'ok' then begin
	widget_control,event.top,/destroy
	widget_control,base,sensitive=1
endif	

return
end

;*************************************************************************
;input TOF window

pro d17tof3
common par,par2
common var0,def
common varbwid,base
common varwid,lab,txt,but,gap

;widget types: lab=label,txt=text,but=button,gap=label(null string)
lab=lonarr(50)
txt=lonarr(50)
but=lonarr(50)
gap=lonarr(50)

;don't show maths errors
!except=0

;defaults that appear in the TOF window
def='def'

; If badflag=0 then the default file (if it exists) is okay
; If badflag=1 then the default file has been found to be corrupted by
; ON_IOERROR below
			badflag=0
;dtb*=direct beam run numbers 
setdefaults:		dtb1=''
			dtb2=''
			dtb3=''

;refl*=reflected beam run numbers
			refl1=''
			refl2=''
			refl3=''

; Instrument background numors
			instbg1=''
			instbg2=''
			instbg3=''
;water=water run numbers (or def)
			water=''

;wavelength range
			lambda='2.1,16'

;th*=theta angle (or def=calculated)
			th1=def
			th2=def
			th3=def

;fac*=factor by which to multiply Reflectivity (or def=calculated such that curves match)
			fac1=def
			fac2=def
			fac3=def

;r=Foreground range
;bg=Background range
			r='11'
			bgl='0'
			bgr='0'

;norm=method by which reflected beam is normalised to direct beam (0=Runtime,1=Monitor)
			norm=1
;bgrd=method by which background rate is determined in range bg (0=left side of peak,1=both sides of peak,2=linear fit calc from both sides of peak)
			bgrd=1

;fil=output file name
			fil='tofdat.out'
;path=path of data runs to be anal2ysed
			path='/users/data/'
; useful x range of detector
			useful='30,239'
; area to search for peak
			peak_searchx='30,239'
			peak_searchy='def'
;check default file exists
			filcheck=findfile('tof_defaults.dat',count=checkfil)			
; if file exists and its not already been found to be corrupt
			if (checkfil ne 0) and (badflag eq 0) then begin
			spacer='XXXXXXX'
			ON_IOERROR, corruptdefs
			close,10
			openr,10,'tof_defaults.dat'
			readf,10,spacer
			readf,10,dtb1
			readf,10,spacer
			readf,10,dtb2
			readf,10,spacer
			readf,10,dtb3
;refl*=reflected beam run numbers
			readf,10,spacer
			readf,10,refl1
			readf,10,spacer
			readf,10,refl2			
			readf,10,spacer
			readf,10,refl3

;instbg8=instrument background numors
			readf,10,spacer
			readf,10,instbg1
			readf,10,spacer
			readf,10,instbg2
			readf,10,spacer
			readf,10,instbg3

;water=water run numbers (or def)
			readf,10,spacer
			readf,10,water

;wavelength range
			readf,10,spacer
			readf,10,lambda

;th*=theta angle (or def=calculated)
			readf,10,spacer
			readf,10,th1
			readf,10,spacer
			readf,10,th2
			readf,10,spacer
			readf,10,th3

;fac*=factor by which to multiply Reflectivity (or def=calculated such that curves match)
			readf,10,spacer
			readf,10,fac1
			readf,10,spacer
			readf,10,fac2			
			readf,10,spacer
			readf,10,fac3
;r=Foreground range
;bg=Background range
			readf,10,spacer
			readf,10,r
; Background
; Left
			readf,10,spacer			
			readf,10,bgl
; Right
			readf,10,spacer
			readf,10,bgr

;norm=method by which reflected beam is normalised to direct beam (0=Runtime,1=Monitor)
			readf,10,spacer
			readf,10,norm
;bgrd=method by which background rate is determined in range bg (0=left side of peak,1=both sides of peak,2=linear fit calc from both sides of peak)
			readf,10,spacer
			readf,10,bgrd

;fil=output file name
			readf,10,spacer
			readf,10,fil
;path=path of data runs to be anal2ysed
			readf,10,spacer
			readf,10,path
; useful xrange of detector
			readf,10,spacer
			readf,10,useful
; area to look for peak
			readf,10,spacer
			readf,10,peak_searchx
			readf,10,spacer
			readf,10,peak_searchy
			close,10
			end
			goto,fine
corruptdefs:
			print,'Corrupted defaults file - ignored. Hardwired defaults set.'
			badflag=1
			goto,setdefaults				
;base window divided into 5 columns
fine: base=widget_base(title='TOF Data for data taken from last cycle 2001 to 2002',uvalue='base',column=6) 

;column 1
gap(10)=widget_label(base,ysize=10,value='')
lab(0)=widget_label(base,value='Run')
lab(1)=widget_label(base,value='set')
gap(0)=widget_label(base,ysize=0,value='')
lab(2)=widget_label(base,value='(1)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(3)=widget_label(base,value='(2)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(4)=widget_label(base,value='(3)  ',/align_right)
gap(23)=widget_label(base,ysize=15,value='')
lab(5)=widget_label(base,value='Water',/align_right)
lab(6)=widget_label(base,value='runs',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
lab(7)=widget_label(base,value='Lamda',/align_right)
lab(8)=widget_label(base,value='range',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
gap(0)=widget_label(base,ysize=0,value='')
lab(9)=widget_label(base,value='Normalise',/align_right)
lab(10)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 2
gap(10)=widget_label(base,ysize=10,value='')
lab(11)=widget_label(base,value='Direct')
lab(12)=widget_label(base,value='runs')
txt(0)=widget_text(base,value=dtb1,xsize=9,/editable,uvalue='int')
txt(1)=widget_text(base,value=dtb2,xsize=9,/editable,uvalue='int')
txt(2)=widget_text(base,value=dtb3,xsize=9,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(3)=widget_text(base,xsize=9,value=water,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(4)=widget_text(base,xsize=9,value=lambda,/editable,uvalue='real')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
but(0)=cw_bgroup(base,['Runtime','Monitor'],set_value=norm,/column,/exclusive,uvalue='norm')
gap(36)=widget_label(base,ysize=30,value='')
lab(11)=widget_label(base,value='Data Path:',/align_right)
lab(11)=widget_label(base,value='Output file:',/align_right)

;column 3
gap(10)=widget_label(base,ysize=10,value='')
lab(13)=widget_label(base,value='Reflect')
lab(14)=widget_label(base,value='runs')
txt(5)=widget_text(base,value=refl1,xsize=9,/editable,uvalue='int')
txt(6)=widget_text(base,value=refl2,xsize=9,/editable,uvalue='int')
txt(7)=widget_text(base,value=refl3,xsize=9,/editable,uvalue='int')
gap(16)=widget_label(base,ysize=16,value='')
lab(15)=widget_label(base,value='Foregrd',/align_right)
lab(16)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=10,value='')
lab(17)=widget_label(base,value='Backgrd',/align_right)
lab(18)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(20)=widget_label(base,ysize=20,value='')
lab(19)=widget_label(base,value='Bkgnd sub:',/align_right)
lab(21)=widget_label(base,value='method',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

txt(8)=widget_text(base,value=path,xsize=9,/editable,uvalue='str')
txt(9)=widget_text(base,value=fil,xsize=9,/editable,uvalue='str')
gap(0)=widget_label(base,ysize=0,value='')

;column 4
gap(10)=widget_label(base,ysize=10,value='')
lab(20)=widget_label(base,value='Instr. Bckgnd.')
lab(23)=widget_label(base,value='runs')
txt(10)=widget_text(base,xsize=4,value=instbg1,/editable,uvalue='real')
txt(11)=widget_text(base,xsize=4,value=instbg2,/editable,uvalue='real')
txt(12)=widget_text(base,xsize=4,value=instbg3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(13)=widget_text(base,xsize=4,value=r,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='left')
txt(14)=widget_text(base,xsize=4,value=bgl,/editable,uvalue='int')
gap(35)=widget_label(base,ysize=0,value='')
but(1)=cw_bgroup(base,['average','fit'],set_value=bgrd,/column,/exclusive,uvalue='bgrd')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=10,value='')
gap(0)=widget_label(base,ysize=0,value='')
but(3)=widget_button(base,value='DO IT',uvalue='done')
gap(0)=widget_label(base,ysize=0,value='')



;column 5
gap(10)=widget_label(base,ysize=10,value='')
lab(21)=widget_label(base,value='Factor')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(15)=widget_text(base,xsize=8,value=fac1,/editable,uvalue='real')
txt(16)=widget_text(base,xsize=8,value=fac2,/editable,uvalue='real')
txt(17)=widget_text(base,xsize=8,value=fac3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=20,value='')
gap(0)=widget_label(base,ysize=22,value='')
gap(6)=widget_label(base,ysize=10,value='')
gap(10)=widget_label(base,ysize=0,value='right')
txt(18)=widget_text(base,xsize=8,value=bgr,/editable,uvalue='int')
gap(40)=widget_label(base,ysize=40,value='')
gap(20)=widget_label(base,ysize=20,value='')
gap(35)=widget_label(base,ysize=35,value='')
but(2)=widget_button(base,value='QUIT',uvalue='quit')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 6
gap(10)=widget_label(base,ysize=10,value='')
lab(22)=widget_label(base,value='Theta')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(19)=widget_text(base,xsize=4,value=th1,/editable,uvalue='real')
txt(20)=widget_text(base,xsize=4,value=th2,/editable,uvalue='real')
txt(21)=widget_text(base,xsize=4,value=th3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')


gap(0)=widget_label(base,ysize=0,value='Detector')
gap(6)=widget_label(base,ysize=0,value='ranges')

drange = widget_base(base,/FRAME,/BASE_ALIGN_CENTER,/COLUMN)
gap(40)=widget_label(drange,value='Useful x range')
txt(22)=widget_text(drange,xsize=8,value=useful,/editable)
gap(6)=widget_label(drange,value='Area to look')
gap(0)=widget_label(drange,value=' for peak')
gap(6)=widget_label(drange,value='(xmin,xmax)')
txt(23)=widget_text(drange,xsize=8,value=peak_searchx,/editable)
gap(6)=widget_label(drange,value='(ymin,ymax)')
txt(24)=widget_text(drange,xsize=8,value=peak_searchy,/editable)

gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;gives the TOF window a margin
baseinfo=widget_info(base,/geometry)
widget_control,base,scr_xsize=baseinfo.scr_xsize+10
widget_control,base,scr_ysize=baseinfo.scr_ysize+10

;creates the TOF window
widget_control,base,/realize

;calls 'pro tof_event'
xmanager,'tof',base

end
;information file on how to enter data is tofinfo.inf
; pro tof    ;;;look for the main program at the bottom!!

;====================================================================================================
; This function takes a string as input an extracts the numors an returns an array of numors. Errors
; are signalled by the flag 'eflag': If this is 0 no error has occured, If it is 1 an error occured.
; The string should be formatted as follows: Individual numors should be punctuated by a plus sign (+)
; ranges of numors can be specified by the min/max numors separated by a comma.
; e.g. 1+5+10,13+20 gives the array of numors: [1,5,10,11,12,13,20]
;====================================================================================================
function getnumors,intlist

; Common block for error flag
common EFLAGS,eflag
	
; array to store numors
	numors=lonarr(1000)
; integer of numor counts
	numor_index=0
	
;convert string to bytes, removing all whitespace add 0 'terminator'
	numlist=[byte(strcompress(intlist,/REMOVE_ALL)),0B]
;index of numlist
	string_index=0
; temporary storage space for an integer of up to 6 digits
	thisnum=bytarr(6)
; index for thisnum-counts number of digits in number	
	count=0
; If true (1) this varaible indicates that the last punctuation was a comma
	comma=0
	
;----------------------------------------------------
; Main loop - loops over string (numlist). Terminates
; when 0 (null) terminator is encountered	
	repeat begin

; read in character
		temp=numlist[string_index]
; increment string index
		string_index=string_index+1
		
; Case block: determines character. If a digit is encountered then it is stored
; in a temporary array until punctuation is encountered. IF a plus is encountered
; then this numor is stored in the list of numors array. If a comma is encountered
; then the number is stored temporarily until the next number (and the following plus
; or terminator) is read, when a range of numors is generated
		case 1 of

;>>>>>>>>> Case: Any ASCII digit: '0' through '9'
; insert digit into thisnum: temporary storage array
		(temp ge 48B) and (temp le 57B): begin	
; If number of digits exceeds 6 then signal numor too big error
			if count eq 6 then begin
				eflag=2
				return,0
			end
; if not then insert digit
			thisnum[count]=temp
; increment counter
			count=count+1
		end
				
;>>>>>>>> Case: '+' or null terminator
; In this case add the previous numor to the list of numors
; or, if there was a comma, add a numor range
		(temp eq 43B) or (temp eq 0B): begin
; If count(=number of digits) is zero then there is no number between punctuation!
			if count eq 0 then begin
; Allow for empty strings -ie only terminator. In which case return special error.
				if (temp eq 0B) and (numor_index eq 0) then begin 
					eflag=4
					return,0
				endif else begin
; otherwise, bog standard formatting cock-up (error 1)
					eflag=1
					return,0
				end
			end
			
; Convert digits stored in thisnum to intger
			rend=long(string(thisnum))

; if value of numor is zero ('0') then signal error
			if rend eq 0 then begin
				eflag=2
				return,0
			end

; If the last punctuation was a comma, then insert a range into the numors array
		if comma then begin
; if end of range is less than beginning then signal error
			if rend lt rbegin then begin
				eflag=5
				return,0
			end
; Put series of integers from rbegin (first numor) to rend (last numor)
			numors[numor_index:(numor_index+rend-rbegin)]=indgen(rend-rbegin+1)+rbegin
; update the numor counter appropriately
			numor_index=numor_index+rend-rbegin+1
; reset comma to false
			comma=0
; reset digit counter
			count=0
; flush string
			thisnum[*]=0
; If no comma then simply insert single numor into array
		endif else begin
			numors[numor_index]=rend
; increment numor index
			numor_index=numor_index+1
; reset counter for next numor
			count=0	
; fluch string
			thisnum[*]=0
			end
		end
		
;>>>>>>>>>> Case: comma ','
		temp eq 44B: begin
; If comma flag is already true (1) then signal formatting error
; (two commas in a row)
		if comma then begin
			eflag=1
			return,0
		end
; otherwise set comma flag to true (1)
		comma=1
; If count(=number of digits) is zero then there is no number
			if count eq 0 then begin
				eflag=1
				return,0
			end
		
; store thisnum (byte array of digits) into 'start of numor range' variable for later use
			rbegin=long(string(thisnum))
; reset digit count
			count=0
; flush string
			thisnum[*]=0
; if value of numor is zero ('0') then signal error
			if rbegin eq 0 then begin
				eflag=2
				return,0
			end
		end
		
; >>>>>>>>>> Case: Illegal character, send error message
		else: begin
			eflag=3
			return,0
		end
		endcase
; Loop back to top unless the terminator is encountered
	endrep until temp eq 0
	
; If we've got this far without returning then there's no error
	eflag=0
; return an array with the numors in
	return,numors[0	:numor_index-1]
end

;********************************************************************************
;converts text widgit strings to appropriate type and checks for errors
;defaults=0,1 according to whether 'def' was entered
;intcheck=0,1 according to whether an integer is expected
;commacheck=0,1,2 according to whether a comma is expected (2=either)
;strcheck=0,1 according to whether a string is expectec
;errcheck1=0 (false),1 (true) according to whether two numbers (ie a range of
; numors) is expected as opposed to just a single number
;errcheck2=0 (false),1 (true) according to whether the field must be completed 
; in order for the calculations to be done.

function convert,txtwid,defaults,intcheck,commacheck,strcheck,errcheck1,errcheck2
common par,par2
common var0,def
common varflag,flag0,flag1,flag2,flag3,flag4,flag5

; parameter to return is an array of 3 strings (possibly to be an array of 3 integers/floats)
valnum=strarr(3)

widget_control,txtwid,get_value=val

valstr=val(0)

valstr=strcompress(valstr,/remove_all)

;signal error flag if a 'def' is given but defaults aren't allowed
if (defaults eq 0) and (valstr eq def) then flag5=1
; if default is set then set valnum (return array) to 1	
if valstr eq def then valnum(0)=1 else $
; else if string_check is true (1) then set the return varaible to the string (valstr)
; NB: Isn't the expression (valstr ne def) redundant since it's already checked as a condition
; to get here, i.e. "if valstr eq def" above
if (valstr ne def) and (strcheck eq 1) then valnum(1)=valstr else begin
; If we're not looking for a string then do the other checks

; look for the position of THE comma
	commapos=strpos(valstr,',')

	if commapos eq -1 then begin
; If there are no commas, but a comma is required then flag an error
		if commacheck eq 1 then flag4=1

; convert the string (which should be a single number, no commas) into a float and
; an integer
		valflt=float(valstr)
		valint=fix(valstr)

; compare the string representation of the converted number. If this is not equal
; to the original string an error has occured 	
		if strpos(string(valflt),valstr) eq -1 then flag2=1
		
; if intcheck=1 (true) and the floating version isn't the same as the integer
; then its not an integer-> signal error flag
		if (intcheck eq 1) and (valint ne valflt) then flag3=1


; If an integer is required return the integer 
		if (intcheck eq 1) and (errcheck1 eq 1) then valnum=[0,valint,0]
; If an integer isn't required then return the floating point
		if (intcheck eq 0) and (errcheck1 eq 1) then valnum=[0,valflt,valflt]
; no range needed
		if (intcheck eq 0) and (errcheck1 eq 0) then valnum(1)=valflt
		if (intcheck eq 1) and (errcheck1 eq 0) then valnum(1)=valint

	endif else begin
; Commas have been found:

; If the comma occupies the first character then user has been painfully stupid.	
		if commacheck eq 0 then flag2=1

; sets valstr (a 3 string array) to: '0', the string between the first character and the comma, the
; string between after the comma and the end.
		valstr=['0',strmid(valstr,0,commapos),strmid(valstr,commapos+1)]

; make arrays of float and integers containing the respective versions of valstr.
		valflt=float(valstr)
		valint=fix(valstr)
	
; check the string versions of the float to the original string. If they aren't equal the user has not 
; entered a number. signal 'Not a number error'
		if (strpos(string(valflt(1)),valstr(1)) eq -1) or (strpos(string(valflt(2)),valstr(2)) eq -1) then flag2=1
; if intcheck=1 (true) and the integers aren't equal to the floats then they aren't integers. Signal 'not int' error
		if (intcheck eq 1) and ((valint(1) ne valflt(1)) or (valint(2) ne valflt(2))) then flag3=1
; If intcheck=1 (true) then return the integers, otherwise return the floats
		if intcheck eq 1 then valnum=valint else valnum=valflt

	endelse

; If errcheck=1 (true) then a range (two numbers) rather than a single number is required.
; This checks to ensure that the first number is smaller than the second, otherwise the
; range is invalid.
; Note the fudge: The range check is not required if integers are being read. This is for the 
; background shift/width which isn't a range. Numor (which are integer) ranges are dealt with by
; another procedure "getnumors"
	if (errcheck1 eq 1) and (intcheck eq 0) then begin

		if valnum(1) gt valnum(2) then flag0=1

	endif

; If errorcheck2=1 (true) then the field must contain a non-zero number. This is the case
; for Direct beam (1), Reflect (1), water, lambda, theta (1) and fac (1). Things like 
; Direct beam (2) are optional and only need to be specified if there is more than one 
; angle of reflection.
	if errcheck2 eq 1 then begin

		if valnum(1) eq 0 then flag1=1

	endif

endelse	

; returns result.
return,valnum

end


;*******************************************************************************************
;calculates factor by which to multiply refb so as to match refa

function factor,refa,refb,qa,qb,errora,errorb

common varbwid,base

xa=qa(sort(qa))
xb=qb(sort(qb))
ya=refa(sort(qa))
yb=refb(sort(qb))
errora=errora(sort(qa))
errorb=errorb(sort(qb))

xaovsub=where(xa ge min(xb))

range=max(xaovsub)-min(xaovsub)

xaov=xa(min(xaovsub):max(xaovsub))

dataa=ya(min(xaovsub):max(xaovsub))
erra=errora(min(xaovsub):max(xaovsub))

datab=fltarr(range)
err2=fltarr(range)
errb=fltarr(range)

numersum=0
denomsum=0

catch,errstat
if errstat ne 0 then begin
	eflag=8
	errormessage,'Incompatible data: check run set order'
	catch,/cancel
endif

for i=1,range-1 do begin
		
	pntabsub=min(where(xb ge xaov(i)))
	pntab=xb(pntabsub)
	databab=yb(pntabsub)
	errbab=errorb(pntabsub)
	pntbesub=max(where(xb lt xaov(i)))
	pntbe=xb(pntbesub)
	databbe=yb(pntbesub)
	errbbe=errorb(pntbesub)
	
	databdiff=databbe-databab

datab(i)=(((pntab-xaov(i))/databdiff)*databbe)+(((xaov(i)-pntbe)/databdiff)*databab)
		errb(i)=sqrt((((pntab-xaov(i))/databdiff)*errbbe)^2+(((xaov(i)-pntbe)/databdiff)*errbab)^2)
	
	if pntab-xaov(i) le xaov(i)-pntbe then begin
		datab(i)=yb(pntabsub)
		errb(i)=errorb(pntabsub)
	endif else begin
		datab(i)=yb(pntbesub)
		errb(i)=errorb(pntbesub)
	endelse
	
	if (dataa(i) gt 1.e-11) and (datab(i) gt 1.e-11) and (erra(i) gt 0.) and (errb(i) gt 0.) then err2(i)=(erra(i)+errb(i))*(erra(i)+errb(i)) else err2(i)=1.e20

	numer=(1/err2(i))*dataa(i)*datab(i)

	denom=(1/err2(i))*datab(i)*datab(i)

	numersum=numersum+numer
	denomsum=denomsum+denom

endfor

catch,/cancel

fac=numersum/denomsum
return,fac

end


;***************************************************************************************************************
;deals with events from TOF window ('pro tof')

pro tof_event,event
common par,par2
common var0,def
common varwid,lab,txt,but,gap
common varbwid,base
common varflag,flag0,flag1,flag2,flag3,flag4,flag5
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3
common varset,norm,bg,r,fil
common varbg,bgrd
common varpath,path

; common block containing the time->lambda conversion array so it can be output
; to a file for each run
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3

; common block for useful xrange of detector and area to find peak in
common detranges,useful,peak_searchx,peak_searchy

; Error flag.
common EFLAGS,eflag

;takes the user value of the widget that cause the event and puts it equal to ev
widget_control,event.id,get_uvalue=ev

;closes all windows if 'quit' is pressed
if ev eq 'quit' then widget_control,base,/destroy

;begins anal2ysis of data if 'done' is pressed
if ev eq 'done' then begin

;flag*=error flags (0=no error, 1=error)
	flag0=0	
	flag1=0	
	flag2=0
	flag3=0
	flag4=0
	flag5=0
	flag6=0

;check*=flag for which run sets were used
	check0=0
	check1=0

;----*----*----*----*----*----*----*----*----*----*----*----*----*----*----
; Lots of repetative code to read in numors and output appropriate errors.
; (Should really be made a little more succinct by making a procedure
;----*----*----*----*----*----*----*----*----*----*----*----*----*----*----

; Read run 3 direct beam----------------------------
	widget_control,txt(2),get_value=val
	dtb3=getnumors(val(0))
; If eflag (error flag) is not zero or 4 (=empty array) then signal error
; empty arrays are allowed for runs 2 and 3 so long as both db and ref are empty
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Direct beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Direct beam'
		return
	end
		
; Read run 3 reflected beam-----------------------
	widget_control,txt(7),get_value=val
	refl3=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Reflected beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Reflected beam'
		return
	end
		
; If only 1 field is entered then signal error
	if ((dtb3[0] eq 0) and (refl3[0] ne 0)) or ((dtb3[0] ne 0) and (refl3[0] eq 0)) then begin 
	errormessage,'Incomplete fields:Run 3 (Enter both DB and REF or neither).'
	return
	end
	
; Read run 2 direct beam-------------------------
	widget_control,txt(1),get_value=val
	dtb2=getnumors(val(0))
; errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Direct beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Direct beam'
		return
	end
		
; Read run 2 reflected beam---------------------
	widget_control,txt(6),get_value=val
	refl2=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Reflected beam'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Reflected beam'
		return
	end
		
; If only 1 field is entered then signal error
	if ((dtb2[0] eq 0) and (refl2[0] ne 0)) or ((dtb2[0] ne 0) and (refl2[0] eq 0)) then begin 
	errormessage,'Incomplete fields:Run 2 (Enter both DB and REF or neither).'
	return
	end
	
; Read run 1 direct beam-----------------------
	widget_control,txt(0),get_value=val
	dtb1=getnumors(val(0))
; errors: note that eflag=4 (=no numors) is an error for run 1
	if eflag ne 0 then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Direct beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Direct beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Direct beam'
		if eflag eq 4 then errormessage,'Missing direct beam numors: Run 1'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Direct beam'
		return
	end
		
; Read run 1 reflected beam
	widget_control,txt(5),get_value=val
	refl1=getnumors(val(0))
; errors: note that eflag=4 (=no numors) is an error for run 1
	if eflag ne 0 then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Reflected beam'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Reflected beam'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Reflected beam'
		if eflag eq 4 then errormessage,'Missing reflected beam numors: Run 1'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Reflected beam'
		return
	end

; Read run 1 Instrument background
	widget_control,txt(10),get_value=val
	instbg1=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 1 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 1 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 1 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 1 Instrument background'
		return
	end
	
; Read run 2 Instrument background
	widget_control,txt(11),get_value=val
	instbg2=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 2 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 2 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 2 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 2 Instrument background'
		return
	end
; return error if Inst. BG set, but no direct beam/reflect runs set
	if (instbg2[0] ne 0) and (refl2[0] eq 0) then begin
		errormessage,'Inst. BG set but Direct beam/Reflected beam numors missing: Run 2.'
		return
	end
	
; Read run 3 Instrument background
	widget_control,txt(12),get_value=val
	instbg3=getnumors(val(0))
;errors
	if (eflag ne 0) and (eflag ne 4) then begin
		if eflag eq 1 then errormessage,'Illegal formatting:Run 3 Instrument background'
		if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Run 3 Instrument background'
		if eflag eq 3 then errormessage,'Illegal character: Run 3 Instrument background'
		if eflag eq 5 then errormessage,'Invalid range (end<beginning): Run 3 Instrument background'
		return
	end
; return error if Inst. BG set, but no direct beam/reflect runs set
	if (instbg3[0] ne 0) and (refl3[0] eq 0) then begin
		errormessage,'Inst. BG set but Direct beam/Reflected beam numors missing: Run 3.'
		return
	end	
; read water files
	widget_control,txt(3),get_value=val
; If 'def' is entered then set water=0 so that water file reading code knows to look
; for the default file
	if val[0] eq 'def' then water=0 else begin
		water=getnumors(val[0])
; errors: note that eflag=4 (=no numors) just means use default (signalled by 1st element of array 'water'
; being zero)
		if (eflag ne 0) and (eflag ne 4) then begin
			if eflag eq 1 then errormessage,'Illegal formatting:Water files'
			if eflag eq 2 then errormessage,'Invalid numor (0<numor<1000000):Water files'
			if eflag eq 3 then errormessage,'Illegal character:Water files'
			if eflag eq 5 then errormessage,'Invalid range (end<beginning): Water files'
		return
		end
	endelse
		
	lamda=convert(txt(4),1,0,2,0,1,1)

	path=convert(txt(8),0,0,0,1,0,0)
	
	fil=convert(txt(9),0,0,0,1,0,0)
	
	th1=convert(txt(19),1,0,0,0,0,0)
	th2=convert(txt(20),1,0,0,0,0,0)
	th3=convert(txt(21),1,0,0,0,0,0)
	
	r=convert(txt(13),0,1,0,0,0,0)
; check that foreground width isn't negative
	if r[1] lt 0 then begin
		errormessage,'Negative foreground width!'
		return
	end
	
;*******************************
; Quick sloppy fix coming up...
;*******************************

; convert returns either a single integer, or if a comma is supplied a 3 (for some reason...) array
; with the second and third elements containing the first (width) and second (shift) integers.
; Convert should really return a structure!!
	leftbg=convert(txt(14),0,1,2,0,1,0)
; Code below strips the leading 0 for a 3-array
	leftbg=[leftbg[1],leftbg[2]]
; Unfortunately have to do same sloppy manipulation for right hand side
	rightbg=convert(txt(18),0,1,2,0,1,0)
	rightbg=[rightbg[1],rightbg[2]]
; Now have two background arrays :leftbg[width,shift] rightbg[width,shift]. Concatenate
; these as single bg array to pass to anal2ysis
	bg=[leftbg,rightbg]
; bg[leftwidth,leftshift,rightwidth,rightshift]
; Yeuch.... that was messy

; check that all background shifts/widths to left and right are positive
	if (bg[0] lt 0) or (bg[1] lt 0) or (bg[2] lt 0) or (bg[3] lt 0) then begin
		errormessage,'Negative background width/shift!'
		return
	end
; Now do same for useful area of detector and peak search area:
	useful=convert(txt(22),0,1,2,0,1,0)
	useful=[useful[1],useful[2]]
	if (useful[0] lt 0) or (useful[1] gt 286) then begin
		errormessage,'Useful area of detector outside of physical size (0,286) of detector!'
		return
	end
	peak_searchx=convert(txt(23),0,1,2,0,1,0)
	peak_searchx=[peak_searchx[1],peak_searchx[2]]

	if (peak_searchx[0] lt useful[0]) or (peak_searchx[1] gt useful[1]) then begin
		errormessage,'Peak search x range is outside useful area of detector'
		return
	end

; if y range is set to "def" then set the range to -1,-1 so that the correct
; default range can be put in when the numors are read and their size is known
	widget_control,txt(24),get_value=temp
	if temp[0] EQ 'def' then peak_searchy=[-1,-1] else begin
		peak_searchy=convert(txt(24),0,1,2,0,1,0)
		peak_searchy=[peak_searchy[1],peak_searchy[2]]
		if (peak_searchy[0] lt 0) or (peak_searchy[1] gt 500) then begin
			errormessage,'Peak search y is outside y range (0,500)'
			return
		end
	end
	


	fac1=convert(txt(15),1,0,0,0,0,1)
	fac2=convert(txt(16),1,0,0,0,0,0)
	fac3=convert(txt(17),1,0,0,0,0,0)

;sets variable to the value of button widget in TOF window 
	widget_control,but(0),get_value=norm
	widget_control,but(1),get_value=bgrd


;if any errors in datat then appropriate message is displayed by calling 'pro errormessage'
	if flag0 eq 1 then errormessage,'Invalid ranges'
	if flag1 eq 1 then errormessage,'Incomplete fields'	
	if flag2 eq 1 then errormessage,'Field must be a number'	
	if flag3 eq 1 then errormessage,'Field must be integer'	
	if flag4 eq 1 then errormessage,'Comma expected'	
	if flag5 eq 1 then errormessage,'Default not available'	
	if flag6 eq 1 then errormessage,'Must complete all fields for given run set'	

;if there are no errors then proceed with anal2ysis
	if (flag0 eq 0) and (flag1 eq 0) and (flag2 eq 0) and (flag3 eq 0) and (flag4 eq 0) and (flag5 eq 0) and (flag6 eq 0) then begin

;renders TOF window insensitive
		widget_control,base,sensitive=0
		close,10

; write contents of text widgets (which have been checked above) into the default file tof_defaults.dat
		openw,10,'tof_defaults.dat'
		printf,10,'Direct beam runs (1)'
		widget_control,txt(0),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Direct beam runs (2)'
		widget_control,txt(1),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Direct beam runs (3)'
		widget_control,txt(2),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (1)'
		widget_control,txt(5),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (2)'
		widget_control,txt(6),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Reflection runs (3)'
		widget_control,txt(7),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (1)'
		widget_control,txt(10),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (2)'
		widget_control,txt(11),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Instrument background runs (3)'
		widget_control,txt(12),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Water (Efficiency) file'
		widget_control,txt(3),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Wavelength range'
		widget_control,txt(4),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (1)'
		widget_control,txt(19),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (2)'
		widget_control,txt(20),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Theta (3)'
		widget_control,txt(21),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (1)'
		widget_control,txt(15),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (2)'
		widget_control,txt(16),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Factor (3)'
		widget_control,txt(17),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Foreground range'
		widget_control,txt(13),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Left Background range'
		widget_control,txt(14),get_value=tempstring
		printf,10,tempstring		
		printf,10,'Right Background range'
		widget_control,txt(18),get_value=tempstring
		printf,10,tempstring
		printf,10,'Normalisation method'
		printf,10,norm
		printf,10,'Method to determine background'
		printf,10,bgrd
		printf,10,'Output filename'
		widget_control,txt(9),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Data Path'
		widget_control,txt(8),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Useful x range on detector'
		widget_control,txt(22),get_value=tempstring		
		printf,10,tempstring
		printf,10,'X range to find peak in'
		widget_control,txt(23),get_value=tempstring		
		printf,10,tempstring
		printf,10,'Y range to find peak in'
		widget_control,txt(24),get_value=tempstring		
		printf,10,tempstring
		close,10
;if default was selected then use default water file, 'water_LAMPascii'
		if water[0] eq 0 then begin
		
			print,' '
			print,' '
			print,'Reading default Water file, ''water_LAMPascii''...'
			w3=make_array(3,286,type=4)

;check default file exists
			filcheck=findfile('water_LAMPascii',count=checkfil)
			if checkfil eq 0 then begin 
; Default water file does not exist
				print,'Default water file water_LAMPascii does not exist. No water correction!'
				w2=make_array(1,286,type=4)
				w2[*]=1.0
			endif else begin

			close,4
			openr,4,"water_LAMPascii"
     			readf,4,w3
;makes it 1-D array
			w2=w3(1,*)
			close,4
;			print,'min water=',min(w2),'max water= ',max(w2)
			end
		endif else begin
;otherwise call 'pro data_read2' to read water files entered
			print,' '
			print,' '
			print,'Reading Water files...'
			watersum=0
;loop data_read2 for each file and sum detector counts (water)

			for i=0,N_ELEMENTS(water)-1 do begin
				data_read2,water[i],wat
			; return if an error occured during reading
				if eflag ne 0 then return
				watersum=wat+watersum
			endfor
;call 'pro awater' to set the size of the array corresponding to the useful size of the detector
			awater,watersum,w2
		endelse
				
;run set (1) 
		print,' '
		print,' '
		print,'Reading data files for set (1)...'

;form summed direct beam array
		print,' '
		print,'for direct beam...'
		db1sum=0
		db1monsum=0
		db1timesum=0
;loop data_read2 for each file and sum detector counts (db*), monitor counts (db*mon) and runtime (db*time) also take detector angle (dbdan*)
		for i=0,N_ELEMENTS(dtb1)-1 do begin
			data_read2,dtb1[i],db1,db1mon,db1time,dbdan1
		; return if an error occured during reading
			if eflag ne 0 then return
			db1sum=db1+db1sum
			db1monsum=db1mon+db1monsum
			db1timesum=db1time+db1timesum
		endfor

;create error array for summed detector counts
		erdb1=sqrt(db1sum)

; output the time-> lambda conversion array
	CLOSE,10
	OPENW,10,'a1_lambda_convert.dat'
	PRINTF,10,'Pixel,   Wavelength (Angstroms)'
	FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
	CLOSE,10
		
;form summed reflected beam array
		print,' '
		print,'for reflected beam...'
		ref1sum=0
		ref1monsum=0
		ref1timesum=0
; store SAN angles into an array for comparison with calculated value
		san=fltarr(N_ELEMENTS(refl1))
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
		for i=0,N_ELEMENTS(refl1)-1 do begin
			data_read2,refl1[i],ref1,ref1mon,ref1time,refdan1
; store SAN (par2[2]) into sans array
			san[i]=par2[2]
		; return if an error occured during reading
			if eflag ne 0 then return
			ref1sum=ref1+ref1sum
			ref1monsum=ref1mon+ref1monsum
			ref1timesum=ref1time+ref1timesum
		endfor
;create error array for summed detector counts
		erref1=sqrt(ref1sum)

; If ther are instrument backgrounds to be subtracted then read and sum these
		if instbg1[0] ne 0 then begin
;form summed reflected beam array
		print,' '
		print,'for Instrument background...'
		instbg1sum=0
		instbg1monsum=0
		instbg1timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
		for i=0,N_ELEMENTS(instbg1)-1 do begin
			print,instbg1
			data_read2,instbg1[i],instbgd1,instbg1mon,instbg1time,instbgdan1
	; return if an error occured during reading
			if eflag ne 0 then return
			instbg1sum=instbgd1+instbg1sum
			instbg1monsum=instbg1mon+instbg1monsum
			instbg1timesum=instbg1time+instbg1timesum
		endfor
;create error array for summed detector counts
		erinstbg1=sqrt(instbg1sum)
		end

; NORMALISE REFLECTED AND BACKGROUND RUNS TO THE DIRECT BEAM
		print,'Normalising....'		
;(norm=0) normalise summed reflected beam (normref*sum) to runtime 
		if norm eq 0 then begin
			normref1sum=ref1sum*(db1timesum/ref1timesum)
			normerref1sum=(db1timesum/ref1timesum)*erref1
; do same for Instrument backgrounds if they are present
			if instbg1[0] ne 0 then begin
				norminstbg1sum=instbg1sum*(db1timesum/instbg1timesum)
				normerinstbg1sum=(db1timesum/instbg1timesum)*erinstbg1
			end
		endif
;(norm=1) normalise summed reflected beam (normref*sum) to monitor 
		if norm eq 1 then begin
			normref1sum=ref1sum*(db1monsum/ref1monsum)
			normerref1sum=(db1monsum/ref1monsum)*erref1
; do same for Instrument backgrounds if they are present
			if instbg1[0] ne 0 then begin
				norminstbg1sum=instbg1sum*(db1monsum/instbg1monsum)
				normerinstbg1sum=(db1monsum/instbg1monsum)*erinstbg1
			end
		endif

; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg1[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref1sum=normref1sum-norminstbg1sum
			normerref1sum=sqrt(normerref1sum^2+normerinstbg1sum^2)
			db1sum=db1sum-norminstbg1sum
			erdb1=sqrt(erdb1^2+normerinstbg1sum^2)
		end
		
		print,' '
		print,' '
		print,'anal2ysing data files for set (1)...'

;call 'pro anal2' to create Reflectivity data
;returns w*=Reflectivity, x*=q, e*=Reflectivity error, qe*=q resolution
		anal2,db1sum,erdb1,dbdan1,normref1sum,normerref1sum,refdan1,w2,r(1),bg,w5,x5,e5,qe5,lamda,th1	
; if an error was signalled then restart
		if eflag ne 0 then return
;if default factor was selected then use fac1=1
		if fac1(0) eq 1 then fac1(1)=1.

;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th1[1] gt 0.1) or (san[i]-th1[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 1:Difference between calculated theta and SAN of numor '+strtrim(string(refl1[i]),2)+' is greater than 0.1'
			end
		endfor
		
		print,' '
		print,'...done set (1)'

;multiply Ref and Referr by fac
		w5=fac1(1)*w5
		e5=fac1(1)*e5

;find number of points
		z5=size(e5)

;sort data in order of increasing q and call arrays *s
		xs=x5(sort(x5))
		ws=w5(sort(x5))
		es=e5(sort(x5))
		qes=qe5(sort(x5))

;if 2 run sets were entered then 1st element of dtb2 is not zero
		if dtb2[0] ne 0 then begin

;run set (2) 
			print,' '
			print,' '
			print,'Reading data files for set (2)...'
				
			print,' '
			print,'for direct beam...'
			db2sum=0
			db2monsum=0
			db2timesum=0
			for i=0,N_ELEMENTS(dtb2)-1 do begin
				data_read2,dtb2[i],db2,db2mon,db2time,dbdan2
			; return if an error occured during reading
				if eflag ne 0 then return
				db2sum=db2+db2sum
				db2monsum=db2mon+db2monsum
				db2timesum=db2time+db2timesum
			endfor
			erdb2=sqrt(db2sum)

; output the time-> lambda conversion array
		CLOSE,10
		OPENW,10,'a2_lambda_convert.dat'
		PRINTF,10,'Pixel,   Wavelength (Angstroms)'
		FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
		CLOSE,10

			print,' '
			print,'for reflected beam...'
			ref2sum=0
			ref2monsum=0
			ref2timesum=0
			
			san=fltarr(N_ELEMENTS(refl2))
			for i=0,N_ELEMENTS(refl2)-1 do begin
				data_read2,refl2[i],ref2,ref2mon,ref2time,refdan2
				san[i]=par2[2]
			; return if an error occured during reading
				if eflag ne 0 then return
				ref2sum=ref2+ref2sum
				ref2monsum=ref2mon+ref2monsum
				ref2timesum=ref2time+ref2timesum
			endfor
			erref2=sqrt(ref2sum)
			
; If ther are instrument backgrounds to be subtracted then read and sum these
			if instbg2[0] ne 0 then begin
;form summed reflected beam array
			print,' '
			print,'for Instrument background...'
			instbg2sum=0
			instbg2monsum=0
			instbg2timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
			for i=0,N_ELEMENTS(instbg2)-1 do begin
				data_read2,instbg2[i],instbgd2,instbg2mon,instbg2time,instbgdan2
			; return if an error occured during reading
				if eflag ne 0 then return
				instbg2sum=instbgd2+instbg2sum
				instbg2monsum=instbg2mon+instbg2monsum
				instbg2timesum=instbg2time+instbg2timesum
			endfor
;create error array for summed detector counts
			erinstbg2=sqrt(instbg2sum)
			end

			print,'Normalising....'
			if norm eq 0 then begin
				normref2sum=ref2sum*(db2timesum/ref2timesum)
				normerref2sum=(db2timesum/ref2timesum)*erref2
; do same for Instrument backgrounds if they are present
				if instbg2[0] ne 0 then begin
					norminstbg2sum=instbg2sum*(db2timesum/instbg2timesum)
					normerinstbg2sum=(db2timesum/instbg2timesum)*erinstbg2
				end
			endif
			if norm eq 1 then begin
				normref2sum=ref2sum*(db2monsum/ref2monsum)
				normerref2sum=(db2monsum/ref2monsum)*erref2
; do same for Instrument backgrounds if they are present
				if instbg2[0] ne 0 then begin
					norminstbg2sum=instbg2sum*(db2monsum/instbg2monsum)
					normerinstbg2sum=(db2monsum/instbg2monsum)*erinstbg2
				end
			endif	
			
; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg2[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref2sum=normref2sum-norminstbg2sum
			normerref2sum=sqrt(normerref2sum^2+normerinstbg2sum^2)
			db2sum=db2sum-norminstbg2sum
			erdb2=sqrt(erdb2^2+normerinstbg2sum^2)
		end

			print,' '
			print,' '
			print,'anal2ysing data files for set (2)...'

			anal2,db2sum,erdb2,dbdan2,normref2sum,normerref2sum,refdan2,w2,r(1),bg,w6,x6,e6,qe6,lamda,th2
; if an error was signalled then restart
			if eflag ne 0 then return

;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th2[1] gt 0.1) or (san[i]-th2[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 2:Difference between calculated theta and SAN of numor '+strtrim(string(refl2[i]),2)+' is greater than 0.1'
			end
		endfor
			
;if default factor was selected then call 'function factor' to match the Reflectivity curve from set (2) to that of set (1)
			if fac2(0) eq 1 then fac2(1)=factor(w5,w6,x5,x6,e5,e6)
;fac*=0 implies no overlap between the Ref curves
			if fac2(1) eq 0. then begin
				print,' '
				print,'No Overlap between (1) & (2)'
			endif
				
			print,' '
			print,'...done set (2)'

			w6=fac2(1)*w6
			e6=fac2(1)*e6
			z6=size(e6)

;create single arrays combining set (1) and (2) for Ref,q,Referr,qres
			x=fltarr(z5(1)+z6(1))
			w=fltarr(z5(1)+z6(1))
			e=fltarr(z5(1)+z6(1))
			qe=fltarr(z5(1)+z6(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			
			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))
			
		endif
			
;if 3 run sets were entered then 1st element of dtb3 is not 0
		if dtb3[0] ne 0 then begin

;run set (3) 
			print,' '
			print,' '
			print,'Reading data files for set (3)...'

			print,' '
			print,'for direct beam...'
			db3sum=0
			db3monsum=0
			db3timesum=0
			for i=0,N_ELEMENTS(dtb3)-1 do begin
				data_read2,dtb3[i],dbd3,db3mon,db3time,dbdan3
			; return if an error occured during reading
				if eflag ne 0 then return
				db3sum=dbd3+db3sum
				db3monsum=db3mon+db3monsum
				db3timesum=db3time+db3timesum
			endfor
			erdb3=sqrt(db3sum)

; output the time-> lambda conversion array
			CLOSE,10
			OPENW,10,'a3_lambda_convert.dat'
			PRINTF,10,'Pixel,   Wavelength (Angstroms)'
			FOR I=0,N_ELEMENTS(lamarr)-1 DO PRINTF,10,i,',',lamarr[i]
			CLOSE,10

			print,' '
			print,'for reflected beam...'
			ref3sum=0
			ref3monsum=0
			ref3timesum=0
			
			san=fltarr(N_ELEMENTS(refl3))
			for i=0,N_ELEMENTS(refl3)-1 do begin
				data_read2,refl3[i],ref3,ref3mon,ref3time,refdan3
				san[i]=par2[2]
			; return if an error occured during reading
				if eflag ne 0 then return
				ref3sum=ref3+ref3sum
				ref3monsum=ref3mon+ref3monsum
				ref3timesum=ref3time+ref3timesum
			endfor
			erref3=sqrt(ref3sum)
			
; If ther are instrument backgrounds to be subtracted then read and sum these
			if instbg3[0] ne 0 then begin
;form summed reflected beam array
			print,' '
			print,'for Instrument background...'
			instbg3sum=0
			instbg3monsum=0
			instbg3timesum=0
;loop data_read2 for each file and sum detector counts (ref*), monitor counts (ref*mon) and runtime (ref*time) also take detector angle (refdan*)
			for i=0,N_ELEMENTS(instbg3)-1 do begin
				data_read2,instbg3[i],instbgd3,instbg3mon,instbg3time,instbgdan3
			; return if an error occured during reading
				if eflag ne 0 then return
				instbg3sum=instbgd3+instbg3sum
				instbg3monsum=instbg3mon+instbg3monsum
				instbg3timesum=instbg3time+instbg3timesum
			endfor
;create error array for summed detector counts
			erinstbg3=sqrt(instbg3sum)
			end

			print,'Normalising....'

			if norm eq 0 then begin
				normref3sum=ref3sum*(db3timesum/ref3timesum)
				normerref3sum=(db3timesum/ref3timesum)*erref3
; do same for Instrument backgrounds if they are present
				if instbg3[0] ne 0 then begin
					norminstbg3sum=instbg3sum*(db3timesum/instbg3timesum)
					normerinstbg3sum=(db3timesum/instbg3timesum)*erinstbg3
				end

			endif
			if norm eq 1 then begin
				normref3sum=ref3sum*(db3monsum/ref3monsum)
				normerref3sum=(db3monsum/ref3monsum)*erref3
; do same for Instrument backgrounds if they are present
				if instbg3[0] ne 0 then begin
					norminstbg3sum=instbg3sum*(db3monsum/instbg3monsum)
					normerinstbg3sum=(db3monsum/instbg3monsum)*erinstbg3
				end

			endif
			
; If there are instrument backgrounds to subtract then subtract the normalised sum and
; calculate the error.
		if instbg3[0] ne 0 then begin
			print,'Subtracting Normalised Instrument Backgrounds.....'
			normref3sum=normref3sum-norminstbg3sum
			normerref3sum=sqrt(normerref3sum^2+normerinstbg3sum^2)
			db3sum=db3sum-norminstbg3sum
			erdb3=sqrt(erdb3^2+normerinstbg3sum^2)
		end

			print,' '
			print,' '
			print,'anal2ysing data files for set (3)...'

			anal2,db3sum,erdb3,dbdan3,normref3sum,normerref3sum,refdan3,w2,r(1),bg,w7,x7,e7,qe7,lamda,th3
; if an error was signalled then restart
			if eflag ne 0 then return
			
;check that calculated value of theta agrees with SAN 
		for i=0,N_ELEMENTS(san)-1 do begin
			if (san[i]-th3[1] gt 0.1) or (san[i]-th3[1] lt -0.1) then begin
				eflag=0
		errormessage,'Warning: Run 3:Difference between calculated theta and SAN of numor '+strtrim(string(refl3[i]),2)+' is greater than 0.1'
			end
		endfor

;if default factor was selected then call 'function factor' to match the Reflectivity curve from set (3) to that of set (2)
			if fac3(0) eq 1 then fac3(1)=factor(w6,w7,x6,x7,e6,e7)
			if fac3(1) eq 0. then begin
				print,' '
				print,'No Overlap between (2) & (3)'
			endif

			print,' '
			print,'...done set (3)'

			w7=fac3(1)*w7
			e7=fac3(1)*e7
			z7=size(e7)

			x=fltarr(z5(1)+z6(1)+z7(1))
			w=fltarr(z5(1)+z6(1)+z7(1))
			e=fltarr(z5(1)+z6(1)+z7(1))
			qe=fltarr(z5(1)+z6(1)+z7(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			for i=(z5(1)+z6(1)),(z5(1)+z6(1)+z7(1)-1) do begin
				x(i)=x7(i-z5(1)-z6(1))
				w(i)=w7(i-z5(1)-z6(1))
				e(i)=e7(i-z5(1)-z6(1))
				qe(i)=qe7(i-z5(1)-z6(1))
			endfor

			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))

		endif

;remove all bad points from the arrays and call arrays *c (corrected)
		ec=es(where(es))
		qec=qes(where(es))
		xc=xs(where(es))
		wc=ws(where(es))
		
;for the purposes of the output file: If default water file is specified then
; redefine water as a string containing the name of the default water file
		if water[0] eq 0 then water='water_LAMPascii'

;check that output file has a valid name
		catch,outfilcheck
		if outfilcheck ne 0 then begin
;set eflag to non-zero to signal error
			eflag=10
			errormessage,'Invalid output file name: '''+strcompress(string(fil(1)),/remove_all)+''''
			catch,/cancel
		endif

;print data info at top of output file
		close,10
		openw,10,fil(1),width=128
		printf,10,' db1:',dtb1
		printf,10,' ref1:',refl1,' th1:',th1(1),' fac1:',fac1(1)
; only print run 2 stuff if there actually is a run 2
		if dtb2[0] ne 0 then begin
			printf,10,' db2:',dtb2
			printf,10,' ref2:',refl2,' th2:',th2(1),' fac2:',fac2(1)
		end
; only print run3 stuff if there is a run 3
		if dtb3[0] ne 0 then begin
			printf,10,' db3:',dtb3
			printf,10,' ref3:',refl3,' th3:',th3(1),' fac3:',fac3(1)
		end
		printf,10,' water:',water,' lamda:',lamda(1),lamda(2),' fgrd:',r(1),' bgrd:',bg
		
 		close,10
		catch,/cancel
		
;run 'pro endmessage' giving the details of the calculated parameters
		endmessage

;run 'pro output' listing the arrays to the output file and plotting the full Reflectivity curve
		output,xc,wc,ec,qec,fil(1)

	endif		

endif

return

end



;************************************************************************************
;reads data for each file (num,int), gives det counts (w1), monitor counts (w2)
; runtime, detector angle (dan)

pro data_read2,num,w1,w2,runtime,dan


; takes a data numor and opens the file, reads paramter blocks and comes back with
; the lambda array for TOF (lamarr) the detector array (w1) the monitor array (w2)

common EFLAGS,eflag
common vars0,def
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3
common varpath,path
common par,par2

;reset error flag
eflag=0

close,3

; floating point arrays of 128 and 256 elements
par1 = fltarr(128)
par2 = fltarr(256)

; string array of 34 elements
txt=sindgen(34)
; set all 34 elements to XXX....
txt(*)='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
txt1=txt(1)

;converts num(int) to 6 digit string with trailing zeroes
name='000000'				;make six digit string of 0's
tempnum=strtrim(string(num),2)		;convert num to string and trim all blank spaces
strput,name,tempnum,6-strlen(tempnum)	;put these digits in occupying the last strlen(tempnum) places of name
name=path(1)+name			; include path in name

;check to see if numor exists
filcheck=findfile(name,count=checkfil)		
; If not signal error and return
if checkfil eq 0 then begin 
	eflag=7
	errormessage,'File not found: '+name
	return
end

; inform user of status and open file (handle=3)
openr,3,name
print,'opened: ',name

; read in 34 lines of text
readf,3,txt
; output 5th and 26th lines (text)
;print,txt(4)
;print,txt(25)

; read 128 floats (2nd block of numbers in file, 1st block is ignored by code above)
readf,3,par1
; read the two line spacer
readf,3,txt1
readf,3,txt1
;read 256 numbers 
readf,3,par2

; degrees per radian
dpr=180./!pi

;output useful information
;print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
;print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
nx=par1(101)

; print out chopper speeds and openings  nx and ny are the detector grouping factors
; ie base detector is 286*276 if nx=2 and ny=1 then detector is 144*276

;print,'nx= ',par1(101),' ny= ',par1(102)
;print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
;print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
;print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
;print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)

; useful chopper variables openr is the requested chopper opening and opena is the read back value
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))

;!chopper opening offset=1.02!
opena=opena-1.02

; chopper period in seconds
period=60./par2(44)

; chopper delay angle between pickup and centre of projected window
dela=(285.+0.9-opena)/2.

; delt is the chopper delay time in seconds
delt=(dela/360.)*period

; cht is hardwired chopper separation in m
cht=85.e-3

; chopsam is the sample to mid-chopper distance in meters
chopsam=4.0115-(cht)/2.

; chopmon is the monitor to detector distance
chopmon=.455

; tofd is the time- of flight distance from mid-chopper to detector par2(15) is
; the sample to detector distance in mm
tofd=chopsam+(par2(15)/1000.)

;chanpa is the number of time channels per angstrom for the detector (neutron wavelength) 
chanpa=(tofd/3956.)/(par1(95)*1.e-6)

;chanpam is the number of time channels per angstrom for the monitor (neutron wavelength
chanpam=(chopmon/3956.)/(par1(95)*1.e-6)

; r is the time grouping factor between the monitor and the detector (not used at present
;as we measure the direct beam on the detector and use the monitor just for normalisation

r=chopsam/tofd

; chopper delay in time channels
delchan=delt/(par1(95)*1e-6)

; electronic delay (set by par tof in MAD) in channels
delechan=par1(96)/par1(95)

;printing out useful stuff
;print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
;print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
;print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
;print,'opening      req= ',openr,' opening      act= ',opena
;print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
;print,'     san= ',par2(2),' deg.'
;print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa

runtime=par1(2)/10.

;print,'run time= ',runtime,' s',' det= ',par2(15),'dan = ',par2(16)

;dan is the detector angle and dett is the sample-detector distance
dan=par2(16)
dett=par2(15)

; Now we can read the data -first read 3 spacer lines
readf,3,txt1
readf,3,txt1
readf,3,txt1

;read total number pixels in detector
readf,3,tot

;set size of arrays (usually in TOF ysize is 1 i.e we have xpxels*time channels only)
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize

;signal error if total number of pixels isn't equal to xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'

;print,'tsize= ',tsize,' detector size= ',dsize
;print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

;set up an array of long integers with specified size
det=lonarr(ysize,xsize,tsize)
; usually pixels are summed in physical y direction of detector-> only 2d
if (ysize eq 1) then det=lonarr(xsize,tsize)

; set up monitor arrray. Monitor is basically an extra line of pixels at the end
; of the data
mon=lonarr(tsize)

;2x2 arrays of data
xy=lonarr(xsize,ysize)
xt=lonarr(xsize,tsize)
yt=lonarr(ysize,tsize)

c=1

;read detector data and monitor data from file
readf,3,det,mon

s2=par2(54)
s3=par2(50)

nx=par1(101)

;millimeters per pixel
mmpp=1.016*nx

;useful area of det in pixels
xminp=16
xmaxp=255
; convert to useful area in mm
xminmm=xminp*mmpp
xmaxmm=xmaxp*mmpp


;make lamda array- conversion between time and wavelength
yy=findgen(tsize)		;generates  floating point array with sequence 0.0,1.0,2.0, e.t.c
lamarr=(yy+delechan-delchan+0.5)/chanpa

; convert data to floating point in w1
w1=float(det)
; add up total monitor counts
w2=float(total(mon))

close,3
; print total monitor counts and monitor counts per unit time
;print,'total counts in detector = ',total(w1),' (',total(w1)/runtime,')'

return

end


;*********************************************************************************************************
;sets water file (w1) to 1 outside useful area of det and returns w2

pro awater,w1,w2

xsize=286
w2=fltarr(xsize)

;useful area of det (x,y) 37:238,30:248
x1=37 & x2=238
w2=float(total(w1,2))

; normalise water
w2=w2/(mean(w2(x1:x2)))
; set anything outside usefule area to 1
w2(0:x1-1)=1. & w2(x2+1:xsize-1)=1.
;print,'Max water=',max(w2),'Min water=',min(w2)
return

end

;***************************************************************************************************
;calculates theta

function tth,d0,p0,dr,pr,nx,det

dpr=180./!pi

pcen=139.81/nx
mmpp=1.016*nx

;print,' '
;print,'pcen= ',pcen
;print,'mmpp= ',mmpp
th=(dr+dpr*atan((pcen-pr)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
print,'calculated theta= ',th


return,th

end


;********************************************************************************************
;anal2yses data, db=direct beam counts, dber=error on direct beam counts, dbdan=detector angle for direct beam, ref=reflected beam counts, refer=error on reflected beam counts, refdan=detector angle for reflected beam, water=detector counts for watef, r=forground range, bg=background range, wdum=Reflectivity, xdum=q, edum=Reflectivity error, qedum=q resolution, lamda=lamda range, th=theta

pro anal2,db,dber,dbdan,ref,refer,refdan,water,rr,bg,wdum,xdum,edum,qedum,lamda,th

wdum=0
xdum=0
edum=0
qedum=0

; Common block for error flag
common EFLAGS,eflag
common par,par2
common vars0,def
common varpar,tofd,opena,period,lamarr,nx,dett,s2,s3
common varbg,bgrd

; common block for useful xrange of detector and area to find peak in
common detranges,useful,peak_searchx,peak_searchy

; reset error flag: no errors
eflag=0

; db is the direct beam run
; ref is the reflection run
; water is the x effiency of the detector
; q is the array of q(A^-1)
; rr is the range over which to sum the intensity
; bg is the range to sum the background either side of r
; w5 is the output reflectivity with the q (x5) and error (e4)
; fac is the normalisation factor for w2 reflection data ie
; divide the ref data by this to make it normalised to the direct beam

;print,'TOTALS REF DB',total(ref),total(db)


ref1=ref
ref2=ref
db1=db
db2=db
edb=db
ere=ref

; get useful area of detector from common block variable
xmax=useful[1]
xmin=useful[0]

mmpp=1.016*nx

catch,erranal2
if erranal2 ne 0 then begin
	errormessage,'Error anal2ysing data: check settings and try again'
	catch,/cancel
endif

;place info of array db (direct beam data) into z.
;z[0]=no dimensions, z[1]=1st dimension, z[2]=2nd dim, z[3]= type
; z[5]=tot. number of elements
z=size(db)
;print,' '
;print,'db size: ',z(2)
;print,'MEAN WATER',mean(water)

;water correction
for i=0,z(2)-1 do begin
	db1(*,i)=db(*,i)/water
	dber(*,i)=dber(*,i)/water
	ref1(*,i)=ref(*,i)/water
	refer(*,i)=refer(*,i)/water
endfor

;print,' '
;print,'done water correction'

;print,'TOTALS REF DB AFTER WATER',total(ref1),total(db1)

; limit area to search peak to user defined values
x1=peak_searchx[0] & x2=peak_searchx[1]

; if "def" is entered in y range then get the values from the size of the data
if peak_searchy[0] eq -1 then begin
	t1=fix(float(z[2])/2.) & t2=z[2]-1 
endif else begin
	t1=peak_searchy[0] & t2=peak_searchy[1]
end

;sum direct beam data along columns:
; restricted range sum
dbtot=total(db1(x1:x2,t1:t2),2)
; whole sum
dbtot2=total(db1,2)
; max. of direct beam data. pixel number is put in dbm
dbtotm=max(dbtot,dbm)
; add resttricted range offset to dbm
dbm=dbm+x1
;print,'direct beam peak at: ',dbm

;calculate summation ranges: rr=width of foreground sum
f1=dbm-fix((rr-1)/2)
f2=dbm+fix((rr-1)/2)
;print,'sum ranges for db: ',f1,f2

;Centre Of Mass calculation for db
numersum=0.
denomsum=0.
for i=f1,f2 do begin
	numer=dbtot2(i)*float(i)
	denom=dbtot2(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
;print,'db stuff:', numersum,denomsum
dbcom=numersum/denomsum
;print,'fitted db peak at: ',(dbcom)

;check to see if peak value is near centre of mass if it isn't set it to
; the centre of mass
if fix(dbcom+0.5) ne dbm then dbm=fix(dbcom+0.5)

; redo foreground calculation
f1=dbm-fix((rr-1)/2)
f2=dbm+fix((rr-1)/2)

print,format='("Direct beam sum ranges: Foreground      :",3x,i3,1x,i3)',f1,f2
if bg[0] ne 0 then print,format='(24x,"Background left :",3x,i3,1x,i3)',f1-bg[0]-bg[1],f1-1-bg[1]
if bg[2] ne 0 then print,format='(24x,"Background right:",3x,i3,1x,i3)',f2+bg[2]+bg[3],f2+1+bg[3]
;print,'corrected db peak at: ',dbm

;  finding the peak in the reflection over a limited range 150:230 in x
;and 200 to the max in time channels

reftot=total(ref1(x1:x2,t1:t2),2)
reftot2=total(ref1,2)
reftotm=max(reftot,refm)
refm=refm+x1
;print,'peak in reflection at: ',refm


ff1=refm-fix((rr-1)/2)
ff2=refm+fix((rr-1)/2)
;print,'sum ranges for ref: ',ff1,ff2
;COM for ref
numersum=0.
denomsum=0.

for i=ff1,ff2 do begin
	numer=reftot2(i)*float(i)
	denom=reftot2(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
refcom=numersum/denomsum
;print,'ref stuff:', numersum,denomsum
;print,'ref peak at: ',(refcom)
if fix(refcom+0.5) ne refm then refm=fix(refcom+0.5)
;print,'corrected ref peak at: ',refm
ff1=refm-fix((rr-1)/2)
ff2=refm+fix((rr-1)/2)


print,' '
print,format='("Ref.   beam sum ranges: Foreground      :",3x,i3,1x,i3)',ff1,ff2
if bg[0] ne 0 then print,format='(24x,"Background left :",3x,i3,1x,i3)',ff1-bg[0]-bg[1],ff1-1-bg[1]
if bg[2] ne 0 then print,format='(24x,"Background right:",3x,i3,1x,i3)',ff2+bg[2]+bg[3],ff2+1+bg[3]

;print,'ref peak at: ',(refcom)

;print,'f1 f2 ff1 ff2',f1,f2,ff1,ff2

; Check that background sum isn't outside range of detector. NB For left side bg[0] is width, bg[1] is shift from edge
; of foreground sum. Similar thing for right in bg[2] and bg[3]
if ((f1-bg[0]-bg[1]) lt xmin) or ((f2+bg[2]+bg[3]) gt xmax) or ((ff1-bg[0]-bg[1]) lt xmin) or ((ff2+bg[2]+bg[3]) gt xmax) then begin
  eflag=6
  errormessage,'Outside useful area of detector.Sum over smaller area'
  return
end



subarr=indgen(z(1))
dbb=fltarr(z(1),z(2))
rb=fltarr(z(1),z(2))
ed=fltarr(z(1),z(2))
eb=fltarr(z(1),z(2))
er=fltarr(z(1),z(2))

; bg is the range to sum background over, therefore if this is gt 0 (i.e. there is
; some background to sum over) then do the sum. NB bg[0] is width of left sum
; bg[2] is width of right sum
if (bg[0] gt 0) or (bg[2] gt 0) then begin
; bgrd is the background subtraction option. If this is zero then use summing method
	if bgrd eq 0 then begin
; loop over z[2]= columns of array db (direct beam)
		for i=0,z(2)-1 do begin
		; background of direct beam is mean of counts in sum range
; IF only left background then average only over left
		if (bg[0] gt 0) and (bg[2] eq 0) then begin 
			bkdb=mean(db1(f1-bg[0]-bg[1]:f1-1-bg[1],i))
			bkref=mean(ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i))
		end
; IF only right background then average only over right
		if (bg[0] eq 0) and (bg[2] gt 0) then begin
			bkdb=mean(db1(f2+1+bg[3]:f2+bg[3]+bg[2],i))						
			bkref=mean(ref1(ff2+1+bg[3]:ff2+bg[3]+bg[2],i))
		end
;; IF both background then average over both
		if (bg[0] gt 0) and (bg[2] gt 0) then begin
			bkdb=(mean(db1(f1-bg[0]-bg[1]:f1-1-bg[1],i))+mean(db1(f2+1+bg[3]:f2+bg[3]+bg[2],i)))/2
			bkref=(mean(ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i))+mean(ref1(ff2+1+bg[3]:ff2+bg[3]+bg[2],i)))/2
		end
		; subtract background from direct beam counts
				db2(*,i)=db1(*,i)-bkdb
		; ditto for the reflected beam
				ref2(*,i)=ref1(*,i)-bkref

				dbb(*,i)=sqrt(bkdb)
                                rb(*,i)=sqrt(bkref)
				
				ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)
				er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

		endfor
      
	endif


; If bgrd=1 then the fitting option is chosen for background subtraction
	if bgrd eq 1 then begin
	
; note: Number of background points to use in fit = number at left+number at right=bg[0]+bg[2]
		n_bgpoints=bg[0]+bg[2]
		;subtract backgrd from db
		for i=0,z(2)-1 do begin


; dbgsuarr is an array that will contain the pixel numbers (on the detector) 
; of the pixels to be used in the fit
			dbbgsubarr=intarr(n_bgpoints)
; This array contains the VALUES of the pixels use for fitting
			dbbgarr=fltarr(n_bgpoints,z(2))
			dbbgfit=fltarr(z(1),z(2))

; Now we need the NUMBERS of the pixels that have been requested for use in the fit and also
; their VALUES:
; Subarr contains an array of pixel numbers for the whole detector. Set the pixel NUMBERS
; in dbgsubarr to the pixels selected for fitting. First the left side....
; (NB bg[0]=left width, bg[1]=left shift, f1=left side of foreground range)
			if bg[0] ne 0 then dbbgsubarr(0:bg[0]-1)=subarr(f1-bg[0]-bg[1]:f1-1-bg[1]) 
; ...Now do right hand side. (NB bg[2]=right width,bg[3]=right shift, f2=right hand side
; of foreground
			if bg[2] ne 0 then dbbgsubarr(bg[0]:(n_bgpoints-1))=subarr(f2+1+bg[3]:f2+bg[2]+bg[3]) 

; Now do a similar thing, but this time get the selected pixel VALUES
			if bg[0] ne 0 then dbbgarr(0:bg[0]-1,i)=db1(f1-bg[0]-bg[1]:f1-1-bg[1],i)
			if bg[2] ne 0 then dbbgarr(bg[0]:n_bgpoints-1,i)=db1(f2+1+bg[3]:f2+bg[2]+bg[3],i)

; find the errors on each of the pixel VALUES for use in the least-squares
; fitting process. Size of error array is equal to no. of fitting pixels
			err=fltarr(n_bgpoints)
; loop over number of background fitting pixels and find error by taking sqrt
			for j=0,n_bgpoints-1 do err(j)=sqrt(dbbgarr(j,i)+1)

; least squares fit of background
			dbbgcoeff=linfit(dbbgsubarr,dbbgarr(*,i),sdev=err,chisq=dbchisq,sigma=dbbgerr,/double)
	

; array containing the best fit line of the background
			dbbgfit(*,i)=dbbgcoeff(0)+dbbgcoeff(1)*subarr
; correct data by subtracting the background fit
			db2(*,i)=db1(*,i)-dbbgfit(*,i)
; error on background fit in the SQUARE ROOT of the fit at each point
			dbb(*,i)=sqrt(dbbgfit(*,i))
; to get error on corrected data add in quadrature the errors on the raw data and the background fit
			ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)

		endfor

		;subtract backgrd from ref
		for i=0,z(2)-1 do begin

			refbgsubarr=intarr(n_bgpoints)
			refbgarr=fltarr(n_bgpoints,z(2))
			refbgfit=fltarr(z(1),z(2))

			if bg[0] ne 0 then refbgsubarr(0:bg[0]-1)=subarr(ff1-bg[0]-bg[1]:ff1-1-bg[1]) 
			if bg[2] ne 0 then refbgsubarr(bg[0]:n_bgpoints-1)=subarr(ff2+1+bg[3]:ff2+bg[2]+bg[3]) 

			if bg[0] ne 0 then refbgarr(0:bg[0]-1,i)=ref1(ff1-bg[0]-bg[1]:ff1-1-bg[1],i)
			if bg[2] ne 0 then refbgarr(bg[0]:n_bgpoints-1,i)=ref1(ff2+1+bg[3]:ff2+bg[2]+bg[3],i)

			err=fltarr(n_bgpoints)
			for j=0,n_bgpoints-1 do err(j)=sqrt(refbgarr(j,i)+1)

			refbgcoeff=linfit(refbgsubarr,refbgarr(*,i),sdev=err,chisq=refchisq,sigma=refbgerr,/double)

			;if refchisq ne 1 then begin
			;refbgcoeff=linfit(refbgsubarr(0:bg-1),refbgarr(0:bg-1,i),sdev=err(0:bg-1),chisq=refchisq,sigma=refbgerr)
			;endif

; Do similar calculation as for direct beam, i.e. take off background. Error in background is sqrt(counts)
; error in corrected data is found by adding in quadrature the errors in raw data and the background errors.
			refbgfit(*,i)=refbgcoeff(0)+refbgcoeff(1)*subarr
			ref2(*,i)=ref1(*,i)-refbgfit(*,i)
			rb(*,i)=sqrt(refbgfit(*,i))
			er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

		endfor

	endif

endif else begin
 
	ref2=ref1
	db2=db1
	ed=dber
	er=refer

endelse

d=total(db2(f1:f2,*),1)
r=total(ref2(ff1:ff2,*),1)

print,' '
if (bg[0] ne 0) and (bg[2] ne 0) then print,'done background correction'

;error calculation
ed=sqrt(total(ed(f1:f2,*)^2,1))
er=sqrt(total(er(ff1:ff2,*)^2,1))

reff=r
ereff=r

dpr=180./!pi

; calculate theta unless specified by user
if th(0) eq 1 then th(1)=tth(dbdan,dbcom,refdan,refcom,nx,dett)

q=4*!pi*sin(th(1)/dpr)/lamarr

for i=0,z(2)-1 do begin
	if (d(i) ne 0.) then begin
		reff(i)=r(i)/d(i)
		ereff(i)=reff(i)*sqrt((er(i)/r(i))^2+(ed(i)/d(i))^2) 
	endif else begin
		ereff(i)=0.
		reff(i)=1.e-11
	endelse
endfor

;resolution (error in q)
etf=((85.e-3)/tofd)+(3956.*opena*period)/(360.*tofd*lamarr)




print,'slit values', par2(93),par2(95)

;if s3 ge s2 then bigslit=s3 else bigslit=s2
;ethf=(bigslit*180)/(th(1)*3.4*!pi)

;s1s2 is the inter-slit distance
s1s2=3500.

ethf=2.*atan((par2(93)+par2(95))/(s1s2*2.))*180./(!pi*th(1))

qe=q*sqrt(etf^2+ethf^2)

;print,etf,ethf,qe/q

; unlogged data for reflectivity is in reff, q is q and error is ereff
if lamda(0) eq 1 then begin

	qmin=(min(q))
	qmax=(max(q))

endif else begin

	qmin=4*!pi*sin(th(1)/dpr)/lamda(2)
	qmax=4*!pi*sin(th(1)/dpr)/lamda(1)

endelse

qrange=where((q ge qmin) and (q le qmax))

wdum=reverse(reff(min(qrange):max(qrange)))
xdum=reverse(q(min(qrange):max(qrange)))
edum=reverse(ereff(min(qrange):max(qrange)))
qedum=reverse(qe(min(qrange):max(qrange)))

catch,/cancel

return
end

;*****************************************************************************************************
; Procedure to group data. Combines data from points which are, within the resolution, too
; close to each other. Also takes logarithm of the data.
; x = q values. y = Reflectivity values. e = error on reflectivity data
; dq = error on q values
; a = groupd reflectivity. b = groupd q values. c = groupd refl. errors
PRO group,x,y,e,dq,a,b,c

; arrays to store groupd data
ny=fltarr(1000)
nx=fltarr(1000)
nee=fltarr(1000)
ndq=fltarr(1000)


print,' '
print,'Bundling nearby data points for plotting:'

; resf = 'Magic' resolution factor. if the difference in q values is less than dq/resf then
; group the points. With resf=2. data points separated by half the error on q are groupd
resf=2.

; number of elements in data
tot=N_ELEMENTS(x)-1

; i counts the number of iterations purely for information on a print statement
	i=1
	
; This loop repeats until the number of pairs found is zero. (NB: It is 
; possible that the number of pairs will not decrease after an iteration.
; In this case data has been groupd, but the resulting point appears close
; to another point. This is why the number of pairs may remain equal to, e.g.
; 1 for the last few iterations
repeat begin

; reset c. c is used as a counter to address the data
 c=0
; set num to the number of elements in the data
 num=tot
; new is used to address the elements of the arrays where the groupd data is stored
 new=0
; counts the number of pairs encountered in each iteration
 pairs=0

; loop through data array
; while c is less than the last element (i.e. up to and including penultimate)
while c lt num do begin

; If q values are sufficiently close....
  if (x(c+1)-x(c) lt dq(c)/resf and x(c+1) ne 0) then begin
; ... then group the data. This is done by averaging the q values and reflectivity of
; each point and the errors are obtained by adding in the two errors in quadrature
     ny(new)=(y(c+1)+y(c))/2.
     nee(new)=(sqrt(e(c)^2.+e(c+1)^2.))/2
     nx(new)=(x(c)+x(c+1))/2.
     ndq(new)=(dq(c)+dq(c+1))/2.

; increase number of pairs
     pairs=pairs+1
; increment counter by two because two numbers have been processed
     c=c+2
; decrease the number of data elements by 1: two points have been groupd
     tot=tot-1
  endif else begin
; If no bundling is necessary then just copy the data into the new arrays.
     ny(new)=y(c)
     nx(new)=x(c)
     nee(new)=e(c)
     ndq(new)=dq(c)
; inc. counter by one
     c=c+1
  endelse

;inc. groupd data array counter
	new=new+1
end

; set old data to new groupd data ready for next iteration
 y=ny
 x=nx
 e=nee
 dq=ndq

	print,pairs,' pairs found on iteration ',i
; increment number of iterations
	i=i+1
	
; stop if no pairs were found
endrep until pairs eq 0

; return results: Log reflectivity data and calc. error on reflectivity.
a=alog10(ny(0:tot-1)) & b=nx(0:tot-1) & c=(nee(0:tot-1)/ny(0:tot-1))/alog(10)

return

end

;*****************************************************************************************************
;outputs to plot and output file

pro output,x,y,e,xe,fil

common varbwid,base

points=size(x)

close,10
openw,10,fil,/append
for i=0,points(1)-1 do begin
	printf,10,x(i),y(i),abs(e(i)),xe(i)
endfor
close,10

plotbase=widget_base(group_leader=base,title='Reflectivity against Q (log plot)',/column)
graph=widget_draw(plotbase,xsize=700,ysize=500,retain=2)
but=widget_button(plotbase,value='OK',uvalue='ok')

widget_control,plotbase,/realize

; negative ref set to 10^-10
y=y > 10.e-10
xe=abs(xe)

nx=fltarr(1000)
ny=fltarr(1000)
ner=fltarr(1000)

; group data. groupd data is nx, ny and ner(new ...)
group,x,y,e,xe,ny,nx,ner

	if N_ELEMENTS(nx) lt 2 then begin
		errormessage,'Data bundled into oblivion!!'
		return
	end
; clip errors to 4. (4 orders of magnitude)
ner=ner<4.

; calc. errors
;errs=e/(y*alog(10.))


  
ploterr,nx,ny,ner
; get rid of negative errors
;errs=abs(errs)

; limits errors to 4 orders of magnitude (on log plot)
;errs=errs<4.
;ploterr,x,alog10(y),errs

xmanager,'message',plotbase

return
end

;**************************************************************************************************
;shows end message window with calculated values
pro endmessage

common varbwid,base
common varwid,lab,txt,but,gap
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3
common varset,norm,bg,r,fil
common varbg,bgrd

res=intarr(50)

if norm eq 0 then nrm='runtime' else nrm='monitor'
if bgrd eq 0 then bgd='average'
if bgrd eq 1 then bgd='fit'

endbase=widget_base(group_leader=base,/floating,title='Finished',column=2)

;column1
res(0)=widget_label(endbase,value='fac1: '+strcompress(string(fac1(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac2: '+strcompress(string(fac2(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac3: '+strcompress(string(fac3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Normalised: '+nrm,/align_left)
res(2)=widget_label(endbase,value='Backgrd used: '+bgd,/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Saved to: '''+strcompress(string(fil(1)),/remove_all)+'''',/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Go again?')
gap(0)=widget_label(endbase,value='',ysize=0)

;column2
res(1)=widget_label(endbase,value='th1: '+strcompress(string(th1(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th2: '+strcompress(string(th2(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th3: '+strcompress(string(th3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Tot. Backgrd: '+strcompress(string(bg[0]+bg[2]),/remove_all),/align_left)
res(2)=widget_label(endbase,value='Foregrd: '+strcompress(string(r(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
endbut1=widget_button(endbase,value='OK',uvalue='ok')
endbut2=widget_button(endbase,value='QUIT',uvalue='quit')

widget_control,endbase,/realize

xmanager,'message',endbase

return
end

;************************************************************************************
;shows error message window
pro errormessage,mes1

common varbwid,base
common EFLAGS,eflag

; If its really an error then display appropriate message
if eflag ne 0 then begin
print,'********************************************************************'
print,'ERROR!! TOF Calculations aborted. Check error message and try again.'
print,'********************************************************************'
errbase=widget_base(group_leader=base,/floating,title='Error Message',/column)
; Otherwise its just a warning
endif else errbase=widget_base(group_leader=base,/floating,title='Warning Message',/column)

mess1=widget_label(errbase,value=mes1)
errbut=widget_button(errbase,value='OK',uvalue='ok')

widget_control,errbase,/realize

xmanager,'message',errbase

return
end

;***********************************************************************************
;handles events from errormessage, endmessage and output
pro message_event,event

common varbwid,base
common varwid,lab,txt,but,gap
common varfac,fac1,fac2,fac3
common varth,th1,th2,th3

widget_control,event.id,get_uvalue=ev,get_value=val

;widget_control,event.top,/destroy

;if ev eq 'yes' then widget_control,base,sensitive=1	

if ev eq 'quit' then widget_control,base,/destroy

if ev eq 'ok' then begin
	widget_control,event.top,/destroy
	widget_control,base,sensitive=1
endif	

return
end

;*************************************************************************
;input TOF window

pro d17tof
common par,par2
common var0,def
common varbwid,base
common varwid,lab,txt,but,gap

;widget types: lab=label,txt=text,but=button,gap=label(null string)
lab=lonarr(50)
txt=lonarr(50)
but=lonarr(50)
gap=lonarr(50)

;don't show maths errors
!except=0

;defaults that appear in the TOF window
def='def'

; If badflag=0 then the default file (if it exists) is okay
; If badflag=1 then the default file has been found to be corrupted by
; ON_IOERROR below
			badflag=0
;dtb*=direct beam run numbers 
setdefaults:		dtb1=''
			dtb2=''
			dtb3=''

;refl*=reflected beam run numbers
			refl1=''
			refl2=''
			refl3=''

; Instrument background numors
			instbg1=''
			instbg2=''
			instbg3=''
;water=water run numbers (or def)
			water=''

;wavelength range
			lambda='2.1,16'

;th*=theta angle (or def=calculated)
			th1=def
			th2=def
			th3=def

;fac*=factor by which to multiply Reflectivity (or def=calculated such that curves match)
			fac1=def
			fac2=def
			fac3=def

;r=Foreground range
;bg=Background range
			r='11'
			bgl='0'
			bgr='0'

;norm=method by which reflected beam is normalised to direct beam (0=Runtime,1=Monitor)
			norm=1
;bgrd=method by which background rate is determined in range bg (0=left side of peak,1=both sides of peak,2=linear fit calc from both sides of peak)
			bgrd=1

;fil=output file name
			fil='tofdat.out'
;path=path of data runs to be anal2ysed
			path='/users/data/'
; useful x range of detector
			useful='30,239'
; area to search for peak
			peak_searchx='30,239'
			peak_searchy='def'
;check default file exists
			filcheck=findfile('tof_defaults.dat',count=checkfil)			
; if file exists and its not already been found to be corrupt
			if (checkfil ne 0) and (badflag eq 0) then begin
			spacer='XXXXXXX'
			ON_IOERROR, corruptdefs
			close,10
			openr,10,'tof_defaults.dat'
			readf,10,spacer
			readf,10,dtb1
			readf,10,spacer
			readf,10,dtb2
			readf,10,spacer
			readf,10,dtb3
;refl*=reflected beam run numbers
			readf,10,spacer
			readf,10,refl1
			readf,10,spacer
			readf,10,refl2			
			readf,10,spacer
			readf,10,refl3

;instbg8=instrument background numors
			readf,10,spacer
			readf,10,instbg1
			readf,10,spacer
			readf,10,instbg2
			readf,10,spacer
			readf,10,instbg3

;water=water run numbers (or def)
			readf,10,spacer
			readf,10,water

;wavelength range
			readf,10,spacer
			readf,10,lambda

;th*=theta angle (or def=calculated)
			readf,10,spacer
			readf,10,th1
			readf,10,spacer
			readf,10,th2
			readf,10,spacer
			readf,10,th3

;fac*=factor by which to multiply Reflectivity (or def=calculated such that curves match)
			readf,10,spacer
			readf,10,fac1
			readf,10,spacer
			readf,10,fac2			
			readf,10,spacer
			readf,10,fac3
;r=Foreground range
;bg=Background range
			readf,10,spacer
			readf,10,r
; Background
; Left
			readf,10,spacer			
			readf,10,bgl
; Right
			readf,10,spacer
			readf,10,bgr

;norm=method by which reflected beam is normalised to direct beam (0=Runtime,1=Monitor)
			readf,10,spacer
			readf,10,norm
;bgrd=method by which background rate is determined in range bg (0=left side of peak,1=both sides of peak,2=linear fit calc from both sides of peak)
			readf,10,spacer
			readf,10,bgrd

;fil=output file name
			readf,10,spacer
			readf,10,fil
;path=path of data runs to be anal2ysed
			readf,10,spacer
			readf,10,path
; useful xrange of detector
			readf,10,spacer
			readf,10,useful
; area to look for peak
			readf,10,spacer
			readf,10,peak_searchx
			readf,10,spacer
			readf,10,peak_searchy
			close,10
			end
			goto,fine
corruptdefs:
			print,'Corrupted defaults file - ignored. Hardwired defaults set.'
			badflag=1
			goto,setdefaults				
;base window divided into 5 columns
fine: base=widget_base(title='TOF Data',uvalue='base',column=6) 

;column 1
gap(10)=widget_label(base,ysize=10,value='')
lab(0)=widget_label(base,value='Run')
lab(1)=widget_label(base,value='set')
gap(0)=widget_label(base,ysize=0,value='')
lab(2)=widget_label(base,value='(1)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(3)=widget_label(base,value='(2)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(4)=widget_label(base,value='(3)  ',/align_right)
gap(23)=widget_label(base,ysize=15,value='')
lab(5)=widget_label(base,value='Water',/align_right)
lab(6)=widget_label(base,value='runs',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
lab(7)=widget_label(base,value='Lamda',/align_right)
lab(8)=widget_label(base,value='range',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
gap(0)=widget_label(base,ysize=0,value='')
lab(9)=widget_label(base,value='Normalise',/align_right)
lab(10)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 2
gap(10)=widget_label(base,ysize=10,value='')
lab(11)=widget_label(base,value='Direct')
lab(12)=widget_label(base,value='runs')
txt(0)=widget_text(base,value=dtb1,xsize=9,/editable,uvalue='int')
txt(1)=widget_text(base,value=dtb2,xsize=9,/editable,uvalue='int')
txt(2)=widget_text(base,value=dtb3,xsize=9,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(3)=widget_text(base,xsize=9,value=water,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(4)=widget_text(base,xsize=9,value=lambda,/editable,uvalue='real')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
but(0)=cw_bgroup(base,['Runtime','Monitor'],set_value=norm,/column,/exclusive,uvalue='norm')
gap(36)=widget_label(base,ysize=30,value='')
lab(11)=widget_label(base,value='Data Path:',/align_right)
lab(11)=widget_label(base,value='Output file:',/align_right)

;column 3
gap(10)=widget_label(base,ysize=10,value='')
lab(13)=widget_label(base,value='Reflect')
lab(14)=widget_label(base,value='runs')
txt(5)=widget_text(base,value=refl1,xsize=9,/editable,uvalue='int')
txt(6)=widget_text(base,value=refl2,xsize=9,/editable,uvalue='int')
txt(7)=widget_text(base,value=refl3,xsize=9,/editable,uvalue='int')
gap(16)=widget_label(base,ysize=16,value='')
lab(15)=widget_label(base,value='Foregrd',/align_right)
lab(16)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=10,value='')
lab(17)=widget_label(base,value='Backgrd',/align_right)
lab(18)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(20)=widget_label(base,ysize=20,value='')
lab(19)=widget_label(base,value='Bkgnd sub:',/align_right)
lab(21)=widget_label(base,value='method',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

txt(8)=widget_text(base,value=path,xsize=9,/editable,uvalue='str')
txt(9)=widget_text(base,value=fil,xsize=9,/editable,uvalue='str')
gap(0)=widget_label(base,ysize=0,value='')

;column 4
gap(10)=widget_label(base,ysize=10,value='')
lab(20)=widget_label(base,value='Instr. Bckgnd.')
lab(23)=widget_label(base,value='runs')
txt(10)=widget_text(base,xsize=4,value=instbg1,/editable,uvalue='real')
txt(11)=widget_text(base,xsize=4,value=instbg2,/editable,uvalue='real')
txt(12)=widget_text(base,xsize=4,value=instbg3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(13)=widget_text(base,xsize=4,value=r,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='left')
txt(14)=widget_text(base,xsize=4,value=bgl,/editable,uvalue='int')
gap(35)=widget_label(base,ysize=0,value='')
but(1)=cw_bgroup(base,['average','fit'],set_value=bgrd,/column,/exclusive,uvalue='bgrd')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=10,value='')
gap(0)=widget_label(base,ysize=0,value='')
but(3)=widget_button(base,value='DO IT',uvalue='done')
gap(0)=widget_label(base,ysize=0,value='')



;column 5
gap(10)=widget_label(base,ysize=10,value='')
lab(21)=widget_label(base,value='Factor')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(15)=widget_text(base,xsize=8,value=fac1,/editable,uvalue='real')
txt(16)=widget_text(base,xsize=8,value=fac2,/editable,uvalue='real')
txt(17)=widget_text(base,xsize=8,value=fac3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=20,value='')
gap(0)=widget_label(base,ysize=22,value='')
gap(6)=widget_label(base,ysize=10,value='')
gap(10)=widget_label(base,ysize=0,value='right')
txt(18)=widget_text(base,xsize=8,value=bgr,/editable,uvalue='int')
gap(40)=widget_label(base,ysize=40,value='')
gap(20)=widget_label(base,ysize=20,value='')
gap(35)=widget_label(base,ysize=35,value='')
but(2)=widget_button(base,value='QUIT',uvalue='quit')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 6
gap(10)=widget_label(base,ysize=10,value='')
lab(22)=widget_label(base,value='Theta')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(19)=widget_text(base,xsize=4,value=th1,/editable,uvalue='real')
txt(20)=widget_text(base,xsize=4,value=th2,/editable,uvalue='real')
txt(21)=widget_text(base,xsize=4,value=th3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')


gap(0)=widget_label(base,ysize=0,value='Detector')
gap(6)=widget_label(base,ysize=0,value='ranges')

drange = widget_base(base,/FRAME,/BASE_ALIGN_CENTER,/COLUMN)
gap(40)=widget_label(drange,value='Useful x range')
txt(22)=widget_text(drange,xsize=8,value=useful,/editable)
gap(6)=widget_label(drange,value='Area to look')
gap(0)=widget_label(drange,value=' for peak')
gap(6)=widget_label(drange,value='(xmin,xmax)')
txt(23)=widget_text(drange,xsize=8,value=peak_searchx,/editable)
gap(6)=widget_label(drange,value='(ymin,ymax)')
txt(24)=widget_text(drange,xsize=8,value=peak_searchy,/editable)

gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(6)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;gives the TOF window a margin
baseinfo=widget_info(base,/geometry)
widget_control,base,scr_xsize=baseinfo.scr_xsize+10
widget_control,base,scr_ysize=baseinfo.scr_ysize+10

;creates the TOF window
widget_control,base,/realize

;calls 'pro tof_event'
xmanager,'tof',base

end
pro d20ff,w,filename
@lamp.cbk
take_datp,datp
datname=filename+'.dat'
PRINT,'Please use d20reg for output of three-columns xy-data!'
wmax=0.
OPENW,dat,datname,/get_lun
IF N_ELEMENTS(w(0,*,*)) GT 1 THEN PRINT,'Only the first pattern will be exported'
ww=w(*,0,0)
nd=ROUND(10.*(max(datp.x(*,0,0))-min(datp.x(*,0,0)))+1.)
x=FINDGEN(nd)+min(datp.x(*,0,0))
ww=INTERPOL(w(*,0,0),datp.x(*,0,0),x)
ee=INTERPOL(datp.e(*,0,0),datp.x(*,0,0),x)
wmax=max(ww)
wmax_old=wmax
WHILE wmax gt 9999999.9 DO wmax=wmax/10.
norm=wmax_old/wmax
if datp.p(12) gt 9990. then datp.p(12)=0.
if datp.p(11) gt 9990. then datp.p(11)=0.
PRINTF,dat,format='(A5,A75)','D1A5 ',datp.w_tit    
PRINTF,dat,format='(A80)',datp.other_tit    
PRINTF,dat,format='(A80)',' '
PRINTF,dat,format='(i6,2f8.2,i6,2f12.0)',10*FLOOR(.1+N_ELEMENTS(w(*,0,0))/10),datp.p(12),datp.p(11),1,datp.n(0,0,0)/norm,datp.p(30)
NNN=N_ELEMENTS(w(*,0,0))-1
PRINTF,dat,FORMAT='(3f10.3)',datp.x(0,0,0),(datp.x(1,0,0)-datp.x(0,0,0)),datp.x(nnn,0,0)
NN=(N_ELEMENTS(w(*,0,0)))/10.
FOR ii=0,NN-1 DO BEGIN
i=10*ii
PRINTF,dat,FORMAT='(10F8.0)',ww(i)/norm,ww(i+1)/norm,ww(i+2)/norm,ww(i+3)/norm,ww(i+4)/norm,ww(i+5)/norm,ww(i+6)/norm,ww(i+7)/norm,ww(i+8)/norm,ww(i+9)/norm
ENDFOR
FOR ii=0,NN-1 DO BEGIN
i=10*ii
PRINTF,dat,FORMAT='(10F8.2)',ee(i)/norm,ee(i+1)/norm,ee(i+2)/norm,ee(i+3)/norm,ee(i+4)/norm,ee(i+5)/norm,ee(i+6)/norm,ee(i+7)/norm,ee(i+8)/norm,ee(i+9)/norm
ENDFOR
CLOSE,dat
FREE_LUN,dat
END
pro d20reg,w,filename,extension,comment=comment,par=par,bad=bad,datp=datp,nolamp=nolamp
;IF NOT KEYWORD_SET(nolamp) THEN BEGIN
;  XiCute,'@lamp.cbk'
;ENDIF
IF N_ELEMENTS(w(0,*)) GT 1 THEN PRINT,'Attention: This macro does not support yet export of 2-dimensional workspaces!'
IF not keyword_set(datp) THEN take_datp,datp
;help,datp,/struc
IF N_ELEMENTS(datp.e) LT N_ELEMENTS(w) THEN mod_datp,datp,'e',SQRT(W)
if n_elements(filename) eq 0 then BEGIN
  IF N_ELEMENTS (W_NUMOR) GT 0 AND N_ELEMENTS(alone) GT 0 THEN BEGIN
    filename=W_NUMOR(alone) 
  ENDIF ELSE BEGIN
    filename='d20reg'
  ENDELSE
ENDIF
if n_elements(extension) eq 0 then extension='xy'
datname=filename+'.'+extension
OPENW,dat,datname,/get_lun
if extension ne 'dat' then cross='#' ELSE cross='!'
PRINTF,dat,cross+' ',strmid(datp.other_tit ,0,76)   
IF STRLEN(datp.other_tit) GT 76 THEN PRINTF,dat,cross+' ...',strmid(datp.other_tit ,76,72)
PRINTF,dat,cross+' ',strmid(datp.w_tit  ,0,76)   
IF STRLEN(datp.w_tit) GT 76 THEN PRINTF,dat,cross+' ... ',strmid(datp.w_tit ,76,72)
;PRINTF,dat,cross+' ',filename,'.',extension
IF KEYWORD_SET(comment) THEN PRINTF,dat,cross+' ',comment
PRINTF,dat,cross+''
PRINTF,dat,cross+' telnet d20sgi.ill.fr | lamp -nw'
FOR i=1,20 DO BEGIN
    search='w'+strcompress(string(i),/remove)
    flag=0
    IF N_ELEMENTS(alone) EQ 1 THEN IF i NE alone THEN BEGIN
      FOR j=0,STRLEN(his(alone))-STRLEN(search)-1 DO BEGIN
        test=strmid(his(alone),j,STRLEN(search))
        if test EQ search and flag eq 0 THEN  BEGIN
          PRINTF,dat,cross+'   '+strmid(his(i),0,76)   
          IF STRLEN(his(i)) GT 76 THEN PRINTF,dat,cross+' ...'+strmid(his(i) ,76,72)
          flag=1
        ENDIF
      ENDFOR
    ENDIF
ENDFOR
IF N_ELEMENTS(alone) NE 1 THEN alone=0
IF N_ELEMENTS(his) GT alone THEN BEGIN
  PRINTF,dat,cross+'   '+strmid(his(alone),0,76)  
  IF STRLEN(his(alone)) GT 76 THEN PRINTF,dat,cross+' ...'+strmid(his(alone) ,76,72)
ENDIF
PRINTF,dat,cross+' d20reg,W',strcompress(string(alone),/r),',"',filename,'","',extension,'"'
PRINTF,dat,cross+''
PRINTF,dat,cross+' Created: ',systime()
IF N_ELEMENTS(lamp_host) EQ 1 THEN PRINTF,dat,cross+'      By: ',lamp_host
if extension ne 'dat' then PRINTF,dat,cross+' x-y-dy to be read by xmgr, gnuplot, igor etc.' ELSE PRINTF,dat,cross+' fullprof : INSTR=10'
IF KEYWORD_SET(par) THEN PRINTF,dat,cross+''
IF KEYWORD_SET(par) THEN par=par(WHERE(par LT N_ELEMENTS(datp.p) AND par GE 0))
IF KEYWORD_SET(par) THEN FOR i=0,N_ELEMENTS(par)-1 DO PRINTF,dat,cross+' ',datp.par_txt(par(i)),datp.p(par(i))
IF KEYWORD_SET(bad) THEN PRINTF,dat,cross+''
IF KEYWORD_SET(bad) THEN BEGIN
  IF N_ELEMENTS(datp.z) EQ 0 THEN PRINTF,dat,cross+' no bad cells' ELSE BEGIN
    IF N_ELEMENTS(w(*,0))+N_ELEMENTS(datp.z) EQ 1600 THEN BEGIN
      PRINTF,dat,cross+string(N_ELEMENTS(datp.z))+' bad cells excluded : cell-no.' 
      FOR i=0,(N_ELEMENTS(datp.z)-1)/15 DO PRINTF,dat,cross+strcompress(datp.z(i*15:i*15+14))
    ENDIF ELSE BEGIN
      PRINTF,dat,cross+string(N_ELEMENTS(datp.z))+' bad cells not excluded, evt. interpolated : cell-no. angle (2th.)' 
      FOR i=0,(N_ELEMENTS(datp.z)-1) DO PRINTF,dat,cross,datp.z(i),datp.x(datp.z(i))
      ENDELSE
  ENDELSE
ENDIF
PRINTF,dat,cross+''
PRINTF,dat,cross+' Monitor/counts   Counting time/sec (A2,F15.0,F9.1)'
PRINTF,dat,format='(A2,F15.0,F9.1)',cross+' ',datp.n(0,0:1<(N_ELEMENTS(datp.n(0,*,0))-1),0)
PRINTF,dat,cross+''
PRINTF,dat,cross+'  angle  counts   sigma (F9.3,F15.1,F9.2)'
PRINT,'Export of ',N_ELEMENTS(w(*,0,0)), ' cells to ',filename,'.',extension
FOR i=0,N_ELEMENTS(w(*,0,0))-1 DO BEGIN
  IF datp.x(i,0,0) GE 0 THEN BEGIN
    PRINTF,dat,FORMAT='(F9.3,F25.3,F15.4)',datp.x(i,0,0),w(i,0,0)<1E19,datp.e(i,0,0)<1E9
  ENDIF
ENDFOR
; PRINTF,dat,cross+' end of data file'
FREE_LUN,dat
END
PRO int_ev,ID
  IF ID.SELECT EQ 1 THEN flag,/int,/nop ELSE flag,/noint,/nop
END

PRO eff_ev,ID
  common d20widget, text,mon
  common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
  IF ID.SELECT EQ 1 THEN BEGIN
    flag,/eff,/nop 
    IF N_ELEMENTS(inf_d20) GT 0 THEN WIDGET_CONTROL,text,SET_VALUE=inf_d20(0),/APPEND
    IF N_ELEMENTS(inf_d20) GT 1 THEN WIDGET_CONTROL,text,SET_VALUE=inf_d20(1),/APPEND
    IF N_ELEMENTS(inf_d20) GT 2 THEN WIDGET_CONTROL,text,SET_VALUE=inf_d20(2),/APPEND
  ENDIF ELSE flag,/noeff,/nop
END

PRO nor_ev,ID
  common d20widget, text,mon
  common d20  , bad_d20 ,flag_d20, wav_d20, psd_d20   
  IF ID.SELECT EQ 1 THEN BEGIN
    str=''
    WIDGET_CONTROL,mon, bad_id=ii, get_value=str
    ;PRINT,str(0)
    flag,nor=FLOAT(str(0)),/nop 
    WIDGET_CONTROL,mon,SET_VALUE=STRING(flag_d20(4))
  ENDIF ELSE flag,/nonor,/nop
END

PRO ang_ev,ID
  common d20widget, text,mon
  common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
  IF ID.SELECT EQ 1 THEN BEGIN
    flag,/ang,/nop 
    IF N_ELEMENTS(inf_d20) GT 0 THEN WIDGET_CONTROL,text,SET_VALUE=inf_d20(0),/APPEND
    IF N_ELEMENTS(inf_d20) GT 1 THEN WIDGET_CONTROL,text,SET_VALUE=inf_d20(1),/APPEND
    IF N_ELEMENTS(inf_d20) GT 2 THEN WIDGET_CONTROL,text,SET_VALUE=inf_d20(2),/APPEND
  ENDIF ELSE flag,/noang,/nop
END

PRO bad_ev,ID
  common d20widget, text,mon
  common d20  , bad_d20 ,flag_d20, wav_d20, psd_d20   
  IF ID.SELECT EQ 1 THEN BEGIN
    flag,/bad,/nop 
    WIDGET_CONTROL,text,SET_VALUE=STRING(N_ELEMENTS(bad_d20))+' bad cells',$
      /APPEND
  ENDIF ELSE flag,/nobad,/nop
END

PRO cal_ev,ID
  calibration
END

PRO mon_ev,ID
  common d20  , bad_d20 ,flag_d20, wav_d20, psd_d20   
  common d20widget, text,mon
  IF flag_d20(4) NE 0 THEN BEGIN
    str=''
    WIDGET_CONTROL,mon, bad_id=ii, get_value=str
    ;PRINT,str(0)
    flag,nor=FLOAT(str(0)),/nop 
  ENDIF
  ;HELP,ID,/STR
END

PRO d20_widget
  common d20widget, text,mon
  common d20  , bad_d20 ,flag_d20, wav_d20, psd_d20   
  common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
  IF XREGISTERED('d20_widget') THEN RETURN
  result=0
  widget=WIDGET_BASE(title='D20 Options Widget',/ROW)
  text=widget_text(widget,ysize=10,xsize=40)
  flag=WIDGET_BASE   (widget,/nonexclusive)
  eff=WIDGET_BUTTON (flag,value='Efficiency Correction' ,uvalue=[-88,379,8,3],EVENT_PRO='eff_ev')
  IF flag_d20(6) EQ 1 THEN WIDGET_CONTROL,eff,/Set_Button
  ang=WIDGET_BUTTON (flag,value='Angle Calibration' ,uvalue=[-88,379,8,3],EVENT_PRO='ang_ev')
  IF flag_d20(2) EQ 1 THEN WIDGET_CONTROL,ang,/Set_Button
  nor=WIDGET_BUTTON (flag,value='Monitor Normalisation' ,uvalue=[-88,379,8,3],EVENT_PRO='nor_ev')
  IF flag_d20(4) GT 0 THEN WIDGET_CONTROL,nor,/Set_Button
  bad=WIDGET_BUTTON (flag,value='Exclusion of bad and zero counting cells' ,uvalue=[-88,379,8,3],$
    EVENT_PRO='bad_ev')
  IF flag_d20(0) EQ 1 THEN WIDGET_CONTROL,bad,/Set_Button
  int=WIDGET_BUTTON (flag,value='Interpolation to equidistant data' ,uvalue=[-88,379,8,3],EVENT_PRO='int_ev')
  IF flag_d20(1) EQ 1 THEN WIDGET_CONTROL,int,/Set_Button
  right=WIDGET_BASE(widget,/COL)
  mon=WIDGET_TEXT(right,value=strtrim(string(flag_d20(4)),2),xsize=20,ysize=1,$
    /EDITABLE,/ALL_EVENTS,$
    EVENT_PRO='mon_ev')
  cal=WIDGET_BUTTON (right,value='Calibration files' ,uvalue=[-88,379,8,3],EVENT_PRO='cal_ev')
  WIDGET_CONTROL,widget,/REALIZE
  IF flag_d20(4) LE 0 THEN WIDGET_CONTROL,mon,SET_VALUE='100000'
  WIDGET_CONTROL,text,SET_VALUE='D20 specific options'
  WIDGET_CONTROL,text,SET_VALUE='All changes will only be applied to next data read in!',/APPEND
  WIDGET_CONTROL,text,SET_VALUE='Click on "DATA Access ..." for accessing instrument data (numors)',/APPEND
  WIDGET_CONTROL,text,SET_VALUE='To change the calibration file manually, call "calibration"',/APPEND
  HELP,inf_d20,/stru 
  XMANAGER,'d20_widget',widget,Event_Handler='LAMP_EVENT_PARSER',/just_reg
END
pro d22kin_add_event,ev
;** ****************
;**

widget_control,ev.id,get_uvalue=uv
case uv(0) of

;*****ADD*****
1:begin widget_control,uv(1),get_value=file1 & file1=file1(0)
	widget_control,uv(2),get_value=file2 & file2=file2(0)
	widget_control,uv(3),get_value=file3 & file3=file3(0)
	widget_control,uv(4),get_value=filen & filen=filen(0)

	if not (file1 eq '') then begin
	x=0
	openr,u,file1+'.tic',/get_lun,error=err
	if (err ne 0) then widget_control,uv(5),set_value=file1+' : no such file' else begin
	widget_control,uv(5),set_value=''
	while not eof(u) do begin
	readf,u,a
	x=x+1
	endwhile
	close,u
	free_lun,u
	t1=lonarr(x)
	openr,u,file1+'.tic',/get_lun
	for i=0,x-1 do begin
	readf,u,a
	t1(i)=a
	endfor
	close,u
	free_lun,u

	if not (file2 eq '') then begin
	x=0
	openr,u,file2+'.tic',/get_lun,error=err
	if (err ne 0) then widget_control,uv(5),set_value=file2+' : no such file' else begin
	widget_control,uv(5),set_value=''
	while not eof(u) do begin
	readf,u,a
	x=x+1
	endwhile
	close,u
	free_lun,u
	t2=lonarr(x)
	openr,u,file2+'.tic',/get_lun
	for i=0,x-1 do begin
	readf,u,a
	t2(i)=a
	endfor
	close,u
	free_lun,u

	if not (file3 eq '') then begin	
	x=0
	openr,u,file3+'.tic',/get_lun,error=err
	if (err ne 0) then widget_control,uv(5),set_value=file3+' : no such file' else begin
	widget_control,uv(5),set_value=''
	while not eof(u) do begin
	readf,u,a
	x=x+1
	endwhile
	close,u
	free_lun,u
	t3=lonarr(x)
	openr,u,file3+'.tic',/get_lun
	for i=0,x-1 do begin
	readf,u,a
	t3(i)=a
	endfor
	close,u
	free_lun,u
	endelse
endif
	endelse
endif
	endelse
endif
	a=n_elements(t1)+n_elements(t2)
	if not (file3 eq '') then a=a+n_elements(t3)
	if a lt 450 then begin
	if not (filen eq '') then begin
	openw,u,filen+'.tic',/get_lun
	for i=0,n_elements(t1)-1 do begin
	printf,u,t1(i)
	endfor
	for i=0,n_elements(t2)-1 do begin
	printf,u,t2(i)
	endfor
	if not (file3 eq '') then begin
	for i=0,n_elements(t3)-1 do begin
	printf,u,t3(i)
	endfor
	endif
	close,u
	free_lun,u
	x=n_elements(t1)+n_elements(t2)
	if not (file3 eq '') then x=x+n_elements(t3)
	tick=90.9e-9
	t=lonarr(x)
	sec=fltarr(x)
	sum=strarr(x)
	openr,u,filen+'.tic',/get_lun
	for i=0,x-1 do begin
	readf,u,c
	t(i)=c
	d=t(i)*tick
	sec(i)=d
	endfor
	close,u
	free_lun,u
	sum(0)=sec(0)
	for i=1,x-1 do sum(i)=sum(i-1)+ sec(i)
	total='total time :'+strtrim((sum(x-1)),2)
	frame='frames :'+strtrim((string(x)),2)	
	widget_control,uv(6),set_value=total
	widget_control,uv(7),set_value=frame
endif
endif

  end
2:begin widget_control,ev.top,/destroy
  end

else:

endcase

end

pro d22kin_add
;** **********
;**

base0 = widget_base   (title='D22 KIN Concatenation of files',/column,frame=5)
title = widget_label  (base0,value='Concatenation of files')

base  = widget_base   (base0,/column,frame=5)

base1 = widget_base   (base ,/row)
label = widget_label  (base1,value='First  file :')
file1 = widget_text   (base1,value='',/editable,xsize=7)
label = widget_label  (base1,value='.tic')

base2 = widget_base   (base ,/row)
label = widget_label  (base2,value='Second file :')
file2 = widget_text   (base2,value='',/editable,xsize=7)
label = widget_label  (base2,value='.tic')

base3 = widget_base   (base ,/row)
label = widget_label  (base3,value='Third  file :')
file3 = widget_text   (base3,value='',/editable,xsize=7)
label = widget_label  (base3,value='.tic')

base5 = widget_base   (base ,/row)
label = widget_label  (base5,value='New file :')
filen = widget_text   (base5,value='',/editable,xsize=7)
label = widget_label  (base5,value='.tic')
add   = widget_button (base5,value='Add',uvalue=1)

base6 = widget_base  (base,/row)
total = widget_label (base6,value='',/dynamic_resize)
frame = widget_label (base6,value='',/dynamic_resize)

base4 = widget_base   (base0,/row)
exit  = widget_button (base4,value='Exit',uvalue=2)
mesg  = widget_label  (base4,value='',/dynamic_resize)

widget_control,add,set_uvalue=[1,file1,file2,file3,filen,mesg,total,frame]

widget_control,base0,/realize
xmanager,'d22kin_add',base0,/just_reg
end
pro d22kin_const_event,ev
;** ******************
;**

widget_control,ev.id,get_uvalue=uv
case uv(0) of

;*****TIME PRESET CONTROL*****
1:begin widget_control,ev.id,get_value=presets & presets=presets(0)
	ok=0								
	on_ioerror,mispreset
	preset=float(presets)
	ok=1
	mispreset: if not ok then widget_control,uv(1),set_value='Error Preset'$
			else widget_control,uv(1),set_value=''
  end

;*****TIME CONTROL*****
2:begin widget_control,ev.id,get_value=times & times=times(0)
	ok=0								
	on_ioerror,mistime
	time=float(times)
	ok=1
	mistime: if not ok then widget_control,uv(1),set_value='Error Time'$
			else widget_control,uv(1),set_value=''
  end

;*****DO********
3:begin t=1 & t1=1 & t2=1
	e=0 & e1=0	

	widget_control,uv(1),get_value=presets & presets=presets(0)
	ok=0								
	on_ioerror,mispreset1
	preset=float(presets)
	ok=1
	mispreset1: if not ok then t=0

	widget_control,uv(2),get_value=times & times=times(0)
	ok=0								
	on_ioerror,mistime1
	time=float(times)
	ok=1
	mistime1:   if not ok then t1=0

	widget_control,uv(3),get_value=file & file=file(0)

if (not (preset eq 0) and not (time eq 0)) then begin

	if t  eq 0 then widget_control,uv(4),set_value='error preset' $
		else begin
			if preset gt 390 then begin
			widget_control,uv(4),set_value='preset less than 390s'
			e=1
			endif else begin
	if t1 eq 0 then begin
		widget_control,uv(4),set_value='error total time'
		e1=1
		endif else widget_control,uv(4),set_value=''
endelse
endelse

if ((t eq 1) and (t1 eq 1)) then begin
if ((e eq 0) and (e1 eq 0)) then begin 

	tick=90.9e-9
	tick=preset/tick	;*transforme s en tick
	x=time/preset		;*nombre de frames
	x=fix(x)

	if x  gt 450 then begin
		widget_control,uv(4),set_value='too many frames'
		t2=0
		endif else begin
		widget_control,uv(4),set_value=''
		endelse

if (t2 eq 1)  then begin
	tic=lonarr(x)
	sec=strarr(x)
	sum=strarr(x)
	s=0
	for i=0,x-1 do begin
		tic(i)=tick
		sec(i)=preset
	endfor
	sum(0)=preset
	total=0
	for i=1,x-1 do begin
		sum(i)=sum(i-1)+preset
	endfor
	if not (file eq '') then begin
	openw,u,file+'.tmp',/get_lun
	printf,u,'      NB       TICKS      SECONDS         SUM  '
	for i=0,x-1 do begin
	printf,u,i+1,tic(i),sec(i),sum(i)
	endfor
	close,u
	free_lun,u
	total='total time :'+strtrim((sum(x-1)),2)
	frame=' frames :'+strtrim((string(x)),2)
	widget_control,uv(5),set_value=total
	widget_control,uv(6),set_value=frame
	xdisplayfile,file+'.tmp',group=ev.top,height=10,width=50
	endif else begin
	openw,u,'kin.tmp',/get_lun
	printf,u,'      NB       TICKS      SECONDS         SUM  '
	for i=0,x-1 do begin
	printf,u,i+1,tic(i),sec(i),sum(i)
	endfor
	close,u
	free_lun,u
	total='total time :'+strtrim((sum(x-1)),2)
	frame=' frames :'+strtrim((string(x)),2)
	widget_control,uv(5),set_value=total
	widget_control,uv(6),set_value=frame
	xdisplayfile,'kin.tmp',group=ev.top,height=10,width=50
	endelse
endif
endif
endif
endif
  end

;*****SAVE*********
4:begin widget_control,uv(1),get_value=presets & presets=presets(0)
	preset=float(presets)
	widget_control,uv(2),get_value=times & times=times(0)
	time=float(times)
	widget_control,uv(3),get_value=save & save=save(0)
if (not (preset eq 0) and not (time eq 0)) then begin
	tick=90.9e-9
	tick=preset/tick ;*transforme s en tick
	x=time/preset    ;*nombre de frames
	x=fix(x)
	tic=lonarr(x)
	for i=0,x-1 do begin
		tic(i)=tick
	endfor
	openw,u,save+'.tic',/get_lun
	for i=0,x-1 do begin
	printf,u,tic(i)
	endfor
	close,u
	free_lun,u
	endif
  end

;*****EXIT*********
5:begin widget_control,ev.top,/destroy
  end

else:

endcase

end

pro d22kin_const
;** ************
;**

base   = widget_base  (title='D22 KIN Constant acquisition',/column,frame=5)
title  = widget_label (base,value='Constant acquisition time')

base0  = widget_base  (base,/column,frame=5)

base1  = widget_base  (base0,/row)
label  = widget_label (base1,value='Preset (s) :')
preset = widget_text  (base1,value='',/editable,xsize=5,uvalue=1)
label  = widget_label (base1,value='Total time (s) :')
time   = widget_text  (base1,value='',/editable,xsize=5,uvalue=2)
do0    = widget_button(base1,value='Do',uvalue=3)

base2  = widget_base  (base0,/row)
label  = widget_label (base2,value='Saved in file :')
file   = widget_text  (base2,value='',/editable,xsize=10)
label  = widget_label (base2,value='.tic ')
save   = widget_button(base2,value='Save',uvalue=4)

base4  = widget_base  (base,/row)
total  = widget_label (base4,value='',/dynamic_resize)
frame  = widget_label (base4,value='',/dynamic_resize)

base3  = widget_base  (base,/row)
exit   = widget_button(base3,value='Exit',uvalue=5)
mesg   = widget_label (base3,value='',/dynamic_resize)

widget_control,preset,set_uvalue=[1,mesg]
widget_control,time  ,set_uvalue=[2,mesg]
widget_control,do0   ,set_uvalue=[3,preset,time,file,mesg,total,frame]
widget_control,save  ,set_uvalue=[4,preset,time,file,mesg]

widget_control,base,/realize
xmanager,'d22kin_const',base,/just_reg
end
pro d22kin_log_event,ev
;** ****************
;**

widget_control,ev.id,get_uvalue=uv
case uv(0) of

;*****FIRST TIME CONTROL*****
1:begin widget_control,ev.id,get_value=firsts & firsts=firsts(0)
	ok=0
	on_ioerror,misfirst
	first=float(firsts)
	ok=1
	misfirst: if not ok then widget_control,uv(1),set_value='Error First time'$
			else widget_control,uv(1),set_value=''
  end

;*****INCREMENT CONTROL*****
2:begin widget_control,ev.id,get_value=incres & incres=incres(0)
	ok=0
	on_ioerror,misincre
	incre=float(incres)
	ok=1
	misincre: if not ok then widget_control,uv(1),set_value='Error Increment'$
			else widget_control,uv(1),set_value=''
  end

;*****TIME CONTROL******
3:begin widget_control,ev.id,get_value=times & times=times(0)
	ok=0
	on_ioerror,mistime
	time=float(times)
	ok=1
	mistime: if not ok then widget_control,uv(1),set_value='Error Time' $
			else widget_control,uv(1),set_value=''
  end

;*****DO*****
4:begin t0=1 & t1=1 & t2=1 & t3=1
	e =0 & e1=0 & e2=0 & e3=0	

	widget_control,uv(1),get_value=firsts & firsts=firsts(0)
	ok=0								
	on_ioerror,misfirst1
	first=float(firsts)
	ok=1
	misfirst1: if not ok then t0=0

	widget_control,uv(2),get_value=incres & incres=incres(0)
	ok=0								
	on_ioerror,misincre1
	incre=float(incres)
	ok=1
	misincre1: if not ok then t1=0

	widget_control,uv(3),get_value=times & times=times(0)
	ok=0								
	on_ioerror,mistime1
	time=float(times)
	ok=1
	mistime1: if not ok then t2=0

	widget_control,uv(4),get_value=file & file=file(0)

	if ((first ne 0) and (incre ne 0) and (time ne 0)) then begin

	if t0 eq 0 then widget_control,uv(5),set_value='error first time'$
		else begin
			if first gt 390 then begin
			widget_control,uv(5),set_value='first time less than 390s'
			e=1
			endif else begin
	if t1 eq 0 then widget_control,uv(5),set_value='error increment'$
		else begin
			if first gt 390 then begin
			widget_control,uv(5),set_value='incrment less than 390s'
			e1=1
			endif else begin
	if t2 eq 0 then begin
		widget_control,uv(5),set_value='error total time'
		e2=1
		endif else widget_control,uv(5),set_value=''
endelse
endelse
endelse
endelse

if ((t0 eq 1) and (t1 eq 1) and (t2 eq 1)) then begin
if ((e  eq 0) and (e1 eq 0) and (e2 eq 0)) then begin 

	tick=90.9e-9
	a=first
	b=first
	x=0
	while ((b le time) and (x le 450)) do begin
		a=a*incre
		x=x+1
		b=b+a
	endwhile
print,x
	if x  gt 450 then begin
		widget_control,uv(5),set_value='too many frames'
		t3=0
		endif else widget_control,uv(5),set_value=''		

if (t3 eq 1)  then begin

	tic=lonarr(x)
	sec=strarr(x)
	sum=strarr(x)
	a=first
	tic(0)=a/tick
	sec(0)=a
	sum(0)=first
	for i=1,x-1 do begin
		a=a*incre
		sum(i)=a+sum(i-1)
		t=a/tick
		tic(i)=t
		sec(i)=a
	endfor
	for i=0,x-1 do begin
		if (sec(i) gt 390) then begin
		widget_control,uv(5),set_value='time must less than 390s'
		e3=1
		endif else widget_control,uv(5),set_value=''
	endfor
if (e3 eq 0)  then begin

	if not (file eq '') then begin
	openw,u,file+'.tmp',/get_lun
	printf,u,'      NB       TICKS      SECONDS         SUM  '
	for i=0,x-1 do begin
	printf,u,i+1,tic(i),sec(i),sum(i)
	endfor
	close,u
	free_lun,u
	total='total time :'+strtrim((sum(x-1)),2)
	frame=' frames :'+strtrim((string(x)),2)
	widget_control,uv(6),set_value=total
	widget_control,uv(7),set_value=frame
	xdisplayfile,file+'.tmp',group=ev.top,height=10,width=50
	endif else begin
	openw,u,'kin.tmp',/get_lun
	printf,u,'      NB       TICKS      SECONDS         SUM  '
	for i=0,x-1 do begin
	printf,u,i+1,tic(i),sec(i),sum(i)
	endfor
	close,u
	free_lun,u
	total='total time :'+strtrim((sum(x-1)),2)
	frame=' frames :'+strtrim((string(x)),2)
	widget_control,uv(6),set_value=total
	widget_control,uv(7),set_value=frame
	xdisplayfile,'kin.tmp',group=ev.top,height=10,width=50
	endelse

endif
endif
endif
endif
endif
  end

;*****SAVE*****
5:begin widget_control,uv(1),get_value=firsts & firsts=firsts(0)
	first=float(firsts)
	widget_control,uv(2),get_value=incres & incres=incres(0)
	incre=float(incres)
	widget_control,uv(3),get_value=times  & times =times (0)
	time=float(times)
	widget_control,uv(4),get_value=file   & file  =file  (0)
	if ((first ne 0) and (incre ne 0) and (time ne 0)) then begin
	tick=90.9e-9
	a=first
	b=first
	x=0
	while (b le time) do begin
		a=a*incre
		x=x+1
		b=b+a
	endwhile
	tic=lonarr(x)
	a=first
	tic(0)=a/tick
	for i=1,x-1 do begin
		a=a*incre
		t=a/tick
		tic(i)=t
	endfor
	openw,u,file+'.tic',/get_lun
	for i=0,x-1 do begin
	printf,u,tic(i)
	endfor
	close,u
	free_lun,u
	endif
 end

;*****EXIT*****
6:begin widget_control,ev.top,/destroy
  end

else:

endcase

end

pro d22kin_log
;** **********
;**

base  = widget_base   (title='D22 KIN logarithmic acquisition',/column,frame=5)
title = widget_label  (base,value='Logarithmic increase of the acquisition times')

base0 = widget_base   (base ,/column,frame=5)

base1 = widget_base   (base0 ,/row)
label = widget_label  (base1,value='First time (s) :')
first = widget_text   (base1,value='',/editable,xsize=5,uvalue=1)
label = widget_label  (base1,value='Increment (s) :')
incre = widget_text   (base1,value='',/editable,xsize=5,uvalue=2)

base2 = widget_base   (base0 ,/row)
label = widget_label  (base2,value='Roughly total time (s) :')
time  = widget_text   (base2,value='',/editable,xsize=5,uvalue=3)
do0   = widget_button (base2,value='Do',uvalue=4)

base3 = widget_base   (base0 ,/row)
label = widget_label  (base3,value='Saved in file :')
file  = widget_text   (base3,value='',/editable,xsize=10)
label = widget_label  (base3,value='.tic')
save  = widget_button (base3,value='Save',uvalue=5)

base5 = widget_base  (base,/row)
total = widget_label (base5,value='',/dynamic_resize)
frame = widget_label (base5,value='',/dynamic_resize)

base4 = widget_base   (base ,/row)
exit  = widget_button (base4,value='Exit',uvalue=6)
mesg  = widget_label  (base4,value='',/dynamic_resize)

widget_control,first,set_uvalue=[1,mesg]
widget_control,incre,set_uvalue=[2,mesg]
widget_control,time ,set_uvalue=[3,mesg]
widget_control,do0  ,set_uvalue=[4,first,incre,time,file,mesg,total,frame]
widget_control,save ,set_uvalue=[5,first,incre,time,file,mesg]


widget_control,base,/realize
xmanager,'d22kin_log',base,/just_reg
end
pro d22kin_pers_event,ev
;** *****************
;**

widget_control,ev.id,get_uvalue=uv
case uv(0) of

;*****TIME CONTROL*****
1:begin widget_control,ev.id,type=1,get_value=times & times=times(0)
	ok=0
	on_ioerror,mistime
	time=float(times)
	ok=1
	mistime: if not ok then widget_control,uv(1),set_value='Error Time' $
			else widget_control,uv(1),set_value=''


  end

;*****DO*****
2:begin t=1

	widget_control,uv(1),get_value=times 
	ok=0
	on_ioerror,mistime1
	time=byte(times)
	ok=1
	mistime1: if not ok then t=0
	widget_control,uv(2),get_value=file & file=file(0)
	if (t eq 0) then widget_control,uv(3),set_value='Error Time' $
		else widget_control,uv(3),set_value=''

if (t eq 1) then begin

	widget_control,uv(1),get_value=time
	tick=90.9e-9
	x=n_elements(time)
	if (time(x-1) eq 0) then x=x-1
if not (x eq 0) then begin
	t  =lonarr(x)
	sec=fltarr(x)
	sum=fltarr(x+1)
	if (x lt 450) then begin
		for i=0,x-1 do begin
		tic=time(i)/tick
		t(i)=tic
		sec(i)=time(i)
		endfor
	sum(0)= sec(0)
		for i=1,x-1 do 	sum(i)=sum(i-1)+sec(i)

	if not (file eq '') then begin
	openw,u,file+'.tmp',/get_lun
	printf,u,'      NB       TICKS      SECONDS          SUM  '
	for i=0,x-1 do begin
	printf,u,i+1,t(i),sec(i),sum(i)
	endfor
	close,u
	free_lun,u
	total='total time :'+strtrim((sum(x-1)),2)
	frame=' frames :'+strtrim((string(x)),2)
	widget_control,uv(4),set_value=total
	widget_control,uv(5),set_value=frame
	xdisplayfile,file+'.tmp',group=ev.top,height=10,width=50
	endif else begin
	openw,u,'kin.tmp',/get_lun
	printf,u,'      NB       TICKS      SECONDS          SUM  '
	for i=0,x-1 do begin
	printf,u,i+1,t(i),sec(i),sum(i)
	endfor
	close,u
	free_lun,u
	total='total time :'+strtrim((sum(x-1)),2)
	frame=' frames :'+strtrim((string(x)),2)
	widget_control,uv(4),set_value=total
	widget_control,uv(5),set_value=frame
	xdisplayfile,'kin.tmp',group=ev.top,height=10,width=50
	endelse
	endif else widget_control,uv(3),set_value='too many frames'
endif
endif
  end

;*****SAVE*****
3:begin	widget_control,uv(1),get_value=time
	widget_control,uv(2),get_value=file & file=file(0)

if not (file eq '') then begin
	tick=90.9e-9
	x=n_elements(time)
	if (time(x-1) eq 0) then x=x-1
if not (x eq 0) then begin
	t  =lonarr(x)
	if (x lt 450) then begin
		for i=0,x-1 do begin
		tic=time(i)/tick
		t(i)=tic
		endfor
	openw,u,file+'.tic',/get_lun
	for i=0,x-1 do begin
	printf,u,t(i)
	endfor
	close,u
	free_lun,u
	endif
	endif
	endif

  end

;*****EXIT*****
4:begin widget_control,ev.top,/destroy

  end

else:

endcase

end

pro d22kin_pers
;** ***********
;**

base   = widget_base  (title='D22 KIN Personal time acquisition',/column,frame=5)
title  = widget_label (base,value='Personal time definiton')

base0 = widget_base   (base ,/column,frame=5)

base1 = widget_base   (base0,/row)
time  = cw_field      (base1,title='Time preset (s) :',value='',xsize=5,ysize=3,uvalue=1)
do0   = widget_button (base1,value='Do',uvalue=2)

base2 = widget_base   (base0,/row)
label = widget_label  (base2,value='Saved in file :')
file  = widget_text   (base2,value='',/editable,xsize=10)
save  = widget_button (base2,value='Save',uvalue=3)

base4 = widget_base  (base,/row)
total = widget_label (base4,value='',/dynamic_resize)
frame = widget_label (base4,value='',/dynamic_resize)

base3 = widget_base   (base ,/row)
exit  = widget_button (base3,value='Exit',uvalue=4)
mesg  = widget_label  (base3,value='',/dynamic_resize)

widget_control,time ,set_uvalue=[1,mesg]
widget_control,do0  ,set_uvalue=[2,time,file,mesg,total,frame]
widget_control,save ,set_uvalue=[3,time,file,mesg]


widget_control,base,/realize
xmanager,'d22kin_pers',base,/just_reg
end
pro d22kin_read_event,ev
;** *****************
;**

widget_control,ev.id,get_uvalue=uv
case uv(0) of

;*****READ*****
1:begin widget_control,uv(1),get_value=file & file=file(0)
	if not (file eq '') then begin
	x=0
	tick=90.9e-9
	openr,u,file+'.tic',/get_lun,error=err
	if (err ne 0) then widget_control,uv(2),set_value=file+' : no such file' else begin
	widget_control,uv(2),set_value=''
	while not eof(u) do begin
	readf,u,a
	x=x+1
	endwhile
	close,u
	free_lun,u
	t=lonarr(x)
	sec=fltarr(x)
	sum=strarr(x)
	openr,u,file+'.tic',/get_lun
	for i=0,x-1 do begin
	readf,u,a
	t(i)=a
	b=t(i)*tick
	sec(i)=b
	endfor
	close,u
	free_lun,u
	sum(0)=sec(0)
	for i=1,x-1 do sum(i)=sum(i-1)+ sec(i)
	openw,u,file+'.tmp',/get_lun
	printf,u,'      NB       TICKS     SECONDS          SUM  '
	for i=0,x-1 do begin
	printf,u,i+1,t(i),sec(i),sum(i)
	endfor
	close,u
	free_lun,u
	total='total time :'+strtrim((sum(x-1)),2)
	frame=' frames :'+strtrim((string(x)),2)
	widget_control,uv(3),set_value=total
	widget_control,uv(4),set_value=frame
	xdisplayfile,file+'.tmp',group=ev.top,height=10,width=50
	endelse
	endif
  end

;*****EXIT*****
2:begin widget_control,ev.top,/destroy
  end

else:

endcase

end

pro d22kin_read
;** ***********
;**

base  = widget_base  (title='D22KIN Reading file',/column)
base1 = widget_base  (base,/row,frame=5)
label = widget_label (base1,value='Read KIN file :')
file  = widget_text  (base1,value='',/editable,xsize=10)
label = widget_label (base1,value='.tic')
read  = widget_button(base1,value='Read',uvalue=1)

base3 = widget_base  (base,/row)
total = widget_label (base3,value='',/dynamic_resize)
frame = widget_label (base3,value='',/dynamic_resize)

base2 = widget_base   (base ,/row)
exit  = widget_button (base2,value='Exit',uvalue=2)
mesg  = widget_label  (base2,value='',/dynamic_resize)

widget_control,read,set_uvalue=[1,file,mesg,total,frame]

widget_control,base,/realize

xmanager,'d22kin_read',base,/just_reg

end
FUNCTION d2q,w
 ; 2qtrue = 2qexp.-ZER

take_datp,datp
d=datp.x(*,0)
e=datp.e
range=where(d gt 0)
d=d(range)
wout=w(range,*)
IF N_ELEMENTS(E) EQ N_ELEMENTS(W) THEN e=e(range,*)
if n_elements(wl) eq 0 then if n_elements(datp.p) gt 9 then if datp.p(9) NE 0.0 THEN wl =datp.p(9) 
if n_elements(wl) eq 1 THEN BEGIN
  q=2*!pi/d
  idx=sort(q)
  mod_datp,datp,'x',q(idx)
  IF N_ELEMENTS(E) EQ N_ELEMENTS(wout) THEN BEGIN
    mod_datp, datp, 'E', e(idx,*)
  ENDIF ELSE mod_datp, datp, 'E',0
  mod_datp,datp,'x_tit','Q/Ang^-1'
  wout=wout(idx,*)
  give_datp,datp
  return,wout
ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
ENDELSE
END
FUNCTION d2tt,w,lambda=wl,zeroshift=z
; tt(true) = tt(obs)-ZER (FullProf)

take_datp,datp
d=datp.x(*,0)
e=datp.e
range=where(d gt 0)
d=d(range)
wout=w(range,*)
IF N_ELEMENTS(E) EQ N_ELEMENTS(W) THEN e=e(range,*)
IF NOT KEYWORD_SET(z) THEN z=0.0
IF NOT KEYWORD_SET(wl)THEN BEGIN
  IF n_elements(datp.p) gt 9 THEN BEGIN
    IF datp.p(9) NE 0.0 THEN wl =datp.p(9)
  ENDIF
ENDIF
if KEYWORD_SET(wl) THEN BEGIN
  tt=asin(wl/2./d)*360./!pi
  idx=sort(tt)
  mod_datp,datp,'x',tt(idx)+z
  IF N_ELEMENTS(E) EQ N_ELEMENTS(wout) THEN BEGIN
    mod_datp, datp, 'E', e(idx,*)
  ENDIF ELSE mod_datp, datp, 'E',0
  mod_datp,datp,'x_tit','2theta/deg'
  wout=wout(idx,*)
  give_datp,datp
  return,wout
ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
ENDELSE
END
	PRO d7_runsummary

COMMON mon,	date, mon1rate, dmon1rate, time1, time2

COMMON mut,	user, local_contact, main_title, sub_title, $
		start_time, run_time, pol_mode, Time_mode, scan_type, $
		nkmes, npmes

	inpath='/usr/illdata/data/d7/'
	outpath=''

	OPENR, 1, outpath+'ls.out'
	numor0=1L	& numor=0L
	ON_IOERROR, endoffile
	WHILE (numor0 GT 0) DO BEGIN
		READF, 1, FORMAT='(I6)', numor
		IF (numor GT 100 AND numor0 LT 100) THEN numor1=numor
		numor0=numor
	ENDWHILE
endoffile:
	numor2=numor0
	CLOSE, 1
		
	numor1=numor2-((numor2-numor1)<500)

	scan=0	& samerun=0
	olduser=''	& old_title=''	& oldtime1=-10.	& old_run_time=0
	old_pol_mode=''	& old_time_mode=''	& old_sub_title=''
	force=0

	OPENW, 7, outpath+'d7_runsummary.htm'
	PRINTF, 7, '<HTML>'
	PRINTF, 7, '<HEAD>'
	PRINTF, 7, '<TITLE>D7 Run Summary</TITLE>'
	PRINTF, 7, '</HEAD>'
	PRINTF, 7, '<PRE>'

	FOR numor=numor1, numor2 DO BEGIN
		IF (numor GE 10000) THEN file='0'+STRTRIM(STRING(numor),2) $
			ELSE file='00'+STRTRIM(STRING(numor),2)
		file=inpath+file
		read_d7sum, file
		run_time=LONG(run_time/60.)	; get it in minutes
		IF (scan EQ 1 AND ((scan_type NE '         ' AND npmes EQ 1) OR $
			(scan_type EQ '         '))) THEN BEGIN
			IF (numor-oldnumor GE 2) THEN PRINTF, 7, $
				FORMAT='("     ... ",A," scan up to #",I5)', STRTRIM(oldscan_type,2), numor-1
			scan=0
			samerun=0
		ENDIF ELSE IF (scan_type EQ '         ') THEN BEGIN
			IF (run_time EQ old_run_time AND pol_mode EQ old_pol_mode AND $
				time_mode EQ old_time_mode AND sub_title EQ old_sub_title AND $
				user EQ olduser AND main_title EQ old_title) THEN BEGIN
				samerun=1
			ENDIF ELSE IF (samerun EQ 1) THEN BEGIN
				IF (numor-oldnumor GE 2) THEN PRINTF, 7, $
					FORMAT='("     ... identical runs up to #",I5)', numor-1
				samerun=0
			ENDIF
		ENDIF
		IF (numor EQ numor1) THEN BEGIN
			PRINTF, 7
			PRINTF, 7,'****************************************************************'
			PRINTF, 7, FORMAT='("Numors",I6," to",I6)', numor1, numor2
			PRINTF, 7, 'Path: ',inpath
			PRINTF, 7,'----------------------------------------------------------------'
			PRINTF, 7
			PRINTF, 7, FORMAT='("User: ",A8,"   Local Contact: ",A8)', user, local_contact
			PRINTF, 7, FORMAT='("Experiment Title: ",A)', main_title
			PRINTF, 7
			PRINTF, 7, 'Numor  Start Time      Minutes Pol TOF   Title'
		ENDIF ELSE IF (user NE olduser) OR (main_title NE old_title) THEN BEGIN
			PRINTF, 7,'----------------------------------------------------------------'
			PRINTF, 7
			PRINTF, 7, FORMAT='("User: ",A8,"   Local Contact: ",A8)', user, local_contact
			PRINTF, 7, FORMAT='("Experiment Title: ",A)', main_title
			PRINTF, 7
			PRINTF, 7, 'Numor  Start Time      Minutes Pol TOF   Title'
		ENDIF
		IF (scan EQ 0 AND samerun EQ 0) THEN BEGIN
			PRINTF, 7, FORMAT='(I5,1X,A18,I5,A5,A6,1X,A)', $
				numor, start_time, run_time, pol_mode, Time_mode, sub_title
			oldnumor=numor
			oldscan_type=scan_type
		ENDIF ELSE IF (numor EQ numor2) THEN BEGIN
			IF (scan_type NE '         ' AND npmes NE 1) THEN $
				PRINTF, 7, FORMAT='("     ... ",A," scan up to #",I5)', $
					STRTRIM(scan_type,2), numor
			IF (scan_type EQ '         ' AND $
				run_time EQ old_run_time AND pol_mode EQ old_pol_mode AND $
				time_mode EQ old_time_mode AND sub_title EQ old_sub_title AND $
				user EQ olduser AND main_title EQ old_title) THEN PRINTF, 7, $
				FORMAT='("     ... identical runs up to #",I5)', numor
		ENDIF
		IF (scan_type NE '         ') THEN scan=1
		olduser=user
		old_title=main_title
		old_run_time=run_time
		old_pol_mode=pol_mode
		old_time_mode=time_mode
		old_sub_title=sub_title
	ENDFOR

	PRINTF, 7, '</PRE>'
	PRINTF, 7, '</BODY>'
	PRINTF, 7, '</HTML>'
	CLOSE, 7

	RETURN
	END
	PRO d7_tlog, numor1, numor2
;
; interrogates MAD.LOG and MAD.LOG-1 for temperatures.   Plots all temperatures
; for files MAD.LOG and MAD.LOG-1, (default) or plots temperature of desired
; numor range.
;					
;							JRS   20/3/00
;
;------------------------------------------------------------------------------


	IF(N_ELEMENTS(numor2) GT 0) THEN numors=[numor1,numor2] ELSE $
	IF(N_ELEMENTS(numor1) GT 0) THEN numors=[numor1,numor1]
	
	inpath='/usr/illdata/data/d7/'

	outpath=''

	mp=10000
	line=''	& time=FLTARR(mp)	& Treg=time	& Tsam=time
	numor=LONARR(mp/10)	& start=FLTARR(mp/10)	& stop=start
	np=INTARR(mp/10) 	& startr=FLTARR(mp/10)	& numorr=numor
	numor(*)=0.	& start(*)=-24.	& stop(*)=24.
	startr(*)=-24. 	& numorr(*)=0.

	PRINT,'Starting d7_tlog'
	nt=-1
	nr=0
	nrr=0
	fn=0
	inp=0
	today=0
	numorflg=0
	npflag=0
	infile='MAD.LOG-1'
	line0=line
	firstnumor=0 & lastnumor=0
;
;-------------------------------------------------------------------------------
;
readdata:
	OPENR, 1, inpath+infile
	WHILE (NOT EOF(1)) DO BEGIN
		READF, 1, line
		col1=STRMID(line,3,1)	& col2=STRMID(line,6,1)	& pol=STRMID(line,9,4)
		sp=STRMID(line,13,1)
		IF (col1 EQ ':' AND col2 EQ ':' AND sp NE ' ') THEN BEGIN
;			PRINT,'colons found. line=',line
			nt=nt+1
			h=FLOAT(STRMID(line,1,2))	& m=FLOAT(STRMID(line,4,2))	& s=FLOAT(STRMID(line,7,2))
			IF (today EQ 0) THEN BEGIN
				time(nt)=h+m/60.+s/60^2-24.
			ENDIF ELSE BEGIN
				time(nt)=h+m/60.+s/60^2
			ENDELSE
			Treg(nt)=FLOAT(STRMID(line,64,7))	& Tsam(nt)=FLOAT(STRMID(line,73,6))
		ENDIF ELSE IF (STRMID(line,1,6) EQ 'Ntimes') THEN BEGIN
			np(inp)=FIX(STRMID(line,8,3))
			print, inp,np(inp)
			npflag=1
		ENDIF ELSE IF (pol EQ 'POL.' AND npflag EQ 1) THEN BEGIN
;			PRINT,'POL. found. line=',line
			h=FLOAT(STRMID(line0,0,2))	& m=FLOAT(STRMID(line0,3,2))
			IF (today EQ 0) THEN BEGIN
				start(nr)=h+m/60.-24.
				startr(nrr)=h+m/60.-24.
			ENDIF ELSE BEGIN
				start(nr)=h+m/60.
				startr(nrr)=h+m/60.
			ENDELSE
			numorflg=1
		ENDIF ELSE IF(numorflg EQ 1 AND STRMID(line,7,5) EQ 'NUMOR') THEN BEGIN
;			PRINT,'NUMOR found. line=',line
			numor(nr)=LONG(STRMID(line,12,7))
			numorr(nrr)=numor(nr)
			nrr=nrr+1
			IF (fn EQ 0) THEN firstnumor=numor(nr)
			fn=1
			numorflg=0
			npflag=0
		ENDIF ELSE IF (STRMID(line,1,5) EQ 'duree' AND nt NE -1 AND np(inp) EQ 1) THEN BEGIN
;			PRINT,'duree found. line=',line
			inp=inp+1
			nr=nr+1
			stop(nr)=time(nt)
		ENDIF
		line0=line
	ENDWHILE
	lastnumor=numor(nr)

	CLOSE, 1
		PRINT, 'After reading ',infile,': nr=',nr,' nt=',nt
	IF (infile EQ 'MAD.LOG-1') THEN BEGIN
		print, 'MAD.LOG'
		infile='MAD.LOG'
		today=1
		GOTO, readdata
	ENDIF
;
;-------------------------------------------------------------------------------
;
	IF (nr EQ -1 OR nt EQ -1) THEN BEGIN
		OPENW, 1, outpath+'d7_tlog.txt'
		PRINTF, 1, 'No temperature data in logfiles'
		CLOSE, 1
		GOTO, finished
	ENDIF

	stop(nr)=time(nt)
	
	start=start(0:nr)	& stop=stop(0:nr)	& numor=numor(0:nr)
	time=time(0:nt)		& Treg=Treg(0:nt)	& Tsam=Tsam(0:nt)
	startr=startr(0:nrr)

	xmax=time(nt-1)+1.	& xmin=-24.
	ymax=MAX([Treg,Tsam])+10.
	ymin=MIN([Treg,Tsam])-10.
	IF (N_ELEMENTS(numors) GT 0) THEN BEGIN
		IF(N_ELEMENTS(numors) EQ 1) THEN numors=[numors,numors]
		i=WHERE(numorr EQ numors(0))
		j=WHERE(numorr EQ numors(1))
		xmin=startr(i(0))
		xmax=startr(j(0)+1)
		numor=numorr
		start=startr
		stop=start
		firstnumor=numors(0)
		lastnumor=numors(1)
		FOR i=0,nrr-1 DO stop(i)=start(i+1)
		nr=nrr
	ENDIF


;	DEVICE,PSEUDO=8
;	WINDOW,1,XSIZE=1024,YSIZE=512,/PIXMAP,RETAIN=2 ; obsolate (barns)
;	WINDOW,1,XSIZE=1024,YSIZE=512,RETAIN=2
;	WSET,1
	SET_PLOT,'Z'  &  DEVICE,set_resolution=[1024,512]
	LOADCT, 5
	PLOT, [0,0], [0,0], XRANGE=[xmin,xmax], XTITLE='Time (hours) -0 hours is midnight', YTITLE='Sample Temperature (K)', $
		XSTYLE=1, YRANGE=[ymin,ymax], YSTYLE=1, COLOR=0,BACKGROUND=255,TITLE='Temperature Log for '+STRTRIM(STRING(firstnumor),2)+':'+STRTRIM(STRING(lastnumor),2)
	FOR i=0,nr-1 DO BEGIN
		s=FLTARR(2,4)
		s0=start(i)	& s1=stop(i)
;		IF (s1 GT xmin(0)) THEN BEGIN
			s0=MAX([xmin(0),s0])  
			s(0,0)=s0 & s(0,1)=s1 & s(0,2)=s1   & s(0,3)=s0
			s(1,0)=0. & s(1,1)=0. & s(1,2)=ymax & s(1,3)=ymax
;			POLYFILL, s, COLOR=50
			IF (s0 GT xmin AND s0 LT xmax) THEN OPLOT, [s0,s0], [0,ymax], COLOR=40
;		ENDIF
	ENDFOR
	nmax=25
	dy=(ymax-ymin-5.)/FLOAT(nmax)
	FOR i=0,nr-1 DO BEGIN
		yval=dy*FLOAT(i+1-nmax*(i/nmax))+ymin
		IF(firstnumor NE numor(0) AND i EQ 0 AND N_ELEMENTS(numors) LT 1) THEN XYOUTS, xmin, yval, ' #'+STRTRIM(STRING(firstnumor),2),COLOR=50
		IF (start(i) GE xmin AND start(i) LT xmax ) THEN XYOUTS, start(i), yval, ' #'+STRTRIM(STRING(numor(i)),2),COLOR=50
	ENDFOR
	OPLOT, time, Tsam, PSYM=5, SYMSIZE=0.5,COLOR=20
	AXIS, 0, 0, XSTYLE=1, YSTYLE=1

	WRITE_GIF, outpath+'d7_tlog.gif', TVRD()

finished:
	RETURN
	END
pro data_blead,num,w1,w2,y,m,q,th,san,dan,dett,nx,time
close,3

par1 = fltarr(128)
par2 = fltarr(256)
txt=sindgen(34)
txt(*)='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
txt1=txt(1)
path='/users/data/'

if strlen(string(strtrim(num,2))) eq 1 then name=path+'00000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 2 then name=path+'0000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 3 then name=path+'000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 4 then name=path+'00'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 5 then name=path+'0'+string(strtrim(num,2))

print,' '
print,' '
print,'opening... ',name
openr,3,name
print,'opened: ',name
readf,3,txt
print,txt(4)
print,txt(25)
readf,3,par1
readf,3,txt1
readf,3,txt1
readf,3,par2

;  

dpr=180./!pi
print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
nx=par1(101)


print,'nx= ',par1(101),' ny= ',par1(102)
print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)

; useful chopper variables
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))
period=60./par2(44)

opena=opena-1.02

dela=(283.754-opena)/2.
delt=(dela/360.)*period
chopsam=3.9475-(85.0e-3)/2
chopmon=.455
tofd=chopsam+(par2(15)/1000.)
chanpa=(tofd/3956.)/(par1(95)*1e-6)
chanpam=(chopmon/3956.)/(par1(95)*1e-6)
r=chopsam/tofd
delchan=delt/(par1(95)*1e-6)
delechan=par1(96)/par1(95)
print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
;print,'     san= ',par2(2),' deg.'
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa

time=par1(2)/10.
print,'run time= ',time,' s',' det= ',par2(15),'dan = ',par2(16)
dan=par2(16)
san=par2(2)
dett=par2(15)
print,par1(90:100)
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
readf,3,txt1
readf,3,txt1
readf,3,txt1
readf,3,tot
print,tot


; define the data array
;tsize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'
print,'tsize= ',tsize,' detector size= ',dsize
print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

det=lonarr(ysize,xsize,tsize)
if (ysize eq 1) then begin
  det=lonarr(xsize,tsize)
  
endif
if (tsize eq 1) then begin
 det=lonarr(ysize,xsize)
endif


c=1

;  read detector and monitor data
;readf,3,det,mon

;bum monitor option
readf,3,det
print,'setting this value to zero',det(ysize-1,xsize-1)
det(ysize-1,xsize-1)=0

;print,'mon= ',mon

;make lambda array (y)

 yy=indgen(tsize)
 y=(yy+delechan-delchan+0.5)/chanpa
 m=(yy+delechan-delchan+0.5)/chanpam

if tsize gt 1 then begin
  w1=det
endif else begin
  w1=transpose(det)
endelse

w2=par1(4)


dpr=180./!pi
p0=135.79/nx

mmpp=1.0357*nx
th=fltarr(xsize)

; calculate th array
for i=0,xsize-1 do th(i)=dan+dpr*atan(((p0-i)*mmpp)/dett)



; and Q
q=4*!pi*sin(par2(2)/dpr)/y

close,3
print,'total counts in detector = ',total(w1),' (',total(w1)/time,')'
;print,'total counts in monitor = ',total(w2),' (',total(w2)/time,')'
return

end
pro data_read,num,w1,w2,y,m,q,th,san,dan,dett,nx,time
close,3

; w1=data array  w2=total monitor  y=lambda array for detector
; m=lambda array for monitor (not anymore) q=q th=th per pixel



par1 = fltarr(128)
par2 = fltarr(256)
txt=sindgen(34)
txt(*)='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
txt1=txt(1)
path='/users/data/'
;name=path+'00'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 1 then name=path+'00000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 2 then name=path+'0000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 3 then name=path+'000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 4 then name=path+'00'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 5 then name=path+'0'+string(strtrim(num,2))

print,' '
print,' '
print,'opening... ',name
openr,3,name
print,'opened: ',name
readf,3,txt
print,txt(4)
print,txt(25)
readf,3,par1
readf,3,txt1
readf,3,txt1
readf,3,par2

;  

dpr=180./!pi
print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
nx=par1(101)


print,'nx= ',par1(101),' ny= ',par1(102)
print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)

; useful chopper variables
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))
period=60./par2(44)

opena=opena-1.02

dela=(283.754-opena)/2.
delt=(dela/360.)*period
;chopsam=4.0115-(85.0e-3)/2
chopsam=3.9475-(85.0e-3)/2
chopmon=.455
tofd=chopsam+(par2(15)/1000.)
chanpa=(tofd/3956.)/(par1(95)*1e-6)
chanpam=(chopmon/3956.)/(par1(95)*1e-6)
r=chopsam/tofd
delchan=delt/(par1(95)*1e-6)
delechan=par1(96)/par1(95)
print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
;print,'     san= ',par2(2),' deg.'
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa

time=par1(2)/10.
print,'run time= ',time,' s',' det= ',par2(15),'dan = ',par2(16)
dan=par2(16)
san=par2(2)
dett=par2(15)
print,par1(90:100)
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
readf,3,txt1
readf,3,txt1
readf,3,txt1
readf,3,tot
print,tot


; define the data array
;tsize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'
print,'tsize= ',tsize,' detector size= ',dsize
print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

det=lonarr(ysize,xsize,tsize)
if (ysize eq 1) then begin
  det=lonarr(xsize,tsize)
  
endif
if (tsize eq 1) then begin
 det=lonarr(ysize,xsize)
endif


c=1

;  read detector and monitor data
readf,3,det

;print,'mon= ',mon

;make lambda array (y)

 yy=indgen(tsize)
 y=(yy+delechan-delchan+0.5)/chanpa
 m=(yy+delechan-delchan+0.5)/chanpam

if tsize gt 1 then begin
  w1=det
endif else begin
  w1=transpose(det)
endelse


; monitor is now written into the parameter block.
w2=par1(4)


dpr=180./!pi
p0=135.79/nx

mmpp=1.0357*nx
th=fltarr(xsize)

; calculate th array
for i=0,xsize-1 do th(i)=dan+dpr*atan(((p0-i)*mmpp)/dett)



; and Q
q=4*!pi*sin(par2(2)/dpr)/y

close,3
print,'total counts in detector = ',total(w1),' (',total(w1)/time,')'
;print,'total counts in monitor = ',total(w2),' (',total(w2)/time,')'
return

end
pro data_readq,num,nn,d0,p0,dr,pr,neww1,qx,qz,res
close,3

par1 = fltarr(128)
par2 = fltarr(256)
txt=sindgen(34)
txt(*)='RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR'
txt1=txt(1)
path='/users/data/'
name=path+'00'+string(strtrim(num,2))

print,' '
print,' '
print,'opening... ',name
openr,3,name
print,'opened: ',name
readf,3,txt
print,txt(4)
print,txt(25)
readf,3,par1
readf,3,txt1
readf,3,txt1
print,txt1
readf,3,par2

print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
print,'nx= ',par1(101),' ny= ',par1(102)
print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)

; useful chopper variables
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))
period=60./par2(44)
dela=(285.-opena)/2.
delt=(dela/360.)*period
chopsam=4
tofd=chopsam+(par2(15)/1000.)
chanpa=(tofd/3956.)/(par1(95)*1e-6)
chanpam=(chopsam/3956.)/(par1(95)*1e-6)
delchan=delt/(par1(95)*1e-6)
delechan=par1(96)/par1(95)
print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
print,'     san= ',par2(2),' deg.','     dan= ',par2(16),' deg.'
san=par2(2)
dan=par2(16)
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa
time=par1(2)/10.
print,'run time= ',time,' s',' det= ',par2(15)
det=par2(15)
print,det
readf,3,txt1
readf,3,txt1
readf,3,txt1



readf,3,tot
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'
print,'tsize= ',tsize,' detector size= ',dsize
print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

w1=lonarr(ysize,xsize,tsize)
if (ysize eq 1) then begin
  w1=lonarr(xsize,tsize)
endif

mon=lonarr(tsize)
xy=lonarr(xsize,ysize)
xt=lonarr(xsize,tsize)
yt=lonarr(ysize,tsize)


c=1
readf,3,w1,mon
help,w1
if (ysize gt 1) then begin
  w1=total(w1,1)
endif

;print,'mon= ',mon

;make lambda array
yy=indgen(tsize)
;larr=(yy+delechan-delchan)/chanpa
larr=(yy)/chanpa
m=(yy+delechan-delchan)/chanpam



lfirst=(delchan-delechan)
print,'channel shift = ',lfirst

; loose nn channels at the beginning to avoid infinities in reciprocal space
help,w1
;nn=5
aa=shift(w1,1,-round(lfirst))

neww1=aa(*,nn:tsize-1)
newlarr=larr(nn:tsize-1)

q=fltarr(xsize,tsize-nn)
th=fltarr(xsize,tsize-nn)
qx=fltarr(xsize,tsize-nn)
qz=fltarr(xsize,tsize-nn)

 
w2=mon


close,3
print,'total counts in detector = ',total(w1),' (',total(w1)/time,')'


print,'total counts in monitor = ',total(w2),' (',total(w2)/time,')'

;  conversion to reciprocal space

dpr=180./!pi
pmin=25.
pmax=253.
pcen=132.73
;mmpp=250./(pmax-pmin)
mmpp=1.04
print,'pcen= ',pcen,' mmpp= ',mmpp
print,'ref th= ',(dr+dpr*atan((pcen-pr)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
lmax=max(newlarr)
lmin=min(newlarr)

;expt information d0=dan for diect beam p0=pixel for direct beam
;dr=dan for reflection pr=pixel for reflection



;find limits in reciprocal space

for i=pmin,pmax do begin
  for j=0,tsize-nn-1 do begin
  
   l=newlarr(j)
   th(i,j)=(dr+dpr*atan((pcen-i)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
   q(i,j)=4*!pi*sin(th(i,j)/dpr)/newlarr(j)
   qx(i,j)=q(i,j)*sin((th(i,j)-san)/dpr)
   qz(i,j)=q(i,j)*cos((th(i,j)-san)/dpr)
   ; print,'i= ',i,' j= ',j,' q= ',q(i,j),' th= ',th(i,j),' lam= ',newlarr(j)
   ; print,'qx= ',qx(i,j),' qz= ',qz(i,j)
   
   endfor
 endfor

   
  
   print,'by array sums....'
   print,'thmax= ',max(th),'thmin= ',min(th),'qmin= ',min(q),'qmax= ',max(q)
   print,'qxmax= ',max(qx),'qxmin= ',min(qx),'qzmax= ',max(qz),'qzmin= ',min(qz)


  
triangulate,qx,qz,triangles
res=trigrid(qx,qz,neww1,triangles)
 

return

end
; Written by J.R.D. Copley.  Last revision 08/01/01.
;************************************************************************************************
pro dcs_binary2ascii
;************************************************************************************************
; This procedure converts DCS data files from Octave binary to Octave ascii.
; The input and output files may be compressed or uncompressed.
; The user chooses which variables to place in the output files.
; Instead, or in addition, the procedure creates a summary file (in ascii),
; listing the values of selected variables for each of several runs.
;
compile_opt strictarr
;
; Define raw data structure and pointer.
dcs_rawdata_ptr,datafile_ptr=datafile_ptr
;
; Get tag names of structure.
;tagnames=strlowcase(tag_names(*datafile_ptr))
;ntags=n_tags(*datafile_ptr)
;
; Find out which variables are to be written to the output file(s),
; whether to create ascii output files and/or a summary file, and
; what delimiter to use for the summary file.
dcs_rawdata_variables_choose,tagnames,ntags,choice,action,delim
dummy=where(choice eq 1,count)
if (count eq 0) then begin
	result=dialog_message(["No variables chosen.","Exiting ..."])
	ptr_free,datafile_ptr
	return
endif
;
nofirstline=0
omithisto=0
printinfo=0
;
files=dialog_pickfile(path="f:\data",filter=["*.dcs","*.dcs.gz"],/multiple_files,$
	title="Select one or more raw data files")
files=files[sort(files)]
fileinfo=size(files)
nfiles=fileinfo[1]
if (files[0] eq "") then begin
	result=dialog_message(["No files selected.","Exiting ..."])
	return
endif
;
; Decide whether output files are to be compressed or not.
if (action.make) then begin
	result=dialog_message("Do you want compressed (gzip'd) output files ?",/question,/default_no)
	out_compressed=(result eq "Yes")
	if (out_compressed) then out_exten=".asc.gz" else out_exten=".asc"
endif
;
if (action.summ) then begin
	repeat begin
		summary_file=dialog_pickfile(path="f:\data",$
			filter="*.txt",title="Select name of summary file")
	endrep until (summary_file ne "" and strpos(summary_file,"\00_") eq -1)
	print,"Writing summary information to ",summary_file
	dcs_write_summary_ptr,summary_file,datafile_ptr=datafile_ptr,choice=choice,0,delim,""
endif
;
for i=0,nfiles-1 do begin
	file_path=files[i]
	compressed=(strmid(file_path,2,3,/reverse_offset) eq ".gz")
	if (compressed) then rootlength=strlen(file_path)-7 else rootlength=strlen(file_path)-4
	file_root=strmid(file_path,0,rootlength)
;
	dcs_read_binaryOctavefile_ptr,file_path,nofirstline,omithisto,variables_read,unknowns,error,$
		datafile_ptr=datafile_ptr
	print,"Binary file ",file_path," has been read."
;
	if (strlen(error) gt 0) then begin
		result=dialog_message(["Error reading binary file.","Exiting ..."])
		return
	endif
;
	if (action.make) then begin
		file_path=file_root+out_exten
		dcs_write_asciiOctavefile_ptr,file_path,datafile_ptr=datafile_ptr,$
			compress=out_compressed,choice=choice
		print,"Ascii file ",file_path," has been written."
	endif
;
	if (action.summ) then begin
		lgth=strlen(file_path)
		pos=strpos(file_path,'\',/reverse_search)+1
		short_form=strmid(file_path,pos,11)
		dcs_write_summary_ptr,summary_file,datafile_ptr=datafile_ptr,choice=choice,1,delim,$
			short_form
	endif
;
endfor
;
ptr_free,datafile_ptr
result=dialog_message(["Success!"],/information);
end; Written by J.R.D. Copley.  Last revision 07/29/01.
;************************************************************************************************
pro dcs_rawdata_ptr,datafile_ptr=datafile_ptr
;************************************************************************************************
;
compile_opt strictarr
;
datafile_ptr=ptr_new({rawdata,$
	badbrd:-1.0d,$
	baddet:-1.0d,$
	ch_bid:fltarr(7)+1.e4,$
	ch_delay:fltarr(7)-1.0d,$
	ch_dis:fltarr(7)+1.e4,$
	ch_input:fltarr(6)-1.0d,$
	ch_ms:-1.0d,$
	ch_phase:fltarr(7)-1.0d,$
	ch_res:-1,$
	ch_slots:fltarr(7,3)-1.0d,$
	ch_srdenom:-1,$
	ch_srmode:-1,$
	ch_wl:-1.0d,$
	coll_amp:-1.0d,$
	coll_mean:-1.0d,$
	coll_osc:-1,$
	command:"xxx",$
	comments:"xxx",$
	datamax:-1.0d,$
	det_dis:+1.d4,$;
	detsum:ulonarr(931)-1,$
	duration:-1.0d,$
	fc_dis:fltarr(3)+1.e4,$
	grandsum:ulonarr(8)-1,$
	highmax:-1.0d,$
	highsource:strarr(17)+"xxx",$
	histodata:ulonarr(1024,913)-1,$
	histohigh:ulonarr(1024,18)-1,$
	motor_pos:fltarr(8)+1.e4,$
	nframes:-1l,$
	repeats:ulonarr(2,32)-1,$
	resets:ulonarr(2,32)-1,$
	sample_desc:strarr(10)+"xxx",$
;	sample_geom:fltarr(10),$
;	sample_envi:fltarr(10),$
	start_date:"xxx",$
	startchoice:"xxx",$
	stop_date:"xxx",$
	tchanlook:ulonarr(2,1024)-1,$
	temp_control:fltarr(500)-1.0,$
	temp_sample:fltarr(500)-1.0,$
	temp_setpoint:-1.0d,$
	timsum:ulonarr(1024)-1,$
	totals:ulonarr(2,32)-1,$
	tsdmin:-1.0d},/no_copy)
;
end; Written by J.R.D. Copley.  Last revision 08/01/01.
;************************************************************************************************
pro dcs_rawdata_variables_choose_handler,event
;************************************************************************************************
;
;
compile_opt strictarr
;
widget_control,event.top,get_uvalue=pstate
;
case event.id of
	(*pstate).none: begin
		for i=0,(*pstate).ntags-1 do widget_control,(*pstate).butid[i],set_button=0
		(*(*pstate).pbut)=intarr((*pstate).ntags)
	end
	(*pstate).all: begin
		for i=0,(*pstate).ntags-1 do widget_control,(*pstate).butid[i],set_button=1
		(*(*pstate).pbut)=intarr((*pstate).ntags)+1
	end
	(*pstate).save: begin
		z=(*(*pstate).pbut)
		filename=dialog_pickfile(path="C:\rsi\dave\dcs\text files",$
			filter="*.txt",title="Select name of save file",$
			file="ascii_variables.txt")
		if (file_test(filename) and filename ne "") then begin
			save,filename=filename,z
			result=dialog_message("Variable names saved to file "+filename,/information)
		endif	else print,"Invalid save file name."
	end
	(*pstate).recall: begin
		filename=dialog_pickfile(path="C:\rsi\dave\dcs\text files",$
			filter="*.txt",title="Select name of restore file",$
			file="ascii_variables.txt")
		print,filename
		if (file_test(filename) and filename ne "") then begin
			restore,filename=filename
			for i=0,(*pstate).ntags-1 do widget_control,(*pstate).butid[i],set_button=z[i]
				(*(*pstate).pbut)=z
			print,"Variable names restored from file ",filename
		endif else print,"Invalid restore file name."
	end
	(*pstate).done: begin
		widget_control,event.top,/destroy
		return
	end
	(*pstate).cancel: begin
		(*(*pstate).pbut)=intarr((*pstate).ntags)
		widget_control,event.top,/destroy
		return
	end
	(*pstate).make: begin
		(*(*pstate).pact).make=event.select
		widget_control,(*pstate).done,sensitive=(*(*pstate).pact).make or (*(*pstate).pact).summ
	end
	(*pstate).summ: begin
		(*(*pstate).pact).summ=event.select
		widget_control,(*pstate).bottom,sensitive=event.select
		widget_control,(*pstate).other,sensitive=event.select and (*pstate).obut
		widget_control,(*pstate).done,sensitive=(*(*pstate).pact).make or (*(*pstate).pact).summ
	end
	(*pstate).tab: *(*pstate).pdelim=string(format='(%"\t",a0)',"")
	(*pstate).com: *(*pstate).pdelim=","
	(*pstate).sem: *(*pstate).pdelim=";"
	(*pstate).spa: *(*pstate).pdelim=" "
	(*pstate).oth: begin
		(*pstate).obut=event.select
		widget_control,(*pstate).other,sensitive=(*pstate).obut
		widget_control,(*pstate).other,get_value=charact
		*(*pstate).pdelim=charact
	end
	(*pstate).other: begin
		widget_control,(*pstate).other,get_value=charact
		*(*pstate).pdelim=charact
	end
	else: begin
		k=where(event.id eq (*pstate).butid)
		(*(*pstate).pbut)[k]=event.select
	end
endcase
;
widget_control,event.top,get_uvalue=pstate
end


;************************************************************************************************
pro dcs_rawdata_variables_choose,tagnames,ntags,choice,action,delim
;************************************************************************************************
;
compile_opt strictarr
;
tlb=widget_base(/col,title='Click on variables to be written to output file.')
	upper=widget_base(tlb,/row,/frame)
		none=widget_button(upper,value="NONE")
		all=widget_button(upper,value="ALL")
		save=widget_button(upper,value="SAVE")
		recall=widget_button(upper,value="RECALL")
		done=widget_button(upper,value="DONE",sensitive=0)
		cancel=widget_button(upper,value="CANCEL")
	middle=widget_base(tlb,/row,/frame)
		ncols=5
		bbase=intarr(ncols)
		butid=intarr(ntags)
		for i=0,ncols-1 do bbase[i]=widget_base(middle,/col,/nonexclusive)
		ndisp=-1
		col=0
		for j=0,ntags-1 do begin
		  ndisp=ndisp+1
			if (ndisp ge 10) then begin
				ndisp=0
				col=col+1
			endif
		  butid[j]=widget_button(bbase[col],value=tagnames[j])
		endfor
	lower=widget_base(tlb,/row,/nonexclusive,/frame)
		make=widget_button(lower,value="MAKE INDIVIDUAL FILES")
		summ=widget_button(lower,value="MAKE SUMMARY FILE")
	bottom=widget_base(tlb,/col,/frame,sensitive=0)
		void=widget_label(bottom,$
			value="Select a field delimiter for the summary file.")
		bottom2=widget_base(bottom,/row)
			delims=widget_base(bottom2,/row,/exclusive)
				tab=widget_button(delims,value="Tab")
				com=widget_button(delims,value="Comma")
				sem=widget_button(delims,value="Semicolon")
				spa=widget_button(delims,value="Space")
				oth=widget_button(delims,value="Other-->")
			other=widget_text(bottom2,/editable,/all_events,xsize=2,ysize=1)
;
widget_control,tlb,/realize
widget_control,tab,/set_button
;
pbut=ptr_new(intarr(ntags))
pact=ptr_new({make:0,summ:0})
pdelim=ptr_new("")
state={none:none,all:all,done:done,save:save,recall:recall,cancel:cancel,$
	make:make,summ:summ,pact:pact,$
	bottom:bottom,tab:tab,com:com,sem:sem,spa:spa,oth:oth,other:other,pdelim:pdelim,$
	ntags:ntags,butid:butid,pbut:pbut,obut:0}
widget_control,tlb,set_uvalue=ptr_new(state),/no_copy
xmanager,'dcs_rawdata_variables_choose',tlb,event_handler='dcs_rawdata_variables_choose_handler'
choice=*pbut
ptr_free,pbut
action=*pact
ptr_free,pact
delim=*pdelim
ptr_free,pdelim
end


; Written by J.R.D. Copley.  Last revision 07/29/01.
;************************************************************************************************
pro dcs_read_binaryOctavefile_ptr_done_reading,unit,ivar,ivaru,variables_read,unknowns
;************************************************************************************************	;
;
compile_opt strictarr
;
if (ivar ge 0) then variables_read=variables_read[0:ivar] else variables_read=["None"]
if (ivaru ge 0) then unknowns=unknowns[0:ivaru] else begin
	unknowns=["None"]
endelse
;
free_lun,unit
return
end


;************************************************************************************************
pro dcs_read_binaryOctavefile_ptr,filepath,nofirstline,omithisto,variables_read,unknowns,error,$
	datafile_ptr=datafile_ptr
;************************************************************************************************
;
compile_opt strictarr
;
; This is a procedure that reads a binary Octave file.
; If omithisto=0, nothing is omitted, everything is read.
; If omithisto=1, histohigh is read but histodata is omitted.
; If omithisto=2, histohigh and histodata are both omitted.
;
on_ioerror, no_file
get_lun,unit
if (filepath eq "") then begin
	filepath="h:\octave\octave.bin"
	filepath="f:\data\20000318_01.dcs"
endif
;print,"Reading from ",filepath
;
; Determine whether or not file is compressed.
ending=strmid(filepath,2,3,/reverse_offset)
compressed=(ending eq ".gz")
;
; Read header to determine byte ordering ("endianness")
openr,unit,filepath,compress=compressed
header=bytarr(11)
readu,unit,header
close,unit
free_lun,unit
;
case string(header[9]) of
	"B": openr,unit,filepath,/swap_endian,compress=compressed
	"L": openr,unit,filepath,compress=compressed
	else: begin
		error="Cannot determine byte ordering of file named "+filepath
		return
	end
endcase
;
readu,unit,header
;print,"Header line: ",string(header)
;
; Define the types of some variables
nlgth=0l & dldocgf=bytarr(5) & dt=0b & padding=0b & scalar=0.0d
n1=0l & n2=0l & nstrgs=0l & nchars=0l
;
variables_read=strarr(100)
unknowns=strarr(100)
error=""
ivar=-1
ivaru=-1
;
while (not eof(unit)) do begin
	readu,unit,nlgth; read name_length
	name=bytarr(nlgth) & readu,unit,name & name=string(name); read name
	if ((omithisto eq 2 and name eq "histohigh") or $
		(omithisto eq 1 and name eq "histodata")) then begin
		dcs_read_binaryOctavefile_ptr_done_reading,unit,ivar,ivaru,variables_read,unknowns
		return
	endif
;	print,"Variable name: ",name
	readu,unit,dldocgf; read 5 bytes of doc_length, doc, and global flag
	readu,unit,dt; read data type
	case dt of
		1: begin; read scalar
			readu,unit,padding
			readu,unit,scalar
;			print,"Scalar read: ",scalar
				case name of
					"badbrd": (*datafile_ptr).badbrd=float(scalar)
					"baddet": (*datafile_ptr).baddet=float(scalar)
					"ch_ms": (*datafile_ptr).ch_ms=float(scalar)
					"ch_res": (*datafile_ptr).ch_res=fix(scalar)
					"ch_srdenom": (*datafile_ptr).ch_srdenom=fix(scalar)
					"ch_srmode": (*datafile_ptr).ch_srmode=fix(scalar)
					"ch_wl": (*datafile_ptr).ch_wl=float(scalar)
					"coll_amp": (*datafile_ptr).coll_amp=float(scalar)
					"coll_mean": (*datafile_ptr).coll_mean=float(scalar)
					"coll_osc": (*datafile_ptr).coll_osc=fix(scalar)
					"datamax": (*datafile_ptr).datamax=float(scalar)
					"det_dis": (*datafile_ptr).det_dis=float(scalar)
					"duration": (*datafile_ptr).duration=float(scalar)
					"highmax": (*datafile_ptr).highmax=float(scalar)
					"nframes": (*datafile_ptr).nframes=long(scalar)
					"temp_setpoint": (*datafile_ptr).temp_setpoint=float(scalar)
					"tsdmin": (*datafile_ptr).tsdmin=float(scalar)
					else: begin & ivaru=ivaru+1 & unknowns[ivaru]=name & end
				endcase
				ivar=ivar+1
				variables_read[ivar]=name
		end
		2: begin; read matrix
			readu,unit,n1,n2
			nhi=n1>n2
			nlo=n1<n2
			if (nlo eq 1) then data=dblarr(nhi) else data=dblarr(n1,n2)
			readu,unit,padding
			readu,unit,data
				case name of
					"ch_bid" : (*datafile_ptr).ch_bid=float(data)
					"ch_delay": (*datafile_ptr).ch_delay=float(data)
					"ch_dis": (*datafile_ptr).ch_dis=float(data)
					"ch_input": (*datafile_ptr).ch_input=float(data)
					"ch_phase": (*datafile_ptr).ch_phase=float(data)
					"ch_slots": (*datafile_ptr).ch_slots=float(data)
					"detsum": (*datafile_ptr).detsum=ulong(data)
					"fc_dis":  (*datafile_ptr).fc_dis=float(data)
					"grandsum": (*datafile_ptr).grandsum=ulong(data)
					"histodata": (*datafile_ptr).histodata=float(data)
					"histohigh": (*datafile_ptr).histohigh=float(data)
					"motor_pos": (*datafile_ptr).motor_pos=float(data)
					"repeats": (*datafile_ptr).repeats=ulong(data)
					"resets": (*datafile_ptr).resets=ulong(data)
	;				"sample_envi": (*datafile_ptr).sample_envi=float(data)
	;				"sample_geom": (*datafile_ptr).sample_geom=float(data)
					"tchanlook": (*datafile_ptr).tchanlook=ulong(data)
					"temp_control": begin
						(*datafile_ptr).temp_control=-1.0
						(*datafile_ptr).temp_control=float(data)
					end
					"temp_sample": begin
						(*datafile_ptr).temp_sample=-1.0
						(*datafile_ptr).temp_sample=float(data)
					end
					"timsum": (*datafile_ptr).timsum=ulong(data)
					"totals": (*datafile_ptr).totals=ulong(data)
					else: begin & ivaru=ivaru+1 & unknowns[ivaru]=name & end
				endcase
				ivar=ivar+1
				variables_read[ivar]=name
		end
		5: begin; read string
			readu,unit,nchars; read number of characters in string element
			if (nchars gt 0) then begin
				str=bytarr(nchars) & readu,unit,str; read string element
				str=string(str)
				case name of
					"command": (*datafile_ptr).command=str
					"comments": (*datafile_ptr).comments=str
					"sample_desc": (*datafile_ptr).sample_desc=str
					"start_date": (*datafile_ptr).start_date=str
					"startchoice": (*datafile_ptr).startchoice=str
					"stop_date": (*datafile_ptr).stop_date=str
					else: begin & ivaru=ivaru+1 & unknowns[ivaru]=name & end
				endcase
				ivar=ivar+1
				variables_read[ivar]=name
			endif
		end
		7: begin; read string array
			readu,unit,nstrgs; read number of strings in array
			strarray=strarr(nstrgs)
			for j=1,nstrgs do begin
				readu,unit,nchars; read number of characters in string element
				str=bytarr(nchars) & readu,unit,str; read string element
				strarray[j-1]=strjoin(string(str)); store, joined, in strarray
			endfor
			case name of
				"highsource": (*datafile_ptr).highsource=strarray
				else: begin & ivaru=ivaru+1 & unknowns[ivaru]=name & end
			endcase
			ivar=ivar+1
			variables_read[ivar]=name
		end
		else: error="N.B. An unsupported variable type has been encountered: "+strcompress(dt)
	endcase
endwhile

;print,"Reading completed."
dcs_read_binaryOctavefile_ptr_done_reading,unit,ivar,ivaru,variables_read,unknowns
return
;
no_file: free_lun,unit
	error="There is no file named "+filepath
end; Written by J.R.D. Copley.  Last revision 07/31/01.
;************************************************************************************************
pro dcs_write_asciiOctavefile_ptr,filename,datafile_ptr=datafile_ptr,compress=compressed,$
	choice=choice
;************************************************************************************************
;
compile_opt strictarr
;
; This is a procedure that writes an ascii Octave file.
;
if (filename eq "") then stop
;
on_ioerror, no_file
get_lun,unit
if (!VERSION.OS_FAMILY eq "Windows") then openw,unit,filename,/binary,/noautomode,compress=compressed
if (!VERSION.OS_FAMILY eq "unix") then openw,unit,filename,compress=compressed
;
nvars=n_tags(*datafile_ptr)
tagnames=tag_names(*datafile_ptr)
;
for ivar=0,nvars-1 do begin
	if (choice[ivar]) then begin
		name=tagnames[ivar]
		data=(*datafile_ptr).(ivar)
		nsize=size(data)
		ns0=nsize[0]
		nst=nsize[ns0+1]
		if (ns0 eq 0) then begin
			case nst of
				7: dt=5; string
				else: dt=1; scalar
			endcase
		endif
		if (ns0 eq 1) then begin
			case nst of
				7: dt=7; string array
				else: dt=2
			endcase
			if (dt eq 2) then begin & n1=nsize[1] & n2=1 & end
		endif
		if (ns0 eq 2) then begin
			case nst of
				7: dt=0
				else: dt=2
			endcase
			if (dt eq 2) then begin & n1=nsize[1] & n2=nsize[2] & end
		endif
;
		if (dt eq 0) then stop,"No good."
;
		printf,unit,"# name: "+name
		case dt of
			1: begin; write scalar
				printf,unit,"# type: scalar"
				printf,unit,data
			end
			2: begin; write matrix
				printf,unit,"# type: matrix"
				printf,unit,"# rows:"+strcompress(n1)
				printf,unit,"# columns:"+strcompress(n2)
				printf,unit,data
			end
			5: begin; write string
				nchars=strlen(data)
				printf,unit,"# type: string array"
				printf,unit,"# elements: 1"
				printf,unit,"# length:"+strcompress(nchars)
				printf,unit,data
			end
			7: begin; write string array
				printf,unit,"# type: string array"
				nstrgs=nsize[1]
				printf,unit,"# elements:"+strcompress(nstrgs)
				for j=0,nstrgs-1 do begin
					nchars=strlen(data[j])
					printf,unit,"# length:"+strcompress(nchars)
					printf,unit,data[j]
				endfor
			end
		endcase
	endif
endfor
;
free_lun,unit
return
;
no_file: begin
	free_lun,unit
	error="There is no file named "+filename
end
;
end
; Written by J.R.D. Copley.  Last revision 08/01/01.
;************************************************************************************************
pro dcs_write_summary_ptr,filename,datafile_ptr=datafile_ptr,choice=choice,icall,delim,short_form
;************************************************************************************************
;
compile_opt strictarr
;
; This procedure writes a delimited file summary.
;
if (filename eq "") then stop
;
on_ioerror, no_file
get_lun,unit
if (icall eq 0) then openw,unit,filename else openw,unit,filename,/append
;
nvars=n_tags(*datafile_ptr)
tagnames=tag_names(*datafile_ptr)
;
ivar_written=0
;
if (icall eq 0) then summary_line="File name" else summary_line=short_form
;
for ivar=0,nvars-1 do begin
	if (choice[ivar]) then begin
		ivar_written=ivar_written+1
		name=tagnames[ivar]
		data=(*datafile_ptr).(ivar)
		nsize=size(data)
		ns0=nsize[0]
		nst=nsize[ns0+1]
		n_el=n_elements(data)
		if (ns0 eq 0) then begin
			case nst of
				7: dt=5; string
				else: dt=1; scalar
			endcase
		endif
		if (ns0 eq 1) then begin
			case nst of
				7: dt=7; string array
				else: dt=2
			endcase
			if (dt eq 2) then begin & n1=nsize[1] & n2=1 & end
		endif
		if (ns0 eq 2) then begin
			case nst of
				7: dt=0
				else: dt=2
			endcase
			if (dt eq 2) then begin & n1=nsize[1] & n2=nsize[2] & end
		endif
;
		if (dt eq 0) then stop,"No good."
;
		if (icall eq 0) then begin
			if (n_el eq 1) then summary_line=summary_line+delim+name else $
				for j=0,n_el-1 do summary_line=summary_line+delim+name+strcompress(j,/remove_all)
		endif else begin
			case dt of
				1: begin; write scalar
					summary_line=summary_line+delim+strcompress(string(format=((f)),data))
				end
				2: begin; write matrix
					for j=0,n_el-1 do summary_line=summary_line+delim+strcompress(string(format=((f)),data))
				end
				5: begin; write string
					summary_line=summary_line+delim+strcompress(data)
				end
				7: begin; write string array
					for j=0,n_el-1 do summary_line=summary_line+delim+strcompress(data[j])
				end
			endcase
		endelse
	endif
endfor
;
printf,unit,summary_line
;
free_lun,unit
return
;
no_file: begin
	free_lun,unit
	error="There is no file named "+filename
end
;
end
pro def2,w3,pos,threshold,$
         noprint=noprint,printer=printer,delta=delta,scale=scale,max=max,datp=datp

IF NOT KEYWORD_SET(datp) THEN take_datp,datp 
IF N_ELEMENTS(threshold) ne 1600 THEN threshold=0
IF NOT KEYWORD_SET(delta) THEN delta=0
IF N_ELEMENTS(scale) NE N_ELEMENTS(pos) THEN scale=FLTARR(N_ELEMENTS(pos))+1.
WINDOW,0
x3=datp.x
xx=x3
FOR i=0,N_ELEMENTS(pos)-1 do begin
  b=pos(i)
  x3=xx
  mod_datp,datp,'x',xx
  w8=defil(w3,b,d,e,datp=datp,x=x3,bg=bg,delta=delta)
  w8=w8/scale(i)
  plotd,w8,d,b,e,datp=datp,threshold,bg=bg,max=max
  IF NOT keyword_set(noprint) THEN BEGIN
    mydevice=!D.NAME
    set_plot,'ps'
    device,/landscape,/color,filen=strcompress(ABS(b),/re)+'_'+strcompress(ABS(datp.p(14)),/re)+'.ps'
    plotd,w8,d,b,e,datp=datp,threshold,bg=bg,max=max
    device,/close
    set_plot,mydevice
    IF NOT keyword_set(printer) THEN printer='dj1_d20'
    spawn,'lp -d'+printer+' '+strcompress(ABS(b),/re)+'_'+strcompress(ABS(datp.p(14)),/re)+'.ps'
  ENDIF
ENDFOR

END
FUNCTION defil,w1,b,c,d,datp=datpp,x=x1,bg=bg,delta=delta

IF NOT Keyword_set(datpp) THEN take_datp,datp ELSE datp=datpp
IF NOT Keyword_set(x1) THEN x1=datp.x
IF NOT Keyword_set(x1) THEN delta=.5
pv1=datp.pv
p1=datp.p
FOR i=0,N_ELEMENTS(x1(0,*))-1 DO x1(*,i)=x1(*,i)-pv1(14,i)            
a=indgen(N_ELEMENTS(w1(0,*)))
w2=fltarr(100*(max(x1)-min(x1))) 
x2=findgen(100*(max(x1)-min(x1)))/100.+min(x1)            
for i=0,1599 do w2(10*i+a)=w2(10*i+a)+w1(i,a) 
w7=w1*0.
for j=0,N_ELEMENTS(w1(0,*))-1 do w7(*,j)=w1(*,j)*(x1(*,j) le b+delta and x1(*,j) ge b-delta )
w8=w7
c=where(total(w7,2) gt 0) 
cells=N_ELEMENTS(c)
w8=w7(c,*)
x8=0
x8=x1(c,*)   
points=N_ELEMENTS(w8(0,*))
bg=fltarr(cells)
for i=0,cells-1 DO bg(i)=min(w8(i,where(w8(i,*) gt 0)))
bg=min(bg)
w8=(w8-bg)>0
mod_datp,datp,'x',x8
IF NOT Keyword_set(datpp) THEN give_datp,datp ELSE datpp=datp
d=x1(0)+p1(14)
RETURN,w8

END

;    ALIGN the Dial
;    ****************

pro  DIAL_ALIGN_MACRO, D,san,trs,len
;**  ********************
;**

	COMMON	dial_plot,gsan,gtrs,len,xp,yp

	CATCH,stat & if stat ne 0 then begin print,!err_string & CATCH,/cancel & return & endif

	iprint =1

	maxiter=5
	
	dpr=180./!pi
	
;   set up instrument before scanning	
	
	foot=len*sin(gsan/dpr)
        sw=foot/2.
	dt=(foot+sw)/2.
	
	
	command='s3w 0'	        & C=DialControl(command,CHECK=0.5)
	command='DET 3400'	& C=DialControl(command,CHECK=0.5)	
	command='DAN 2'	        & C=DialControl(command,CHECK=0.5)
	command='DAN 2'	        & C=DialControl(command,CHECK=0.5)
	command='s2w '+STRING(sw)	        & C=DialControl(command,CHECK=0.5)
	command='s3w '+STRING(sw)	        & C=DialControl(command,CHECK=0.5)
	
	var    =D.scanvar
	c_time =STRING(D.c_time)

	IF (NOT D.started) THEN BEGIN
		D.started=1	& D.niter=0
		D.current(*)=[0,gtrs-dt,gtrs+dt,0.05,.6,.1,1.0,.2,0,0]
		D.current(0)=D.current(1)
		B           =D.current(0)
		IF (iprint GT 0)   THEN PRINT,'Start first scan'
		command=D.initialise	& C=DialControl(command,CHECK=0.5)
		if C lt 0 then print,'Mad is un-reachable !!! sending "'+command+'"''
		command=var+' '+STRING(B)	& C=DialControl(command,CHECK=0.5)
		
		wait,3.
		
		command='co '+c_time+' t nos'	& C=DialControl(command,CHECK=0.5)
		DialWSet
	ENDIF ELSE BEGIN
		B	=D.current(0)
		Bmin	=D.current(1)
		Bmax	=D.current(2)
		dB	=D.current(3)
		B1range	=D.current(4)
		dB1	=D.current(5)
		B2range	=D.current(6)
		dB2	=D.current(7)
		lambda	=D.lambda
		IF (iprint GT 0) THEN BEGIN
			PRINT,'B=',B,' Bmin=',Bmin,' Bmax=',Bmax,' dB=',dB,' var=',var
			FOR i=0,3 DO PRINT,'D.current(',i,')=',D.current(i)
			PRINT,'D.scanvar=', D.scanvar
			PRINT,'Check counting status'
		ENDIF
		D.type='flagus' & status=DialNewValue()
		IF (status EQ 0) THEN BEGIN
;-------------------get monitor counts and plot them------------------
			D.type='data'  & monitor=DialNewValue()
			V=total(monitor)  & D.value=V  & D.error=SQRT(V)
			IF (B EQ Bmin) THEN BEGIN
				 xp=[B,B]  & yp=[V,V]
				 xp=[B]    & yp=[V]
			ENDIF ELSE BEGIN
				xp=[xp,B]  & yp=[yp,V] & ENDELSE
			ep=SQRT(yp)
			DialWSet
			PLOT, xp, yp, PSYM=2, XRANGE=[Bmin,Bmax], YRANGE=[0,MAX(yp)], XTITLE=var, $
				YTITLE='M2 Counts', TITLE='Iteration no. '+STRTRIM(STRING(D.niter+1),2)+' - scan of '+var
			ERRPLOT, xp, yp-ep, yp+ep
;-------------------increment current and start new count-------------
			IF (B LT Bmax) THEN BEGIN
;		    --------continue present scan
				B=B+dB
				command=var+' '+STRING(B)	& C=DialControl(command)
				wait,0.2
				command='co '+c_time+' t nos'	& C=DialControl(command)
			ENDIF ELSE BEGIN
;		    --------end scan, fit minimum, set current and start new scan
				D.niter=D.niter+1
				fit_parabola,xp,float(yp),bestfit,B00	& B0=B00(0) & ymin=B00(1)
				B0=FLOAT(ROUND(B0*100.))/100.
;				DialWSet
				OPLOT, xp, bestfit, PSYM=0, LINESTYLE=0
				ch='Minimum at '+var+' ='+STRING(B0)
				XYOUTS, B0, ymin, ch
				command=var+' '+STRING(B0)	& C=DialControl(command,CHECK=0.5)
				if C lt 0 then print,'Mad is un-reachable !!! sending "'+command+'"'
				IF (var EQ 'TRS') THEN BEGIN
					D.bestB1=B0	& var='B2'
				ENDIF ELSE BEGIN
					D.bestB2=B0	& var='B1'
				ENDELSE
				IF (D.niter EQ 5) THEN BEGIN
					PRINT,'Best currents found: B1=',D.bestB1
					PRINT,'                     B2=',D.bestB2
					PRINT,'finished'
					dialstop
					RETURN
				ENDIF ELSE IF (D.niter EQ 1) THEN BEGIN
					Bmin=3.5	& Bmax=5.9 & dB=0.2
				ENDIF ELSE IF (2*(D.niter/2) EQ D.niter) THEN BEGIN
					Bmin=D.bestB1-B1range	& Bmax=D.bestB1+B1range & dB=dB1
				ENDIF ELSE BEGIN
					Bmin=D.bestB2-B2range	& Bmax=D.bestB2+B2range & dB=dB2
				ENDELSE
				B=Bmin
				wait,3.0
				command=var+' '+STRING(B)	& C=DialControl(command,CHECK=0.5)
				wait,3.0
				command='co '+c_time+' t nos'	& C=DialControl(command,CHECK=0.5)
			ENDELSE
		ENDIF
		D.scanvar=var
		D.current(0)=B
		D.current(1)=Bmin
		D.current(2)=Bmax
		D.current(3)=dB
	ENDELSE

	END

pro fit_parabola, xp,yp, bestfit, xymin
;** ************
	s=SIZE(xp)	& np=s(1)
	dx=xp(1)-xp(0)

	A0=INT_TABULATED(xp,yp)
	A1=INT_TABULATED(xp,yp*xp)
	A2=INT_TABULATED(xp,yp*xp^2)

	x1=xp(0)	& x2=xp(np-1)
	d1=x2-x1
	d2=(x2^2-x1^2)/2.
	d3=(x2^3-x1^3)/3.
	d4=(x2^4-x1^4)/4.
	d5=(x2^5-x1^5)/5.

	A=[[d3,d2,d1],[d4,d3,d2],[d5,d4,d3]]
	B=[A0,A1,A2]
	R=CRAMER(A,B)

	bestfit=R(0)*xp^2+R(1)*xp+R(2)
	x0=-0.5*R(1)/R(0)
	ymin=R(0)*x0^2+R(1)*x0+R(2)

	xymin=[x0,ymin]
	END




;******* ********************************
;******* ********************************
function DIAL_FLIPPER
;******* ********************************
;******* ********************************
;**
;** 
;** Output D is the dial structure returned for DialInit
;********* *********************************************

name     ="flipper"
generic  ="mad"
type     ="data"
onoff    = 0
value    = 0L
error    = 0L
frequency= 2.0
duration = 0.0
history  = 0
plot     = 100

                ;** Other tags used in your procedure DIAL_TEMPLATE1_MACRO:
                ;** ******************************************************
                unit      ="counts"	;The dial string unit
                lowerlim  =0.          ;The dial lower limit value
                upperlim  =0.	;The dial upper limit value

		started   = 0
		current   = FLTARR(10)  ;[,,,initial dB,B1range,dB1,B2range,dB2]
		scanvar   = 'trs'
		initialise='san 0.8'
		c_time    = 5		; counting time per point
		lambda    = 5.0

D={NAME:name, GENERIC:generic  , VALUE:value    , ONOFF:onoff    , FREQUENCY:frequency,$
              DURATION:duration, UNIT:unit      , HISTORY:history, UPPERLIM:upperlim  ,$
              LOWERLIM:lowerlim, PLOT:plot      , TYPE:type      , STARTED:started    ,$
              CURRENT:current  , SCANVAR:scanvar, INITIALISE:initialise,$
              C_TIME:c_time    , LAMBDA:lambda  , NITER:0,BESTB1:0.,BESTB2:0.}
RETURN ,D
END
;pro dial_autoalign,len,san,scantrs,scandata

;pro err_event
;  if ev.select then widget_control, ev.tp,/DESTROY
;end

;pro message,tit
; base=widget_base()
; button=widget_button(base,value='DONE',title=tit)
; widget_control,base,/realize
; xmanager,'message',base
;end


;*************************************************************************


pro dial_autoalign,len,san,scantrs,scandata
print,'Starting autoalign....'
prin=0
dpr=180./!pi

;message,'Please make sure SAN~theta and sample is aligned with TRS'

foot=len*sin(san/dpr)
count='10'
rdan=2.3
dbdan=0.8
dbtrs=3.
range=2.5
points=25.
shif=2
nx=1.
pcen=138.98/nx
mmpp=1.0357*nx 
scandata=fltarr(points)
scantrs =fltarr(points)

step=range/points
print,'range: ',range,' points: ',points,'footprint: ',foot

print,'Defining SAN and TRS to be zero'
d17mad,'par set trs 0'
d17mad,'par set san 0'


mv,'s2w',0
mv,'s3w',0

mv,'dan',rdan

; set sample slit equal to the footprint s2w needs to be minimum 0.5

mv,'s2w',0.5
mv,'s3w',foot


; set san equal to requested value
mv,'san',san
wait,1
co,count,'t n'
co,count,'t n'
d=dial_mad_read('t_res')
size=d.par_tof(0)*(d.par_tof(4)-d.par_tof(3)+1)*(d.par_tof(2)-d.par_tof(1)+1)
print,'size= ',d.par_tof(0),(d.par_tof(4)-d.par_tof(3)+1),(d.par_tof(2)-d.par_tof(1)+1)

d17mad,'kill'
;  scan the translation trs
   for i=0,points-1 do scandata(i)=0.
   for i=0,points-1 do scantrs(i)=0.


for i=0,points-1 do begin

   trs=-range/2.+i*step
   mv,'trs',trs
   co,count,'t n'
   dat=dial_mad_read('data')
   scandata(i)=total(dat(0:size-1))
   wait,1
   m=DIAL_MAD_READ('motors')
   scantrs(i)=m(1)
endfor


for i=0,points-1 do print,i,scantrs(i),scandata(i)
dialwset
plot,scantrs,scandata
errplot,scantrs,scandata-sqrt(scandata),scandata+sqrt(scandata)

; find the maximum of the peak

  maxtot=max(scandata(1:points-1),a)
  print,'max is: ',maxtot
  maxtrs=scantrs(a+1)
  print,'at: ',maxtrs
;  find half footprint from the peak


  a1=(a+1)-shif
  a2=(a+1)+shif
  print,'finding centre between trs values: ',scantrs(a+1-shif),' and ',scantrs(a+1+shif) 

;  m1=maxtrs-foot/2.
;  m2=maxtrs+foot/2.
;  print,'finding centre between trs values: ',scantrs(a+1-shif),' and ',scantrs(a+1+shif) 
;  blap=where ((scantrs(1:points-1) gt m1 and scantrs(1:points-1) lt m2))

;  a1=min(blap)
;  a2=max(blap)



  sum1=0
  sum2=0
  for i=a1,a2 do begin
     sum1=sum1+scantrs(i)*scandata(i)
     sum2=sum2+scandata(i)
  endfor
  print,sum1,sum2
  centrs=sum1/sum2


  print,'centre of scan found at trs: ',centrs


;  move to centre and set value to zero

   mv,'trs',centrs-.5
   mv,'trs',centrs
  

   d17mad,'par set trs 0'
 
   mv,'san',san
   calsan

   mv,'dan',rdan
   mv,'trs',-0.5
   mv,'trs',0
   mv,'san',0


   m=DIAL_MAD_READ('motors')
   print,' '
   print,'SAN is now equal to theta and is at ',m(2),' deg.'
   print,'Detector angle DAN is now at ',m(16),' deg.'
   print,'Sample translation TRS is centred at zero and is at',m(1),' mm'
   print,'  '
   print,'You are now ready to start a measurement'
  
end
;------------------------------------------------------------------------------
; This code is used to run a Dial speaking to the instrument without GEORGE guy
;------------------------------------------------------------------------------

; FUNCTION DialNewValue   GET  A VALUE FROM THE INSTRUMENT
; FUNCTION DialControl 	  SEND A COMMAND TO THE INSTRUMENT
; FUNCTION DialOn 	  NORMALY USED FOR INTERRUPT IN GEORGE
; PRO      DialTag 	  SET OR GET A DIAL PROPERTY
; PRO      DialStart	  TIE A DIAL TO THE CLOCK
; PRO      DialStop	  DETACH A DIAL FROM THE CLOCK
; PRO      DialModValue	  ADD or CHANGE DIMENSION OF A DIAL PROPERTY
; PRO      DialInit	  READ   A DIAL FROM FILE AND PUT IN MEMORY
; PRO      DialMacro	  EXECUTE THE MACRO OF A NON-ACTIVE DIAL
; PRO      DialClear	  REMOVE A DIAL FROM MEMORY
; PRO      DialWset       NORMALY USED TO SELECT MAIN-PLOT-WINDOW IN GEORGE
; PRO      DialsFrequency NORMALY USED TO GIVE THE SAME FREQUENCY TO A GROUP OF DIALS

; MATLAB tips: DD=CALL_FUNCTION('dial_'+DD.origin+'_macro',DD)
;             ii =EXECUTE('DD='+dial)
;             mat= 1 in by_timer
;             value='                                               ',/dynamic_resize
;--------------------------------------------------------------------------------------
FUNCTION DialNewValue, tope,NAME=name,d=dnum,SETVALUE=setvalue, COMMENT=ctxt, TYPE=tipe
;******* ************
;**	 GET A VALUE FROM THE INSTRUMENT
	 common noGeorge,DD, Widg
	 
CATCH,stat
if stat ne 0 then begin catch,/cancel & print,!err_string & return,'error' & endif
if n_elements(tope) ne 1 then if n_elements(tipe) ne 1 then tipe=DD.type
if n_elements(tope) eq 1 then if n_elements(tipe) ne 1 then tipe=tope
IF DD.generic eq 'lamp'  then begin
   CASE strlowcase(tipe) of
   'flagus':	V=0
   'status':	V='Idle'
   'log':	V=''
   ELSE:	V=0
   ENDCASE
ENDIF else $
   V= CALL_FUNCTION('dial_'+DD.generic+'_read',tipe)    ;...GET A VALUE FROM INSTRUMENT
if keyword_set(setvalue) then DialModValue, V, tag='VALUE'
return,V
END

;--------------------------------------------------------------------------------------
FUNCTION DialControl, command, d=dnum ,check=check ,name=nome
;******* ***********
;**	 SEND A COMMAND TO THE INSTRUMENT
	 common noGeorge,DD, Widg

CATCH,stat
if stat ne 0 then begin catch,/cancel   & print,!err_string  & return,'error' & endif
if n_elements(check) ne 1 then check=0. & V=0
IF DD.generic ne 'lamp' then $
  V= CALL_FUNCTION('dial_'+DD.generic+'_send','',check,command)$;SEND COMMAND TO INSTRU
ELSE ii=EXECUTE(command(0))
return,V
END

;--------------------------------------------------------------------------------------
FUNCTION DialOn, dial, d=dnum
;******* ******
;**	 NORMALY USED FOR INTERRUPT IN GEORGE
return,1
END

;--------------------------------------------------------------------------------------
PRO DialTag, name, d=dnum, TAG=tag, SET=setv, GET=getv
;** *******
;** SET OR GET A DIAL PROPERTY
    common noGeorge,DD, Widg

BY_SWITCH,/STORE, NEWNUM=dnum,NEWNAME=name
getv=0
IF n_elements(tag)  eq 0 then getv=DD else ii=execute('getv=DD.'+tag)           ;...GET
IF n_elements(setv) gt 0 then DialModValue, setv, TAG=tag                       ;...SET
BY_SWITCH,/RESTORE
END

;--------------------------------------------------------------------------------------
PRO DialStart, name, d=dnum
;** *********
;** TIE A DIAL TO THE CLOCK
    common noGeorge,DD, Widg

BY_SWITCH,/STORE, NEWNUM=dnum,NEWNAME=name
DialModValue, systime(1), TAG='BYSTART'
DD.onoff=1 & widget_control,bad_id=ii,Widg(DD.number+3),TIMER=.1     ;...SET TIME EVENT
BY_SWITCH,/RESTORE
END

;--------------------------------------------------------------------------------------
PRO DialStop, name, d=dnum
;** ********
;** DETACH A DIAL FROM THE CLOCK
    common noGeorge,DD, Widg
    
DialTag, name, d=dnum, TAG='ONOFF', SET=0
END

;--------------------------------------------------------------------------------------
PRO DialModValue, val, NAME=name, d=dnum ,tag=TAG
;** ************
;** ADD or CHANGE DIMENSION OF A DIAL PROPERTY
    common noGeorge,DD, Widg
    
      sv =SIZE(val)
      if n_elements(TAG) ne 1 then TAG='VALUE' else TAG=strupcase(TAG)
      tlist=strupcase(tag_names(DD))
      idx=WHERE(tlist eq TAG) & sz =[0,0,0]
      if idx(0) ge 0 then ii=execute('sz=SIZE(DD.'+TAG+')')
      if (sz(sz(0)+1) ne sv(sv(0)+1)) or (sz(sz(0)+1) eq 8) or $
         (sz(0) ne sv(0)) or (sz(sz(0)+2) ne sv(sv(0)+2)) then begin
	 elsa = ''
	 for k=0,n_elements(tlist)-1 do begin
          CASE tlist(k) of
           TAG:
           ELSE:      elsa =elsa+','+tlist(k)+':DD.'+tlist(k)
          ENDCASE
	 endfor
                 ii=execute('DD={'+TAG+':val'+ elsa +'}') ;...RECONSTRUCT THE STRUCTURE
      endif else ii=execute('DD.' +TAG+'=val')            ;...OR SIMPLY MODIFY THE  TAG
END

;--------------------------------------------------------------------------------------
PRO DialInit, name, d=dnum, path=pth, restore=rest, new=newed, herits=diaH, nostart=nos
;** ********
;** READ A DIAL FROM FILE AND PUT IN MEMORY
    common noGeorge,DD, Widg

IF n_tags(DD) ge 3 then begin if n_elements(name) ne 1 then name=DD.name
			kp=DD.number & endif else kp=0
DIAL_BYGEORGE, name, nostart=nos, new=newed                            ;...GET THE DIAL
BY_SWITCH,LOAD=kp
END

;--------------------------------------------------------------------------------------
PRO DialMacro, name, d=dnum, Si=di
;** *********
;** EXECUTE THE MACRO OF A NON-ACTIVE DIAL
    common noGeorge,DD, Widg

BY_SWITCH,/STORE, NEWNUM=dnum,NEWNAME=name
call_procedure,'dial_' +DD.origin+'_macro',DD                     ;...EXECUTE THE MACRO
BY_SWITCH,/RESTORE
END

;--------------------------------------------------------------------------------------
PRO DialClear, name, d=dnum
;** *********
;** REMOVE A DIAL FROM MEMORY
    common noGeorge,DD, Widg

BY_SWITCH,/CLEAR, NEWNUM=dnum,NEWNAME=name
END

;--------------------------------------------------------------------------------------
PRO DialWset, Activity=activity
;** ********
;** NORMALY USED TO SELECT MAIN PLOT WINDOW IN GEORGE
    Wset,0L
END

;--------------------------------------------------------------------------------------
PRO DialsFrequency, GET=getv, SET=setv, STOP=stop, START=stort, DURATION=lim, SENS=sens
;** **************
;** NORMALY USED TO GIVE THE SAME FREQUENCY TO A GROUP OF DIALS IN GEORGE

getv=0.
END
;-------------------------------- End of User library ---------------------------------
;-------------------------------- End of User library ---------------------------------

;--------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------

;--------------------------------  Internal routines  ---------------------------------
;--------------------------------  Internal routines  ---------------------------------

; PRO      by_switch	  SWITCH ROUND THE DIALS WHEN INVOLVED
; PRO      by_timer	  THE CLOCK HANDLER
; PRO      by_stop	  STOP ALL DIALS
; PRO      dial_byGeorge  CALLED BY "DialInit" TO READ A DIAL FILE


PRO by_switch,LOAD=lod ,SAVE=sav,STORE=sto ,RESTORE=res,NEWNUM=dnu,NEWNAME=nam,$
              CLEAR=clr,STOP=stp,GETNUM=gnu
;** *********
;** SWITCH ROUND THE DIALS WHEN INVOLVED
    common noGeorge,DD, Widg
    common bygeorge,d0 ,d1 ,d2 ,d3 ,d4 ,d5 ,d6 ,d7 ,d8 ,d9 ,d10,$
                    d11,d12,d13,d14,d15,d16,d17,d18,d19,d20,names,pile

IF n_elements(names) eq 0 then begin d0={ONOFF:0,NUMBER:0,NAME:''}   & d1 =d0 & d11=d1
	d2 =d1 & d3 =d1 & d4 =d1 & d5 =d1 & d6 =d1 & d7 =d1 & d8 =d1 & d9 =d1 & d10=d1
	d12=d1 & d13=d1 & d14=d1 & d15=d1 & d16=d1 & d17=d1 & d18=d1 & d19=d1 & d20=d1
	names=strarr(21) & pile='' & ENDIF

IF n_elements(nam)  eq 1 then begin
		    idx=where(names eq strlowcase(nam))
		    if idx(0) gt 0 then lod=idx(0) else IF keyword_set(sto) then lod=0
ENDIF
IF n_elements(dnu)  eq 1           then lod=dnu

if n_tags    (DD)   lt 3 then DD=d0 & sd=strtrim(string(DD.number),2)

same=0 & if n_elements(lod) ne 1 then same=1 else if lod eq DD.number then same=1

;---SWITCHES---
IF keyword_set(clr) then begin if same then idx=DD.number else idx=lod
		    r=EXECUTE('d'+strtrim(string(idx),2)+'.ONOFF=0')
		    if same then DD.onoff=0 & names(idx)='' & same=1    & ENDIF
 
IF keyword_set(stp) then FOR k=1,20 do r=EXECUTE('d'+strtrim(string(k),2)+'.ONOFF=0')
IF keyword_set(stp) then DD.onoff=0

IF keyword_set(gnu) then begin if n_elements(lod) eq 1 then gnu=lod $
		               else begin idx=where(names(1:*) eq '')+1
			                  if idx(0) eq 0 then gnu=20 else gnu=idx(0)
			       endelse  & same=1 & ENDIF

IF keyword_set(sto) then pile=[pile,sd]

IF keyword_set(sav) then begin names(DD.number)= DD.name
			       r=EXECUTE('d'+sd+'=DD') & ENDIF

IF     not same     then begin names(DD.number)= DD.name
			       r=EXECUTE('d'+sd+'=temporary(DD)')
			       r=EXECUTE('DD=d'+strtrim(string(lod),2)) & ENDIF

IF keyword_set(res) then BEGIN nn=n_elements(pile)-1
		    IF nn gt 0 then BEGIN sg=pile(nn) & pile=pile(0:nn-1)
		       IF sg ne sd then BEGIN
		               names(DD.number)= DD.name
		               r=EXECUTE('d'+sd+'=temporary(DD)')
			       r=EXECUTE('DD=d'+sg)    & ENDIF & ENDIF & ENDIF
END



PRO by_timer, event
;** ********
;** THE CLOCK HANDLER
    common noGeorge,DD, Widg
BYs=0
IF Widg(0) gt 0 then begin widget_control,event.id,get_uvalue=uv
		MAT=0 ;MAT=0 for Idl, mat=1 for Matlab
		if (DD.number ne uv(0)) then $
		 if MAT then begin BY_SWITCH,/STORE,NEWNUM=uv(0) & BYs=1
		 endif  else BY_SWITCH,LOAD=uv(0)
ENDIF
WHILE ((DD.frequency gt 0) and (DD.onoff)) do begin T1=systime(1)

	CALL_PROCEDURE,'dial_'+DD.origin+'_macro',DD

	if n_elements(DD.value) eq 1 then if (DD.value(0) ne '') then $
			 val=' Val=' + string(DD.value) else val='' else val=''

	if (DD.history   eq 1) then if (DD.value(0) ne '')   then begin
		openw,u,'dial_'+DD.name+'.his',/get_lun,/APPEND
		printf,u,DD.value & free_lun,u & endif
	  
	T2=systime(1)
	if  DD.duration  gt 0. then if (T2-DD.bystart) gt DD.duration then DD.onoff=0
       
	T1=(DD.frequency-float((T2-T1)))>0.01
	if (DD.frequency gt 0.) and (DD.onoff) then $
		if Widg(0) gt 0 then begin
		   widget_control,Widg(1),bad_id=ii,set_value=strmid(!stime,12,11)$
		                             +' Freq='+strtrim(string(DD.frequency),2)+val
		   widget_control,Widg(2), set_value=strupcase(DD.name)
		   widget_control,Widg(uv(0)+3),timer=T1
		   if BYs then    BY_SWITCH,/RESTORE
		   BYs=0 & return
		endif else wait,T1
ENDWHILE
if BYs then BY_SWITCH,/RESTORE
END

PRO by_stop, event
;** *******
;** STOP ALL DIALS
    common noGeorge,DD, Widg

BY_SWITCH,/STOP
if n_elements(event) gt 0 then widget_control,event.top,/destroy
END

PRO map	   & common noGeorge,DD, Widg & widget_control,Widg(0),bad_id=ii,map=1 & END
PRO nomap  & common noGeorge,DD, Widg & widget_control,Widg(0),bad_id=ii,map=0 & END
;** *****

PRO dial_byGeorge, name, nostart=nostart, new=newed
;** *************
;** CALLED BY "DialInit" TO READ A DIAL FILE
    common noGeorge,DD, Widg
    
!quiet=1 & dnum=1 & if n_elements(name) eq 0 then name='bygeorge'
IF n_elements(newed) eq 0 then newed=name

BY_SWITCH,/SAVE
BY_SWITCH, GETNUM=dnum, NEWNAME=newed
dial ='dial_'+name
DD   ={INIT:0,ONOFF:0}

IF name ne 'bygeorge' then ii =EXECUTE('DD='+dial+'()') else II=1
                                IF (not II) then RETURN

tags =['NAME','VALUE','UNIT','GENERIC','TYPE','ORIGIN','PATH']
defs =[ newed,   ''  ,  ''  ,  'mad'  ,'data', name   ,  ''  ]
tagi =['NUMBER','ONOFF','PLOT','WUPDATE','HISTORY','INIT']
defi =[ dnum   ,   1   ,   1  ,    0    ,    0    ,  0   ]
tagr =['ERROR','UPPERLIM','LOWERLIM','FREQUENCY','DURATION']
defr =[   0.  ,    0.    ,    0.    ,     1.    ,    0.    ]

tlist= strupcase(tag_names(DD))
FOR i= 0,n_elements(tags)-1 do begin  idx=WHERE(tlist eq tags(i))
    if idx(0) eq -1 then DialModValue,defs(i),tag=tags(i) & ENDFOR
FOR i= 0,n_elements(tagi)-1 do begin  idx=WHERE(tlist eq tagi(i))
    if idx(0) eq -1 then DialModValue,defi(i),tag=tagi(i) & ENDFOR
FOR i= 0,n_elements(tagr)-1 do begin  idx=WHERE(tlist eq tagr(i))
    if idx(0) eq -1 then DialModValue,defr(i),tag=tagr(i) & ENDFOR

DD.name=newed

if (!D.flags and 65536) ne 0 then begin
  if xregistered('ByGeorge') le 0 then begin Widg=lonarr(24)
  	Widg(0)  =widget_base  (Title="By George !",/column,event_pro='by_timer',map=0)
	bod      =widget_base  (Widg(0),/row)
	Widg(2)  =widget_label (bod    ,value='----- '+strupcase(newed)+' -----' )
	bid      =widget_button(bod    ,value='stop'       ,event_pro='by_stop' )
	for i=0,20 do Widg(3+i)=widget_label (bod    ,value='', uvalue=i)

	bod      =widget_base  (Widg(0),/row)
	Widg(1)  =widget_label (bod    ,value=' ',/dynamic_resize)

	widget_control,Widg(0),/realize
	XMANAGER,'ByGeorge',Widg(0),event_handler='by_timer',/no_block
  endif
  IF keyword_set(nostart) then DD.onoff=0 else if DD.onoff then DialStart
  BY_SWITCH,/SAVE

endif else begin Widg=0 & BY_TIMER & BY_STOP & endelse
END

PRO  byGeorge, name, nostart=nostart, new=newed
dial_byGeorge, name, nostart=nostart, new=newed
END
; written by Floris Andre, August 2001;

;**************************
;HOW TO RUN THIS DIAL:
;------------------------
;START idl THEN ENTER:  
;Idl>.run dial_changer_file
;Idl> changer_file   
;**************************


pro changer_file
;** *********
;Used to run with "byGeorge"
FORWARD_FUNCTION DialControl, DialNewValue, DialOn
if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

dial_bygeorge,'changer_file'	;<-------- Name of the Dial !!!
END				;         ~~~~~~~~~~~~~~~~~ !!!

;*********************
PRO dial_changer_file_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by 
;** the function dial_changer_file

print, " "
print, "***********************"
print, "dial_changer_file_macro"

if D.init eq 0 then begin
	;D.init=1
	D.frequency=0.
	;Lim=DialNewValue(type='limits')
	;para=DialNewValue(type='t_para')
	changer_file_gui
endif 
end

;*************************************************************************************************************************************
;*************************************************************************************************************************************
pro changer_file_event,ev
;*************************************************************************************************************************************
;*************************************************************************************************************************************

common check,chec			;to know whitch button has been selected
common nofile,exist_file,ex

exist_file=1
widget_control,ev.id,get_uvalue=u


;---------- HELP BUTTON -----------------
if u(0) eq 11116 then begin 
xdisplayfile,'/users/d22/hlp/dial_changer_file.hlp',title='Changer-File Help',group=ev.top,height=40,width=65
	

  end


;---------- close button ---------------
if u(0) eq 11114 then begin
	widget_control,ev.top,/destroy
endif 

;------------ create new file ----------
if u(0) eq 11111 then begin
	chec=0
	ex=0
	rack
endif 

;----------- use a saved file -----------
if u(0) eq 11112 then begin
	chec=1

;----------------- DEFINITION OF WIDGETS ---------------------
common basedeb,based0,based1
common basefin,base2d,base3d
common basedeb,based0,based1
common b,b1,b2
common sortie,exit
common top,changer_based0

base3d=widget_base(base2d,/row)
q3=cw_field(base3d,title='enter the saved file to open:',xsize=10,/return_events)
q4=widget_label(base3d,value='.cmd')

b5=widget_button(base2d,xsize=250,value='check this file')
b3=widget_button(base2d,xsize=200,frame=2,value='open file')

widget_control,b1,sensitive=0
widget_control,b2,sensitive=0

;--------------------- REALIZE THE WIDGETS ------------------------
widget_control,changer_based0,/realize

;-------------------------- EVENTS ----------------------------
widget_control,q3,set_uvalue=[11115,q3]
widget_control,b5,set_uvalue=[11117,q3]
widget_control,b3,set_uvalue=[11113,b3,q3]
widget_control,exit,set_uvalue=[11114,exit]
xmanager,'ev01',changer_based0,/just_reg
	
endif
end

;*************************************************************************************************************************************
;*************************************************************************************************************************************
pro ev01_event,ev
;*************************************************************************************************************************************
;*************************************************************************************************************************************
common check,chec
common tablo,tabb
common errr,err2
common nofile,exist_file,ex


tabb=strarr(1100)
widget_control,ev.id,get_uvalue=uu


;-------------- TO KNOW IF THE FILE EXISTS OR NOT ---------------
exist_file=0
ex=0
;-----------------------------------------------------------------



;------------ close button ----------------
if uu(0) eq 11114 then begin
	widget_control,ev.top,/destroy
endif 
;------------------------------------------

;--------------- wavelength ---------------
;if uu(0) eq 11116 then begin
;	widget_control,uu(1),get_value=l
;	tabb[1099]=l[0]
;
;endif
;--------------------------------------------

;---------------- name of file ----------------
if uu(0) eq 11115 then begin
	widget_control,uu(1),get_value=nam
;	print,"nam: ",nam
	nam=strtrim(string(nam))	; +string('.cmd')
;	print,"nam: ",nam
	tabb[1098]=nam[0]
endif

;---------------- box with file ----------------
if uu(0) eq 11117 then begin
	widget_control,uu(1),get_value=nam
	tabb[1098]=nam[0]
	fileread=string(format='(A30)','')
	fileread=tabb[1098]+'.cmd'
	print, "new version 3"
	print, "fileread: [",fileread,"]"
	xdisplayfile,fileread[0],group=ev.top,height=30,width=60
endif

;---------------------------------------------



;------------ open file button -----------------
if uu(0) eq 11113 then begin

	widget_control,uu(2),get_value=nam
	tabb[1098]=nam[0]
	nam=tabb[1098]+'.cmd'
;	print,"nam: ",nam


common nb,n
common vale,val

;-------------------------- VARIABLES ---------------------------
read1='   '
deb=0
cpt=0
common var,j,p,sn
j=0
val=strarr(10)
po=strarr(23)
pa=strarr(23)
ru=strarr(23)
rut=strarr(23)
sa=strarr(23)
re=strarr(23)



;----------------------------------------------------------------

;------------------------ READ THE FILE -------------------------


on_ioerror,label
openr,roro,nam[0],/get_lun

;----- THE FILE EXISTS --------
exist_file=1
err2=string(format='(A80)','')
;------------------------------

while not (eof(roro)) do begin
	point_lun,-roro,deb
	readf,roro,read1
	if strmid(read1,4,5) eq 'title' then begin
		val[0]=strmid(read1,9,80)
		val[0]=strmid(strtrim(val[0],2),0,32)
	endif
		
	if strmid(read1,4,4) eq 'date' then begin
		val[1]=strmid(read1,9,80)
		val[1]=strmid(strtrim(val[1],2),0,11)
	;print,"date: [",val[1],"]"
	endif
	
	if strmid(read1,4,4) eq 'user' then begin
		val[2]=strmid(read1,9,80)
		val[2]=strmid(strtrim(val[2],2),0,10)
	;print,val[2]
	endif
	
	if strmid(read1,4,4) eq 'prop' then begin
		val[3]=strmid(read1,9,20)
		val[3]=strmid(strtrim(val[3],2),0,10)
	;print,val[3]
	endif

	;----------------- FOR POSITION ---------------
	
	ch=strpos(read1,'cha')
	;print,'cha= ',ch
	if ch ge 0 then begin
		cpt=cpt+1
		j=cpt
		po[j]=strmid(read1,ch+4,80)
		po[j]=strtrim(po[j],2)	
		; print,"po(",strtrim(j,2),")= ",po[j]
		nsa=po[j]
	endif	
	ps=strpos(read1,'par sub')
	;print,'ps= ',ps
	if ps ge 0 then begin
		;---------- FOR PAR SUB --------------
		und=strpos(read1,'_')
		
		if und gt 0 then begin
		  pa[nsa]=strmid(read1,ps+10,20)
		  pa[nsa]=strtrim(pa[nsa])
		;  print,pa[nsa]
		endif else begin
		  pa[nsa]=strmid(read1,ps+8,20)
		  pa[nsa]=strtrim(pa[nsa])
		endelse
		
		;---------------------------------------
	endif
	
	if strmid(read1,0,3) eq 'run' then begin
		r=strpos(read1,'run')
		rf=r+3
		
		;----------- FOR RUN VALUE ---------------
		;if strmid(read1,4,50) eq 'm' then begin
			p1=strpos(read1,'m')
			if p1 gt 0 then begin
			;print,'p=',p1,cpt
			rut[j]='m'
			;print,'rut= ',rut[j]
			p=p1
			endif
		;if strmid(read1,4,50) eq 't' then begin
			p2=strpos(read1,'t')
			if p2 gt 0 then begin
			;print,'p=',p2,cpt
			rut[j]='t'
			;print,'rut= ',rut[j]
			p=p2
			endif else begin
			rut[j]='t'
			endelse
		;endif
		
		
			ru[j]=strmid(read1,rf+1,p-(rf+1))
			ru[j]=strtrim(ru[j],2)
			;print,'ru= ',ru[j]
		
		
		
		;---------- FOR S/N VALUE -----------------
		
		s1=strpos(read1,'s',rf)
			if s1 gt 0 then begin
			
			sa[j]='s'
			;print,'sav= ',sa[j]
			sn=s1
			endif else begin
			sa[j]='s'
			endelse
		
		n1=strpos(read1,'n',rf)
			
			if n1 gt 0 then begin
			sa[j]='n'
			;print,'sav= ',sa[j]
			sn=n1
			;print,'sn= ',sn
			
		
		;-----------------------------------------
		
		;---------- FOR REP VALUE -----------------
		
		re[j]=strmid(read1,p+1,sn-(p+1))
		re[j]=strtrim(re[j],2)
		;print,'re= ',re[j]
		;-----------------------------------------
			
			endif else begin
			re[j]='1'
			endelse
			
	endif
	
	;print,''
	
	
	
	
	
	
endwhile

close,roro



;------------------------------ end of reading -----------------------


;if exist_file eq 1 then begin
;openr,roro,nam[0],/get_lun

;while not (eof(roro)) do begin
;	point_lun,-roro,deb
;	readf,roro,read1

;		if strpos(read1,'wavelength') gt 0 then begin
;		tabb[1099]=strmid(read1,11,50)
;		ex=1	
;		print,'l= ',tabb[1099]
;		endif

;endwhile
;close,roro
;endif


label:err2=string('no such file has been found')




;--------- INITIALISATION -----------
common tablo2,tabb2
tabb2=strarr(701)
;------------------------------------



;--------------------------- FILL GRILLE.PRO WITH THE OPENED FILE ------------


for i=1,cpt do begin
  tabb[i]        =strtrim(string(po[i]),2)	;position
  tabb[i+100]    =strtrim(string(pa(po[i])),2)	;par sub
  tabb[po[i]+600]=strtrim(string(pa(po[i])),2)	;par sub for keeping (order in rack)
  tabb[i+200]    =strtrim(string(ru[i]),2)	;value of preset
  tabb[i+300]    =strtrim(string(rut[i]),2)	;t/m
  tabb[i+400]    =strtrim(string(re[i]),2)	;repetition
  tabb[i+500]    =strtrim(string(sa[i]),2)	;save
endfor

;----- nb max of samples = 100 ----------
tabb[1081]=100
;----------------------------------------
tabb[1080]=cpt


;ev_event
grille

endif


end


;*************************************************************************************************************************************
;*************************************************************************************************************************************
pro changer_file_gui
;*************************************************************************************************************************************
;*************************************************************************************************************************************

;print, 'start changer_file_gui'
;----------------- DEFINITION OF WIDGETS ---------------------

common basedeb,based0,based1
common basefin,base2d,base3d
common b,b1,b2
common sortie,exit
common newl,newline
common top,changer_based0

IF NOT XREGISTERED('changer_file') then begin
;------------ for new line button in grille.pro------------
newline=0
;----------------------------------------------------------

; print, 'create first widget'
changer_based0=widget_base(title='Changer Command File (1)',/column)

q1=widget_label(changer_based0,frame=5,value='     select one button     ')
q2=widget_label(changer_based0,value='*****')

; print, 'create second widget'

based1=widget_base(changer_based0,/column)
base2d=widget_base(changer_based0,/column)
base3d=widget_base(changer_based0,/column,/align_center)

b1=widget_button(based1,value='   create new file   ')
b2=widget_button(based1,value='   use saved file    ')


;q3=widget_label(base3d,value='*****')
help     =widget_button (base3d,value='  Help  ',frame=2)
;bid      =widget_label  (base3d,value=' ')
exit=widget_button(base3d,value='  close  ')


;--------------------- REALIZE THE WIDGETS ------------------------
; print, 'realize widgets'
widget_control,changer_based0,/realize;  ,/group_leader
; print, 'done'
;------------------------------------------------------------

;-------------------------- EVENTS ----------------------------

widget_control,b1,set_uvalue=[11111,b1]
widget_control,b2,set_uvalue=[11112,b2]
widget_control,help,set_uvalue=[11116]
widget_control,exit,set_uvalue=[11114,exit]


xmanager,'changer_file',changer_based0,/just_reg; ,/group_leader
endif

end



;*********************
FUNCTION dial_changer_file
;*********************
;**
;** The dial initialisation

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='mad'         ;connect to the mad-idl interface
    TYPE='data'           ;when DialNewValue() is used, get the data
    ONOFF=0               ;state of the Dial 1=running
    HISTORY=0             ;=1 to record values in file .his
    DURATION=0            ;if >0 then Dial is stopped after running duration seconds
    WUPDATE=1             ;update corresponding workspace
    FREQUENCY=0.          ;the Dial macro is executed each frequency seconds. 
    			  ;if =0 then the general frequency is used

 return, {init:0,generic:GENERIC}
end


FUNCTION dial_cleardial_send, dummy1,dummy2, text, button
;*******
;**
;** Called from the Pad, generaly to start and stop Dials

Dials=strlowcase(strtrim(str_sep(text(0),'~'),2))

FOR i=0,n_elements(Dials)-1 DO BEGIN
    Dialstop ,Dials(i)
    Dialclear,Dials(i)
ENDFOR

return,0
end
;*********************
PRO dial_d17data_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_d17data

    if D.DIMS(0) eq 0 then begin
	V=DialNewValue(TYPE='t_res')
	D.DIMS(0)=V.par_tof(0)
	D.DIMS(1)=V.par_tof(4) - V.par_tof(3) +1
	D.DIMS(2)=V.par_tof(2) - V.par_tof(1) +1
        print,V.par_tof(0),V.par_tof(1),V.par_tof(2),V.par_tof(3),V.par_tof(4),V.par_tof(5),V.par_tof(6)
	print,"Dimensions:",D.DIMS
	DialInit ,'showx'
	DialStart,'showx' & DialTag,'showx',tag='PATER',set=D.number
 	DialInit ,'showy'
	DialStart,'showy' & DialTag,'showy',tag='PATER',set=D.number
   ENDIF

    V=DialNewValue()

	t=D.DIMS(0) & y=D.DIMS(1) & x=D.DIMS(2)
;        print,'xyt',x,y,t

	V=V(0:x*y*t-1)

	if y eq 1 and t gt 1 then begin 
          ;print,'x t data'         
          V=reform(V,x,t)
          px=total(V,2) & if d.logx eq 1 then px=alog10(px>.1)
          DialTag,'showx',tag='VALUE'    ,set=px
          py=total(V,1) & if d.logy eq 1 then py=alog10(py>.1)
  	  DialTag,'showy',tag='VALUE'    ,set=py
          
        endif

        if t eq 1 and y gt 1 then begin
          V=reform(V,y,x)
          V=transpose(V)
          py=total(V,1) & if d.logy eq 1 then py=alog10(py>.1)
  	  DialTag,'showy',tag='VALUE'    ,set=py
          px=total(V,2) & if d.logx eq 1 then px=alog10(px>.1)
          DialTag,'showx',tag='VALUE'    ,set=px

        endif

        if t eq 1 and y eq 1 then begin
;          print,'only X pixel data'
;          V=reform(V,x)
;          V=transpose(V)
          px=V & if d.logx eq 1 then px=alog10(px>.1)
	  DialTag,'showx',tag='VALUE'    ,set=px
          py=px & if d.logy eq 1 then py=alog10(py>.1)
	  DialTag,'showy',tag='VALUE'    ,set=py
        endif

	 if t gt 1 and x eq 1 then begin
          print,'only Y pixel data'
          V=reform(V,y,t)
          ;V=transpose(V)
          px=total(V,2) & if d.logx eq 1 then px=alog10(px>.1)
	  DialTag,'showx',tag='VALUE'    ,set=px
          py=total(V,1) & if d.logy eq 1 then py=alog10(py>.1)
	  DialTag,'showy',tag='VALUE'    ,set=py
        endif



	;dialWset
	;contour,alog(V>.01),/fill
	if D.logv eq 1 then V=alog10(V>.1)
    DialModValue,V
end



;********************
FUNCTION dial_d17data
;********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='data'      ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=6.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0          ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------
    DIMS=lonarr(3)
    

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,plot:PLOT,DIMS:dims,LOGX:0,LOGY:0,LOGV:1}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_d17data_macro :
;** *************
;** V=DialNewValue([/SETVALUE, COMMENT=txt])   ;Get a new value from DIAL_'generic'_READ
;**                                            (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
	PRO dial_d17status_macro, D
;
; Interactive dynamic display of d17 setup
;						JRS 18/5/00
;
	COMMON c_lamp_font	
	COMMON local, nparams

	nparams=24
	bobfac=1.84

; read in the values

	D.type='motors'   & mall=DialNewValue()
;	D.type='currents' & ball=DialNewValue()
;	D.type='t_para'   & para=DialNewValue()
;	D.type='t_res'    & res=DialNewValue()
;	ball(0:1)=ball(0:1)*bobfac
	param=FLTARR(nparams)
	param(0:23)=mall(0:23)
;	param(5)=mall(6)
;	param(6:10)=ball(0:4)

	stat=DialNewValue(type='status',/SETVALUE)
	stat=STRTRIM(stat,2)
	status='d17 is '+stat
;	numor=STRTRIM(STRING(ROUND(res.numor_to_send)),2)
;	title=STRTRIM(STRING(para.C_TXT),2)
;	subtitle=STRTRIM(STRING(para.SUB_TITLE),2)
;	user=STRTRIM(STRING(para.C_USER),2)
;	lc=STRTRIM(STRING(para.C_LC),2)
;	label1=title+'    User: '+user+'  Local Contact: '+lc
;	label2='Run #'+numor+'   '+subtitle

; initiallise the dial

    	IF  (D.init EQ 0) THEN BEGIN

		D.init=1
		command='mall' & C=DialControl(command)

; initiallise the text fields

		param_text=STRARR(nparams)
		param_text(21) ='collimation'
		param_text(16) ='Detector Angle'
		param_text(2) ='Sample Angle'
		param_text(15) ='Detector Distance'
;		param_text(4) ='Omega'
;		param_text(5) ='Rotation'
;		param_text(6) ='Flip.'
;		param_text(7) ='Corr.'
;		param_text(8) ='Z coils'
;		param_text(9) ='X coils'
;		param_text(10)='Y coils'

print,param_text(21),param(21)
print,param_text(16),param(16)
print,param_text(2),param(2)
print,param_text(15),param(15)

; Set up GUI
;		d17S_BASE_4=Widget_Base(UNAME='d17S_BASE_4',TITLE="d17 Status" $
;			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
;		d17S_BASE_0=Widget_Base(d17S_BASE_4,UNAME='d17S_BASE_0' $
;			,SPACE=3,XPAD=3,YPAD=3,/ROW)
;		d17S_BASE_1=Widget_Base(d17S_BASE_0,UNAME='d17S_BASE_1' $
;			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
;		d17S_LABEL_0=Widget_Label(d17S_BASE_1,UNAME='d17S_LABEL_0' $
;			,VALUE=label1,/ALIGN_CENTER $
;			,SCR_XSIZE=500,FONT=ft_normal)
;		d17S_LABEL_1=Widget_Label(d17S_BASE_1,UNAME='d17S_LABEL_1' $
;			,VALUE=status,/ALIGN_CENTER $
;			,SCR_XSIZE=500,FONT=ft_biggest)
;		d17S_LABEL_2=Widget_Label(d17S_BASE_1,UNAME='d17S_LABEL_2' $
;			,VALUE=label2,/ALIGN_CENTER $
;			,SCR_XSIZE=500,FONT=ft_normal)
;		d17S_DRAW_0=Widget_Draw(d17S_BASE_1,UNAME='d17S_DRAW_0' $
;			,SCR_XSIZE=500,SCR_YSIZE=500)
;		d17S_BASE_2=Widget_Base(d17S_BASE_0,UNAME='d17S_BASE_2' $
;			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
;		d17S_BASE_3=Widget_Base(d17S_BASE_0,UNAME='d17S_BASE_3' $
;			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
;		FOR i=0,nparams-1 DO BEGIN 
;  			name='d17S_LABEL_'+STRTRIM(STRING(i+1),2) 
; 			dummy = Widget_Label(d17S_BASE_2, UNAME=name,XOFFSET=3   $ 
;     	 		,YOFFSET=3, SCR_YSIZE=33,/ALIGN_LEFT ,VALUE=param_text(i) $
;			,FONT=ft_smaller)
;  	  	ENDFOR
;		FOR i=0,nparams-1 DO BEGIN 
;  			name='d17S_VALUE_'+STRTRIM(STRING(i+1),2) 
;  			dummy = Widget_Text(d17S_BASE_3, UNAME=name ,FRAME=1  $ 
;     			,XOFFSET=3 ,YOFFSET=3 ,SCR_XSIZE=100 ,SCR_YSIZE=29 $
;			,/EDITABLE ,VALUE=STRTRIM(STRING(param(i)),2) $
;			,FONT=ft_smaller) 
;  	  	ENDFOR


;		Widget_Control,/REALIZE,d17S_BASE_3
;		Widget_Control,d17S_DRAW_0,GET_VALUE=win_id
;		D.mywin=win_id
;		D.head0=d17S_LABEL_0
;		D.head1=d17S_LABEL_1
;		D.head2=d17S_LABEL_2
;		loadct, 5
;		XMANAGER, 'dial_d17status_macro',d17S_BASE_0,/JUST_REG

    	ENDIF

; update headers

;	Widget_Control,D.head0,SET_VALUE=label1	
;	Widget_Control,D.head1,SET_VALUE=status
;	Widget_Control,D.head2,SET_VALUE=label2

; reinspect parameters

        IF(TOTAL(D.ang) EQ TOTAL(param)) THEN GOTO, finished

	ang=param(0:3)*!pi/180
	omega=param(4)*!pi/180
	rotation=param(5)*!pi/180

; offset on bank2
	ang(1)=ang(1)+0.14

; Setup diagram

	WSET, D.mywin
	box1x=[1.5,1.5,1.3,1.3,1.5]
	box1y=[-0.05,.05,0.05,-0.05,-0.05]
;	box2x=[-0.3,-0.3,0.3,0.3,-0.3]
;	box2y=[0.45,0.55,0.55,0.45,0.45]
;	box3x=[-0.1,0.1,0.1,-0.1,-0.1]
;	box3y=[1.2,1.2,0.8,0.8,1.2]
;	flipx=-0.1+FINDGEN(15)/75.
;	flipy=[0.57,0.77]
	circle=INDGEN(200)*2*!pi/180.
	rcirc=FLTARR(200)+0.1
	PLOT,rcirc,circle,/POLAR,BACKGROUND=255,COLOR=100,XMARGIN=[3,3] $
		,YMARGIN=[1,1],XRANGE=[-1.5,1.5],YRANGE=[-1.5,1.5],XSTY=4,YSTY=4
	OPLOT,box1x,box1y,COLOR=1
;	OPLOT,box2x,box2y,COLOR=1

	r1=0.6
	r2=1.5
	r1arc=FLTARR(100)+r1
	r2arc=FLTARR(100)+r2
;	arc=INDGEN(100)*2*seg/100.
	r=[10,0,0,0]
        ppmm=1.5/3400.
        OPLOT,[-1.5,1.5],[0,0],/POLAR,COLOR=0
;	OPLOT,[-1.3,0],[param(21)*!pi/180.,param(21)*!pi/180.],/POLAR,COLOR=18
        dan=(param(16)+180)*!pi/180.
        san=(param(2)*2+180)*!pi/180.
        det=param(15)*ppmm
        
        OPLOT,[0,det],[dan,dan],/POLAR,COLOR=20
        OPLOT,[0,det],[san,san],/POLAR,COLOR=25
        xdet=211.
        xo=param(15)*tan(param(16)*!pi/180.)
        xr=param(15)*tan(2*param(2)*!pi/180.)

        if xo lt xdet/2. and xo gt -xdet/2. then begin
           OPLOT,[sqrt(det^2+(xdet*ppmm/2)^2),sqrt(det^2+(xdet*ppmm/2)^2)],[dan+atan(xdet*ppmm/(2*det)),dan-atan(xdet*ppmm/(2*det))],/POLAR,COLOR=20
           db=1
        endif else begin
           OPLOT,[sqrt(det^2+(xdet*ppmm/2)^2),sqrt(det^2+(xdet*ppmm/2)^2)],[dan+atan(xdet*ppmm/(2*det)),dan-atan(xdet*ppmm/(det*2))],/POLAR,COLOR=21
           db=0
        endelse

        if san lt dan+atan(xdet*ppmm/(2*det)) and san gt dan-atan(xdet*ppmm/(2*det)) then begin
           rb=1
        endif else begin
           rb=0
        endelse







        detl=1.6
        detd=0.5
        
        

; Annotations
	

	!P.FONT=0

	DEVICE,FONT=ft_smaller

	XYOUTS,0.15,0.70,'Collimation angle: '+STRTRIM(STRING(param(21)),2)+' deg.',COLOR=0,ALIGNMENT=0
        XYOUTS,0.15,0.80,'Sample angle:       '+STRTRIM(STRING(param(2)),2)+' deg.',COLOR=0 ,ALIGNMENT=0
        XYOUTS,0.15,0.90,'Detector angle:     '+STRTRIM(STRING(param(16)),2)+' deg.',COLOR=0 ,ALIGNMENT=0
        XYOUTS,0.15,1.00,'Detector distance: '+STRTRIM(STRING(param(15)),2)+' mm',COLOR=0 ,ALIGNMENT=0

        if db eq 1 then begin
          XYOUTS,0.15,1.10,'Direct beam is ON the detector',COLOR=1 ,ALIGNMENT=0
        endif else begin
          XYOUTS,0.15,1.10,'Direct beam is OFF the detector ',COLOR=0 ,ALIGNMENT=0 
        endelse

        if rb eq 1 then begin
          XYOUTS,0.15,1.20,'Reflected beam is ON the detector',COLOR=1 ,ALIGNMENT=0
        endif else begin
          XYOUTS,0.15,1.20,'Reflected beam is OFF the detector ',COLOR=0 ,ALIGNMENT=0 
        endelse


	D.ang=param
finished:	
	END

;pro dial_d17status_macro_event, event
;** ************
;**
;	COMMON local
;
;	WIDGET_CONTROL,event.id,bad_id=ii
;	IF (ii NE 0) THEN BEGIN 
;		D.init=0
;		DialStop 
;		RETURN
;	ENDIF
;
;      	wWidget =  Event.top
;
;     	FOR i=1,nparams DO BEGIN
;      	name='d17S_VALUE_'+STRTRIM(STRING(i),2)
;      	IF (Event.id EQ WIDGET_INFO(wWidget, FIND_BY_UNAME=name)) THEN $
;      	    IF (TAG_NAMES(Event, /STRUCTURE_NAME) EQ 'WIDGET_TEXT_CH' ) THEN $
;      	    	send_command, event,i
;      	ENDFOR
;	
;
;end
;pro send_command, event,i
;** ************
;**
;	Widget_Control, event.id, GET_VALUE=gv
;	gv=STRTRIM(gv,2)
;	IF(i LE 4) THEN command='bank'+STRTRIM(STRING(i),2)+' '+gv
;	IF(i EQ 5) THEN command='omega'+' '+gv 
;	IF(i EQ 6) THEN command='rotation'+' '+gv
;	IF((i GT 6) AND (i LE 11)) THEN command='b'+STRTRIM(STRING(i-6),2)+' '+gv  
;	print, command
;	;C=DialControl(command)
;	C=Dial_mad_send('',0,command)
;end
function dial_d17status
;******* ***********
;**

    return, {NAME:'d17status',GENERIC:'mad',TYPE:'log',VALUE:'',FREQUENCY:1,$
	     INIT:0L,MYWIN:0,ANG:FLTARR(24),HEAD1:0L,HEAD0:0L,$
	     HEAD2:0L}
    end
; written by Roland May, August 2001
; modifications to also run it on D11 by Roland May, October 2001

;**************************
;HOW TO RUN THIS DIAL:
;------------------------
;START idl THEN ENTER:  
;Idl>.run dial_d22centre
;Idl> d22centre    
;**************************


pro d22centre
;** *********
;Used to run with "byGeorge"
FORWARD_FUNCTION DialControl, DialNewValue, DialOn
if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

dial_bygeorge,'d22centre'	;<-------- Name of the Dial !!!
END				;         ~~~~~~~~~~~~~~~~~ !!!



pro d22centre_gui_event, ev
;** *******************
;**

widget_control,ev.id,get_uvalue=uv

print,'dial_d22centre widget # ',uv(0)


case uv(0) of

1:begin	

;****************************************
;* CALCULATE CENTRE FROM DATA OR RUN	*
;****************************************

;print, "uv: ", uv
	widget_control,uv(1),get_value=larun 
	numor=larun(0)
;print, "numor: ",numor	

	widget_control,uv(2),get_uvalue=bex & bex=bex(0)
;print, "bex: ", bex
	choice=bex(0)
;print, "choice: ", choice
;	choice=2	

	widget_control,uv(3),get_value=lx0c 
;print, "lx0c: ", lx0c

	machine=strlowcase(getenv("HOST"))
	;print,"Instrument: ",machine
	id=strpos(machine,".")
	if id gt 0 then machine=strmid(machine,0,id)
	;print,"Instrument: ",machine

	if ((numor le 0) or (choice eq 1)) then begin
		V  =DialNewValue(TYPE='data',NAME='d22centre',/SETVALUE)
		V1 =DialNewValue(TYPE='t_nother',NAME='d22centre')
	  if machine eq 'd22' then begin
	 	dtr =V1.actang(1)	;*	detector offset		*
	 	dan =V1.actang(2)	;*	detector angle		*
	  endif else if machine eq 'd11' then begin
		dtr=0.
		dan=0.
	  endif
	endif else begin
	  if machine eq 'd22' then begin
		rdset,inst='D22',base='d22' & rdp=1 & V=rdrun(numor,datp=rdp)
		dan=rdp.p(18)
		dtr=rdp.p(19)
	  endif else if machine eq 'd11' then begin
		rdset,inst='D11',base='d11' & rdp=1 & V=rdrun(numor,datp=rdp)
		dan=0.
		dtr=0.
	  endif
	endelse
;print, dtr, dan
	
;*	FIND CENTRE OF GRAVITY (OF DIRECT-BEAM RUN).
; first round, rough centre
	Xsum    =TOTAL(V,2)     &  idx  =FINDGEN (n_elements(Xsum))
	Ysum    =TOTAL(V,1)     &  idy  =FINDGEN (n_elements(Ysum))
	Sumt=TOTAL(V)
	Sum1=TOTAL(Xsum)
	Xgravity=TOTAL(Xsum*idx)/Sum1
	Xgravity=fix(100.*(Xgravity+0.005))
	Xgravity=float(Xgravity)/100.
	Sum2=TOTAL(Ysum)
	Ygravity=TOTAL(Ysum*idy)/Sum2
	Ygravity=fix(100.*(Ygravity+0.005))
	Ygravity=float(Ygravity)/100.
print, "calulated centre (1): X0= ",Xgravity,"; Y0= ", Ygravity
print, "Sum of counts on detector: ",Sumt
print, "Sums over X and Y(1): X   ",Sum1,"; Y   ", Sum2
;second round
	myarr=lonarr(2)
	myarr(0)=0
	myarr(1)=fix(Xgravity-7.5)
	minx=max(myarr,i)
	minx=i
	if machine eq 'd22' then begin
	  myarr(0)=127
	  myarr(1)=fix(Xgravity+8.5)
	  maxx=min(myarr,i)
	  myarr(0)=0
	  myarr(1)=fix(Ygravity-7.5)
	  miny=max(myarr,i)
	  myarr(0)=127
	  myarr(1)=fix(Ygravity+8.5)
	  maxy=min(myarr,i)
	  Xsum=TOTAL(V(0:127,miny:maxy),2) & idx  =FINDGEN (n_elements(Xsum))
	  Ysum=TOTAL(V(minx:maxx,0:127),1) & idy  =FINDGEN (n_elements(Ysum))
	endif else if machine eq 'd11' then begin
	  myarr(0)=63
	  myarr(1)=fix(Xgravity+8.5)
	  maxx=min(myarr,i)
	  myarr(0)=0
	  myarr(1)=fix(Ygravity-7.5)
	  miny=max(myarr,i)
	  myarr(0)=63
	  myarr(1)=fix(Ygravity+8.5)
	  maxy=min(myarr,i)
	  Xsum=TOTAL(V(0:63,miny:maxy),2) & idx  =FINDGEN (n_elements(Xsum))
	  Ysum=TOTAL(V(minx:maxx,0:63),1) & idy  =FINDGEN (n_elements(Ysum))
	endif
	Sum1=TOTAL(Xsum(minx:maxx))
	Xgravity=TOTAL(Xsum(minx:maxx)*idx(minx:maxx))/Sum1
	Xgravity=fix(100.*(Xgravity+0.005))
	Xgravity=float(Xgravity)/100.
	Sum2=TOTAL(Ysum(miny:maxy))
	Sumc=TOTAL(V(minx:maxx,miny:maxy))
	Ygravity=TOTAL(Ysum(miny:maxy)*idx(miny:maxy))/Sum2
	Ygravity=fix(100.*(Ygravity+0.005))
	Ygravity=float(Ygravity)/100.
	X0S=STRMID(STRTRIM(Xgravity,2),0,5)
	Y0S=STRMID(STRTRIM(Ygravity,2),0,5)

print, "calulated centre (2): X0= ",X0S,"; Y0= ", Y0S
print, "Sums over X and Y(2): X   ",Sum1,"; Y   ", Sum2
print, "Sum around centre: ",Sumc

	widget_control,uv(3),set_value=X0S
	widget_control,uv(4),set_value=Y0S
		
	if machine eq 'd22' then begin
	  BXOFFSET=-3
	  BYOFFSET=0
	  BX	=FIX((Xgravity-63.5)*7.5+dtr+0.5)+BXOFFSET
	  BY	=FIX((Ygravity-63.5)*7.5+0.5)+BYOFFSET
	endif else if machine eq 'd11' then begin
	  BXOFFSET=0
	  BYOFFSET=0
	  BX	=FIX((Xgravity-31.5)*10.+dtr+0.5)+BXOFFSET
	  BY	=FIX((Ygravity-31.5)*10.+0.5)+BYOFFSET
	endif
	BXS	=STRTRIM(BX,2)	
	BYS	=STRTRIM(BY,2)	
print, "calculated beamstop: BX= ",BXS,"; BY= ", BYS

	widget_control,uv(5),set_value=BXS
	widget_control,uv(6),set_value=BYS

	widget_control,uv(7),set_value=strtrim(long(Sumt),2)
	widget_control,uv(8),set_value=strtrim(long(Sumc),2)

	widget_control,uv(9),set_value=''; erase message
end

2:begin 

;****************************************
;*         GET DATA/RUN CHOICE		*
;****************************************

;print, "uv: ", uv
	widget_control,uv(2),get_uvalue=bex			
;print, "bex: ", bex
	bex(0)=uv(1)				
	widget_control,uv(2),set_uvalue=bex
;print, "bex: ", bex
	choice=fix(bex(0))
	print, "data/run = ", choice

end

3:begin

;****************************************
;*           GET RUN NUMBER		*
;****************************************

	widget_control,ev.id,get_value=laruns & laruns=laruns(0)		
	ok=0								
	on_ioerror,missdd
	larun=long(laruns)
	numor=long(laruns)
print, "numor : ", numor
	ok=1
	missdd: if not ok then widget_control,uv(2),$
		set_value='Type conversion error' $
                else widget_control,uv(2),set_value=''

end

4:begin

;****************************************
;*           GET X0			*
;****************************************

	widget_control,ev.id,get_value=lax0cs & lax0c=lax0cs(0)		
	ok=0								
	on_ioerror,misx0c
	lax0c=float(lax0cs)
	nx0c=float(lax0cs)
;	print, "x0c : ", nx0c
	ok=1
	misx0c: if not ok then widget_control,uv(2),$
		  set_value='Type conversion error' $
                else widget_control,uv(2),set_value=''

end

5:begin

;****************************************
;*           GET Y0			*
;****************************************

	widget_control,ev.id,get_value=lay0cs & lay0c=lay0cs(0)		
	ok=0								
	on_ioerror,misy0c
	lay0c=float(lay0cs)
	ny0c=float(lay0cs)
;	print, "x0c : ", ny0c
	ok=1
	misy0c: if not ok then widget_control,uv(2),$
		  set_value='Type conversion error' $
		else widget_control,uv(2),set_value=''

end

6:begin

;****************************************
;*           GET BX			*
;****************************************

	widget_control,ev.id,get_value=labxs & labx=float(labxs(0))		
	ok=0								
	on_ioerror,misbx
;	lax0c=float(lax0cs)
	nbx=float(lax0cs)
	print, "bxc : ", nbx
	ok=1
	misbx:	if not ok then widget_control,uv(2),$
		  set_value='Type conversion error' $
		else widget_control,uv(2),set_value=''

end

7:begin
		
;****************************************
;*           GET BY			*
;****************************************

	widget_control,ev.id,get_value=labys & laby=float(labys(0))		
	ok=0								
	on_ioerror,misby
;	laby=float(labys)
	nby=float(labys)
	print, "byc : ", nby
	ok=1
	misby:	if not ok then widget_control,uv(2),$
		  set_value='Type conversion error' $
		else widget_control,uv(2),set_value=''

end

8:begin
 
;****************************************
;*      SEND CENTRE VALUES TO MAD	*
;****************************************

;print, "uv: ", uv
	widget_control,uv(1),get_value=lax0cs & lax0c=lax0cs(0)			
;print, "x0c: ", lax0c
	x0s=strtrim(lax0c,2)				
	widget_control,uv(2),get_value=lay0cs & lay0c=lay0cs(0)			
;print, "y0c: ", lay0c
	y0s=strtrim(lay0c,2)				
	txt='par centre '+X0S+' '+Y0S
	print, txt
;	R =Dialcontrol (txt,check=.5,NAME='d22centre')
	R =Dialcontrol (txt,NAME='d22centre')

end

9:begin 

;****************************************
;*      SEND BEAMSTOP VALUES TO MAD	*
;****************************************

;print, "uv: ", uv

	widget_control,uv(1),get_value=lax0cs & lax0c=lax0cs(0)			
	x0s=strtrim(lax0c,2)				
	widget_control,uv(2),get_value=lay0cs & lay0c=lay0cs(0)			
	y0s=strtrim(lay0c,2)				
	txt='BX '+X0S+' BY '+Y0S
	print, txt
;	R =Dialcontrol (txt,check=.5,NAME='d22centre')
	R =Dialcontrol (txt,NAME='d22centre')

end

12:begin 

;****************************************
;*      REFRESH MAD CENTRE VALUES	*
;****************************************

	para	=DialNewValue(TYPE='t_para',NAME='d22centre')
	X0      =para.x0
	Y0      =para.y0
print, "X0: ", X0, "   Y0: ", Y0
	X0tr	=strtrim(X0,2)
	Y0tr	=strtrim(Y0,2)
print, "X0tr: ", X0tr, "   Y0tr: ", Y0tr
	widget_control,uv(1),set_value=X0tr			
	widget_control,uv(2),set_value=Y0tr			
	V1 =DialNewValue(TYPE='t_nother',NAME='d22centre')
	BX  =V1.actang(3)
	BY  =V1.actang(4)
	BXM=strmid(strtrim(string(BX),2),0,5)
	BYM=strmid(strtrim(string(BY),2),0,5)
	widget_control,uv(3),set_value=BXM			
	widget_control,uv(4),set_value=BYM			

end

13:begin

;****************************************
;*	EXIT BUTTON			*
;****************************************

	widget_control,ev.top,/destroy
	DialClear, 'd22centre'

end

14:begin

;****************************************
;*           MINUS BUTTON		*
;****************************************

	widget_control,uv(1),get_value=laruns 
	numor=long(laruns(0))-1
print, "numor : ", numor
	laruns=strtrim(string(numor),2)
	widget_control,uv(1),set_value=laruns 

end


15:begin

;****************************************
;*           PLUS BUTTON		*
;****************************************

	widget_control,uv(1),get_value=laruns 
	numor=long(laruns(0))+1
print, "numor : ", numor
	laruns=strtrim(string(numor),2)
	widget_control,uv(1),set_value=laruns 

end

else:
; **************************************
endcase

end

;**************

pro d22centre_gui, para
;** *************
;**

if xregistered('d22centre_gui') eq 0 then begin
										
	para=DialNewValue(TYPE='t_para',NAME='d22centre')
;help, para, /struc
	X0      =para.x0
	Y0      =para.y0
	X0M=strmid(strtrim(string(X0),2),0,5)
	Y0M=strmid(strtrim(string(Y0),2),0,5)

	V1 =DialNewValue(TYPE='t_nother',NAME='d22centre')
	BX  =V1.actang(3)
	BY  =V1.actang(4)
	BXM=strmid(strtrim(string(BX),2),0,5)
	BYM=strmid(strtrim(string(BY),2),0,5)
	X0S	=''
	Y0S	=''
	BXS	=''
	BYS	=''

base=widget_base(title='BEAM CENTRE',/COLUMN,resource_name='geo')

;******************************************************************************	
										
base0  =widget_base  (base   ,/column,frame=5);,resource_name='lamp')		
 
base01	=widget_base  (base0 ,/row)
labvide	=widget_label (base01,value='      MAD centre values:       X0 = ')
lax0M	=widget_label (base01,value='')
txx0M   =widget_text  (base01,value=X0M,xsize=4,ysize=1)
labvide	=widget_label (base01,value='Y0 = ')
lay0M	=widget_label (base01,value='')
txy0M	=widget_text  (base01,value=Y0M,xsize=4,ysize=1)
base02	=widget_base  (base0 ,/row)
labvide	=widget_label (base02,value='      MAD beamstop values: BX = ')
labxM	=widget_label (base02,value='')
txbxM   =widget_text  (base02,value=BXM,xsize=4,ysize=1)
labvide	=widget_label (base02,value='BY = ')
labyM	=widget_label (base02,value='')
txbyM	=widget_text  (base02,value=BYM,xsize=4,ysize=1)
base03	=widget_base  (base0 ,/row)
bid	=widget_label (base03,$
	value='                                              ')
refresh	=widget_button(base03 ,value='Refresh',frame=5,resource_name='lamp')

base1  =widget_base  (base   ,/column,frame=5);,resource_name='lamp')		
mesg   =widget_label (base1,value=string(''),/dynamic_resize,$
	resource_name='lamp')

widget_control,txx0M,set_uvalue 	=[10,txx0M]
widget_control,txy0M,set_uvalue 	=[11,txy0M]
widget_control,refresh,set_uvalue	=[12,txx0M,txy0M,txbxM,txbyM]

base12 =widget_base  (base1  ,/row)
bid    =widget_label (base12 ,value='     ')
calcul =widget_button(base12 ,value='Calculate centre',uvalue=1,frame=5,$
	resource_name='lamp')
bid    =widget_label (base12 ,value=' from ')
set    =lonarr(3)
excl   =widget_base  (base12,/exclusive,/row)
set(1) =widget_button(excl,value=' data' ,  /no_release,uvalue=[2,1,excl])
set(2) =widget_button(excl,value=' run #',  /no_release,uvalue=[2,2,excl])
larun  =widget_label (base12,value='')
minus  =widget_button(base12 ,value='-',uvalue=14,frame=5,resource_name='lamp')
txrun  =widget_text  (base12,value='0',/editable,frame=5,xsize=5,uvalue=3,$
	resource_name='lamp')
plus   =widget_button(base12 ,value='+',uvalue=15,frame=5,resource_name='lamp')

widget_control,set(1),/set_button
widget_control,excl,set_uvalue=[2,set]
widget_control,txrun,set_uvalue=[3,txrun,mesg]
widget_control,minus,set_uvalue=[14,txrun]
widget_control,plus,set_uvalue=[15,txrun]

base17	=widget_base  (base1 ,/row)
lasumt	=widget_label (base17,value='      Counts on detector: ')
txsumt	=widget_text  (base17,value=' ',xsize=6,ysize=1)
lasumc	=widget_label (base17,value=' around centre: ')
txsumc	=widget_text  (base17,value=' ',xsize=6,ysize=1)

base13	=widget_base  (base1 ,/row)
labvide	=widget_label (base13,value='      calculated values: ')
lax0c	=widget_label (base13,value='X0 = ')
txx0c	=widget_text  (base13,value=+strtrim(X0S,2),frame=5,xsize=4,ysize=1,$
	/editable)
lay0c	=widget_label (base13,value='Y0 = ')
txy0c	=widget_text  (base13,value=+strtrim(Y0S,2),frame=5,xsize=4,ysize=1,$
	/editable)
bid	=widget_label (base13,value=' (editable)')

base14	=widget_base  (base1 ,/row)
labv	=widget_label (base14,value='      beamstop values: ')
labx	=widget_label (base14,value='BX = ')
txbx	=widget_text  (base14,value=+strtrim(BXS,2),frame=5,xsize=4,ysize=1,$
	/editable)
laby	=widget_label (base14,value='BY = ')
txby	=widget_text  (base14,value=+strtrim(BYS,2),frame=5,xsize=4,ysize=1,$
	/editable)
bid	=widget_label (base14,value=' (editable)')

widget_control,txx0c,set_uvalue =[4,txx0c,mesg]
widget_control,txy0c,set_uvalue =[5,txy0c,mesg]
widget_control,txbx,set_uvalue  =[6,txbx,mesg]
widget_control,txby,set_uvalue  =[7,txby,mesg]
widget_control,calcul,set_uvalue=[1,txrun,excl,txx0c,txy0c,txbx,txby,$
	txsumt,txsumc,mesg]

base15	=widget_base  (base1 ,/row)
bid	=widget_label (base15 ,value='     ')
censet	=widget_button(base15 ,value='Send centre values to MAD',uvalue=1,$
	frame=5,resource_name='lamp')
bid	=widget_label (base15 ,value='     ')
beamset	=widget_button(base15 ,value='  Set beamstop with MAD  ',uvalue=1,$
	frame=5,resource_name='lamp')

widget_control,censet,set_uvalue =[8,txx0c,txy0c]
widget_control,beamset,set_uvalue=[9,txbx,txby]

base16	=widget_base  (base1 ,/row)
bid	=widget_label (base16,$
	value='                                              ')
exit	=widget_button(base16,value='     Exit     ',uvalue=[13],frame=5,$
	resource_name='lamp')

widget_control,base,/realize

xmanager,'d22centre_gui',base,/just_reg

endif
end

;*********************
PRO dial_d22centre_macro, D, Lim, para
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function 
;** dial_d22centre

print, " "
print, "********************"
print, "dial_d22centre_macro"

if D.init eq 0 then begin
;	print, "init was 0"
	D.init=1
	D.frequency=0.
	Lim=DialNewValue(type='limits')
	para=DialNewValue(type='t_para')
;help, para, /struc
	d22centre_gui, para

endif else begin
;	print,'init was 1'
endelse

end


;*********************
FUNCTION dial_d22centre
;*********************
;**
;** The dial initialisation

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='mad'         ;connect to the mad-idl interface
    TYPE='data'           ;when DialNewValue() is used, get the data
    ONOFF=0               ;state of the Dial 1=running
    VALUE=fltarr(128,128) ;value you assign to the Dial. 
                          ;This value is automaticaly plotted. 
			  ;put errors in ERROR var.
;   PLOT=0                ;-2=no plot 0=image 1=surface 2=contour 
                          ;n>2 means show vector of last n values of the scalar
;   UPPERLIM=0.           ;upper limit of a 1dim. plot (LOWERLIM for lower)
    HISTORY=0             ;=1 to record values in file .his
    DURATION=0            ;if >0 then Dial is stopped after "duration" seconds
    WUPDATE=1             ;update corresponding workspace
    FREQUENCY=0.          ;the Dial macro is executed each frequency seconds. 
    			  ;if =0 then the general frequency is used

   ;User Variables (Must be present in return statement)
   ;--------------
;    LOG =0	 ;  Detectors  not in log.
;    DLOG=0	 ;  Diagram    not in log.
;    NUMOR_sim=0L ;Used for simulation
;    NUMOR_cal=0L ;Used for calibration numor
;    WATER=0	 ;Used for calibration data
;    DIAGUPD=0	 ;1:Diagram may be updated

;return, {generic:GENERIC,type:TYPE,value:VALUE,FREQUENCY:FREQUENCY] ;,$
;         PLOT:PLOT,init:0,log:LOG,dlog:DLOG,tof:0L,channel:1L,$
;         xcenter:0.,ycenter:0.,diagupd:DIAGUPD,$
;	 numor_sim:NUMOR_sim,numor_cal:NUMOR_cal,water:WATER}
return, {init:0}
end
;*********************
PRO dial_d22data_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_d22data

;***RESETING DIAL (OR FIRST CALL).
	IF D.init eq 0 then begin D.init=1

;**	   CHECK FOR INSTRUMENT CONFIGURATION.
	   IF D.numor_sim le 0 then begin
	      para  =DialNewValue(TYPE='t_para')
	      nother=DialNewValue(TYPE='t_nother')
	      D.dist_wave(0)=nother.actang(0)*100.
	      D.dist_wave(1)=nother.act_wave
	      D.tof     =para.tof
	      D.channel =para.tof_cha_resol
	      V         =DialNewValue(TYPE='data')
	      
	   ENDIF else begin rdset,inst='D22',base='d22' & V=rdrun(D.numor_sim)
	   ENDELSE  ; Simulation
	   
	   IF D.numor_cal gt 0 then begin
	      rdset,inst='D22',base='d22' & W= rdrun(D.numor_cal) + 1
	      mean= TOTAL(W)/n_elements(W)
	      W   = mean /W  & DialModValue,W, TAG='WATER'
	   ENDIF
	   
;*	   NORMAL ACQUISITION.
	   IF D.tof eq 0 then begin
	    DialModValue,V
	    DialInit ,'diagram'
	    DialStop ,'diagram' & DialTag,'diagram',tag='PATER',set=D.number
	    DialInit ,'showx'
	    DialStart,'showx'   & DialTag,'showx'  ,tag='PATER',set=D.number
 	    DialInit ,'showy'
	    DialStart,'showy'   & DialTag,'showy'  ,tag='PATER',set=D.number

;*	    FIND GRAVITY CENTER.
		Xsum    =TOTAL(V,2)     &  idx  =FINDGEN (n_elements(Xsum))+1
		Ysum    =TOTAL(V,1)     &  idy  =FINDGEN (n_elements(Ysum))+1
		Xsum    =Xsum-MIN(Xsum) &  Ysum =Ysum-MIN(Ysum)
		Xsum(WHERE(Xsum LE MAX(Xsum)/2))=0.
		Ysum(WHERE(Ysum LE MAX(Ysum)/2))=0.
		Xgravity=TOTAL(Xsum*idx)/TOTAL(Xsum)
		Ygravity=TOTAL(Ysum*idy)/TOTAL(Ysum)
		D.Xcenter =(Xgravity)-1
		D.Ycenter =(Ygravity)-1
	   ENDIF ELSE $

;**	   TIME OF FLIGHT ACQUISITION.
	   IF D.tof eq 4 then begin
	              DialModValue,TOTAL(TOTAL(V,1),2)

	   ENDIF ELSE DialModValue,'TOF='+string(D.tof)

	ENDIF ;(D.init)

;***GET DATA FROM MAD.
	IF D.numor_sim eq 0 then V =DialNewValue(TYPE='data') $
	                    else V =rdrun(D.numor_sim)
			       ; V =V+1
	IF D.numor_cal gt 0 then $
	   if n_elements(V) eq n_elements(D.WATER) then V=V * D.WATER

;***UPDATE PROJECTION DIALS.
	IF D.tof eq 0 then begin
	   px=TOTAL(V,2) & if D.xlog eq 1 then px=alog(px>.1)
	   py=TOTAL(V,1) & if D.ylog eq 1 then py=alog(py>.1)
	   DialTag,'showx',tag='VALUE',set=px
	   DialTag,'showy',tag='VALUE',set=py
	ENDIF

;***UPDATE RADIAL INTEGRATION.
	IF D.tof eq 0 then begin onoff=0
	  DialTag,'diagram',tag='ONOFF', get=onoff
	  if (onoff) then begin
;**	   MASK THE CENTER ON IMAGE.
	   S  =SIZE (V)
	   a0 =ROUND(D.Xcenter)  &  b0=ROUND(D.Ycenter)
	   a1 =(a0-D.Xmask/2)<(S(1)-1)>0 & a2=(a0+D.Xmask/2)<(S(1)-1)>0
	   b1 =(b0-D.Ymask/2)<(S(2)-1)>0 & b2=(b0+D.Ymask/2)<(S(2)-1)>0
	   ray=max([a0+1,b0+1,(S(1)-a0),(S(2)-b0)])

	   if (a1 ne a2) and (b1 ne b2) then V(a1:a2,b1:b2)=-1

;**	   DO THE WORK.
	   D.diagupd=D.diagupd+D.frequency ;(cpu moderator)
	   IF D.diagupd gt 0 then begin
	      D.vmask=D.vmask*0
	      D.vmask(*,0)=1 & D.vmask(*,s(2)-1)=1 & D.vmask(0,*)=1
	      if (a1 ne a2) and (b1 ne b2) then D.vmask(a1:a2,b1:b2)=1
	      RADIAL_AT, V, CENTER=[D.Xcenter,D.Ycenter], INCR=1., $
	                 DIAG=diam, X=xdiam, MASK=D.vmask, ERROR=error
	     ;DECOR, D.Xcenter+1,D.Ycenter+1, 0.,360., D.dist_wave(0)>1
	     ;DEPLI, V,max([D.Xmask,D.Ymask]),ray,arel,diam,xdiam
	      ytit='I'
	      if D.dlog eq 1 then begin diam=alog(diam>.1) & ytit='logn(I)'
	      	 error=(alog((diam+error)>.001)-alog((diam+error)>.001))/2.
	      endif
	      theta =ATAN(xdiam*0.75  ,D.dist_wave(0))/2.
	      Q     =4.*!pi*SIN(theta)/D.dist_wave(1)
	      DialTag,'diagram',tag= 'VALUE'   ,set=diam
	      DialTag,'diagram',tag='XVALUE'   ,set=Q
	      DialTag,'diagram',tag= 'ERROR'   ,set=error
	      DialTag,'diagram',tag= 'Y_TIT'   ,set=ytit
	      DialTag,'diagram',tag= 'X_TIT'   ,set='Q'
	   endif

;**	   MARK CENTER CROSS-HAIR.
	   IF D.plot  eq 0 then begin
		avg=-1
		a1 =0 &  a2=S(1)-1   & b1=0 & b2=S(2)-1
		a0 =a0*((a0 ge 0) and (a0 lt S(1)))
		b0 =b0*((b0 ge 0) and (b0 lt S(2)))
 		IF a0 gt 0 then V(a0,b1:b2)=avg
		IF b0 gt 0 then V(a1:a2,b0)=avg
	   ENDIF
	  ENDIF
	ENDIF
;***UPDATE VALUE OF CURRENT DIAL.
	IF (D.tof eq 0) or (D.TOF eq 4) then begin
	   IF D.tof eq 4 then V =TOTAL(TOTAL(V,1),2)
	   IF D.log eq 1 then D.value= ALOG(V>1) ELSE $
	   IF D.log eq 2 then D.value= SQRT(V>0) ELSE $
	                      D.value=      V
	ENDIF
end



;*********************
FUNCTION dial_d22data
;*********************
;**
;** The dial initialisation

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='data'      ;when DialNewValue() is used, get the data
    ONOFF=0          ;state of the Dial 1=running
    VALUE=fltarr(128,128) ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 0=image 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=0.      ;upper limit of a 1dim. plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds
    WUPDATE=1        ;update corresponding workspace
    FREQUENCY=7.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used

   ;User Variables (Must be present in return statement)
   ;--------------
    LOG =0	 ;  Detectors  not in log.
    DLOG=0	 ;  Diagram    not in log.
    XLOG=0	 ;X projection not in log.
    YLOG=0	 ;Y projection not in log.
    NUMOR_sim=0L ;Used for simulation
    NUMOR_cal=0L ;Used for calibration numor
    WATER=0	 ;Used for calibration data
    XMASK=12	 ;X size of mask
    YMASK=15	 ;Y size of mask
    VMASK=VALUE	 ;matrix containing the mask (1's)
    DIAGUPD=0	 ;1:Diagram may be updated
    DIST_WAVE=[400.,5.] ;Detector distance & wavelength

return, {generic:GENERIC,value:VALUE,FREQUENCY:FREQUENCY,vmask:VMASK,$
         PLOT:PLOT,init:0,log:LOG,xlog:XLOG,ylog:YLOG,dlog:DLOG,tof:0L,channel:1L,$
         xcenter:0.,ycenter:0.,xmask:XMASK,ymask:YMASK,diagupd:DIAGUPD,$
	 dist_wave:DIST_WAVE,numor_sim:NUMOR_sim,numor_cal:NUMOR_cal,water:WATER}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_d22data_macro :
;** *************
;** V=DialNewValue([/SETVALUE, COMMENT=txt])   ;Get a new value from DIAL_'generic'_READ
;**                                            (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;**************************
;HOW TO RUN THIS DIAL !!!
;------------------------
;START idl THEN ENTER:  
;Idl>.run dial_d22kin
;Idl> d22kin    
;**************************


pro d22kin
;** *********
;Used to run with "byGeorge"
FORWARD_FUNCTION DialControl, DialNewValue, DialOn
if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

dial_bygeorge,'d22kin'   ;<-------- Name of your Dial !!!
END                      ;          ~~~~~~~~~~~~~~~~~ !!!



pro d22kin_gui_event,ev
;** ************
;**

widget_control,ev.id,get_uvalue=uv
case uv(0) of

;*****CONSTANT*****
1:begin call_procedure,'d22kin_const'

  end

;*****LOGARITHMIC*****
2:begin call_procedure,'d22kin_log'
	
  end

;*****PERSONEL*****
3:begin call_procedure,'d22kin_pers'

  end

;*****ADDITION*****
4:begin call_procedure,'d22kin_add'
	
  end

;*****READING FILE*****
5:begin call_procedure,'d22kin_read'
	
  end

;*****EXIT*****
6:begin widget_control,ev.top,/destroy
	DialClear, 'd22kin'
;	DialClear, 'd22kin_const'
;	DialClear, 'd22kin_log'
;	DialClear, 'd22kin_pers'
;	DialClear, 'd22kin_add'
;	DialClear, 'd22kin_read'
	
  end

;*****HELP*****
7:begin ;xdisplayfile,'.hlp',title='D22 KIN help',group=ev.top,height=20,width=65
	
  end

else:

endcase

end

pro d22kin_gui
;** ******
;**

if xregistered('d22kin_gui') eq 0 then begin

base = widget_base (title='D22 KIN',/column,frame=5)

base0 = widget_base   (base,/column,frame=5)

base1 = widget_base   (base0,/row)
const = widget_button (base1,value='Do',uvalue=1)
label = widget_label  (base1,value='Constant acquisition time ')

base2 = widget_base   (base0,/row)
log   = widget_button (base2,value='Do',uvalue=2)
label = widget_label  (base2,value='Logarithmic acquisition time ')

base3 = widget_base   (base0,/row)
pers  = widget_button (base3,value='Do',uvalue=3)
label = widget_label  (base3,value='Personal acquisition time ')

base4 = widget_base   (base0,/row)
add   = widget_button (base4,value='Do',uvalue=4)
label = widget_label  (base4,value='Concatenation of files ')

base5 = widget_base   (base0,/row)
rf    = widget_button (base5,value='Do',uvalue=5)
label = widget_label  (base5,value='Reading file ')

label = widget_label  (base,value='For information :')
label = widget_label  (base,value='-Time is converted in ticks (1 tick=90.9 ns)')
label = widget_label  (base,value='-Max preset per frame is 390.4 s(=2^32*90.9)',/align_left)
label = widget_label  (base,value='-The max number of frames is 450',/align_left)

base6 = widget_base   (base,/row)
exit  = widget_button (base6,value='Exit',uvalue=6)
help  = widget_button (base6,value='Help',uvalue=7)

widget_control,base,/realize
xmanager,'d22kin_gui',base,/just_reg
endif
end

pro dial_d22kin_macro, D
;** ********************
;**

if D.init eq 0 then begin
	D.init=1
	D.frequency=0.
	d22kin_gui

endif else print,'ok'

end

function dial_d22kin
;******* **************
;**

return, {init:0}
end
;**************************
;HOW TO RUN THIS DIAL !!!
;------------------------
;START idl THEN ENTER:  
;Idl>.run dial_d22qrange
;Idl> d22qrange    
;**************************


pro d22qrange
;** *********
;Used to run with "byGeorge"
FORWARD_FUNCTION DialControl, DialNewValue, DialOn
if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

dial_bygeorge,'d22qrange'   ;<-------- Name of your Dial !!!
END                         ;          ~~~~~~~~~~~~~~~~~ !!!


pro qrange_gui_event,ev
;** ****************
;**

widget_control,ev.id,get_uvalue=uv
	;print,'dial_d22qrange widget # ',uv(0)


case uv(0) of

;****************************************
;*	WAVELENGTH CONTROL		*
;****************************************
1:begin widget_control,ev.id,get_value=bwls & bwls=bwls(0)		
	ok=0								
	on_ioerror,miswl
	bwl=float(bwls)
	ok=1
	miswl: if not ok then widget_control,uv(1),set_value='Type conversion error' $
                         else widget_control,uv(1),set_value=''
  end
			
;****************************************
;*	BEAMSTOP CONTROL		*
;****************************************
2:begin widget_control,uv(2),get_uvalue=bex			
	bex(0)=uv(1)				
	widget_control,uv(2),set_uvalue=bex
  end
		
;****************************************
;*	DETECTOR DISTANCE CONTROL	*
;****************************************
3:begin widget_control,ev.id,get_value=lasdds & lasdds=lasdds(0)		
	ok=0								
	on_ioerror,missdd
	lasdd=float(lasdds)
	ok=1
	missdd: if not ok then widget_control,uv(1),set_value='Type conversion error' $
                         else widget_control,uv(1),set_value=''
  end

;****************************************
;*	DETECTOR OFFSET CONTROL		*
;****************************************
4:begin widget_control,ev.id,get_value=txdofs & txdofs=txdofs(0)	
	ok=0								
	on_ioerror,misdof
	txdof=float(txdofs)
	ok=1
	misdof: if not ok then  widget_control,uv(1),set_value='Type conversion error' $
			 else widget_control,uv(1),set_value=''
  end

;****************************************
;*	CALCULATE BUTTON		*
;****************************************
5:begin 
	eps =0.002 ;**epsilon for DET **
	eps1=0.02  ;**epsilon for DTR DAN BX BY  **
	e=0
	e1=0
	e2=0
	bs=0
	xo=63.5
	t =1 
	t1=1 
	t2=1
	v1=DialNewValue(TYPE='t_para'  ,NAME='d22qrange')
	nb=v1.speed_nb
	h =v1.speed_h
	l =v1.speed_l
	x=0
	cste  = v1.sel_const(0)
	offset= v1.wave_offset(0)
									;********************************
	widget_control,uv(2),get_uvalue=bexcls & bexcls=bexcls(0)	;*	beamstop		*
	bexcl=float(bexcls)						;********************************
	if (bexcl eq 1) then bs=4.					
	if (bexcl eq 2) then bs=5.
	if (bexcl eq 3) then bs=5.5
	if (bexcl eq 4) then bs=7.
	if (bexcl eq 5) then bs=8.
									;********************************
	widget_control,uv(1),get_value=bwls    & bwls=bwls(0)		;*	wavelength		*
	ok=0								;********************************
	on_ioerror,misenter1 
	bwl=float(bwls)
	ok=1
	misenter1: if not ok then t=0		
									;********************************
	widget_control,uv(3),get_value=sdds    & sdds=sdds(0)		;*	detector distance	*
	ok1=0								;********************************
	on_ioerror,misenter2 
	sdd=float(sdds)
	ok1=1
	misenter2:if not ok1 then t1=0
	
									;********************************
	widget_control,uv(4),get_value=dofs    & dofs=dofs(0)		;*	detector offset		*
	ok2=0								;********************************
	on_ioerror,misenter3 
	dof=float(dofs)
	ok2=1
	misenter3:if not ok2 then t2=0
										;************************
	widget_control,uv(12),get_uvalue=coll  & coll=coll(n_elements(coll)-1)	;*	collimation	*
										;************************
	speed=cste/(bwl-offset)

	if t eq 0 then widget_control,uv(10),set_value='Type conversion error in Wavelength' $
			else begin
				for i=0,nb do begin
				if ((speed gt l(i)) and (speed lt h(i))) then x=1
				endfor
				if x eq 1 then begin
				widget_control,uv(10),set_value='? Wavelength forbidden'
				e=1
				endif else begin
	if t1 eq 0 then widget_control,uv(10),set_value='Type conversion error in Distance' $
			else begin
				if ((sdd lt (uv(13)-eps)) or (sdd gt (uv(14)+eps))) then begin
				Distance='? Distance: range from '+strtrim((string(uv(13))),2)+' to '+strtrim((string(uv(14))),2)
				widget_control,uv(10),set_value=Distance
				e1=1
				endif else begin
	if t2 eq 0 then widget_control,uv(10),set_value='Type conversion error in Offset' $
			else begin
				if ((dof lt (uv(15)-eps1)) or (dof gt (uv(16)+eps1))) then begin
				Offset='? Offset: range from '+strtrim((string(uv(15))),2)+' to '+strtrim((string(uv(16))),2)
				widget_control,uv(10),set_value=Offset
				e2=1
				endif else begin
	if coll lt (sdd-eps) then widget_control,uv(10),set_value='! caution: collimation smaller than detector distance !'$
			else widget_control,uv(10),set_value=''
								endelse
							endelse
						endelse
					endelse
				endelse
			endelse

	if ((t eq 1) and (t1 eq 1) and (t2 eq 1)) then begin
;	if ((e eq 0) and (e1 eq 0) and (e2 eq 0)) then begin	

							;************************			
	rmin    =sdd/(sdd-0.3)*bs/2			;*	rmin		*	
	rmin=(round(rmin/0.75+0.5)+1)*0.75		;*			*
	arg=xo*0.75+dof/10				;*		/ all	*
   	rmax    =sqrt(arg*arg+61*61*0.75*0.75)		;*	rmax		*
	rmax=round(rmax)				;*		/ in	*
  	tetamin =0.5*atan(rmin/(sdd*100))		;*			*
	qmin    =(4*!pi)/(bwl)*sin(tetamin)		;*	qmin	/ cm	*
	tetamax =0.5*atan(rmax/(sdd*100))		;*			*
	qmax    =(4*!pi)/(bwl)*sin(tetamax)		;*	qmax		*
	dmax    =!pi/qmin				;*	dmax		*
	dmin    =!pi/qmax				;*	dmin		*
							;************************
							;************************	
	widget_control,uv(5),set_value=string(rmin) 	;*	rmin		*	
	widget_control,uv(6),set_value=string(rmax) 	;*	rmax		*
	widget_control,uv(7),set_value=string(qmin) 	;*	qmin		*
	widget_control,uv(8),set_value=string(qmax) 	;*	qmax 		*
	widget_control,uv(9),set_value=string(dmax) 	;*	dmax		*
	widget_control,uv(11),set_value=string(dmin) 	;*	dmin		*
	endif						;************************
;	endif
end

;****************************************
;*	COLLIMATION LIST		*
;****************************************
6:begin coll=uv(ev.index+1)
	uv(n_elements(uv)-1)=coll		;* puts value of coll in last element of list!	*
	widget_control,ev.id,set_uvalue=uv	;************************************************
	widget_control,uv(10),get_value=sdds & sdds=sdds(0)
	sdd=float(sdds)
	if coll lt sdd then widget_control,uv(11),set_value='caution: collimation smaller than detector distance'$
	else widget_control,uv(11),set_value=''
		
  end

;****************************************
;*	EXIT BUTTON			*
;****************************************
7:begin widget_control,ev.top,/destroy
	DialClear, 'd22qrange'

  end

;****************************************
;*	HELP BUTTON			*
;****************************************
8:begin xdisplayfile,'/users/d22/hlp/dial_d22qrange.hlp',title='Q-Range Help',group=ev.top,height=52,width=65
	

  end

;****************************************
;*	SEND BUTTON			*
;****************************************
9:begin
	e=0 & e1=0 & e2=0 & e3=0 & e4=0
	t=1 & t1=1 & t2=1 & t3=1 & t4=1
	V1=DialNewValue(TYPE='t_nother',NAME='d22qrange')
	V2=DialNewValue(TYPE='t_para'  ,NAME='d22qrange')

	nb=v2.speed_nb
	h =V2.speed_h
	l =V2.speed_l
	x=0
	cste  = v2.sel_const(0)
	offset= v2.wave_offset(0)
									;********************************
	widget_control,uv(1),get_value=bwls    & bwls=bwls(0)		;*	wavelength		*  	
	ok=0								;********************************
	on_ioerror,missend 
	bwl=float(bwls)							
	ok=1
	missend: if not ok then t=0
									;********************************
	widget_control,uv(2),get_uvalue=bexcls & bexcls=bexcls(0)	;*	beamstop		*
									;********************************
	widget_control,uv(3),get_value=sdds    & sdds=sdds(0)		;*	detector distance	*
	ok1=0								;********************************
	on_ioerror,missend1 
	sdd=float(sdds)
	ok1=1
	missend1: if not ok1 then t1=0
									;********************************
	widget_control,uv(4),get_value=dofs    & dofs=dofs(0)		;*	offset			*
	ok2=0								;********************************
	on_ioerror,missend2 
	dof=float(dofs)
	ok2=1
	missend2: if not ok2 then t2=0
								       	;********************************
	widget_control,uv(6),get_value=bxs     & bxs=bxs(0)		;*	Bx			*
	ok3=0								;********************************
	on_ioerror,missend3 
	bx=float(bxs)
	ok3=1
	missend3: if not ok3 then t3=0
									;********************************
	widget_control,uv(7),get_value=bys     & bys=bys(0)		;*	By			*
	ok4=0								;********************************
	on_ioerror,missend4 
	by=float(bys)
	ok4=1
	missend4: if not ok4 then t4=0
									;********************************
	widget_control,uv(9),get_value=x0s     & x0s=x0s(0)		;*	X0			*
	x0=float(x0s)							;********************************

									;********************************
	widget_control,uv(10),get_value=y0s     & y0s=y0s(0)		;*	Y0			*
	y0=float(y0s)							;********************************
	
									;********************************
	widget_control,uv(5),get_uvalue=coll				;*	collimation		*
	coll=coll(n_elements(coll)-1)					;********************************

									;********************************
	activity=V1.cstate						;*	instrument status	*
									;********************************
	speed=cste/(bwl-offset)

	if t  eq 0 then widget_control,uv(8),set_value='Type conversion error in Wavelength' $	;************************
			else begin								;*	test values	*
				for i=0,nb do begin						;************************
				if ((speed gt l(i)) and (speed lt h(i))) then x=1
				endfor
				if x eq 1 then begin
				widget_control,uv(8),set_value='? Wavelength forbidden'
				e=1
				endif else begin
	if t1 eq 0 then widget_control,uv(8),set_value='Type conversion error in Distance' $
			else begin
				if ((sdd lt (uv(11))) or (sdd gt (uv(12)))) then begin
				Distance='? Distance: range from '+strtrim((string(uv(9))),2)+' to '+strtrim((string(uv(10))),2)
				widget_control,uv(8),set_value=Distance
				e1=1
				endif else begin
	if t2 eq 0 then widget_control,uv(8),set_value='Type conversion error in Offset' $
			else begin
				if ((dof lt (uv(13))) or (dof gt (uv(14)))) then begin
				Offset='? Offset: range from '+strtrim((string(uv(11))),2)+' to '+strtrim((string(uv(12))),2)
				widget_control,uv(8),set_value=Offset
				e2=1
				endif else begin
	if t3 eq 0 then widget_control,uv(8),set_value='Type conversion error in Bx' $
			else begin
				if ((bx lt (uv(17))) or (bx gt (uv(18)))) then begin
				Bx='? Bx: range from '+strtrim((string(uv(13))),2)+' to '+strtrim((string(uv(14))),2)
				widget_control,uv(8),set_value=Bx
				e3=1
				endif else begin
	if t4 eq 0 then widget_control,uv(8),set_value='Type conversion error in By' $
			else begin
				if ((by lt (uv(19))) or (by gt (uv(20)))) then begin
				By='? By: range from '+strtrim((string(uv(15))),2)+' to '+strtrim((string(uv(16))),2)
				widget_control,uv(8),set_value=By
				e4=1
				endif else begin
				widget_control,uv(8),set_value=''
										endelse
									endelse
								endelse
							endelse
						endelse
					endelse
				endelse
			endelse
		endelse
	endelse
	print,'Current status is ',activity
	if activity eq 0 then begin
	if ((t eq 1) and (t1 eq 1) and (t2 eq 1) and (t3 eq 1) and (t4 eq 1)) then begin
	if ((e eq 0) and (e1 eq 0) and (e2 eq 0) and (e3 eq 0) and (e4 eq 0)) then begin	
										;********************************
	R =DialControl ('wave '+string(bwl)               ,NAME='d22qrange')	;*	wave		/MAD	*	
	R =DialControl ('att c 3'                ,check=.5,NAME='d22qrange')	;*	attenuator		*
	R =DialControl ('bx ' +bxs+' by '+bys    ,check=.5,NAME='d22qrange')	;*	bx by			*
	cmd='det '+sdds+' coll '+string(coll)+' dtr '+dofs			;*				*
	R =DialControl (cmd                      ,check=.5,NAME='d22qrange')	;*	det coll dtr		*
	R =Dialcontrol ('par centre '+x0s+' '+y0s,check=.5,NAME='d22qrange')	;*	x0 y0			*
	R =DialControl ('att o'                  ,check=.5,NAME='d22qrange')	;*	attenuator out		*
										;********************************
	endif
	endif
	endif

	;* NB: beam command is  n o t  being sent by pushing the SEND button ! *
	;***********************************************************************
  end

;****************************************
;*	GET SETTING BUTTON		*
;****************************************
10:begin a=strtrim(string(uv(1)),2)
		on_ioerror,misfil
		u=-1
		if (a eq 0) then a='t'
		get_lun,u
		openr,u,'setting_'+a+'.cmd'
		a=' ' & wav=0. & beam=0 & det=0. & coll=0. & dtr=0. & n=0 &
		bx=0. & by=0. & x0=0. & y0=0. & dan=0.
	while not eof(u) do begin						;********************************
		readf,u,a							;*				*
		a=strlowcase(a)							;*	reading setting file	*
		i=strpos(a,'wave')						;*				*
		if i ge 0 then begin						;********************************
		reads,strmid(a,i+5,10),wav
		endif
		i=strpos(a,'beam')
		if i ge 0 then begin
		reads,strmid(a,i+5,17),beam
		endif
		i=strpos(a,'det')
		if i ge 0 then begin
		reads,strmid(a,i+4,10),det
		endif
		i=strpos(a,'coll')
		if i ge 0 then begin
		reads,strmid(a,i+5,10),coll
		endif
		i=strpos(a,'dtr')
		if i ge 0 then begin
		reads,strmid(a,i+4,10),dtr
		endif 
		i=strpos(a,'dan')
		if i ge 0 then begin
		reads,strmid(a,i+4,10),dan
		endif
		i=strpos(a,'bx')
		if i ge 0 then begin
		reads,strmid(a,i+3,10),bx
		reads,strmid(a,i+23,10),by
		endif
		;i=strpos(a,'by')
		;if i ge 0 then begin
		;reads,strmid(a,i+3,10),by
		;endif
		i=strpos(a,'par centre')
		if i ge 0 then begin
		reads,strmid(a,i+11,10),x0
		reads,strmid(a,i+25,10),y0
		endif &
	endwhile
		close,u
		free_lun,u
		col=0
		if coll eq 2    then col=1
		if coll eq 2.8  then col=2
		if coll eq 4    then col=3
		if coll eq 5.6  then col=4
		if coll eq 8    then col=5
		if coll eq 11.2 then col=6
		if coll eq 14.4 then col=7
		if coll eq 17.6 then col=8
									;********************************
		widget_control,uv(3) ,set_value =strtrim(string(wav),2) ;*	wavelength		*
		widget_control,uv(5) ,set_value =strtrim(string(det),2) ;* sample to detector distance  *
		widget_control,uv(6) ,set_value =strtrim(string(dtr),2) ;*	detector offset		*
		widget_control,uv(8) ,set_value =strtrim(string(bx),2) 	;*          bx                  *
		widget_control,uv(9) ,set_value =strtrim(string(by),2) 	;*          by                  *
		widget_control,uv(10),set_value =strtrim(string(x0),2)	;*          x0                  *
		widget_control,uv(11),set_value =strtrim(string(y0),2)	;*          y0                  *
		widget_control,uv(12),set_value =strtrim(string(dan),2)	;*	    dan			*
		widget_control,uv(4) ,get_uvalue=bex			;*	beamstop		*
		bex(0)=beam						;*				*
		widget_control,uv(4) ,set_uvalue=bex			;*				*
		widget_control,bex(beam),/set_button			;*				*
		widget_control,uv(7) ,set_list_select =col		;*	collimation		*		
		widget_control,uv(7) ,get_uvalue=cuv			;*				*	
		cuv(n_elements(cuv)-1)=coll				;*				*
		widget_control,uv(7) ,set_uvalue=cuv			;********************************

		if coll lt det then widget_control,uv(13),set_value='! caution: collimation smaller than detector distance !'$
		else widget_control,uv(13),set_value=''
		a=uv(1)
		widget_control,uv(14),set_value=strtrim(string(a),2)

		misfil:if u gt 0 then free_lun,u
 end

;****************************************
;*	SAVE SETTING BUTTON		*
;****************************************				
11:begin 
	e =0 & e1=0 & e2=0 & e3=0 & e4=0 & e5=0 & e6=0 & e7=0 & e8=0
	t0=1 & t1=1 & t2=1 & t3=1 & t4=1 & t5=1 & t6=1 & t7=1 & t8=1
	V1=DialNewValue(TYPE='t_para'  ,NAME='d22qrange')
	nb=v1.speed_nb
	h =V1.speed_h
	l =V1.speed_l
	x=0
	cste  = v1.sel_const(0)
	offset= v1.wave_offset(0)

	widget_control,uv(7),get_value=setnums & setnums=setnums(0)	;********************************
	ok8=0								;*	setting number		*
	on_ioerror,missave8						;********************************
	setnum=fix(setnums)
	ok8=1
	missave8: if not ok8 then t8=0

	if t8 eq 1 then begin

	widget_control,uv(1), get_value=bwls & bwls   =bwls(0)		;********************************
	ok=0								;*	wavelength		*
	on_ioerror,missave						;********************************
	bwl=float(bwls)
	ok=1
	missave: if not ok then t0=0
									;********************************
	widget_control,uv(2), get_uvalue=bexcl & bexcl=bexcl(0)		;*	beamstop		*
									;********************************
	widget_control,uv(3), get_value=sdds & sdds  =sdds(0)		;*	detector distance	*
	ok1=0								;********************************
	on_ioerror,missave1
	sdd=float(sdds)
	ok1=1
	missave1: if not ok1 then t1=0
		
	widget_control,uv(4), get_value=dofs & dofs  =dofs(0)		;********************************
	ok2=0								;*	offset			*
	on_ioerror,missave2						;********************************
	dof=float(dofs)
	ok2=1
	missave2: if not ok2 then t2=0
		
	widget_control,uv(8), get_value=dans & dans  =dans(0)		;********************************
	ok3=0								;*	angle			*
	on_ioerror,missave3						;********************************
	dan=float(dans)
	ok3=1
	missave3: if not ok3 then t3=0

	widget_control,uv(9), get_value=bxs & bxs    =bxs(0)		;********************************
	ok4=0								;*	Bx			*
	on_ioerror,missave4						;********************************
	bx=float(bxs)
	ok4=1
	missave4: if not ok4 then t4=0

	widget_control,uv(10),get_value=bys & bys    =bys(0)		;********************************
	ok5=0								;*	By			*
	on_ioerror,missave5						;********************************
	by=float(bys)
	ok5=1
	missave5: if not ok5 then t5=0

	widget_control,uv(11),get_value=x0s & x0s    =x0s(0)		;********************************
	ok6=0								;*	X0			*
	on_ioerror,missave6						;********************************
	x0=float(x0s)
	ok6=1
	missave6: if not ok6 then t6=0

	widget_control,uv(12),get_value=y0s & y0s   =y0s(0)		;********************************
	ok7=0								;*	Y0			*
	on_ioerror,missave7						;********************************
	y0=float(y0s)
	ok7=1
	missave7: if not ok7 then t7=0
										
	widget_control,uv(6),get_uvalue=coll   & coll=coll(n_elements(coll)-1)	
										
	widget_control,uv(7),get_value=setnums & setnums=setnums(0)

	speed=cste/(bwl-offset)

	if t0 eq 0 then widget_control,uv(13),set_value='Type conversion error in Wavelength' $	;************************
			else begin								;*	test values	*
				for i=0,nb do begin						;************************
				if ((speed gt l(i)) and (speed lt h(i))) then x=1
				endfor
				if x eq 1 then begin
				widget_control,uv(10),set_value='? Wavelength forbidden'
				e=1
				endif else begin
	if t1 eq 0 then widget_control,uv(13),set_value='Type conversion error in Distance' $
			else begin
				if ((sdd lt (uv(14))) or (sdd gt (uv(15)))) then begin
				Distance='? Distance: range from '+strtrim((string(uv(14))),2)+' to '+strtrim((string(uv(15))),2)
				widget_control,uv(13),set_value=Distance
				e1=1
				endif else begin
	if t2 eq 0 then widget_control,uv(13),set_value='Type conversion error in Offset' $
			else begin
				if ((dof lt (uv(16))) or (dof gt (uv(17)))) then begin
				Offset='? Offset: range from '+strtrim((string(uv(16))),2)+' to '+strtrim((string(uv(17))),2)
				widget_control,uv(13),set_value=Offset
				e2=1
				endif else begin
	if t3 eq 0 then widget_control,uv(13),set_value='Type conversion error in Angle' $
			else begin
				if ((dan lt (uv(18))) or (dan gt (uv(19)))) then begin
				Angle='? Angle: range from '+strtrim((string(uv(18))),2)+' to '+strtrim((string(uv(19))),2)
				widget_control,uv(13),set_value=Angle
				e3=1
				endif else begin
	if t4 eq 0 then widget_control,uv(13),set_value='Type conversion error in Bx' $
			else begin
				if ((bx lt (uv(20))) or (bx gt (uv(21)))) then begin
				Bx='? Bx: range from '+strtrim((string(uv(20))),2)+' to '+strtrim((string(uv(21))),2)
				widget_control,uv(13),set_value=Bx
				e4=1
				endif else begin
	if t5 eq 0 then widget_control,uv(13),set_value='Type conversion error in By' $
			else begin
				if ((by lt (uv(22))) or (by gt (uv(23)))) then begin
				By='? By: range from '+strtrim((string(uv(22))),2)+' to '+strtrim((string(uv(23))),2)
				widget_control,uv(13),set_value=By
				e5=1
				endif else begin
;	if t6 eq 0 then widget_control,uv(13),set_value='Type conversion error in X0' $
;			else begin
;				if ((x0 lt (0)) or (x0 gt (127))) then begin
;				widget_control,uv(13),set_value='? X0 : range from 0 to 127'
;				e6=1
;				endif else begin
;	if t7 eq 0 then widget_control,uv(13),set_value='Type conversion error in Y0' $
;			else begin
;				if ((y0 lt (0)) or (y0 gt (127))) then begin
;				widget_control,uv(13),set_value='? Y0 : range from 0 to 127'
;				e7=1
;				endif else begin
				widget_control,uv(13),set_value=''
;						endelse
;						endelse
;						endelse
;						endelse
				endelse
				endelse
				endelse
				endelse
		endelse
		endelse
		endelse
		endelse
endelse
endelse
endelse
endelse

	b=systime(0)
	setnum = fix(setnums)
	a=strtrim(setnum,2)
print,a
if ((t0 eq 1) and (t1 eq 1) and (t2 eq 1) and (t3 eq 1) and (t4 eq 1) and (t5 eq 1)) then begin
if ((e  eq 0) and (e1 eq 0) and (e2 eq 0) and (e3 eq 0) and (e4 eq 0) and (e5 eq 0)) then begin
if ((x0 lt (0)) or (x0 gt (127))) then begin
		widget_control,uv(13),set_value='? X0 : range from 0 to 127'
endif
if ((y0 lt (0)) or (y0 gt (127))) then begin
		widget_control,uv(13),set_value='? Y0 : range from 0 to 127'
endif
if ((a gt 0.9)  and (a lt 9.1)) then begin
		get_lun,u						;********************************
		openw ,u,'setting_'+a+'.cmd'				;*				*
		printf,u,'! written by GEORGE dial d22qrange on ',b	;*				*
		printf,u,'att c 3'					;*	writing setting file	*
		printf,u,'wave',bwl					;*				*	
        	printf,u,'! beam',bexcl					;********************************	
         	printf,u,'det',sdd,' coll',coll,' dtr',dof,' dan',dan
		printf,u,'bx',bx,' by',by
		printf,u,'par centre',x0,y0
		printf,u,'att o'
		close ,u
		free_lun,u
endif else begin
		if (a eq 0) then begin
		get_lun,u						;********************************
		openw,u,'setting_t.cmd'					;*				*	
		printf,u,'! written by GEORGE dial d22qrange on ',b	;*				*	
		printf,u,'att c 3'					;*	writing setting t file	*
		printf,u,'wave',bwl					;*				*	
        	printf,u,'! beam',bexcl					;********************************	
         	printf,u,'det',sdd,' coll',coll,' dtr',dof,' dan',dan
		printf,u,'bx',bx,' by',by
		printf,u,'par centre',x0,y0
		printf,u,'att c 3'
		close ,u
		free_lun,u
		endif
endelse

endif
endif

endif else widget_control,uv(7),set_value=''

  end
;****************************************
;*	INSTRUMENT SETTING BUTTON	*
;****************************************
12:begin 
	 V1 =DialNewValue(TYPE='t_nother',NAME='d22qrange')
	 V2 =DialNewValue(TYPE='t_para'  ,NAME='d22qrange')
	 Lim=DialNewValue(TYPE='limits'  ,NAME='d22qrange')	 
	 ;help,V1,/struc
	 ;help,V2,/struc
	 ;help,lim,/struc				;********************************
	 wave=V1.act_wave				;*	wavelength		*
	 coll=V1.act_coll				;*	collimation		*
	 beam=V2.beam_stop_unit				;*	beamstop		*
	 det =V1.actang(0)				;* sample to detector distance	*
	 dtr =V1.actang(1)				;*	detector offset		*
	 dan =V1.actang(2)				;*	     dan		*
	 bx  =V1.actang(3)				;*	     bx			*
	 by  =V1.actang(4)				;*	     by			*
	 X0  =V2.x0					;*	     x0			*
	 y0  =V2.y0					;*	     y0			*
	 						;********************************

	 if coll eq 1.4  then col=0
	 if coll eq 2    then col=1
	 if coll eq 2.8  then col=2
	 if coll eq 4    then col=3
	 if coll eq 5.6  then col=4
	 if coll eq 8    then col=5
	 if coll eq 11.2 then col=6
	 if coll eq 14.4 then col=7
	 if coll eq 17.6 then col=8
									;********************************
	 widget_control,uv(1) ,set_value = strtrim(string(wave),2)     	;*	wavelength		*
	 widget_control,uv(3) ,set_value = strtrim(string(det) ,2)     	;* sample to detector distance	*
	 widget_control,uv(4) ,set_value = strtrim(string(dtr) ,2)	;*	detector offset		*
	 widget_control,uv(6) ,set_value = strtrim(string(dan) ,2)	;*	     dan		*
	 widget_control,uv(7) ,set_value = strtrim(string(bx)  ,2)	;*	     bx			*
	 widget_control,uv(8) ,set_value = strtrim(string(by)  ,2)	;*	     by			*
	 widget_control,uv(9) ,set_value = strtrim(string(x0)  ,2)	;*	     x0			*
	 widget_control,uv(10),set_value = strtrim(string(y0)  ,2)	;*	     y0			*
	 widget_control,uv(2) ,get_uvalue= bex     			;*	beamstop		*
	 widget_control,bex(beam),/set_button				;*				*
	 widget_control,uv(5) ,set_list_select =col 			;*	collimation		*
	 widget_control,uv(5) ,get_uvalue=cuv				;*				*  
	 cuv(n_elements(cuv)-1)=coll					;*				*
	 widget_control,uv(5),set_uvalue=cuv				;*				*
									;********************************
   end

;****************************************
;*	SETTING NUMBER CONTROL		*
;****************************************
13:begin widget_control,ev.id,get_value=sns & sns=sns(0)
	 ok=0
	 on_ioerror,missn
	 sn=float(sns)
	 ok=1
	 missn: if not ok then widget_control,uv(1),set_value=''
   end

;****************************************
;*	X0 CONTROL			*
;****************************************
14:begin widget_control,ev.id,get_value=x0s & x0s=x0s(0)
	 ok=0
	 on_ioerror,misx0
	 x0=float(x0s)
	 ok=1
	 misx0: if not ok then widget_control,uv(1),set_value='' 
   end

;****************************************
;*	Y0 CONTROL			*
;****************************************
15:begin widget_control,ev.id,get_value=y0s & y0s=y0s(0)
	 ok=0
	 on_ioerror,misy0
	 y0=float(y0s)
	 ok=1
	 misy0: if not ok then widget_control,uv(1),set_value='' 
   end

;****************************************
;*	BX CONTROL			*
;****************************************
16:begin widget_control,ev.id,get_value=bxs & bxs=bxs(0)
	 ok=0
	 on_ioerror,misbx
	 bx=float(bxs)
	 ok=1
	 misbx: if not ok then widget_control,uv(1),set_value='' 
   end

;****************************************
;*	BY CONTROL			*
;****************************************
17:begin widget_control,ev.id,get_value=bys & bys=bys(0)
	 ok=0
	 on_ioerror,misby
	 by=float(bys)
	 ok=1
	 misby: if not ok then widget_control,uv(1),set_value=''
   end

;****************************************
;*	DAN CONTROL			*
;****************************************
18:begin widget_control,ev.id,get_value=dans & dans=dans(0)
	 ok=0
	 on_ioerror,misdan
	 dan=float(dans)
	 ok=1
	 misdan: if not ok then widget_control,uv(1),set_value='' 

   end


else:
endcase

end
;**************

pro qrange_gui, Lim
;** **********
;**

if xregistered('qrange_gui') eq 0 then begin


base=widget_base(title='D22 Q-RANGE',/COLUMN,resource_name='geo')

;******************************************************************************	;********************************
										;*	Get Setting #		*
base0  =widget_base  (base   ,/column,frame=5);,resource_name='lamp')		;*	Get Instrument Setting	*
										;*	Save Setting #		*
base01 =widget_base  (base0  ,/row)						;********************************
setting=widget_label (base01 ,value='Get Setting #')

base02 =widget_base  (base0  ,/row)
bid    =widget_label (base02 ,value='     ')
curset =widget_button(base02 ,value='Get Instrument Setting',uvalue=12,frame=5,resource_name='lamp')
bid    =widget_label (base02 ,value='        ')

base022=widget_base  (base02 ,/row,frame=5)
save   =widget_button(base022,value='Save Setting #',uvalue=[11],resource_name='lamp')
bid    =widget_label (base022,value='0 (for t)-9:')
sn1    =widget_text  (base022,value='',xsize=3,ysize=1,/editable,uvalue=13,resource_name='lamp')
widget_control,sn1,set_uvalue=[13,sn1]

;******************************************************************************	;********************************
										;*	Wavelength		*
base1  =widget_base  (base ,/column,frame=5)					;*	Beamstop #		*
										;*	Detector Distance	*
base11 =widget_base  (base1 ,/row)						;*	Offset			*
labwl  =widget_label (base11,value='Wavelength ('+string("305B)+') :')		;********************************
bwl    =widget_text  (base11,value='',xsize=5,ysize=1,/editable,uvalue=1,resource_name='lamp')
labbst =widget_label (base11,value='   Beamstop #')
def    =4
bst    =lonarr(5)
bexcl  =widget_base  (base11,/exclusive,/row)
	bst(0)=widget_button(bexcl,value='1',/no_release,uvalue=[2,1,bexcl])
	bst(1)=widget_button(bexcl,value='2',/no_release,uvalue=[2,2,bexcl])
	bst(2)=widget_button(bexcl,value='3',/no_release,uvalue=[2,3,bexcl])
	bst(3)=widget_button(bexcl,value='4',/no_release,uvalue=[2,4,bexcl])
	bst(4)=widget_button(bexcl,value='5',/no_release,uvalue=[2,5,bexcl])

widget_control,bst(def-1),/set_button
widget_control,bexcl,set_uvalue=[def,bst]

mesg   =widget_label (base1,value=string(''),/dynamic_resize,resource_name='lamp')

base12 =widget_base  (base1 ,/row)
lasdd  =widget_label (base12,value='Detector Distance (m) :')
txsdd  =widget_text  (base12,value='',xsize=6,ysize=1,/editable,uvalue=3,resource_name='lamp')
ladof  =widget_label (base12,value='         Offset (mm) :')
txdof  =widget_text  (base12,value='',xsize=6,ysize=1,/editable,uvalue=4,resource_name='lamp')

widget_control,bwl,  set_uvalue=[1,mesg]
widget_control,txsdd,set_uvalue=[3,mesg]
widget_control,txdof,set_uvalue=[4,mesg]

;******************************************************************************		;************************
											;*	Radius		*
											;*	Calculate	*
base2     =widget_base  (base ,/column,frame=5)						;*	Dmax		*
calculate =widget_button(base2,value='Calculate',uvalue=5,frame=5,resource_name='lamp')	;*	Q		*
											;************************	
base21    =widget_base  (base2 ,/row)							
labvide   =widget_label (base21,value='               ')
txrmin    =widget_label (base21,value='',/dynamic_resize)
labuni1   =widget_label (base21,value=' cm')
labrmin   =widget_label (base21,value='<  Radius  <')
txrmax    =widget_label (base21,value='',/dynamic_resize)
labuni2   =widget_label (base21,value=' cm')
bid       =widget_label (base21,value='                         ')

base22    =widget_base  (base2 ,/row)
labvide   =widget_label (base22,value='         ')
txqmin    =widget_label (base22,value='',/dynamic_resize)
labuni3   =widget_label (base22,value=+string("305B)+'-1')
labqmin   =widget_label (base22,value='<     Q        <')
txqmax    =widget_label (base22,value='',/dynamic_resize)
labuni5   =widget_label (base22,value=+string("305B)+'-1')
bid       =widget_label (base22,value='                         ')
 
base23    =widget_base  (base2 ,/row)
labvide   =widget_label (base23,value='            ')
labdmax   =widget_label (base23,value='Dmax =')
txdmax    =widget_label (base23,value='',/dynamic_resize)
labuni4   =widget_label (base23,value=+string("305B))
labdmin   =widget_label (base23,value='Dmin =')
txdmin    =widget_label (base23,value='',/dynamic_resize)
labuni4   =widget_label (base23,value=+string("305B))
bid       =widget_label (base23,value='                         ')

;******************************************************************************	;************************
										;*	Collimation	*
base3    =widget_base  (base ,/column,frame=5)					;*      X0		*
basea    =widget_base  (base3,/row)						;*      Y0		*
										;*      Bx		*
baseb    =widget_base  (basea,/row)						;*      By		*
labcolli =widget_label (baseb,value='Collimation (m) : ')			;*      angle		*
										;*	setting button	*
col	 =fltarr(9)								;************************
col	 =['1.4','2','2.8','4','5.6','8','11.2','14.4','17.6']
colli	 =widget_list  (baseb,value=col,ysize=3,uvalue=[6.,float(col),txsdd,mesg,0.],resource_name='lamp')

basec    =widget_base  (basea,/column)

basee    =widget_base  (basec,/row)
labvide  =widget_label (basee,value='              ')
labbx    =widget_label (basee,value='Bx (mm) =')
txtbx    =widget_text  (basee,value='',  /editable,xsize=5,uvalue=16,resource_name='lamp')

based    =widget_base  (basec,/row)
labvide  =widget_label (based,value='              ')
labby    =widget_label (based,value='By (mm) =')
txtby    =widget_text  (based,value='',  /editable,xsize=5,uvalue=17,resource_name='lamp')

base33   =widget_base  (base3 ,/row)
labx0    =widget_label (base33,value='X0 (pix.) =')
txtx0    =widget_text  (base33,value='', /editable,xsize=5,uvalue=14,resource_name='lamp')
labvide  =widget_label (base33,value='    ')
laby0    =widget_label (base33,value='Y0 (pix.) =')
txty0    =widget_text  (base33,value='', /editable,xsize=5,uvalue=15,resource_name='lamp')
labvide  =widget_label (base33,value='    ')
labdan   =widget_label (base33,value='angle (deg.) =')
txtdan   =widget_text  (base33,value='0',/editable,xsize=5,uvalue=18,resource_name='lamp')

widget_control,txtx0, set_uvalue =[14,txtx0]
widget_control,txty0, set_uvalue =[15,txty0]

widget_control,txtbx, set_uvalue =[16,txtbx]
widget_control,txtby, set_uvalue =[17,txtby]
widget_control,txtdan,set_uvalue =[18,txtdan]

set      =lonarr(11)
excl     =widget_base   (base01,/exclusive,/row)
	set(1) =widget_button(excl,value='1',  /no_release,$
		uvalue=[10,1,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
  	set(2) =widget_button(excl,value='2',  /no_release,$
		uvalue=[10,2,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(3) =widget_button(excl,value='3',  /no_release,$
		uvalue=[10,3,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(4) =widget_button(excl,value='4',  /no_release,$
		uvalue=[10,4,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(5) =widget_button(excl,value='5',  /no_release,$
		uvalue=[10,5,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(6) =widget_button(excl,value='6',  /no_release,$
		uvalue=[10,6,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(7) =widget_button(excl,value='7',  /no_release,$
		uvalue=[10,7,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(8) =widget_button(excl,value='8',  /no_release,$
		uvalue=[10,8,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(9) =widget_button(excl,value='9',  /no_release,$
		uvalue=[10,9,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])
	set(10)=widget_button(excl,value='0:t',/no_release,$
		uvalue=[10,0,excl,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,txtx0,txty0,txtdan,mesg,sn1])

widget_control,save,     set_uvalue =[11,bwl,bexcl,txsdd,txdof,excl  ,colli ,sn1   ,txtdan,txtbx ,txtby,txtx0 ,txty0,mesg,lim]
widget_control,curset,   set_uvalue =[12,bwl,bexcl,txsdd,txdof,colli ,txtdan,txtbx ,txtby ,txtx0 ,txty0,lim]
widget_control,calculate,set_uvalue =[5 ,bwl,bexcl,txsdd,txdof,txrmin,txrmax,txqmin,txqmax,txdmax,mesg ,txdmin,colli,lim]

;******************************************************************************			;************************
												;*	Send		*
base4    =widget_base   (base ,/row,frame=5)							;*	Help		*
												;*	Exit		*
send     =widget_button (base4,value='Send Command',uvalue=[9],frame=10,resource_name='lamp')	;************************
bid      =widget_label  (base4,value=' ')
bid      =widget_label  (base4,value=' ')
help     =widget_button (base4,value='Help',uvalue=[8],frame=5,resource_name='lamp')
bid      =widget_label  (base4,value=' ')
bid      =widget_label  (base4,value='                                                        ')
exit     =widget_button (base4,value='Exit',uvalue=[7],frame=5,resource_name='lamp')

widget_control,send,set_uvalue =[9,bwl,bexcl,txsdd,txdof,colli,txtbx,txtby,mesg,txtx0,txty0,lim]

;******************************************************************************

widget_control,base,/realize

xmanager,'qrange_gui',base,/just_reg
endif
end

pro dial_d22qrange_macro, D
;** ********************
;**

if D.init eq 0 then begin
	D.init=1
	D.frequency=0.
	Lim=DialNewValue(type='limits')
	qrange_gui,Lim

endif else print,'init was 1'

end

function dial_d22qrange
;******* **************
;**

return, {init:0}
end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
; D7 Count automation 
;
;-------------------------------------------------------------------------------
;*******************************************************************************

FUNCTION DIAL_D7COUNT_SEND, Dialtype, Check, Commd, Dialname
	a=docount()			;Get count parameters from user
RETURN, 0 
END
;-------------------------------------------------------------------------------
;*******************************************************************************

	pro dial_d7monitor1_macro, Dial

;	Prints the monitor 1 value from the previous measurement
;	updates every 10 mins
;						JRS 22/3/01
;
;-------------------------------------------------------------------------------
;*******************************************************************************

    b=DialNewValue()
    Dial.type='t_res' & a=DialNewValue()
    phn=a.phase_nb
    Dial.value=b(0:phn-1)
    end

function dial_d7monitor1
;******* *************
;**

    return, {NAME:'d7temp',FREQUENCY:600,GENERIC:'mad',TYPE:'monitor1'}
    end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
; D7 Parameter setting 
;
;-------------------------------------------------------------------------------
;*******************************************************************************

FUNCTION DIAL_D7PARAMS_SEND, Dialtype, Check, Commd, Dialname
	set_param_d7
RETURN, 0 
END
;-------------------------------------------------------------------------------
;*******************************************************************************

	PRO dial_d7status_macro, D
;
; 	Interactive dynamic display and control of D7
;
;						JRS 22/5/02
;-------------------------------------------------------------------------------
;*******************************************************************************

	COMMON c_lamp
	COMMON c_lamp_font	
	COMMON local, nparams

	nparams = 18
	bobfac  = 1.84

; read in the instrument motor/current values
	mall = DIALNEWVALUE(TYPE = 'motors', /SETVALUE)
	ball = DIALNEWVALUE(TYPE = 'currents', /SETVALUE)
	para = DIALNEWVALUE(TYPE = 't_para', /SETVALUE)
	res  = DIALNEWVALUE(TYPE = 't_res', /SETVALUE)

	ball(0:1) = ball(0:1)*bobfac			;Flipper Currents
	param = FLTARR(nparams)
	param(0:4)   = mall(0:4)			;bank + rotation
	param(5)     = mall(5)				;omega
	param(6:10)  = ball(0:4)			;Currents
	param(11:16) = mall(8:13)			;monos
	param(17)    = mall(14)				;polariser angle
	
; Setup parameter value strings
	parstr = STRTRIM(STRING(param),2)
	FOR i = 0, nparams-1 DO BEGIN
		IF (i EQ 6) OR (i EQ 7) THEN BEGIN
			dummy = FLOAT(ROUND(100. * FLOAT(parstr(i))))/100.
			parstr(i) = STRTRIM(STRING(dummy),2)
		ENDIF
		posdot = STRPOS(parstr[i],'.')
		pos00  = STRPOS(STRMID(parstr(i),posdot),'00')
		IF pos00 NE -1 THEN parstr(i) = STRMID(parstr(i),0,pos00+posdot)
		last = STRLEN(parstr(i))
		IF(STRPOS(parstr(i),'.') EQ last - 1)  THEN parstr(i) = parstr(i)+'0'
		IF RSTRPOS(parstr(i),'0') EQ last - 1 THEN $
		IF STRPOS(parstr[i],'.') NE -1 THEN parstr(i) = STRMID(parstr(i),0,last-1)

	ENDFOR

; Read header values
	stat     = DIALNEWVALUE(TYPE = 'status', /SETVALUE)
	stat     = STRTRIM(stat,2)
	status   = 'D7 is ' + stat
	numor    = STRTRIM(STRING(ROUND(res.numor_to_send) + 1),2)
	title    = STRTRIM(STRING(para.C_TXT),2)
	subtitle = STRTRIM(STRING(para.SUB_TITLE),2)
	user     = STRTRIM(STRING(para.C_USER),2)
	lc       = STRTRIM(STRING(para.C_LC),2)
	label = STRARR(4)
	label(0) = title
	label(1) = 'User: ' + user + '  Local Contact: ' + lc
	label(2) = status
	label(3) = 'Run #' + numor + '   ' + subtitle

; initiallise the dial
    	IF  (D.init EQ 0) THEN BEGIN
		D.init=1

; initiallise the text fields
		param_text = STRARR(nparams)
		param_text(0)  = 'Bank 1'
		param_text(1)  = 'Bank 2'
		param_text(2)  = 'Bank 3'
		param_text(3)  = 'Bank 4'
		param_text(4)  = 'Rotation'
		param_text(5)  = 'Omega'
		param_text(6)  = 'Flip.'
		param_text(7)  = 'Corr.'
		param_text(8)  = 'Z coils'
		param_text(9)  = 'X coils'
		param_text(10) = 'Y coils'
		param_text(11) = 'Mono1'
		param_text(12) = 'Mono2'
		param_text(13) = 'Mono3'
		param_text(14) = 'Mono4'
		param_text(15) = 'Mono5'
		param_text(16) = 'Mono6'
		param_text(17) = 'Polariser'

; Set up GUI
		D7S_BASE    = WIDGET_BASE(UNAME = 'D7S_BASE_4', $
			      TITLE = "D7 Status", /COLUMN)
		D7S_BASE_0  = WIDGET_BASE(D7S_BASE, UNAME = 'D7S_BASE_0', $
			      /ROW)
		D7S_BASE_1  = WIDGET_BASE(D7S_BASE_0, UNAME = 'D7S_BASE_1', $
			      /COLUMN)
		D7S_LABEL    = LONARR(4)
		D7S_LABEL(0) = WIDGET_LABEL(D7S_BASE_1, UNAME = 'D7S_LABEL_0', $
			      VALUE = label(0), /ALIGN_CENTER, $
			      SCR_XSIZE=500, FONT = ft_bigger)
		D7S_LABEL(1) = WIDGET_LABEL(D7S_BASE_1, UNAME = 'D7S_LABEL_1', $
			      VALUE = label(1), /ALIGN_CENTER, $
			      SCR_XSIZE=500, FONT = ft_bigger)
		D7S_LABEL(2) = WIDGET_LABEL(D7S_BASE_1, UNAME = 'D7S_LABEL_2', $
			      VALUE = label(2), /ALIGN_CENTER, $
			      SCR_XSIZE=500, FONT = ft_biggest)
		D7S_LABEL(3) = WIDGET_LABEL(D7S_BASE_1, UNAME = 'D7S_LABEL_3', $
			      VALUE = label(3), /ALIGN_CENTER, $
			      SCR_XSIZE=500, FONT = ft_bigger)
		D7S_DRAW_0  = WIDGET_DRAW(D7S_BASE_1, UNAME = 'D7S_DRAW_0', $
			      SCR_XSIZE=500, SCR_YSIZE=560)
		D7S_BASE_2  = WIDGET_BASE(D7S_BASE_0, UNAME = 'D7S_BASE_2', $
			      /COLUMN)
		D7S_BASE_3  = WIDGET_BASE(D7S_BASE_0, UNAME = 'D7S_BASE_3', $
			      /COLUMN)
		D7_BOX = LONARR(nparams)
		FOR i = 0, nparams - 1 DO BEGIN 
  			lname = 'D7S_LABEL_' + STRTRIM(STRING(i+1),2) 
  			dummy = WIDGET_LABEL(D7S_BASE_2, UNAME = lname, $
				XOFFSET = 1, YOFFSET = 3, SCR_YSIZE = 30, $
				/ALIGN_LEFT, VALUE = param_text(i), $
				FONT = ft_normal)
  	  		bname = 'D7S_VALUE_' + STRTRIM(STRING(i+1),2) 
  			D7_BOX(i) = WIDGET_TEXT(D7S_BASE_3, UNAME = bname, $
				FRAME = 0, $ 
     			        XOFFSET = 1, YOFFSET = 0, SCR_XSIZE = 100, $
				SCR_YSIZE = 30, /EDITABLE, VALUE = parstr(i), $
				FONT = ft_propor) 
		ENDFOR
		D7_BUT      = WIDGET_BUTTON(D7S_BASE_3, UNAME = 'D7S_BUT', $
			      /ALIGN_LEFT, FONT = ft_bigger, FRAME = 2, $
			      VALUE = 'Print', UVALUE = 0)

		WIDGET_CONTROL, /REALIZE, D7S_BASE
		WIDGET_CONTROL, D7S_DRAW_0, GET_VALUE = win_id
		D.mywin = win_id
		D.heads = D7S_LABEL
		D.boxes = D7_BOX
		D.but = D7_BUT
		XMANAGER, 'dial_d7status_macro', D7S_BASE, /JUST_REG
    	ENDIF
	WIDGET_CONTROL, D.but, GET_UVALUE = printfl

; update headers
	FOR i = 0, 3 DO WIDGET_CONTROL, D.heads(i), SET_VALUE = label(i)	

; reinspect parameters and update boxes and plot
        IF (TOTAL(D.ang) EQ TOTAL(param)) AND (printfl EQ 0) THEN GOTO, finished
	
	FOR i = 0, nparams - 1 DO WIDGET_CONTROL, D.boxes(i), SET_VALUE = parstr(i)
	ang      = param(0:3)*!pi/180.
	omega    = param(5)*!pi/180.
	rotation = param(4)*!pi/180.
	mono4    = param(10)*!pi/180.
	mono5    = param(11)*!pi/180.
	mono6    = param(12)*!pi/180.

; Setup diagram

	IF printfl EQ 0 THEN WSET, D.mywin
	IF printfl EQ 1 THEN BEGIN
		SET_PLOT, 'PS'
		DEVICE, FILENAME = 'd7_status.ps', /COLOR, YSIZE = 20, XSIZE = 15
	ENDIF
	box1x = [-0.05,-0.05,0.05,0.05,-0.05]		;montior 2 arm
	box1y = [-0.5,-1.5,-1.5,-0.5,-0.5]
	box2x = [-0.3,-0.3,0.3,0.3,-0.3]		;chopper box
	box2y = [0.45,0.55,0.55,0.45,0.45]
	box3x = [-0.1,0.1,0.1,-0.1,-0.1]		;polarizer/flipper box
	box3y = [1.2,1.2,0.8,0.8,1.2]
	flipx = -0.1 + FINDGEN(15)/75.			;flipper coil
	flipy = [0.57,0.77]
	circle = INDGEN(200)*2*!pi/180.			;sample position
	rcirc  = FLTARR(200)+0.1
	PLOT, rcirc,circle, /POLAR, BACKGROUND = 0, COLOR = 10, XMARGIN = [3,3], $
	      YMARGIN = [5,5], XRANGE = [-1.2,1.2], YRANGE = [-1.2,1.6], $
	      XSTY = 2, YSTY = 2, TITLE = 'D7 Status - ' + SYSTIME(0), $
	      SUBTITLE = title+'  '+label(3), TICKLEN = 0.0, $
	      XTICKNAME = [' ',' ',' ',' ',' ',' ',' '], $
	      YTICKNAME = [' ',' ',' ',' ',' ',' ',' ',' '], XTICKS = 6, $
	      YTICKS = 7
	OPLOT, box1x, box1y, COLOR=10
	OPLOT, box2x, box2y, COLOR=10
	FOR i = 0,14 DO OPLOT,[flipx(i),flipx(i)], flipy, COLOR = 60
        OPLOT, box3x, [0.78,0.78,0.56,0.56,0.78], COLOR = 10
	OPLOT, box3x, box3y, COLOR=200	
	seg = !pi*22.5/180.				;half-angle of banks
	r1 = 0.6					;inner bank radius
	r2 = 1.5					;outer bank radius
	r1arc = FLTARR(100) + r1
	r2arc = FLTARR(100) + r2
	arc   = INDGEN(100)*2*seg/100.
	r     = [r1,r2arc,r1arc,r1]
	OPLOT, [0,0.3], [0,0.5*!pi - rotation], /POLAR, COLOR=200
	OPLOT, [0,0.2], [0,0.5*!pi - omega],    /POLAR, COLOR=200
	ang(1) = ang(1) + 8.5*!pi/180.			;bank 2 offset
	ang(2) = ang(2) - 1.*!pi/180.
	FOR i=0, 3 DO BEGIN
		theta=(!pi/2.)-[ang(i)-seg,ang(i)-seg+arc,ang(i)+seg-arc,ang(i)-seg]
		OPLOT,r,theta,/POLAR,COLOR=10
	ENDFOR
	monolen = 0.15
	monoyc = 1.8
	monoxc = [monolen*1.5,0,-monolen*1.5]
	monoang = param(14:16)
	monoxmin = monoxc - monolen*cos(monoang*!pi/180.)
	monoxmax = monoxc + monolen*cos(monoang*!pi/180.)
	monoymin = monoyc - monolen*sin(monoang*!pi/180.)
	monoymax = monoyc + monolen*sin(monoang*!pi/180.)
	FOR i=0,2 DO OPLOT, [monoxmin(i),monoxmax(i)],[monoymin(i),monoymax(i)], $
			    COLOR = 255

; Annotations
	xco = 1.0*sin(ang)
	yco = 1.0*cos(ang)
	!P.FONT = 0
	IF(printfl EQ 0) THEN DEVICE, FONT = ft_smaller
	wc = 255
	FOR i = 0, 3 DO $
	XYOUTS,xco(i), yco(i), 'Bank' + STRTRIM(STRING(i + 1),2)+' = '+ $
		 parstr(i), COLOR=wc, ALIGNMENT = 0.5
	xrot = 0.35*cos(0.5*!pi - rotation)
	yrot = 0.35*sin(0.5*!pi - rotation)
	XYOUTS, xrot, yrot, 'Rot = '+parstr(4), COLOR = wc, ALIGNMENT = 0.5
	xom  = 0.25*cos(0.5*!pi - omega)
	yom  = 0.25*sin(0.5*!pi - omega)
	XYOUTS, xom, yom, 'Omega = '+parstr(5), COLOR = wc, ALIGNMENT = 0.5
	XYOUTS, 0.15, 0.70, 'Flip. = '+parstr(6), COLOR = wc, ALIGNMENT = 0
	XYOUTS, 0.15, 0.60, 'Corr. = '+parstr(7), COLOR = wc, ALIGNMENT = 0
	XYOUTS, 0.15, 1.0, 'Polariser = '+parstr(17), COLOR = wc, ALIGNMENT = 0
	XYOUTS, 0.6, 1.7, 'Mono6 = '+parstr(16), COLOR = wc, ALIGNMENT = 0
	XYOUTS, 0.6, 1.8, 'Mono5 = '+parstr(15), COLOR = wc, ALIGNMENT = 0
	XYOUTS, 0.6, 1.9, 'Mono4 = '+parstr(14), COLOR = wc, ALIGNMENT = 0

; Return to X device and print postscript file
	IF printfl EQ 1 THEN BEGIN
		printfl = 0
		WIDGET_CONTROL, D.but, SET_UVALUE = 0
		DEVICE, /CLOSE
		SET_PLOT, 'X'
		cmd = 'lp -d'+lamp_devps+' d7_status.ps'
		PRINT, cmd
		SPAWN, cmd
	ENDIF

	D.ang=param

finished:	
	END

pro dial_d7status_macro_event, event
;** ************
;**
	COMMON local

	WIDGET_CONTROL,event.id,bad_id=ii
	IF (ii NE 0) THEN BEGIN 
		D.init=0
		DialStop 
		RETURN
	ENDIF

      	wWidget =  Event.top

      	FOR i=1,nparams DO BEGIN
      	name='D7S_VALUE_'+STRTRIM(STRING(i),2)
      	IF (Event.id EQ WIDGET_INFO(wWidget, FIND_BY_UNAME=name)) THEN $
      	    IF (TAG_NAMES(Event, /STRUCTURE_NAME) EQ 'WIDGET_TEXT_CH' ) THEN $
      	    	send_command, event,i
      	ENDFOR
	IF (Event.id EQ WIDGET_INFO(wWidget, FIND_BY_UNAME='D7S_BUT')) THEN $
      	    WIDGET_CONTROL, event.id, SET_UVALUE = 1

	

end
pro send_command, event,i
;** ************
;**
	iprint = 0

	Widget_Control, event.id, GET_VALUE=gv
	gv=STRTRIM(gv,2)
	IF(i LE 4) THEN command='bank'+STRTRIM(STRING(i),2)+' '+gv
	IF(i EQ 5) THEN command='rotation'+' '+gv 
	IF(i EQ 6) THEN command='omega'+' '+gv
	IF((i GT 6) AND (i LE 11)) THEN command='b'+STRTRIM(STRING(i-6),2)+' '+gv  
	IF((i GT 11) AND (i LE 17)) THEN command='mono'+STRTRIM(STRING(i-11),2)+' '+gv
	IF(i EQ 18) THEN command='polar'+' '+gv
	C=Dial_mad_send('',0,command)
	IF(iprint GT 0) THEN PRINT,'Sent command: '+command
end
function dial_d7status
;******* ***********
;**

    return, {NAME:'d7status',GENERIC:'mad',TYPE:'log',VALUE:'',FREQUENCY:1,$
	     INIT:0L,MYWIN:0,ANG:FLTARR(18),HEADS:LONARR(4),$
	     BOXES:LONARR(18),BUT:0L}
    end
;*********************
PRO dial_diagram_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_diagram

IF D.pater gt 0 then begin
	DialTag, d=D.pater,  tag='ONOFF'    ,get=onoff
	DialTag, d=D.pater,  tag='FREQUENCY',get=freq
	DialTag, d=D.pater,  tag='DIAGUPD'  ,get=diag
	IF onoff THEN D.frequency=freq else  DialStop
	IF diag gt 0 THEN BEGIN   DialTag, d=D.pater,  tag='DIAGUPD',set=-D.minfreq
	                  ENDIF
ENDIF

end



;*********************
FUNCTION dial_diagram
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'      ;connect to the mad-idl interface
    TYPE='monitor'     ;when DialNewValue() is used, get the monitor
    ONOFF=0            ;state of the Dial 1=running
    FREQUENCY=1.       ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE='Not active' ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0             ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0          ;=1 to record values in file .his
    DURATION=0         ;if >0 then Dial is stopped after running duration seconds

   ;User Variables (optional)
   ;-------------
    INIT=0           ;may be used when started
    MINFREQ=20       ;Minimal frequency (to preserve cpu)

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,$
         INIT:init,XVALUE:0,PATER:0,MINFREQ:minfreq}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_diagram_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
pro DialCommons
;** ***********
;** Global variables
;@lamp.cbk ;Replace this line by next 3 lines for standalone use (No lamp!)
	common c_lamp_info, did_win0
	common c_lamp_w,w0
	common dialshare2,dd,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,d10
	common c_dialet, c_base, c_name, c_output, c_stat, c_freq, c_lim,$
			     c_timon,c_current,c_input,c_basd,c_seq,c_que,c_web
	common c_weweb, gew_act, gew_pth, gew_snd, gew_err, gew_pwd, gew_v
end

;************************************************************ ;+++++++++++
pro DialTag, name ,D=dnum, Si=di, TAG=tag, SET=setv, GET=getv ;+++++++++++
;** *******
;**
;** Set or get the tag value of named Dial
    common dialshare2
getv=0
IF n_elements(name) eq 1 then DialNameToNumber,name,D=dnum
IF n_elements(di)   ne 1 then di=strtrim(string(dnum),2)
IF dnum ge 0  THEN  $
IF n_elements(setv) gt 0 then BEGIN
   IF strupcase(tag) eq "ONOFF" then if setv gt 0 then $
               DialStart,D=dnum else DialStop,    D=dnum      ELSE $
   IF strupcase(tag) eq "VALUE" then DialModValue,D=dnum,setv ELSE $
   IF strupcase(tag) eq "ERROR" then DialModValue,D=dnum,setv,tag="ERROR"$
   ELSE    ii=EXECUTE("d"+di+"."+tag+"=setv")
ENDIF ELSE ii=EXECUTE("getv=d"+di+"."+tag)
end

;************************************************** ;+++++++++++++++++++++
pro DialsFrequency, GET=getv, SET=setv, STOP=stop,$ ;+++++++++++++++++++++
                    START=start, DURATION=lim
;** **************
;**
;** Settings for the main Timer
    common c_dialet

IF n_elements(setv) eq 1 then c_freq=setv
IF n_elements(lim)  eq 1 then c_lim =lim
IF keyword_set(stop)     then c_stat=0
IF keyword_set(start)    then begin c_timon(0)=systime(1)*1000
                              c_stat=1 & Dialet_event,{id:c_base} & endif
getv=c_freq 
end

;***************************************************** ;++++++++++++++++++
function DialNewValue, SETVALUE=setvalue, COMMENT=ctxt ;++++++++++++++++++
;******* ************
;**
;** Get value of the running dial by calling dial_"generic"_read function
    common dialshare2
    common c_dialet

di= strtrim(string(c_current),2)
IF n_elements(ctxt) eq 0 then ctxt=""

DialTag,D=c_current,Si=di,tag="GENERIC",get=generic
DialTag,D=c_current,Si=di,tag="TYPE"   ,get=nome
val=3.14
ii=EXECUTE('val=dial_'+generic+'_read(nome, c_seq, ctxt)')
IF not ii then begin  DialMessage,4,di+":"+nome  & DialStop
ENDIF ELSE IF keyword_set(setvalue) then  DialModValue,val,D=c_current
RETURN,val
end

;************************************************ ;+++++++++++++++++++++++
pro DialModValue, val, NAME=name, d=dnum ,tag=TAG ;+++++++++++++++++++++++
;** ************
;**
;** Used when dial.VALUE changes its type or dimension
    common dialshare2
    common c_dialet

    IF n_elements(name) eq 1 then DialNameToNumber,name,D=dnum
    IF n_elements(dnum) ne 1 then dnum=c_current
      di=strtrim(string(dnum),2)
      sv=SIZE(val)
      IF n_elements(TAG) ne 1 then TAG='VALUE'
      sz=0 & ii=EXECUTE('sz=SIZE(d'+di+'.'+TAG+')')
      IF (sz(sz(0)+1) ne sv(sv(0)+1)) or  $
         (sz(0) ne sv(0)) or (sz(sz(0)+2) ne sv(sv(0)+2)) then BEGIN
          elsa = ''
          tlist=[''] & ii=EXECUTE('tlist=strupcase(tag_names(d'+di+'))')
          FOR k=0,n_elements(tlist)-1 DO BEGIN CASE tlist(k) OF
              TAG:
              ELSE: elsa =elsa+','+tlist(k)+':d'+di+'.'+tlist(k)
              ENDCASE
          ENDFOR
                 ii=EXECUTE('d'+di+'={'+TAG+':val'+ elsa +'}')
      ENDIF ELSE ii=EXECUTE('d'+di+'.' +TAG+'=val')
end

;************************** ;+++++++++++++++++++++++++++++++++++++++++++++
pro DialStop,  name, D=dnum ;+++++++++++++++++++++++++++++++++++++++++++++
;** ********
;** Stop the Dial
    common dialshare2
    common c_dialet
IF  n_elements(name) eq 1 then DialNameToNumber,name,D=dnum
IF  n_elements(dnum) ne 1 then dnum=c_current
IF  dnum gt 0 then BEGIN 
    di= strtrim(string(dnum),2) & ii= EXECUTE('d'+di+'.ONOFF=0')
    DialMessage,6,di            & ENDIF
end

;************************** ;+++++++++++++++++++++++++++++++++++++++++++++
pro DialStart, name, D=dnum ;+++++++++++++++++++++++++++++++++++++++++++++
;** *********
;** Start or resume the Dial
    common dialshare2
    common c_dialet
IF  n_elements(name) eq 1 then DialNameToNumber,name,D=dnum
IF  n_elements(dnum) ne 1 then dnum=c_current
IF  dnum gt 0 then BEGIN
    di= strtrim(string(dnum),2)    & freq=0
    ii= EXECUTE('d'+di+'.ONOFF=1') & ii=EXECUTE('freq=d'+di+'.FREQUENCY')
    c_timon(dnum)=systime(1)*1000  & DialMessage,7,di
    IF freq gt 0 THEN Dialet_event,{id:c_basd(dnum,0)} $
                 ELSE Dialet_event,{id:c_base}
ENDIF & end

;************************************************* ;++++++++++++++++++++++
function DialControl, command, D=dnum, CHECK=check ;++++++++++++++++++++++
;******* ***********
;**
;** Back control to the instrument
    common dialshare2
    common c_dialet

IF n_elements(dnum)  ne 1 then dnum =c_current
IF n_elements(check) ne 1 then check=0.
di     =strtrim(string(dnum),2)
generic='' & DialTag,D=dnum,Si=di,tag="GENERIC",get=generic
nome=''    & DialTag,D=dnum,Si=di,tag="TYPE"   ,get=nome
name=''    & DialTag,D=dnum,Si=di,tag="NAME"   ,get=name
val=3.14
if c_web then WebDo,'snd',command,dnum
ii=EXECUTE('val=dial_'+generic+'_send(nome, check, command, name)')
IF not ii then BEGIN val=0 & DialMessage,5,di+":"+name & DialStop & ENDIF
RETURN,val
end

;************************** ;+++++++++++++++++++++++++++++++++++++++++++++
pro DialClear, name, D=dnum ;+++++++++++++++++++++++++++++++++++++++++++++
;** *********
;** Remove the Dial
    common c_dialet
IF  n_elements(name) eq 1 then DialNameToNumber,name,D=dnum
IF  n_elements(dnum) ne 1 then dnum=c_current
IF  d_num gt 0 then BEGIN DialStop ,D=dnum & c_name(d_num)="" & ENDIF
end

;********************************* ;++++++++++++++++++++++++++++++++++++++
pro DialMacro, name, D=dnum, Si=di ;++++++++++++++++++++++++++++++++++++++
;** *********
;**
;** Execute the macro of named Dial
    common dialshare2
    common c_dialet
    common c_lamp_w
IF n_elements(name) eq 1 then DialNameToNumber,name,D=dnum else name=''
IF n_elements(dnum) ne 1 then dnum=c_current
CATCH,stat & if stat ne 0 then begin catch,/cancel & DialStop
                                     DialMessage,0 & return & endif
IF dnum gt 0 then BEGIN
   c_basd(dnum,1)=c_current    & c_current=dnum  & orig=""
   IF n_elements(di) ne 1 then di= strtrim(string(dnum),2)
   DialTag,D=dnum,Si=di,tag="NAME"  ,get=name
   DialMessage,8,name
   DialTag,D=dnum,Si=di,tag="ORIGIN",get=orig
   ii = EXECUTE('dial_'+orig+'_macro,d'+di)
   IF ii eq 0 then begin DialMessage,9,name & DialStop
   ENDIF ELSE BEGIN
	sz=0 & vl=0   & ii=EXECUTE('sz=size(d'+di+'.VALUE)') & nl=sz(sz(0)+2) 
	IF nl le 5 then ii=EXECUTE('vl=d'+di+'.VALUE') $
	           else ii=EXECUTE('vl=d'+di+'.VALUE(0:4)')
	str=name+"="+string(vl,/print) & IF nl gt 5 then str=str+" ->"
	IF n_elements(w1) gt 0 then ii=EXECUTE('w'+di+'=d'+di+'.VALUE');Lamp

	if c_web then begin
		if (sz(sz(0)+1) eq 7) or (nl eq 1) then begin
			if nl    gt 1  then ii=EXECUTE('vl=d'+di+'.VALUE')
			if nl    gt 1  then WebDo,'log',vl ,dnum
			if vl(0) ne '' then WebDo,'val',str,dnum
		endif    else ii=EXECUTE('WebDo,"wks",str,dnum,d'+di+'.VALUE')
	endif

	IF (vl(0) ne '') or (nl gt 1) then begin
	  DialMessage ,10,str
	  hiss=0  & DialTag, D=dnum,Si=di,tag="HISTORY",get=hiss
	  IF hiss then begin u=-1
	   on_ioerror,misopn & openw,u,"dial_"+name+".his",/append,/get_lun
	   ii=EXECUTE('printf,u,d'+di+'.VALUE')
	   misopn: IF u gt 0 then free_lun,u
	ENDIF  &  ENDIF
   ENDELSE
   c_current=c_basd(dnum,1)
ENDIF & end

;*********** ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
pro DialWSet ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;** ********
;**
;** Select the main draw window
    common c_lamp_info
IF  n_elements(did_win0) eq 1 then Wset,did_win0 ;Lamp
end

;**************************** ;+++++++++++++++++++++++++++++++++++++++++++
function DialOn, Dial, D=dnum ;+++++++++++++++++++++++++++++++++++++++++++
;******* ******
;**
;** Check fo a user input
    common c_dialet
R=1
P_DIA_WIDGET, "GET_ev",c_input,resp
IF resp then BEGIN     Dialet_event,{id:c_input}
   IF n_tags(Dial)     gt 1 then dnum=Dial.number
   IF n_elements(dnum) ne 1 then dnum=c_current
   DialTag,D=dnum,TAG="ONOFF",GET=R
   IF R then BEGIN
      DialTag,D=dnum,TAG="FREQUENCY",GET=freq
      IF freq eq 0 then BEGIN 
         DialsFrequency, GET=freq
         IF (freq le 0) or (c_stat eq 0) then R=0
      ENDIF
   ENDIF
ENDIF
RETURN,R
end

;*********************************************************** ;++++++++++++
pro DialInit, name, D=dnum, NEW=newed, PATH=pth, herits=diaH ;++++++++++++
;** ********
;**
;** Initiates a Dial from its file
    common dialshare2
    common c_dialet

IF n_elements(c_name) eq 0 then Dialet, /MAP
IF n_elements(name)   ne 1 then name  = "NoName"
IF n_elements(newed)  ne 1 then newed = strlowcase(name)
IF n_elements(pth)    ne 1 then pth   = ""
IF n_elements(dnum)   ne 1 then DialNameToNumber,newed,/find,D=dnum
dial=""
ii  =EXECUTE ("dial=dial_"+name+"()")
IF ii eq 1 then BEGIN
   tlist   =strupcase(tag_names(dial))

   idx     =where    (tlist eq 'INHERITS')
   IF idx(0) ge 0 then IF dial.inherits gt ' '  then  BEGIN  diaG=''
          DialInit , string (dial.inherits) , d=dnum, herits=diaG
          DialMix  , dial ,  diaG
          tlist=strupcase(tag_names(dial)) & ENDIF
   IF n_elements(diaH) gt 0 then BEGIN DialMix,diaH,dial & RETURN & ENDIF

   named   =newed  & onoff    =0  & generic =name   & type     =name
   value   =0.     & error    =0. & elsa    =""     & frequency=0.
   history =0      & duration =0. & plot    =0      & unit     =""
   upperlim=0.     & lowerlim =0.

   FOR k=0,n_elements(tlist)-1 DO CASE tlist(k) OF
                     "NAME":
                     "PATH":
                     "NUMBER":
                     "ONOFF":    onoff    =fix   (dial.onoff)
                     "VALUE":    value    =       dial.value
                     "ERROR":    value    =       dial.error
                     "PLOT":     plot     =fix   (dial.plot)
                     "UNIT":     unit     =string(dial.unit)
                     "UPPERLIM": upperlim =float (dial.upperlim)
                     "LOWERLIM": lowerlim =float (dial.lowerlim)
                     "GENERIC":  generic  =string(dial.generic)
                     "TYPE":     type     =string(dial.type)
                     "FREQUENCY":frequency=float (dial.frequency)
                     "HISTORY":  history  =fix   (dial.history)
                     "DURATION": duration =float (dial.duration)
                      ELSE:      elsa=elsa+","+tlist(k)+":dial."+tlist(k)
                      ENDCASE
   di=strtrim(string(dnum),2)
   ii=execute('d'+di+'={NAME:named,ORIGIN:name,GENERIC:generic'+$
             ',TYPE:type,PLOT:plot,VALUE:value,ERROR:error'    +$
             ',UNIT:unit,UPPERLIM:upperlim,LOWERLIM:lowerlim'  +$
             ',FREQUENCY:frequency,DURATION:duration,PATH:pth' +$
             ',ONOFF:onoff,HISTORY:history,NUMBER:dnum'+elsa   +'}')
   IF ii eq 1 then BEGIN
      c_name(dnum)=named
      DialMessage,11,di+":"+named
      DialTag,D=dnum,Si=di,TAG="ONOFF", SET=onoff
   ENDIF ELSE DialMessage,3,named

ENDIF ELSE DialMessage,2,name
end

;********************************** ;+++++++++++++++++++++++++++++++++++++
pro WebOn, PATH=wpth ,PASSWORD=pass ;+++++++++++++++++++++++++++++++++++++
;** *****
common c_dialet
common c_weweb

if n_elements(gew_pth) ne 1 then gew_pth='c:\User\didier\d7\'
if n_elements(gew_pwd) ne 1 then gew_pwd=''
if n_elements(   wpth) eq 1 then gew_pth=  wpth
if n_elements(   pass) eq 1 then gew_pwd=  pass
on_ioerror,misopn
openw,u,gew_pth+'geo_d_0.web',/get_lun & free_lun,u
list=findfile(gew_pth+'geo_d_*',count=nn)
if  nn gt 0 then bid=sys_dep('DELIST',list)
if  n_elements(gew_v) eq 0 then begin
    par1='' & ii=execute('par1=dial_pad_init()') & sz=SIZE(par1)
    if (sz(0) eq 2) and (sz(1) eq 5) then begin
	  openw,u,gew_pth+'dial_pad.web',/get_lun
	  for j=0,sz(2)-1 do for i=0,sz(1)-1 do printf,u,par1(i,j)
	  free_lun,u & endif
endif
if sys_dep ("MACHINE") eq  "vms" then gew_v=";1" else gew_v=""
gew_act=100 & gew_snd=['-'] & gew_err='-'
if  gew_pwd gt ' ' then begin DialInit ,"webon"
                              DialTag  ,"webon",tag="WEBPTH",set=gew_pth+$
							"geo_webon.txt"
                              DialTag  ,"webon",tag="PWD"   ,set=gew_pwd
                              DialStart,"webon" & endif
WebDo,"sta","on",0
c_web=1 & return
misopn: DialErrMes
end

;********* ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
pro WebOff ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;** ******
common c_dialet
if c_web gt 0 then WebDo,"sta","off",0
c_web=0
gew_pwd='' & DialStop,"webon"
end

;****************************** ;+++++++++++++++++++++++++++++++++++++++++
pro WebDo, flg, val, dnum, matx
;** *****
common c_dialet
common dialshare2
common c_weweb
case flg of
'act':gew_act=100 + 100-val
'err':gew_err=val
'snd':gew_snd=val
'log':begin openw,u,gew_pth+'geo_d_'+strtrim(dnum,2)+'.txt'+gew_v,/get_lun
	      printf,u, val
	      free_lun,u & end
 else:begin di=strtrim(dnum,2)			;'gif' 'val' 'wks'
	DialTag,D=dnum,Si=di,tag="FREQUENCY",get=freq
	DialTag,D=dnum,Si=di,tag="DURATION" ,get=dur
	DialTag,D=dnum,Si=di,tag="HISTORY"  ,get=his
	img=n_elements(matx)
	on_ioerror,misopn
	if img gt 1 then $
	   if flg ne 'wks' then write_gif,gew_pth+'geo_d_'+di+'.gif'+gew_v,$
							    matx,gew_r,gew_g,gew_b
	openw,u,gew_pth+'geo_d_'+di+'.web'+gew_v,/get_lun
	printf,u, gew_act,c_freq,c_lim
	printf,u, freq,dur,his,' '+flg
	printf,u, val
	if gew_err    ne '' then begin printf,u,'err:'+gew_err & gew_err=''
					 endif
	if gew_snd(0) ne '' then begin printf,u,'snd:'+gew_snd & gew_snd=['']
					 endif
	free_lun,u & end
endcase
misopn:
end

pro DialMix, A,B ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;** *******
;** Mixe Dial B into Dial A

    nA=n_tags(A)  & nB=n_tags(B)
    IF nB lt 1 then RETURN & IF nA lt 1 then BEGIN A=B & RETURN & ENDIF
    elsa=''
    lA=strupcase(tag_names(A))
    FOR k=0,nA-2 DO  elsa =elsa    + lA(k)   +':A.'+lA(k)+','
                     elsa =elsa    + lA(nA-1)+':A.'+lA(nA-1)
    lB=strupcase(tag_names(B))
    FOR k=0,nB-1 DO  IF (where(lA eq lB(k)))(0) eq -1 then $
                     elsa =elsa+','+ lB(k)   +':B.'+lB(k)
    ii=EXECUTE('A={'+ elsa +'}')
end

pro DialMessage ,flg, str ;+++++++++++++++++++++++++++++++++++++++++++++++
;** ***********
;**
;** Message output
    common c_dialet
msg=""
CASE flg OF
0:   msg=!err_string
1:   msg="Executed: "+str
2:   msg="Dial file dial_"+str+".pro ->"+!err_string
3:   msg="Dial "+str+" failed setting attributes ->"+!err_string
4:   msg="Dial "+str+" failed reading new value ->"+!err_string
5:   msg="Dial "+str+" failed sending control ->"+!err_string
6:   P_DIA_WIDGET, "SET_va",c_basd(long(str),0)," "+str
7:   P_DIA_WIDGET, "SET_va",c_basd(long(str),0),"+"+str
8:   msg="Dial "+str
9:   msg="Dial "+str+" failed executing macro ->"+!err_string
10:  msg=str
11:  msg="Dial "+str+" is loaded ..."
12:  msg="Error-code"+str+" ->"+!err_string
ELSE:
ENDCASE
IF   c_basd(0,0)  eq 1 then P_DIA_WIDGET, "SET_va",c_output,msg $
ELSE BEGIN	IF flg eq 6 then msg="Dial "+str+" is stopped ..."
		IF flg eq 7 then msg="Dial "+str+" is started ..."
		IF flg ne 8 then begin print,msg
		 IF c_web then IF flg ne 10 then WebDo,'err',msg
		ENDIF
ENDELSE  & end

pro DialNameToNumber, name, FIND=find, D=knam ;++++++++++++++++++++++++++++
;** ****************
;**
;** Given the name of a dial, return its number
;** If keyword_set find then  return a free number if no name match
    common c_dialet
    common dialshare2

kfree= 1 & knam=-1

FOR i= n_elements(c_name)-1 , 1 ,-1 DO IF c_name(i) eq name then knam =i $
                                  ELSE IF c_name(i) eq ""   then kfree=i

IF (knam lt 0) and (keyword_set(find)) then knam=kfree
end

pro Dialet_event, event, uv ;+++++++++++++++++++++++++++++++++++++++++++++
;** ************
;**
;** Event handler
    common dialshare2
    common c_dialet

IF n_elements(uv) eq 0 then P_DIA_WIDGET, "GET_uv", event.id, uv
CATCH,stat
IF stat ne 0 then DialMessage,0 ELSE BEGIN
CASE uv(1) OF
690: BEGIN P_DIA_WIDGET, "GET_va", event.id, comd
           ii=EXECUTE(comd(0))      ;COMMAND INPUT -----------------------
           IF ii ne 1 then DialMessage,0 ELSE DialMessage,1,comd(0)
           comd="                         ;"+strtrim(comd(0),2)
           P_DIA_WIDGET, "SET_va", event.id, strmid (comd,0,100)
     END
691: BEGIN c_seq=systime(1)
           IF uv(2) lt 0 then BEGIN ;GENERAL  TIMER ----------------------
            IF c_lim gt 0 then IF c_seq*1000-c_timon(0) gt c_lim*1000 $
                          then DialsFrequency,/STOP
            IF c_stat     then BEGIN
             P_DIA_RETIM ,event.id, c_freq
             dnum =0 & R  =1
             FOR i=1,n_elements(c_name)-1 DO IF c_name(i) gt "" THEN BEGIN
              di  =strtrim(string(i),2) & i0=i
              onoff=0 & DialTag,D=i0,Si=di,tag="ONOFF"    ,get=onoff
              IF onoff then BEGIN
               freq=0 & DialTag,D=i0,Si=di,tag="FREQUENCY",get=freq
                IF freq le 0 then BEGIN
                   IF dnum gt 0 then R=DIALON(d=i0)
                   IF c_stat then if R then BEGIN dnum =i
		                                DIALMACRO,D=dnum,Si=di & ENDIF
                ENDIF
              ENDIF
             ENDIF
             tot=c_freq-(systime(1)-c_seq)
             IF tot lt 0 then if c_freq gt 0 then P_DIA_RETIM,event.id,tot
            ENDIF
           ENDIF ELSE BEGIN         ;SPECIFIC TIMER ----------------------
            dnum =uv(2) & di=strtrim(string(dnum),2)
            freq = 0    & DialTag ,D=dnum,Si=di,tag="FREQUENCY",get=freq
            durat= 0    & DialTag ,D=dnum,Si=di,tag="DURATION" ,get=durat
            IF durat gt 0 then IF  c_seq*1000-c_timon(dnum) gt durat*1000 $
                     then DialStop,D=dnum
            onoff= 0    & DialTag ,D=dnum,Si=di,tag="ONOFF"    ,get=onoff
            IF freq  gt 0 then IF  onoff then  BEGIN
		   P_DIA_RETIM , event.id , freq
               DIALMACRO   , D=dnum   , Si=di
               totim=(c_freq*c_stat)+freq - (systime(1)-c_seq)
               if totim lt 0 then P_DIA_RETIM ,event.id, totim
            ENDIF
           ENDELSE
     END
694: P_PAD_EVENT, event, uv
ELSE:
ENDCASE
ENDELSE
end

pro P_DIA_RETIM, id,freq ;++++++++++++++++++++++++++++++++++++++++++++++++
;** ***********
;** RE-TIMER
			widget_control,bad_id=ii,id,/CLEAR_EVENTS
if freq gt 0 then	widget_control,bad_id=ii,id, TIMER=freq	else $
if freq lt 0 then	widget_control,bad_id=ii,id, TIMER=0.05<(-freq)
end

pro P_DIA_WIDGET, flg, id, val ;++++++++++++++++++++++++++++++++++++++++++
;** ************
;** Miscelaneous widget controls
CASE flg OF
'GET_ev':BEGIN evv=widget_event(id,/nowait,bad_id=ii)
               IF evv.id eq id then val=1 ELSE val=0 & END
'SET_va':widget_control,id,set_value =val ,bad_id=ii
'GET_va':widget_control,id,get_value =val ,bad_id=ii
'GET_uv':widget_control,id,get_uvalue=val
ELSE:
ENDCASE
end

pro P_PAD_EVENT, event, uv ;++++++++++++++++++++++++++++++++++++++++++++++
;** ***********
;**
common dialshare2

widget_control,uv(3),get_uvalue=PadTab
ncomm=-1

if (uv(4) ne 100) and ((PadTab(2,uv(8)) eq "t") or $
			(PadTab(2,uv(8)) eq "c")) then begin
	k=uv(8)
	str8="PAD_" +strtrim  (string(k),2)
	if xregistered(str8) le 0 then begin
	   padr=str_sep    (strlowcase(PadTab(1,k)),"<cr>")
	   padb=widget_base(title=PadTab(0,k),resource_name='lamp',/column)
	   for r=0,n_elements(padr)-1 do begin
		padt=str_sep      (Padr(r),"~")
		n   =n_elements   (padt)
		if (n/2)*2 ne n then padt=[padt,padt(n-1)]
		n   =n_elements   (padt) & biti =lonarr(n)
		padg=widget_base(padb,/row,resource_name='geo',/frame)
		for i=0,n-1,2 do begin
		 bid=widget_base (padg,/column)
		 bil=widget_label(bid ,value=padt(i))      & biti(i)  =bil
		 bit=widget_text (bid ,value=padt(i+1),/editable, $
		                xsize=strlen(padt(i+1))+3) & biti(i+1)=bit
		endfor
		if r eq 0 then bito=biti else bito=[bito,-1,-1,biti]
	   endfor
	   ivv  =uv & ivv(4)=100
	   padg =widget_base  (padb,/row,resource_name='geo')
	   bid  =widget_button(padg,value='SEND ->',uvalue=ivv)
	   err  =widget_label (padg,value='       ',xsize =250)
	   bito =[bito,err]
	   widget_control,padb,set_uvalue=bito,/realize
	   XMANAGER, str8,padb,event_handler="Dialet_event",/just_reg
	endif
endif else begin
	ncomm=uv(8)
	if (uv(4) ne 100) then  comm =PadTab(1,uv(8)) $	;from button
	else begin    como='' & comm =[''] & r=0 & sep=""	;from GUI
		widget_control, event.top, get_uvalue=bito
		nbito= n_elements(bito)-1
		for j=1,nbito-1,2 do begin	   comi=''
		  if bito(j) gt 0 then begin
			widget_control,bad_id=ii,bito(j-1),get_value=labi
			widget_control,bad_id=ii,bito(j)  ,get_value=comi
			comi   = strtrim (comi(0),2)
			comm(r)= comm(r) +comi+' '
			if comi eq '' then ncomm=-1
			como   = como+sep+labi(0)+"~"+comi & sep="~"
		  endif else begin r=r+1  & sep="" 
			comm   =[comm,''] & como=como+"<cr>" & endelse
		endfor
		PadTab(1,uv(8))=como
		widget_control,uv(3),set_uvalue=PadTab
		if ncomm lt 0	then txt ='!!! Cmd is incomplete.' $
				else txt ='Sending ...'
		widget_control, bito(nbito),set_value =txt
	endelse
endelse

if ncomm ge 0 then begin pros=[uv(5),uv(6)]
   d0={GENERIC:PadTab(3,ncomm),NAME:PadTab(0,ncomm),TYPE:'PAD',PROS:pros}
   on_ioerror, mischk & check=0. & check=float(PadTab(4,ncomm)) & mischk:
   R=0 & ii=execute('R = DialControl(comm,  d=0, check=check)')
   if (R lt 0) or (R gt 1) then txt="err-code "+string(R) else txt='Sent'
   DialMessage,12,txt
endif
end

pro P_PAD_CREATE, aque,bido,cque ;++++++++++++++++++++++++++++++++++++++++
;** ************
;**
	par1='' & ii=execute('par1=dial_pad_init()')
	sz=SIZE(par1)
	if (sz(0) eq 2) and (sz(1) eq 5) then begin

	   cque = widget_base  (aque ,/row,frame=3)

	   widget_control,bido,set_value=par1(0,0)
	   PROX=[-1L,0]
	   uvv =[-88,694,0,cque]
	   widget_control,cque,set_uvalue=par1

	   i=1 & k=0 & n_e=n_elements(par1)/5
	   par1=[[par1],['','','','','']]
	   while i  lt n_e do begin
		val=par1(0,i)
		j=k/2 & if j*2 eq k then dque=widget_base  (cque ,/column)
		eque  = widget_base  (dque ,/row)
		k=k+1
;**	level1
		if par1(2,i) eq '-' then begin
		  bid1= widget_button(eque ,value=val ,menu=2)
		  i=i+1
		  while strpos(par1(0,i),'-') eq 0 do begin
		   val =strmid(par1(0,i),1,15)
;**	level2
		   if par1(2,i) eq '-' then begin
			bid2=widget_button(bid1 ,value=val ,menu=2)
			i=i+1
			while strpos(par1(0,i),'--') eq 0 do begin
			  val =strmid(par1(0,i),2,15)
;**	level3
			  if par1(2,i) eq '-' then begin
				bid3=widget_button(bid2 ,value=val ,menu=2)
				i=i+1
				while strpos(par1(0,i),'---') eq 0 do begin
				  val =strmid(par1(0,i),3,15)
				  bid4=widget_button(bid3 ,value=val,uvalue=$
					[uvv,i,PROX,bido,i]) & i=i+1
				endwhile
			  endif else begin
				bid3=widget_button(bid2 ,value=val,uvalue=$
				     [uvv,i,PROX,bido,i]) & i=i+1 & endelse
			endwhile
		   endif else begin
			bid2=widget_button(bid1 ,value=val,uvalue=$
				[uvv,i,PROX,bido,i]) & i=i+1 & endelse
		  endwhile
		endif else begin
		  bid = widget_button(eque ,value=val,uvalue=$
			 [uvv,i,PROX,bido,i]) & i=i+1 & endelse
	   endwhile
	endif
end

pro Dialet, MAP=map ,PAD=pad ;++++++++++++++++++++++++++++++++++++++++++++
;** ******
;** Initiate the User Interface (Visible if map=1)
;**
;** c_name is a string array containing the Dial names
;** c_basd  is a baseID array used to keep the timer events & c_current
;** c_output is a baseID for message output
;** c_input  is a baseID for command input
;** c_current is the running Dial (saved in c_basd for recurrent calls)
;** c_stat, c_freq, c_lim are the onoff,frequency,duration of main timer
;** c_timon is a double array containing start time for each dial
;** c_seq   is the start time for current loop (used in DialNewValue)
;** c_base  is the main base
    common c_dialet
    common c_lamp_info

IF n_elements (c_name)   eq 0 then begin c_name =STRARR(11) & c_current=0
                                         c_stat =1          & c_freq=0D
                                         c_timon=DBLARR(11) & c_lim =0
                                         c_seq  =0D         & c_web =0
                                         c_basd =LONARR(11,2) & endif
IF not keyword_set(pad)  then pad= 0
IF not keyword_set(map)  then map=pad &  c_basd(0,0)=map
IF XREGISTERED("DIALET") eq 0 then begin c_que=0
   c_base  = widget_base   (title="Dialet Control",MAP=0,/column,$
				resource_name="lamp"   ,uvalue=[-88,691,-1])
   c_input = widget_text   (c_base,xsize=52,/editable,uvalue=[-88,690, 1])
   c_set   = widget_base   (c_base,/row)
   FOR i=1,n_elements(c_name)-1 DO c_basd(i,0)= $
             widget_label  (c_set ,value="    ",uvalue=[-88,691, i])
   c_output= widget_label  (c_base,xsize=52*10 , value=" ")
             widget_control,c_base,/REALIZE
          XMANAGER,"DIALET",c_base,/just_reg
ENDIF
IF (pad and (c_que eq 0)) then P_PAD_CREATE, c_base, c_input, c_que
widget_control,c_base,MAP=map
IF map then XMANAGER
end
;*********************
PRO dial_example_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_status

    V=DialNewValue()
    print, V
end



;*********************
FUNCTION dial_example
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='flagus'    ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0 	     ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_status_macro :
;** *************
;** V=DialNewValue([/SETVALUE, COMMENT=txt])   ;Get a new value from DIAL_'generic'_READ
;**                                            (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process

;    FLIPPER the Dial
;    ****************

pro  DIAL_FLIPPER_D17_MACRO, D
;**  ********************
;**

	COMMON	flipper_plot, xp, yp

	CATCH,stat & if stat ne 0 then begin print,!err_string & CATCH,/cancel & return & endif

	iprint =1

	maxiter=5

	var    =D.scanvar
	c_time =STRING(D.c_time)

	IF (NOT D.started) THEN BEGIN
		D.started=1	& D.niter=0
		D.current(*)=[0,.5,2.4,0.2,.6,.1,1.0,.2,0,0]
		D.current(0)=D.current(1)
		B           =D.current(0)
		IF (iprint GT 0)   THEN PRINT,'Start first scan'
		command=D.initialise	& C=DialControl(command,CHECK=0.5)
		if C lt 0 then print,'Mad is un-reachable !!! sending "'+command+'"''
		command=var+' '+STRING(B)	& C=DialControl(command,CHECK=0.5)
		wait,0.5
                command='co '+c_time+' t nos'	& C=DialControl(command,CHECK=0.5)
		D.type='t_res' & dims=DialNewValue()
                D.DIMX=dims.par_tof(4) - dims.par_tof(3) +1
                D.DIMY=dims.par_tof(2) - dims.par_tof(1) +1
                wait,D.delay
		DialWSet
	ENDIF ELSE BEGIN
		B	=D.current(0)
		Bmin	=D.current(1)
		Bmax	=D.current(2)
		dB	=D.current(3)
		B1range	=D.current(4)
		dB1	=D.current(5)
		B2range	=D.current(6)
		dB2	=D.current(7)
		lambda	=D.lambda
		IF (iprint GT 0) THEN BEGIN
			PRINT,'B=',B,' Bmin=',Bmin,' Bmax=',Bmax,' dB=',dB,' var=',var
			FOR i=0,3 DO PRINT,'D.current(',i,')=',D.current(i)
			PRINT,'D.scanvar=', D.scanvar
			PRINT,'Check counting status'
		ENDIF
		D.type='flagus' & status=DialNewValue()
		
		IF (status EQ 0) THEN BEGIN
	            wait, D.delay
;-------------------get monitor counts and plot them------------------
			D.type='data'  & monitor=DialNewValue()
			V=total(monitor(0:D.dimx*D.dimy-1))  & D.value=V  & D.error=SQRT(V)
			D.arse=monitor(0:D.dimx*D.dimy-1)
			print, V
			IF (B EQ Bmin) THEN BEGIN
				 xp=[B,B]  & yp=[V,V]
				 xp=[B]    & yp=[V]
			ENDIF ELSE BEGIN
				xp=[xp,B]  & yp=[yp,V] & ENDELSE
			ep=SQRT(yp)
			DialWSet
			PLOT, xp, yp, PSYM=2, XRANGE=[Bmin,Bmax], YRANGE=[0,MAX(yp)], XTITLE=var, $
				YTITLE='M2 Counts', TITLE='Iteration no. '+STRTRIM(STRING(D.niter+1),2)+' - scan of '+var
			ERRPLOT, xp, yp-ep, yp+ep
;-------------------increment current and start new count-------------
			IF (B LT Bmax) THEN BEGIN
;		    --------continue present scan
				B=B+dB
				command=var+' '+STRING(B)	& C=DialControl(command)
				command='co '+c_time+' t nos'	& C=DialControl(command)
			ENDIF ELSE BEGIN
;		    --------end scan, fit minimum, set current and start new scan
				D.niter=D.niter+1
				fit_parabola,xp,float(yp),bestfit,B00	& B0=B00(0) & ymin=B00(1)
				B0=FLOAT(ROUND(B0*100.))/100.
;				DialWSet
				OPLOT, xp, bestfit, PSYM=0, LINESTYLE=0
				ch='Minimum at '+var+' ='+STRING(B0)
				XYOUTS, B0, ymin, ch
				command=var+' '+STRING(B0)	& C=DialControl(command,CHECK=0.5)
				if C lt 0 then print,'Mad is un-reachable !!! sending "'+command+'"'
				IF (var EQ 'B1') THEN BEGIN
					D.bestB1=B0	& var='B2'
				ENDIF ELSE BEGIN
					D.bestB2=B0	& var='B1'
				ENDELSE
				IF (D.niter EQ 5) THEN BEGIN
					PRINT,'Best currents found: B1=',D.bestB1
					PRINT,'                     B2=',D.bestB2
					PRINT,'finished'
					dialstop
					RETURN
				ENDIF ELSE IF (D.niter EQ 1) THEN BEGIN
					Bmin=3	& Bmax=6 & dB=0.25
				ENDIF ELSE IF (2*(D.niter/2) EQ D.niter) THEN BEGIN
					Bmin=D.bestB1-B1range	& Bmax=D.bestB1+B1range & dB=dB1
				ENDIF ELSE BEGIN
					Bmin=D.bestB2-B2range	& Bmax=D.bestB2+B2range & dB=dB2
				ENDELSE
				B=Bmin
				command=var+' '+STRING(B)	& C=DialControl(command,CHECK=0.5)
				wait, 0.5
				command='co '+c_time+' t nos'	& C=DialControl(command,CHECK=0.5)
			ENDELSE
		ENDIF
		D.scanvar=var
		D.current(0)=B
		D.current(1)=Bmin
		D.current(2)=Bmax
		D.current(3)=dB
	ENDELSE

	END

pro fit_parabola, xp,yp, bestfit, xymin
;** ************
	s=SIZE(xp)	& np=s(1)
	dx=xp(1)-xp(0)

	A0=INT_TABULATED(xp,yp)
	A1=INT_TABULATED(xp,yp*xp)
	A2=INT_TABULATED(xp,yp*xp^2)

	x1=xp(0)	& x2=xp(np-1)
	d1=x2-x1
	d2=(x2^2-x1^2)/2.
	d3=(x2^3-x1^3)/3.
	d4=(x2^4-x1^4)/4.
	d5=(x2^5-x1^5)/5.

	A=[[d3,d2,d1],[d4,d3,d2],[d5,d4,d3]]
	B=[A0,A1,A2]
	R=CRAMER(A,B)

	bestfit=R(0)*xp^2+R(1)*xp+R(2)
	x0=-0.5*R(1)/R(0)
	ymin=R(0)*x0^2+R(1)*x0+R(2)

	xymin=[x0,ymin]
	END




;******* ********************************
;******* ********************************
function DIAL_FLIPPER_D17
;******* ********************************
;******* ********************************
;**
;** 
;** Output D is the dial structure returned for DialInit
;********* *********************************************

name     ="flipper"
generic  ="mad"
type     ="data"
onoff    = 0
value    = 0L
error    = 0L
frequency= 6
duration = 0.0
history  = 0
plot     = 100
dimx     =0
dimy     =0
arse     =LONARR(15730)
delay    =2.

                ;** Other tags used in your procedure DIAL_TEMPLATE1_MACRO:
                ;** ******************************************************
                unit      ="counts"	;The dial string unit
                lowerlim  =0.          ;The dial lower limit value
                upperlim  =0.	;The dial upper limit value

		started   = 0
		current   = FLTARR(10)  ;[,,,initial dB,B1range,dB1,B2range,dB2]
		scanvar   = 'B1'
		initialise='B2 2.5'
		c_time    = 1		; counting time per point
		lambda    = 5.7

D={NAME:name, GENERIC:generic  , VALUE:value    , ONOFF:onoff    , FREQUENCY:frequency,$
              DURATION:duration, UNIT:unit      , HISTORY:history, UPPERLIM:upperlim  ,$
              LOWERLIM:lowerlim, PLOT:plot      , TYPE:type      , STARTED:started    ,$
              CURRENT:current  , SCANVAR:scanvar, INITIALISE:initialise,$
              C_TIME:c_time    , LAMBDA:lambda  , NITER:0,BESTB1:0.,BESTB2:0.,$
              dimx:DIMX,dimy:DIMY,arse:ARSE,delay:DELAY}
RETURN ,D
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO  DIAL_FLIPPER_D7_MACRO, D
;
; 	Scans flipper currents for zpo/xyz setups
;
;						KHA/JRS 22/5/02
;
;-------------------------------------------------------------------------------
;*******************************************************************************
 
	COMMON	flipper_plot, xp, yp

	CATCH,stat
	IF stat ne 0 THEN BEGIN
		PRINT,!err_string
		CATCH, /cancel
		RETURN
	ENDIF

	iprint  = 0			;turns on debugging messages
	maxiter = 5			;number of iterations for each phase
	var    = D.scanvar
	c_time = STRING(D.c_time)

;-------------------------------------------------------------------------------
;*******************************************************************************
; Initialise Dial before each scan phase

start:
	IF NOT D.started THEN BEGIN
		D.started = 1
		D.niter = 0
		IF D.xyz THEN BEGIN
			CASE D.xyziter OF
				0: BEGIN 
				   	D.bxyz = [7.0,0.0,0.0]
				   	D.phase_tit = 'Z scan - '
				   END
				1: BEGIN
					D.bxyz = [-4.5,5.0,0.0]
					D.phase_tit = 'X scan - '
				   END
				2: BEGIN
					D.bxyz = [-4.5,0.0,7.0]
					D.phase_tit = 'Y scan - '
				   END
			ENDCASE
			C = DIALCONTROL('b3 '+STRING(D.bxyz[0]), CHECK=0.5)
			C = DIALCONTROL('b4 '+STRING(D.bxyz[1]), CHECK=0.5)
			C = DIALCONTROL('b5 '+STRING(D.bxyz[2]), CHECK=0.5)
		ENDIF
		D.lambda = DIALNEWVALUE(TYPE = 'wave', /SETVALUE)
		IF (D.lambda LT 4) THEN $
		  D.current(*) = [0.0,0.0,4.0,0.4,1.0,0.2,1.0,0.2] ELSE $
		IF (D.lambda LT 5) THEN $
		  D.current(*) = [0.0,0.5,2.5,0.2,0.6,0.1,1.2,0.2] ELSE $
		  D.current(*) = [0.0,0.5,2.5,0.2,0.6,0.1,1.2,0.2]
		D.current[0] = D.current[1]
		B = D.current[0]
		IF iprint GT 0 THEN PRINT, 'Start first scan'
		C = DIALCONTROL('b2 '+STRING(D.initb2), CHECK=0.5)
		IF C LT 0 THEN PRINT,'Mad is un-reachable'
		C = DIALCONTROL(var+' '+STRING(B))
		C = DIALCONTROL('co '+c_time+' nos')
		DIALWSET

;------------------------------------------------------------------------------
; Update the scan

	ENDIF ELSE BEGIN
		B	= D.current[0]
		Bmin	= D.current[1]
		Bmax	= D.current[2]
		dB	= D.current[3]
		B1range	= D.current[4]
		dB1	= D.current[5]
		B2range	= D.current[6]
		dB2	= D.current[7]
		lambda	= D.lambda
		IF (iprint GT 0) THEN BEGIN
			PRINT,'B=',B,' Bmin=',Bmin,' Bmax=',Bmax,' dB=',dB,' var=',var
			FOR i=0,3 DO PRINT,'D.current[',i,'] =',D.current[i]
			PRINT,'D.scanvar=', D.scanvar
			PRINT,'Check counting status'
		ENDIF

		status = DIALNEWVALUE(TYPE = 'flagus', /SETVALUE)

		IF status EQ 0 THEN BEGIN

;------------------------------------------------------------------------------
;Plot the monitor 2 counts

			monitor = DIALNEWVALUE(TYPE = 'monitor2', /SETVALUE)
			V = monitor[0]
			D.value = V
			D.error = SQRT(V)
			IF B EQ Bmin THEN BEGIN
				 xp = [B,B]   & yp = [V,V]
				 xp = [B]     & yp = [V]
			ENDIF ELSE BEGIN
				 xp = [xp,B]  & yp = [yp,V]
			ENDELSE
			ep = SQRT(yp)
			DIALWSET
			IF NOT D.xyz THEN phase_tit = 'ZPO scan - '
			PLOT, xp, yp, PSYM=2, XRANGE=[Bmin,Bmax], $
			  YRANGE=[0,MAX(yp)], XTITLE=var, $
			  YTITLE='M2 Counts', TITLE=D.phase_tit+'Iteration no. '+$
			  STRTRIM(STRING(D.niter+1),2)+' - scan of '+var
			ERRPLOT, xp, yp-ep, yp+ep

			IF B LT Bmax THEN BEGIN
;------------------------------------------------------------------------------
;Increment current and start new count
				B = B + dB
				C = DIALCONTROL(var+' '+STRING(B))
				C = DIALCONTROL('co '+c_time+' nos')

			ENDIF ELSE BEGIN
;------------------------------------------------------------------------------
;End scan, fit minimum, set current and start new scan

				D.niter = D.niter + 1
				fit_parabola, xp, float(yp), bestfit, B00
				B0 = B00[0]
				ymin = B00[1]
				B0 = FLOAT(ROUND(B0*100.))/100.
				OPLOT, xp, bestfit, PSYM=0, LINESTYLE=0
				XYOUTS, B0, ymin, 'Minimum at '+var+' ='+STRING(B0)
				C = DIALCONTROL(var+' '+STRING(B0),CHECK=0.5)
				IF C LT 0 THEN PRINT,'Mad is un-reachable'
				IF var EQ 'B1' THEN BEGIN
					D.bestB1=B0	& var='B2'
				ENDIF ELSE BEGIN
					D.bestB2=B0	& var='B1'
				ENDELSE
				IF (D.niter EQ 5) AND (D.xyz EQ 0) THEN BEGIN
					PRINT,'Best currents found: B1=',D.bestB1
					PRINT,'                     B2=',D.bestB2
					command='par pczp '+STRING(D.bestB1)+STRING(D.bestB2)
					C = DIALCONTROL(command)
					C = DIALCONTROL('co zpo 10 nos')
					DIALSTOP
					D.started=0
					D.scanvar='B1'
					RETURN
				ENDIF ELSE IF (D.niter EQ 5) AND (D.xyz EQ 1) THEN BEGIN
					CASE D.xyziter OF
						0:	phase = 'z'
						1:	phase = 'x'
						2:	phase = 'y'
					ENDCASE
					PRINT,'Best '+phase+' currents found: B1=',D.bestB1
					PRINT,'                       B2=',D.bestB2
					command = 'par pc'+phase+' '+STRING(D.bestB1)+STRING(D.bestB2)+ $
						  STRING(D.bxyz[0])+STRING(D.bxyz[1])+STRING(D.bxyz[2])
					C = DIALCONTROL(command)
					D.started = 0
					var = 'B1'
					IF D.xyziter EQ 2 THEN BEGIN
						C = DIALCONTROL('co xyz 10 nos')
						DIALSTOP
						D.scanvar = 'B1'
						RETURN
					ENDIF
					D.xyziter = D.xyziter + 1
					GOTO, start
				ENDIF ELSE IF D.niter EQ 1 THEN BEGIN
					Bmin = D.initb2 - 1.8
					Bmax = D.initb2 + 1.8
					dB = 0.3
				ENDIF ELSE IF 2*(D.niter/2) EQ D.niter THEN BEGIN
					Bmin = D.bestB1 - B1range
					Bmax = D.bestB1 + B1range
					dB = dB1
				ENDIF ELSE BEGIN
					Bmin = D.bestB2-B2range
					Bmax = D.bestB2+B2range
					dB = dB2
				ENDELSE
				B = Bmin
				C = DIALCONTROL(var+' '+STRING(B))
				C = DIALCONTROL('co '+c_time+' nos')
			ENDELSE
		ENDIF
		D.scanvar=var
		D.current(0)=B
		D.current(1)=Bmin
		D.current(2)=Bmax
		D.current(3)=dB
	ENDELSE

	END

;-------------------------------------------------------------------------------
;*******************************************************************************

	PRO fit_parabola, xp, yp, bestfit, xymin

	s = SIZE(xp)
	np = s[1]
	dx = xp[1] - xp[0]

	A0 = INT_TABULATED(xp,yp)
	A1 = INT_TABULATED(xp,yp*xp)
	A2 = INT_TABULATED(xp,yp*xp^2)

	x1 = xp[0]
	x2 = xp[np - 1]
	d1 = x2 - x1
	d2 = (x2^2 - x1^2)/2.
	d3 = (x2^3 - x1^3)/3.
	d4 = (x2^4 - x1^4)/4.
	d5 = (x2^5 - x1^5)/5.

	A = [[d3,d2,d1],[d4,d3,d2],[d5,d4,d3]]
	B = [A0,A1,A2]
	R = CRAMER(A,B)

	bestfit = R[0]*xp^2+R[1]*xp+R[2]
	x0 = -0.5*R[1]/R[0]
	ymin = R[0]*x0^2 + R[1]*x0 + R[2]
	xymin = [x0,ymin]
	END

;------------------------------------------------------------------------------
;******************************************************************************
	FUNCTION dial_flipper_d7

	xyz = 0

	name     = "flipper_d7"
	generic  = "mad"
	type     = "monitor"
	onoff    = 0
	value    = 0L
	error    = 0L
	frequency= 1.6
	duration = 0.0
	history  = 0
	plot     = 100

        unit      = "counts"	; The dial string unit
        lowerlim  = 0.          ; The dial lower limit value
        upperlim  = 0.		; The dial upper limit value
	bxyz      = FLTARR(3)
	current   = FLTARR(8)
	phase_tit = 'ZPO - '
	scanvar   = 'B1'
	initb2    = 4.0		; initial value of correction coil
	c_time    = 1.0		; counting time per point
	lambda    = 0.0

	D={NAME:name        , GENERIC:generic, VALUE:value    , ONOFF:onoff        ,$
           DURATION:duration, UNIT:unit      , HISTORY:history, UPPERLIM:upperlim  ,$
           LOWERLIM:lowerlim, PLOT:plot      , TYPE:type      , STARTED:0          ,$
           CURRENT:current  , SCANVAR:scanvar, INITB2:initb2  , FREQUENCY:frequency,$
           C_TIME:c_time    , LAMBDA:lambda  , NITER:0        , BESTB1:0.          ,$
	   BESTB2:0.        , BXYZ:bxyz      , XYZ:xyz	      , XYZITER:0          ,$
	   PHASE_TIT:phase_tit}
	RETURN ,D
	END
;*********************
PRO dial_fpcyc_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_fpcyc
;** This macro procedure is called by George every D.frequency seconds

  
  LF=string(10b)
  length=STRLEN(D.search1)
  value=0.0
  error=0.0
  success=0
  IF STRPOS(D.os,'vms') EQ -1 AND STRPOS(D.os,'Win') EQ -1 THEN BEGIN
    list=FINDFILE(D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+'.sum',count=test)
    PRINT,D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+'.sum'
    IF test EQ 1 OR D.init eq 0  THEN  BEGIN
	  PRINT,'I am running ...'
      IF test EQ 1 THEN BEGIN
	    PRINT,'... not for the first time'
        OPENR,file,D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+'.sum',/get_lun
        line=""
        WHILE STRPOS(line,D.search0) EQ -1 AND NOT EOF(file) DO BEGIN
          READF,file,line
        ENDWHILE
        IF STRPOS(line,D.search0) NE -1 THEN BEGIN
          WHILE STRPOS(line,D.search1) EQ -1 AND NOT EOF(file) DO BEGIN
             READF,file,line
          ENDWHILE
          IF STRPOS(line,D.search1) NE -1 THEN BEGIN
            position=STRPOS(line,D.search1)
            text=STRMID(line,position+length,strlen(line)-position-length)
            IF D.newline THEN READF,file,text
            IF D.rderr THEN READS,text,value,error ELSE READS,text,value
            D.value=value
            D.error=error
            D.xvalue=D.Runnumber-1
            PRINT,D.xvalue,D.value,D.error
            success=1
          ENDIF ELSE PRINT,D.search0+' not found in',D.RUNNUMBER-1
        ENDIF ELSE PRINT,D.search1+' not found in',D.RUNNUMBER-1
        FREE_LUN,file
      ENDIF ELSE PRINT,'... for the first time'
      list=FINDFILE(D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+'.pcr',count=test)
	  PRINT,D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+'.pcr'
	  PRINT,D.RUNNUMBER-1,'=>',D.RUNNUMBER
      IF (test EQ 1 OR D.init eq 0) AND success EQ 1 THEN BEGIN
        IF D.init NE 0 THEN BEGIN
          IF STRPOS(D.os,'MacOS') NE -1 THEN BEGIN
            DO_APPLE_SCRIPT,'tell application "Finder"'+lf+$
                            'duplicate file "'+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+'.pcr"'+lf+$
	                    'try'+lf+'delete file "'+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.pcr"'+lf+'end try'+lf+$
  	                    'set name of file "'+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+'.pcr copy" to "'+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.pcr"'+lf+$
                            'end tell'
          ENDIF ELSE BEGIN
		    SPAWN,"cp "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+".pcr "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+".pcr"
		    PRINT,"cp "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER-1,/REMOVE)+".pcr "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+".pcr"
          ENDELSE
        ENDIF ELSE PRINT,'nothing to copy yet'
        list=FINDFILE(D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.sum',count=test)
        IF test EQ 1 THEN BEGIN
          IF STRPOS(D.os,'MacOS') NE -1 THEN BEGIN
            DO_APPLE_SCRIPT,'tell application "Finder"'+lf+$
	                    'delete file "'+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.sum"'+lf+$
                            'end tell'
          ENDIF ELSE BEGIN
		    SPAWN,"rm "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.sum'
		    PRINT,"rm "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.sum'
	      ENDELSE
        ENDIF
        list=FINDFILE(D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.dat',count=test)
 		PRINT,D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.dat is searched'
        IF test EQ 1 THEN BEGIN
		  PRINT,D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.dat is present'
          list=FINDFILE(D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.pcr',count=test)
          IF test EQ 1 THEN BEGIN
		    PRINT,D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.pcr as well'
            IF STRPOS(D.os,'MacOS') NE -1 THEN BEGIN
              DO_APPLE_SCRIPT,'tell application "Finder"'+lf+$
                              'open file "'+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+'.pcr" using file "HansenG3:Applications (Mac OS 9):JFullProf:FullProf"'+lf+$
                              'end tell'
            ENDIF ELSE BEGIN
			  SPAWN,"fullprof "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+" &"
			  PRINT,"fullprof "+D.FILEPATH+D.FILENAME+STRCOMPRESS(D.RUNNUMBER,/REMOVE)+" &"
			ENDELSE
            D.runnumber=D.runnumber+1
          ENDIF
        ENDIF ELSE D.onoff=0
      ENDIF
    ENDIF ELSE IF D.init eq 0 THEN BEGIN
    ENDIF
  ENDIF ELSE D.onoff=0
  IF D.init eq 0 THEN  D.init=1  
end



;*********************
FUNCTION dial_fpcyc
;*********************
;**
;** The dial initialisation

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
   ;GENERIC='mad'    ;connect to the mad-idl interface
   ;TYPE='monitor'   ;then V=DialNewValue() stands for V=DialNewValue(TYPE='monitor')
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=60.    ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0.0        ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    ERROR=0.0        ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=10           ;-2=none 0=plot 1=surface 2=contour n>2 means show vector of last n scalar values
    UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file fpcyc.his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds
    WUPDATE=0        ;=1 to automaticaly update corresponding workspace, =-1 silent!
                     ;=2 to automaticaly update and plot workspace to the main window
                     ;   0,1,2 are set by pressing the left,middle,right mouse button on the dial snapshot

   ;User Variables (Must be present in return statement to be available)
   ;-------------
    search0='Conventional'
    search1='Rwp:'
    newline=0
    rderr=0
    OS=!VERSION.OS
    LF=string(10b)
    FILENAME='khp'
    FILEPATH=''
    RUNNUMBER=1000        
    INIT=0           ;may be used in fpcyc_macro when started or on reset
    xvalue=0

return, {ERROR:error,VALUE:value,PLOT:plot,ONOFF:onoff,FREQUENCY:frequency,INIT:init,$
         OS:os,FILENAME:filename,FILEPATH:filepath,RUNNUMBER:runnumber,$
         SEARCH0:search0,SEARCH1:search1,RDERR:rderr,NEWLINE:newline,XVALUE:xvalue}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_fpcyc_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V ,[tag='VALUE']           ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;*********************
PRO dial_furnace_ramp_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_furnace_ramp

    IF(D.init NE 1) THEN BEGIN
	D.current=2.14
	D.init=1
    ENDIF
    V=DialNewValue(/setvalue)
    D.current=D.current+0.01
    command='b7 '+STRTRIM(STRING(D.current),2)
    C=DialControl(command)

end



;*********************
FUNCTION dial_furnace_ramp
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='temp'   ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=120.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=1	 ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds
    CURRENT=2.12
    INIT=0
   ;Own Variables (optional)
   ;-------------

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,current:CURRENT,$
         init:INIT}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_furnace_ramp_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
pro dial_getwave_macro, Dial
;** ****************
;**

    V=DialNewValue()
    Dial.value=string(V)
    end

function dial_getwave
;******* **********
;**

    return, {NAME:'getwave',TYPE:'wave',GENERIC:'mad',VALUE:''}
    end

;Replace the 4 occurences of 'model' by your 'dial name'
;File dial_template1.pro contains a list of usual Tags ans Calls
;*****************************************************************************
;-----------------------------------------------------------------------------
;
	PRO dial_hytec_data_all_macro, D
;
; Displays all Hytec counters with errors and proper axes
;
;						JRS 14/11/01
;
;*****************************************************************************
;-----------------------------------------------------------------------------

	IF(D.init EQ 0) THEN BEGIN
		D.type='motors'		& bank=DialNewValue() & bank=bank(0:3)
		D.type='wave'		& lambda=DialNewValue()
		IF (lambda LT 4.) THEN zeroshift=1.33 ELSE zeroshift=0.0
		angle=FLTARR(16,4)-zeroshift

;		YIG scan 16/9/99

		angle(*,0)=[206.00,203.05,200.32,197.39,194.57,191.73,188.95,186.04, $
			    183.15,180.35,177.50,174.60,171.79,168.94,166.22,163.18]
		angle(*,1)=[196.66,193.78,191.03,188.11,185.26,182.39,179.59,176.73, $
			    173.89,171.04,168.24,165.36,162.51,159.67,156.90,153.98]
		angle(*,2)=[202.71,199.83,196.95,194.19,191.34,188.44,185.66,182.76, $
			    179.90,177.10,174.32,171.34,168.49,165.68,162.88,159.96]
		angle(*,3)=[199.67,196.82,194.04,191.13,188.29,185.45,182.61,179.81, $
			    176.93,174.11,171.35,168.42,165.57,162.73,159.92,156.99]
		D.xvalue=FLTARR(64)
		FOR ibank=0,3 DO D.xvalue(ibank*16:ibank*16+15)=bank(ibank)-angle(*,ibank)
		D.init=1
		D.newtot =0.
		D.holdtot=0.
		DialModValue,lonarr(64)
		DialModValue,lonarr(64) ,tag='NEW'
		DialModValue,lonarr(64) ,tag='HOLD'
	ENDIF

;	GET THE DATA
;	------------
	V=DialNewValue(type='hytec')

;	REFRESHED?
;	---------
	tmp=total(V)
	IF(tmp lt D.newtot) THEN BEGIN	
		D.hold   =D.hold+D.new
		D.holdtot= total(D.hold)
	ENDIF ELSE BEGIN
		D.init=0
	ENDELSE

	D.new   = V
	D.newtot= tmp
	f = D.hold+D.new
	
;	PLOT
;	----
	yout=f
	yerr=sqrt(yout)
	D.error=yerr
	D.value=yout

	END

;*********************
FUNCTION dial_hytec_data_all
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='hytec'     ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=2.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0          ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------
    HOLD    = 0
    NEW     = 0
    HOLDTOT = 0.
    NEWTOT  = 0.
    TOFCH   = 0L
    XVALUE  = FLTARR(64)
    ERROR   = FLTARR(64)
    X_TIT   = 'Scattering angle (deg)'
    Y_TIT   = 'Counts'

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,holdtot:HOLDTOT,$
	 hold:HOLD,new:NEW,newtot:NEWTOT,init:0L,tofch:TOFCH,plot:PLOT,xvalue:XVALUE,$
	 x_tit:X_TIT,y_tit:Y_TIT,error:ERROR}
end






;*****************************************************************************
;-----------------------------------------------------------------------------
;
	PRO dial_hytec_data_macro, D
;
; Displays Hytec counters with errors and proper axes
;
;						JRS 10/8/01
;
;*****************************************************************************
;-----------------------------------------------------------------------------

	IF(D.init EQ 0) THEN BEGIN
		D.type='motors'		& bank=DialNewValue() & bank=bank(0:3)
		D.type='wave'		& lambda=DialNewValue()
		IF (lambda LT 4.) THEN zeroshift=1.33 ELSE zeroshift=0.0
		angle=FLTARR(8,4)-zeroshift

;		YIG scan 16/9/99

		angle(*,0)=angle(*,0)+[203.334,197.230,191.938,186.146,180.086,175.015,169.190,163.276]
		angle(*,1)=angle(*,1)+[193.803,188.033,182.300,176.830,170.917,165.057,159.300,153.770]
		angle(*,2)=angle(*,2)+[199.465,194.010,188.467,182.707,177.113,171.570,165.625,160.043]
		angle(*,3)=angle(*,3)+[196.693,190.988,185.062,179.510,173.758,168.194,162.510,156.666]
		D.xvalue=FLTARR(32)
		FOR ibank=0,3 DO D.xvalue(ibank*8:ibank*8+7)=bank(ibank)-angle(*,ibank)
		D.init=1
		D.newtot =0.
		D.holdtot=0.
		DialModValue,lonarr(32)
		DialModValue,lonarr(64) ,tag='NEW'
		DialModValue,lonarr(64) ,tag='HOLD'
	ENDIF

;	GET THE DATA
;	------------
	V=DialNewValue(type='hytec')

;	REFRESHED?
;	---------
	tmp=total(V)
	IF(tmp lt D.newtot) THEN BEGIN	
		D.hold   =D.hold+D.new
		D.holdtot= total(D.hold)
	ENDIF ELSE BEGIN
		D.init=0
	ENDELSE

	D.new   = V
	D.newtot= tmp
	f = D.hold+D.new
	
;	PLOT
;	----
	even=INDGEN(32)*2+1
	yout=f(even)
	yerr=sqrt(yout)
	D.error=yerr
	D.value=yout

	END

;*********************
FUNCTION dial_hytec_data
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='hytec'     ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=2.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0          ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------
    HOLD   =0
    NEW    =0
    HOLDTOT=0.
    NEWTOT =0.
    TOFCH  =0L
    XVALUE    =FLTARR(32)
    ERROR = FLTARR(32)
    X_TIT = 'Scattering angle (deg)'
    Y_TIT = 'Counts'

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,holdtot:HOLDTOT,$
	 hold:HOLD,new:NEW,newtot:NEWTOT,init:0L,tofch:TOFCH,plot:PLOT,xvalue:XVALUE,$
	 x_tit:X_TIT,y_tit:Y_TIT,error:ERROR}
end






; written by Floris Andre, August 2001

;**************************
;HOW TO RUN THIS DIAL:
;------------------------
;START idl THEN ENTER:  
;Idl>.run dial_lecture
;Idl> lecture   
;**************************


pro lecture
;** *********
;Used to run with "byGeorge"
FORWARD_FUNCTION DialControl, DialNewValue, DialOn
if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

dial_bygeorge,'lecture'	;<-------- Name of the Dial !!!
END				;         ~~~~~~~~~~~~~~~~~ !!!

;*********************
PRO dial_lecture_macro, D, V1
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_d22centre

print, " "
print, "********************"
print, "dial_lecture_macro"

if D.init eq 0 then begin
;	print, "init was 0"
	D.init=1
	D.frequency=0.
	Lim=DialNewValue(type='limits')
	para=DialNewValue(type='t_para')
;help, para, /struc
	lecture_gui

endif else begin
;	print,'init was 1'
endelse

end

;*************************************************************************************************************************************
;*************************************************************************************************************************************
pro ev01_event,ev
;*************************************************************************************************************************************
;*************************************************************************************************************************************
common check,chec
common tablo,tabb
tabb=strarr(1100)
widget_control,ev.id,get_uvalue=uu




;-------------- TO KNOW IF THE FILE EXISTS OR NOT ---------------
common errr,err2
common nofile,exist_file,ex
exist_file=0
ex=0
;-----------------------------------------------------------------



;------------ close button ----------------
if uu(0) eq 11114 then begin
widget_control,ev.top,/destroy
endif 
;------------------------------------------

;--------------- wavelength ---------------
;if uu(0) eq 11116 then begin
;	widget_control,uu(1),get_value=l
;	tabb[1099]=l[0]
;
;endif
;--------------------------------------------

;---------------- name of file ----------------
if uu(0) eq 11115 then begin
	widget_control,uu(1),get_value=nam
	print,"nam: ",nam
	nam=strtrim(string(nam))+string('.cmd')
	print,"nam: ",nam
	tabb[1098]=nam[0]
endif

;---------------------------------------------



;------------ open file button -----------------
if uu(0) eq 11113 then begin

widget_control,uu(2),get_value=nam
tabb[1098]=nam[0]+'.cmd'
nam=tabb[1098]
print,"nam: ",nam


common nb,n
common vale,val

;-------------------------- VARIABLES ---------------------------
read1='   '
deb=0
cpt=0
common var,j,p,sn
j=0
val=strarr(10)
po=strarr(23)
pa=strarr(23)
ru=strarr(23)
rut=strarr(23)
sa=strarr(23)
re=strarr(23)



;----------------------------------------------------------------

;------------------------ READ THE FILE -------------------------


on_ioerror,label
openr,roro,nam[0],/get_lun

;----- THE FILE EXISTS --------
exist_file=1
err2=string(format='(A80)','')
;------------------------------

while not (eof(roro)) do begin
	point_lun,-roro,deb
	readf,roro,read1
	
	if strmid(read1,4,5) eq 'title' then begin
	val[0]=strmid(read1,9,80)
	val[0]=strmid(strtrim(val[0],2),0,32)
	endif
		
	if strmid(read1,4,4) eq 'date' then begin
	val[1]=strmid(read1,9,80)
	val[1]=strmid(strtrim(val[1],2),0,10)
	;print,val[1]
	endif
	
	if strmid(read1,4,4) eq 'user' then begin
	val[2]=strmid(read1,9,80)
	val[2]=strmid(strtrim(val[2],2),0,10)
	;print,val[2]
	endif
	
	if strmid(read1,4,4) eq 'prop' then begin
	val[3]=strmid(read1,9,20)
	val[3]=strmid(strtrim(val[3],2),0,10)
	;print,val[3]
	endif

	;----------------- FOR POSITION ---------------
	
	ch=strpos(read1,'cha')
	;print,'cha= ',ch
	if ch ge 0 then begin
		cpt=cpt+1
		j=cpt
		po[j]=strmid(read1,ch+4,80)
		po[j]=strtrim(po[j],2)	
		;print,"po= ",po[j]
		nsa=po[j]
	endif	
	ps=strpos(read1,'par sub')
	;print,'ps= ',ps
	if ps ge 0 then begin
		;---------- FOR PAR SUB --------------
		und=strpos(read1,'_')
		
		if und gt 0 then begin
		pa[nsa]=strmid(read1,ps+10,20)
		pa[nsa]=strtrim(pa[nsa])
		;print,pa[nsa]
		endif else begin
		pa[nsa]=strmid(read1,ps+8,20)
		pa[nsa]=strtrim(pa[nsa])
		endelse
		
		;---------------------------------------
	endif
	
	if strmid(read1,0,3) eq 'run' then begin
		r=strpos(read1,'run')
		rf=r+3
		
		;----------- FOR RUN VALUE ---------------
		;if strmid(read1,4,50) eq 'm' then begin
			p1=strpos(read1,'m')
			if p1 gt 0 then begin
			;print,'p=',p1,cpt
			rut[j]='m'
			;print,'rut= ',rut[j]
			p=p1
			endif
		;if strmid(read1,4,50) eq 't' then begin
			p2=strpos(read1,'t')
			if p2 gt 0 then begin
			;print,'p=',p2,cpt
			rut[j]='t'
			;print,'rut= ',rut[j]
			p=p2
			endif else begin
			rut[j]='t'
			endelse
		;endif
		
		
			ru[j]=strmid(read1,rf+1,p-(rf+1))
			ru[j]=strtrim(ru[j],2)
			;print,'ru= ',ru[j]
		
		
		
		;---------- FOR S/N VALUE -----------------
		
		s1=strpos(read1,'s',rf)
			if s1 gt 0 then begin
			
			sa[j]='s'
			;print,'sav= ',sa[j]
			sn=s1
			endif else begin
			sa[j]='s'
			endelse
		
		n1=strpos(read1,'n',rf)
			
			if n1 gt 0 then begin
			sa[j]='n'
			;print,'sav= ',sa[j]
			sn=n1
			;print,'sn= ',sn
			
		
		;-----------------------------------------
		
		;---------- FOR REP VALUE -----------------
		
		re[j]=strmid(read1,p+1,sn-(p+1))
		re[j]=strtrim(re[j],2)
		;print,'re= ',re[j]
		;-----------------------------------------
			
			endif else begin
			re[j]='1'
			endelse
			
	endif
	
	print,''
	
	
	
	
	
	
endwhile

close,roro



;------------------------------ end of reading -----------------------


;if exist_file eq 1 then begin
;openr,roro,nam[0],/get_lun

;while not (eof(roro)) do begin
;	point_lun,-roro,deb
;	readf,roro,read1

;		if strpos(read1,'wavelength') gt 0 then begin
;		tabb[1099]=strmid(read1,11,50)
;		ex=1	
;		print,'l= ',tabb[1099]
;		endif

;endwhile
;close,roro
;endif


label:err2=string('no such file has been found')




;--------- INITIALISATION -----------
common tablo2,tabb2
tabb2=strarr(601)
;------------------------------------



;--------------------------- FILL GRILLE.PRO WITH THE OPENED FILE ------------


for i=1,cpt do begin
tabb[i]=po[i]		;position
tabb[i+100]=pa(po[i])	;par sub
tabb[i+200]=ru[i]	;value of preset
tabb[i+300]=rut[i]	;t/m
tabb[i+400]=re[i]	;repetition
tabb[i+500]=sa[i]	;save

endfor

;----- nb max of samples = 100 ----------
tabb[1081]=100
;----------------------------------------
tabb[1080]=cpt


grille
endif


end

















;*************************************************************************************************************************************
;*************************************************************************************************************************************
pro ev0_event,ev
;*************************************************************************************************************************************
;*************************************************************************************************************************************

common check,chec			;to know whitch button has been selected
common nofile,exist_file
exist_file=1
widget_control,ev.id,get_uvalue=u

;---------- close button ---------------
if u(0) eq 11114 then begin
	widget_control,ev.top,/destroy
endif 

;------------ create new file ----------
if u(0) eq 11111 then begin
	chec=0
	ex=0
	rack
	
endif 

;----------- use a saved file -----------
if u(0) eq 11112 then begin
	chec=1
common basedeb,based0,based1

;----------------- DEFINITION OF WIDGETS ---------------------
common basefin,base2d,base3d
common basedeb,based0,based1
common b,b1,b2
common sortie,exit
base3d=widget_base(base2d,/row)
q3=cw_field(base3d,title='enter the saved file to open:',xsize=10,/return_events)
q4=widget_label(base3d,value='.cmd')

b3=widget_button(base2d,xsize=200,value='open file')

widget_control,b1,sensitive=0
widget_control,b2,sensitive=0

;--------------------- REALIZE THE WIDGETS ------------------------
widget_control,based0,/realize

;-------------------------- EVENTS ----------------------------
widget_control,q3,set_uvalue=[11115,q3]
widget_control,b3,set_uvalue=[11113,b3,q3]
widget_control,exit,set_uvalue=[11114,exit]
xmanager,'ev01',based0,/just_reg
	
endif
end



;*******************************************************************************
;*****************************************************************************











;*************************************************************************************************************************************
;*************************************************************************************************************************************
pro lecture_gui
;*************************************************************************************************************************************
;*************************************************************************************************************************************

;----------------- DEFINITION OF WIDGETS ---------------------

common basedeb,based0,based1
common basefin,base2d,base3d
common b,b1,b2
common sortie,exit
common newl,newline

;------------ for new line button in grille.pro------------
newline=0
;----------------------------------------------------------

based0=widget_base(title='Command File (1)',/column)

q1=widget_label(based0,frame=5,value='     select one button     ')
q2=widget_label(based0,value='*****')


based1=widget_base(based0,/column)
base2d=widget_base(based0,/column)
base3d=widget_base(based0,/column,/align_center)

b1=widget_button(based1,value='   create new file   ')
b2=widget_button(based1,value='   use saved file    ')


q3=widget_label(base3d,value='*****')
exit=widget_button(base3d,value='close')


;--------------------- REALIZE THE WIDGETS ------------------------
widget_control,based0,/realize
;------------------------------------------------------------

;-------------------------- EVENTS ----------------------------

widget_control,b1,set_uvalue=[11111,b1]
widget_control,b2,set_uvalue=[11112,b2]
widget_control,exit,set_uvalue=[11114,exit]


xmanager,'ev0',based0,/just_reg


end



;*********************
FUNCTION dial_lecture
;*********************
;**
;** The dial initialisation

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='mad'         ;connect to the mad-idl interface
    TYPE='data'           ;when DialNewValue() is used, get the data
    ONOFF=0               ;state of the Dial 1=running
    HISTORY=0             ;=1 to record values in file .his
    DURATION=0            ;if >0 then Dial is stopped after running duration seconds
    WUPDATE=1             ;update corresponding workspace
    FREQUENCY=0.          ;the Dial macro is executed each frequency seconds. 
    			  ;if =0 then the general frequency is used

 return, {init:0,generic:GENERIC}
end



pro make_mad_struc
;** **************
;**
;** structures t_NOTHER, t_RES, t_STATUS, t_PARA,...
;** are used for MAD memory mapping.

common madshare, mad_home_dir, t_PARA,   t_NOTHER, t_RES, t_XBU, t_COUNTS, t_ERREURS, t_PILE,$
                               t_MOTORS, t_STATUS, t_CHOPPER,   geoMadStr, geoHytec, geoData, geoLimits

;**************************************
;* User define table here !!!!!!!!!!! *
;**************************************
;**************************************************************************************************
;*               Dial.Type        Structure      min.Freq   Extract value                         *
;**************************************************************************************************
   geoMadStr = [['motors'	, 't_nother'	, '0.5'	, ' t_nother.actang'			],$
		['t_nother'	, 't_nother'	, '0.5'	, ' t_nother'				],$
		['phase'	, 't_res'	, '0.5'	, '[t_res.phase_nb,t_res.phase_mes]'	],$
		['temp'		, 't_res'	, '0.5'	, ' t_res.tempea'			],$
		['t_res'	, 't_res'	, '0.5'	, ' t_res'				],$
		['d22cps'	, 't_status'	, '0.2'	, '[t_status.det_cps,t_status.det_sum]' ],$
		['monitor1'	, 't_status'	, '0.2'	, ' t_status.mon1'			],$
		['monitor2'	, 't_status'	, '0.2'	, ' t_status.mon2'			],$
		['hytecsum'	, 't_status'	, '0.2'	, ' t_status.hytec_sum'			],$
		['pmcsum'	, 't_status'	, '0.2'	, ' t_status.pmc_sum'			],$
		['time'		, 't_status'	, '0.2'	, ' t_status.duree_l'			],$
		['status'	, 't_status'	, '0.0'	, ' '					],$
		['t_status'	, 't_status'	, '0.0'	, ' t_status'				],$
		['flagus'	, 't_status'	, '0.0'	, ' '					],$
		['wave'		, 't_para'	, '0.9'	, ' t_para.wave'			],$
		['t_para'	, 't_para'	, '0.5'	, ' t_para'				],$
		['chopper1'	, 't_chopper1'	, '0.5'	, ' t_chopper'				],$
		['chopper2'	, 't_chopper2'	, '0.5'	, ' t_chopper'				],$
		['hytec'	, 'hytec'	, '0.5'	, ' '					],$
		['pmc'  	, 'pmc'	        , '0.5'	, ' '					],$
		['data'		, 'data'	, '0.4'	, ' '					],$
		['limits'	, 'limits'	, '2.0'	, ' '					],$
		['log'		, 'log'		, '1.5'	, ' '					],$
		['currents'	, 't_nother'	, '0.5'	, ' t_nother.actbob'			]]
;**************************************************************************************************
;**************************************************************************************************
;*!You have to restart George whenever you modify this table!*
;*************************************************************

Mach=strlowcase(getenv('HOST')) & id=strpos(Mach,'.')
if id gt 0 then Mach=strmid(Mach,0,id)
mad_home_dir="/users/"+Mach+"/"

if Mach eq 'd7'  then GeoData  =lonarr(16896)
if Mach eq 'd7'  then GeoHytec =lonarr(64)
if Mach eq 'd17' then GeoData  =lonarr(560000)
if Mach eq 'd22' then GeoData  =lonarr(128,128)
if Mach eq 'in6' then GeoData  =lonarr(512,300)
if Mach eq 'd20' then GeoData  =lonarr(1600)
                      GeoLimits=fltarr(48)

DET_NO   =1        
IND_ang1 =6        
IND_ang2 =6       
N_CHOP   =1	& if Mach eq 'in6' then N_CHOP=2
NB_CHAG  =6            
RES_MD_X =128        
RES_MD_Y =128       
SEL_MAX  =3              

str80 =bytarr(80) & str40 =bytarr(40) & str39 =bytarr(39) & str20= bytarr(20)
str18= bytarr(18) & str11= bytarr(11) & str10= bytarr(10) & str8 = bytarr(8)
str3 = bytarr(3)  & str2 = bytarr(2)

;****************************************  T_RES  *****************************************************
;****************************************  T_RES  *****************************************************
IF Mach eq 'd7' THEN $
t_RES   = { tt_res,  $
        LASNUM:0L, ISODIS:0L, NKMES:0L, JCACQ:0L, JC:0L, ICHECK:0L,$
        CHOP_STATUS:lonarr(N_CHOP), NWSAVE:0L,  NFSAVE:0L, NKSAVE:0L, NWHICH:0L,  $
        NFUNC:0L, NKEY:0L, RST_COMMI:str80, N_RST_COMMAND:0L, NPMES:0L,$
        N_TOTAL_SPECT:0L, N_MON_SPECT:0L, N_SINGLE_SPECT:0L, ISWITCH_DYN:0L,$
        NSWITCH:0L, LUN_TR:0L, LOG_FILE:0L, IXBFIL:0L, NXFILE:0L, NREPET:0L,$
        NPREP:0L, TYPE_MES:0L, PHASE_NB:0L, PHASE_MES:0L, free_01:0L,$
        num_temp:0L, rota_nb:0L, rota_mes:0L, preset_b_cur:0L, rest_time:0L,$
        hytec_sum:0L, chan_sum:0L, ss_timer:0L, monitor1:0L, monitor2:0L,$
        numor_to_send:0L, lastsend:0L,$
        free1:lonarr(79), check1:0L,$
        TEMPEA:fltarr(4), TEMPE:0.0, XC:0.0, SPEED_ACT:fltarr(N_CHOP),$
        PHASE_ACT:fltarr(N_CHOP), SPEED_REQ:fltarr(N_CHOP), PHASE_REQ:fltarr(N_CHOP),$
        update_data:0.0, free2:fltarr(98), check2:0.0}
	
IF Mach eq 'd22' THEN $
t_RES   = { tt_res,   $
	LASNUM:0L,        ISODIS:0L,            NKMES:0L,$
	JC:0L,            ICHECK:0L,            CHOP_STATUS:lonarr(N_CHOP),$
	NFUNC:0L,         NKEY:0L,              RST_COMMI:str80,$
	N_RST_COMMAND:0L, NPMES:0L,             NREPET:0L,$
	NPREP:0L,         NSERIE:0L,            num_temp:0L,$
	numor_to_send:0L, lastsend:0L,          xc:0L,$
	BEAM_CHANGE:0L,   BEAM_PHASE:0L,        LAST_SEL_DAY:0L,$
	LAST_SEL_SEC:0L,  NB_SPECT:0L,          par_tof:lonarr(7),$
	init_tof_done:0L, first_update_data:0L, DAC_LAST_CON:lonarr(2),$
	free1:lonarr(97), check1:0L,$
	TEMPEA:fltarr(4), free2:fltarr(100),    check2:0.  }
	
IF Mach eq 'in6' THEN $
t_RES   ={tt_res,     $
	LASNUM:0L,ISODIS:0L,NKMES:0L,JC:0L,ICHECK:0L,CHOP_STATUS:lonarr(N_CHOP),Bidonnerie:0L,$ ;<----------- Bidonnerie
        NFUNC:0L,NKEY:0L,RST_COMMI:str80,NPMES:0L,N_TOTAL_SPECT:0L,N_MON_SPECT:0L, $
        N_SINGLE_SPECT:0L,LOG_FILE:0L,IXBFIL:0L,NXFILE:0L,NREPET:0L,NPREP:0L, $
        num_temp:0L,numor_to_send:0L,lastsend:0L,xc:0L,xc_base:0L,xc_cumul:0L,$
        rota_preset:0L,cpt_time:0L,cpt_monitor:0L,cpt_c2:0L,cpt_c3:0L,update_data:0L, $
        free1:lonarr(90), check1:0L,$
	TEMPEA:fltarr(4), TEMPE:0.0, XC:0.0, SPEED_REQ:fltarr(N_CHOP),$
	PHASE_REQ:fltarr(N_CHOP), SPEED_ACT:fltarr(N_CHOP), PHASE_ACT:fltarr(N_CHOP),$
	TREQ:0.0, free2:fltarr(95), check2:0.0}
	
IF Mach eq 'd17' THEN $
t_res={tt_res, LASNUM:0L,ISODIS:0L,NKMES:0L,JC:0L,ICHECK:0L,$ 
	free11:0L, NFUNC:0L,$ 
	NKEY:0L, RST_COMMI: str80 ,N_RST_COMMAND:0L, NPMES:0L,NREPET:0L,$ 
	NPREP:0L,NSERIE:0L,NUM_TEMP:0L,NUMOR_TO_SEND:0L, lastsend:0L,$ 
	XC:0L,BEAM_CHANGE:0L, BEAM_PHASE:0L,LAST_SEL_DAY:0L,LAST_SEL_SEC:0L,$ 
	NB_SPECT:0L,par_tof:lonarr(9),init_tof_done:0L,FIRST_UPDATE_DATA:0L,$ 
	free1:lonarr(96), check1:0L, TEMPEA:lonarr(4),CONBOB:lonarr(5),$
        free2:fltarr(101), check2:0.}
	
IF Mach eq 'd20' THEN $
t_res={tt_res,$
	lasnum:0L,       nscan:0L,            iscan:0L,            ntgv:0L,        $
	isodis:0L,       nk_scan:0L,          np_scan:0L,          numdun:0L,       $
	ipsi:0L,         jcacq:0L,            jcscan:0L,           jc:0L,           $
	k_func:0L,       nb_ang:0L,           icoupled:0L,         nbg:0L,          $
	iftest:0L,       nhamil:0L,           rst_comm:str20,      n_rst_comm:0L,     $
	n_in_scan:0L,    iang_scan:lonarr(4), ndata_to_save:0L,    idata_to_save:lonarr(7),$
	nfile:0L,        ixbfil:0L,           nxfile:0L,           icheck:0L,$
	nkmes:0L,        LOG_FILE:0L,         nfunc:0L,            moni:0L, $
	acqsum:0L,       ss_counts:lonarr(4), nmotor:0L,           lastsend:0L,$
	lastsendidefix:0L, nbpt:0L,           nbpt2:0L,            nkpt:0L,$
	nkpt2:0L,        freen:0L,            nrin_scan:0L,        ncin_scan:0L,$
	moni2:0L,        time_co_unit:0L,     free1:lonarr(66),    check1:0L,      $
	h:fltarr(3),           angle:fltarr(4),  factor:0.,  dx:0.,           $
	psi:0.,                volte:0.,         tempe:0.,   xc:0.,       $
	dscan:0.,              fscan:0.,         step:0.,    dscan2:0.,       $
	fscan2:0.,             step2:0.,         xcacq:0.,   xcscan:0.,$
	ang_in_scan:fltarr(4), qshmin:0.,        qskmin:0.,  qslmin:0.,$
	qshmax:0.,             qskmax:0.,        qslmax:0.,  champ:0.,$
	free2 :fltarr(95),     check2:0L}


;****************************************  T_NOTHER  **************************************************
;****************************************  T_NOTHER  **************************************************
IF Mach eq 'd7' THEN   $
t_NOTHER = {tt_nother, $
         PCODE:0L, PSTATE:0L, CSTATE:0L, XBU_STATE:0L, MAD_TERM:str8,$
         NWHICHR:0L, NFUNC:0L, NKEY:0L, NKEY1:0L, IREMOT:0L, IXBFIL:0L,$
         CHOP_STOP_NUMBER:lonarr(N_CHOP), CHOP_STOP_TIME:lonarr(N_CHOP),$
         SUM_DET:lonarr(N_CHOP), SUM_MON:lonarr(2), SUM_TOTALE:0L, NUM_DURATION:0L, $
         IPCP1:0L, IPCP2:0L, IPCP3:0L, RESET:0L, FLAG:lonarr(8), TEMPEA:0.,$
         SUCCES:0L, INST_NAME:str8, INST_LEN:0L, actang:fltarr(16), actbob:fltarr(8),$
         count_flag:0L, vme_option:0L, xbu_inter:0L, MAD_WARNING:0L,$
         tab_fils:lonarr(20), nb_fils:0L, NSWITCH:0L,  $
         mon1:lonarr(6), mon2:lonarr(6), duree_l:lonarr(6), $
         hytec_sum:lonarr(6),pmc_sum:lonarr(6), $
         free3:lonarr(58), check:0L }

IF Mach eq 'd22' THEN  $
t_NOTHER = {tt_nother, $
	PCODE:0L,            PSTATE:0L,         CSTATE:0L,$
	XBU_STATE:0L,        NWHICHR:0L,        NFUNC:0L,$
	NKEY:0L,             NKEY1:0L,          CHOP_STOP_NUMBER:lonarr(N_CHOP),$
	CHOP_STOP_TIME:lonarr(N_CHOP), NUM_DURATION:0L, PRESET_REST:0L,$
	IPCP1:0L,            IPCP2:0L,          pcp_kill:0L,$
	pcp_pause:0L,        pcp_continue:0L,   SEL_UNIT_ACT:0L,$
	sel_state:0L,        selector_speed:0L, inst_state:0L,$
	att_state:0L,        ACT_SAM_DIAPH:0L,  det_cps:0L,$
	mon_cps:0L,          sample_no:0L,      det_sum:0L,$
	direct_beam:0L,      count_flag:0L,     motors_succes:0L,$
	vme_option:0L,       SUCCES:0L,         xbu_inter:0L,$
	tab_fils:lonarr(20), int_nb_fils:0L,    NSWITCH:0L,$
	time_update_gui:0L,  chek01:0L,         chek02:0L,$
	NUM_TIME:0.,         actang:fltarr(16), ACT_SEL_SPEED:0.,$
	ACT_WAVE:0.,         act_ieee:fltarr(2),act_adc:fltarr(2),$
	ACT_COLL:0.,         coll_state:0.,     TEMPEA:fltarr(4),$
	ACT_POWER:0.,        start_time:str18,  al1:str2,$
	stop_time:str18,     al12:str2,         start_num:str8, $
	cstate_flags:0L,     delta:0.,          delta1:0.,$
	CONBOB:fltarr(4),    ACTBOB:fltarr(4),  auto_free:0L,$
	act_ieee_deb:fltarr(3), act_ieee3:0.,   motor_flags:0L,$
	colf:0L, colb:0L,    free3:lonarr(78),  check:0L }

IF Mach eq 'in6' THEN  $
t_NOTHER= { tt_nother, $
	 PCODE:0L, PSTATE:0L, CSTATE:0L, XBU_STATE:0L, $
	 NWHICHR:0L, NFUNC:0L, NKEY:0L, NKEY1:0L, IREMOT:0L, IXBFIL:0L,$
	 CHOP_STOP_NUMBER:lonarr(N_CHOP), CHOP_STOP_TIME:lonarr(N_CHOP),$
         SUM_DET:lonarr(3), SUM_MON:lonarr(3), SUM_TOTALE:0L,NUM_TIME:0L, NUM_DURATION:0L, $
	 IPCP1:0L, IPCP2:0L, IPCP3:0L, RESET:0L, $
	 SUCCES:0L, INST_NAME:str8, INST_LEN:0L, $
	 count_flag:0L, vme_option:0L, xbu_inter:0L, $
         tab_fils:lonarr(20), nb_fils:0L, file_flun1:0L,NSWITCH:0L, $
         free3:lonarr(107), check:0L }

IF Mach eq 'd17' THEN  $
t_NOTHER= {tt_nother, PCODE:0L, PSTATE:0L, CSTATE:0L, XBU_STATE:0L, NWHICHR:0L,$
	NNFUNC:0L, NNKEY:0L, NNKEY1:0L, free11:0L , $
	free12:0L, NUM_DURATION:0L,$	
	PRESET_REST:0L, IPCP1:0L,IPCP2:0L, SEL_UNIT_ACT:0L, sel_state:0L,$
	selector_speed:0L, inst_state:0L, att_state:lonarr(3), free_det_cps:0L, $
	free_mon_cps:0L, sample_no:0L, free_det_sum:0L, free_mon_sum:0L,$
	count_flag:0L, $
	motors_succes:0L,vme_option:0L, SUCCES:0L, XBU_INTER:0L, $
	tab_fils:lonarr(20), nb_fils:0L, NSWITCH:0L, time_update_gui:0L,$ 
	chek01:0L,chek02:0L, tt1:0L,tt2:0L, NUM_TIME:0.,$
	det_cps:0.,mon_cps:0.,det_sum:0.,mon_sum:0.,$ 
	free_actang:fltarr(12),$
	ACT_SEL_SPEED:0.,ACT_WAVE:0.,act_ieee:fltarr(2),act_adc:fltarr(2),$
	ACT_COLL:0., coll_state:0.,NTEMPEA:fltarr(4),$
	start_time:str18, al1:0L,$
	stop_time:str18, al2:0L, start_num:str8, $
	cstate_flags:0L, motor_flags:0L,delta:0.,$
	delta1:0.,ss_count:lonarr(4),total:0L,ss_rates:lonarr(4),$
	npoll_rate:0L,jcode:0L,icons:0L,$
	colf:0L,colb  :0L,pcp_kill :0L,pcp_pause :0L,pcp_continue :0L,$
	actual_spectrum_length :0L, total_spectrum_length :0L,$
	actang:fltarr(40), actdiaphcom:fltarr(10), actbob:fltarr(5),$
        free3:lonarr(10), check :0L}

IF Mach eq 'd20' THEN  $
t_NOTHER= {tt_nother,$
	pcode:0L,        pstate:0L,      cstate:0L,          mad_term:str8,$
	nwhich:0L,       nother:0L,      nkey:0L,            nkey1:0L,  $
	iremot:0L,       free:lonarr(2), iercde:0L,          iersum:0L,    $
	iercam:0L,       nbrec:0L,       nbword:0L,          ipcp1:0L,    $
	ipcp2:0L,        reset:0L,       nswitch:0L,         succes:0L,    $
	inst_name:str8,  inst_len:0L,    libre_34:0L,        num_disp:0L,   $
	last_sent:0L,    nactive:0L,     visu:0L,            ydyvis:0.,$
	last_count:0L,   ipost_scan:0L,  vme_option:0L,      actang:fltarr(16),   $
	xbu_state:0L,    xbu_inter:0L,   count_flag:0L,      cur_phase:0L,$
	Palpha1:0.,      Palpha2:0.,     tab_fils:lonarr(20), nb_fils:0L,   $
	colf:0L,         colb:0L,        pcp_kill:0L,         pcp_pause:0L,$
	pcp_continue:0L, cstate_flags:0L,motor_flags:0L,     icons:0L,$
	jcode:0L,        ss_rates:lonarr(4), flun1:0L,       free3:lonarr(61),$
	check:0L} 


;****************************************  T_COUNTS  **************************************************
;****************************************  T_COUNTS  **************************************************
IF Mach eq 'd7'  THEN  $
t_COUNTS = {tt_counts, $
          mon1:fltarr(500), mon2:fltarr(500), dect:fltarr(32000), $
          som_dect:fltarr(500), ANG:fltarr(500) }
	  
IF Mach eq 'd17' THEN  $
t_COUNTS = {tt_counts, $
          mon1:fltarr(100), mon2:fltarr(100), dect:fltarr(100), $ 
          som_dect:fltarr(100), ANG:fltarr(100) }
	  
IF Mach eq 'in6' THEN  $
t_COUNTS = {tt_counts, $
          mon1:fltarr(100), mon2:fltarr(100), dect:fltarr(100), $ 
          som_dect:fltarr(100), ANG:fltarr(100) }
	  
IF Mach eq 'd20' THEN  $
t_COUNTS={tt_COUNTS,$
	start_time:str18,$
        flag:0L,$
        stop_time:str18,$
        data:lonarr(417792),$
        ss_counts:lonarr(4),$
        cou:fltarr(2000),$
        ang:fltarr(1996)}

t_XBU    = {tt_xbu, NAME:str8, NCH:0L, LOOPS:0L, NLOOP:0L, NLINE:0L, LINES:0L, Ncheck:0L} 

t_ERREUR = {tt_erreur,degre:0L, txt:str80}

t_ERREURS= {tt_erreurs, nbr_err:0, err:replicate({tt_erreur},20)}

t_PILE   = {tt_pile, old_cmd:replicate(string(replicate(32b,8)), 100),ind_cmd:0L}

t_MOTORS= {tt_motors,motnam_ch:bytarr(8),COEF_VME:0.,UNIT_VME:0L,$
	MKT_VME:0L,PREC:0.,unit:bytarr(4),enab:0L,$
	errsum:0L,name2:bytarr(2),type:0L, param:lonarr(40),retries:0L,$
	but_min:0.,but_max:0.,off_small:0.,off_large:0.,bckl:0.,start:0.,$
	actual:0.,req:0.,action:0L,error:0L,adresse_diaph:0L}
	

;****************************************  T_PARA  ****************************************************
;****************************************  T_PARA  ****************************************************
IF Mach eq 'd7' THEN $
t_PARA   = {tt_para, $
         TST_BEAM :0L, JCODE :0L,    ISOR     :0L, ISWITCH :0L, $
         ISORT :0L, TOF_CHA_RESOL:0L, TOF_CHA_WIDTH:0L, TOF_DIVID:0L,$
         NUM_CHAN_USED:0L, COMPUTE_PAR :0L, MIN_RATE :0L, MAX_RATE:0L,$
         filer :0L, UPDATE_TIMER:0L, STATE_TIMER :0L, OUTPUT_TIMER:0L,$
         ALARM_TIMER:0L, CHOP_OPTION:0L, ALIGN:0L, SCAN_UNIT:0L,$
         ICRY:0L, IRVOLT:0L, IVOLT:0L, ITVOLT:0L, IREGUL:0L,$
         SLOT_CHOP:lonarr(N_CHOP), PICK_CHOP:lonarr(N_CHOP),$
         TSWITCH_TERM:str8, long_TSWITCH_TERM:0L,$
         MAD_REMOTE_TERM:str8, long_MAD_REMOTE_TERM:0L,$
         C_TXT:str80, long_TXT:0L, C_USER:str8, long_C_USER:0L,$
         C_LC:str8, long_C_LC:0L, SUB_TITLE:str80,  long_PROPAL:0L,$
         BOOL_TOFF:0L, PRESET_BASE:0L, tgv:0L,   ask_tgv:0L,$
         free1:lonarr(87), check1: 0L, $
         WAVE:0., ENERGY:0., SPE_CHOPPER:fltarr(N_CHOP), PERIOD_CHOP:0.,$
         CHA_WIDTH:0., TOF_DELAY:0., CONS:0., SCAN_VALDEP:0.,$
         SCAN_VALFIN:0., SCAN_STEP:0.,$
         ZCURRENT:fltarr(5), XCURRENT:fltarr(5), YCURRENT:fltarr(5),$
         EMIN:0., EMAX:0., EL_PEAK:0.,$
         BANK1:fltarr(3),BANK2:fltarr(3),BANK3:fltarr(3),BANK4:fltarr(3),$
         THE_BOB_DEP:0.,THE_BOB_LAST:0., THE_BOB2_DEP:0.,THE_BOB2_LAST:0.,$
         PRESET_COEF_XYZ:0., PRESET_COEF_Z:0., ZPO_FLI:0.,ZPO_COR:0.,$
         THE_BOB_DEPX:0., THE_BOB_LASTX:0., THE_BOB2_DEPX:0., THE_BOB2_LASTX:0.,$
         THE_BOB_DEPY:0., THE_BOB_LASTY:0., THE_BOB2_DEPY:0., THE_BOB2_LASTY:0.,$
         free3:fltarr(50),   $
         check2:0.     }

IF Mach eq 'd22' THEN $
t_PARA  = { tt_para,  $
	TST_BEAM:0L,       TOF_CHA_RESOL:0L,    TOF_DIVID:0L,$
	COMPUTE_PAR:0L,    MIN_RATE:0L,         MAX_RATE:0L, $
	UPDATE_TIMER:0L,   STATE_TIMER:0L,      OUTPUT_TIMER:0L,$
	ALARM_TIMER:0L,    ISWITCH:0L,          ALIGN:0L,$
	SCAN_UNIT:0L,      use_cry:0L,          use_volt:lonarr(2), IRVOLT:lonarr(2),$
	ITVOLT:lonarr(2),  IREGUL:0L,           DET_MASK:lonarr(1), $
	MD_NSPECT:0L,      MD_RADIUS:0L,        MODE:0L,$
	grouping_mode:0L,  X1_MD:0L,            X2_MD:0L,$
	Y1_MD:0L,          Y2_MD:0L,            cal_option:0L,$
	sel_unit:0L,       sel_const:lonarr(3), attenu_cur:0L,$
	beam_stop_unit:0L, changer_cur:0L,      sample_min:0L,$
	sample_max:0L,       attenu_pos:0L,     selector_speed_cor:0L,$
	scan_area:lonarr(4), use_cha:0L,        use_she:0L,$
	use_ste:0L,        use_mag:0L,          use_cho:0L,$
	use_pre:0L,        use_spe:0L,          use_adc:lonarr(2),$
	ENVIRONMENT:0L,    MD_MASK_FILE:str20,  C_TXT:str39,$
	long_TXT:0L,       SUB_TITLE:str20,     long_SUB_TITLE:0L,$
	C_USER:str10,      long_C_USER:0L,      PROPOSAL_NUMBER:str8,$
	long_PROPOSAL_NUMBER:0L, LOG_BOOK_N:str3, long_LOG_BOOK_N:0L,$
	EXP_START_TIME:str11,    long_EXP_START_TIME:0L, ieee_cmds:str80,$
	speed_nb:0L,       speed_l:lonarr(10),  speed_h:lonarr(10),$
	API_OPTION:0L,     use_volt3:0L,        IRVOLT3:0L,$
	ITVOLT3:0L,        ieee3_cmds:str40,    rs232_speed:0L,$
	rs232_c_end:0L,    rs232_type:0L,       tof:0L,$
	total_spec:0L,     industri_option:0L,  pardesc:0L,$
	free1:lonarr(59),  check1:0L,$
	WAVE_TOL:0.,       wave_offset:fltarr(3), CHA_WIDTH:0.,$
	TOF_DELAY:0.,      CONS:0.,             SCAN_VALDEP:0.,$
	SCAN_VALFIN:0.,    SCAN_STEP:0.,        DIS_S_D:0.,$
	SDI1:0.,           SDI2:0.,             SDI3:0.,$
	IDI:0.,            CD11:0.,             CD12:0.,$
	SAL:0.,            SAR:0.,              SALOW:0.,$
	SAUP:0.,           X0:0.,               Y0:0.,$
	BEAM_X:0.,         BEAM_Y:0.,           DET_DIST:0.,$
	DET_ANG:0.,        filer_ang:fltarr(12),CHANGER_ONE:fltarr(NB_CHAG),$
	CHANGER_INC:fltarr(NB_CHAG), CHANGER_NB:fltarr(NB_CHAG),MD_X0:0., $
	MD_Y0:0.,          amp_limit:0.,        volt_limit:0.,$
	resolution:0.,     bath_offset:0.,      bath_slope:0.,$
	free2:fltarr(97),  check2:0.  }

IF Mach eq 'in6' THEN $
t_PARA    ={ tt_para, $
          TST_BEAM:0L, JCODE:0L, TOF_CHA_RESOL:0L, TOF_CHA_WIDTH:0L, $
          TOF_DIVID:0L,DET_MASK:lonarr(8),MON_MASK:lonarr(8),NUM_CHAN_USED:0L, $
          COMPUTE_PAR:0L,MIN_RATE:0L,MAX_RATE:0L,UPDATE_TIMER:0L, $
          STATE_TIMER:0L,OUTPUT_TIMER:0L,ALARM_TIMER:0L,CHOP_OPTION:0L,$
          ENVIRONMENT:0L,ICRY:0L,IRVOLT:0L,IVOLT:0L,ITVOLT:0L,IREGUL:0L,$
          ISWITCH:0L,mad_remote_term:str8, C_TXT:str80, long_TXT:0L, $
          C_USER:str8, long_C_USER:0L,$
          C_LC:str8, long_C_LC:0L, SUB_TITLE:str80,  long_PROPAL:0L,$
          ELPEAK:0L, free1:lonarr(69), check1: 0L, $
	  WAVE:0.,RAT_CHOPPER:0., SPE_CHOPPER:fltarr(N_CHOP), $
          DEPH_CHOPPER:fltarr(N_CHOP),DEPH_OFFSET:0.,PERIOD:0., $
          CHA_WIDTH:0.,TOF_DELAY:0.,CONS:0.,res_chopper:0.,ei_chopper:0., $
          qmin_chopper:0.,qmax_chopper:0.,emin_chopper:0.,emax_chopper:0., $
          DISTANCE:fltarr(6),DIS_S_M:0.,SAMPLE_ANG:0., $
          free2:fltarr(89),    check2:0.    }

IF Mach eq 'd17' THEN $
t_para={tt_para,TST_BEAM:0L ,TOF_CHA_RESOL:0L,TOF_DIVID:0L,$
	COMPUTE_PAR:0L, MIN_RATE:0L,MAX_RATE:0L,UPDATE_TIMER:0L,$
	STATE_TIMER:0L,OUTPUT_TIMER:0L,ALARM_TIMER:0L,ISWITCH:0L,$
	ALIGN:0L,SCAN_UNIT:0L,ICRY:0L,IVOLT:lonarr(2),IRVOLT:lonarr(2),$
	ITVOLT:lonarr(2),IREGUL:0L,DET_MASK:lonarr(1),MD_NSPECT:0L,$
	MD_RADIUS:0L,MODE:0L,grouping_mode:0L,X1_MD:0L,X2_MD:0L,$
	Y1_MD:0L,Y2_MD:0L,cal_option:0L,sel_unit:0L,sel_const:lonarr(3),$
	attenu_cur:0L,beam_stop_unit:0L,changer_cur:0L,sample_min:0L,$
	sample_max:0L,attenu_pos:0L,selector_speed_cor:0L,$
	scan_area:lonarr(4),use_cha:0L,use_she:0L,use_ste:0L, use_mag:0L,$
	use_cho:0L,use_pre:0L,use_spe:0L,use_adc:lonarr(2),$
	ENVIRONMENT:0L,MD_MASK_FILE:bytarr(20),C_TXT:bytarr(39),$
	long_TXT:0L,SUB_TITLE:bytarr(20),long_SUB_TITLE:0L,$
	C_USER:bytarr(10) ,long_C_USER:0L,PROPOSAL_NUMBER:bytarr(8),$
	long_PROPOSAL_NUMBER:0L,LOG_BOOK_N:bytarr(3),long_LOG_BOOK_N:0L,$
	EXP_START_TIME:bytarr(11),long_EXP_START_TIME:0L,$
	ieee_cmds:bytarr(40,2),$
	speed_nb:0L,speed_l:lonarr(10), speed_h:lonarr(10),$
	nx_tof:0L, ny_tof:0L, pend_preset:0L,pend_preset_type:0L,$
	free1:lonarr(75), check1:0L ,WAVE_TOL:0. ,$
	wave_offset:fltarr(3),CHA_WIDTH:0.,TOF_DELAY:0., CONS:0.,$
	SCAN_VALDEP:0.,SCAN_VALFIN:0. ,SCAN_STEP:0. ,$
	DIS_S_D:0. ,SDI1:0. ,SDI2:0. ,SDI3:0. ,IDI:0., CD11:0.,$
	CD12:0.,CD21:0. ,CD22:0.,CD31:0.,CD32:0.,X0:0. ,Y0:0.,$
	BEAM_X:0.,BEAM_Y:0. ,DET_DIST:0.,DET_ANG:0.,filer_ang:fltarr(12) ,$
	CHANGER_ONE:fltarr(NB_CHAG),CHANGER_INC:fltarr(NB_CHAG),$
	CHANGER_NB:fltarr(NB_CHAG),MD_X0:0. ,MD_Y0:0. ,amp_limit:0. ,$
	volt_limit:0.,$
	off_diah_comb:fltarr(10),pend_down:0. , pend_up:0. ,$
	free2:fltarr(88),check2:0.}

IF Mach eq 'd20' THEN $
t_para={tt_para,$
	lcode:0L ,           j_code:0L ,       ido_tgv:0L,       ifit:0L,      $
	isor:0L,             ivisu:0L,         irescl:0L,        isorl:0L, $
	ih:0L,               ik:0L,            iomega:0L,        isorte:0L,       $
	npsca:0L,            nkscan:0L,        idelta:0L,        nbas:0L,    $
	mex:lonarr(9),       nkb:0L,           ihamil:0L,        iquad:0L,    $
	ipara:0L,            iblin1:0L,        iblin2:0L,        ichi_zero_top:0L,$
	ispin:0L,            iref:0L,          ntest:0L,         nbtest:0L,$
	nspeci:0L,           iglob:0L,         itilt:0L,         icry:0L,      $
	ianal:0L,            isn:0L,           ichi:0L,          icyce:0L,   $
	iscce:0L,            ilicen:0L,        imort:0L,         ido_volt:0L,    $
	 nkcefi:0L,           imode:0L,         flgkif:0L,        icyfit:0L,   $
	ifacto:0L,           ivisch:0L,        ivisty:0L,        ivistt:0L,       $
	ilasti:0L,           ichadi:0L,        ifaisc:0L,        ihard:0L,       $
	icelim:lonarr(3),    icycle:0L,        isa:0L,           iswitch:0L,    $
	isort:0L,            stipos:0L,        swa3:0L,          ix:0L,  $
	iecr:0L,             iregd:0L,         naxe:0L,          nkcen:0L,       $
	swpol:0L,            iber:0L,          ido_dti:0L,       icorec:0L,       $
	mad_rem_iclt:bytarr(8), par_term:bytarr(8), ibob:lonarr(10), c_txt:bytarr(80),  $
	k1:0L,               c_user:bytarr(8),   k2:0L,          c_lc:bytarr(8),      $
	k3:0L,               sub_title:bytarr(80), k4:0L,        proposal:bytarr(80), $
	iwp:0L,              itvolt:0L,        irvolt:0L,        imub:0L,         $
	fixpl:0L,            ivariz:0L,        mult_sing:0L,     nb_det:0L,       $
	nblocks_sdata:0L,    mboxx:0L,         mboxy:0L,         scan_unit:0L,$
	mot_unit:0L,         strombo_mode:0L,  nb_cycles:0L,     nb_slices:0L,    $
	type_mes:0L,         tranche:lonarr(768), unit_slice:lonarr(256), slice_t:lonarr(7,4),$
	check_slice:0L,      rtrpower:0L,      D19:0L,           OS:0L,$
	SeqType:0L,          check12:0L,       tempphasei:fltarr(4), p_phase1:fltarr(3),  $
	p_phase2:fltarr(3),  p_phase3:fltarr(3), ido_mag:0L,     free1:lonarr(31), $
	check1:0L,$
	wav:0.,       rhmin:0.,          rhmax:0.,          rkmin:0.,       $
	rkmax:0.,     rlmin:0.,          rlmax:0.,          psimin:0.,          $
	psimax:0.,    paspsi:0.,         thmin:0.,          thmax:0.,     $
	ub:fltarr(9), valmin:0.,         tscan:0.,          deltav:0.,        $
	factor:0.,    tbas:fltarr(5),    dbas:fltarr(5),    apha:0.,          $
	vimoy:0.,     tfit:0.,           cell:fltarr(6),    grandd:0.,       $
	petitd:0.,    thetac:fltarr(3),  domegc:fltarr(3),  ratio:0.,       $
	tctest:0.,    ameil:0.,          coumin:0.,         tenmax:0.,        $
	counor:0.,    part:fltarr(3),    vmort:0.,          vmaxi:0.,        $
	vtest:0.,     atemp:0.,          btemp:0.,          ymin:0.,          $
	ymax:0.,      vnorm:0.,          a4:fltarr(4),      shchi:0.,         $
	themoy:0.,    chref:fltarr(12),  ptest:0.,          pasbg:0.,       $
	consbg:0.,    cons:0.,           temmon:0.,         temreg:0.,   $
	errreg:0.,    cmvohm:0.,         aplan:fltarr(6),   a1:fltarr(2),       $
	st_alim_m:0., st_alim_a:0.,      dm:0.,             da:0.,       $
	pash:0.,      pask:0.,           pasl:0.,           eregsy:0.,       $
	cimini:0.,    thetax:fltarr(5),  xx:fltarr(5),      a2:fltarr(5),       $
	a3:fltarr(5), vmavis:0.,         fcar:fltarr(4),    scar:fltarr(4),  $
	mcu:fltarr(5),mpg:fltarr(5),     ominli:0.,         omaxli:0.,       $
	bmin:0.,      bmax:0.,           aglob:0.,          bglob:0.,   $
	cglob:0.,     dglob:0.,          pfstep:0.,         pfmon:0.,       $
	qh:0.,        qk:0.,             ql:0.,             dqh:0., $
	dqk:0.,       dql:0.,            en:0.,             den:0.,     $
	valkif:0.,    omzert:fltarr(5),  omzerv:fltarr(5),  xdist:0.,       $
	dstab1:0.,    dstab2:0.,         conf:fltarr(25),   det:fltarr(15),$
	free2:fltarr(60),  check2:0. }


;****************************************  T_STATUS  **************************************************
;****************************************  T_STATUS  **************************************************
IF Mach eq 'd7' THEN  $
t_STATUS= {tt_status, $
        PCODE:0L, PSTATE:0L, CSTATE:0L, count_flag:0L, JC:0L, SCAN_UNIT:0L,  $
        time_counts:0L, moni1_counts:0L,moni2_counts:0L , $
        sum_pmc:0L, sum_hytec:0L, $ 
        mon1:lonarr(6), mon2:lonarr(6), duree_l:lonarr(6), $
        hytec_sum:lonarr(6),pmc_sum:lonarr(6), $
        free2:lonarr(18), check1:0L}

IF Mach eq 'd17' THEN $
t_STATUS= {tt_status, $
	PCODE:0L, PSTATE:0L, CSTATE:0L,$
	JC:0L, det_cps:0L, mon_cps:0L,$
	det_sum:0L, ss_counts:lonarr(2), count_flag:0L,$
	cstate_flags:0L, motor_flags:0L, free2:lonarr(18),$
	check1:0L }

IF Mach eq 'd22' THEN $
t_STATUS= {tt_status, $
	PCODE:0L, PSTATE:0L, CSTATE:0L,$
	JC:0L, det_cps:0L, mon_cps:0L,$
	det_sum:0L, ss_counts:lonarr(2), count_flag:0L,$
	cstate_flags:0L, motor_flags:0L, free2:lonarr(18),$
	check1:0L }
	
IF Mach eq 'in6' THEN $
t_STATUS= {tt_status, $
	PCODE:0L, PSTATE:0L, CSTATE:0L, count_flag:0L, JC:0L,  $
	time_counts:0L, vsum:fltarr(8),$
	free2:lonarr(18), check1:0L}
	
IF Mach eq 'd20' THEN $
t_STATUS= {tt_status, $
	PCODE:0L, PSTATE:0L, CSTATE:0L,$
	JC:0L, det_cps:0L, mon_cps:0L,$
	det_sum:0L, ss_counts:lonarr(2), count_flag:0L,$
	cstate_flags:0L, motor_flags:0L, free2:lonarr(18),$
	check1:0L }
	
IF Mach eq 'd17' THEN $
t_CHOPPER={tt_chopper,$ 
	frequence:0L, moy_phase:0L, phi:0L, phi_long:0L, dphase:0L,$ 
	oscillation:0L, cadran:0L, regulation:0L, couple:0L, nb_poles:0L,$ 
	gene_type:0L, nb_pickup:0L, sign_pickup:0L, clock_mode:0L, lost_phase_low:0L,$
	lost_phase_high:0L, dt_pickup_counter:0L, dt_counter:0L, phase_hist:lonarr(101)}

end
;*****************************************************************************************
;*****************************************************************************************
;*****************************************************************************************
;*****************************************************************************************
;*****************************************************************************************
function GET_MAD_STRUC, pth, txt, struc
;******* *************
;**
if (n_elements(struc) eq 0) or (pth eq '') then return,3.14
return, CALL_EXTERNAL (pth, txt, struc) 
end

FUNCTION DIAL_MAD_READ, DialType, TimeSeq, aString
;******* *************
;**
;**
common geoMad_rface, geoMadSeq, geoMadPth, geoMadLog, geoMadPtr
common madshare
V='3.14'
S= 0.
if n_elements(TimeSeq) ne 1 then begin TimeSeq=systime(1) & aString='' & endif
;**********
;First call
;**********
if n_elements(geoMadPth) eq 0 then begin MAKE_MAD_STRUC & geoMadPth='/users/mad/IDL_MAD_SERVER/ex1.so'
					 bid=FINDFILE(geoMadPth,count=nn) & if nn lt 1 then geoMadPth =''
					 geoMadLog=mad_home_dir+'LOG_FILE/MAD.LOG'
					 bid=FINDFILE(geoMadLog,count=nn)
					 if nn lt 1 then begin	geoMadLog=mad_home_dir+'mad.log'
					 			bid=FINDFILE(geoMadLog,count=nn) & endif
					 if nn lt 1 then geoMadLog =''
					 geoMadPtr=-1
					 geoMadSeq={hytec:   -1D ,$
					            data:    -1D ,$
					            limits:  -1D ,$
					            status:  -1D ,$	;**** Structure T_STATUS ****
					            para:    -1D ,$	;**** Structure T_PARA   ****
					            nother:  -1D ,$	;**** Structure T_NOTHER ****
					            res:     -1D ,$	;**** Structure T_RES    ****
					            counts:  -1D ,$	;**** Structure T_COUNTS ****
					            motors:  -1D ,$	;**** Structure T_MOTORS ****
					            chopper1:-1D ,$	;**** Structure T_CHOPPER****
					            chopper2:-1D ,$	;**** Structure T_CHOPPER****
					            log:     -1D }
						    
endif


idx=where(geoMadStr(0,*) eq DialType) & idx=idx(0)
IF  idx ge 0 THEN BEGIN

;********************************
;Time to update our structures ??
;********************************
   Mins=FLOAT(geoMadStr(2,idx))
   CASE       geoMadStr(1,idx) of
   
   't_nother':	if TimeSeq - geoMadSeq.nother	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_nother' , t_nother)
								   geoMadSeq.nother  =TimeSeq & endif
   't_res':	if TimeSeq - geoMadSeq.res	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_res'    , t_res)
								   geoMadSeq.res     =TimeSeq & endif
   't_para':	if TimeSeq - geoMadSeq.para	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_para'   , t_para)
								   geoMadSeq.para    =TimeSeq & endif
   't_status':	if TimeSeq - geoMadSeq.status	ge Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_status' , t_status)
								   geoMadSeq.status  =TimeSeq & endif
   't_chopper1':if TimeSeq - geoMadSeq.chopper1	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_chopper_status'  , t_chopper)
								   geoMadSeq.chopper1=TimeSeq & endif
   't_chopper2':if TimeSeq - geoMadSeq.chopper2	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_chopper2_status' , t_chopper)
								   geoMadSeq.chopper2=TimeSeq & endif
   'hytec':	if TimeSeq - geoMadSeq.hytec	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_data_hytec' , geoHytec)
								   geoMadSeq.hytec   =TimeSeq & endif
   'pmc':	if TimeSeq - geoMadSeq.hytec	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_data_pmc'   , geoData)
								   geoMadSeq.hytec   =TimeSeq & endif
   'data':	if TimeSeq - geoMadSeq.data	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_data'       , GeoData)
								   geoMadSeq.data    =TimeSeq & endif
   'limits':	if TimeSeq - geoMadSeq.limits	gt Mins	then begin S=GET_MAD_STRUC(geoMadPth,'get_mad_mot_limit'  , GeoLimits)
								   geoMadSeq.limits  =TimeSeq & endif
   'log':	if TimeSeq - geoMadSeq.log	gt Mins	then begin V=''
								   if aString gt ' ' then fil=aString else fil=geoMadLog
								   IF fil ne '' then begin
								     U=-1 & on_ioerror,misMO
								     openr,U,fil,/get_lun
								     st=fstat(U)
								     if geoMadPtr  ge 0 then begin Ptr=geoMadPtr>(st.size-5000)
									lin='' & point_lun,U,Ptr & readf,U,V
									while(1) do begin readf,U,lin & V=[V,lin] & endwhile
									endif
								     misMO: if U gt 0 then begin geoMadPtr=st.size
									                         free_lun,U  & endif
								   ENDIF
								   geoMadSeq.log    =TimeSeq
							endif else V=''
   ELSE:
   ENDCASE

;********************
;Give back the values
;********************
   IF S ne 3.14 then CASE DialType of

   'data':	return, GeoData
   'pmc':	return, GeoData
   'hytec':	return, geoHytec
   'limits':	return, geoLimits
   'log':
   'flagus':	if (t_status.PCODE eq 2 ) then V= t_status.cstate else V=-1
   'status':	if (t_status.PCODE eq 0 ) then V= 'MAD IS NOT RUNNING' else $
		if (t_status.PCODE eq 1 ) then V= 'MAD INIT PHASE'     else $
		if (t_status.PCODE eq 2 ) then begin
		 case t_status.cstate of 
		 0:   V= 'Idle'
		 1:   V= 'COUNTING'
		 2:   V= 'POSITIONNING'
		 3:   V= 'ENCODER READING'
		 4:   V= 'TEMPERATURE SETTING'
		 5:   V= 'WAITING'
		 6:   V= 'WAVELENGTH SETTING'
		 7:   V= 'CHOPPER SETTING'
		 8:   V= 'DATA UPDATING'
		 9:   V= 'COLLIMATION SETTING'
		 10:  V= 'ATTENUATOR SETTING'
		 11:  V= 'BEAM STOP SETTING'
		 else:V= 'UNDEFINED'
		 endcase
		endif  

   ELSE:	ii=EXECUTE('V='+geoMadStr(3,idx))
   ENDCASE
   IF S eq 3.14 then IF DialType eq 'status' then V= 'Idle' ;FOR TESTS
   
ENDIF
return, V
end
;HACKED by Mark to remove GEORGE dependencies


FUNCTION DIAL_MAD_SEND, DialType, Check, Commd, DialName
;******* *************
;**
common geoMad_sface, geoMadPth, geoMadmin
R=3.14
;**********
;First call
;**********
if n_elements(geoMadPth) eq 0 then begin geoMadPth='/users/mad/IDL_MAD_SERVER/ex1.so'
					 bid=FINDFILE(geoMadPth,count=nn)
					 if nn lt 1 then geoMadPth=''
					 geoMadmin=0.1 & endif                ; Minimum check waiting time
if n_elements(DialName)  ne 1 then DialName=''
;**********
;Send Commd
;**********
;Care with Check !!!!!!!!!!!!!!!!!!
;***************

IF  geoMadPth ne '' then  $
FOR i=0,n_elements(Commd)-1 do BEGIN
    if R ge 0 then begin
      ;print,'Sending: '+Commd(i)
       R= CALL_EXTERNAL(geoMadPth,'put_mad_command',Commd(i))                 ; Send the command
      ;print,'Returned status from Mad-Idl:',R
    endif
    if R ge 0 then $
    if Check gt 0 then begin chk=Check > geoMadmin & V=-1
			 if DialType eq 'PAD' then   V= 0 $                   ; At this time, no wait from the Pad !
					      else wait,chk < geoMadmin       ; Get Mad running
			 while (V ne 0) do begin
			     V=DIAL_MAD_READ('flagus')
			     if DialName gt ' ' then $
			     if not DialOn(0) then begin R=3.14 & V=0 & endif ; User stopped the Dial !
			     if V lt 0        then begin R=-1   & V=0 & endif ; Mad is not running  !
			     if V ne 0        then wait, chk                  ; wait if not Idle  !
			 endwhile
		   endif
ENDFOR
return, R
end
;******************************************************************************
;------------------------------------------------------------------------------
;
	PRO dial_madview_macro, Dial
;
;       Displays MAD output in window
;
;						JRS 10/8/01
;******************************************************************************
;------------------------------------------------------------------------------

	COMMON c_lamp_font

;	ft_biggest , ft_bigger  , ft_normal , ft_smaller, ft_smallest,$
;	ft_b_bigger, ft_b_normal, ft_propor
	
	IF(Dial.init EQ 0) THEN BEGIN
		Dial.init=1
		ML_BASE_0=Widget_Base(TITLE="MAD Output")
		ML_TEXT_0=Widget_Text(ML_BASE_0,XSIZE=78,YSIZE=60,/SCROLL $
			,FONT=ft_propor)
		Widget_Control,ML_BASE_0,/REALIZE
		Dial.tbase=ML_TEXT_0
 	ENDIF
	V=DialNewValue(/setvalue)
	V=STRTRIM(V,2)
	IF(N_ELEMENTS(V) GT 1) OR (V(0) GT " ") THEN BEGIN
		Widget_Control,Dial.tbase,BAD_ID=ii,SET_VALUE=V,/APPEND
		IF(ii NE 0) THEN DIAL.init=0
	ENDIF	
   	END

function dial_madview
;******* ***********
;**

    RETURN, {NAME:'madlog',GENERIC:'mad',TYPE:'log',VALUE:'',FREQUENCY:1,$
	     INIT:0,TBASE:0L}
    END
;*********************
PRO dial_monit_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_monit
;** This macro procedure is called by George every D.frequency seconds

    w1=monit(loops=D.loops,hole=D.holes)
end



;*********************
FUNCTION dial_monit
;*********************
;**
;** The dial initialisation

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='monitor'   ;then V=DialNewValue() stands for V=DialNewValue(TYPE='monitor')
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=120.   ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=fltarr(64) ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=none 0=plot 1=surface 2=contour n>2 means show vector of last n scalar values
    UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file monit.his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds
    WUPDATE=0        ;=1 to automaticaly update corresponding workspace, =-1 silent!
                     ;=2 to automaticaly update and plot workspace to the main window
                     ;   0,1,2 are set by pressing the left,middle,right mouse button on the dial snapshot

   ;User Variables (Must be present in return statement to be available)
   ;-------------
    INIT=0           ;may be used in monit_macro when started or on reset
    XVALUE=fltarr(64);Abscissa of VALUE  (ordinates go in YVALUE)
    X_TIT='I am X'   ;X axis title       (Y axis title go in Y_TIT)
    loops=1        ;pause after loops monitored numors
    holes=1        ;accept missing numors

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,INIT:init,holes:holes,loops:loops}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_monit_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V ,[tag='VALUE']           ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;*********************
PRO dial_mydata_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_mydata

    if D.DIMS(0) eq 0 then begin
	V=DialNewValue(type='t_res')
	D.DIMS=V.par_tof
    ENDIF

    V=DialNewValue()

	t=D.DIMS(1)
	y=D.DIMS(3)-D.DIMS(2)+1
	x=D.DIMS(5)-D.DIMS(4)+1  &  print,t,y,x
	
	V=V(0:x*y*t-1)
	V=reform(V, t,y)
	help,V
    DialModValue,V
end



;*********************
FUNCTION dial_mydata
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='data'      ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=6.    ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0          ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------
    DIMS=fltarr(6)
    

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,plot:PLOT,DIMS:dims}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_mydata_macro :
;** *************
;** V=DialNewValue([/SETVALUE, COMMENT=txt])   ;Get a new value from DIAL_'generic'_READ
;**                                            (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
	PRO dial_numor_macro, D
;** ****************
;**

	saverun=D.par(0)
	lastnosaverun=D.par(1)

	D.type='log'	& V=DialNewValue()

	D.type='flagus'	& status=DialNewValue()
	IF (status NE 1 AND status NE 8) THEN RETURN	; not counting or updating

	numor=0
	saverun=-1
	found0=STRPOS(V,'Start run    NUMOR=')
	IF (found0 NE -1) THEN saverun=1
	found1=STRPOS(V,'Start run    (no save)')
	IF (found1 NE -1) THEN saverun=0
	IF (saverun EQ 1) THEN numor=LONG(STRMID(V,found0+19,7)) $
	ELSE IF (saverun EQ 0) THEN numor=lastnosaverun+1

	found2=STRPOS(V,'Temporary NUMOR')
	IF (found2 NE -1) THEN lastnosaverun=LONG(STRMID(V,found2+15,7))

	D.par(0)=saverun
	D.par(1)=lastnosaverun

	IF (numor NE 0) THEN D.value=numor

	PRINT,'numor=',D.value,' saverun=',D.par(0),' lastnosaverun=',D.par(1)

	RETURN
	END

	FUNCTION dial_numor
;******* ***********
;**
	RETURN, {NAME:'numor', GENERIC:'mad', TYPE:'log', VALUE:0L, $
		FREQUENCY:1.0, PLOT:-2, PAR:LONARR(10)}
	END
;*********************
PRO dial_omega_rot_macro, D
;*********************
;**
;** Rotates omega back and fore

    IF(D.init NE 1) THEN BEGIN
	D.init=1
    ENDIF
    V=DialNewValue()
    D.value=V(4)
    D.current=D.value
    IF(D.dir EQ 0 AND D.current+10 GT 358) THEN D.dir=1
    IF(D.dir EQ 1 AND D.current-10 LT 1) THEN D.dir=0
    IF(D.dir EQ 0) THEN BEGIN
    	D.current=D.current+D.step
    ENDIF ELSE BEGIN
        D.current=D.current-D.step
    ENDELSE
    command='omega '+STRTRIM(STRING(D.current),2)
    C=DialControl(command)

end



;*********************
FUNCTION dial_omega_rot
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='motors'   ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    VALUE=1.	 ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds
    CURRENT=1.
    INIT=0
    DIR=0
   ;Own Variables (optional)
   ;-------------

    STEP=5.
    FREQUENCY=75.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,current:CURRENT,$
         init:INIT,dir:DIR,step:STEP}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_furnace_ramp_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
function dial_PAD_init_d17, dummy
;******* *****************
;**      See Manual about Dials for a good understanding.
;**      This is a template to construct a PAD in the GEORGE-LAMP main interface.
;**      The PAD is used to send control-commands to dial_'generic'_send procedure.
;**      You must return a 5*n string area.
;**      First line is for the input widget_text, the others for buttons.
;**      ACTION 's' to send the COMMAND , 't' to put the COMMAND into the WIDGET_TEXT
;**             'c' to create the command from a GUI.
;**             'i' concern the first line (Important: generic must be the same for 'i' & 't')
;**      
;**            LABEL                  COMMAND          ACTION   PROCEDURE      WAIT
;**     'Input Widget_text'      ''                      'i'   ,'generic'    ,'check'
;**     'Button label'           'Command to send'       's'   ,'generic'    ,'check'
;**     'Button label'           'Command to show'       't'   ,'generic'    ,'check'
;**     'Button  menu'           ''                      '-'   ,''           ,' '
;**       '-sub  button'         'Command to send'       's'   ,'generic'    ,'check'
;**       '-sub  button'         'Command to show'       't'   ,'generic'    ,'check'
;**       '-sub    menu'         ''                      '-'   ,''           ,' '
;**         '--sub sub but'      'Command to send'       's'   ,'generic'    ,'check'
;**etc..

PAR1= [        ' '              ,' '                    ,'i'   ,'mad'        ,'0']
PAR1= [[PAR1],['D17 data'       ,'d17data'              ,'s'   ,'startup'   ,'0']]
PAR1= [[PAR1],['D17 spy'        ,'d17status'            ,'s'   ,'startup'   ,'0']]

                                 
return, PAR1
end
function dial_PAD_init_d22, dummy
;******* *****************
;**      See Manual about Dials for a good understanding.
;**      This is a template to construct a PAD in the GEORGE-LAMP main interface.
;**      The PAD is used to send control-commands to dial_'generic'_send procedure.
;**      You must return a 5*n string area.
;**      First line is for the input widget_text, the others for buttons.
;**      ACTION 's' to send the COMMAND 
;**             't' to put the COMMAND into the WIDGET_TEXT
;**             'c' to create the command from a GUI.
;**             'i' concern the first line (Important: generic must be the same for 'i' & 't')
;**      
;**            LABEL                  COMMAND          ACTION   PROCEDURE      WAIT
;**     'Input Widget_text'    , ''                    , 'i'   , 'generic'    , 'check'
;**     'Button label'         , 'Command to send'     , 's'   , 'generic'    , 'check'
;**     'Button label'         , 'Command to show'     , 't'   , 'generic'    , 'check'
;**     'Button  menu'         , ''                    , '-'   , ''           , ' '
;**       '-sub  button'       , 'Command to send'     , 's'   , 'generic'    , 'check'
;**       '-sub  button'       , 'Command to show'     , 't'   , 'generic'    , 'check'
;**       '-sub    menu'       , ''                    , '-'   , ''           , ' '
;**         '--sub sub but'    , 'Command to send'     , 's'   , 'generic'    , 'check'
;**etc..

PAR1= [        ' '              ,' '                                           , 'i', 'mad', '0']
PAR1= [[PAR1],[' Setup  '      ,' '                                            , '-', ' '  , '0']]

PAR1= [[PAR1],[  '-Experiment information','startupdata'                       , 's', 'startup', '0']]
PAR1= [[PAR1],[  '-Q-range'               ,'d22qrange'                         , 's', 'startup', '0']]
PAR1= [[PAR1],[  '-Beam centre'           ,'d22centre'                         , 's', 'startup', '0']]
PAR1= [[PAR1],[  '-Changer file'          ,'changer_file'                      , 's', 'startup', '0']]
PAR1= [[PAR1],[  '-Kinetics files'        ,'d22kin'                            , 's', 'startup', '0']]

PAR1= [[PAR1],[  '-Instrument settings '  ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[    '--All settings'       ,' ~det~Detector distance (m)~ ~ ~col~Collimation (m)~ ~ ~dtr~offset (mm)~ ~ ~bx~Bx (mm)~ ~ ~by~By (mm)'  ,'c' ,'mad' ,'0']]
PAR1= [[PAR1],[    '--Detector distance'  ,' ~det~Detector distance (m)~ '     , 'c' ,'mad', '0']]
PAR1= [[PAR1],[    '--Collimation'        ,' ~coll~Collimation (m)~ '          , 'c' ,'mad', '0']]
PAR1= [[PAR1],[    '--Detector offset'    ,' ~dtr~offset (mm)~ '               , 'c' ,'mad', '0']]
PAR1= [[PAR1],[    '--Beamstop'           ,' ~bx~Bx (mm)~ ~ ~by~By (mm)~ '     , 'c' ,'mad', '0']]
PAR1= [[PAR1],[    '--Wavelength'         ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[    '---Wavelength'        ,' ~wav   ~Wavelength (Angstrom)~ '  , 'c', 'mad' ,'0']]
PAR1= [[PAR1],[    '---Selector speed'    ,' ~sel~Selector speed (rpm)~    '   , 'c', 'mad', '0']]

PAR1= [[PAR1],[  '-Rack  ', ' '                                                , '-', ' ',   '0']]
PAR1= [[PAR1],[  '--Read parameters'      ,'par cha'                           , 's', 'mad', '0']]
PAR1= [[PAR1],[  '--Choose rack'          ,' ~par cha set~rack #~'             , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '--Set parameters'       ,' ~par cha~rack #~1~pos.1~~incr.~-40~number~22', 'c', 'mad', '0']]

PAR1= [[PAR1],[  '-Temperature  '         ,' '                                 , '-', ' ' ,'0']]
PAR1= [[PAR1],[  '--Cryo'                 ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '---Set cryo temp'       ,'   ~pte~Set point(K)~    '         , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '---enable'              ,'par cryo 1'                        , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---disable'             ,'par cryo 0'                        , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---line speed'          ,'   ~par  rs232~line speed~9600'    , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '--Bath temp (DAC)'      ,'   ~bath~temperature (C)~    '     , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '--Bath temp RS232'      ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '---temperature   '      ,'   ~pte~temperature (C)~    '      , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '---line speed'          ,'   ~par  rs232~line speed~9600'    , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '--Eurotherm'            ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '---command'             ,'   ~eudev~ch. string~    '         , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '---line speed'          ,'   ~par  rs232~line speed~4800'    , 'c', 'mad', '0']]

PAR1= [[PAR1],[  '-Voltmeter'             ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '--1'                    ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '---reading'             ,'   ~ieee1'                         , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto Volt params'    ,'   ~par ieee1 1 1 2'               , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto Amps params'    ,'   ~par ieee1 1 3 2'               , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto Ohms params'    ,'   ~par ieee1 1 2 2'               , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto off'            ,'   ~par ieee1 0'                   , 's', 'mad', '0']]
PAR1= [[PAR1],[  '--2'                    ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '---reading'             ,'   ~ieee2'                         , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto Volt params'    ,'   ~par ieee2 1 1 2'               , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto Amps params'    ,'   ~par ieee2 1 3 2'               , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto Ohms params'    ,'   ~par ieee2 1 2 2'               , 's', 'mad', '0']]
PAR1= [[PAR1],[  '---auto off'            ,'   ~par ieee2 0'                   , 's', 'mad', '0']]

PAR1= [[PAR1],['  Dials   '               ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '-D22 data'              ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '--Start'                ,'d22data'                           , 's', 'startup', '0']]
;PAR1= [[PAR1],[  '--log plot'             ,'d22data~LOG~1'                     , 's', 'properties', '0']]
;PAR1= [[PAR1],[  '--lin plot'             ,'d22data~lOG~0'                     , 's', 'properties', '0']]
PAR1= [[PAR1],[  '--log plot'             ,'DialTag,"d22data",TAG="LOG",SET=1' , 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--lin plot'             ,'DialTag,"d22data",TAG="LOG",SET=0' , 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--sqr plot'             ,'DialTag,"d22data",TAG="LOG",SET=2' , 's', 'lamp', '0']]
PAR1= [[PAR1],[  '-Diagram'               ,' '                                 , '-', ' '  , '0']]
;PAR1= [[PAR1],[  '--log plot'             ,'d22data~DLOG~1'                    , 's', 'properties', '0']]
;PAR1= [[PAR1],[  '--lin plot'             ,'d22data~DlOG~0'                    , 's', 'properties', '0']]
PAR1= [[PAR1],[  '--log plot'             ,'DialTag,"d22data",TAG="DLOG",SET=1', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--lin plot'             ,'DialTag,"d22data",TAG="DLOG",SET=0', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--sqr plot'             ,'DialTag,"d22data",TAG="DLOG",SET=2', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '-X projection'          ,' '                                 , '-', ' '  , '0']]
;PAR1= [[PAR1],[  '--log plot'            ,'d22data~XLOG~1'                    , 's', 'properties', '0']]
;PAR1= [[PAR1],[  '--lin plot'            ,'d22data~XlOG~0'                    , 's', 'properties', '0']]
PAR1= [[PAR1],[  '--log plot'             ,'DialTag,"d22data",TAG="XLOG",SET=1', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--lin plot'             ,'DialTag,"d22data",TAG="XLOG",SET=0', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--sqr plot'             ,'DialTag,"d22data",TAG="XLOG",SET=2', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '-Y projection'          ,' '                                 , '-', ' '  , '0']]
;PAR1= [[PAR1],[  '--log plot'             ,'d22data~YLOG~1'                    , 's', 'properties', '0']]
;PAR1= [[PAR1],[  '--lin plot'             ,'d22data~YlOG~0'                    , 's', 'properties', '0']]
PAR1= [[PAR1],[  '--log plot'             ,'DialTag,"d22data",TAG="YLOG",SET=1', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--lin plot'             ,'DialTag,"d22data",TAG="YLOG",SET=0', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '--sqr plot'             ,'DialTag,"d22data",TAG="YLOG",SET=2', 's', 'lamp', '0']]
PAR1= [[PAR1],[  '-Status'                ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '--Start'                ,'status'                            , 's', 'startup', '0']]

PAR1= [[PAR1],['Acquisition'              ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '-Sample title  '        ,' ~par sub~sample title (20 char.)~1_dummy' , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '-Changer       '        ,' ~cha    ~position #~ '            , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '-Run           '        ,' ~run    ~duration  ~ ~t(s)/m~t~times~1', 'c', 'mad', '0']]
PAR1= [[PAR1],[  '-Kinetics      '        ,' ~kin    ~time file name   ~ ~repetitions~1~no/save~s '              ,'c', 'mad', '0']]
;PAR1= [[PAR1],[  '-Kinetic status'        ,'unix kin'                          , 's', 'mad', '0']]
PAR1= [[PAR1],[  '-Check         '        ,' ~check  ~command file name~ ~repetitions~1','c', 'mad', '0']]
PAR1= [[PAR1],[  '-Start         '        ,' ~start  ~command file name~ ~repetitions~1','c', 'mad', '0']]
PAR1= [[PAR1],[  '-Scan          '        ,' ~scan   ~motor name~ ~from~ ~to~ ~step~ ~ ~run~time~10~t/m~t~no/align~a'         ,'c', 'mad', '0']]
PAR1= [[PAR1],[  '-Adjust        '        ,' ~adjust ~on position~ '           , 'c', 'mad', '0']]
PAR1= [[PAR1],[  '-Wait          '        ,' ~wait    ~time [sec]~ '           , 'c', 'mad', '0']]

PAR1= [[PAR1],['     Stop     '           ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],[  '-no save'               ,'stop n'                            , 's', 'mad', '0']]
PAR1= [[PAR1],[  '-save'                  ,'stop s'                            , 's', 'mad', '0']]

PAR1= [[PAR1],[' Pause '                  ,'pause'                             , 's', 'mad', '0']]

PAR1= [[PAR1],['Resume'                   ,'resume'                            , 's', 'mad', '0']]


PAR1= [[PAR1],['Attenuators'              ,' '                                 , '-', ' '  , '0']]
PAR1= [[PAR1],['-3 (1/3000)   '           ,'att c 3'                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-2 (1/900)    '           ,'att c 2'                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-1 (1/150)    '           ,'att c 1'                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-in           '           ,'att in '                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-out          '           ,'att out'                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-4 (ap.  5 mm)'           ,'att c 4'                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-5 (ap. 10 mm)'           ,'att c 5'                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-6 (ap. 20 mm)'           ,'att c 6'                           , 's', 'mad', '0']]
PAR1= [[PAR1],['-7 (ap. 30 mm)'           ,'att c 7'                           , 's', 'mad', '0']]
                               
PAR1= [[PAR1],['    Help      '           ,' '                                 , '-', 'mad', '0']]
PAR1= [[PAR1],['-not yet ...'             ,' '                                 , 's', 'mad', '0']]
PAR1= [[PAR1],['-sorry      '             ,' '                                 , 's', 'mad', '0']]

return, PAR1
end

;******************************************************************************
;------------------------------------------------------------------------------
;
	FUNCTION dial_PAD_init_d7, dummy
;
;       Creates the D7 MAD pad
;
;						JRS 16/5/02
;
;******************************************************************************
;------------------------------------------------------------------------------

PAR1= [        ' '              ,' '                                                                            ,'i'   ,'mad'        ,'0']
PAR1= [[PAR1],['Count ->'       ,'COUNT'                                                                        ,'s'   ,'d7count'    ,'0']]
PAR1= [[PAR1],['Stop ->'        ,' '                                                                            ,'-'   ,' '          ,'0']]
PAR1= [[PAR1],[  '-next'        ,'stop next'                                                                    ,'s'   ,'mad'        ,'0']]
PAR1= [[PAR1],[  '-last'        ,'stop last'                                                                    ,'s'   ,'mad'        ,'0']]
PAR1= [[PAR1],['Pause'          ,'pause'                                                                        ,'s'   ,'mad'        ,'0']]
PAR1= [[PAR1],['Resume'         ,'resume'                                                                       ,'s'   ,'mad'        ,'0']]
PAR1= [[PAR1],['Set Par ->'     ,'PARAMS'                                                                       ,'s'   ,'d7params'   ,'0']]
PAR1= [[PAR1],['LAUNCH ->'		,' '                                                                    ,'-'   ,' '          ,'0']]
PAR1= [[PAR1],[  '-Flipper'      	,'flipper_d7'                                                           ,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Status'	 	,'d7status'                                                          	,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-MAD Log'      	,'madview'                                                              ,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Pol HYTEC Data'	,'hytec_data'                                                          	,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Nopo HYTEC Data'	,'hytec_data_all'                                                       ,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-TOF Data'    	,'tof_data'                                                             ,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Nopo TOF Data'    	,'tof_data_all'                                                         ,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Temp Scan'		,'temp_ramp'                                                          	,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Furnace Ramp'	,'furnace_ramp'                                                         ,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Rotate Omega'	,'omega_rot'                                                            ,'s'   ,'startup'    ,'0']]
PAR1= [[PAR1],[  '-Monitor 1'		,'d7monitor1'                                                          	,'s'   ,'startup'    ,'0']]
                                 
RETURN, PAR1
END
function dial_PAD_init, dummy
;******* *************
;**      See Manual about Dials for a good understanding.
;**      This is a template to construct a PAD in the GEORGE-LAMP main interface.
;**      The PAD is used to send control-commands to dial_'generic'_send procedure.
;**      You must return a 5*n string area.
;**      First line is for the input widget_text, the others for buttons.
;**      ACTION 's' to send the COMMAND , 't' to put the COMMAND into widget_text.
;**             'c' to create the command from a GUI.
;**             '-' for a menu button.
;**             'i' concern the first line (Important: generic must be the same for 'i' & 't').
;**      
;**            LABEL                     COMMAND          ACTION   PROCEDURE      WAIT seconds
;**     'Input Widget_text'         ''                      'i'   ,'generic'     ,'0'
;**     'Button label'              'Command to send'       's'   ,'generic'     ,'0'
;**     'Button label'              'Command to show'       't'   ,'generic'     ,' '
;**     'Button  menu'              ''                      '-'   ,''            ,' '
;**       '-sub  button'            'Command to send'       's'   ,'generic'     ,' '
;**       '-sub  button'            'Command to show'       't'   ,'generic'     ,' '
;**       '-sub    menu'            ''                      '-'   ,''            ,' '
;**         '--sub sub but'         'Command to send'       's'   ,'generic'     ,' '
;**etc..

PAR1= [        ' '                 ,'show,systime()'      ,'i'   ,'lamp'        ,' ' ]

PAR1= [[PAR1],[' '                 ,'show,systime()'      ,'s'   ,'lamp'        ,' ' ]]
PAR1= [[PAR1],[' '                 ,'print,systime()'     ,'s'   ,'lamp'        ,' ' ]]
PAR1= [[PAR1],[' '                 ,'print,systime()'     ,'s'   ,'lamp'        ,' ' ]]
PAR1= [[PAR1],[' '                 ,'show,systime()'      ,'s'   ,'lamp'        ,' ' ]]

PAR1= [[PAR1],['Tornade'           ,' '                   ,'-'   ,' '           ,' ' ]]
PAR1= [[PAR1],[ '-Start  Tornade ' ,'tornade'             ,'s'   ,'startdial'   ,' ' ]]
PAR1= [[PAR1],[ '-Stop   Tornade ' ,'tornade'             ,'s'   ,'stopdial'    ,' ' ]]
PAR1= [[PAR1],[ '-Resume Tornade ' ,'tornade'             ,'s'   ,'resumedial'  ,' ' ]]
PAR1= [[PAR1],[ '-Clear  Tornade ' ,'tornade'             ,'s'   ,'cleardial'   ,' ' ]]

PAR1= [[PAR1],[ 'Template'         ,' '                   ,'-'   ,' '           ,' ' ]]
PAR1= [[PAR1],[ '-Start Templates' ,'template1'           ,'s'   ,'startdial'   ,' ' ]]
PAR1= [[PAR1],[ '-Clear Templates' ,'template1~template2~template3~template4' ,'s'   ,'cleardial'   ,' ' ]]

PAR1= [[PAR1],['Cron'              ,' '                   ,'-'   ,' '           ,' ' ]]
PAR1= [[PAR1],[ '-Start SaveSess.' ,'savsession'          ,'s'   ,'startdial'   ,' ' ]]
PAR1= [[PAR1],[ '-Clear SaveSess.' ,'savsession'          ,'s'   ,'cleardial'   ,' ' ]]
PAR1= [[PAR1],[' '                 ,'print,systime()'     ,'s'   ,'lamp'        ,' ' ]]

return, PAR1
end
FUNCTION dial_properties_send, dummy1,dummy2, text, button
;*******
;**
;** Called from the Pad, generaly to start and stop Dials

prop=strlowcase(strtrim(str_sep(text(0),'~'),2))

FOR i=0,n_elements(prop)-1 DO BEGIN
 CASE prop(i) of
 'dlog':	DialTag,'d22data',TAG='DLOG',set=1
 'dlin':	DialTag,'d22data',TAG='DLOG',set=0
 ELSE:
 ENDCASE
ENDFOR

return,0
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_properties_send :
;** *************
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;*********************
PRO dial_prox_macro, D
;*********************
;**
;** Input D is the dial structure as defined by the function dial_prox
;** This macro procedure is called by George every D.frequency seconds

DialInit,'xbu',d=D.number ,NEW='prox'
DialTag ,d=D.number ,tag='GENERIC'   ,set='lamp'
DialTag ,d=D.number ,tag='FREQUENCY' ,set=.5
DialTag ,d=D.number ,tag='ONOFF'     ,set=1

end



;*********************
FUNCTION dial_prox
;*********************
;**
;** The dial constructor

    return,{ONOFF:1}
end
FUNCTION dial_resumedial_send, dummy1,dummy2, text, button
;*******
;**
;** Called from the Pad, generaly to start and stop Dials

Dials=strlowcase(strtrim(str_sep(text(0),'~'),2))

FOR i=0,n_elements(Dials)-1 DO BEGIN
    Dialstart ,Dials(i)
ENDFOR

return,0
end
;*********************
PRO dial_savsession_macro, D
;*********************
;**
;** The dial method

SaveSession
DialModValue,systime()
end

;*********************
FUNCTION dial_savsession
;*********************
;**
;** The dial constructor

return, {FREQUENCY:600}  ;run every 10 minutes
end
PRO scheme
;** ******
FORWARD_FUNCTION DialControl, DialNewValue, DialOn
if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

dial_bygeorge,'scheme'   ;<-------- Name of your Dial !!!
END                      ;          ~~~~~~~~~~~~~~~~~ !!!

;-------------------------------------------------
;--------------------Here is your Dial----------
;---------------------------------------------

PRO dial_scheme_macro, D
;** *****************

V=DialNewValue('status',/setvalue)
IF V eq 'Idle' then BEGIN

   CASE D.init of
   0:BEGIN D.init = 1         & c=DialControl(' ')
           D.value='1'                        & END
   1:BEGIN D.init = 2         & c=DialControl(' ')
           D.frequency=2.1    & D.value='2'   & END	   
   2:BEGIN D.init = 3         & V=DialNewValue('t_para')
           D.value='3'                        & END
   3:BEGIN D.init = 4         & c=DialControl(' ')
           D.frequency=1.2    & D.value='4'   & END	   
   4:BEGIN D.value='off'      & c=DialControl(' ')
           DialStop                           & END
   ELSE:
   ENDCASE

ENDIF else D.value=V
END

;******* ***********
FUNCTION dial_scheme & return,{init:0} & END
;******* ***********
;*********************
PRO dial_showx_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_showx

end



;*********************
FUNCTION dial_showx
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='monitor'   ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0          ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_showx_macro :
;** *************
;** V=DialNewValue([/SETVALUE, COMMENT=txt])   ;Get a new value from DIAL_'generic'_READ
;**                                            (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;*********************
PRO dial_showy_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_showy

IF D.pater gt 0 then begin
	DialTag, d=D.pater,tag='ONOFF',get=onoff
	DialTag, d=D.pater,tag='FREQUENCY',get=freq
	IF onoff THEN D.frequency=freq ELSE DialStop
ENDIF

end



;*********************
FUNCTION dial_showy
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='monitor'   ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0        ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;User Variables (optional)
   ;-------------
    INIT=0           ;used when started

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,INIT:init,XVALUE:0,PATER:0}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_showy_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
FUNCTION dial_startdial_send, dummy1,dummy2, text, button
;*******
;**
;** Called from the Pad, generaly to start and stop Dials

Dials=strlowcase(strtrim(str_sep(text(0),'~'),2))

FOR i=0,n_elements(Dials)-1 DO BEGIN
    DialInit ,Dials(i)
    DialStart,Dials(i)
ENDFOR

return,0
end
FUNCTION DIAL_STARTSCAN_SEND, DialType, Check, Commd, DialName
;******* *******************
;**

print,"I'm StartScan and got cmd:"+Commd

DialInit ,"template1"
DialTag  ,"template1",tag="FREQUENCY",set=1
DialTag  ,"template1",tag="HISTORY"  ,set=1
DialStart,"template1"

R=dial_mad_send( DialType, Check, Commd, DialName)



return, R
end
;**************************
;TO RUN THIS DIAL START IDL, THEN ENTER:  
;Idl>.run dial_startupdata
;Idl> startupdata    
;**************************



pro test_empty, inf, i, ok
;******* *****************
;**
common startup_error, error4

if strlen(strtrim(inf[0],2)) le 0 then begin
  case i of
    1:begin
      temp='user name'
    end
    2:begin
      temp='proposal number'
    end
    3:begin
      temp='experiment title'
    end
    4:begin
      temp='starting date'
    end
    5:begin
      temp='logbook number'
    end
    6:begin
      temp='parameter description control'
    end
    7:begin
      temp='sample title'
    end
  end
;--------------------------------- ERROR ---------------------------------------
  ok=ok+1
  widget_control,error4,set_value='*** enter value for '$
  	+string(temp)+' field ***'
;-------------------------------------------------------------------------------
endif

return
end


pro startupdata
;** *********
;Used to run with "byGeorge"
FORWARD_FUNCTION DialControl, DialNewValue, DialOn
if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

dial_bygeorge,'startupdata'	;<-------- Name of your Dial !!!
END                      	;          ~~~~~~~~~~~~~~~~~ !!!



;*******************************************************************************
;*******************************************************************************
pro startupdata_event,ev
;*******************************************************************************
;*******************************************************************************

common startup_base, base0
common startup_error, error4

widget_control,ev.id,get_uvalue=uva

case uva(0) of

2001:	begin 
	widget_control,ev.id,get_value=user0 
	widget_control,uva(2),set_value=''
	ok=0
	test_empty, user0, 1, ok
	;tabb[1]=user0
end

2002:	begin widget_control,ev.id,get_value=prop0
	widget_control,uva(2),set_value=''
	ok=0
	test_empty, prop0, 2, ok
	;tabb[2]=prop0
end

2003:	begin widget_control,ev.id,get_value=title0
	widget_control,uva(2),set_value=''
	ok=0
	test_empty, title0, 3, ok
	;tabb[3]=title0
end

2004:	begin widget_control,ev.id,get_value=date0
	widget_control,uva(2),set_value=''
	ok=0
	test_empty, date0, 4, ok
	;tabb[4]=date0
end

2005:	begin widget_control,ev.id,get_value=book0
	widget_control,uva(2),set_value=''
	ok=0
	test_empty, book0, 5, ok
	;tabb[5]=book0
end

2006:	begin widget_control,ev.id,get_value=pardes0
	widget_control,uva(2),set_value=''
	ok=0
	test_empty, pardes0, 6, ok
	;tabb[6]=pardes0
end

2007:	begin widget_control,ev.id,get_value=sample0
	widget_control,uva(2),set_value=''
	ok=0
	test_empty, sample0, 7, ok
	;tabb[7]=sample0
end

2011:	begin 
;------ OKK1 is the condition that allows to write to MAD (0) or not (>0) ----
	okk1=0
	widget_control,uva(8),set_value=''
	for i=1,7 do begin
	  widget_control,uva(i),get_value=inf
	  test_empty, inf, i, okk1
	  ;print,"ok: ",okk1
	endfor
	V1 =DialNewValue(TYPE='t_nother',NAME='startupdata')
	activity=fix(V1.cstate)
	print,'Current status is ',activity
	if activity eq 0 then begin
	  widget_control,uva(1),get_value=user0 
	  widget_control,uva(2),get_value=prop0
	  widget_control,uva(3),get_value=title0
	  widget_control,uva(4),get_value=date0
	  widget_control,uva(5),get_value=book0
	  widget_control,uva(6),get_value=pardes0
	  widget_control,uva(7),get_value=sample0
	  if okk1 eq 0 then begin
	    arg=strtrim(user0,2)
	    R =DialControl ('par user '+arg,NAME='startupdata')	
	    arg=strtrim(prop0,2)
	    R =DialControl ('par prop '+arg,NAME='startupdata')	
	    arg=strtrim(title0,2)
	    R =DialControl ('par title '+arg,NAME='startupdata')	
	    arg=strtrim(date0,2)
	    R =DialControl ('par date '+arg,NAME='startupdata')	
	    arg=strtrim(book0,2)
	    R =DialControl ('par log '+arg,NAME='startupdata')	
	    arg=strtrim(pardes0,2)
	    R =DialControl ('par pardes '+arg,NAME='startupdata')	
	    arg=strtrim(sample0,2)
	    R =DialControl ('par sub '+arg,NAME='startupdata')
	    widget_control,uva(8),$
	    	set_value='*** Values have been sent to MAD ***'
	  endif
	endif else begin
	  widget_control,uva(8),set_value='*** instrument isn''t idle ***'
	endelse
end

;------- GET VALUE OF DATE, TITLE, USER, PROP, LOG BOOK FROM INSTRUMENT --------
2012:	begin
	para =DialNewValue(TYPE='t_para',NAME='startupdata')

	user_n=string(para.c_user[0])
	for i=1,9 do begin
		user_n=user_n+string(para.c_user[i])
	endfor

	prop_n=string(para.proposal_number[0])
	for i=1,7 do begin
		prop_n=prop_n+string(para.proposal_number[i])
	endfor

	title_n=string(para.c_txt[0])
	for i=1,31 do begin
		title_n=title_n+string(para.c_txt[i])
	endfor

	date_n=string(para.exp_start_time[0])
	for i=1,10 do begin
		date_n=date_n+string(para.exp_start_time[i])
	endfor

	book_n=string(para.log_book_n[0])+string(para.log_book_n[1])$
		+string(para.log_book_n[2])

	sample_n=string(para.sub_title[0])
	for i=1,19 do begin
		sample_n=sample_n+string(para.sub_title[i])
	endfor
	
	pardes_n=string(format='(I1)',para.pardesc)
	if pardes_n eq '1' then pardes_n='on'
	if pardes_n eq '0' then pardes_n='off'

	widget_control,uva(1),set_value=user_n;		user
	widget_control,uva(2),set_value=prop_n;		prop
	widget_control,uva(3),set_value=title_n;	title
	widget_control,uva(4),set_value=date_n;		date
	widget_control,uva(5),set_value=book_n;		book
	widget_control,uva(6),set_value=pardes_n;	pardes
	widget_control,uva(7),set_value=sample_n;	sample
	widget_control,uva(8),set_value=' ';		error field
end
;-------------------------------------------------------------------------------

2013:	begin 
	widget_control,base0,/destroy
	DialClear, 'startupdata'
end

end
end


;*******************************************************************************
;*******************************************************************************
pro startupdata_gui
;** ****************
;**

common startup_base, base0
common startup_error, error4

if xregistered('startupdata_gui') eq 0 then begin

	base0  =widget_base(group_leader=changer_based0,$
		title='Experiment Info',/column)

;	base01 =widget_label(base0,frame='5',$
;		value='fill in user information')
	err4   =string(format='(I80)','')
	error4 =widget_label(base0,value=err4)

	base1  =widget_base(base0, /row)
	base10 =widget_base(base1, /column)
	base11 =widget_base(base10,/column)
	base111=widget_base(base10,/row)
	base12 =widget_base(base1,/column)

	base13 =widget_base(base0,/column,/align_center)
	base14 =widget_base(base0,/column)
	base15 =widget_base(base0,/column)

;-------------------------------- BASE CREATION --------------------------------
	user=  cw_field(base11,xsize=10,title='user (10 char)',/return_events)
	prop=  cw_field(base11,xsize=8,title='proposal #:    ',/return_events)
	title= cw_field(base11,xsize=32,title='title (32 char):',/return_events)
	date=  cw_field(base11,xsize=11,title='starting date (dd-mmm-yyyy):',$
		/return_events)
	book=  cw_field(base11,xsize=2,title='log book #:    ',/return_events)
	pardes=cw_field(base11,xsize=3,title='Parameter description {on/off):',$
		/return_events)
	sample=cw_field(base11,xsize=20,title='sample (20 char):',$
		/return_events)

	but01=widget_button(base13,frame=10,xsize=250,value='send to MAD')
	but02=widget_button(base13,xsize=250,value='reset to MAD values')
	but03=widget_button(base13,xsize=250,value='done')

	widget_control,base0,/realize

;------------------------------------- EVENTS ----------------------------------

	widget_control,user,  set_uvalue=[2001,user,error4]
	widget_control,prop,  set_uvalue=[2002,prop,error4]
	widget_control,title, set_uvalue=[2003,title,error4]
	widget_control,date,  set_uvalue=[2004,date,error4]
	widget_control,book,  set_uvalue=[2005,book,error4]
	widget_control,pardes,set_uvalue=[2006,pardes,error4]
	widget_control,sample,set_uvalue=[2007,sample,error4]

	widget_control,but01, set_uvalue=[2011,user,prop,title,date,book,$
		pardes,sample,error4]
	widget_control,but02, set_uvalue=[2012,user,prop,title,date,book,$
		pardes,sample,error4]
	widget_control,but03, set_uvalue=[2013]

	widget_control,error4,set_uvalue=[2014,error4]

;------------ fill the widgets with the values from MAD ----------------
	err4=' '
	widget_control,error4,set_value=string(err4)

	para =DialNewValue(TYPE='t_para',NAME='startupdata')
	;help,para,/struc

	user_n=string(para.c_user[0])
	for i=1,9 do begin
		user_n=user_n+string(para.c_user[i])
	endfor

	prop_n=string(para.proposal_number[0])
	for i=1,7 do begin
		prop_n=prop_n+string(para.proposal_number[i])
	endfor

	title_n=string(para.c_txt[0])
	for i=1,38 do begin
		title_n=title_n+string(para.c_txt[i])
	endfor

	date_n=string(para.exp_start_time[0])
	for i=1,10 do begin
		date_n=date_n+string(para.exp_start_time[i])
	endfor

	book_n=string(para.log_book_n[0])+string(para.log_book_n[1])$
		+string(para.log_book_n[2])

	sample_n=string(para.sub_title[0])
	for i=1,19 do begin
		sample_n=sample_n+string(para.sub_title[i])
	endfor
	
	pardes_n=string(format='(I1)',para.pardesc)
	if pardes_n eq '1' then pardes_n='on'
	if pardes_n eq '0' then pardes_n='off'

	widget_control,user,   set_value=user_n;	user
	widget_control,prop,   set_value=prop_n;	prop
	widget_control,title,  set_value=title_n;	title
	widget_control,date,   set_value=date_n;	date
	widget_control,book,   set_value=book_n;	book
	widget_control,pardes, set_value=pardes_n;	pardes
	widget_control,sample, set_value=sample_n;	sample

	xmanager,'startupdata',base0,/just_reg,group_leader=changer_based0
endif
end

pro dial_startupdata_macro, D
;** *************************
;**

if D.init eq 0 then begin
	D.init=1
	D.frequency=0.
	startupdata_gui

endif else print,'ok'

end

function dial_startupdata
;******* *****************
;**

return, {init:0}
end
FUNCTION dial_startup_send, dummy1,dummy2, text, button
;*******
;**
;** Called from the Pad, generaly to start and stop Dials

Dials=strlowcase(strtrim(str_sep(text(0),'~'),2))

FOR i=0,n_elements(Dials)-1 DO BEGIN
    DialInit ,Dials(i)
    DialTag  ,Dials(i),tag='FREQUENCY',set=1.0
    DialStart,Dials(i)
ENDFOR

return,0
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_startup_send :
;** *************
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;*********************
PRO dial_status_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_status

    V=DialNewValue(/setvalue)
end



;*********************
FUNCTION dial_status
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='status'    ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE='' 	     ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_status_macro :
;** *************
;** V=DialNewValue([/SETVALUE, COMMENT=txt])   ;Get a new value from DIAL_'generic'_READ
;**                                            (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
FUNCTION dial_stopdial_send, dummy1,dummy2, text, button
;*******
;**
;** Called from the Pad, generaly to start and stop Dials

Dials=strlowcase(strtrim(str_sep(text(0),'~'),2))

FOR i=0,n_elements(Dials)-1 DO BEGIN
    Dialstop ,Dials(i)
ENDFOR

return,0
end
;    *********************************************************
;    ************************          ***********************
;    ************************  A DIAL  ***********************
;    ************************          ***********************
;    *********************************************************
;    dial TC
;    **************

;This dial monitors instrument time 

pro  DIAL_TC_MACRO, D
;**  ********************

DialWSet
xyouts, 10,10, STRING(dialNewValue(/SETVALUE)), /DEVICE
PRINT, 'Time- Counts: ',d.V


end





;******* ********************************
;******* ********************************
function DIAL_TC
;******* ********************************
;******* ********************************
;**
;** Input  <none>
;** Output D is the dial structure returned for DialInit()
;********* *********************************************

;inherits="template0"                   ;May inherits tags of Dial "template0"
 inherits=""                            ;    (so, its macro is compiled).

;** Usefull tags:                       ;Only one tag is necessary to validate a Dial
;** ************                        (George creates usefull tags if they are not)
name     ="tc"                   ;Consistent with "dial_template1.pro"
generic  ="mad"                    ;Reading instrument control procedure is:
                                        ;                "dial_template_read.pro"
type     ="time-counts"                 ;Requested value will be the temperature
plot     = -2                          ;Mode for plotting (ex: 50 last values,
                                        ;  -2 for no plot, -1 read into workspace) 
                                        ;  for 2D dials: 1= surface, 2= levels)
value    = 0L                           ;The dial value    set to a correct type &
                                        ;                              dimension
error    = 0.                           ;Idem for error -> value +- error
onoff    = 0                            ;The dial activity set to 0 initially [0,1]
number   = 0                            ;The dial number   set by george (d1...d20)
frequency= 2                         ;The dial specific frequency (in seconds)
duration = 0.0                          ;The dial specific duration  (in seconds)
history  = 0                            ;If 1, values are saved into history file:
                                        ;                     "dial_template1.his"

                ;** Other tags used in your procedure DIAL_TEMPLATE1_MACRO:
                ;** ******************************************************
                unit      =""           ;The dial string unit
                lowerlim  =0.           ;The dial lower limit value
                upperlim  =150.         ;The dial upper limit value
                                        ;   (used also for plotting)   etc......

D={NAME:name, GENERIC:generic, VALUE:value, ONOFF:onoff, FREQUENCY:frequency,  $
              DURATION:duration,UNIT:unit , HISTORY:history, UPPERLIM:upperlim,$
              LOWERLIM:lowerlim, PLOT:plot, TYPE:type, INHERITS:inherits}

return,D
end
;***********************
PRO dial_template1_macro, D
;***********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_template1
;** This macro procedure is called by George every D.frequency seconds

V= DialNewValue()
V= round(sin(V)*100)

if D.init  eq 0 then $
if V gt 50 then begin  D.init=1
                           Cd=DialControl("Start brothers")
                           DialsFrequency, SET=2.
                              DialInit ,  "template2", path=D.PATH
                              DialStart,  "template2"
                              DialTag  ,  "template2", TAG="PLOT", SET=1
                            	 DialInit ,  "template3", path=D.PATH
                            	 DialStart,  "template3"
                            	 DialTag  ,  "template3", TAG="PLOT", SET=0
                            	    DialInit, "template4",path=D.PATH
endif

if D.init then if V lt 50 then DialMacro, "template4"
D.VALUE = V
D.ERROR = sqrt(V)
end

;**********************
FUNCTION dial_template1
;**********************
;**
;** The dial initialisation

   ;Dial Variables (Defaulted if not present in return statement)
   ;--------------
    GENERIC='template' ;Reading control procedure is:"dial_template_read.pro"
    TYPE='temperature' ;then V=DialNewValue() stands for V=DialNewValue(TYPE='temperature')
    ONOFF=0            ;state of the Dial 1=running
    FREQUENCY=1.       ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0            ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    ERROR=0.
    PLOT=50            ;-2=none 0=plot 1=surface 2=contour n>2 means show vector of last n scalar values
    UPPERLIM=150.      ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0          ;=1 to record values in file template1.his
    DURATION=0         ;if >0 then Dial is stopped after running duration seconds
    WUPDATE=0          ;=1 to automaticaly update corresponding workspace

   ;User Variables (Must be present in return statement to be available)
   ;-------------
    INIT=0           ;may be used in template1_macro when started or on reset
    XVALUE=fltarr(64);Abscissa of VALUE  (ordinates go in YVALUE)
    X_TIT='I am X'   ;X axis title       (Y axis title go in Y_TIT)

D={GENERIC:generic, VALUE:value, ONOFF:onoff, FREQUENCY:frequency,  $
              DURATION:duration , HISTORY:history, UPPERLIM:upperlim,$
              PLOT:plot, TYPE:type , INIT:0}

return,D
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_template1_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V ,[tag='VALUE']           ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;***********************
PRO dial_template2_macro, D
;***********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_template2
;** This macro procedure is called by George every D.frequency seconds

V= DialNewValue()
V= round(cos(V)*75)

if V lt 25  then DialMacro, "template4"
D.VALUE=V

end

;**********************
FUNCTION dial_template2
;**********************
;**
;** The dial initialisation

generic  ="template"
upperlim =150.
lowerlim =0.
;inherits="template1"   ;May inherits tags of Dial "template1"
 inherits=""

return, {GENERIC:generic,TYPE:'bidon',UPPERLIM:upperlim,LOWERLIM:lowerlim,INHERITS:inherits,VALUE:0}
end
;***********************
PRO dial_template3_macro, D
;***********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_template3
;** This macro procedure is called by George every D.frequency seconds

V= DialNewValue()
V= round(sin(V)*cos(V)*2*100)

if V lt 25  then DialMacro, "template4"
D.VALUE='S='+string(V)

end

;**********************
FUNCTION dial_template3
;**********************
;**
;** The dial initialisation

return, {GENERIC:'template',TYPE:'bidon',VALUE:''}
end
;***********************
PRO dial_template4_macro, D
;***********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_template4
;** This macro procedure is called by George every D.frequency seconds

V= DialNewValue()
V= round(sin(V)*100)

DialModValue, sin( dist(25)/((V/10.)>1) )

end

;**********************
FUNCTION dial_template4
;**********************
;**
;** The dial initialisation

return, {GENERIC:'template',TYPE:'bidon',VALUE:0}
end
function DIAL_TEMPLATE_READ, name, sequence, ctxt
;******* ******************
;**
common template_read, seq, ran, val

if n_elements (seq) eq 0 then seq=-1.
if n_elements (sequence) ne 1 then sequence=seq+1.
if sequence ne seq then begin seq=sequence & val=randomu(ran,1) & endif

return, val(0)
end
FUNCTION DIAL_TEMPLATE_SEND, DialType, Check, Commd, DialName
;******* ******************
;**

print,"got cmd:"+Commd

return, 1
end
;*********************
PRO dial_temp_ramp_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_furnace_ramp

    IF(D.init NE 1) THEN BEGIN
	D.current=1.4
	D.init=1
    ENDIF
    V=DialNewValue(/setvalue)
    D.current=D.current+0.3
    command='pte '+STRTRIM(STRING(D.current),2)
    C=DialControl(command)

end



;*********************
FUNCTION dial_temp_ramp
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='temp'   ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=60.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=1	 ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds
    CURRENT=2.12
    INIT=0
   ;Own Variables (optional)
   ;-------------

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,current:CURRENT,$
         init:INIT}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_furnace_ramp_macro :
;** *************
;** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ
;**                [TYPE='monitor'])           (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                           ,[PATH=path ]                dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
;    *********************************************************
;    ************************          ***********************
;    ************************  A DIAL  ***********************
;    ************************          ***********************
;    *********************************************************
;    dial TIME
;    **************

;This dial monitors instrument time 

pro  DIAL_TIME_MACRO, D
;**  ********************

DialWSet
;xyouts, 10,10, STRING(dialNewValue()), /DEVICE
V=dialnewvalue()
d.value=V.time_counts
PRINT, 'Time: ',d.Value


end





;******* ********************************
;******* ********************************
function DIAL_TIME
;******* ********************************
;******* ********************************
;**
;** Input  <none>
;** Output D is the dial structure returned for DialInit()
;********* *********************************************

;inherits="template0"                   ;May inherits tags of Dial "template0"
 inherits=""                            ;    (so, its macro is compiled).

;** Usefull tags:                       ;Only one tag is necessary to validate a Dial
;** ************                        (George creates usefull tags if they are not)
name     ="time"                   ;Consistent with "dial_template1.pro"
generic  ="mad"                    ;Reading instrument control procedure is:
                                        ;                "dial_template_read.pro"
type     ="t_status"                 ;Requested value will be the temperature
plot     = -2                          ;Mode for plotting (ex: 50 last values,
                                        ;  -2 for no plot, -1 read into workspace) 
                                        ;  for 2D dials: 1= surface, 2= levels)
value    = 0L                           ;The dial value    set to a correct type &
                                        ;                              dimension
error    = 0.                           ;Idem for error -> value +- error
onoff    = 0                            ;The dial activity set to 0 initially [0,1]
number   = 0                            ;The dial number   set by george (d1...d20)
frequency= 2                         ;The dial specific frequency (in seconds)
duration = 0.0                          ;The dial specific duration  (in seconds)
history  = 0                            ;If 1, values are saved into history file:
                                        ;                     "dial_template1.his"

                ;** Other tags used in your procedure DIAL_TEMPLATE1_MACRO:
                ;** ******************************************************
                unit      =""           ;The dial string unit
                lowerlim  =0.           ;The dial lower limit value
                upperlim  =150.         ;The dial upper limit value
                                        ;   (used also for plotting)   etc......

D={NAME:name, GENERIC:generic, VALUE:value, ONOFF:onoff, FREQUENCY:frequency,  $
              DURATION:duration,UNIT:unit , HISTORY:history, UPPERLIM:upperlim,$
              LOWERLIM:lowerlim, PLOT:plot, TYPE:type, INHERITS:inherits}

return,D
end
;*********************
PRO dial_tof_data_all_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_tof_data

	IF(D.init EQ 0) THEN BEGIN
		D.init=1
		V=DialNewValue(type='t_para')    
		D.tofch=V.TOF_CHA_RESOL
		D.newtot =0.
		D.holdtot=0.
		DialModValue,lonarr(D.tofch,64)
		DialModValue,lonarr(D.tofch,64) ,tag='NEW'
		DialModValue,lonarr(D.tofch,64) ,tag='HOLD'
		dialinit ,'showx'
		dialstart,'showx' & dialtag,'showx',tag='PATER',set=d.number
ENDIF
;	GET THE DATA
;	------------
	V=DialNewValue(type='pmc')
	e=V(0:(D.tofch*66)-1)
        i=INDGEN(32)*2+1
	e=reform(e,D.tofch,66)
        f=e(*,0:63)
;	REFRESHED?
;	---------
	tmp=total(f)
	IF(tmp lt D.newtot) THEN BEGIN	D.hold   =D.hold+D.new
					D.holdtot= total(D.hold) & ENDIF
	D.new   = f
	D.newtot= tmp
	D.value = D.hold+D.new
	f=alog10(f>0.0001)
	
	
;	UPDATE OTHER DIALS
;	------------------
	dialtag,'showx',tag='VALUE',set=total(D.value,2)
end



;*********************
FUNCTION dial_tof_data_all
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='monitor'   ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=5.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0          ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------
    HOLD   =0
    NEW    =0
    HOLDTOT=0.
    NEWTOT =0.
    TOFCH  =0L

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,holdtot:HOLDTOT,$
	 hold:HOLD,new:NEW,newtot:NEWTOT,init:0L,tofch:TOFCH,plot:PLOT}
end






;*********************
PRO dial_tof_data_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_tof_data

	IF(D.init EQ 0) THEN BEGIN
		D.init=1
		V=DialNewValue(type='t_para')    
		D.tofch=V.TOF_CHA_RESOL
		D.newtot =0.
		D.holdtot=0.
		DialModValue,lonarr(D.tofch,32)
		DialModValue,lonarr(D.tofch,32) ,tag='NEW'
		DialModValue,lonarr(D.tofch,32) ,tag='HOLD'
		dialinit ,'showx'
		dialstart,'showx' & dialtag,'showx',tag='PATER',set=d.number
ENDIF
;	GET THE DATA
;	------------
	V=DialNewValue(type='pmc')
	e=V(0:(D.tofch*66)-1)
        i=INDGEN(32)*2+1
	e=reform(e,D.tofch,66)
        f=e(*,i)
;	REFRESHED?
;	---------
	tmp=total(f)
	IF(tmp lt D.newtot) THEN BEGIN	D.hold   =D.hold+D.new
					D.holdtot= total(D.hold) & ENDIF
	D.new   = f
	D.newtot= tmp
	D.value = D.hold+D.new
	f=alog10(f>0.0001)
	
	
;	UPDATE OTHER DIALS
;	------------------
	dialtag,'showx',tag='VALUE',set=total(D.value,2)
end



;*********************
FUNCTION dial_tof_data
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='monitor'   ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=5.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=0          ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------
    HOLD   =0
    NEW    =0
    HOLDTOT=0.
    NEWTOT =0.
    TOFCH  =0L

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,holdtot:HOLDTOT,$
	 hold:HOLD,new:NEW,newtot:NEWTOT,init:0L,tofch:TOFCH,plot:PLOT}
end






pro dial_tornade_macro ,D
;** ******************
;**
common	c_torn, pix_win,pix_sav,see_win,winx,winy,$
	c_back,c_ground,c_clouds,c_torn,c_spot,$
	clouds_pts,ground_pts,tornado_pts,arc_pts,trans,ident4,$
	max_torn_pt,max_torn_pt_m1,max_torn_pt_m2,ramp,clouds_ang,ground_ang,$
	pos_clouds_x ,pos_clouds_y ,pos_clouds_z ,vel_clouds_x ,vel_clouds_y ,vel_clouds_z,$
	pos_ground_x ,pos_ground_y ,pos_ground_z ,vel_ground_x ,vel_ground_y ,vel_ground_z,$
	pos_tornado_x,pos_tornado_y,pos_tornado_z,vel_tornado_x,vel_tornado_y,vel_tornado_z,$
	twist_ang,spin_pts,plane_pts,spin_tornado,spin_change,speed_tornado,$
	time_inc,float_vel,grav_time,count

IF not D.init then begin D.init=1
	c_back   =   5
	c_ground =  60
	c_clouds = 100
	c_torn   = 190
	c_spot   = 250
	IF n_elements(pix_sav) eq 0 THEN pix_sav=0
	IF n_elements(pix_win) eq 0 THEN pix_win=0
	DialWset   &  see_win =!d.Window  &  winx=!d.x_size  &  winy=!d.y_size
	
   clouds_pts  = 200
   ground_pts  = 200
   tornado_pts = 25
   arc_pts     = 7

   clouds_center_x = 0.5
   clouds_center_y = 0.5

   trans = Fltarr(4, 4)
   ident4 = trans
   ident4([0, 5, 10, 15]) = 1.0

   max_torn_pt = tornado_pts - 1
   max_torn_pt_m1 = max_torn_pt - 1
   max_torn_pt_m2 = max_torn_pt - 2

   arc_ones = Replicate(1.0, arc_pts)
   zeroes = Fltarr(tornado_pts)
   ramp = 1.0 - (Findgen(tornado_pts) / Float(tornado_pts - 1))
   clouds_ang = Fltarr(clouds_pts)
   ground_ang = Fltarr(ground_pts)

   temp = Randomu(s, 1)

   pos_clouds_x = (Randomu(s, clouds_pts) * 2.0) - 0.5
   pos_clouds_y = (Randomu(s, clouds_pts) * 2.0) - 0.5
   pos_clouds_z = Replicate(1.0, clouds_pts)

   vel_clouds_x = Randomu(s, clouds_pts) /  100.0
   vel_clouds_y = Randomu(s, clouds_pts) /  100.0
   vel_clouds_z = Randomu(s, clouds_pts) / 1000.0

   pos_ground_x = (Randomu(s, ground_pts) * 2.0) - 0.5
   pos_ground_y = (Randomu(s, ground_pts) * 2.0) - 0.5
   pos_ground_z = Fltarr(ground_pts)

   vel_ground_x = Fltarr(ground_pts)
   vel_ground_y = Fltarr(ground_pts)
   vel_ground_z = Fltarr(ground_pts)

   pos_tornado_x = Replicate(clouds_center_x, tornado_pts)
   pos_tornado_y = Replicate(clouds_center_y, tornado_pts)
   pos_tornado_z = Replicate(1.0, tornado_pts)

   vel_tornado_x = Fltarr(tornado_pts)
   vel_tornado_y = Fltarr(tornado_pts)
   vel_tornado_z = Replicate((-0.01), tornado_pts) * ramp

   twist_ang = Randomu(s, tornado_pts) * 180.0
   ang_inc = 360.0 / Float(arc_pts)

   spin_pts = Fltarr(3, arc_pts, tornado_pts)

   plane_pts = Fltarr(3, arc_pts)
   ang = 0.0
   FOR i=0, (arc_pts - 1) DO BEGIN
      plane_pts(0, i) = Cos(ang * !DTOR)
      plane_pts(1, i) = Sin(ang * !DTOR)
      ang = ang + ang_inc
   ENDFOR

   spin_tornado = Fltarr(tornado_pts)
   spin_change = Replicate(0.1, tornado_pts)
   speed_tornado = Fltarr(tornado_pts)

   time_inc = 0.025
   float_vel = 0.1
   grav = 1.0
   grav_time = grav * time_inc
   pi2 = !PI * 2.0

   count = 0.0
ENDIF

kp_p=!P & kp_x=!X & kp_y=!Y & kp_z=!Z

IF pix_win eq 0 THEN BEGIN Window,/Free,/Pixmap,Xsize=winx,Ysize=winy,Retain=1 & pix_win=!D.Window & endif
IF pix_sav eq 0 THEN BEGIN Window,/Free,/Pixmap,Xsize=winx,Ysize=winy,Retain=1 & pix_sav=!D.Window
                           Device, Copy=[0, 0, winx, winy, 0, 0, see_win]      & endif

;THE LOOP
      Create_View, Winx=winx, Winy=winy, Az=30, Ay=0, Ax=-90, Zfac=1., Zoom=0.6, Persp=2.
      count = count + 1.0

      vel_clouds_z  = Temporary(vel_clouds_z) + (float_vel / 20.0)

      z_pos_ramp    = 1.0 - pos_tornado_z

      vel_tornado_x = Temporary(vel_tornado_x) + (ramp * z_pos_ramp^2 * (Randomu(s, tornado_pts) - 0.5) / 4.0)

      vel_tornado_y = Temporary(vel_tornado_y) + (ramp * z_pos_ramp^2 * (Randomu(s, tornado_pts) - 0.5) / 4.0)

      vel_tornado_z = Temporary(vel_tornado_z) - (ramp * float_vel * (Randomu(s, tornado_pts) - 0.5))

      IF (pos_tornado_z(0) GE 0.25) THEN vel_tornado_z(0) = vel_tornado_z(0) < vel_tornado_z(1) < (0.0)

      vel_tornado_x(max_torn_pt) = 0.0
      vel_tornado_y(max_torn_pt) = 0.0
      vel_tornado_z(max_torn_pt) = 0.0

      vel_tornado_x = Smooth(Temporary(vel_tornado_x),  3); , /Edge_Truncate)
      vel_tornado_y = Smooth(Temporary(vel_tornado_y),  3); , /Edge_Truncate)
      vel_tornado_z = Smooth(Temporary(vel_tornado_z),  3); , /Edge_Truncate)

      pos_tornado_x = Temporary(pos_tornado_x) + (vel_tornado_x * time_inc)
      pos_tornado_y = Temporary(pos_tornado_y) + (vel_tornado_y * time_inc)
      pos_tornado_z = Temporary(pos_tornado_z) + (vel_tornado_z * time_inc)

;     IF (pos_tornado_z(0) GT 0.0) THEN BEGIN
;        index      = Where((pos_tornado_z(1:*)-pos_tornado_z(0:max_torn_pt_m1)) LE 0.0)
;        IF (index(0) GT 0L) THEN pos_tornado_z(index) = pos_tornado_z(index) - (0.005)
;     ENDIF

      pos_tornado_x(0) = pos_tornado_x(1)
      pos_tornado_x(max_torn_pt) = pos_tornado_x(max_torn_pt_m1)
      pos_tornado_x    = Smooth(Temporary(pos_tornado_x),  3); , /Edge_Truncate)

      pos_tornado_y(0) = pos_tornado_y(1)
      pos_tornado_y(max_torn_pt) = pos_tornado_y(max_torn_pt_m1)
      pos_tornado_y    = Smooth(Temporary(pos_tornado_y),  3); , /Edge_Truncate)

      pos_tornado_z(0) = pos_tornado_z(0) < (pos_tornado_z(1) - 0.01)
      pos_tornado_z(max_torn_pt) = 1.0
      pos_tornado_z    = Smooth(Temporary(pos_tornado_z),  3)

      index = Where((pos_tornado_x LE 0.0) OR (pos_tornado_x GE 1.0))
      IF (index(0) GE 0L) THEN vel_tornado_x(index) = 0.0
      index = Where((pos_tornado_y LE 0.0) OR (pos_tornado_y GE 1.0))
      IF (index(0) GE 0L) THEN vel_tornado_y(index) = 0.0
      index = Where((pos_tornado_z LE 0.0) OR (pos_tornado_z GE 1.0))
      IF (index(0) GE 0L) THEN vel_tornado_z(index) = 0.0
      
      pos_tornado_x = (Temporary(pos_tornado_x) > 0.0) < 1.0
      pos_tornado_y = (Temporary(pos_tornado_y) > 0.0) < 1.0
      pos_tornado_z = (Temporary(pos_tornado_z) > 0.0) < 1.0

;     speed_tornado =  ((1.5 + ramp) * time_inc * 20.0 * (Sqrt(spin_tornado) + 0.001))
      speed_tornado =  ((0.5 + ramp) * time_inc * 50.0 * (Sqrt(spin_tornado) + 0.001))

      spin_change   = Temporary(spin_change) + $
         Smooth(((Randomu(s, tornado_pts) - 0.5) / 10.0), 3); , /Edge_Truncate)
      spin_change   = Smooth(Temporary(spin_change), 3); , /Edge_Truncate)

      spin_change   =  (Temporary(spin_change) > (-0.125)) < (0.125)
      spin_tornado  = ((Temporary(spin_tornado) + (spin_change * time_inc)) > 0.0) < 0.15
      spin_tornado(max_torn_pt) = spin_tornado(max_torn_pt_m1) + ((0.001 * count)  < 0.15)

      spin_tornado  = Smooth(Temporary(spin_tornado),  3); , /Edge_Truncate)
      spin_tornado  = Smooth(Temporary(spin_tornado), (tornado_pts/4)); , /Edge_Truncate)
      spin_tornado(0) = spin_tornado(1) * (1.0 - pos_tornado_z(0))^4

      twist_ang     = Temporary(twist_ang) + (10.0 * time_inc * speed_tornado)
      index         = Where(twist_ang GE 360.0)
      IF (index(0) GE 0L) THEN twist_ang(index) = twist_ang(index) - 360.0

      ground_dx = pos_ground_x - pos_tornado_x(0)
      ground_dy = pos_ground_y - pos_tornado_y(0)
      ground_dz = pos_ground_z - pos_tornado_z(0)
      ground_dist = Sqrt(ground_dx^2 + ground_dy^2)
      index = Where(ground_dist GT 0.0)
      ground_ang(*) = 0.0
      ground_ang(index) = Atan(ground_dy(index), ground_dx(index))

      ground_xyz_dist   = Sqrt(ground_dx^2 + ground_dy^2 + ground_dz^2)

      vect_x   = pos_tornado_x(2) - pos_tornado_x(0)
      vect_y   = pos_tornado_y(2) - pos_tornado_y(0)
      pt_dz    = Sqrt(vect_x^2 + vect_y^2)
      IF (pt_dz GT 0.0) THEN pt_ang = Atan(vect_y, vect_x) ELSE pt_ang = 0.0
      ang_diff = pt_ang - ground_ang
      tilt_fac = (pt_dz * (-Cos(ang_diff))) + (Randomu(s, ground_pts) / 2.0)

      vel_ground_z =   Temporary(vel_ground_z) - (grav_time)

      pos_ground_x = ((Temporary(pos_ground_x) + (vel_ground_x * time_inc)) > (-1.0)) < 2.0
      pos_ground_y = ((Temporary(pos_ground_y) + (vel_ground_y * time_inc)) > (-1.0)) < 2.0
      pos_ground_z =  (Temporary(pos_ground_z) + (vel_ground_z * time_inc)) > 0.0
      index = Where(pos_ground_z LE 0.0)
      IF (index(0) GE 0L) THEN BEGIN
         vel_ground_x(index) = 0.0
         vel_ground_y(index) = 0.0
         vel_ground_z(index) = time_inc * spin_tornado(1) * 10.0 * tilt_fac(index) / $
            (ground_xyz_dist(index) + 0.25)^6
      ENDIF

      index = Where(pos_ground_z GT 0.0)
      IF (index(0) GE 0L) THEN BEGIN
         vel_ground_x(index) = vel_ground_x(index) - $
            (Sin(ground_ang(index)) * 4.0 * spin_tornado(1) / (1.5*(ground_xyz_dist(index) + 0.5))^6)
         vel_ground_y(index) = vel_ground_y(index) + $
            (Cos(ground_ang(index)) * 4.0 * spin_tornado(1) / (1.5*(ground_xyz_dist(index) + 0.5))^6)
      ENDIF

      vel_ground_x = Temporary(vel_ground_x) * 0.85
      vel_ground_y = Temporary(vel_ground_y) * 0.85
      vel_ground_z = Temporary(vel_ground_z) * 0.95

      clouds_dx    = pos_clouds_x - pos_tornado_x(max_torn_pt)
      clouds_dy    = pos_clouds_y - pos_tornado_y(max_torn_pt)
      clouds_dist  = Sqrt(clouds_dx^2 + clouds_dy^2)
      index        = Where(clouds_dist GT 0.0)
      clouds_ang(*)= 0.0
      clouds_ang(index) = Atan(clouds_dy(index), clouds_dx(index))
      vel_clouds_x = Temporary(vel_clouds_x) - $
         (Sin(clouds_ang) * 2.0 * spin_tornado(max_torn_pt) / (1.5*(clouds_dist + 0.5))^4)
      vel_clouds_y = Temporary(vel_clouds_y) + $
         (Cos(clouds_ang) * 2.0 * spin_tornado(max_torn_pt) / (1.5*(clouds_dist + 0.5))^4)
      vel_clouds_x = Temporary(vel_clouds_x) + (0.075 * (Randomu(s, clouds_pts) - 0.5))
      vel_clouds_y = Temporary(vel_clouds_y) + (0.075 * (Randomu(s, clouds_pts) - 0.5))
      vel_clouds_x = Temporary(vel_clouds_x) * 0.75
      vel_clouds_y = Temporary(vel_clouds_y) * 0.75

      vel_clouds_x = Temporary(vel_clouds_x) - (0.03 * Cos(clouds_ang) / (1.0 + (10.0 * clouds_dist)))
      vel_clouds_y = Temporary(vel_clouds_y) - (0.03 * Sin(clouds_ang) / (1.0 + (10.0 * clouds_dist)))

      vect_x   = pos_tornado_x(max_torn_pt) - pos_tornado_x(max_torn_pt_m2)
      vect_y   = pos_tornado_y(max_torn_pt) - pos_tornado_y(max_torn_pt_m2)
      pt_dz    = Sqrt(vect_x^2 + vect_y^2)
      IF (pt_dz GT 0.0) THEN pt_ang = Atan(vect_y, vect_x) ELSE pt_ang = 0.0
      ang_diff = pt_ang - clouds_ang
      tilt_fac = pt_dz * (-Cos(ang_diff)) * 5.0

      clouds_dz    = pos_clouds_z - pos_tornado_z(max_torn_pt)
      clouds_dist  = (clouds_dx^2 + clouds_dy^2 + clouds_dz^2)

      vel_clouds_z = Temporary(vel_clouds_z) - (spin_tornado(max_torn_pt) * tilt_fac / (clouds_dist > 0.01))

      vel_clouds_z = Temporary(vel_clouds_z) + ((Randomu(s, clouds_pts) - 0.5) * float_vel / 40.0)

      vel_clouds_z =(Temporary(vel_clouds_z) > (-float_vel)) < float_vel

      pos_clouds_x =   Temporary(pos_clouds_x) + (vel_clouds_x * time_inc)
      pos_clouds_y =   Temporary(pos_clouds_y) + (vel_clouds_y * time_inc)
      pos_clouds_z = ((Temporary(pos_clouds_z) + (vel_clouds_z * time_inc)) > 0.0) < 1.0

      index = Where(Sqrt((pos_clouds_x - 0.5)^2 + (pos_clouds_y - 0.5)^2) GT 1.0)
      IF (index(0) GE 0L) THEN BEGIN
        vel_clouds_x(index) = 0.0
        vel_clouds_y(index) = 0.0
      ENDIF


      Wset, pix_win
      Erase, c_back

      FOR i=0, max_torn_pt DO BEGIN

         prev_pt = (i - 1) > 0
         next_pt = (i + 1) < max_torn_pt

         vect_x  =  pos_tornado_x(next_pt) - pos_tornado_x(prev_pt)
         vect_y  =  pos_tornado_y(next_pt) - pos_tornado_y(prev_pt)
         vect_z  = (pos_tornado_z(next_pt) - pos_tornado_z(prev_pt)) > 0.001 > $
                                           (0.01 * Float(i) / Float(max_torn_pt))
         xy_len  = Sqrt(vect_x^2 + vect_y^2)

         IF (xy_len GT 0.0) THEN BEGIN
            ang_z = Atan(vect_y, vect_x)
            ang_y = (!PI / 2.0) - (Atan(vect_z, xy_len))
         ENDIF ELSE BEGIN
            ang_z = 0.0
            ang_y = 0.0
         ENDELSE

         trans = ident4

         sf    = (spin_tornado(i)) * 1.25
         m4x4  = ident4
         m4x4([0, 5, 10]) = [sf, sf, 1.0]
         trans = Temporary(trans) # m4x4

         m4x4  = ident4
         s_ang = Sin(twist_ang(i)-ang_z)
         c_ang = Cos(twist_ang(i)-ang_z)
         m4x4(0,0) = c_ang
         m4x4(0,1) = s_ang
         m4x4(1,0) = (-s_ang)
         m4x4(1,1) = c_ang
         trans = Temporary(trans) # m4x4

         m4x4  = ident4
         s_ang = Sin(ang_y)
         c_ang = Cos(ang_y)
         m4x4(0,0) = c_ang
         m4x4(0,2) = (-s_ang)
         m4x4(2,0) = s_ang
         m4x4(2,2) = c_ang
         trans = Temporary(trans) # m4x4

         m4x4  = ident4
         s_ang = Sin(ang_z)
         c_ang = Cos(ang_z)
         m4x4(0,0) = c_ang
         m4x4(0,1) = s_ang
         m4x4(1,0) = (-s_ang)
         m4x4(1,1) = c_ang
         trans = Temporary(trans) # m4x4

         m4x4  = ident4
         m4x4([3,7,11]) = [pos_tornado_x(i), pos_tornado_y(i), pos_tornado_z(i)]
         trans = Temporary(trans) # m4x4

         new_pts = Vert_T3d(plane_pts, Matrix=trans)
         new_pts(2, *) = (new_pts(2, *) > 0.0) < 1.0
         spin_pts(0, 0, i) = new_pts

      ENDFOR

      Plots, pos_ground_x, pos_ground_y, pos_ground_z, Psym=4, Symsize=1.5, $
         /Normal, /T3d, Color=c_ground

      Plots, pos_clouds_x, pos_clouds_y, pos_clouds_z, Psym=1, Symsize=1.0, $
         /Normal, /T3d, Color=c_clouds

      Plots, Reform(spin_pts, 3, arc_pts*tornado_pts), $
         Psym=4, Symsize=0.5, /Normal, /T3d, Color=c_torn

;     Plots, pos_tornado_x, pos_tornado_y, pos_tornado_z, $
;       /Normal, /T3d, Color=c_spot

      Wset, see_win
      Device, Copy=[0, 0, winx, winy, 0, 0, pix_win]
;     Empty

      !P=kp_p & !X=kp_x & !Y=kp_y & !Z=kp_z

      R=DialOn()
      ;evv=WIDGET_EVENT(/nowait) ; if evv.id gt 0 
      IF  R eq 0 THEN BEGIN
	DialStop
	Device, Copy=[0, 0, winx, winy, 0, 0, pix_sav]
	Wdelete,pix_win & pix_win=0
	Wdelete,pix_sav & pix_sav=0
      ENDIF
END

function dial_tornade
;******* ************
;**
return, {INIT:0,DURATION:900,FREQUENCY:.06,PLOT:-2,WUPDATE:-1}
end
;*********************
PRO dial_t_res_macro, D
;*********************
;**
;** The Dial macro
;** Input D is the dial structure as defined below by the function dial_t_res

    V=DialNewValue()
    DialModValue, V     ;(D.value=V)
    help,v
end



;*********************
FUNCTION dial_t_res
;*********************
;**
;** The dial initialisation

   ;Dial Variables (optional)
   ;--------------
    GENERIC='mad'    ;connect to the mad-idl interface
    TYPE='t_res'    ;when DialNewValue() is used, get the monitor
    ONOFF=0          ;state of the Dial 1=running
    FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used
    VALUE=fltarr(64) ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var.
    PLOT=0           ;-2=no plot 1=surface 2=contour n>2 means show vector of last n values of the scalar
    UPPERLIM=100.    ;upper limit of the plot (LOWERLIM for lower limit)
    HISTORY=0        ;=1 to record values in file .his
    DURATION=0       ;if >0 then Dial is stopped after running duration seconds

   ;Own Variables (optional)
   ;-------------

return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY}
end






;***************************************************************************************

;** Usefull calls to be used in procedure dial_t_res_macro :
;** *************
;** V=DialNewValue([/SETVALUE, COMMENT=txt])   ;Get a new value from DIAL_'generic'_READ
;**                                            (a request is made to the instrument)
;**                                            (/SETVALUE means D.value is set to V)
;** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control
;**                                            (CHECK means check every .5 sec till the
;**                                             command  is complete)
;** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'
;**                                                                of  the dial 'temp2'
;** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'
;** DialStart ,    'temp3'                     ;A short  for previous call
;** DialStop  ,    'temp3'                     ;A short  too
;**
;** DialModValue,   V                          ;Set the new value for current dial or
;** D.value   =     V                          ;modify yourself the tag Value if type &
;**                                            ;dimensions don't change.(same for Error)
;** D.upperlim=   150.                         ;Set upper limit for plotting.
;**
;** R=DialOn ()                                ;Return 0 if Dial has been interrupted
;**                                            (To use inside loops)
;** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:
;**                                                               dial_template4.pro
;**                                            (You may change its name to 'tmp4' and
;**                                            (use DialStart,'tmp4' to activate it)
;** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO
;**                                            ('template4'  is keept inactive, ONOFF=0)
;** DialClear,     'template4'                 ;Suppress dial  'template4' from memory
;** DialWSet                                   ;Reserve central draw window for next plot
;**
;** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value
;**                [DURATION=90.] ,   [/START] ;              (time is in seconds)
;**                                            ;Stop or Start the general process
;**                                            ;Set  Time  limit for the active process
pro dial_webon_macro,D
;** ****************
;**
bid=FINDFILE(D.webpth,count=nn)
IF  nn gt 0 then begin wline=[''] & value=['']
    on_ioerror,misopn
    OPENR,u,D.webpth,/GET_LUN,/DELETE
	on_ioerror,misread
	line=''
	WHILE (not EOF(u)) do begin READF,u,line & wline=[wline,line] & ENDWHILE
	misread:  on_ioerror,misopn
	FREE_LUN ,u
	IF n_elements(wline) gt 2 then if wline(1) eq D.pwd then begin
		wline=wline(2:*)
		XICUTER,' ;--->WebOn '+!stime+' {'+wline(0)+'...}'
		CATCH,stat & if stat ne 0 then begin print,!err_string & return & endif
		FOR i=0,n_elements(wline)-1 do $
			IF wline(i) ne D.pwd then begin line=strtrim(wline(i),2)
			
			   if strpos(line,'ii=barns_i') ge 0 then jj=EXECUTE(line) $
			   else if line gt ' ' then begin XICUTER,(line+'') & value=[value,line]
			        endif
			ENDIF
		XICUTER,' ;---> '
		if n_elements(value) gt 1 then value=value(1:n_elements(value)-1)
		WebDo,'log',value,12
	ENDIF
	DialModValue,value, TAG='VALUE'
    misopn:
endif else if D.value(0) ne '' then DialModValue,[''], TAG='VALUE'
end

function dial_webon
;******* **********
;**
return,{NAME:"webon",PLOT:0,HISTORY:0,VALUE:[''],FREQUENCY:2,WEBPTH:'',PWD:'',WUPDATE:-1}
end
pro xbu
;** ***
FORWARD_FUNCTION DialControl, DialNewValue, DialOn

if strpos(!path,'/home/cs/lambda/macros') lt 0 then $
    !path=!path+':'+expand_path('+/home/cs/lambda/macros')

;bygeorge,'xbu' ;UN-COMMENT when standalone use.
END

pro dial_xbu_macro, DD
;** **************
;**
common for_users, a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

widget_control, DD.wbase,bad_id=ii,get_uvalue=basl				;**Get BASL
IF n_elements(basl) le 1 then begin
   IF xregistered('Dial_'+DD.name) eq 0 then xbu_window,DD $			;**Make GUI
   ELSE begin xbu_help,DD.number,ret  & DD.wbase=ret & ENDELSE & RETURN & ENDIF
   
cur=basl(0,1)									;**Cur line#
IF  basl(0,0) eq -1 then begin	basl(0,0)=-2					;**Canceled ???
		widget_control,DD.wbase,set_uvalue=basl
		IF cur gt 0 then begin
		  xbuline, line, cur, basl, casof
		  IF (casof eq 'CTRL') and (DD.generic ne 'lamp') then begin
				rr=DialControl('stop') & WAIT,1 & ENDIF		;**STOP !!!
		ENDIF
ENDIF
		
act=basl(0,0) & nxt=basl(0,2)
            
VV=DialNewValue(TYPE='status') & DialModValue,VV				;**Get  status

IF (act ne 0) and (cur gt 0) then begin IF VV ne 'Idle'  then begin
		txt='   '+VV+'{'+strtrim(string(cur),2)+'} '+DD.cmd
		widget_control,basl( 1 ,2),set_value=txt			;**Show status
		widget_control,basl(cur,1),set_value='   '+VV & endif else $	;**Show status
		widget_control,basl(cur,1),set_value='...done...'		;**Cmd  done
endif else begin
   if nxt gt 0 then begin txt='   Stopped{'+strtrim(string(nxt),2)+'} '		;**Tell stopped
		commd='' & xbuline, commd, nxt, basl
                widget_control,basl( 1 ,2),set_value=txt+commd
   endif  else  widget_control,basl( 1 ,2),set_value='   '+VV & endelse		;**Inactive

LL=DialNewValue(TYPE='log')							;**Get  Logs

IF LL(0) le ' ' then DialModValue,DD.cmd+'['+VV+']' $				;**Show logs
ELSE begin DialModValue,LL  & LL=[DD.log,LL]  & nl=n_elements(LL)
	   if cur eq 1 then mx=15 else mx=100
           if nl gt mx then LL=LL(nl-mx-1:nl-1)   & DialModValue,LL,TAG='log'
           widget_control,basl(9,2),set_value=LL & nl=n_elements(LL)
           widget_control,basl(9,2),set_text_top_line=nl-16 & ENDELSE

IF  DD.lines ne (size(basl))(1)-1 then XBU_MORE, DD.lines ,basl			;**More lines

IF  VV ne 'Idle' then RETURN							;**Running

IF  act eq -2   then begin basl(0,0)=0 & act=0 & xbu_sensitive,basl,1		;**Just stopped
                           basl(0,1)=nxt
                           widget_control,DD.wbase,set_uvalue=basl  & ENDIF

IF  act eq 0    then IF DD.generic eq 'lamp' then DD.onoff=0			;**Stopped
IF  act eq 0    then begin DD.frequency=3 &  RETURN				;**Stopped
		ENDIF ELSE DD.frequency=DD.Xfreq

IF  nxt gt 0    then begin cur=nxt-1 & basl(0,2)=0                  & ENDIF	;**Resume

command=''
WHILE (cur le DD.lines) and (command eq '') do begin  cur=cur+1			;**Next Cmd
    if cur le DD.lines then xbuline, command, cur, basl, casof
ENDWHILE

IF (cur gt 0) and (cur le DD.lines) then begin Lo=cur

  CATCH,stat & IF stat ne 0 then begin xbuErrors, basl,cur,DD      & RETURN  & ENDIF

  !Error=0
  DD.cmd=command
  widget_control,basl( 1 ,2),set_value='   Active{'+strtrim(string(cur),2)+'} '+DD.cmd
  widget_control,basl(cur,1),set_value= '<'  & txt=' '
  CASE casof of
  'IF':      begin coco='o='+strmid(command,2,100)
  		idx=strpos(strlowcase(coco),' then')
		IF idx gt 0 then coco=strmid(coco,0,idx)
  		ii=EXECUTE(coco)
		IF !Error ne 0 then begin xbuErrors, basl,cur,DD   & RETURN  & ENDIF
		ok=0
		IF not o then widget_control,basl(cur,1),set_value= 'No'
		IF not o then $
		   WHILE (Lo le DD.lines) and (casof ne 'ENDIF') do begin
		    Lo=Lo+1
		    if Lo le DD.lines then xbuline,command,Lo,basl,casof
		    IF casof eq 'IF' then ok=ok+1
		    IF casof eq 'ENDIF' then IF ok gt 0 then begin casof='' & ok=ok-1 & ENDIF
		   ENDWHILE
		IF Lo gt DD.lines then begin xbuErrors, basl,cur,DD,'No ENDIF!'
		                             RETURN  & ENDIF
		cur=Lo & END

  'IDL':     begin idx=1
  		WHILE idx gt 0 do   begin idx=strpos(command,'$')
  		   IF idx gt 0 then begin var=''
  		    ii=execute('var=strtrim(string( '+strmid(command,idx+1,1)+'),2)')
  		    command=strmid(command,0,idx)+var+strmid(command,idx+2,100)
  		   ENDIF
		ENDWHILE
		widget_control,basl(cur,1),set_value= 'Executing'			;**Execute Idl
  		IF DD.lampok then XICUTE,command else ii=EXECUTE(command)		;*************
		IF !Error ne 0 then begin xbuErrors, basl,cur,DD   & RETURN  & ENDIF
		txt='Executed' & END

  'CTRL':      if strpos(command,'! ') ne 0 then begin
  		idx=1
  		WHILE idx ge 0 do   begin idx=strpos(command,'$')
  		   IF idx ge 0 then begin var=''
  		    ii=execute('var=strtrim(string( '+strmid(command,idx+1,1)+'),2)')
  		    command=strmid(command,0,idx)+var+strmid(command,idx+2,100)
  		   ENDIF
		ENDWHILE
  		rr= DialControl(command)						;**Execute Mad
		if DD.generic eq 'lamp' then txt='Executed'  else txt='Sent' & ENDIF	;*************

  'ENDFOR':  begin ok=0
		WHILE (Lo gt 0) and (casof ne 'FOR') do begin
		   Lo=Lo-1 & if Lo ge 1 then xbuline,command,Lo,basl,casof
		   IF casof eq 'ENDFOR' then ok=ok+1
		   IF casof eq 'FOR' then IF ok gt 0 then begin casof=''    & ok=ok-1 & ENDIF
		ENDWHILE
		IF Lo lt 1 then begin xbuErrors, basl,cur,DD,'No FOR!'      & RETURN  & ENDIF
		END

  'ENDWHILE':begin ok=0
		WHILE (Lo gt 0) and (casof ne 'WHILE') do begin
		   Lo=Lo-1 & if Lo ge 1 then xbuline,command,Lo,basl,casof
		   IF casof eq 'ENDWHILE' then ok=ok+1
		   IF casof eq 'WHILE' then IF ok gt 0 then begin casof=''  & ok=ok-1 & ENDIF
		ENDWHILE
		IF Lo lt 1 then begin xbuErrors, basl,cur,DD,'No WHILE!'    & RETURN  & ENDIF
		END

  'STOP':    begin widget_control,basl(cur,3),set_value='<<-'
		   basl(0,0)=-2 & basl(0  ,2)=cur & END
   ELSE:
  ENDCASE
  
  CASE casof of
  'FOR':begin good=0									;**For loop
	bid=strmid(command,3,100)
	je =strpos(bid,'=')
	IF je gt 0 then begin a1=0. & a2=-1. & a3=1.
	 ;**GET LOOP VARIABLES IN A1 A2 A3**
	  jd =strpos (strlowcase(bid),' do') & if jd lt je then jd=100
	  var=strupcase(strtrim(strmid(bid,0,je),2))
	  bid=strmid (bid,je+1,jd-je-1)
	  tab=str_sep(bid+',1',',')
	  ii=Execute ('a1='+tab(0)+' & a2='+tab(1)+' & a3='+tab(2))
	  on_ioerror,misloop   & a1=float(a1) & a2=float(a2)  & a3=float(a3)
	  if long(a1) eq a1 then a1=long (a1) & if long (a3) eq a3 then  a3=long(a3)
	 ;**GET NOW STEP IN A5**
	  jn =strpos (command,';NOW=') & txt=' '
	  IF  jn  lt 0  then jn = strlen (command)
	  IF  cur ne Lo then ii = Execute(var+'=a3+'+var) $
	  		else ii = Execute(var+'=a1')
	  ii =Execute('a5='+var)
	  IF long(a5) eq a5 then a5=long(a5)
	 ;**TEST END OF LOOP**
	  IF a3 gt 0  then if a5 gt a2 then txt='Loop complete'
	  IF a3 lt 0  then if a5 lt a2 then txt='Loop complete'
	 ;**LOOP IS OK?
	  cur=Lo  & ok=0
	  IF txt ne ' ' then begin now=''
	    WHILE (cur le DD.lines) and (casof ne 'ENDFOR') do begin
		cur=cur+1 & if cur le DD.lines then xbuline,command,cur,basl,casof
		IF casof eq 'FOR' then ok=ok+1
		IF casof eq 'ENDFOR' then IF ok gt 0 then begin casof='' & ok=ok-1 & ENDIF
	    ENDWHILE
	  ENDIF else now=';NOW='+strtrim(string(a5),2)
	  newcmd='FOR ' +var+'='+strmid(bid,0,jn)+' do begin '+now
	  widget_control,basl(Lo,0),set_value=newcmd
	  good=1
	  misloop:IF not good then begin xbuErrors, basl,cur,DD,' '  & RETURN &  ENDIF
	ENDIF & END

  'WHILE':begin	txt=' ' & coco='o='+strmid(command,5,100)				;**While loop
  	  idx=strpos(strlowcase(coco),' do') & IF idx gt 0 then coco=strmid(coco,0,idx)
	  ii=EXECUTE(coco)
	  IF !Error ne 0 then begin xbuErrors, basl,cur,DD & RETURN &  ENDIF
	  cur=Lo & ok=0
	  IF not o then begin txt='Loop complete'
	    WHILE (cur le DD.lines) and (casof ne 'ENDWHILE') do begin
		cur=cur+1 & if cur le DD.lines then xbuline,command,cur,basl,casof
		IF casof eq 'WHILE' then ok=ok+1
		IF casof eq 'ENDWHILE' then IF ok gt 0 then begin casof='' & ok=ok-1 & ENDIF
	    ENDWHILE
  	  ENDIF & END
   ELSE:
  ENDCASE
  widget_control,basl(cur,1),set_value= txt
ENDIF

IF cur gt DD.lines then begin xbu_sensitive, basl,1 & basl(0,*)=0 & cur=0		;**All done
	command='done'
	widget_control,basl(1,1),set_value='...All is done...'
ENDIF

DD.cmd=command
basl(0,1)=cur & widget_control,DD.wbase,set_uvalue=basl
end

pro xbuComp, new_macro, bat
;** *******
;**
	resol =0
	if float(!version.release) ge 4.0 then resol=2 else resol=1
	poc='lamp_tmp.pro'
	pac='lamp_tmp'
	if resol gt 0 then begin out1=-1
	   ON_IOERROR,mis_cmp
	   OPENW ,out1,poc,/get_lun
	   if bat ne '.pro' then PRINTF,out1,'pro '+pac
	   for i=0,n_elements(new_macro)-1 do PRINTF,out1,new_macro(i)
	   PRINTF,out1,''
	   if bat ne '.pro' then PRINTF,out1,'end' $
	   else begin	PRINTF,out1,'pro '+pac & PRINTF,out1,'end'
			endelse
	   PRINTF  ,out1,''
 	   FREE_LUN,out1 & out1=-1

	  if resol eq 1 then iii=EXECUTE   ( pac )
	  if resol eq 2 then RESOLVE_ROUTINE,pac

	  mis_cmp:if out1 gt 0 then free_lun,out2
	 ;OPENR ,out1,poc,/get_lun,/DELETE & FREE_LUN,out1 & out1=-1
	endif
end


pro xbuErrors, basl,cur,DD, error
;** *********
;**
basl(0,0)=0  & DD.onoff=0
basl(0,1)=cur
basl(0,2)=cur
IF n_elements(error) eq 0 then error=strmid(!err_string,0,52)
widget_control,DD.wbase   ,set_uvalue=basl
widget_control,basl(cur,1),set_value ='<-Error!'
widget_control,basl(1,2)  ,set_value =   error
widget_control,basl(cur,3),set_value ='<<-'
xbu_sensitive,basl,1
end

pro xbuline, line, cur, basl, casof
;** *******
;**
  widget_control,basl(cur,0),get_value =comd
  ctrl=basl(cur,5)
  line=strtrim  (comd(0),2)
  COMD=strupcase(line)
  IF ctrl   then casof='CTRL'  else casof='IDL'
  if strpos(COMD,'! ')    eq 0 then casof='CTRL'
  IF strpos(COMD,'CTRL:') eq 0 then begin casof='CTRL'
  	line=strmid (line,5,100)
  	line=strtrim(line,2) & COMD=strupcase(line) & endif else $
  	
  IF strpos(COMD,'IDL:')  eq 0 then begin casof='IDL'
  	line=strmid (line,4,100)
  	line=strtrim(line,2) & COMD=strupcase(line) & ENDIF
  
  IF casof eq 'IDL' then begin
	if (strpos(COMD,'IF(') eq 0) or (strpos(COMD,'IF ') eq 0) then casof='IF' else $
	if (strpos(COMD,'ENDIF')    eq 0) then casof='ENDIF'    else $
	if (strpos(COMD,'FOR ')     eq 0) then casof='FOR'      else $
	if (strpos(COMD,'ENDFOR')   eq 0) then casof='ENDFOR'   else $
	if (strpos(COMD,'WHILE')    eq 0) then casof='WHILE'    else $
	if (strpos(COMD,'ENDWHILE') eq 0) then casof='ENDWHILE' else $
	if (strpos(COMD,'STOP')     eq 0) then casof='STOP'
  ENDIF
end

pro xbucontrol  ,flag ,LINES=L ,COMMAND=command ,FILE=fifi ,NAME=xbu ,ctrl=ctrl
;** **********
;**

IF n_elements(xbu) ne 1 then xbu='XBU'
dialTag,xbu ,tag='WBASE',get=top

CASE strlowcase(flag) of

'read':		if (n_elements(fifi) eq 1) then $
		xbu_event, {TOP:top,ID:0,UV:[2 ,0]} ,FILE=fifi
		
'write':	if (n_elements(fifi) eq 1) then $
		xbu_event, {TOP:top,ID:0,UV:[3 ,0]} ,FILE=fifi
		
'start':	xbu_event, {TOP:top,ID:0,UV:[4 ,0]}
'break':	xbu_event, {TOP:top,ID:0,UV:[5 ,0]}
'resume':	xbu_event, {TOP:top,ID:0,UV:[6 ,0]}
'stop':		xbu_event, {TOP:top,ID:0,UV:[7 ,0]}
'back':		xbu_event, {TOP:top,ID:0,UV:[8 ,0]}
'next':		xbu_event, {TOP:top,ID:0,UV:[9 ,0]}
'erase':	xbu_event, {TOP:top,ID:0,UV:[10,0]}

'put':		if (n_elements(L) eq 1) and (n_elements(command) eq 1) then begin
		if n_elements(ctrl) ne 1 then ctrl=0
		xbu_event, {TOP:top,ID:0,UV:[11,0,L,ctrl]} ,COMMAND=command & endif
		
'show':		xbu_event, {TOP:top,ID:0,UV:[12,0]}

'more':		begin if (n_elements(L) ne 1) then L=1
		xbu_event, {TOP:top,ID:0,UV:[14,0,L]} & end

'map':		widget_control,top, bad_id=ii,map=1
'nomap':	widget_control,top, bad_id=ii,map=0

ELSE:
ENDCASE
end

pro xbu_DYING, id
;** *********
;**
widget_control, id, get_uvalue=basl
DialStop ,D=basl(13,2)
DialClear,D=basl(13,2)
end

pro xbu_event, ev, command=command ,file=fifi
;** *********
;**
widget_control, ev.top, get_uvalue=basl & sz=(size(basl))(1)
IF ev.id gt 0 then widget_control, ev.id, get_uvalue=uv ELSE uv=ev.uv
IF n_elements(uv) lt 2 then RETURN
uv(1)=basl(1,2) & widget_control, uv(1) , set_value =string(replicate(byte(32),52))

dnum=basl(13,2)

CASE uv(0) of
0:begin										;**toggle Log/Xbu
	if uv(4) eq 0 then begin widget_control, uv(2),map=0
	                         widget_control, uv(3),map=1
	endif else         begin widget_control, uv(3),map=0
	                         widget_control, uv(2),map=1 & endelse
	uv(4)=abs(uv(4)-1)   &   widget_control, ev.id,set_uvalue=uv
	end
1:	basl(uv(2),5)=ev.select							;**toggle Ctrl/Idl

2:begin	if n_elements(fifi) ne 1 then widget_control, uv(2), get_value=fifi	;**read XBU file
	fifi=strtrim(fifi(0),2) & on_ioerror,misread & u=-1 & tline=''
	if fifi ne '' then begin
	 openr,u,fifi,/get_lun  & line=''
	 while (not EOF(u)) do begin readf,u,line & tline=[tline,line] & endwhile
	 free_lun,u
	endif
	nel=n_elements(tline)
	XBU_MORE, nel ,basl  &   sz=(size(basl))(1)
	if strpos(fifi,'.cmd') gt 0  then bstat=1 else bstat=0
	for i=1,sz-1 do begin  basl(i,5)= bstat
		if basl(i,4) gt 0 then widget_control, basl(i,4), set_button=bstat
	  if i ge nel then widget_control , basl(i,0), set_value=' ' $
	  else begin  line=tline(i)
		widget_control,  basl(i,0), set_value=line
		xbuline,  linc, (i), basl, casof
		if casof eq 'CTRL' then begin
		  widget_control,basl(i,0), set_value=strmid (line,5,100) & basl(i,5)=1
		  if basl(i,4) gt 0 then widget_control,basl(i,4),set_button=1
		endif
	  endelse
	  widget_control, basl(i,1), set_value=string(replicate(byte(32),15))
	  widget_control, basl(i,3), set_value=string(replicate(byte(32),3 ))
	endfor
	widget_control, uv(1),  set_value =fifi+' is loaded'
	xbu_sensitive, basl,1 & basl(0,*)=0
	misread:
	if u lt 0 then widget_control,uv(1),set_value ='!!! un-readable '+fifi
	end
3:begin	if n_elements(fifi) ne 1 then widget_control, uv(2), get_value=fifi	;**write XBU file
	fifi=fifi(0) & on_ioerror,miswrite & tline='' & u=-1 & ttick=0
	for i=1,sz-1 do begin
	    widget_control, basl(i,0), get_value =line & line=line(0) & linv=strtrim(line,2)
	    bid =  basl(i,5)
	    if linv ne '' then if bid then line='CTRL:'+line
	    if linv ne '' then tline=[tline,line]
	endfor
	if  n_elements(tline) gt 1 then begin
	    openw,u,fifi,/get_lun
	    for i=1,n_elements(tline)-1 do printf,u,tline(i)
	    free_lun,u
	    widget_control, uv(1), set_value =fifi+' is saved'
	endif
	miswrite:
	if u lt 0 then widget_control,uv(1),set_value ='!!! un-writeable '+fifi
	end
4:if basl(0,0) eq 0 then begin							;**Start
	xbu_sensitive,basl,0 & basl(0,*)=0 & basl(0,0)=1
	for i=1,sz-1  do begin widget_control,basl(i,1),set_value=' '
	              widget_control,basl(i,3),set_value=' ' & endfor & endif

5:if basl(0,0) eq 1 then begin
	basl(0,0)=-2 & nxt=basl(0,2) & basl(0,2)=(basl(0,1)+1)<(sz-1)		;**Stop next
	if nxt gt 0 then widget_control,basl(nxt,3),set_value=' '
	widget_control,basl(basl(0,2),3),set_value='<<-'              & endif

6:if basl(0,0) eq 0 then begin nxt=basl(0,2)					;**Resume
	if nxt gt 0 then begin xbu_sensitive,basl,0 & basl(0,0)=1     & endif
	if nxt gt 0 then widget_control,basl(nxt,3),set_value=' '     & endif

7:if basl(0,0) eq 1 then begin							;**Cancel
	basl(0,0)=-1 & nxt=basl(0,2) & basl(0,2)=basl(0,1)>1
	if nxt gt 0 then widget_control,basl(nxt,3),set_value=' '
	widget_control,basl(basl(0,2),3),set_value='<<-'              & endif

8:begin if basl(0,2) eq 0 then basl(0,2)=basl(0,1)				;**Previous
	widget_control,basl(basl(0,2)>1,3),set_value=' '
	basl(0,2)=(basl(0,2)-1)>1
	if basl(0,0) eq 0 then txt='<<-' else txt='Brk'
	widget_control,basl(basl(0,2),3),set_value= txt               & end

9:begin if basl(0,2) eq 0 then basl(0,2)=basl(0,1) & if basl(0,2) gt 0 then $	;**Next
	widget_control,basl(basl(0,2)>1,3),set_value=' '
	basl(0,2)=(basl(0,2)+1)<(sz-1)
	if basl(0,0) eq 0 then txt='<<-' else txt='Brk'
	widget_control,basl(basl(0,2),3),set_value= txt               & end

10:for i=1,sz-1 do begin widget_control, basl(i,0), set_value=' ' & basl(0,*)=0	;**Erase
			 widget_control, basl(i,1), set_value=' '
			 widget_control, basl(i,3), set_value=' '     & endfor

11:begin i=uv(2)>1<(sz-1)
	 widget_control, basl(i,0),set_value=command & basl(i,5)=uv(3)		;**Put
	 if basl(i,4) gt 0 then widget_control,basl(i,4),set_button=uv(3)
   end
12:										;**Show !!!!!

13:begin tline=[''] & line=''							;**Check
	for i=1,sz-1 do begin
	    widget_control, basl(i,0), get_value =line & line=line(0)
	    bid =  basl(i,5)
	    if bid then    line=';;;'+line
	    if line gt ' ' then tline=[tline,line]
	endfor
	!Error=0 & xbuComp, tline ,'.xbu'
	IF !Error ne 0 then  widget_control,uv(1),set_value =!err_string
	IF !Error ne 0 then  txt='Found error !!!' else txt='Seems ok !!!'
	widget_control,basl(1,1),set_value =txt
	END

14:	XBU_MORE, sz-1+uv(2) ,basl						;**More

15:	IF uv(2) eq 1 then DialTag,D=dnum,tag='XFREQ',set=.1 else $		;**Speed
	IF uv(2) eq 2 then DialTag,D=dnum,tag='XFREQ',set=.8 else $
	IF uv(2) eq 3 then DialTag,D=dnum,tag='XFREQ',set=1.5

16:	XBU_SHIFT ,basl, ev.value						;**Slider

17:     XBU_INSERT,basl, uv(2)							;**Inset new line
else:
ENDCASE
widget_control, ev.top, set_uvalue=basl
IF basl(0,0) eq 1 then begin DialTag,D=dnum,tag='ONOFF',get=onoff
                             if onoff eq 0 then DialStart,D=dnum & ENDIF
end

pro xbu_sensitive, basl,a
;** *************
;**
b=abs(a-1)
	widget_control, basl(2,2), sensitive=a ;start
	widget_control, basl(3,2), sensitive=a ;read
	widget_control, basl(4,2), sensitive=b ;stop nx
	widget_control, basl(5,2), sensitive=a ;resume
	widget_control, basl(6,2), sensitive=b ;cancel
	widget_control, basl(7,2), sensitive=a ;prev
	widget_control, basl(8,2), sensitive=a ;next
end

pro xbu_help, dnum,ret
;** ********
;**
common xbu_kp,basec0
ret=basec0(dnum)
end

pro xbu_window,DD
;** **********
;**
@lamp.cbk
common xbu_kp,basec0

if xregistered('Dial_'+DD.name) eq 0 then begin DD.lines=DD.lines>14
   lampok=n_elements(lamp_b1)
   DialModValue,lampok,tag='LAMPOK'
   if n_elements(basec0)  eq 0 then basec0=lonarr(21)
   basl=lonarr(DD.lines+1,6)
   basec0_0=widget_base  (title='Dial_'+DD.name,/column ,resource_name='lamp',kill_notify='xbu_DYING')
   basec0(DD.number)=basec0_0
   basecf1 =widget_base  (basec0_0 ,/row,/frame,resource_name='don')
   basecmap=widget_base  (basec0_0 ,/frame,resource_name='did')
   basec2  =widget_base  (basecmap ,map=1,/row)
   basecf2g=widget_base  (basecmap ,map=0)
   basecf2s=widget_slider(basec2   ,xsize=15,ysize=350,max=1,min=DD.lines,/vertical,/drag,value=1,/suppress_value,title='')
   basecf2 =widget_base  (basec2   ,/column)
   baselog =widget_text  (basecf2g ,xsize=60,ysize=18 ,font=ft_b_normal,/scroll)
   basecf3 =widget_base  (basec0_0 ,/frame,resource_name='don')
   
   if DD.lampok then put_logo,basecf1
   bid     =widget_label (basecf1  ,value='  ')
   baselogx=widget_button(basecf1  ,value='Log/'+DD.name  ,font=ft_b_normal)
   bid     =widget_label (basecf1  ,value='  ')
   bid     =widget_label (basecf1  ,value=DD.name+' file:',font=ft_b_normal)
   basefil =widget_text  (basecf1  ,xsize=15,ysize=1,/editable, font=ft_propor)
   baseread=widget_button(basecf1  ,value='Read'     ,font=ft_b_normal)
   basewrit=widget_button(basecf1  ,value='Write'    ,font=ft_b_normal)
   bid     =widget_button(basecf1  ,value='Help'     ,font=ft_b_normal,menu=2)
     bid1 =widget_button(bid       ,value='Use only variables A->Z and Workspaces'             ,font=ft_b_normal)
     bid1 =widget_button(bid       ,value='Prefix A->Z with "$" for substitutions'      ,font=ft_b_normal)
     bid1 =widget_button(bid       ,value='Tick left for Instrument control lines'      ,font=ft_b_normal)
     bid1 =widget_button(bid       ,value='WHILE  command'				,font=ft_b_normal,menu=2)
      bid2=widget_button(bid1      ,value='- 1  K=55. & T=800 & N=10'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='* 2  Set temperature $K'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 3  R=my_temp_macro()'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 4  WHILE (T eq R) and (N gt 0) do begin'	, font=ft_propor)
      bid2=widget_button(bid1      ,value='* 5      Count $T seconds'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 6      R=my_temp_macro()'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 7      N=N-1'				, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 8  ENDWHILE'				, font=ft_propor)
     bid1 =widget_button(bid       ,value='FOR  command'				,font=ft_b_normal,menu=2)
      bid2=widget_button(bid1      ,value='- 1  N=10'					, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 2  FOR J=N,0,-2 do begin'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='* 3      Set position $J'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='* 4      Count 800 seconds'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 5  ENDFOR'					, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 6  print,"End"'                             , font=ft_propor)
     bid1 =widget_button(bid       ,value='IF  command'					,font=ft_b_normal,menu=2)
      bid2=widget_button(bid1      ,value='- 1  IF (K ne 55.) then begin'		, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 2      print,"on pompe!"'			, font=ft_propor)
      bid2=widget_button(bid1      ,value='* 3      Set temperature 55.0'		, font=ft_propor)
      bid2=widget_button(bid1      ,value='- 4  ENDIF'					, font=ft_propor)
     bid1 =widget_button(bid       ,value='STOP command does a break'                   ,font=ft_b_normal)
     bid1 =widget_button(bid       ,value='------'					, font=ft_propor)
     check=widget_button(bid       ,value='Check for syntax now!'			, font=ft_propor)
     bid1 =widget_button(bid       ,value='------'					, font=ft_propor)
     bid1 =widget_button(bid       ,value='To insert an empty line, type <Enter>'       ,font=ft_b_normal)
     bid1 =widget_button(bid       ,value='To delete a line, erase and type <Enter>'    ,font=ft_b_normal)
     bid1 =widget_button(bid       ,value='------'					, font=ft_propor)
      run1=widget_button(bid       ,value='Run fast'					, font=ft_propor)
      run2=widget_button(bid       ,value='Run medium'					, font=ft_propor)
      run3=widget_button(bid       ,value='Run slow'					, font=ft_propor)
   
   basec2_0=widget_base  (basecf2  ,/row)
   basestar=widget_button(basec2_0 ,value='Start',font=ft_b_normal)
   basemess=widget_label (basec2_0 ,font=ft_propor,$
   	                  value=string(replicate(byte(45),52)))
   
   basec3_0=widget_base  (basecf3  ,/row)
   basestop=widget_button(basec3_0 ,value='Break'    ,font=ft_b_normal)
   bid     =widget_label (basecf1  ,value=' '        ,font=ft_propor)
   baseresu=widget_button(basec3_0 ,value='Resume'   ,font=ft_b_normal)
   bid     =widget_label (basecf1  ,value=' '        ,font=ft_propor)
   b1      =widget_button(basec3_0 ,value='<-'       ,font=ft_b_normal)
   b2      =widget_button(basec3_0 ,value='->'       ,font=ft_b_normal)
   bid     =widget_label (basec3_0 ,value='         ',font=ft_propor)
   basecanc=widget_button(basec3_0 ,value='!Stop-Instrument'    ,font=ft_b_normal)
   
   more=-basecf3
   basl(1:14,2)=[basemess,basestar,baseread,basestop,baseresu,basecanc,b1,b2, $
                 baselog ,basecf2 ,more    ,basec0_0,DD.number,basecf2s]
   XBU_MORE, DD.lines ,basl

   widget_control, basec0_0, set_uvalue=basl
   widget_control, baselogx, set_uvalue=[0 ,basemess,basec2,basecf2g,0]
   widget_control, basefil , set_uvalue=[2 ,basemess,basefil]
   widget_control, baseread, set_uvalue=[2 ,basemess,basefil]
   widget_control, basewrit, set_uvalue=[3 ,basemess,basefil]
   widget_control, basestar, set_uvalue=[4 ,basemess]
   widget_control, basestop, set_uvalue=[5 ,basemess]
   widget_control, baseresu, set_uvalue=[6 ,basemess]
   widget_control, basecanc, set_uvalue=[7 ,basemess]
   widget_control, b1      , set_uvalue=[8 ,basemess]
   widget_control, b2      , set_uvalue=[9 ,basemess]
   widget_control, check   , set_uvalue=[13,basemess]
   widget_control, run1    , set_uvalue=[15,basemess,1]
   widget_control, run2    , set_uvalue=[15,basemess,2]
   widget_control, run3    , set_uvalue=[15,basemess,3]
   widget_control, basecf2s, set_uvalue=[16,basemess,1]
   widget_control, basestop, sensitive = 0
   widget_control, baseresu, sensitive = 0
   widget_control, basecanc, sensitive = 0
   widget_control, b1      , sensitive = 0
   widget_control, b2      , sensitive = 0
   
   res=0 & ii=execute('res=LMGR(/EMBEDDED)<1 + LMGR(/RUNTIME)<1 ')
   if res ne 0 then widget_control,check,sensitive=0
   
   DialModValue,basec0_0,tag='WBASE'

   if DD.nowin eq 1 then widget_control, basec0_0, map=0
   widget_control, basec0_0, group_leader=lamp_b1, /realize  & if DD.lampok then put_logo
   widget_control, basemess, set_value= DD.value
   XMANAGER,'Dial_'+DD.name , basec0_0, event_handler='xbu_event',/just_reg

endif
end

pro xbu_more, nb2 ,basl
;** ********
;**
@lamp.cbk

   basemess= basl(1 ,2) & basecf2= basl(10,2) & more= basl(11,2) & basec0_0=basl(12,2)
   nb=(size(basl))(1)-1
   DialTag,D=basl(13,2),tag='LINES',set=nb2>nb
   if(nb ge  nb2) and (more gt 0) then RETURN
   if nb lt  nb2 then begin mo=nb2-nb & basl=[[basl],lonarr(mo,6)]
   			    widget_control,basl(14,2),set_slider_max=1,set_slider_min=nb2
   endif
   visible=8
   nb1= nb+1
   if more lt 0 then begin nb1=1 & more=abs(more) & basl(11,2)=more & endif
   if nb1  gt 1 then begin widget_control,/hourglass
                     IF !version.release gt '4.0' THEN widget_control, basec0_0, update=0
   endif
   rep15=string(replicate(byte(45),15))
   rep3 =string(replicate(byte(45),3 ))
   for i=nb1,nb2  do  begin
	if i le visible then begin
   	   si=strtrim(string(i),2) & if i le 9 then si='0'+si & if i le 99 then si='0'+si
	   bid      =widget_base  (basecf2,/row)
	   bod      =widget_base  (bid,/nonexclusive)
	   basl(i,4)=widget_button(bod,value=si,font=ft_propor          ,uvalue=[1 ,basemess,i])
	   basl(i,0)=widget_text  (bid,xsize=31,/editable,font=ft_propor,uvalue=[17,basemess,i])
	   basl(i,1)=widget_label (bid,value=rep15,font=ft_propor,uvalue=bid)
	   basl(i,3)=widget_label (bid,value=rep3 ,font=ft_propor)
	endif else begin
	   bid      =widget_base(more,/row,map=0)
	   basl(i,0)=widget_text  (bid,xsize=31,/editable,font=ft_propor)
	   basl(i,1)=widget_label (bid,value=rep15,font=ft_propor,uvalue=bid)
	   basl(i,3)=widget_label (bid,value=rep3 ,font=ft_propor) & endelse
   endfor
   if nb1 eq 1 then begin bosl=lonarr(visible,4) ;Extras for keeping
      for i=0,visible-1 do begin
           bid      =widget_base(more,/row,map=0)
	   bod      =widget_base  (bid,/nonexclusive)
	   bosl(i,3)=widget_button(bod,value='000',font=ft_propor,uvalue=[1,basemess,i+1])
	   bosl(i,0)=widget_text  (bid,xsize=31,/editable,font=ft_propor)
	   bosl(i,1)=widget_label (bid,value=rep15,font=ft_propor,uvalue=bid)
	   bosl(i,2)=widget_label (bid,value=rep3 ,font=ft_propor)
      endfor
      widget_control,more,set_uvalue={id:bosl,vis:visible}
   endif else IF !version.release gt '4.0' THEN widget_control, basec0_0, update=1
   widget_control, basec0_0, set_uvalue=basl
end

pro xbu_insert,basl, cur
;** **********
;**

nb=(size(basl))(1)-1
widget_control,basl(cur,0),get_value=txt  & txt=strtrim(txt(0),2)
widget_control,basl(11,2) ,get_uvalue=kp  & vis=kp.vis & go=nb-vis+1

if txt gt ' ' then begin          ;Insert a new line
	widget_control,/hourglass
	widget_control,basl(nb  ,0),get_value=t1
	widget_control,basl(nb-1,0),get_value=t2
	widget_control,/hourglass
	if cur gt go then XBU_SHIFT,basl,go
	if strcompress(t1(0)+t2(0)) gt ' ' then XBU_MORE ,nb+1,basl
	XBU_SHIFT,basl,cur, decal= 1
	if cur ge nb-1 then begin
	   widget_control,basl(14,2),get_uvalue=sluv
	   XBU_SHIFT,basl,sluv(2)+1 & endif

endif else if nb gt 20 then begin ;Suppress an empty line
	XBU_SHIFT,basl,cur, decal=-1
endif
end

pro xbu_shift, basl,to, decal=decal
;** *********
;**
nb =(size(basl))(1)-1
 widget_control,basl(11,2),get_uvalue=kp   & visible=kp.vis

;DECAL AFTER LINE INSERT
;***********************
if n_elements(decal) eq 1 then begin cur=to
 if decal gt 0 then begin
 	for i=nb,cur+2,-1 do begin
 	  widget_control,basl(i-1  ,0), get_value=tmp
 	  widget_control,basl(i    ,0), set_value=tmp(0)
 	  basl(i,5)=basl(i-1,5)
	  if basl(i,4) gt 0 then widget_control,basl(i,4),set_button=basl(i,5)
 	endfor
 	  widget_control,basl(cur+1,0), set_value=''  &  basl(cur+1,5)=0
	  if basl(cur+1,4) gt 0 then widget_control,basl(cur+1,4),set_button=0
 endif else begin
 	for i=cur,nb-1    do begin
 	  widget_control,basl(i+1  ,0), get_value=tmp
 	  widget_control,basl(i    ,0), set_value=tmp(0)
 	  basl(i,5)=basl(i+1,5)
	  if basl(i,4) gt 0 then widget_control,basl(i,4),set_button=basl(i,5)
 	endfor
 	  widget_control,basl(nb   ,0), set_value=''  &  basl(nb,5)=0
 	  if (nb gt 20) and (cur lt nb-visible) then begin
 	  	widget_control,basl(nb,1),get_uvalue=bid
 	  	widget_control,bid,/destroy
 	  	basl=basl(0:nb-1,*)
 	  	DialTag,D=basl(13,2),tag='LINES',set=nb-1 & endif
 endelse

endif else begin
;SLIDER HAS MOVED
;****************
 widget_control,basl(14,2),get_uvalue=sluv & from=sluv(2) & sluv(2)=to
 widget_control,basl(14,2),set_uvalue=sluv,set_value=to
 onu=from<(nb-visible+1)  &  num=to<(nb-visible+1)

 IF onu ne num then begin

 v=visible-1
 
;GET TEXT VALUES
;***************
 txt=strarr(visible) & oxt=txt & lb1=txt & lb2=txt & ob1=txt & ob2=txt
 for i=0,visible-1 do begin
 	widget_control,basl(num+i,0), get_value=tmp  & txt(i)=tmp(0)
	widget_control,basl(num+i,1), get_value=tmp  & lb1(i)=tmp(0)
	widget_control,basl(num+i,3), get_value=tmp  & lb2(i)=tmp(0)
	widget_control,basl(onu+i,0), get_value=tmp  & oxt(i)=tmp(0)
	widget_control,basl(onu+i,1), get_value=tmp  & ob1(i)=tmp(0)
	widget_control,basl(onu+i,3), get_value=tmp  & ob2(i)=tmp(0)
 endfor
;EXCHANGE WIDGET ID's
;********************
 tmp=basl(onu:onu+v,[0,1,3,4])  & basl(onu:onu+v,[0,1,3,4])=kp.id & kp.id=basl(num:num+v,[0,1,3,4])
 basl(num:num+v,[0,1,3,4])=tmp  & widget_control,basl(11,2),set_uvalue=kp

;SET TEXT VALUES
;***************
 for i=0,visible-1 do begin
	widget_control,basl(onu,0), set_value=oxt(i)
	widget_control,basl(onu,1), set_value=ob1(i)
	widget_control,basl(onu,3), set_value=ob2(i) & onu=onu+1
 endfor
 for i=0,visible-1 do begin
   	si=strtrim(string(num),2) & if num le 9 then si='0'+si & if num le 99 then si='0'+si
	widget_control,basl(num,4), set_value=si,set_button=basl(num,5),set_uvalue=[1 ,0,num]
	widget_control,basl(num,0), set_value=txt(i)                   ,set_uvalue=[17,0,num]
	widget_control,basl(num,1), set_value=lb1(i)
	widget_control,basl(num,3), set_value=lb2(i) & num=num+1
 endfor
 ENDIF
endelse
end

function dial_xbu
;******* ********

;**
return,{value:'Idle',wbase:0L,cmd:'',log:[''],wupdate:-1, nowin:0, lines:45, onoff:1, frequency:1., Xfreq:.8}
end
;******* ******   *
function di_rev , c
;******* ******   *
;******* ******   *
if (size(c))(0) eq 2 then return, REVERSE(REVERSE(c,1),2) $
		     else return, REVERSE(c)
end

;** ******   ************** Return s1,s4 margin & s2,s3 vector index range
pro di_mka , c ,s1,s2,s3,s4
;** ******   ************** **********************************************
;** ******   ************** **********************************************


    tm= findgen(n_elements(c))
    i = round  (total(tm*c)/total(c))
    id= where  (c gt 0)   & nc= n_elements(id)
    i = i-id(0)
    s = i-(nc-i-1)
    s1=((-s)>0)+1  & s4=((+s)>0)+1
    s2= id(0)	   & s3=id(nc-1)
end

;******* ******   *****  ** Construcs the vector in all directions of the plane
function di_two , v1,v2 ,fl
;******* ******   *****  ** ***************************************************
;******* ******   *****  ** ***************************************************
common di_com, di_siz,di_sin,di_cos,di_t1,di_t2,di_r1,di_r2,di_th1,di_th2,di_bo

if not fl then return,v1#v2

n1=n_elements(v1) & n2=n_elements(v2)

if n_elements(di_siz) ne 2 then di_siz=[0,0]
if (di_siz(0) ne n1)  or (di_siz(1) ne n2) then begin
    di_siz= [n1,n2]
    di_t1 = fltarr(n1)+1.     & di_t2 =fltarr(n2)+1.
    di_th1= fltarr(n1,n2)     & di_th2=fltarr(n1,n2)

    a	  = !pi/n2 & b=!pi/n1 & m1=(n1-1)/2 & m2=(n2-1)/2 &  di_bo=[-m1,-m2,m1,m2]
    for j = 0,n2-1  do begin di_th1(0:m1-1,j)=!pi  +a*j & di_th1(m1:*,j)=a*j	     & endfor
    for i = 0,n1-1  do begin di_th2(i,0:m2-1)=!pi/2+b*i & di_th2(i,m2:*)=-!pi/2+b*i  & endfor

    di_sin= abs(findgen(n1)-m1) # di_t2	    & di_r1 =di_sin
    di_cos= di_t1 # abs(findgen(n2)-m2)	    & di_r2 =di_cos
    di_sin(m1,*)=1.
    di_cos= ATAN(di_cos/di_sin)		    & di_cos(m1,*)=!pi/2.
    di_sin= SIN (di_cos)^2		    & di_cos=COS(di_cos)^2
    di_sin(m1,m2)=.5			    & di_cos(m1,m2) =.5
endif
r1=v1#di_t2				    & r2=di_t1#v2
r1=POLAR_SURFACE(r1,di_r1,di_th1,sp=[1,1],bo=di_bo)
r2=POLAR_SURFACE(r2,di_r2,di_th2,sp=[1,1],bo=di_bo)

return,r1*di_cos + r2*di_sin
end

;******* *******  *********** Solve linear or bilinear function (coef. of convolution steps)
function di_solv, R,bi,R2,bi2,METHOD=met,GUESS=guess
;******* *******  *********** **************************************************************
;******* *******  *********** **************************************************************
s =size (R)
tb=total(bi) & t1=tb/total(R)
nc=s(1) & mi=(nc-1)/2

   A = dblarr(nc,nc) & B=dblarr(nc)
   if  n_elements(bi) eq 1 then  B (mi)=bi else B=bi
   for i = 0  ,mi   do A(0,i)   =R (mi-i:nc-1)         ;fill each coefficient
   for i =mi+1,nc-1 do A(i-mi,i)=R (0   :nc-1-(i-mi))  ;fill each coefficient

if n_elements(met) ne 1 then met=1

if met eq 1 then begin
	SVDC,A,w,u,v
	CZ = SVSOL(u,w,v,B)
   
endif else if met eq 2 then begin ; un-used methode
	CZ = CRAMER(A,B)

endif else if met eq 3 then begin
	if n_elements(guess) gt 1 then X = guess else  $
	X  = -R & X(mi)=X(mi)+total(R)+total(bi)/total(R)
	CZ = LINBCG(sprsin(A),B,X)

endif else if met eq 4 then begin
	LUDC,A,Index
	CZ = LUSOL(A,Index,B)
   
endif else if met eq 5 then begin AA=A
	if n_elements(guess) gt 1 then X = guess else  $
	X  = -R & X(mi)=X(mi)+total(R)+total(bi)/total(R)
	LUDC,AA,Index
	CZ = LUMPROVE(A,AA,Index,B,X)
endif

if n_elements(R2) gt 1 then begin
   s = size (R2)
   tb=total(bi2) & t2=tb/total(R2)
   n2= s(1) & m2=(n2-1)/2
   A = dblarr(n2,n2) & B=dblarr(n2)
   if  n_elements(bi2) eq 1 then B (m2)=bi2 else B=bi2
   for i = 0  ,m2   do A(0,i)   =R2(m2-i:n2-1)
   for i =m2+1,n2-1 do A(i-m2,i)=R2(0   :n2-1-(i-m2))
   SVDC,A,w,u,v
   CZ2= SVSOL(u,w,v,B)
  ;CZ2= CZ2 + (t2-total(CZ2))/n2

   CZ = DI_TWO(CZ,CZ2,1)                               ;make 2D function
endif
return,CZ
end

;******* *******  *** Just do a convolution
function di_conv, F,C
;******* *******  *** *********************
;******* *******  *** *********************
sf =size(F) & sc =size(C)
nf1=sf(1)   & nc1=sc(1) & mi=(nc1-1)/2

if sf(0) eq 1 then begin
   if  nf1 gt nc1  then return,  CONVOL(	    F	         ,C) $
		   else begin  t=CONVOL([fltarr(mi),F,fltarr(mi)],C)
			return,t(mi:nf1-1+mi) & endelse
endif else begin
   nf2=sf(2) & nc2=sc(2) & ni=(nc2-1)/2
   if (nf1 gt nc1) and (nf2 gt nc2) then return,CONVOL(F   ,C) $
   else begin
	if nf1 le nc1 then nf1=nf1+2*mi else mi=0
	if nf2 le nc2 then nf2=nf2+2*ni else ni=0
	tmp=fltarr(nf1,nf2) & tmp(mi,ni)=F & t =CONVOL(tmp ,C)
	return,t(mi:nf1-1-mi,ni:nf2-1-ni)
   endelse
endelse
end

;******* *******  ************* Derivatives: return all max values
function di_keeb, V ,mi, D ,idx ,shf
;******* *******  ************* **********************************
;******* *******  ************* **********************************
gi =mi/4
s  =size (V)
if s(0) eq 1 then begin
   v1 =shift(V, 1)     & res=    ((V-v1)>0) & res(0)       =0
   v1 =shift(V,-1)     & res=res*((V-v1)>0) & res(s(1)-1)  =0
endif else begin
   v1 =shift(V, 1, 0)  & res=    ((V-v1)>0) & res(0,*)     =0
   v1 =shift(V,-1, 0)  & res=res*((V-v1)>0) & res(s(1)-1,*)=0
   v1 =shift(V, 0,-1)  & res=res*((V-v1)>0) & res(*,0)     =0
   v1 =shift(V, 0, 1)  & res=res*((V-v1)>0) & res(*,s(2)-1)=0
endelse

idx=where(res gt 0)
if  idx(0) eq -1 then bid=max(V,idx)
shf=idx*0

;Gravity center for better peak positions.
;******* ****** *** ****** **** *********
if gi gt 1 then begin ni=n_elements(idx) & l1=s(1)-1 & l2=s(2)-1
	for i=0,ni-1 do begin
	    if s(0) eq 1 then begin
		hf=(idx(i)-gi)>0 & hl=(idx(i)+gi)<l1
		gd=(D(hf:hl))
		gd=(gd-min(gd))
		gx=findgen(hl-hf+1)+hf
;		shf(i)=idx(i)-ROUND((total(gd*gx)/total(gd)+idx(i))/2.)
		shf(i)=idx(i)-ROUND((total(gd*gx)/total(gd)))
		;print,idx(i),total(gd*gx)/total(gd)
	    endif else begin
	        iy= idx(i)/s(2)  & ix=idx(i)-iy*s(2)
		hf=(ix-gi)>0     & hl=(ix+gi) <l1
		vf=(iy-gi)>0     & vl=(iy+gi) <l2
		gd=(D(hf:hl,vf:vl))
		gd=(gd-min(gd))
		gh=total(gd,2)   & gv=total(gd,1)
		gx=findgen(hl-hf+1)+hf & gy=findgen(vl-vf+1)+vf
		tx=ROUND((total(gh*gx)/total(gh)))
		ty=ROUND((total(gv*gy)/total(gv)))
		shf(i)=idx(i)-(tx+ty*s(2))
	    endelse
	endfor
	res(*)=0
endif

res(idx+shf)=V(idx)
idx=idx+shf
return,res
end

;******* ********  *********  ***** Make a 1 or 2 dimensional Gaussian
function di_gauss, h,hw1,hw2 ,y1,y2
;******* ********  *********  ***** **********************************
;******* ********  *********  ***** **********************************
if hw1 gt 0 then begin
   n1= round(hw1*10)+1
   y1= h*exp(-(((findgen(n1)-n1/2)/hw1)^2)/2)
   y1= y1/total(y1) & y1=y1>2e-5 & y1=y1-2e-5 & y1=y1/total(y1)
   y1= y1(where(y1 gt 0))
   y2= 0
endif
if hw2 gt 0 then begin
   n2= round(hw2*10)+1
   y2= h*exp(-(((findgen(n2)-n2/2)/hw2)^2)/2)
   y2= y2/total(y2) & y2=y2>2e-5 & y2=y2-2e-5 & y2=y2/total(y2)
   y2= y2(where(y2 gt 0))
   y3= DI_TWO  (y1,y2,0)
   return,y3/total(y3)
endif
   return,y1
end

;************************************************
function diconv , d ,cv ,pos=idx ,filt=filt ,Xdata=xx ,Xprofil=xcv, stat=stat, get_profil=prof $
		, h_hw=h_hw,v_hw=v_hw,orient=a_deg ,sym=sym, unit=unit, bg=bg, res=cd, cutoff=cut
;******* ******					*
;						*
;** d    = input data				*
;** cv   = optionnal observed resolution profil	*
;** h_hw = optionnal horiz half_width profil	*
;** v_hw = optionnal verti half_width profil	*
;** a_deg= degrees of profil:clockwise rotation *
;** xx   = abcissa of input if not regular      *
;** xcv  = abcissa of input profil if unregular *
;** unit = regular unit cell                    *
;** /sym   make cv symetrical                   *
;** /filt  use FOU function to remove stat.     *
;** /stat  use FOU function  & return.          *
;** /prof  return normalized profil only        *
;** /cut   low cutoff limit (max value factor   *
;                                               *
;** return F(d)					*
;** return idx the positions of bands           *
;** return bg  the calculated background        *
;**                                             *
;** 		D.Richard Apr 1996 (ILL)	*
;************************************************
;** 2D gaussian with a_deg not implemented !!
;** gravity in keeb for 2D data to check !!
;** Errors for d 
;** cv & d same unit !!

common c_conv, cz, fou ,c, kcv, kh_hw, kv_hw, ku, kdeg

;** Adjustment variables:
    LC=2e-4      ;**Minimum value set to 0 in normalised CV (use cut if defined)
    F =1./1000.  ;**Delta for CZ calculation (c+|eps)~CZ=|1 (self adjust)
    LS=5.        ;**Lowest limit factor for second maximum in CZ

sd = size(d)  & xn=sd(1) & if sd(0) eq 2 then yn=sd(2) else yn=1
ncv= n_elements(cv)
w  = 0

;CHECK PARAMETERS resol:-1=bad, 0=given, 1=1Dgauss, 2=2Dgauss
;***** **********
resol=-1
use  = 1

if (n_elements(unit) ne 1)  then if (n_elements(xcv) eq ncv)   then unit=min(abs(shift(xcv,-1)-xcv)) else $
				 if (n_elements(xx)  eq xn )   then unit=min(abs(shift(xx ,-1)-xx) ) else unit=1
if (n_elements(ku)   eq 0)  then ku  =0  &  if (unit ne ku )   then use =0 & ku=unit

if (n_elements(a_deg) ne 1) or (yn eq 1)  then o_deg=0 else o_deg=a_deg
if (n_elements(kdeg)  eq 0) then kdeg=0  &  if o_deg ne kdeg then use =0 & kdeg=o_deg

if keyword_set(h_hw) then    begin
   if h_hw  gt 0 then begin  resol=1 & if n_elements(kh_hw) ne 1 then use=0 else if kh_hw ne h_hw then use=0
      if yn gt 1 then begin  resol=2
	 if not  keyword_set(v_hw) then v_hw=h_hw else $
	 if v_hw le 0 then   v_hw =h_hw
	 if n_elements(kv_hw) ne 1 then use=0 else if kv_hw ne v_hw then use=0
      endif
     ;MAKE PROFIL IF NOT GIVEN.
     ;*********** ** *** ***** 
      if not use then begin
	 if  resol eq 1 then c=DI_GAUSS(1.,h_hw/unit,0        ,y1,0 ) & kh_hw=h_hw	;1D gaussian
	 if  resol eq 2 then c=DI_GAUSS(1.,h_hw/unit,v_hw/unit,y1,y2) & kv_hw=v_hw	;2D gaussian
      endif
      kcv=0 & sym=1
   endif

endif else if ncv ge 3  then  if (size(cv))(0) eq sd(0)  then begin
      resol=0 & kh_hw=0 & kv_hw=0
      sym=keyword_set(sym)
      if ncv ne n_elements(kcv) then use=0 else if total(cv-kcv) ne 0 then use=0
      if not use then begin
     ;CENTER GIVEN RESOLUTION PROFIL.
     ;****** ***** ********** ******
	c = cv>0  & c=c-min(c) & c = c/total(c)
	if n_elements(cut) eq 1 then lc=max(c)*cut
	c=c>lc & c=c-lc & c=c/total(c)
	
	if (size(cv))(0) eq 1 then begin
		if n_elements(xcv) le 1 then if n_elements(xx) gt 1 then xcv=xx
		if n_elements(xcv) eq ncv then begin
			n =(xcv(ncv-1)-xcv(0))/unit +1
			co=INTERPOL(c,xcv,findgen(n)*unit + xcv(0))
			c =co/total(co)
		endif
		DI_MKA,c, s1,s2,s3,s4
		c =[fltarr(s1) , c(s2:s3) , fltarr(s4)]

	endif else begin
		if o_deg ne 0 then begin ct=ROT(c,-o_deg,/interp)
		                 ca=total(ct,2)  & cb=total(ct,1)
		endif else begin ca=total(c ,2)  & cb=total(c ,1) & endelse
		DI_MKA,ca, s1,s2,s3,s4 & sa=s1+s3-s2+s4+1
		DI_MKA,cb, s5,s6,s7,s8 & sb=s5+s7-s6+s8+1
    
		if o_deg ne 0 then begin sm=max([sa,sb])  & s1=s1+(sm-sa)/2 & sa=sm
					 s5=s5+(sm-sb)/2  & sb=sm & endif
		cc=fltarr( sa , sb)
		cc(s1,s5)=c(s2:s3,s6:s7) & c=cc
	endelse
	if sym then c=(DI_REV(c)+c)/2.
	kcv=cv
      endif
endif

nc= n_elements(c) & mi=(nc-1)/2 & xi=mi
if  yn gt 1 then xi=(((size(c))(1))-1)/2
                 yi=(((size(c))(2))-1)/2
                 
IF  resol lt 0        THEN RETURN,w
IF  keyword_set(prof) THEN RETURN,c
IF  nc gt xn*yn/2     THEN RETURN,w

;CZ IS A DECONVOLUTION FUNCTION OF PROFILE+DELTA (R+|f)
;** ** * ************* ******** ** ********************
;(R+|f)~CZ= |1
;*************
    if not use then begin ok=0
    	WHILE not ok do begin
	if yn eq 1 then begin R =c  & R (mi)=R (mi)+f  & CZ=di_solv(R ,1.)
	endif	   else begin R1=y1 & R1(xi)=R1(xi)+f
			      R2=y2 & R2(yi)=R2(yi)+f  & CZ=di_solv(R1,1.,R2,1.)  & endelse
	rcz=CZ & rcz(mi)=0
	if (CZ(mi)/max(rcz))  lt LS then f=f*2. else ok=1
	ENDWHILE
	if o_deg  ne 0  then  CZ=ROT(CZ,o_deg,/interp)
	if o_deg  ne 0  then  C =ROT(C ,o_deg,/interp)

	;FOU IS A FUNCTION USED TO REMOVE STATISTICS
	;*** ** * ******** **** ** ****** **********
   	FOU=-CZ*f
   	FOU(mi)=fou(mi)+1.
   	FOU=FOU/total(FOU)
			;OLD METHODE c~CM=c WHERE CM=c2~CX2 (aproximatively)
			;*** ******* ****** ***** *********  **************
			;	c2= double(c)^2.5 & c2=float(c2/total(c2))
			;	CX2=-c2
			;	CX2(mi)=CX2(mi)+1.
			;    ***C~c2
			;	IF sym then res=di_conv(c  ,c2 ) else res=di_conv(c ,DI_REV(c2) ) ;???
			;	res=res / total(res)
			;    ***Adjust maximum
			;	e  =(c(mi)-res(mi))/total(res*CX2)
			;	CX2=CX2*e & CX2(mi)=CX2(mi)+1.
			;    ***CM =c2~cx2
			;	IF sym then CM =di_conv(c2 ,CX2) else CM=di_conv(c2,DI_REV(CX2))  ;???
			;	CM(mi)=CM(mi)-(total(CM)-1.)
			;    ***Adjuste CM
    endif

;MAKE DATA REGULAR IF NECESSARY (vector only)
;**** **** ******* ** *********
	wok=0
	IF n_elements(xx) eq xn then begin wok=1
		   n=(xx(xn-1)-xx(0))/unit +1  &  xreg=findgen(n)*unit + xx(0)
		   W=INTERPOL(d,xx,xreg)
	ENDIF else W=d

;REMOVE STATISTIC.
;****** *********

	if keyword_set(filt) or keyword_set(stat) then begin
	   W =DI_CONV(W,FOU)
	   Wt=DI_CONV(W,FOU)
	  ;W =W+(W-Wt)
	   if keyword_set(stat) then begin
	   	if wok then RETURN,INTERPOL(W,xreg,xx) else RETURN,W
	   endif
	endif


;!!!!!!!!!!!Test junk for overlaped signals

; w=w+shift(w,10)+shift(w,20)/4+shift(w,-14)/6;+findgen(n_elements(w))/n_elements(w);+shift(w,-15)/2.
;w=[fltarr(24),c,c/2,c*1.5,fltarr(24)] & w=w+findgen(n_elements(w))/n_elements(w)
;if yn eq 1 then begin cp =[fltarr(mi),c,fltarr(mi)]	         & ch =shift(cp,6) & endif
;if yn gt 1 then begin cp = fltarr (4*xi+1,4*yi+1) & cp(xi,yi)=c & ch =shift(cp,7,7) & endif
;if yn eq 1 then w  =cp+ch+(findgen(4*xi+1))/(100.*xi)
;if yn gt 1 then w  =cp+ch+(findgen(4*xi+1,4*yi+1))/(100.*xi*yi)
;!!!!!!!!!!!
;****************************************************************
; (c+|f)~CZ= |1
;  T         =total(CZ)
;  B~c       = D -bg   } sum --> B~c + (D+fB)~CZ/T  = D+B/T
; (D+fB)~CZ/T= B/T +bg }     --> B~(|1/T -fCZ/T-c)  = D~(CZ/T -|1)
;                                B~ a1              = D~ a2
;****************************************************************
; a1 = c~a2
; *********
; a1+c = (CZ/T)~c		EN COURS:ca=di_solv(a1+un,un) , w~cz/t~ca  .......!!!!!
; ***************
; D~(CZ/T) - (D2) =D
; ******************
;(a1+a2)~solv(c+|f) = a2
;
;(B~a1 + B~abs(a1))*F1 = B~(a1>0)*2*F1
;(D~a2 +   XXX    )*F1 = ------------- --> have to find XXX=D~a22 !!!
;
; a22=di_solv(c+un/90,|.25|.5|.25)!
;             c          gunn
; gunn is F(di_solv(c,a11)!


;POSITION OF THE BANDS
;******** ** *** *****
	T  =  abs(total(CZ))
	a2 =  CZ/T      & a2(mi) =a2(mi)-total(a2)
	a1 =-(CZ/T*f+c) & a1(mi) =a1(mi)+1./T
	
	Ro=abs(a1(mi)/total(a2*c)) ;**Error factor
	F1=1./a1(mi) * Ro          ;**Adjustment factor
	Re=abs(1.-Ro)* F1          ;**Lower limit ---------> find better
	D2=di_conv(W ,a2)
	
		bid=60
		solv=w*0.  & solv(bid)=1. & solv(bid+10)=1. & solv(bid+20)=.25 & solv(bid-14)=1./6
		un =c*0.   & un(mi)=1     & D11=di_conv(solv,a1)

	B  = (di_keeb(D2>0,mi*3/2,D2 ,id1,shf)) *F1
	
	D1 =di_conv(solv,a1)
	
stop
	
;ADJUST HIGHT OF THE BANDS
;****** ***** ** *** *****
	for j=1,3 do begin
	  B1=B & print,B(id1)
	  for i=1,5 do begin
		D1 =  di_conv(B1,a1)
	  	df1=B1*0   & df1(id1)=(D2(id1-shf)*Ro - D1 (id1))
	            B1 (id1)= B1(id1)+df1(id1)*F1 & print,B1(id1)
	  endfor

	  ;MISSING BANDS
	  ;******* *****
	  D3=(D2*2-D1)
	  B  = (di_keeb(D3>0,mi,D3 ,id1,shf)) *F1
	  stop
	endfor
		;les bon pics !!! tres mauvais !!
		cc=-c & cc(mi)=cc(mi)+1
		;DC=di_conv(D3,cc)
		;B1(where(DC gt D3))=0
		;B1=B1>0
		;D1=di_conv(B1,a1)

;RST IS BG , CALCULATED BANDS
;*** ** *********************
	rst=di_conv(W+B1*f,cz)+(D1-D2)*t
	rst(0:mi)=W(0:mi)
	rst(xn-mi-1:xn-1)=W(xn-mi-1:xn-1) ; Care bi_dim !!!!!!!!!!!!
	wb =rst-B1
stop
return,rst
end
pro phowind, ytp,rawe,vidp,pry,corre, xout,yin,win, yraw,exclu ,elas,ott,wavel ,ERRdat
;** *******
;**
;** TOF SHOW . (D. Richard).

@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common pho_cu,  pho_grp, pho_rax, pho_fct ,pho_rep, pho_oiw, pho_e,pho_w,pho_x,pho_y,$
		pho_t  , pho_mx , pho_psf

sw   = size(win )
maxw = max(win,min=minw) & maxw=[minw,maxw]
rtp  =[wavel(5:*)]
if n_elements(pho_fct) eq 0 then pho_fct=1
if n_elements(pho_rep) eq 0 then pho_rep=6
if n_elements(pho_grp) eq 0 then pho_grp=sw(2)   $
			    else pho_grp=min([pho_grp,sw(2)])
if n_elements(pho_rax) eq 0 then pho_rax=[0,0]
if n_elements(pho_mx)  eq 0 then pho_mx =maxw(1) $
			    else pho_mx =maxw(1)

if lamp_siz lt 800 then yys=15 else yys=0

wko=ott(0) & wkos=strtrim(string(wko),2) & pho_out=wkos & if wko le 9 then wkos=wkos+' '
wkn=ott(1) & wkns=strtrim(string(wkn),2) & pho_in =wkns
pho_oiw=[pho_out,pho_in]
uv =[-88,340]
psf=pho_rep+pho_fct+(pho_grp+pho_rax(0)+pho_rax(1))/10+wkn
psf='DL'+strtrim(string(psf),2)

bshow =	widget_base  (title='didline '+strtrim(his(wkn),2),group_leader=lamp_b1,$
				   /column,resource_name='lamptouch')
bplt1 = widget_base  (bshow,/row)
bdra1 = widget_draw  (bplt1,xsize=512,ysize=60-yys)
bget1 = widget_base  (bplt1,/column)
blabel= widget_label (bget1,value='RAW SAMPLE PEAKS'      ,font=ft_b_normal)
bggg1 = widget_base  (bget1,/row)
bread = widget_button(bggg1,font=ft_b_normal ,value='re_Treat W'+wkns)
brev  = widget_button(bggg1,font=ft_smallest ,value='<',uvalue=[-88,310,bread,4])
bnex  = widget_button(bggg1,font=ft_smallest ,value='>',uvalue=[-88,311,bread,4])

bplt4 = widget_base  (bshow,/row)
bdra4 = widget_draw  (bplt4,xsize=512,ysize=60-yys)
bcorr = widget_label (bplt4,value='SAMPLE P corrected'    ,font=ft_b_normal)

bplt3 = widget_base  (bshow,/row)
bdra3 = widget_draw  (bplt3,xsize=512,ysize=85-yys)
blabel= widget_label (bplt3,value='EFFICIENCIES'                 ,font=ft_b_normal)
valf  =strtrim(string(wavel),2)
val   =strtrim(string(rtp)  ,2)
betis = widget_button(bplt3,value='?',menu=2,uvalue=rtp          ,font=ft_biggest)
binfo = widget_button(betis,value='Wavelenght   (Angs)= '+valf(0),font=ft_propor)
binfo = widget_button(betis,value='Channel width(msec)= '+valf(1),font=ft_propor)
binfo = widget_button(betis,value='Sample->Det (meter)= '+valf(2),font=ft_propor)
binfo = widget_button(betis,value='Vanadium Temp.  (K)= '+valf(3),font=ft_propor)
binfo = widget_button(betis,value='Sample   Temp.  (K)= '+valf(4),font=ft_propor)
binf2 = widget_button(betis,value='F(E) efficiencies  =IN4,5,6 type',font=ft_propor)

binf2 = widget_button(betis,value='Sample transmission= '+val(0) ,menu=2,font=ft_propor)
 seq  =['.10','.15','.20','.25','.30','.35','.40','.45','.50','.55',$
        '.60','.65','.70','.75','.80','.82','.84','.86','.88','.90',$
        '.91','.92','.93','.94','.95','.96','.97','.98','.99','1.0']
 seq  = reverse    (seq)
 for i=0,n_elements(seq)-1 do $
 btrs = widget_button(binf2,value=seq(i),uvalue=[uv,3,0,binf2,betis]	,font=ft_smallest)
binf2 = widget_button(betis,value='Vana   transmission= '+val(1) ,menu=2,font=ft_propor)
 for i=0,n_elements(seq)-1 do $
 btrv = widget_button(binf2,value=seq(i),uvalue=[uv,3,1,binf2,betis]	,font=ft_smallest)

vabs  = strtrim(string(fix(val(2))),2)
binf2 = widget_button(betis,value='Self-absorption    = '+vabs ,menu=2  ,font=ft_propor)
 bsa1 = widget_button(binf2,value='0=None',uvalue=[uv,3,2,binf2,betis,0]	   ,font=ft_propor)
 case vabs of
 '1':bsa2 = widget_button(binf2,value='1=Single slab',uvalue=[uv,3,2,binf2,betis,1]  ,font=ft_propor)
 '2':bsa2 = widget_button(binf2,value='2=Full cylinder',uvalue=[uv,3,2,binf2,betis,2] ,font=ft_propor)
 '3':bsa2 = widget_button(binf2,value='3=Hollow cylinder',uvalue=[uv,3,2,binf2,betis,3],font=ft_propor)
 else:
 endcase
binf2 = widget_button(betis,value='ABOUT THIS TREATMENT'       ,menu=2  ,font=ft_propor)
 seq  =['- Normalise  vanadium , empty_can , sample according to monitor counts' ,$
        '- Determine  peak position of sample and vanadium'                  ,$
        '- Align      sample and vanadium (empty) using a circular shift'    ,$
        '- Remove     empty_can from sample and vanadium using transmissions',$
        '- Remove     noisy , too low and too high spectra (discrimination)' ,$
        '- Correct    the vanadium using a Debye Waller factor'              ,$
        '- Calibrate  the sample   using the elastic peak of the vanadium'   ,$
        '-(Resolution)instrument is taken from vanadium peak at any angles'  ,$
        '- Correct    for the energy dependent efficiency of the detectors'  ,$
        '- Transform  to energy'                                             ,$
        '- Group      angles if many'                                        ,$
        ' ',$
        'IF YOU CHANGE TRANSMISSION OR ABSORBTION TYPE YOU HAVE TO'          ,$
        'PRESS THE "re_Treat W" BUTTON ON YOUR UPPER RIGHT']
 for i=0,n_elements(seq)-1 do $
  bt  = widget_button(binf2,value=seq(i),font=ft_propor)

if rtp(2) ne 1 then titi='--- EMPTY PEAKS ---' else titi='ABSORPTION shape'
bdra2=0L
blra2=0L
if yys eq 0 then begin
 bplt2= widget_base  (bshow,/row)
 bdra2= widget_draw  (bplt2,xsize=512,ysize=85-yys)
 blra2= widget_label (bplt2,value=titi			,font=ft_b_normal)
endif
brow  = widget_base  (bshow,/row)
br1   = widget_base  (brow ,/column)
btext = widget_list  (br1  ,xsize=14 ,ysize=17		,font=ft_propor)
blabel= widget_label (br1  ,value='TOF reduction'	,font=ft_b_normal)
blabel= widget_label (br1  ,value='by'			,font=ft_smaller)
blabel= widget_label (br1  ,value='D.Richard (7307)'	,font=ft_b_normal)
blabel= widget_label (br1  ,value='M.Ferrand       '	,font=ft_b_normal)

br3   = widget_base  (brow ,/column)
bupd  = widget_button(br3  ,value='re-PLOT'         ,font =ft_b_normal)
blabel= widget_label (br3  ,value='....'            ,font =ft_smallest)
bswqe = widget_button(br3  ,value='S(w,Qel)'        ,font =ft_b_normal)
bswq  = widget_button(br3  ,value='S(w,Q)'          ,font =ft_b_normal)
bpab  = widget_button(br3  ,value='P(a,B)'          ,font =ft_b_normal)
bquas = widget_button(br3  ,value='QUASI'           ,font =ft_b_normal)
blabel= widget_label (br3  ,value='....'            ,font =ft_smallest)
blev  = widget_button(br3  ,value='Levels'          ,font =ft_b_normal)
bsurf = widget_base  (br3  ,/row)
bsu1  = widget_button(bsurf,value='S'               ,font =ft_b_normal)
bsu2  = widget_button(bsurf,value='u'               ,font =ft_b_normal)
bsu3  = widget_button(bsurf,value='r'               ,font =ft_b_normal)
bsu4  = widget_button(bsurf,value='f'               ,font =ft_b_normal)
bsu0  = widget_button(br3  ,value='Front'           ,font =ft_b_normal)
blabel= widget_label (br3  ,value='....'            ,font =ft_smallest)
br3r  = widget_base  (br3  ,/row)
bid   = widget_label (br3r ,value='To'              ,font =ft_smallest)
bhard = widget_button(br3r ,value=psf+'.PS'         ,font =ft_b_normal)
br3r  = widget_base  (br3  ,/row)
bid   = widget_label (br3r ,value='To'              ,font =ft_smallest)
bhinx = widget_button(br3r ,value=psf+'.INX'        ,font =ft_b_normal)
br3r  = widget_base  (br3  ,/row)
bid   = widget_label (br3r ,value='To'              ,font =ft_smallest)
bsav  = widget_button(br3r ,font=ft_propor   ,value='W'+wkos)
brev  = widget_button(br3r ,font=ft_smallest ,value='<',uvalue=[-88,310,bsav,5])
bnex  = widget_button(br3r ,font=ft_smallest ,value='>',uvalue=[-88,311,bsav,5])

br2   = widget_base  (brow ,/column)
bsca  = widget_base  (br2  ,/row)
bidon = widget_label (bsca ,value='Max Count '      	    ,font =ft_b_normal)
bidon = widget_label (bsca ,value=strtrim(maxw(1),2)	    ,font =ft_b_normal)
bidon = widget_label (bsca ,value=' cut to '   	          ,font =ft_b_normal)
bscal = widget_text  (bsca ,value=strtrim(pho_mx ,2),xsize=7,font =ft_propor,/editable)
xwin  = 430
br2r  = widget_base  (br2  ,/row)
bdrac = widget_draw  (br2r ,xsize=xwin,ysize=300)
bslid = widget_base  (br2  ,/row)
bsld1 = widget_base  (bslid,/column)
bsld2 = widget_base  (bslid,/column)
bsli1 = widget_slider(bsld1,title='',min=1  ,max=350,xsize=xwin/2-8,/supp,$
				     value=1  ,/drag,ysize=15)
bsli2 = widget_slider(bsld2,title='',min=151,max=500,xsize=xwin/2-8,/supp,$
				     value=500,/drag,ysize=15)
bran1 = widget_label (bsld1,value='_______________' ,font =ft_propor)
bran2 = widget_label (bsld2,value='_______________' ,font =ft_propor)

bxgrp = widget_base  (br2  ,/row)
bslix = widget_slider(bxgrp,title='',min=3  ,max=500,xsize=xwin,/supp,$
				     value=500,/drag,ysize=15)
blabx = widget_label (bxgrp,value='______'	    ,font =ft_propor)

br2rr = widget_base  (br2r ,/column)
blabg = widget_label (br2rr,value=strtrim(string(pho_grp),2),font=ft_b_normal)
bgrp  = widget_slider(br2rr,title='',min=1,max=sw(2),/supp,value=pho_grp,xsize=17,$
		      /drag,/vertical,ysize=300-20,uvalue=[uv,5,blabg,bran1])

if exclu(0) ge 0 then $
widget_control,btext,set_value=[' Excluded  ' , '  Spectra'  ,  ' ' ,   $
				 strtrim(string(yraw(exclu)) ,2)+' -> '+$
				 strtrim(string(     exclu+1),2)]  else $
widget_control,btext,set_value=[' Excluded  ' , '  Spectra']

if pho_rax(0) eq pho_rax(1) then begin
   idx=where(xout ge -2*xout(sw(1)-1))
   idx=min([idx,(sw(1)-1)/2])
   idx=0
   idz=where(xout ge -2*xout(0))
   if idz(0) le idx then idz=sw(1)-1
   idz=min([idz(0),(sw(1)-1)])
   pho_rax=[idx,idz]
endif else begin
   idx=min([pho_rax(0),sw(1)-4])
   idz=max([min([pho_rax(1),sw(1)-1]),sw(1)/2+2])
   pho_rax=[idx,idz]
endelse

rx1    =xout(idx)
rx2    =xout(idz)
str_lab={sx:sw(1) , idi:idx , xval:xout ,ygrp:pho_grp}
widget_control,bran1,set_uvalue=str_lab,set_value=string(rx1)
str_lab.idi=idz
widget_control,bran2,set_uvalue=str_lab,set_value=string(rx2)

uvs=[uv,1,bran1,bran2,bslix,blabx]
     widget_control,bsli1,set_uvalue=uvs,set_value=(idx+1)*500./sw(1)
uvs=[uv,1,bran2,bran1,bslix,blabx]
     widget_control,bsli2,set_uvalue=uvs,set_value=(idz+1)*500./sw(1)

uvs=[uv,6,blabx,bran1,bran2]
     widget_control,bslix,set_uvalue=uvs  &  grpx=idz-idx+1
     widget_control,blabx,set_value =strtrim(string(grpx),2)

uvs=[uv,2,bran1,bran2,bcorr,1,0 ,blabx,bscal]     	& widget_control,bupd ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-1,blabx,bscal]     	& widget_control,bswqe,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-2,blabx,bscal]     	& widget_control,bswq ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-3,blabx,bscal]     	& widget_control,bpab ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-4,blabx,bscal]     	& widget_control,bquas,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,1 ,blabx,bscal]     	& widget_control,bsu1 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,2 ,blabx,bscal]     	& widget_control,bsu2 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,3 ,blabx,bscal]     	& widget_control,bsu3 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,4 ,blabx,bscal]     	& widget_control,bsu4 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,5 ,blabx,bscal]     	& widget_control,bsu0 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,6 ,blabx,bscal]     	& widget_control,blev ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,3,bread,blabx,bscal,bsav] 	& widget_control,bhinx,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,2,bread,blabx,bscal]  	& widget_control,bsav ,set_uvalue=uvs
uvs=[uv,4,betis,ott]		            	  	& widget_control,bread,set_uvalue=uvs

bid=sys_dep      ('DYNLAB',bshow,1)
widget_control,bshow,/realize

if bdra2 gt 0 then widget_control,bdra2,get_value=wip2 else wip2=0
widget_control,bdra1,get_value=wip1
widget_control,bdra3,get_value=wip3
widget_control,bdra4,get_value=wip4
widget_control,bdrac,get_value=wic

uvs=[-88,350,wic,bhard,wkn,2]        & widget_control,bhard,set_uvalue=uvs

 widget_control,bpab  ,sensitive=0
 widget_control,bquas ,sensitive=0
;widget_control,bhinx ,sensitive=0

wicp   =[wic,wip2,blra2]
str_lab={cy:yin,w:win,id:wicp,kn:wkn,mx:maxw,hd:[bhard,bhinx],wl:wavel,err:ERRdat}
widget_control,bcorr,set_uvalue=str_lab

XMANAGER, 'Didline', bshow, event_handler='LAMP_EVENT_PARSER',/just_reg

keepd =!D.window
col   =0
bgr   =255
ry1   =min (vidp)
ry2   =max (vidp) & ryt=ry2
ry3   =max (rawe)
if ry3 gt ry2*5 then ry2=ry2*5 else ry2=max([ry2,ry3])

wset,wip1
plot,ytp,rawe        ,color=col,background=bgr,$
		xmargin=[0,0],ymargin=[0,0],ystyle=4 ,xticklen=1.,xgridstyle=1
wset,wip4
plot,ytp,corre       ,color=col,background=bgr,$
		xmargin=[0,0],ymargin=[0,0],ystyle=4 ,xticklen=1.,xgridstyle=1
wset,wip3
plot,ytp,1./pry      ,color=col,background=bgr,$
		xmargin=[0,0],ymargin=[2,0],ystyle=4 ,xticklen=1.,xgridstyle=1

if wip2 gt 0 then begin
wset,wip2
if rtp(2) eq 1 then ry2=ryt
plot,ytp,vidp        ,color=col,background=bgr,yrange=[ry1,ry2],$
		xmargin=[0,0],ymargin=[0,0],ystyle=4 ,xticklen=1.,xgridstyle=1
endif
trap_current=!D.window

wset,keepd
pho_contour,[wic,0],win,xout,yin,ERRdat, [rx1,rx2],maxw, w_tit(wkn) ,pho_grp,grpx,1,wavel,pho_mx

end

pro pho_contour, wicp ,www,xxx,yyy,eee ,rangx ,maxw, wtit ,nsp,nch ,what ,wavel ,maxim
;** ***********
;**
@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common pho_cu

win =www (pho_rax(0):pho_rax(1),*)<maxim
EER =eee (pho_rax(0):pho_rax(1),*)
xout=xxx (pho_rax(0):pho_rax(1),*)
yin =yyy

		 pho_groupx  , nch ,win ,xout,EER
if nsp gt 1 then pho_groupy  , nsp ,win ,yin ,EER $
	    else begin  yin=total(yin)  /n_elements(yyy)
			win=total(win,2)/n_elements(yyy)
			EER=SQRT(total(EER^2,2))/n_elements(yyy)
			endelse

s   =size(win) & if nsp eq 1 then s(2)=1

if pho_fct eq 1 then begin
   xtit='Energy Changes (meV)'
   ytit='Q elastic'
   ztit='S ( Q elas , W )'
   yin = sin(yin*!pi/180/2) *4*!pi / wavel(0)
endif

if pho_fct eq 2 then begin
   xtit='Energy Changes (meV)'
   ytit='Q'
   ztit='S ( Q , W )'
   qc  = cos(yin*!pi/180)
   ymax= sin(max(yin)*!pi/180/2) *4*!pi / wavel(0) *4
   yin = fltarr(s(1),s(2))

   ee    =(1.05457*  2*!pi)^2 / (2*1.67493) / 1.602177 * 10     ;h^2 /2m /f(joules)
   eelast= ee  /  wavel(0) ^2
   mho   = 0.695014*sqrt(eelast+xout) ;+ if energy changes, - if energy transfert
   mhoc  = mho^2
   ki    = 0.695014*sqrt(eelast)
   kic   = ki ^2

   for i=0,s(2)-1 do yin(*,i)= sqrt(kic + mhoc - 2.* ki * mho * qc(i) )

   yin =   yin<ymax
   xout=         [ [xout],[xout] ]
   xout=   congrid (xout ,s(1),s(2))
endif

if pho_fct eq 3 then begin
   rtemp =wavel(4)>5.
   rmass =1.	& radian=57.3
   xtit  ='Energy(meV)  Temp='+strtrim(string(rtemp),2)+' mass=1.'
   ytit  ='PaB'
   ztit  =''
   yin   = sin(yin*!pi/180/2) *4*!pi / wavel(0)

   ei      =81.799/wavel(0)^2  &  temp_inv = 11.61/rtemp  &  temp_x_mass = rtemp*rmass
   tof_fac = 5.227e6/ei        &  tof_in = sqrt(tof_fac)  &  rec_tof2 = 1.0/tof_in^2
   tau     = 1.0/(sqrt((xout)/5.227e6 + 1.0/tof_fac))     &  tau2 = tau^2  &  tau4 = tau^4

   beta      =(xout*temp_inv)<40  &  exp_beta = exp(0.5*beta)>  1.0e-9
   shine_beta= 0.5 *(exp_beta  - 1.0/exp_beta )

   cos_theta= cos(yin / radian)
   q_eff    = ((1.0/tau2)+rec_tof2-((2.0*cos_theta)/(tof_in*tau)))
   alfa     =(((6.07e7)*q_eff)/temp_x_mass) > .00001

   for cpt=0,s(2)-1 do begin
   	yc        = win(*,cpt)*tof_in/((9.681e-8) *tau4)
	sab       =((0.82412e-8)*tau4*exp_beta*yc)/tof_in
        win(*,cpt)=(2.0*beta*shine_beta*sab)/alfa(cpt)
        
   	yc        = EER(*,cpt)*tof_in/((9.681e-8) *tau4)
	sab       =((0.82412e-8)*tau4*exp_beta*yc)/tof_in
        EER(*,cpt)=(2.0*beta*shine_beta*sab)/alfa(cpt)
   endfor
endif

if pho_fct eq 4 then begin
   xtit='Q elastic'
   ytit='Quasi'
   ztit=''
endif

;PLOT
;****
if what eq 1 then begin
   keepd =!D.window
   bg    =255 & col=0

   if wicp(1) gt 0 then begin
      if nsp gt 1 then proj  =total(win,2)/s(2) else proj=win
      proj  =proj -min(proj)
      wset,wicp(1)
      plot,xout,proj,color=col,background=bg,xtitle=xtit,$
		  xmargin=[0,0],ymargin=[2,0] ,xticklen=1.,xgridstyle=1
      widget_control,bad_id=i,wicp(2),set_value=ytit+' projection'
      endif
   wset,wicp(0)
   if (nsp     eq 1) then begin
      plot,xout,win ,color=col,background=bg,xtitle=xtit,xmargin=[7,1],ymargin=[3,2] $
		    ,xticklen=1.,xgridstyle=1,yticklen=1.,ygridstyle=1
   endif  else $
   if (pho_rep eq 6) then begin
;     if maxw(1) gt 50 then win=win<(maxw(1)/10)
      win =alog(win) & xtit=xtit+' (Log display)'
      if s(1)*s(2) gt 80.*50 then if sys_dep('VERSION') lt 4.1 then ii=execute("win=smooth(win,3)") $
                                                               else ii=execute("win=smooth(win,3,/edge)")
      nl  =24
      contour   ,win,xout,yin,/fill,nlevels=nl ,$
                          xtitle=xtit,ytitle=ytit,title=wtit,$
                          xmargin=[7,1],ymargin=[3,2]
;     contour   ,win,xout,yin,c_colors=(indgen(nl)+1)*(180/nl)+50 ,nlevels=nl ,$
;                         xtitle=xtit,ytitle=ytit,title=wtit,background=bg    ,$
;                         xmargin=[7,1],ymargin=[3,2],color=col
   endif  else $
   if (pho_rep ge 1) and (pho_rep le 5) then begin
      maxz=max(win,min=minz)
      mima=maxz -  minz
      szz =strcompress(string([minz, minz+mima/4  ,minz+mima/2,$
				     minz+mima*3/4,maxz],format='(f8.2)'))
      xx=60 &		    zz=   0
      if pho_rep eq 1  then zz= -20 else if pho_rep eq 2 then zz=  20
      if pho_rep eq 3  then zz=-160 else if pho_rep eq 4 then zz= 160
      if pho_rep eq 5  then xx=   0
      if abs(zz) gt 45 then mtit='' else mtit=wtit
      if xx	 eq 0  then begin   mtit=xtit & xtit='' & endif

      res=sys_dep('VIEWER')
      if (res eq 1) and ((pho_rep eq 3) or (pho_rep eq 4)) then begin
	      if pho_rep eq 3 then matovr,win,xout,yin,/row
	      if pho_rep eq 4 then matovr,win,xout,yin,/col
	      res=sys_dep('VIEWER','lamp.wrl')
      endif else $
      if s(2) gt 16 then $
      	      shade_surf,win,xout,yin,ax=xx,az=zz,color=col,zticks=4,ztickname=szz,$
                                      xtitle=xtit,ytitle=ytit,title=mtit,background=bg,$
                                      xmargin=[7,1],ymargin=[3,2]        $
      else    surface   ,win,xout,yin,ax=xx,az=zz,color=col,/horizontal ,$
                                      xtitle=xtit,ytitle=ytit,title=mtit,background=bg,$
                                      xmargin=[7,1],ymargin=[3,2],zticks=4,ztickname=szz
   endif
   trap_current=!D.window
   wset,keepd
endif

;SAVE
;****
if what ge 2 then begin
   pho_tri,win,xout,yin,what ,EER
   pho_t =[wtit,xtit,ytit]
   
   XICUTE,'W'+pho_oiw(0)+'=sav_didline(W'+pho_oiw(1)+',samp='+pho_oiw(1)+')'
   if what eq 3 then $
   XICUTE,'dumpx,W'+pho_oiw(0) +',"'+ pho_psf+'.INX"'
endif

return
end

pro pho_tri, win,xout,yin,what ,EER
;** *******
;**
common pho_cu

s =size(win)
if (pho_fct eq 2) and (what ge 2) and (s(0) eq 2) then begin
   s =size(win)
   sx=size(xout)
   sy=size(yin)
   n =sx(1)-1
   a =max (xout,min=b)   & gsx = (a-b)/n
   n =sy(sy(0))-1
   a =max (yin ,min=c)   & gsy = (a-c)/n

   if sx(0) eq 1 then begin
      xout=         [ [xout],[xout] ]
      xout=   congrid (xout ,s(1),s(2))
      endif
   if sy(0) eq 1 then begin
      yin =transpose([ [yin],[yin] ])
      yin =     congrid(yin ,s(1),s(2))
      endif

   triangulate,  xout,yin, triangles ,bds
   pho_w=     trigrid(xout,yin,win,  triangles ,[gsx,gsy] )
   pho_e=SQRT(trigrid(xout,yin,EER^2,triangles ,[gsx,gsy] ))

   s    =size(pho_w)
   pho_x=b+findgen(s(1))*gsx
   pho_y=c+findgen(s(2))*gsy

endif else begin pho_x=xout & pho_y=yin & pho_w=win & pho_e=EER & endelse

return
end

function sav_didline, w,sample=n
;******* ***********
;**
@lamp.cbk
common pho_cu

   centm=100000.
   iii =execute('X'+pho_oiw(0)+'=pho_x')
   iii =execute('Y'+pho_oiw(0)+'=pho_y')
   iii =execute('E'+pho_oiw(0)+'=pho_e')
   iii =execute('N'+pho_oiw(0)+'=centm')
   w_tit(fix(pho_oiw(0)))=pho_t(0)
   x_tit(fix(pho_oiw(0)))=pho_t(1)
   y_tit(fix(pho_oiw(0)))=pho_t(2)

return,pho_w
end

pro pho_event ,ev ,uv
;** *********
;**
@lamp.cbk
common pho_cu

case uv(2) of

;Range sliders
;***** *******
1:begin widget_control,bad_id=i,uv(3),get_uvalue=str_lab
	idx	   =round(str_lab.sx/500.*ev.value)-1
	str_lab.idi=idx
	strig      =string(str_lab.xval(idx))
	widget_control,bad_id=i,uv(3),set_uvalue=str_lab,set_value=strig
	widget_control,bad_id=i,uv(4),get_uvalue=str_lab & idz=str_lab.idi
	widget_control,bad_id=i,uv(5),set_value =500
	widget_control,bad_id=i,uv(6),set_value =strtrim((abs(idz-idx)+1)>3 ,2)
        end
;Update Save Buttons
;****** **** *******
2:begin widget_control,bad_id=i,uv(3),get_uvalue=str_s1
	widget_control,bad_id=i,uv(4),get_uvalue=str_s2
	widget_control,bad_id=i,uv(5),get_uvalue=str_yw
	da1     =min([str_s1.idi ,str_s2.idi])
	da2     =max([str_s1.idi ,str_s2.idi]) & if da1 eq da2 then da2=da2+2
	pho_rax=[da1,da2]
	pho_grp= str_s1.ygrp
	rangx  =[str_s1.xval(da1),str_s2.xval(da2)]

	if (uv(6) eq 2) or (uv(6) eq 3) then begin
	   if uv(6) eq 2 then iv=ev.id else iv=uv(10)
	   widget_control,iv  ,get_value=wkn  & wkn=wkn(0) & i=strpos(wkn,'W')
	   wkn=strtrim(strmid(wkn,i+1,2),2)   & pho_oiw(0) =wkn
	   widget_control,uv(7),get_value=wkn & wkn=wkn(0) & i=strpos(wkn,'W')
	   wkn=strtrim(strmid(wkn,i+1,2),2)   & pho_oiw(1) =wkn

	endif else if uv(7) gt 0 then pho_rep= uv(7) $
	      else if uv(7) lt 0 then pho_fct=-uv(7)

        psf    =pho_rep+pho_fct+(pho_grp+pho_rax(0)+pho_rax(1))/10+str_yw.kn
        pho_psf='DL'+strtrim(string(psf),2)
	widget_control,bad_id=i,str_yw.hd(0),set_value=pho_psf+'.PS'
	widget_control,bad_id=i,str_yw.hd(1),set_value=pho_psf+'.INX'

	widget_control,bad_id=i,uv(8),get_value=grpx  & grpx =fix(grpx(0))

	widget_control,bad_id=i,uv(9),get_value=maxou & maxou=maxou(0)
			on_ioerror,mismax & maxim=str_yw.mx(1)
			maxim=float(maxou)
			if (maxim le str_yw.mx(0)) then maxim=str_yw.mx(1) $
			else pho_mx=maxim
			mismax:

	pho_contour, str_yw.id ,str_yw.w ,str_s1.xval ,str_yw.cy ,str_yw.err ,rangx ,$
		     str_yw.mx ,w_tit(str_yw.kn),str_s1.ygrp,grpx ,uv(6),str_yw.wl,maxim
	end

;Change parameters
;****** **********
3:begin if uv(3) eq 0 then begin
;	Sample transmision
	   widget_control,ev.id,get_value =val & valf=float(val)
	   widget_control,uv(5),get_uvalue=rtp & rtp(0)=valf
	   widget_control,uv(5),set_uvalue=rtp
	   widget_control,uv(4),set_value ='Next sample trans -> '+val
	endif
	if uv(3) eq 1 then begin
;	Vanadi transmision
	   widget_control,ev.id,get_value =val & valf=float(val)
	   widget_control,uv(5),get_uvalue=rtp & rtp(1)=valf
	   widget_control,uv(5),set_uvalue=rtp
	   widget_control,uv(4),set_value ='Next vanad. trans -> '+val
	endif
	if uv(3) eq 2 then begin
;	Self-absorbtion
	   widget_control,uv(5),get_uvalue=rtp & rtp(2)=uv(6)
	   widget_control,uv(5),set_uvalue=rtp
	   widget_control,uv(4),set_value ='Next absorb. type -> '+strtrim(string(uv(6)),2)
	endif
	end

;Read   button
;****   ******
4:begin
	widget_control,uv(3),get_uvalue=rtp
	widget_control,ev.id,get_value =wkn & wkn=wkn(0)
	i  =strpos(wkn,'W')
	wkn=strtrim(strmid(wkn,i+1,2),2) & pho_oiw(1)=wkn

	cmd='w'+strtrim(string(uv(4)),2)+'=didline(samp='+wkn
	if uv(6) gt 0  then cmd=cmd+        ',vana=' +strtrim(string(uv(6)),2)
	if uv(7) gt 0  then cmd=cmd+        ',empt=' +strtrim(string(uv(7)),2)
	if uv(8) gt 0  then cmd=cmd+        ',canv=' +strtrim(string(uv(8)),2)
	cmd=cmd+',trans_abs=rtp)'
	iii=execute(cmd)
  	end

;Group  slider for angles
;*****  ****** *** ******
5:begin widget_control,uv(3),set_value =strtrim(string(ev.value),2)
	widget_control,uv(4),get_uvalue=str_s1
	str_s1.ygrp=ev.value
	widget_control,uv(4),set_uvalue=str_s1
  	end

;Group  slider for channels
;*****  ****** *** ********
6:begin widget_control,uv(4),get_uvalue=str_lab & da1=str_lab.idi
	widget_control,uv(5),get_uvalue=str_lab & da2=str_lab.idi
	idx=((da2-da1+1)*ev.value/500)>3
	widget_control,uv(3),set_value =strtrim(string(idx),2)
	end
else:

endcase

return
end

pro pho_groupy, nsp,win,yin ,ERR
;** **********
;**
     sw=size(win)
     if nsp ne sw(2) then begin
        gp  =float (sw(2))/nsp
	wtmp=fltarr(sw(1) ,nsp)
	ERRt=fltarr(sw(1) ,nsp) & if n_elements(ERR) eq 0 then ERR=SQRT(win)
	ytmp=fltarr(nsp)

	for  i =nsp -1 ,1,-1  do begin
	     j1=round(i*gp)
	     j2=round(i*gp+gp-1)
	     j3=j2-j1+1
	     if j3 gt 1 then wtmp(*,i)=     total(win(*,j1 : j2)    ,2)  /j3 $
	     		else wtmp(*,i)=           win(*,j1)
	     if j3 gt 1 then ERRt(*,i)=SQRT(total(ERR(*,j1 : j2)^2  ,2)) /j3 $
	     		else ERRt(*,i)=           ERR(*,j1)
	     		     ytmp  (i)=     total(yin(  j1 : j2)      )  /j3
	endfor
	     j3=round(gp)
	     if j3 gt 1 then wtmp(*,0)=     total(win(*, 0 : j3-1)  ,2)  /j3 $
	     		else wtmp(*,0)=           win(*, 0)
	     if j3 gt 1 then ERRt(*,0)=SQRT(total(ERR(*, 0 : j3-1)^2,2)) /j3 $
	     		else ERRt(*,0)=           ERR(*, 0)
	     		     ytmp  (0)=     total(yin(   0 : j3-1)    )  /j3

	win=wtmp & wtmp=0
	ERR=ERRt & ERRt=0
	yin=ytmp & ytmp=0
     endif
return
end

pro pho_groupx, nch,win,xin ,ERR
;** **********
;**
     sw=size(win)
     if nch ne sw(1) then begin
        gp  =float (sw(1))/nch
	wtmp=fltarr(nch,sw(2))
	ERRt=fltarr(nch,sw(2)) & if n_elements(ERR) eq 0 then ERR=SQRT(win)
	xtmp=fltarr(nch)

	for  i =nch -1 ,1,-1  do begin
	     j1=round(i*gp)
	     j2=round(i*gp+gp-1)
	     j3=j2-j1+1
	     if j3 gt 1 then wtmp(i,*)=     transpose(total(win(  j1 : j2,*)  ,1)) /j3 $
	     		else wtmp(i,*)=                     win(  j1     ,*)
	     if j3 gt 1 then ERRt(i,*)=SQRT(transpose(total(ERR(  j1 : j2,*)^2,1)))/j3 $
	     		else ERRt(i,*)=                     ERR(  j1     ,*)
	     		     xtmp  (i)=               total(xin(  j1 : j2) )       /j3
	endfor
	     j3=round(gp)
	     if j3 gt 1 then wtmp(0,*)=     transpose(total(win( 0 : j3-1,*)  ,1)) /j3 $
	     		else wtmp(0,*)=                     win( 0       ,*)
	     if j3 gt 1 then ERRt(0,*)=SQRT(transpose(total(ERR( 0 : j3-1,*)^2,1)))/j3 $
	     		else ERRt(0,*)=                     ERR( 0       ,*)
	     		     xtmp  (0)=               total(xin( 0 : j3-1) )       /j3

	win=wtmp & wtmp=0
	ERR=ERRt & ERRt=0
	xin=xtmp & ytmp=0
     endif
return
end

function didline , radata , sample=sampln  , vanadium=vanadn , empty=emptn , canvan=canva , trans_abs=rtp , cadmium=cadmn
;******* *******
;**
;** Reality show . (D. Richard)
;**
@lamp.cbk

if n_params() eq 1 then begin INX,(one+0),(two+0) & return,radata & endif
instv=strupcase(inst_value)

;****CHECK PARAMETERS
;****
second=two

if n_elements(radata) gt 1 then rodata=radata else $
if n_elements(sampln) eq 1 then if (sampln gt 0)   and (sampln le 20) then  begin second=sampln
   rodata=0 & sn=strtrim(string(sampln),2) & i=execute('rodata=w'+sn) & i=execute('ERRdat=e'+sn)
   endif else sampln=0 else sampln=0

if n_elements(vanadn) eq 1 then if (vanadn gt 0)   and (vanadn le 20) then begin
   vanadi=0 & vn=strtrim(string(vanadn),2) & i=execute('vanadi=w'+vn)
   endif else vanadn=0 else vanadn=0

empti=0
if n_elements(emptn ) eq 1 then if (emptn  gt 0)   and (emptn le 20)  then begin
   empti =0 & en=strtrim(string(emptn) ,2) & i=execute('empti =w'+en) & i=execute('ERRemp=e'+en)
   endif else emptn =0 else emptn =0

if n_elements(canva ) eq 1 then if (canva  gt 0)   and (canva le 20)  then begin
   canvi =0 & ci=strtrim(string(canva) ,2) & if (canva ne emptn) then   i=execute('canvi =w'+ci)
   endif else canva =0 else canva =0

if n_elements(cadmn ) eq 1 then if (cadmn  gt 0)   and (cadmn le 20)  then begin
   cadmi =0 & di=strtrim(string(cadmn) ,2) & i=execute('cadmi =w'+di) & i=execute('ERRcad=e'+di)
   endif else cadmn =0 else cadmn =0

wk1 =strtrim(string(one),2) & wk2=strtrim(string(second),2)

sizs= size(rodata)
siza= size(vanadi)
sizn= size(empti)
sizc= size(canvi)
sizd= size(cadmi)
win = 0
if  n_elements(vanadi) le 1   then  begin v_is= 0 & siza=sizs & endif  else v_is=1
if  n_elements(empti)  le 1   then  begin n_is= 0 & sizn=sizs & endif  else n_is=1
if  n_elements(canvi)  le 1   then  begin c_is= 0 & sizc=sizs & endif  else c_is=1
if  n_elements(cadmi)  le 1   then  begin d_is= 0 & sizd=sizs & endif  else d_is=1
if  emptn  eq sampln		     then n_is=-1
if (emptn  eq canva) and (n_is eq 1) then c_is= 2
;if (c_is   eq 0)     and (n_is eq 1) then c_is= 2

if (sizs(0) eq 2) and (siza(0) eq 2) and (sizn(0) eq 2) and (sizc(0) eq 2) and $
   (sizs(1) eq siza(1)) and (sizs(1) eq sizn(1)) and (sizs(1) eq sizc(1))  and $
   (sizs(2) eq siza(2)) and (sizs(2) eq sizn(2)) and (sizs(2) eq sizc(2)) then begin
    rodata=rodata>0
    if n_elements(ERRdat) ne n_elements(rodata) then ERRdat=SQRT(rodata)
    if n_elements(ERRemp) ne n_elements(empti)  then ERRemp=SQRT(empti)
    if n_elements(ERRcad) ne n_elements(cadmi)  then ERRcad=SQRT(cadmi)
;****
;****
     p_in=0 & p_vn=0 & iii = execute('p_in=p'+wk2)
     if v_is eq 1 then iii = execute('p_vn=p'+vn)

     cwidth= 1. & wavel=1. & dist=1. & kelvis=0. & kelvin=0. & s_elas=sizs(1)/2.+.5 & doppl=1.
     if n_elements(p_in) gt 27 then begin
      doppl = p_in(2)>0.
      cwidth= p_in(18)
      wavel = p_in(21)
      dist  = p_in(27)
      kelvis= p_in(11)
      s_elas= p_in( 9)>0
      if v_is eq 1 then kelvin= p_vn(11)
     endif
     if   (instv eq 'IN10') or (instv eq 'IN16') or $
	  (instv eq 'IN13') then wavel=doppl
     if wavel gt 0 then begin
     if dist  gt 0 then begin

     fe_a  = 1.0      & f5_a  = 0.951
     fe_b  =-0.0565   & f5_b  =-0.0887
     fe_c  =-3.284    & f5_c  =-4.07
     if   (instv eq 'IN4') then begin fe_a=0.951 & fe_b=-.0887 & fe_c=-5.597 & endif
     
     if n_elements(rtp) gt 1 then begin
     		if rtp(0) eq 0 then rtp(0)=.99
     		if rtp(1) eq 0 then rtp(1)=.99
		transs= rtp(0) & Ts=transs
		transv= rtp(1) & Tv=transv
		transc= 0.97   & Tc=transc
		transn= 0.97   & Tn=transn
		slab  = rtp(2)
		tolow = rtp(3)
		ra1   = rtp(4)
		ra2   = rtp(5)
		ires  = rtp(6)
		igg   = fix(rtp(7)) & bgsub=[0,0,0,0] & bgsub(0)=(igg and 1)/1 & bgsub(1)=(igg and 2)/2
		                                        bgsub(2)=(igg and 4)/4 & bgsub(3)=(igg and 8)/8
		sangl = rtp(8)
		test  = long(sangl/180.)
		if test*180 eq sangl then slab=0
      endif  else begin
		transs= 0.90   & Ts=transs
		transv= 0.85   & Tv=transv
		transc= 0.97   & Tc=transc
		transn= 0.97   & Tn=transn
		slab  = 0
		tolow =15./100
		ra1   =0
		ra2   =0
		ires  =0
		igg   =1       & bgsub =[1,0,0,0]
		sangl =0
     endelse

     if strpos(strlowcase(x_tit(second)),'energy')  ge 0   then inergy=1 else inergy=0
     if v_is ne 1 then bgsub(0)=0 & if n_is ne 1 then bgsub(2)=0 & if c_is ne 1 then bgsub(3)=0

;*** ANGLE RANGE
;***
     xout=0 & iii =execute('xout=x'+wk2) & xout=xout(*,0)
     yraw=0 & iii =execute('yraw=y'+wk2)

     if n_elements(xout) ne sizs(1) then xout=findgen(sizs(1))+1.
     if n_elements(yraw) ne sizs(2) then yraw=findgen(sizs(2))+10. & sizy=size(yraw)
     elas = where(xout ge 0) & elas=elas(0)>0
     if elas gt 0 then s_elas= elas
     if sizy(0) eq 2 then yraw=reform(yraw(s_elas,*))

     if ra2 gt ra1 then begin
	id1=where(yraw ge ra1) & id1=id1(0)>0
	id2=where(yraw ge ra2) & id2=id2(0) & if id2 lt id1 then id2=n_elements(yraw)-1
	if id2 gt id1 then begin
				  rodata=rodata(*,id1:id2)
				  yraw  =yraw  (  id1:id2)
				  ERRdat=ERRdat(*,id1:id2)
		if n_is eq 1 then ERRemp=ERRemp(*,id1:id2)
		if n_is eq 1 then empti =empti (*,id1:id2)
		if c_is eq 1 then canvi =canvi (*,id1:id2)
		if d_is eq 1 then cadmi =cadmi (*,id1:id2)
		if d_is eq 1 then ERRcad=ERRcad(*,id1:id2)
		if v_is eq 1 then vanadi=vanadi(*,id1:id2)
		sizs= size(rodata)
	endif
     endif

   if not inergy then begin

;****GROUP SAME ANGLES
;****
     if v_is eq 1  then begin yt=yraw &  groupy,vanadi,yt         ,/average & endif
     if n_is eq 1  then begin yt=yraw &  groupy,empti ,yt  ,ERRemp,/average & endif
     if c_is eq 1  then begin yt=yraw &  groupy,canvi ,yt         ,/average & endif
     if d_is eq 1  then begin yt=yraw &  groupy,cadmi ,yt  ,ERRcad,/average & endif
					 groupy,rodata,yraw,ERRdat,/average
     sizs=size (rodata)

;****NORMALIZE BY MONITORS
;****
        msamp =1 & i=execute('msamp=total(n'+wk2+'(*,0))>1') & centm=100000.
        rodata=(rodata)* ( centm/msamp)
	ERRdat=(ERRdat)* ( centm/msamp)
	msamp =centm

     if v_is eq 1 then begin
        mvana =1 & i=execute('mvana=total(n'+vn +'(*,0))>1')
        vanadi=(vanadi)* ( msamp/mvana)
     endif
     if n_is eq 1 then begin
        mempt =1 & i=execute('mempt=total(n'+en +'(*,0))>1')
        empti =(empti) * ( msamp/mempt)
	ERRemp=(ERRemp)* ( msamp/mempt)
     endif
     if c_is eq 1 then begin
        mcanv =1 & i=execute('mcanv=total(n'+ci +'(*,0))>1')
        canvi =(canvi) * ( msamp/mcanv)
     endif
     if d_is eq 1 then begin
        mcadm =1 & i=execute('mcadm=total(n'+di +'(*,0))>1')
        cadmi =(cadmi) * ( msamp/mcadm)
	ERRcad=(ERRcad)* ( msamp/mcadm)
     endif

;****SELF ABSORPTION CURVE
;****
     if (slab eq 1) and ((n_is eq 1) or (v_is*c_is ge 1)) then begin
	 alpha=sangl*!pi/180.
	 Yr =	 yraw/180.*!pi
	 ida=where(Yr eq alpha)
	 if ida(0) ge 0 then Yr(ida)=Yr(ida)*1.01 ;(Yr((Ida-1)>0)+Yr((ida+1)<(n_elements(yr)-1)))/2.01
	 idt=where(Yr lt alpha) & idr=where(Yr gt alpha)
	 As =	-alog(TRANSs)/   sin(alpha)
	 Bc =	-alog(TRANSc)/(2*sin(alpha))
	 Av =	-alog(TRANSv)/   sin(alpha)
	 Bn =	-alog(TRANSn)/(2*sin(alpha))
	 Mex=85. ;EXP(89)=Inf!

	 if (v_is eq 1) and (c_is eq 2) then begin Bn=Bc & canvi=empti & c_is=1 & endif

	 if idt(0) ge 0 then begin
	    j=idt(0)
	    Rt =    sin(alpha)  / sin(alpha - Yr(idt))
;*	    SAMPLE IN TRANSMISSION
	    vecSt=(exp(-Bc*(Rt+1))*exp(-As*Rt)*(exp((As*(Rt-1))<Mex)-1))/(As*(Rt-1)) ;1/A1

	    if n_is eq 1 then begin ;A2~
	       vectt=(exp(-As*Rt) * exp(-Bc*Rt) +  exp(-As) * exp(-Bc)) / ((1+exp((Bc*(Rt-1))<Mex))*exp(-Bc*Rt))
	    endif
;*	    VANADIUM IN TRANSMISSION
	    vecVt=(exp(-Bn*(Rt+1))*exp(-Av*Rt)*(exp((Av*(Rt-1))<Mex)-1))/(Av*(Rt-1)) ;1/A1

	    if v_is*c_is eq 1 then begin ;A2~
	       vevtt=(exp(-Av*Rt) * exp(-Bn*Rt) +  exp(-Av) * exp(-Bn)) / ((1+exp((Bn*(Rt-1))<Mex))*exp(-Bn*Rt))
	    endif
	 endif
	 if idr(0) ge 0 then begin
	    j=idr(0)
	    Rr =  -sin(alpha)  /  sin(Yr(idr) - alpha)
;*	    SAMPLE IN REFLEXION
	    A1Sr=(exp((Bc*(Rr-1))<Mex)*(exp((As*(Rr-1))<Mex)-1))/(As*(Rr-1)) ;1/A1
	    if idt(0) ge 0 then vecSt=[vecSt,A1Sr] else vecSt=A1Sr

	    if n_is eq 1 then begin ;A2~
	       A2r=(1+exp((Bc*(Rr-1))<Mex)*exp((As*(Rr-1))<Mex)) / (1+exp((Bc*(Rr-1))<Mex))
	       if idt(0) ge 0 then vectt=[vectt,A2r] else vectt=A2r
	    endif
;*	    VANADIUM IN REFLEXION
	    A1Vr=(exp((Bn*(Rr-1))<Mex)*(exp((Av*(Rr-1))<Mex)-1))/(Av*(Rr-1)) ;1/A1
	    if idt(0) ge 0 then vecVt=[vecVt,A1Vr] else vecVt=A1Vr

	    if v_is*c_is eq 1 then begin ;A2~
	       A2r=(1+exp((Bn*(Rr-1))<Mex)*exp((Av*(Rr-1))<Mex)) / (1+exp((Bn*(Rr-1))<Mex))
	       if idt(0) ge 0 then vevtt=[vevtt,A2r] else vevtt=A2r
	    endif
	 endif
	 AA1=vecVt/vecSt
     endif else slab=0

;****REMOVE EMPTY CAN BEFORE ALINE ???
;****
     if bgsub(2) eq 0 then begin
      	 if n_is  eq 1 then                   rodata=(rodata - Ts*empti)
      	 if n_is  eq 1 then                   ERRdat=SQRT(ERRdat^2 + (Ts*ERRemp^2))
      	 if d_is  eq 1 then if n_is eq 1 then rodata=(rodata - (1-Ts)*cadmi)
      	 if d_is  eq 1 then if n_is eq 1 then ERRdat=SQRT(ERRdat^2 + (((1-Ts)*ERRcad^2)))
      	 if v_is  eq 1 then if c_is eq 2 then vanadi=(vanadi - Tv*empti)
      	 if d_is  eq 1 then if c_is eq 2 then vanadi=(vanadi - (1-Ts)*cadmi)
     endif
     if bgsub(3) eq 0 then begin
      	 if v_is  eq 1 then if c_is eq 1 then vanadi=(vanadi - Tv*canvi)
     endif

;****ALINE
;****
     exclu=[-1]   &  s_idx=indgen(sizs(2)) & decal=intarr(sizs(2))       & v_elas=s_elas
     excln=[-1]
     exclv=[-1]
     exclg=[-1]
     if bgsub(3) then cav=lineup(canvi  ,g_elas,g_idx,exclg,bid  ,tolow)
     if bgsub(2) then vid=lineup(empti  ,n_elas,n_idx,excln,bid  ,tolow ,ERRORS=ERRemp)
     if bgsub(0) then van=lineup(vanadi ,v_elas,v_idx,exclv,decal,tolow) & s_elas=v_elas
     if bgsub(1) then win=lineup(rodata ,s_elas,s_idx,exclu,decal,tolow ,ERRORS=ERRdat) else win=rodata

     if bgsub(1) then if not bgsub(0) then for i=0,sizs(2)-1 do win   (*,i)=shift(win   (*,i),decal(i))
     if bgsub(1) then if not bgsub(0) then for i=0,sizs(2)-1 do ERRdat(*,i)=shift(ERRdat(*,i),decal(i))
     if bgsub(0) then if not bgsub(1) then for i=0,sizs(2)-1 do van   (*,i)=shift(van   (*,i),decal(i))
     wro=win

     if  n_is eq 1  then if bgsub(2)  then begin
	 if n_elas gt 0 then $
	 if s_elas ne n_elas then vid   =shift(vid   ,s_elas-n_elas,0)
	 if s_elas ne n_elas then ERRemp=shift(ERRemp,s_elas-n_elas,0)
	endif else vid=empti

     if  v_is eq 1  then if bgsub(0)  then begin
	 if v_elas gt 0 then $
	 if s_elas ne v_elas then van   =shift(van   ,s_elas-v_elas,0)
	endif else van=vanadi

     if  c_is eq 1  then if bgsub(3)  then begin
	 if g_elas gt 0 then $
	 if s_elas ne g_elas then cav   =shift(cav,s_elas-g_elas,0)
	endif else cav=canvi

;****REMOVE EMPTY CAN AFTER ALINE ???
;****
     if bgsub(2) eq 1 then begin              win   =(win - Ts*vid)
                                              ERRdat=SQRT(ERRdat^2 + (Ts*ERRemp^2))
      	 if d_is  eq 1 then if n_is eq 1 then win   =(win - (1-Ts)*cadmi)
      	 if d_is  eq 1 then if n_is eq 1 then ERRdat=SQRT(ERRdat^2 + (((1-Ts)*ERRcad^2)))
         if v_is  eq 1 then if c_is eq 2 then van   =(van - Tv*vid)
      	 if d_is  eq 1 then if c_is eq 2 then van   =(van - (1-Ts)*vid)
     endif
     if bgsub(3) eq 1 then                    van   =(van - Tv*cav)

;****SLAB CORRECTIONS
     if slab then begin
     ;?? if n_is      eq 1 then for i=0,n_elements(vectt)-1 do vid (*,i)=vid (*,i) * vectt(i)
     ;?? if v_is*c_is eq 1 then for i=0,n_elements(vevtt)-1 do cav (*,i)=cav (*,i) * vevtt(i)
	 			for i=0,n_elements(AA1)  -1 do win   (*,i)=win   (*,i) * AA1  (i)
	                        for i=0,n_elements(AA1)  -1 do ERRdat(*,i)=ERRdat(*,i) * AA1  (i)
     endif
     
;****MERGE GOOD INDEX GIVEN BY LINEUP
;****
     idx=s_idx
     if (v_is eq 1) or (n_is eq 1) or (c_is eq 1) then begin
     	 if excln(0) ge 0  then if exclv(0) ge 0  then exclv=[exclv,excln] else exclv=excln
     	 if exclg(0) ge 0  then if exclv(0) ge 0  then exclv=[exclv,exclg] else exclv=exclg
	 if exclv(0) ge 0  then begin
     	    for i= 0,n_elements(s_idx)-1 do begin
	        n= where(exclv eq s_idx(i) ,cnt)
	        if cnt gt 0  then begin
				  exclu   =[exclu,s_idx(i)]
				  s_idx(i)=-1   &   endif
     	    endfor
     	    idx=s_idx(where(s_idx ge 0))
     	    if  n_elements(exclu) gt 1 then  begin
     	    	if exclu(0) eq -1 then exclu=exclu(1:*)
     	    	exclu=exclu(sort(exclu))
	    endif
	 endif
     endif
;****REDUCTION OF BAD DETECTORS
;****
     rr =3    &         win   =win   (rr:sizs(1)-rr-2,idx)
     			ERRdat=ERRdat(rr:sizs(1)-rr-2,idx)
			xout  =xout  (rr:sizs(1)-rr-2)
     if  v_is eq 1 then van   =van   (rr:sizs(1)-rr-2,idx)
     if  n_is eq 1 then vid   =vid   (rr:sizs(1)-rr-2,idx)
     if  slab eq 1 then vecSt =vecSt (idx)
     if  slab eq 1 then vecVt =vecVt (idx)
     sizs  =size (win)

     rawe=total( wro((s_elas-10)>0 : (s_elas+10)<(sizs(1)-1),idx) ,1)/21  &  wro=0

     s_elas=(s_elas-rr)>0
     nsp  =n_elements(idx)
     decal=decal(idx)
     yin  =yraw (idx)
     ytp  =yin

;****REMOVE ELECTR. NOISES IF NO EMPTY GIVEN
;****
     if  n_is eq  0 then vidp=fltarr(nsp)+1 else $
     if  n_is eq -1 then begin
	 pry =total (win,2)
	 pidx=sort  (pry)
	 pidx=pidx  (4:(n_elements(pidx)/4)>5)  &  nch =n_elements(pidx)
	 vch =(nch/10)>2
	 vid =fltarr(vch,nsp)
	 vie =fltarr(vch,nsp)

         for  i= 0,vch-1 do vid(i,*)= win   (pidx(i),*)
         for  i= 0,vch-1 do vie(i,*)= ERRdat(pidx(i),*)
         pry= total(vid  ,1)/vch
	 vie= total(vie^2,1)/vch
         for  i= 0,nsp-1 do win   (*,i)=    (win   (*,i)  -pry(i)) >0
         for  i= 0,nsp-1 do ERRdat(*,i)=SQRT(ERRdat(*,i)^2+vie(i))

         if v_is eq 1 then begin
            for  i= 0,vch-1 do vid(i,*)= van(pidx(i),*)
            pry=(total(vid,1))/vch
            for  i= 0,nsp-1 do van(*,i)=(van(*,i)-pry(i)) >0
         endif

         vidp=pry
     endif else $
         vidp=total(vid((s_elas-10)>0:(s_elas+10)<(sizs(1)-1),*),1)/21

;****NORMALIZE BY EFFICIENCIES
;****
     win=win+.3
     if (v_is eq 0) and (n_is eq -1) then begin
	 van =fltarr(nch,nsp)
	 for  i= 0,nch-1 do van(i,*)=win(pidx(i),*)
         pry =(total(van,1)/nch)+1 & van=0

     endif else if v_is eq 0 then pry=fltarr(nsp)+1 $

     else begin
	 tmp=total(van,2) & tmp=tmp/max(tmp)
	 van=van>0
	 print,'Elastic peak position:',s_elas+rr
         pry=(total(van((s_elas-10)>0:(s_elas+15)<(sizs(1)-1),*),1)/26)+1
;*       DEBYE-WALLER attenuation
;*
         kc   = (sin(yin*!pi/180/2) *4*!pi / wavel) ^2
         dwf  = exp(-.0067*kelvin/300 *kc)
         pry  = pry * dwf
     endelse
     mx   = max ( pry,min=mn )
     pry  = total(pry)/n_elements(pry)/pry

     for i=0,nsp-1 do win   (*,i)=win   (*,i)*pry(i)
     for i=0,nsp-1 do ERRdat(*,i)=ERRdat(*,i)*pry(i)
     if v_is*ires eq 1 then for i=0,nsp-1 do van(*,i)=van(*,i)*dwf(i)
    ;vidp =  vidp*pry
     corre=total(win((s_elas-10)>0:(s_elas+10)<(sizs(1)-1),*),1)/21

;****NEGATIVE VALUES
;****
     if n_is eq 1 then begin
         	idx=where(win   lt 0) & n =n_elements(idx)
		if n gt 1 then begin
			nto=total(win(idx))/n & pto=total(win)/n_elements(win)
			mxx=max  (win,min=mii)
			print,'Transmission Correction Info: E_negative='+string(nto)+' E_positive='+string(pto)
			print,'************ Min='+string(mii)+' Max='+string(mxx)
         		win =win>.3
		endif
     endif

;****Care with multidetector distance
;    --------------------------------
     j1=0  &  j3=0  &  j4=nsp-1

     a =where(yin lt 9.)
     if a(0) ge 0 then begin n=n_elements(a)-1 & j2=a(n) & j3=j2+1 & endif

;****TO S(w,2*theta)
;****
     decad = decal * cwidth/252.781/wavel
     cwidts= cwidth*1e-6
     xgen  = findgen   (sizs(1))

     ee    =(1.05457*  2*!pi)^2 / (2*1.67493) / 1.602177 * 10     ;h^2 /2m /f(joules)
     eelast= ee     /  wavel ^2
     telast= dist   *  wavel /3956.				  ;3956=1e6/252.781
     fltime= telast - (s_elas-xgen)*cwidts
     lam   = fltime *  3956. /dist

     yout =sin(yin*!pi/180/2) *4*!pi / wavel

      if   (instv eq 'IN10') or (instv eq 'IN16') then begin
       if  (instv eq 'IN10') then t2efac= 1.234 else t2efac=1.036
       xgen =xgen+1
       xout =xgen*2.0*t2efac*doppl/max(xgen)
       xout =xout-0.5*max(xout)
      endif else begin

       xout  = eelast -  ee    /lam ^2

;****  F(E) EFFICIENCIES
;****
       eff  = fe_a *exp( fe_b /sqrt(eelast-xout)) * (1-exp( fe_c /sqrt(eelast-xout)))
       ef5  = f5_a *exp( f5_b /sqrt(eelast-xout)) * (1-exp( f5_c /sqrt(eelast-xout)))
       flti = 1
       if instv eq 'IN5' then begin
          j5=where(Yin le 63) & j5=j5(n_elements(j5)-1)
          for i=j1,j5 do begin
		    telas2  =(dist-decad(i))*  wavel /3956.
     		    flti    =(telas2   - (s_elas-xgen)*cwidts) ^4 * 1.0e6 / telas2 *10
		    			   win   (*,i)= win   (*,i) * flti  / ef5
		    			   ERRdat(*,i)= ERRdat(*,i) * flti  / ef5
		    if v_is*ires eq 1 then van   (*,i)= van   (*,i) * flti  / ef5
          endfor
          j1=j5+1
       endif
       for i=j1,j4 do begin
		    telas2  =(dist-decad(i))*  wavel /3956.
     		    flti    =(telas2   - (s_elas-xgen)*cwidts) ^4 * 1.0e6 / telas2 *10
		    			   win   (*,i)= win   (*,i) * flti  / eff
		    			   ERRdat(*,i)= ERRdat(*,i) * flti  / eff
		    if v_is*ires eq 1 then van   (*,i)= van   (*,i) * flti  / eff
       endfor
      endelse

;*****GROUP
;*****
      gp  =1
      if sizs(2) gt 80  then gp=gp+1
      if sizs(2) gt 160 then gp=gp+1
      nsp =nsp/gp
      tms =yin  &	     pho_groupy, nsp,win,yin ,ERRdat
      if v_is*ires eq 1 then pho_groupy, nsp,van,tms
      sizs=size (win)

;*****RESOLUTION FILTER
;*****
      if v_is*ires eq 1 then begin
      tmc=total(van,2)
      tmv=smooth(smooth(median(tmc,3),3),3)
     
	id1=s_elas & m=tmv(s_elas)
	while (id1 gt 0) and (tmv(id1-1) lt m) do begin m=tmv(id1) & id1=id1-1 & endwhile
	id2=s_elas & m=tmv(s_elas) & n=sizs(1)-1
	while (id2 lt n) and (tmv(id2+1) lt m) do begin m=tmv(id2) & id2=id2+1 & endwhile
	
	id =max([s_elas-id1   , id2-s_elas]  )
	tmc=tmc((s_elas-id)>0 :(s_elas+id)<n )
			;tmc=[0,tmc-min(tmc),0]
			; mx=tmc(s_elas) & tmc=smooth(median(tmc,3),3) & tmc(id+1)=mx
	tmc=tmc/total(tmc)
	tmc=tmc>1E-4
	tmc=tmc-1E-4

;      win(*,20)=diconv(win(*,20),tmc,/stat)
      help,tmc
      i=1 & if i then $
      for i=0,nsp-1 do begin print,i,nsp-1
	tms=win(*,i)
;	if ires eq 1 then tms=diconv(tms,tmc,/use,/filt) $
;	             else tms=diconv(tms,tmc,/use,/stat)
	win(*,i)=tms
      endfor
      endif
;*****
      rr=2 & win   = win   (rr:sizs(1)-rr-2,*)
	     ERRdat= ERRdat(rr:sizs(1)-rr-2,*)
	     xout  = xout  (rr:sizs(1)-rr-2,*)
      sizs  =size (win)
      s_elas=(s_elas-rr)>0
      van=0 & vid=0 & cav=0

;*****REVERSE X AXIS (NOT TREATED BY INX FORTRAN)
      P_MUS,'mus_shot'
      win   =reverse( win  )
      ERRdat=reverse(ERRdat)
      xout  =reverse(-xout)
      s_elas=sizs(1) -s_elas -1

;*****WHERE ALREADY IN ENERGIE !!
   endif else begin
      yout=yraw
      yin =asin(yout*wavel/4/!pi)*180*2/!pi
      win =rodata
      ytp =yin & rawe=yin*0+1 & vidp=rawe & pry=rawe & corre=reform(win(s_elas,*))
      exclu=[-1]
   endelse

;*****CALL THE GRAPHICAL SHOW
     if slab eq 1  then vidp=vecSt
     ott   =[one,second,vanadn,emptn,canva]
     wavel =[wavel,cwidth,dist,kelvin,kelvis,transs,transv,slab,tolow,ra1,ra2,$
	     ires ,igg   ,sangl]
     phowind, ytp,rawe,vidp,pry,corre, xout,yin,win, yraw,exclu ,s_elas,ott,wavel ,ERRdat

;****OUTPUT VARIABLES BACK TO LAMP
;****
     iii=execute('y'+wk1+'=yout'  )
     iii=execute('x'+wk1+'=xout'  )
     iii=execute('e'+wk1+'=ERRdat')
     iii=execute('n'+wk1+'=centm' )
     x_tit(one)= 'Energy Changes (meV)'
     y_tit(one)= 'Q elastic'

endif else begin mess='! Sample-Detector distance too small [P'+wk2+'(27)]'
		 widget_control,l_message,bad_id=i,set_value=mess & print,string(7b),mess & endelse
endif else begin mess='! Wave-lenght not defined [P'+wk2+'(21) or P'+wk2+'(2)]'
		 widget_control,l_message,bad_id=i,set_value=mess & print,string(7b),mess & endelse
endif else begin mess='! Workspaces have different sizes ...'
		 widget_control,l_message,bad_id=i,set_value=mess & print,string(7b),mess & endelse
return,win
end
Function difd20,wn1,wn2

; *** This function does a correct (?) difference w1-w2, even if
; *** dimension, twotheta range or normalisation do not fit in the beginning ...
; *** changed 18/09/2001 Peter Fischer, Thomas Hansen: error calculation ***

common C_LAMP_INFO 

IF N_ELEMENTS(wn2) GT 1 THEN BEGIN
  n2=three
ENDIF
IF N_ELEMENTS(wn1) GT 1 THEN BEGIN
  n1=two
ENDIF
IF N_ELEMENTS(wn1) EQ 1 THEN n1=wn1
IF N_ELEMENTS(wn2) EQ 1 THEN n2=wn2
IF N_ELEMENTS(n1) EQ 1 THEN BEGIN
IF N_ELEMENTS(n2) EQ 1 THEN BEGIN
take_w,w1,w=n1
take_w,w2,w=n2
;help,w1,w2
IF N_ELEMENTS(w1(0,*)) LE 1 THEN BEGIN
 IF N_ELEMENTS(w2(0,*)) LE 1 THEN BEGIN
  take_datp,d1,w=n1
  take_datp,d2,w=n2
  e1=d1.e
  e2=d2.e
  IF d1.n(0) NE d2.n(0) THEN BEGIN
    norm=(d1.n(0) + d2.n(0))/2.
    PRINT, 'Normalisation to ', norm, ' (before : ',d1.n(0), d2.n(0),')'
    w1=w1/d1.n(0)*norm
    e1=e1/d1.n(0)*norm
    w2=w2/d2.n(0)*norm
    e2=e2/d2.n(0)*norm
  ENDIF ELSE norm=d1.n(0)
  dx1=FLOOR(d1.x*10)/10.
  dx2=FLOOR(d2.x*10)/10.
  delta=((d1.x(0)+d2.x(0))-(dx1(0)+dx2(0)))/2
  x1=delta+dx1
  x2=delta+dx2
  i1=INTERPOL(w1,d1.x,x1)
  e1=INTERPOL(e1,d1.x,x1)
  i2=INTERPOL(w2,d2.x,x2)
  e2=INTERPOL(e2,d2.x,x2)
  dx1=ROUND(10.*dx1)
  dx2=ROUND(10.*dx2)
  start=min(dx1)<min(dx2)
  stop =max(dx1)>max(dx2)
  array=[dx1,dx2]
  array=array(SORT(array))
  array=array(UNIQ(array))
  x=FLOAT(array/10.)+delta
  points=N_ELEMENTS(array)
  w=FLTARR(points)
  e=FLTARR(points)
;plot,x1,w1
;oplot,x2,w2
  ff1=0
  ff2=0
  For i= 0,points-1 DO BEGIN
    f1=where(dx1 EQ array(i),c1)
    f2=where(dx2 EQ array(i),c2)
    f1=f1(0)
    f2=f2(0)
    IF c1 GT 0 THEN BEGIN
      IF c2 GT 0 THEN BEGIN
        w(i)=(i1(f1)-i2(f2))
        ;e(i)=e1(f1)+e2(f2) ; *** changed 18/09/2001 Peter Fischer, Thomas Hansen ***
        ;e(i)=w(i)/SQRT(i1(f1)^2/e1(f1)^2+i2(f2)^2/e2(f2)^2)
        e(i)=SQRT(e1(f1)^2+e2(f2)^2) ; *** changed 18/09/2001 Peter Fischer, Thomas Hansen ***
        ff1=[ff1,f1]
        ff2=[ff2,f2]
      ENDIF ELSE BEGIN
        w(i)=0
        e(i)=0
      ENDELSE
    ENDIF ELSE BEGIN
      w(i)=0
      e(i)=0
    ENDELSE  
  ENDFOR
  ff1=ff1(1:N_ELEMENTS(ff1)-1)
  ff2=ff2(1:N_ELEMENTS(ff2)-1)
;plot,x1(ff1),w1(ff1)
;oplot,x2(ff2),w2(ff2)
  d=d1
  index=where(w NE 0 AND e NE 0)
  x=x(index)
  w=w(index)
  e=e(index)
  mod_datp,d,'x',x
  mod_datp,d,'e',e
  d.n(0)=norm
  d.w_tit=d.w_tit+' - Dif. W'+STRCOMPRESS(n1,/RE)+'-W'+STRCOMPRESS(n2,/RE)
  give_datp,d
  RETURN,w
 ENDIF ELSE PRINT,'2nd WorkSpace should not be pluri-dimensional'
ENDIF ELSE PRINT,'1st WorkSpace should not be pluri-dimensional'
ENDIF ELSE PRINT,'2nd WorkSpace Number missing'
ENDIF ELSE PRINT,'WorkSpace Numbers missing'
END
FUNCTION divergence,dx,xmax,ddiv,divmax,dlam,lammax,ddelta,Deltamax,d,l,d2,l2,om,mos,dspac,takeoff,d3,l3,d4,l4,ds,ls,ld,lg,dsample,$
                    w1=w,x1=x,w2=w2,x2=x2,w3=w3,w4=w4a,ws=w5,wd=w6
;+
; NAME:
;	 DIVERGENCE
;
;	 <A HREF="divergence.pro">See source code!</A>
;
; PURPOSE:
;  Creates a workspace of illumination and divergence of e.g. a monochromator
;
; INPUTS:
;  Dx:       Spacial definition / mm
;  Xmax:     Beamwidth/2 / mm
;  Ddiv:     Divergence definition / degrees
;  Divmax:   Maximum positive divergence / degrees
;  Dlam:     Wavelength definition / Angstroem
;  Lammax:   Maximum positive delta(lambda) / Angstroem
;  Ddelta:   Deviation definition / degrees
;  Deltamax: Maximum positive deviation by monochromator / degrees
;  D:        Width of illuminating source
;  L:        Distance from illuminator to slits in front of the monochromator / mm
;  D2:       Width slit in front of monochromator / mm
;  L2:       Distance from illuminating source to center of the illuminated monochromator / mm
;  Om:       Angle of monochromator to axis normal (transmission: takeoff/2, reflection: (takeoff/2)-90 deg)
;  Mos:      Mosaic of monochromator (degrees)
;  Dspac:    d-spacing of monochromator / Angstroem
;  Takeoff:  Takeoff angle
;  D3:       Width of slits after monochromator / mm
;  L3:       Distance from monochromator to first secondary slit (monochromator) / mm
;  D4:       Width of slits before sample / mm
;  L4:       Distance from monochromator to second secondary slit (sample) / mm
;  Ds:       Diameter of sample / mm
;  Ls:       Distance from monochromator to sample center / mm
;  Ld:       Distance from sample center to detector entrance / mm
;  Lg:       Distance from detector entrance to microstrip detection plate (detection gap) / mm
;  Dsample:  d-spacing of Bragg reflection of sample / Angstroem
;
; KEYWORDS (OPTIONAL FOR OUTPUT):
;  W1:       Beam arrived at slit before monochromator
;  X1:       Beam arrived at slit before monochromator : position
;  W2:       Beam arrived at monochromator
;  X2:       Beam arrived at monochromator : position
;  W3:       Beam arrived at slit after monochromator
;  W4:       Beam arrived at slit before sample
;  Ws:       Beam arrived at cylindrical sample
;  Wd:       Beam arrived at detector entrance window
;
; PROJECTS:
;  second set of slits between source and monochromator
;  wavelength distribution
;  monochromator penetration
;  incident neutron spectrum
;  for-next-loops in c
;
; MODIFICATION HISTORY:
;  Written by: Thomas Hansen, May 1998.
;  June, 1998 Documentation, wavelength distribution, slits, sample to detector.
;
;-

ddelta=Dlam/Lammax*Deltamax 
PRINT,Dx,      " = Dx:       Spacial definition / mm"
PRINT,Xmax,    " = Xmax:     Beamwidth/2 / mm"
PRINT,Ddiv,    " = Ddiv:     Divergence definition / degrees"
PRINT,Divmax,  " = Divmax:   Maximum positive divergence / degrees"
PRINT,Dlam,    " = Dlam:     Wavelength definition / Angstroem"
PRINT,Lammax,  " = Lammax:   Maximum positive delta(lambda) / Angstroem"
PRINT,Ddelta,  " = Ddelta:   Deviation definition / degrees"
PRINT,Deltamax," = Deltamax: Maximum positive deviation by monochromator / degrees"
PRINT,D,       " = D:        Width of illuminating source"
PRINT,L,       " = L:        Distance from illuminator to slits in front of the monochromator / mm"
PRINT,D2,      " = D2:       Width slit in front of monochromator / mm"
PRINT,L2,      " = L2:       Distance from illuminating source to center of the illuminated monochromator / mm"
PRINT,Om,      " = Om:       Angle of monochromator to axis normal (transmission: takeoff/2, reflection: (takeoff/2)-90 deg)"
PRINT,Mos,     " = Mos:      Mosaic of monochromator (degrees)"
PRINT,Dspac,   " = Dspac:    d-spacing of monochromator / Angstroem"
PRINT,Takeoff, " = Takeoff:  Takeoff angle"
PRINT,D3,      " = D3:       Width of slits after monochromator / mm"
PRINT,L3,      " = L3:       Distance from monochromator to first secondary slit (monochromator) / mm"
PRINT,D4,      " = D4:       Width of slits before sample / mm"
PRINT,L4,      " = L4:       Distance from monochromator to second secondary slit (sample) / mm"
PRINT,Ds,      " = Ds:       Diameter of sample / mm"
PRINT,Ls,      " = Ls:       Distance from monochromator to sample center / mm"
PRINT,Ld,      " = Ld:       Distance from sample center to detector entrance / mm"
PRINT,Lg,      " = Lg:       Distance from detector entrance to microstrip detection plate (detection gap) / mm"
PRINT,Dsample, " = Dsample:  d-spacing of Bragg reflection of sample / Angstroem"
; The source: all wavelengths and divergences are equally distributed
take_datp,datp
x = FINDGEN (ROUND (2 * Xmax   / Dx  )) * Dx   - Xmax
y = FINDGEN (ROUND (2 * Divmax / Ddiv)) * Ddiv - Divmax
w = FLTARR(N_ELEMENTS(X),N_ELEMENTS(Y))
j=indgen(N_ELEMENTS(x))
FOR i=0,N_ELEMENTS(y)-1 DO BEGIN
  k=(x(j) GE l*tan(!pi/180.*( y(i)))-d/2 AND x(j) LE l*tan(!pi/180.*( y(i)))+d/2 AND x(j) GE -d2/2 AND x(j) LE  d2/2)
  w(j,i) = cos(y(i)*!PI/180.)*k(j)
ENDFOR
PRINT,'Beam profile at slits before monochromator (w1)'
x1=x

; Now we are at the slits of max(x)-min(x) at the distance l from the source ...
w2=w*0
x2=x/cos(om*!PI/180.)
y2=x*tan(om*!PI/180.)
maxj=N_ELEMENTS(x)-1
maxi=N_ELEMENTS(y)-1
FOR i=0,maxi DO BEGIN
  jj= ROUND(((x2(*)-((l2-l)+y2(*))*tan(( y(i))*!PI/180.))+Xmax)/Dx)
  w2(j,i) = w2(j,i)+cos(y(i)*!PI/180.)*w((jj>0)<maxj,i)*cos(om*!PI/180.)*(jj GE 0 AND jj LE maxj)
ENDFOR
PRINT,'Beam profile on monochromator (w2)'

; Now we are at the monochromator - its mosaic will change divergence and wavelength ...
; ATTENTION : Up to now the monochromator has a penetration depth of 0!
; ATTENTION : Up to now no FANKUCHEN effect!
x=x2*cos((takeoff-om)*!PI/180.)
y2=x2*sin((takeoff-om)*!PI/180.)
lam = 2.*dspac * sin (takeoff/2. * !pi / 180.)
PRINT,"Wavelength",lam
z = FINDGEN (ROUND (2 * Lammax / Dlam)) * Dlam - Lammax + lam
w3=fltarr(N_ELEMENTS(x),N_ELEMENTS(y),N_ELEMENTS(z))
int = 1.
pik = int*2./mos*sqrt(alog(2)/!pi)
sig = mos/(2.*sqrt(2.*alog(2.)))
gau = GAUSS(y,[pik,0,sig])
delta=FINDGEN (ROUND (2 * Deltamax / Ddelta)) * Ddelta - Deltamax 
maxk=N_ELEMENTS(z)-1
kk= ROUND((2.*dspac*sin((takeoff/2.-delta(*))*!pi/180.)-lam+lammax)/dlam)
FOR k=0,N_ELEMENTS(delta)-1 DO BEGIN      ; fuer Ablenkungen delta
  y3=y+delta(k)
  ;sumk=TOTAL(w3)
; ii= ROUND(((y(*))-delta(k)+DivMax)/DDiv)
  ii= ROUND((y3(*)+DivMax)/DDiv)
  iii= ROUND((-y(*)+delta(k)/2.+DivMax)/DDiv)
  FOR i=0,maxi DO BEGIN    ; resulting divergence
;   jj= ROUND(((x2(*)-((l2-l)+y2(*))*tan(( y (i))*!PI/180.)                           )+Xmax)/Dx)
;   jj= ROUND(((x (*)-( l3   -y2(*))*tan(( y3(i))*!PI/180.))/cos((takeoff-om)*!PI/180.)+Xmax)/Dx)  ; cosinus ?
    jj= ROUND(((x (*)-( l3   +y2(*))*tan(( y3(i))*!PI/180.)                           )+Xmax)/Dx)  
    help=(jj GE 0 AND jj LE maxj AND kk(k) GE 0 AND kk(k) LE maxk AND ii(i) GE 0 AND ii(i) LE maxi AND iii(i) GE 0 AND iii(i) LE maxi)
    w3(*,(ii(i)>0)<maxi,(kk(k)>0)<maxk) = w3(*,(ii(i)>0)<maxi,(kk(k)>0)<maxk)+cos((takeoff-om-y3(i))*!PI/180.)*w2((jj>0)<maxj,i)*GAU((iii(i)>0)<maxi)*help
  ENDFOR
  ;PRINT,'step',k,':',TOTAL(w3)-sumk,' counts at',delta(k),'deg beam deviation'
ENDFOR
jj=WHERE(x le -d3/2 OR x ge d3/2,count)
jj=(jj>0)<maxj
w3(jj,*,*)=(count LE 0)*w3(jj,*,*)
PRINT,'Beam profile a(f)t(er) monochromator slits (w3)'

; Now are at the first set of slits behind the monochromator, performing secondary collimation
; The next slit will just reduce the background at the sample
w4=w3*0.
FOR k=0,maxk DO BEGIN      ; for different wavelengths
  FOR i=0,maxi DO BEGIN    ; for different divergences
    jj= ROUND(((x(*)-(l4-l3)*tan(( y(i))*!PI/180.))+Xmax)/Dx)
    w4((jj>0)<maxj,i,k) = w4((jj>0)<maxj,i,k)+cos(y(i)*!PI/180.)*w3((jj>0)<maxj,i,k)*(jj GE 0 AND jj LE maxj)
  ENDFOR
ENDFOR
jj=WHERE(x le -d4/2 OR x ge d4/2,count)
jj=(jj>0)<maxj
w4(jj,*,*)=(count LE 0)*w4(jj,*,*)
PRINT,'Beam profile at sample slits (w4)'
w4a=w4

; Here we are at the cylindrical sample ...
; It has a certain scattering power, incoherent scattering and absorption ...
; Different wavelength will be diffracted to different directions ...
; Start with a single point in the center of the sample (x=0)
; The reference is x=0, y=0 (div.) and z=lam
;
jj=WHERE(x le -ds/2 OR x ge ds/2,count)   ; limitation to sample diameter
jj=(jj>0)<maxj
w4(jj,*,*)=(count LE 0)*w4(jj,*,*)
;
; ^ This has to be changed afterwards ^ ... (above)
;
w5=w4*0.
theta= ASIN(lam/dsample/2.)/!pi*180.
PRINT,'twotheta',theta*2.
; diffraction angle deviation from right angle
delta = 2. * (ASIN(z/dsample/2.)/!pi*180. - theta)
FOR k=0,maxk DO BEGIN      ; for different wavelengths
  ; The divergence will change depending on wavelength
  yy = y + delta(k)
  ii= ROUND((yy(*)+DivMax)/DDiv)
  FOR i=0,maxi DO BEGIN    ; for different divergences
    ;PRINT,k,delta(k),i,y(i),yy(i),ii(i)
    jj= ROUND(((x(*)*SIN((yy(i)+2*theta)/180.*!PI)-(ls-l4)*tan(( y(i))*!PI/180.))+Xmax)/Dx)
    w5((jj>0)<maxj,(ii(i)>0)<maxi,k) = w5((jj>0)<maxj,(ii(i)>0)<maxi,k)+cos(y(i)*!PI/180.)*w4((jj>0)<maxj,i,k)*(jj GE 0 AND jj LE maxj)*(ii(i) GE 0 AND ii(i) LE maxi)
   ;
   ; to be implemented :
   ; At x=0 scattering from -r to +r, at -/+r scattering only at x, at >+r/<-r nothing!
   ;
  ENDFOR
ENDFOR
PRINT,'Beam profile a(f)t(er) sample'

; The next step is the entrance to the detector
; There's some Aluminium scattering (wing effect) depending on wavelength etc.
;
; #####################################################################################################################
; # CHECK: A certain divergence at the sample should result in the same divergence on the PSD: D20: 0.1 deg = 2.5 mm! # 
; #####################################################################################################################
;
;
w6=w5*0.
FOR k=0,maxk DO BEGIN      ; for different wavelengths
  FOR i=0,maxi DO BEGIN    ; for different divergences
    jj= ROUND(((x(*)-(ld*tan(( y(i))	*!PI/180.)))+Xmax)/Dx)
    w6((jj>0)<maxj,i,k) = w6((jj>0)<maxj,i,k)+cos(y(i)*!PI/180.)*w5((jj>0)<maxj,i,k)*(jj GE 0 AND jj LE maxj)
  ENDFOR
ENDFOR
PRINT,'Beam profile at PSD'

; The next step is the capture reaction somewhere in the detection gap depending on wavelength 
; a T-p-trace will create an electron avalanche of a certain length

; Finally these electrons will be amplified and detected at the microstrip electrodes
; Only the cell receiving the maximum of electrons will count ...

mod_datp,datp,'x',x
mod_datp,datp,'y',y
mod_datp,datp,'z',z
give_datp,datp
RETURN,w6
end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION divide, w_in1, w_in2

; Divides two workspaces with correct error propogation (any dimension)
;
;COMMAND SYNTAX
; w3=divide(w1,w2)
;
;						KHA, 6/11/97
;-------------------------------------------------------------------------------
;*******************************************************************************

	take_datp, dat1
	take_datp, dat2, /third

	e_in1=dat1.e
	e_in2=dat2.e

	zero=WHERE(w_in2 EQ 0.,nz)
	zeroed1=WHERE(e_in1 LT -0.9,nz1)
	zeroed2=WHERE(e_in2 LT -0.9,nz2)

	w_out=w_in1/w_in2
	e_out=SQRT((e_in1/w_in2)^2+(w_in1*e_in2/w_in2^2)^2)

	IF (nz NE 0) THEN BEGIN
		w_out(zero)=0.
		e_out(zero)=-1.
	ENDIF
	IF (nz1 NE 0) THEN BEGIN
		w_out(zeroed1)=0.
		e_out(zeroed1)=-1.
	ENDIF
	IF (nz2 NE 0) THEN BEGIN
		w_out(zeroed2)=0.
		e_out(zeroed2)=-1.
	ENDIF

	datp=dat1

	mod_datp, datp, "e", e_out

	give_datp, datp

	RETURN, w_out
	END
pro do_apple_script, script, as_script=as, result=res
;** ***************
res=''
end
; **************************************************************************
; ** docount macro	Version 1.2.1b					  **
; ** -------------							  **
; ** Mark McCrum 3/8/00							  **
; **									  **
; ** Uses: time.pro time library					  **
; **	   dial_mad_send (Standard GEORGE / MAD interface)	       	  **
; **									  **
; **									  **
; **									  **
; **									  **
; ** New Features: Initial configuration can now be passed as a parameter **
; **									  **
; **		   Actual configuration is returned as well as the system **
; **		   time at the start of scan (-1 if scan was cancelled    **
; **									  **
; **		   Duration is now duration per scan position rather than **
; **		   duration of entire scan. It is believed that this will **
; **		   prove more convenient to the user.			  **
; **									  **
; **		   Durations may now be entered in hours minutes and	  **
; **		   seconds.						  **
; **									  **
; **		  Corrected bug: Output window after count initiated      **
; **				 always assumed duration was in units     **
; **				 of time. This would result in            **
; **				 nonsensical output if duration was in    **
; **				 counts					  **	
; **									  **
; ** MODIFIED 4/8/00: Added NO_RELEASE keyword to unitbuttons BGROUP	  **
; **		      This is necessary to prevent screen update problems **
; **		      under IDL 5.1. It should be removed for earlier     **
; **		      versions						  **
; **									  **
; **		      Minor layout change. (addition of scanFieldBase)	  **
; **									  **
; **		      Removed dialog box informing that scan has started  **
; **		      pending replacement by a non modal version. This is **
; **		      so the stats program can start monitoring a count   **
; **		      as soon as it starts				  **
; **									  **
; ** Known problems:	Help is out of date				  **
; **									  **
; **									  **
; **************************************************************************
; **									  **
; ** This macro provides a graphical interface for setting up		  **
; ** Scans and Counts on D7. The appropriate parameters are gathered	  **
; ** validated then sent to MAD in the appropriate format		  **
; **									  **
; ** This version (b) is designed to be launched from a GEORGE PAD        **
; ** and includes a dialog box explaining that the count has been         **
; ** launched, how long it will last, and when it will finish		  **
; **									  **
; **************************************************************************



FUNCTION calcNumSteps, scanFrom, scanTo, scanBy		;Calculate the number 
;**********************************************		;of steps in a scan with
							;the given parameters

	IF scanBy NE 0 THEN RETURN,round(((scanTo-scanFrom)/scanBy))+1
	RETURN, 0
END




PRO Count_event, event		;This is the top level event handler. All widgets
;**********************		;have event handlers except for the fields as IDL 
				;does not appear to have any facility to give them
				;one. Therefore events for the fields are handled 
				;here
	
	;Variables in 'countConstants' wil be used as constants by various
	;procdures and functions. They are set up in the docount procedure
	;(below)

	COMMON countConstants, NOSCAN, THETASCAN, OMEGASCAN, ROTATIONSCAN, $
			       NOPOL, ZPOL, XYZPOL, MONITORUNIT, TIMEUNIT

	
	FORWARD_FUNCTION sec2time	;Forward function definions for the
	FORWARD_FUNCTION now		;time library (there is probably a 
	FORWARD_FUNCTION addTime	;better way of doing this)
	FORWARD_FUNCTION timeAfter
	FORWARD_FUNCTION time2string
	


	 ;A common block is used to allow procedures easy access to the widgets
	 ;that make up the interface and the 'state' of the application. This
	 ;method was used as it is far easier than holding the state in the uvalue
	 ;of some widget. Using a common block means that only one copy of the
	 ;application can run at a time, but it would not be desirable to run
	 ;more than one anyway

	COMMON countCom, po,duration, unit, repeats, save, title, ratio,$
                          scan, from, to, step, saveButton, scanButtons,$
			  scanFromField, scanToField, scanStepField,    $
			  polButtons, countRatioField, repeatField,     $
			  countsField, hoursField, minsField, secsField,$
			  unitsButtons, scanButtonID, polButtonID,      $
			  unitButtonID, okButton, cancelButton,		$
			  helpButton, titleField, scanNumStepsField,	$
			  numSteps, timeInputBase, startTime ;***ADDITION **


	

	 ;Here we process events for  totalTimeField and repeatField, 
	 ;ensuring that the contents of the fields 
	 ;remain positive. NB this method isn't foolproof so we must 
	 ;still validate elsewhere

	 ;NB need 2 if statements because IDL does not appear to support lazy
	 ;evaluation and not all widgets have a numeric value field.
	
	IF event.ID EQ countsField OR event.ID EQ hoursField OR event.ID EQ minsField $
	   OR event.ID EQ secsField OR event.ID EQ repeatField THEN IF event.Value<0 THEN $
				WIDGET_CONTROL, event.ID, SET_VALUE=-event.Value

	IF event.ID EQ minsField OR event.ID EQ secsField THEN IF event.Value GE 60 THEN $
				WIDGET_CONTROl, event.ID, SET_VALUE=0

	
	
	;Update the numSteps field 
	
	IF (scan EQ OMEGASCAN OR scan EQ ROTATIONSCAN) AND $
	   (event.ID EQ scanFromField OR event.ID EQ scanToField $
	   OR event.ID EQ scanStepField) THEN BEGIN
		
		WIDGET_CONTROL, scanFromField, GET_VALUE=from
		WIDGET_CONTROL, scanToField, GET_VALUE=to
		WIDGET_CONTROL, scanStepField, GET_VALUE=step

		numSteps=calcNumSteps(from, to, step)
		WIDGET_CONTROL, scanNumStepsField, SET_VALUE=numSteps 
	ENDIF


END

PRO get2thetaParams	;Read the 2theta scan parameters from MAD and update
;******************	;the Scan From, To and By fields appropriately

	COMMON countConstants
	COMMON countCom
	params=DIAL_MAD_READ('t_para')
	from=params.bank1(0)
	to=params.bank1(1)
	step=params.bank1(2)
	numSteps=calcNumSteps(from, to, step)
	
	WIDGET_CONTROL, scanFromField, SET_VALUE=from
	WIDGET_CONTROL, scanToField, SET_VALUE=to
	WIDGET_CONTROL, scanStepField, SET_VALUE=step
	WIDGET_CONTROL, scanNumStepsField, SET_VALUE=numSteps
	


END



PRO setDefaults, defaults	; This procedure sets the initial, default,
				; parameter values and sets the interface widgets
			        ; to reflect this
	
	COMMON countCom
	COMMON countConstants


	;do some initialisation
	 countsField=0
	 hoursField=0
	 minsField=0
	 secsField=0
	 startTime=0


	 ;set variables	


	IF (SIZE(defaults))(0) EQ 0 THEN BEGIN
		title=''	;Title to give the scan
		po=NOPOL	;Polarisation
		duration=0L	;Total length of measurement
		unit='t'	;Is the above in counts (m) or seconds (t)?
		repeats=1	;Number of times to do each measurement	
		save=1		;1= save, 0 = don't save results
		ratio=1		;Flip / non-flip count ratio
		scan=NOSCAN	;Type of Scan to perform
		from=0.		;Start scan position
		to=0.		;End scan position
		step=0.		;Step amount
		numSteps=0	;No. of steps in the scan
	END ELSE BEGIN
		title=defaults.title
	
		
		CASE defaults.scan OF
			'2theta': scan=THETASCAN	
			'rotation': scan=ROTATIONSCAN
			'omega':  scan=OMEGASCAN
			ELSE: 	  scan=NOSCAN
		ENDCASE

		CASE defaults.po OF
			'NOP': po=NOPOL
			'ZP': po=ZPOL
			'XYZP': po=XYZPOL
			ELSE: po=NOPOL
		ENDCASE


		duration=defaults.duration
		IF defaults.unit EQ 'm' OR defaults.unit EQ 't' THEN $  
		      unit=defaults.unit $
		ELSE $
      			unit='t'


		repeats=defaults.repeats
		save=defaults.save
		ratio=defaults.ratio
		from=defaults.from
		to=defaults.to
		step=defaults.step
		numSteps=calcNumSteps(from, to, step)
				
	END



	 ;Set controls to match

	WIDGET_CONTROL, titleField, SET_VALUE=title
	
	IF save EQ 1 THEN $
		WIDGET_CONTROL, saveButton, /SET_BUTTON $
	ELSE $
		WIDGET_CONTROL, saveButton, SET_BUTTON=0

	WIDGET_CONTROL, scanFromField, SET_VALUE=from
	WIDGET_CONTROL, scanToField, SET_VALUE=to
	WIDGET_CONTROL, scanStepField, SET_VALUE=step
	WIDGET_CONTROL, scanNumStepsField, SET_VALUE=numSteps
	WIDGET_CONTROL, countRatioField, SET_VALUE=ratio
	WIDGET_CONTROL, repeatField, SET_VALUE=repeats
		

	IF unit EQ 'm' THEN BEGIN
		enableMonitorUnits
		WIDGET_CONTROL, countsField, SET_VALUE=duration
		WIDGET_CONTROL, unitButtonID(1), /SET_BUTTON
	END ELSE BEGIN
		enableTimeUnits
		hours=FIX(duration/3600)
		mins=FIX((duration MOD 3600) / 60)
		secs=FIX(duration MOD 3600)MOD 60
		WIDGET_CONTROL, hoursField, SET_VALUE=hours
		WIDGET_CONTROL, secsField, SET_VALUE=secs	
		WIDGET_CONTROL, minsField, SET_VALUE=mins
		WIDGET_CONTROL, unitButtonID(0), /SET_BUTTON
	END

	CASE scan OF
		NOSCAN: BEGIN
				WIDGET_CONTROL, scanButtonID(0), /SET_BUTTON
				disableScan
			END

		THETASCAN: BEGIN
				WIDGET_CONTROL, scanButtonID(1), /SET_BUTTON
				enableThetaScan
			   END
		OMEGASCAN: BEGIN
				WIDGET_CONTROL, scanButtonID(2), /SET_BUTTON
				enableScan
			   END

		ROTATIONSCAN: BEGIN
				WIDGET_CONTROL, scanButtonID(3), /SET_BUTTON
				enableScan
			      END
	ENDCASE


	CASE po OF
		NOPOL: 	BEGIN
				WIDGET_CONTROL, polButtonID(0), /SET_BUTTON
				disableRatio
			END		

		ZPOL:	BEGIN	
				WIDGET_CONTROL, polButtonID(1), /SET_BUTTON
				enableRatio
			END

		XYZPOL:	BEGIN
				WIDGET_CONTROL, polButtonID(2), /SET_BUTTON
				enableRatio
			END
	ENDCASE
	

	

END

PRO disableScan	;This procedure disables the Scan parameter input fields.
;**************	;This is done if the user selects the 'None' 
		;scan option
	COMMON countCom
	WIDGET_CONTROL, scanFromField, SENSITIVE=0
	WIDGET_CONTROL, scanToField,  SENSITIVE=0
	WIDGET_CONTROL, scanStepField, SENSITIVE=0
	WIDGET_CONTROL, scanNumStepsField, SENSITIVE=0
END 

PRO disableRatio ;This procedure disables the Flip / non-flip ratio field.
;*************** ;Called when the user selects the 'None' polarisation 
		 ;analysis option

	COMMON countCom
	WIDGET_CONTROL, countRatioField, SENSITIVE=0
END

PRO enableScan	;enable scan parameter input. 
;*************	;This is done for Omega and Rotation scans.
		;Theta scan parameters are read directly
		;from MAD
	COMMON countCom
	WIDGET_CONTROL, scanFromField, /SENSITIVE, /EDITABLE
	WIDGET_CONTROL, scanToField, /SENSITIVE, /EDITABLE
	WIDGET_CONTROL, scanStepField, /SENSITIVE, /EDITABLE

         ;Reset the scanNumStepsField to the correct value

	numSteps=calcNumSteps(from,to,step)
	WIDGET_CONTROL, scanNumStepsField, SET_VALUE=numSteps,$
			/SENSITIVE
	
END 	


PRO enableThetaScan	;update scan parameter fields but 
;******************	;don't allow input. Values for the 
			;fields are read from the MAD 2theta
			;parameters

	COMMON countCom
	WIDGET_CONTROL, scanFromField, SENSITIVE=0
	WIDGET_CONTROL, scanToField, SENSITIVE=0
	WIDGET_CONTROL, scanStepField, SENSITIVE=0
	WIDGET_CONTROL, scanNumStepsField, /SENSITIVE
	get2thetaParams ;read MAD parameters into the fields	
END

PRO enableRatio ;re-enable flip / non flip ratio parameter input 
;**************
	COMMON countCom
	WIDGET_CONTROL, countRatioField, /SENSITIVE
END

FUNCTION scanButtons_event, event	; Event handler for the scan selection
;********************************	; button group
	COMMON countCom
	COMMON countConstants

	scan=event.VALUE		;scan should contain current scan selection
	
	;Disable or enable scan parameter fields as appropriate
 	
	CASE scan OF
		THETASCAN: enableThetaScan
		NOSCAN: disableScan
		ELSE: enableScan
	ENDCASE
	
		
END


PRO enableMonitorUnits
	COMMON countCom
	COMMON countConstants

	WIDGET_CONTROL, timeInputBase, UPDATE=0
	countsField=CW_FIELD(timeInputBase, /LONG, $
			     TITLE='Duration: ', XSIZE=6, /ALL_EVENTS, $
				    UVALUE='countsField', VALUE=0)

	WIDGET_CONTROL, hoursField, BAD_ID=rubbish,  /DESTROY
	WIDGET_CONTROL, minsField, BAD_ID=rubbish, /DESTROY
	WIDGET_CONTROL, secsField, BAD_ID=rubbish, /DESTROY
	WIDGET_CONTROL, timeInputBase, BAD_ID=rubbish,/UPDATE	

	unit='m'
END

PRO enableTimeUnits
	COMMON countCom
	COMMON countConstants


	WIDGET_CONTROL, timeInputBase, UPDATE=0	
	hoursField=CW_FIELD(timeInputBase, /LONG, $
			    TITLE='Hours: ', XSIZE=4, /ALL_EVENTS, $
			    UVALUE='hoursField', VALUE=0)

	minsField=CW_FIELD(timeInputBase, /LONG, $
			   TITLE='Mins: ', XSIZE=2, /ALL_EVENTS, $
			   UVALUE='minsField', VALUE=0)
	
	secsField=CW_FIELD(timeInputBase, /LONG, $
			   TITLE='Secs: ', XSIZE=2, /ALL_EVENTS, $
			   UVALUE='secsField', VALUE=0)

	WIDGET_CONTROL, countsField, BAD_ID=rubbish, /DESTROY
	WIDGET_CONTROL, timeInputBase, /UPDATE

	unit='t'
END

FUNCTION polButtons_event, event	; Event handler for the polarisation analysis
;*******************************	; selection button group
	COMMON countCom
	COMMON countConstants	

	po=event.VALUE			;po should contain current polarisation
					;analysis selection.

	;Disbale or enable flip / non flip parameter field as appropriate
	if po EQ NOPOL THEN disableRatio ELSE enableRatio
END

FUNCTION unitButtons_event, event	; Event handler for the unit selection
;********************************	; button group. (used to set the 't' or 'm'
					; keywords for the mad 'co' command)

	COMMON countCom
	COMMON countConstants

	if event.VALUE eq MONITORUNIT THEN BEGIN
		enableMonitorUnits
	END ELSE BEGIN
		enableTimeUnits
	END
		
END

FUNCTION saveButton_event, event	; Event handler for the save / nosave
;*******************************	; button
	COMMON countCom
	save=1-save
END





FUNCTION okButton_event, event		; Event handler for the OK button. This
;*****************************		; function validates the scan and count
					; parameters, calculates appropriate
					; presets, and generates the appropriate
					; MAD commands

	MaxPresetB=300	;Range of acceptable preset_B values
	MinPresetB=150

	COMMON countCom
	COMMON countConstants	
	
	 ;Retrieve widget values

	WIDGET_CONTROL, repeatField, GET_VALUE=repeats


	IF unit EQ 'm' THEN $
		WIDGET_CONTROL, countsField, GET_VALUE=duration $
	ELSE BEGIN
		WIDGET_CONTROL, hoursField, GET_VALUE=hours
		WIDGET_CONTROL, minsField, GET_VALUE=mins
		WIDGET_CONTROL, secsField, GET_VALUE=secs

		duration=secs+60*mins + 3600 * hours
	END

	WIDGET_CONTROL, countRatioField, GET_VALUE=ratio

	WIDGET_CONTROL, scanFromField, GET_VALUE=from
	WIDGET_CONTROL, scanToField, GET_VALUE=to
	WIDGET_CONTROL, scanStepField, GET_VALUE=step
	WIDGET_CONTROL, scanNumStepsField, GET_VALUE=numSteps
	
	WIDGET_CONTROL, titleField, GET_VALUE=title
	If save THEN savetxt='save' ELSE savetxt='nosave'
	
	

   	 ;process polarisation analysis setting
	CASE po OF
		NOPOL:poltxt=' co nopo ' 
		ZPOL:poltxt=' co zpo '
		XYZPOL:poltxt=' co xyzpo '
		ELSE:BEGIN
		      PRINT, "ERROR! Invalid polarisation setting" 
		      RETURN, 0
		     END
	ENDCASE

	 ;process scan setting
	CASE scan OF
		NOSCAN: scantxt='' 
		THETASCAN: scantxt=' scan 2theta '
		OMEGASCAN: scantxt=' scan omega '
		ROTATIONSCAN: scantxt=' scan rotation '		
		ELSE: BEGIN
			PRINT, "ERROR! Invalid scan setting"
			RETURN, 0
		      END
	ENDCASE

	 ;Validate count duration
	IF duration LE 0 THEN BEGIN
		dummy=WIDGET_MESSAGE('Duration of count must be > 0', /ERROR)
		RETURN, 0
	END
	
	 ;Validate repeats
	IF repeats LT 1 THEN BEGIN
		dummy=WIDGET_MESSAGE('Repeats must be >= 1', /ERROR)
		RETURN, 0
	END
	

	 ;Validate scan parameters
	IF scan NE NOSCAN AND scan NE THETASCAN THEN BEGIN
		
		 ;Check for zero step size
		IF step EQ 0 THEN BEGIN
		 	dummy=WIDGET_MESSAGE('Scan step size must be non zero',/ERROR)
			RETURN, 0
		END

		 ;Check to ensure step is in correct direction
		IF ((to-from)/step) LT 0 THEN BEGIN
		   dummy=WIDGET_MESSAGE('Scan step is in wrong direction', /ERROR)
			   RETURN, 0
	        END
		
		 ;ensure that numSteps contains the correct value. (It should already,
		 ;this is just to double-check)

		numSteps=calcNumSteps(from,to,step)

		;Add the scan paramters to the scan command string
		scantxt=scantxt+STRING(from) + ' '+STRING(to) +' '+ STRING(step)+' '
	ENDIF $
        ELSE IF scan EQ THETASCAN THEN BEGIN
		;Check number of steps
		IF numSteps LE 0 THEN BEGIN
			dummy=WIDGET_MESSAGE('Number of scan steps must be > 0', /ERROR)
			RETURN, 0
		END	
	ENDIF

	
	
	 ;If we are not scanning, then we set numSteps to one so that newDuration
	 ; is calculated correctly. (see below)
	
	IF scan EQ NOSCAN THEN numSteps=1
 
	 ;Calculate preset time. 
	 ;This is calculated such that the Duration field will contain
	 ;the total time for the entire scan / count.
	 ;
	 ;We also recalculate the duration based on our new preset to 
	 ;account for rounding. 
	
	
	CASE po OF
		NOPOL: BEGIN
			preset=ROUND(FLOAT(duration)/repeats)
			newDuration=preset*repeats
		       END

		ZPOL: BEGIN
			preset=ROUND(FLOAT(duration)/((ratio+1.)*repeats))
			newDuration=LONG(preset*((ratio+1.)*repeats))
		      END

		XYZPOL: BEGIN
		          preset=ROUND(FLOAT(duration)/(4.*repeats*(ratio+1.)))
			  newDuration=LONG(preset*(4*repeats*(ratio+1.)))
			END
	ENDCASE
	

	 ;Now we check for rounding errors. If such errors exist we present the user
	 ;with a recalculated total duration for the scan and ask him whether to
	 ;proceed with the new value

	IF duration NE newDuration THEN BEGIN
	   IF unit EQ 't' THEN BEGIN
		temp=sec2Time(newDuration)
		newText=STRING(temp(0))+'days'+STRING(temp(1))+'hrs'+$ 
			    STRING(temp(2))+'mins' +STRING(temp(3))+'secs'
	   END ELSE newText=STRING(newDuration)

	   IF WIDGET_MESSAGE(['The duration you entered cannot be reconciled with', $
			      'the repeat, flip non-flip ratio and scan parameters',$
			      'The closest duration is: '+newText, 		    $
			      'Proceed with this new duration?'], /QUESTION) EQ 'No'$
		THEN RETURN, 0
	END
	duration=newDuration




	 ;calculate preset_b. 
	 ;	            preset must be an integer multiple of 
	 ; preset_b. The procedure will attempt to find a suitable
	 ; preset_b number in the range MinPresetB to MaxPresetB.
	 ; If the calculated preset time is < MinPresetB then we
	 ; set preset_b = preset.
	 ;
	 ; NB for some preset values a suitable preset_b may not 
	 ; exist. Care should therefore be taken when specifying
	 ; the total duration.

	preset_b=-1
	IF preset LT MinPresetB  THEN preset_b=preset ELSE $
		FOR i=MaxPresetB, MinPresetB, -1 DO IF (preset MOD i) EQ 0 THEN $
								preset_b=i
	
	IF preset_b EQ -1 THEN BEGIN
		dummy=WIDGET_MESSAGE('No acceptable preset_b value exists. ' + $
			       'please try another duration', /ERROR)
		RETURN, 0
	END

	;build MAD commands

	ratstr=STRTRIM(STRING(ratio),2)
AS0:	n=STRLEN(ratstr)	& i=RSTRPOS(ratstr,'0')
	IF (i EQ n-1) THEN BEGIN
		ratstr=STRMID(ratstr,0,n-1)
		GOTO, AS0
        ENDIF		

	IF po EQ ZPOL THEN $
		madCommand='par preset_z '+ratstr $
	ELSE IF po EQ XYZPOL THEN  $
		madCommand='par preset_xyz '+ratstr 
	
	
	if po EQ NOPOL THEN $
		madCommand='par preset_b '+STRING(preset_b) $
	ELSE $
		madCommand=[[madCommand],'par preset_b '+STRING(preset_b)]
	
	madCommand=[[madCommand],scantxt+poltxt+STRING(preset)+' '+unit+' '+ $ 
		    STRING(repeats)+' '+ savetxt +' title '+ title]

		
	
	PRINT, 'MAD: ', madCommand

	 ;Send the commands to MAD

	dummy=dial_mad_send('',0,madCommand,'')

	
	 ;calculate start and finish times
	
	
	totalDuration=numSteps*duration ;duration is originally time per scan position

	startTime=systime(1)  ;record the time that the scan started

	IF unit EQ 't' THEN BEGIN
		totalDuration=sec2time(totalDuration)	;convert duration into days/
							;hrs/mins/secs

		durationtxt=STRING(totalDuration(0))+'days'+ $
			    STRING(totalDuration(1))+'hrs'+ $ 
			    STRING(totalDuration(2))+'mins' + $
			    STRING(totalDuration(3))+'secs'

	
		durationtxt=STRCOMPRESS(durationtxt)
		finish=timeAfter(now(), totalDuration)

		finishtxt=time2string(finish)

		 ;give the user a message
		message='Command sent to MAD'
		message=[[message],'Scan started: '+systime()]
		message=[[message],'Length of scan is: '+durationtxt]
		message=[[message],'Scan should finish at: '+finishtxt]
		dummy=WIDGET_MESSAGE(message, /INFORMATION)
	END ELSE BEGIN
		dummy=WIDGET_MESSAGE('Scan started: '+systime(), /INFORMATION)
	END

	WIDGET_CONTROL, event.top, /DESTROY

END





FUNCTION cancelButton_event, event	; Event handler for the cancel button
;*********************************
	
	COMMON countCom
	startTime=-1
	WIDGET_CONTROL, event.Top, /DESTROY
END

FUNCTION helpButton_event, event	; Event handler for the help button
;*******************************
	dummy=WIDGET_MESSAGE(['Title: The title to give to the run(s).', $
			      'Save: Save results.', $
			   'Scan: Type of scan to perform.', $
			   'From/To/By: scan parameters for omega and rotation scans',$
			   'Num Steps: Number of scan steps. This is entered',$
			   '           manually for 2theta scans and is calculated',$
			   '           automatically for other scan types',$
			   'Polarisation Analysis: The kind of polarisation analysis',$
			   '                       to perform',$
			   'Flip/non-flip ratio: Ratio of time spent counting', $
			   '                     spin flipped and non spin flipped',$
			   '                     neutrons.',$
			   'Repeat: No. of times to repeat each count', $
			   'Total Duration: Total length of entire scan', $
			   'Units: Specifies whether the above is given in seconds', $
			   '	      or monitor 1 counts'], /INFORMATION)
END



FUNCTION doCount, defaults
;*************************
		 ;The Main function. This procedure creates the interface and 
		 ;registers the application with the IDL XMANAGER
		 ;returns 0 if count started, -1 if count was cancelled
 	
	IF XREGISTERED('Count') THEN BEGIN 	;ensure no other copies running
					PRINT, "docount is already running"
					RETURN, -1
				     END
	
	 ;Setup constants used for radio button values. This is done so that the
	 ;radio button text can be changed here and still be picked up correctly
	 ;by the event handlers

	COMMON countConstants

	NOSCAN='None'
	THETASCAN='2theta'
	OMEGASCAN='Omega'
	ROTATIONSCAN='Rotation'
	
	NOPOL='None'
	ZPOL='Z Only'
	XYZPOL='XYZ'
	MONITORUNIT='Monitor'
	TIMEUNIT='Time'

	
	COMMON countCom

	time	;load the time library (there is probably a better way of doing this)

	
	cancelFlag=0; 	Will be set to -1 if count is cancelled

	  ;Create the interface

	mainWindow=WIDGET_BASE(TITLE='D7 Count parameters', ROW=5)
	
	  ;Output setup

	titleBase=WIDGET_BASE(mainWindow, /ROW)
	titleField=CW_FIELD(titleBase, /STRING, TITLE='Count Title:')
	saveButton=CW_BGROUP(titleBase, ['Save'], /NONEXCLUSIVE, /RETURN_NAME, $
				EVENT_FUNCT='saveButton_event')

	  ; Scan Setup

	scanBase=WIDGET_BASE(mainWindow, /FRAME, COLUMN=2)
	scanButtons=CW_BGROUP(scanBase,[NOSCAN, $
					THETASCAN, $
					OMEGASCAN, $
					ROTATIONSCAN], /EXCLUSIVE, $
			       LABEL_LEFT='Scan: ', / RETURN_NAME, /FRAME, $
			       EVENT_FUNCT='scanButtons_event', $
			       IDS=scanButtonID)
			       
	scanFieldBase=WIDGET_BASE(scanBase, /COL)
	scanFromField=CW_FIELD(scanFieldBase, /FLOATING, TITLE='Scan From:', $
			       	XSIZE=8, /ALL_EVENTS)

	scanToField=CW_FIELD(scanFieldBase, /FLOATING, TITLE='  Scan To:', $
			  	XSIZE=8, /ALL_EVENTS)

	scanStepField=CW_FIELD(scanFieldBase, /FLOATING, TITLE='  Step By:', $
				XSIZE=8, /ALL_EVENTS)

	scanNumStepsField=CW_FIELD(scanFieldBase, /LONG, TITLE='Num Steps:', $
				XSIZE=8, /ALL_EVENTS, /NOEDIT)
	

	  ;Polarisation Analysis setup
	
	polBase=WIDGET_BASE(mainWindow, /COL, /FRAME)
	polButtons=CW_BGROUP(polBase, [NOPOL, $
					  ZPOL, $
					  XYZPOL], /EXCLUSIVE, $
			     LABEL_LEFT='Polarisation Analysis: ',$
			     /RETURN_NAME, /FRAME, $
			     EVENT_FUNCT='polButtons_event', $
			     IDS=polButtonID)
	

	

	countRatioField=CW_FIELD(polBase, /FLOATING, $
				 TITLE='Flip / non-flip ratio: ', XSIZE=4)

	  ;Count time setup

	totalTimeBase=WIDGET_BASE(mainWindow, ROW=2, /FRAME)

	repeatField=CW_FIELD(totalTimeBase, /INTEGER, TITLE='Repeat: ',$
                             XSIZE=4, /ALL_EVENTS, UVALUE='repeatField')

	subBase=WIDGET_BASE(totalTimeBase, ROW=3, /FRAME)

	 ;NB The fields in this base are generated dynamically depending on 
	 ;the state of unitsButtons

	
	
	timeLabel=WIDGET_LABEL(subBase, VALUE='Duration per scan position')


	

	
	timeInputBase=WIDGET_BASE(subBase, /ROW)

	 ;NO_RELEASE keyword added for IDL v. 5.2. Without this keyword
	 ;two events will be generated each time a button is selected.
	 ;This causes either enableMonitorUnits or enableTimeUnits to be
	 ;called twice whcih means that the old fields are not destroyed
	 ;properly when the new ones are dynamically created
	
	unitsButtons=CW_BGROUP(subBase, [TIMEUNIT, MONITORUNIT], $
			       /EXCLUSIVE, LABEL_LEFT='Units:', /FRAME, $
			       IDS=unitButtonID, EVENT_FUNCT='unitButtons_event',$
                               /RETURN_NAME, /NO_RELEASE)
	;Footer setup
	
	footerBase=WIDGET_BASE(mainWindow, /ROW, /FRAME)
	okButton=WIDGET_BUTTON(footerBase, VALUE='OK', EVENT_FUNC='okButton_event')
	cancelButton=WIDGET_BUTTON(footerBase, VALUE='Cancel', $
				    EVENT_FUNC='cancelButton_event')

	helpButton=WIDGET_BUTTON(footerBase, VALUE='Help', /HELP, $
				 EVENT_FUNC='helpButton_event')	


	setDefaults, defaults ;set default values

	;Paint and setup event loop

	WIDGET_CONTROL, mainWindow,	/REALIZE

	CATCH, Error_status	;Establish error handler
	
	;If an error occurs we pop up a message box with the error 
	;message. If the user clicks cancel then we quit the program
	;otherwise execution continues as normal.

	IF Error_status NE 0 THEN BEGIN
		result=WIDGET_MESSAGE(!ERR_STRING, /ERROR, /CANCEL)
		IF result EQ 'Cancel' THEN BEGIN
						WIDGET_CONTROL, /RESET
						RETURN, -1
					   END
	END


	XMANAGER,'Count',mainWindow, /MODAL


	;Fill out return data structure
	CASE scan OF
		NOSCAN: scantxt=''
		THETASCAN: scantxt='2theta'
		OMEGASCAN: scantxt='omega'
		ROTATIONSCAN: scantxt='rotation'
	ENDCASE

	CASE po OF
		NOPOL: poltxt='NOP'
		ZPOl: poltxt='ZP'
		XYZPOL: poltxt='XYZP'
	ENDCASE
	
	RETURN, {title:title, po:poltxt, scan:scantxt, duration:duration, unit: unit,$
		 repeats:repeats, save:save, ratio:ratio, from:from, to:to, $
	         step:step, numSteps: numSteps, startTime:startTime}


END
FUNCTION dspac,l,a,h,l=l,a=a,h=h
RETURN,d=a/SQRT(h(0,*)^2+h(1,*)^2+h(2,*)^2)
END
;*********** D2B => Paolo Radaelli ******************

pro dud, dets=d, pts=p


common c_rdid, dzap, pzap

dzap=d
pzap=p


end
pro dumpx,wk_in,o_file
;
; Dumps an INX file - parameters may be a bit odd
@lamp.cbk
wkstr=strtrim(string(alone),2)
pi=3.1416
w_buf=0
x_buf=0
y_buf=0
pmt_buf=0
;
; Prepare zones
   nzone=intarr(7)
   nzone(1)=1
   nzone(2)=2
   nzone(3:6)=0
;
; Prepare w_buffer
   jjj0=execute('w_buf=w'+wkstr)
      my_check=size(w_buf)

;
; What dimensions for the data?
      case my_check(0) of
         0: return
         1: begin
               nchans=my_check(1)
               nspecs=1
            end
         2: begin
               nchans=my_check(1)
               nspecs=my_check(2)
            end
	 else: return
      endcase
;
; Prepare other buffers
   jjj1=execute('x_buf=x'+wkstr)
   jjj2=execute('y_buf=y'+wkstr)
   jjj3=execute('pmt_buf=p'+wkstr)
   jjj4=execute('e_buf=e'+wkstr)
   
   if n_elements(w_buf) ne n_elements(e_buf) then e_buf=w_buf*0.
   if (size(y_buf))(0) eq 2 then y_buf=reform(y_buf(0,*))
   sx=(size(x_buf))(0)
   
; Get the parameters
      temp	=pmt_buf(11) 
      einc	=81.799/pmt_buf(21)/pmt_buf(21) 
      qinc	=2*pi/pmt_buf(21) 
      amass	=1.0
      nlines	=nchans+3
      deltatau	=pmt_buf(18)
      deltaen	=0.0
      deltak	=0.0
      isym	=0
      dumme	=0.0
      on_ioerror,pb_wrt  
      get_lun,ifile
      openw,ifile,o_file
				frmv='(5x,f10.5,e13.5,e12.4)'
       if max(y_buf) ge 10 then frmt='(x,f6.2,f8.3,f8.4,f9.3,f6.1,i2)' $
			   else frmt='(x,f6.4,f8.3,f8.4,f9.3,f6.1,i2)'
       for i=0,nspecs-1 do begin
         printf ,ifile,nlines,nzone(1:6),nchans          ,format='(8i5)'
	 printf ,ifile,w_tit(alone)
	 printf ,ifile,y_buf(i),einc,qinc,temp,amass,isym,format=frmt
	 printf ,ifile,deltaen,deltatau,deltak           ,format='(16x,3f8.4)'
	 if sx eq 1 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j)  ,w_buf(j,i),e_buf(j,i)  ,format=frmv

	 if sx eq 2 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j,i),w_buf(j,i),e_buf(j,i)   ,format=frmv

       endfor
       pb_wrt:free_lun,ifile
    return
    end	    
      
;***************************************;

pro interpol,x_in,w_in,w_out,E,t,i            ,E_IN,E_OUT
;
; Do interpolation
;
  m=(w_in(t,*)-w_in(t-1,*))/(x_in(t)-x_in(t-1))
  b= w_in(t,*)-m*x_in(t)
  w_out  (i,*)=m*E+b

  if n_elements(e_out) gt 1 then begin
    r=(e_in(t,*)^2+e_in(t-1,*)^2)/(x_in(t)-x_in(t-1))
    s= e_in(t,*)^2  + r*x_in(t)
    e_out  (i,*)=SQRT(r*E+s)
  endif
  i=i+1
end

;***************************************;

pro calculate,Estep,x_in,w_in,w_out,E,t,i,nch ,E_IN,E_OUT
;
; Average over values within E..E+Estep
;
  counter=0
  e_out(i,*)=e_out(i,*)^2
  while (t lt nch-1) and (x_in(t) lt E+Estep)  do begin     
    w_out(i,*)=w_out(i,*)+w_in(t,*)
    if n_elements(e_out) gt 1 then e_out(i,*)=e_out(i,*)+e_in(t,*)^2
    t=t+1
    counter=counter+1
  endwhile
  w_out(i,*)=w_out(i,*)/counter
  if n_elements(e_out) gt 1 then e_out(i,*)=SQRT(e_out(i,*))/counter
  i=i+1
end
;***************************************;

pro starter,Estep,x_in,w_in,w_out,E,t,i       ,E_IN,E_OUT
;
; Find starting point
;
  while (x_in(t) lt E) do t=t+1
  while (x_in(t)-E) gt Estep do begin
    if t eq 0 then w_out(t,*)=0 $
    else interpol,x_in,w_in,w_out,E,t,i       ,E_IN,E_OUT
    E=E+Estep
  endwhile
end



function ebin,in_wk,Emin,Emax,Estep
;
; Bin with given Emin,Emx,Estep
;
@mac.in 
my_check=size(in_wk)

  if my_check(0) lt 1 then  begin
     P_MUS,'mus_cannon'
     mess='Workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
   endif

  if strpos(his(two),'t2e') lt 0 then begin
     P_MUS,'mus_cannon'
     mess='Input workspace not in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
  endif

  P_MUS,'mus_shot'
  nch=my_check(1)
  nang=my_check(2)
;
; Arguments reasonable ?
;
  if Emin gt Emax then begin
    E=Emax
    Emax=Emin
    Emin=E
  endif $
  else E=Emin
    if (Estep lt 0) then Estep=-Estep 
      if Estep gt (Emax-Emin) $
      or Estep eq 0 then Estep=max(x_in)-min(x_in)/nch
  length=round((Emax-Emin)/Estep)+1
  if length gt (3.*nch) then Estep=(Emax-Emin)/(3.*nch)
  w_out=fltarr(round((Emax-Emin)/Estep)+1,nang)
  x_out=fltarr(round((Emax-Emin)/Estep)+1)
  IF n_elements(e_in) eq n_elements(w_in) then E_OUT=w_out else E_OUT=0
  i=0 
  t=0
;
; Main program
;
  starter,Estep,x_in,w_in,w_out,E,t,i                ,E_IN,E_OUT
  repeat begin
    if (x_in(t)-E) gt Estep $
      then interpol,x_in,w_in,w_out,E,t,i            ,E_IN,E_OUT $
      else calculate,Estep,x_in,w_in,w_out,E,t,i,nch ,E_IN,E_OUT
    E=E+Estep
  endrep until E gt Emax
  c=findgen(round((Emax-Emin)/Estep)+1)
  x_out=Emin+Estep*c
  y_out=y_in
  p_out(30)=p_in(30)
  p_out(19)=round((Emax-Emin)/Estep)+1
@mac.out
  return,w_out
end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION elastic, w_in, min=xmin, max=xmax, save=save
;
;For IN4, IN5, IN6 and D7 data. 
; 
;Finds the elastic peak position in each spectrum by fitting a Gaussian
;and a flat background. Looks for peak in region xmin<x<xmax 
;
;ARGUMENTS:
;	min:	minimum x-value for peak search
;	max:	maximum x-value for peak search
;
;KEYWORDS:
; 	/save     : Write out results to file 'elastic.dat'
;
;DIMENSIONS:
;w_in(nchannels,nspectra) OR w_in(nchannels)
;
;COMMAND SYNTAX:
;w3=elastic(w2[,min=<min>][,max=<max>][,/save])
;
;(optional arguments and keywords shown in square brackets)
;
;							KHA,JRS 13/7/00
;
;-------------------------------------------------------------------------------
;*******************************************************************************

	COMMON c_lamp_access, inst

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start elastic:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace and energy gaussameters

	par=datp.p

	IF (N_ELEMENTS(xmin) EQ 0) THEN BEGIN
		xmin=par(9)-30.
		xmax=par(9)+30.
	ENDIF

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	nchannels=sw(1)
	IF (sw(0) EQ 1) THEN nspectra=1     ELSE $
	IF (sw(0) EQ 2) THEN nspectra=sw(2) ELSE return,0

	IF (iprint GT 0) THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	phi=datp.y
	x_in=datp.x
	e_in=datp.e

	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN e_in=SQRT(w_in)

	IF (iprint GT 0) THEN PRINT,'End of setup section'

;-------------------------------------------------------------------------------------
;	Fit Gaussians

	x_out=phi
	w_out=FLTARR(nspectra)	& e_out=w_out

	gauss=FLTARR(4)	& dgauss=gauss
	x=x_in
	FOR ispec=0,nspectra-1 DO BEGIN
		y=w_in(*,ispec)
		e=e_in(*,ispec)
		IF (iprint GT 0) THEN PRINT,'Fitting Gaussian to s',ispec
		fitgauss, x, y, e, xmin, xmax, gauss, dgauss, ispec
		w_out(ispec)=gauss(2)	& e_out(ispec)=dgauss(2)
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of fitting section'

;-------------------------------------------------------------------------------------
;	Save to file

	IF KEYWORD_SET(save) THEN BEGIN
		OPENW, 1, 'elastic.dat'
		FOR i=0,nspectra-1 DO PRINTF, 1, phi(i), w_out(i), e_out(i)
		PRINTF, 1, 'Elastic channels'
		PRINTF, 1, 'Scattering Angle'
		PRINTF, 1, 'Elastic Channel'
		CLOSE, 1
		PRINT,'elastic: Elastic channels svaed to file "elastic.dat"'
	ENDIF
;-------------------------------------------------------------------------------------

	datp.x_tit='Scattering Angle'
	datp.y_tit='Elastic Channel'

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out

	x1=STRTRIM(STRING(FIX(xmin)),2) & x2=STRTRIM(STRING(FIX(xmax)),2)
	datp.other_tit=datp.other_tit+' -el('+x1+','+x2+')'

	PRINT,'elastic: Gaussians fitted from channels '+x1+' to '+x2

	give_datp, datp

finished:
	RETURN, w_out
	END


pro error

a=fltarr(10)

catch, error_status

if Error_status ne 0 then begin

print, 'error', error_status
print, 'message', !err_string

a=fltarr(12)
endif
a(11)=12

end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION estrip, w_in, E=Evalue, dE=dE, dQ=dQ, $
		 pos_angles=pos_angles, neg_angles=neg_angles, $
		 all_angles=all_angles, ev, eb, qb, ib
;
; For IN4, IN5, IN6 and D7
;
;Rebins output data from t2e and reb to regular-grid S(Q,w) data using the old
;KHA IN6 rebin algorithm. Selects a single E-value. Input workspace must be in
;energy transfer versus scattering angle, i.e. only one component or spin phase.
;
;ARGUMENTS:
;	Evalue: E-value at centre of extracted strip
;	dE :	Width of E-strip
;	dQ :	Q bin width
;
;KEYWORDS: (- only for D7 data:)
; /neg_angles   : use only negative angles
; /pos_angles	: use only positive angles
; /all_angles	: use all angles (default)
;		input workspace must be in energy transfer versus scattering angle,
;		i.e. only one component or spin phase.
; (ev, eb, qb and ib are obsolete, kept for backwards compatability)
;
;DIMENSIONS:
; w_in(nE,nphi) -> w_out(nE,nQ)
;
;COMMAND SYNTAX:
; w10=estrip(w9,E=<Evalue>,dE=<dE>,dQ=<dQ>[,/pos_angles][,/neg_angles][,/all_angles])
;
; (Optional keywords shown in square brackets)
;
;							KHA,JRS 13/7/00
;
;-------------------------------------------------------------------------------
;*******************************************************************************

	common c_lamp_access, inst

	common grid, Qmin, Qmax, Emin, Emax

	iprint=0	; if iprint>0, show debugging messages
			; if iprint>1, plot overlap areas

	IF (iprint GT 0) THEN PRINT,'Start estrip:'

	take_datp, datp

	ibank=2
	IF(N_ELEMENTS(ev) GT 0) THEN Evalue=ev
	IF(N_ELEMENTS(eb) GT 0) THEN dE=eb
	IF(N_ELEMENTS(qb) GT 0) THEN dQ=qb
	IF(N_ELEMENTS(ib) GT 0) THEN ibank=ib

	IF KEYWORD_SET(pos_angles) THEN ibank=1
	IF KEYWORD_SET(neg_angles) THEN ibank=0
	IF KEYWORD_SET(all_angles) THEN ibank=2


;-------------------------------------------------------------------------------
;Set up starting parameters

	IF (N_ELEMENTS(Evalue) NE 1 OR N_ELEMENTS(dE) NE 1 OR N_ELEMENTS(dQ) NE 1) THEN BEGIN
		PRINT,'estrip: Error - Evalue, dE, dQ must be specified'
		return,w_in
	ENDIF

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	IF (sw(0) NE 2) THEN BEGIN
		PRINT,'estrip: Error - input workspace must be 2-D: E vs. phi'
		return,w_in
	ENDIF
	nx=sw(1)
	ny=sw(2)
	IF (iprint GT 0) THEN PRINT,'nx=',nx,' ny=',ny
	x_in=datp.x	& sx=SIZE(x_in)
	y_in=datp.y	& sy=SIZE(y_in)
	IF (nx NE sx(1)) OR (ny NE sy(1)) THEN BEGIN
		PRINT,'estrip: Error - sx=',sx,' sy=',sy
		return,w_in
	ENDIF

	e_in=datp.e
	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN e_in=w_in*0.

	par=datp.p

	IF (iprint GT 0) THEN PRINT,'Instrument = ',inst
	IF (inst EQ 'D7') THEN BEGIN
		lambda=par(4)
		IF (N_ELEMENTS(ibank) EQ 0) THEN ibank=2
		TOF=FIX(par(8))
		IF (TOF NE 1) THEN BEGIN
			PRINT,'estrip: Error - workspace data is not in TOF'
			return,w_in
		ENDIF
	ENDIF ELSE lambda=par(21)

	IF (iprint GT 0) THEN PRINT,'lambda=',lambda,'A'

;-------------------------------------------------------------------------------------
;	Set constants and prepare arrays for rebinning to regular Q-E grid

	const1=5.22697		; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571	; E(meV)=const2*k(A^-1)^2 for neutron
	const3=3.956076		; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066		; E(meV)=const4/lambda(A)^2 for neutron

	Ei=const4/lambda^2
	ki=SQRT(Ei/const2)
	y_in=y_in*!pi/180.	; convert to radians

	nEps=nx+1	& Eps=FLTARR(nEps)
	Eps(0)=x_in(0)-(x_in(1)-x_in(0))/2.
	Eps(1:nx-1)=(x_in(0:nx-2)+x_in(1:nx-1))/2.
	Eps(nx)=x_in(nx-1)+(x_in(nx-1)-x_in(nx-2))/2.

	IF (iprint GT 0) THEN PRINT,'x=',x_in
	IF (iprint GT 0) THEN PRINT,'Eps=',Eps

	Emin=Evalue-dE/2.	& Emax=Evalue+dE/2.
	iEarr=WHERE(Eps GT Emin AND Eps LT Emax,n)
	iEarr=[iEarr(0)-1,iEarr]
	IF (Emax LT Eps(nx)) THEN iEarr=[iEarr,iEarr(n-1)+1]
	Eps=Eps(iEarr)	& s=SIZE(Eps)	& nEps=s(1)
	Eps(0)=Emin	& Eps(nEps-1)=Emax
	IF (iprint GT 0) THEN PRINT,'Eps=',Eps
	iEarr=iEarr(0:nEps-2)
	Qmin=0.	& Qmax=SQRT((2.*Ei-Emin-2.*SQRT(Ei*(Ei-Emin))*COS(y_in(ny-1)))/const2)
	IF (iprint GT 0) THEN PRINT,'Emin=',Emin,' Emax=',Emax,' meV'
	IF (iprint GT 0) THEN PRINT,'Qmin=',Qmin,' Qmax=',Qmax,' A-1'

	nQ=FIX((Qmax-Qmin)/dQ)+1
	IF (iprint GT 0) THEN PRINT,'nQ=',nQ

	w_out=FLTARR(nQ,nEps-1)*0.	& e_out=w_out-1.
	Q=Qmin+FLOAT(INDGEN(nQ))*dQ
	IF (iprint GT 0) THEN PRINT,'Q=',Q

	IF (iprint GT 0) THEN PRINT,'y_in=',y_in*180./!pi

	IF (inst EQ 'D7') THEN BEGIN
		i=WHERE(y_in GT 0.,n)
		IF (n LE 0 OR n EQ ny) THEN BEGIN
			PRINT,'estrip: Error - For D7 both -ve and +ve angles must be present'
			return,w_in
		ENDIF
		IF (ibank EQ 2) THEN BEGIN
			twice=1
			iphi1=0		& iphi1next=i(0)
			iphi2=i(0)-1	& iphi2next=ny-1
		ENDIF ELSE BEGIN
			twice=0
			IF (ibank EQ 0) THEN BEGIN
				iphi1=0
				iphi2=i(0)-1
			ENDIF ELSE IF (ibank EQ 1) THEN BEGIN
				iphi1=i(0)
				iphi2=ny-1
			ENDIF ELSE BEGIN
				PRINT,'estrip: Error - ibank =',ibank
				return,w_in
			ENDELSE
		ENDELSE
	ENDIF ELSE BEGIN
		twice=0
		iphi1=0	& iphi2=ny-1
	ENDELSE
	IF (iprint GT 0) THEN PRINT,'twice=',twice,' iphi1=',iphi1,' iphi2=',iphi2

start:
	nphi=iphi2-iphi1+2
	phi=FLTARR(nphi)
	phi(0)=y_in(iphi1)-(y_in(iphi1+1)-y_in(iphi1))/2.
	phi(1:nphi-2)=(y_in(iphi1:iphi2-1)+y_in(iphi1+1:iphi2))/2.
	phi(nphi-1)=y_in(iphi2)+(y_in(iphi2)-y_in(iphi2-1))/2.
	COSphi=COS(phi)

	w_buf=w_in(iEarr,iphi1:iphi2)
	e_buf=e_in(iEarr,iphi1:iphi2)
	y_buf=y_in(iphi1:iphi2)
	IF (phi(0) LT 0.) THEN BEGIN ; reverse array direction for negative angles
		w_buf=REVERSE(w_buf,2)
		e_buf=REVERSE(e_buf,2)
		y_buf=ABS(REVERSE(y_buf))
		phi=ABS(REVERSE(phi))
		COSphi=REVERSE(COSphi)
	ENDIF

	IF (iprint GT 0) THEN PRINT,'phi=',phi*180./!pi

	IF (iprint GT 0) THEN PRINT,'End of "prepare arrays" section'

;-------------------------------------------------------------------------------------
;	Rebin to constant Q grid

	a=const2		;	E(meV)=a*Q(A**-1)**2   for neutron

	iprint0=iprint
	oldymin=0.

	IF (iprint GT 1) THEN BEGIN
		b=''
		PRINT,'About to start rebinning. Hit return to continue'
		READ, b
	ENDIF

	FOR iQ=0,nQ-1 DO BEGIN
		IF (iprint0 GT 0) THEN PRINT,'Rebinning at Q =',Q(iQ),' +/-',dQ/2.
		iprint=0
		IF (iprint0 GT 0) AND (10*(iQ/10) EQ iQ) THEN iprint=iprint0
		IF (iprint GT 1) THEN PRINT,'iQ=',iQ
		Qmin=Q(iQ)-dQ/2.	& Qmax=Q(iQ)+dQ/2.
		Q00=[Qmin,Qmin,Qmax,Qmax]
		IF (iprint GT 1) THEN PRINT,Qmin,' < Q <',Qmax
		FOR iEps=0,nEps-2 DO BEGIN
			IF (iprint GT 1) THEN PRINT,'iEps=',iEps
			Emin=Eps(iEps)	& Emax=Eps(iEps+1)
			corrarea=dQ*(Emax-Emin)
			Eps0=[Emin,Emax,Emax,Emin]
			IF (iprint GT 1) THEN PRINT,Emin,' < Eps <',Emax
			COSphi0=(2.*Ei-Eps0-a*Q00^2)/(2.*SQRT(Ei*(Ei-Eps0)))
			IF (iprint GT 1) THEN PRINT,' COS(phi1-4):',COSphi0
			IF (MAX(ABS(COSphi0)) GE 1.) THEN GOTO, outside
			phi0=ACOS(COSphi0)
			IF (iprint GT 1) THEN PRINT,' phi0=',phi0*180./!pi
			phimin=MIN(phi0)	& phimax=MAX(phi0)
			IF (iprint GT 1) THEN PRINT,'Outside if: phimax=',phimax*180./!pi,'< phi(0)=',phi(0)*180./!pi
			IF (iprint GT 1) THEN PRINT,'        or: phimin=',phimin*180./!pi,'> phi(nphi-1)=',phi(nphi-1)*180./!pi,'  nphi=',nphi
			IF (phimax LT phi(0) OR phimin GT phi(nphi-1)) THEN GOTO, outside
			IF (iprint GT 1) THEN PRINT,'phi within range'
			iphi=WHERE(phi GT phimin AND phi LT phimax, nlines)
			iphi0=(iphi(0)-1)>0
			IF (nlines EQ 0) THEN BEGIN
				phimean=(phimin+phimax)/2.
				ip=WHERE(phi LT phimean, np)
				iphi0=ip(np-1)
			ENDIF
startrebin:		Areasum=0.
			wsum=0.
			e2sum=0.
			phiminmeas=7.	& phimaxmeas=0.
			FOR iphi=iphi0,(iphi0+nlines)<(nphi-2) DO BEGIN
				IF (iprint GT 1) THEN BEGIN
					ip1=iphi0
					ip2=(iphi0+nlines)<(nphi-2)
					PRINT,'FOR iphi=',ip1,',',ip2
					PRINT,'phi(',ip1,')=',phi(ip1)*180./!pi
					PRINT,'phi(',ip2+1,')=',phi(ip2+1)*180./!pi
				ENDIF
				COSphi1=COSphi(iphi)	& COSphi2=COSphi(iphi+1)
				COSphi0=[COSphi1,COSphi1,COSphi2,COSphi2]
				IF (iprint GT 1) THEN PRINT,'phi1=',phi(iphi)*180./!pi,$
								' phi2=',phi(iphi+1)*180./!pi
				Q0=SQRT((2.*Ei-Eps0-2.*SQRT(Ei*(Ei-Eps0))*COSphi0)/a)
				area=overlap(Q0,Eps0,iprint-1,oldymin)
				IF (area GT 0.) THEN BEGIN
					IF (iprint GT 1) THEN PRINT,'Area>0'
					w=w_buf(iEps,iphi)	& e=e_buf(iEps,iphi)
					IF (w NE 0. OR e GE 0.) THEN BEGIN
						areasum=areasum+area
						wsum=wsum+area*w
						e2sum=e2sum+(area*e)^2
						phiminmeas=phiminmeas<phi(iphi)
						phimaxmeas=phimaxmeas>phi(iphi+1)
						IF (iprint GT 1) THEN PRINT, $
							'w_buf(',iEps,',',iphi,')=',w
						IF (iprint GT 1) THEN PRINT, $
							'e_buf(',iEps,',',iphi,')=',e
						IF (iprint GT 1) THEN PRINT, $
						phiminmeas,' < phimeas <',phimaxmeas
					ENDIF
				ENDIF ELSE IF (iprint GT 1) THEN PRINT,'Area<=0'
			ENDFOR
			IF (areasum NE 0.) THEN BEGIN
				IF (iprint GT 1) THEN PRINT,'areasum NE 0. - OK'
				w_out(iQ,iEps)=wsum/areasum
				e_out(iQ,iEps)=SQRT(e2sum)/areasum
				GOTO, binned
			ENDIF ELSE IF (iprint GT 1) THEN PRINT,'areasum is zero'
outside:		IF (iprint GT 1) THEN PRINT,'Outside covered Q-w region'
			w_out(iQ,iEps)=0.
			e_out(iQ,iEps)=-1.
			GOTO, nextpoint
binned:
			IF (iprint GT 1) THEN PRINT,'phimin=',phimin,' phimax=',phimax
			IF (iprint GT 1) THEN PRINT,'measur=',phiminmeas,'        ',phimaxmeas
			p1=phimin>phiminmeas
			p2=phimax<phimaxmeas
			IF (p2-p1 LT (phimax-phimin)/2.) THEN BEGIN
				IF (iprint GT 1) THEN PRINT,'Point removed'
				w_out(iQ,iEps)=0.
				e_out(iQ,iEps)=-1.
			ENDIF ELSE IF (iprint GT 1) THEN PRINT,'Point kept'
nextpoint:
			IF (iprint GT 1) THEN PRINT,'*********************************************************'
		ENDFOR
	ENDFOR

	iprint=iprint0

	IF (iprint GT 0) THEN PRINT,'End of rebinning'

	IF (twice EQ 1) THEN BEGIN
		IF (iphi1 EQ 0) THEN BEGIN
			w_out1=w_out	& e_out1=e_out
			iphi1=iphi1next
			iphi2=iphi2next
			GOTO, start
		ENDIF ELSE BEGIN
			w_out2=w_out	& e_out2=e_out
			w_out(*,*)=0.	& e_out(*,*)=0.
			not1=WHERE(e_out1 LE 0.,n1)
			IF (n1 NE 0) THEN e_out1(not1)=1.
			not2=WHERE(e_out2 LE 0.,n2)
			IF (n2 NE 0) THEN e_out2(not2)=1.
			w_out=(w_out1/e_out1^2+w_out2/e_out2^2)/(1./e_out1^2+1./e_out2^2)
			e_out=1./SQRT(1./e_out1^2+1./e_out2^2)
			IF (n1 NE 0) THEN e_out1(not1)=-1.
			IF (n2 NE 0) THEN e_out2(not2)=-1.
			IF (n1 NE 0) THEN BEGIN
				w_out(not1)=w_out2(not1)
				e_out(not1)=e_out2(not1)
			ENDIF
			IF (n2 NE 0) THEN BEGIN
				w_out(not2)=w_out1(not2)
				e_out(not2)=e_out1(not2)
			ENDIF
		ENDELSE
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of rebinning section'

;-------------------------------------------------------------------------------------
;	Add E channels together

	dEps=Eps(1:nEps-1)-Eps(0:nEps-2)	& dEpssum=Eps(nEps-1)-Eps(0)
	dEps=REFORM(dEps,1,nEps-1)	& x=fltarr(nQ)+1.	& dEps=x#dEps

	n_out=0*w_out+1	& i=WHERE(e_out LT 0.)	& n_out(i)=0	& e_out(i)=0.

	w_out=TOTAL(w_out*n_out*dEps,2)
	e_out=SQRT(TOTAL((e_out*n_out*dEps)^2,2))
	n_out=TOTAL(n_out*dEps,2)

	i=WHERE(n_out GE dEpssum/2.)	& z=WHERE(n_out EQ 0)	& n_out(z)=1
	w_out=w_out/n_out	& w_out=w_out(i)
	e_out=e_out/n_out	& e_out=e_out(i)
	Q=Q(i)

	IF (iprint GT 0) THEN PRINT,'End of channel adding section'

;-------------------------------------------------------------------------------------
;	Return parameters and exit

	datp.x_tit='Wavevector Transfer (A-1)'
	datp.y_tit=datp.z_tit

	mod_datp, datp, "x", Q
	mod_datp, datp, "e", e_out

	PRINT, FORMAT='("estrip: Rebinned to constant Q-w: E=",F6.2,"+/-",F4.2,"meV")', Evalue, dE/2.

	s=STRTRIM(STRING(FLOAT(Evalue)),2)  & i=STRPOS(s,'.') & Evalue=STRMID(s,0,i(0)+3)
	s=STRTRIM(STRING(FLOAT(dE)),2)  & i=STRPOS(s,'.') & dE=STRMID(s,0,i(0)+3)
	s=' -es('+Evalue+','+dE
	IF (inst EQ 'D7') THEN s=s+','+STRTRIM(STRING(ibank),2)+')' ELSE s=s+')'
	datp.other_tit=datp.other_tit+s

	give_datp, datp

finished:
	RETURN, w_out
	END


PRO ex1600,w,fil

IF N_ELEMENTS(w) NE 1600 THEN BEGIN
  PRINT,'Array does not contain 1600 points!'
  fil=fil+'.'+STRCOMPRESS(N_ELEMENTS(w),/REMOVE_ALL)
  PRINT,'Stored as ', fil
ENDIF
openw,a,/get,fil
printf,a,w
free_lun,a

END
PRO exasc,w,filename,HELP=help
;
; Started: 02-Dec-96 by Th.Hansen, ILL-Grenoble
; Output of data 
; Last modification: 02-Dec-96 by Th.Hansen
;
IF KEYWORD_SET(help) THEN BEGIN
  print,''
  print,'                         PRO ExAsc.PRO'
  print,''
  print,'LAMP-IDL Macro (Procedure) started: 02-Dec-96 by Th.Hansen, ILL-Grenoble (D20)'
  print,'Output of data '
  print,''
  print,"Call:      EXASC,W[,'filename'][,/HELP]"
  print,"Variables: Workspace (necessary, won't be changed)"
  print,"           basic filename different from '' (optional, will be changed)"
  print,'Keywords:  HELP: this hopefully helping text'
  print,''
  print,'Last modification: 02-Dec-96 by Th.Hansen'
  print,''
ENDIF
IF n_elements(filename) EQ 0 THEN filename = ''
take_datp,datp
x=w
y=fltarr(N_ELEMENTS(w(0,*)))
IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN x=datp.x ELSE FOR i=0,N_ELEMENTS(w(0,*))-1 DO x(*,i)=datp.x(*)
IF N_ELEMENTS(datp.y(0,*)) GT 1 THEN FOR i=0,N_ELEMENTS(w(0,*))-1 DO y(i)=datp.y(0,i) ELSE y=datp.y 
filename=string(filename)
filename = strcompress(filename,/REMOVE_ALL)
FOR i=0,n_elements(w(0,*))-1 DO BEGIN
  filext = string(long(datp.p(0)))+'.'+string(long(i))
  filext=strcompress(filext,/REMOVE_ALL)
;  print,'FileName: ',filename+filext
  OPENW,out,filename+filext,/get_lun
  PRINTF,out,'TwoTheta, Counts, Z=',y(i),', File: ',filename+filext
  FOR j=0,N_ELEMENTS(w(*,i))-1 DO PRINTF,out,x(j,i),w(j,i)
  FREE_LUN,out
ENDFOR
END

pro exclusions,w
common calibration
common d20
@lamp.cbk
take_datp,datp
print,' '
print,'Workspace ',alone
print,'Please pay attention to bad (excluded or interpolated) detector cells!'
print,'Correction flag ',datp.p(38)
int_flag=0
if datp.p(38) ge 8 then BEGIN
  datp.p(38)=datp.p(38)-8
  print,'Bad cells have been interpolated'
  int_flag=1
ENDIF
bad_flag=0
if datp.p(38) ge 4 then BEGIN
  datp.p(38)=datp.p(38)-4
  print,'Bad cells have been treated'
  bad_flag=1
ENDIF
FOR i=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
  if bad_flag eq 1 then BEGIN
    IF int_flag eq 1 THEN print,i,bad_d20(i),datp.x(bad_d20(i),0,0) else print,i,bad_d20(i)
  ENDIF
ENDFOR
print,'List of files in ~lambda/BAD_CELLS :',psd_d20
end
pro export_cyc, FileNameInit , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                               , PR=p, PV=pv, PAR_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot $
                               ,datp=datp $
                               ;, nolamp=nolamp;
                               ,par=par,comment=comment $
                               , bad=bad
;** *********
;**
;**	Standard call for a data-write procedure called by LAMP.
		  
;**	Keywords:		  
;**		  XC       =  vector of x coordinates.
;**		  YC       = [vector of y coordinates.]
;**		  ZC       = [vector of z coordinates.]
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to PR (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size) or 0
;
;+
; Export of Fullprof data format INSTR=10
; especially for the existing script fpcyc at ILL (Bachir Ouladdiaf)
; the base name is cut to three characters, and a sequential number is added
; new name by Thomas Hansen 19 September 2001
;
;                       X,Y,Sigma format with header lines.
;                       In all cases the first 6 lines are considered
;                       as comments.
;                       If in the first line (left ajusted) appears the
;                       keyword XYDATA, then the following 5 lines are
;                       considered as the heading of the file. Among
;                       these 5 lines the following keywords and values
;                       have a meaning to the program:
;                        -> INTER  fac_x  fac_y  Interpol  Stepin
;                        -> TEMP  tsamp
;                        fac_x  internal multiplier of X-values
;                        fac_y  internal multiplier of Y and Sigma-values
;                        Interpol=0 data are given at constant step
;                                   or variable step is used in the program
;                                =1 The variable step data are interpolated
;                                   internally to the constant step Stepin.
;
;                       If no sigma values are provided the program assumes
;                       that sigma(Y)=sqrt(Y).
;                       You can add comments to the data file if they
;                       start with the character ! in the first position
;                       of the line. These lines are ignored by the program.
;-
if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION sys_dep')

CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
ON_IOERROR,mis

;IF NOT KEYWORD_SET(nolamp) THEN BEGIN
;    XiCute,'@lamp.cbk'
;ENDIF
Filename=FilenameInit
IF KEYWORD_SET(x) AND NOT KEYWORD_SET(e) THEN e=SQRT(data)
IF NOT (KEYWORD_SET(x) AND KEYWORD_SET(e) AND KEYWORD_SET(pv)) THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN BEGIN
    IF N_ELEMENTS(FilenameInit) GT 1 THEN BEGIN
      IF N_PARAMS() EQ 1 THEN data='data'
      tmp=FilenameInit
      Filename=data
      data=tmp
      flag=1
    ENDIF 
    TAKE_DATP,datpp
    datp=datpp
  ENDIF ELSE IF N_ELEMENTS(data) EQ 1 THEN BEGIN
    tmp=FilenameInit
    Filename=data
    data=tmp
  ENDIF 
  x=datp.x
  n=datp.n
  y=datp.y
  z=datp.z
  e=datp.e
  p=datp.p
  par_txt=datp.par_txt
  pv=datp.pv
  p_txt=datp.par_txt
  wt=datp.w_tit
  xt=datp.x_tit
  yt=datp.y_tit
  zt=datp.z_tit
  ot=datp.other_tit
ENDIF 
IF N_ELEMENTS(E) NE N_ELEMENTS(data) THEN E=SQRT(data)
help,filename,data
subs=N_ELEMENTS(data(0,*))
newpos=0
flag=0
REPEAT BEGIN
  pos=newpos
  ii=execute("newpos=STRPOS(FILENAME,SYS_DEP('DIVIDER'),pos+1)")
  IF newpos GE 0 THEN flag=1
ENDREP UNTIL newpos LT 0
IF NOT flag THEN pos=-1
IF subs GT 1 THEN BEGIN
  FILENAME=FILENAME+'___'
  FILENAME=STRMID(FILENAME,pos+1,3)
  PRINT,subs,' subsets'
ENDIF
FOR k=0,subs-1 DO BEGIN
  sub=''
  IF subs GT 1 THEN BEGIN
    digits=STRLEN(STRCOMPRESS(subs,/RE))
    sub=STRMID(STRCOMPRESS(10^digits+k,/RE),0,digits+1)
  ENDIF
  OPENW ,unit, STRCOMPRESS(FileName)+sub+'.dat', /get_lun
  PRINT,STRCOMPRESS(FileName,/RE)+sub+'.dat'
  PRINTF,unit, 'XYDATA ',strmid(STRCOMPRESS(wt) ,0,73)  
  PRINTF,unit, 'INTER ',1,1,0,0.1
  PRINTF,unit, 'TEMP ',pv([12,11,10],k)
  PRINTF,unit,'! ',strmid(ot ,0,76)   
  ;IF STRLEN(ot) GT 76 THEN PRINTF,unit,'! ...',strmid(ot ,76,72)
  PRINTF,unit,'! ',strmid(ot  ,0,76)   
  ;IF STRLEN(wt) GT 76 THEN PRINTF,unit,'! ... ',strmid(wt ,76,72)
  ;IF KEYWORD_SET(comment) THEN PRINTF,unit,'! ',comment
  ;PRINTF,unit,'!'
  ;PRINTF,unit,'! telnet d20sgi.ill.fr | lamp -nw'
  ;FOR l=1,20 DO BEGIN
  ;  search='w'+strcompress(string(l),/remove)
  ;  flag=0
  ;  IF N_ELEMENTS(alone) EQ 1 THEN IF l NE alone THEN BEGIN
  ;    FOR j=0,STRLEN(his(alone))-STRLEN(search)-1 DO BEGIN
  ;      test=strmid(his(alone),j,STRLEN(search))
  ;      if test EQ search and flag eq 0 THEN  BEGIN
  ;        PRINTF,unit,'!   '+strmid(his(l),0,76)   
  ;        ;IF STRLEN(his(l)) GT 76 THEN PRINTF,unit,'! ...'+strmid(his(l) ,76,72)
  ;        flag=1
  ;      ENDIF
  ;    ENDFOR
  ;  ENDIF
  ;ENDFOR
  ;IF N_ELEMENTS(alone) NE 1 THEN alone=0
  ;IF N_ELEMENTS(his) GT alone THEN BEGIN
  ;  PRINTF,unit,'!   '+strmid(his(alone),0,76)  
  ;  IF STRLEN(his(alone)) GT 76 THEN PRINTF,unit,'! ...'+strmid(his(alone) ,76,72)
  ;ENDIF
  ;PRINTF,unit,'! write_dat,','"',filename,'"',',W',strcompress(string(alone),/r)
  ;PRINTF,unit,'!'
  ;PRINTF,unit,'! Created: ',systime()
  ;IF N_ELEMENTS(lamp_host) EQ 1 THEN PRINTF,unit,'!      By: ',lamp_host
  ;PRINTF,unit,'! fullprof : INSTR=10'
  ;IF KEYWORD_SET(par) THEN PRINTF,unit,'!'
  ;IF KEYWORD_SET(par) THEN par=par(WHERE(par LT N_ELEMENTS(p) AND par GE 0))
  ;IF KEYWORD_SET(par) THEN FOR j=0,N_ELEMENTS(par)-1 DO PRINTF,unit,'! ',par_txt(par(j)),pv(par(j))
  ;IF KEYWORD_SET(bad) THEN PRINTF,unit,'!'
  ;IF KEYWORD_SET(bad) THEN BEGIN
  ;  IF N_ELEMENTS(z) EQ 0 THEN PRINTF,unit,'! no bad cells' ELSE BEGIN
  ;    IF N_ELEMENTS(data(*,0))+N_ELEMENTS(z) EQ 1600 THEN BEGIN
  ;      PRINTF,unit,'!'+string(N_ELEMENTS(z))+' bad cells excluded : cell-no.' 
  ;      FOR j=0,(N_ELEMENTS(z)-1)/15 DO PRINTF,unit,'!'+strcompress(z(j*15:j*15+14))
  ;    ENDIF ELSE BEGIN
  ;      PRINTF,unit,'!'+string(N_ELEMENTS(z))+' bad cells not excluded, evt. interpolated : cell-no. angle (2th.)' 
  ;      FOR j=0,(N_ELEMENTS(z)-1) DO PRINTF,unit,'!',z(j),x(z(j))
  ;    ENDELSE
  ;  ENDELSE
  ;ENDIF
  ;PRINTF,unit,'!'
  ;PRINTF,unit,'! Monitor/counts   Counting time/sec (A2,F15.0,F9.1)'
  ;PRINTF,unit,format='(A2,F15.0,F9.1)','!'+' ',n(0,0:1<(N_ELEMENTS(n(0,*,0))-1),0)
  PRINTF,unit,'! Monitor/counts, Counting time/sec: ',n(0,0,0),n(0,1<(N_ELEMENTS(n(0,*,0))-1),0)
  ;PRINTF,unit,'!'
  ;PRINTF,unit,'!  angle  counts   sigma (F9.4,F18.3,F9.3)'
  FOR i=0,N_ELEMENTS(data(*,k))-1 DO BEGIN
    ;PRINTF,unit,FORMAT='(F9.4,F18.3,F12.3)',(x(i,k))<(180.),(data(i,k))<(1.0E12),(e(i,k))<(1.0E6)
    IF x(i,k<(N_ELEMENTS(x(0,*))-1)) GE 0 THEN PRINTF,unit,FORMAT='(F9.4,F18.3,F12.3)',(x(i,k<(N_ELEMENTS(x(0,*))-1)))<(180.),(data(i,k))<(1.0E12),(e(i,k))<(1.0E6)
 ENDFOR

  FREE_LUN,unit

ENDFOR

return

mis:print,!err_string
end
pro export_dat, FileNameInit , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                               , PR=p, PV=pv, PAR_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot $
                               ,datp=datp $
                               ;, nolamp=nolamp;
                               ,par=par,comment=comment $
                               , bad=bad
;** *********
;**
;**	Standard call for a data-write procedure called by LAMP.
		  
;**	Keywords:		  
;**		  XC       =  vector of x coordinates.
;**		  YC       = [vector of y coordinates.]
;**		  ZC       = [vector of z coordinates.]
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to PR (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size) or 0
;
;+
; Export of Fullprof data format INSTR=10
;
;                       X,Y,Sigma format with header lines.
;                       In all cases the first 6 lines are considered
;                       as comments.
;                       If in the first line (left ajusted) appears the
;                       keyword XYDATA, then the following 5 lines are
;                       considered as the heading of the file. Among
;                       these 5 lines the following keywords and values
;                       have a meaning to the program:
;                        -> INTER  fac_x  fac_y  Interpol  Stepin
;                        -> TEMP  tsamp
;                        fac_x  internal multiplier of X-values
;                        fac_y  internal multiplier of Y and Sigma-values
;                        Interpol=0 data are given at constant step
;                                   or variable step is used in the program
;                                =1 The variable step data are interpolated
;                                   internally to the constant step Stepin.
;
;                       If no sigma values are provided the program assumes
;                       that sigma(Y)=sqrt(Y).
;                       You can add comments to the data file if they
;                       start with the character ! in the first position
;                       of the line. These lines are ignored by the program.
;-
if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION sys_dep')

CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
ON_IOERROR,mis

;IF NOT KEYWORD_SET(nolamp) THEN BEGIN
;    XiCute,'@lamp.cbk'
;ENDIF
Filename=FilenameInit
IF KEYWORD_SET(x) AND NOT KEYWORD_SET(e) THEN e=SQRT(data)
IF NOT (KEYWORD_SET(x) AND KEYWORD_SET(e) AND KEYWORD_SET(pv)) THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN BEGIN
    IF N_ELEMENTS(FilenameInit) GT 1 THEN BEGIN
      IF N_PARAMS() EQ 1 THEN data='data'
      tmp=FilenameInit
      Filename=data
      data=tmp
      flag=1
    ENDIF 
    TAKE_DATP,datpp
    datp=datpp
  ENDIF ELSE IF N_ELEMENTS(data) EQ 1 THEN BEGIN
    tmp=FilenameInit
    Filename=data
    data=tmp
  ENDIF 
  x=datp.x
  n=datp.n
  y=datp.y
  z=datp.z
  e=datp.e
  p=datp.p
  par_txt=datp.par_txt
  pv=datp.pv
  p_txt=datp.par_txt
  wt=datp.w_tit
  xt=datp.x_tit
  yt=datp.y_tit
  zt=datp.z_tit
  ot=datp.other_tit
ENDIF 
help,filename,data
subs=N_ELEMENTS(data(0,*))
newpos=0
flag=0
REPEAT BEGIN
  pos=newpos
  ii=execute("newpos=STRPOS(FILENAME,SYS_DEP('DIVIDER'),pos+1)")
  IF newpos GE 0 THEN flag=1
ENDREP UNTIL newpos LT 0
IF NOT flag THEN pos=-1
IF subs GT 1 THEN BEGIN
  FILENAME=FILENAME+'_'
;  FILENAME=STRMID(FILENAME,pos+1,3)
  PRINT,subs,' subsets'
  IF (pv(29,subs-1)-pv(29,0)) EQ (subs-1) THEN numflag=1 ELSE numflag=0
ENDIF
FOR k=0,subs-1 DO BEGIN
  sub=''
  IF subs GT 1 THEN BEGIN
    digits=STRLEN(STRCOMPRESS(subs,/RE))
    sub=STRMID(STRCOMPRESS(10^digits+k,/RE),0,digits+1)
    IF numflag THEN sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
  ENDIF
  OPENW ,unit, STRCOMPRESS(FileName)+sub+'.dat', /get_lun
  PRINT,STRCOMPRESS(FileName,/RE)+sub+'.dat'
  PRINTF,unit, 'XYDATA ',strmid(STRCOMPRESS(wt) ,0,73)  
  PRINTF,unit, 'INTER ',1,1,0,0.1
  PRINTF,unit, 'TEMP ',pv([12,11,10],k)
  PRINTF,unit,'! ',strmid(ot ,0,76)   
  PRINTF,unit,'! ',strmid(ot  ,0,76)   
  PRINTF,unit,'! Monitor/counts, Counting time/sec: ',n(0,0,0),n(0,1<(N_ELEMENTS(n(0,*,0))-1),0)
  FOR i=0,N_ELEMENTS(data(*,k))-1 DO BEGIN
    IF x(i,k<(N_ELEMENTS(x(0,*))-1)) GE 0 THEN PRINTF,unit,FORMAT='(F9.4,F18.3,F12.3)',(x(i,k<(N_ELEMENTS(x(0,*))-1)))<(180.),(data(i,k))<(1.0E12),(e(i,k))<(1.0E6)
 ENDFOR

  FREE_LUN,unit

ENDFOR

return

mis:print,!err_string
end
pro export_eth, FileNameInit , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                               , PR=p, PV=pv, PAR_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot $
                               ,datp=datp $
                               ;, nolamp=nolamp;
                               ,par=par,comment=comment $
                               , bad=bad
;** *********
;**
;**	Standard call for a data-write procedure called by LAMP.
		  
;**	Keywords:		  
;**		  XC       =  vector of x coordinates.
;**		  YC       = [vector of y coordinates.]
;**		  ZC       = [vector of z coordinates.]
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to PR (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size) or 0
;
;+
; Export of3 column format data, e.g. for MAUD (Luca Lutterotti)
; Done by Thomas Hansen for Romana Frattini
;
;                       X,Y,Sigma format with header lines.
;                       In all cases the first 6 lines are considered
;                       as comments.
;                       If in the first line (left ajusted) appears the
;                       keyword XYDATA, then the following 5 lines are
;                       considered as the heading of the file. Among
;                       these 5 lines the following keywords and values
;                       have a meaning to the program:
;                        -> INTER  fac_x  fac_y  Interpol  Stepin
;                        -> TEMP  tsamp
;                        fac_x  internal multiplier of X-values
;                        fac_y  internal multiplier of Y and Sigma-values
;                        Interpol=0 data are given at constant step
;                                   or variable step is used in the program
;                                =1 The variable step data are interpolated
;                                   internally to the constant step Stepin.
;
;                       If no sigma values are provided the program assumes
;                       that sigma(Y)=sqrt(Y).
;                       You can add comments to the data file if they
;                       start with the character ! in the first position
;                       of the line. These lines are ignored by the program.
;-
if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION sys_dep')

CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
ON_IOERROR,mis

;IF NOT KEYWORD_SET(nolamp) THEN BEGIN
;    XiCute,'@lamp.cbk'
;ENDIF
Filename=FilenameInit
IF KEYWORD_SET(x) AND NOT KEYWORD_SET(e) THEN e=SQRT(data)
IF NOT (KEYWORD_SET(x) AND KEYWORD_SET(e) AND KEYWORD_SET(pv)) THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN BEGIN
    IF N_ELEMENTS(FilenameInit) GT 1 THEN BEGIN
      IF N_PARAMS() EQ 1 THEN data='data'
      tmp=FilenameInit
      Filename=data
      data=tmp
      flag=1
    ENDIF 
    TAKE_DATP,datpp
    datp=datpp
  ENDIF ELSE IF N_ELEMENTS(data) EQ 1 THEN BEGIN
    tmp=FilenameInit
    Filename=data
    data=tmp
  ENDIF 
  x=datp.x
  n=datp.n
  y=datp.y
  z=datp.z
  e=datp.e
  p=datp.p
  par_txt=datp.par_txt
  pv=datp.pv
  p_txt=datp.par_txt
  wt=datp.w_tit
  xt=datp.x_tit
  yt=datp.y_tit
  zt=datp.z_tit
  ot=datp.other_tit
ENDIF 
help,filename,data
subs=N_ELEMENTS(data(0,*))
newpos=0
flag=0
REPEAT BEGIN
  pos=newpos
  ii=execute("newpos=STRPOS(FILENAME,SYS_DEP('DIVIDER'),pos+1)")
  IF newpos GE 0 THEN flag=1
ENDREP UNTIL newpos LT 0
IF NOT flag THEN pos=-1
IF subs GT 1 THEN BEGIN
;  FILENAME=FILENAME+'_'
;  FILENAME=STRMID(FILENAME,pos+1,3)
  PRINT,subs,' subsets'
  IF (pv(29,subs-1)-pv(29,0)) EQ (subs-1) THEN numflag=1 ELSE numflag=0
ENDIF
shortname=filename
print,STRPOS(shortname,SYS_DEP('DIVIDER'))
while STRPOS(shortname,SYS_DEP('DIVIDER')) GE 0 do begin
  shortname=strmid(shortname,STRPOS(shortname,SYS_DEP('DIVIDER'))+1, strlen(shortname))
  print,shortname,STRPOS(shortname,SYS_DEP('DIVIDER'))
endwhile
OPENW ,cif, STRCOMPRESS(FileName)+'.cif', /get_lun,width=256
PRINTF,cif,'loop_'
PRINTF,cif,'_riet_meas_datafile_name'
PRINTF,cif,'_pd_meas_orientation_omega'
PRINTF,cif,'_pd_meas_orientation_chi'
PRINTF,cif,'_pd_meas_orientation_phi'
FOR k=0,subs-1 DO BEGIN
  sub=''
  IF subs GT 1 THEN BEGIN
    digits=STRLEN(STRCOMPRESS(subs,/RE))
    sub=STRMID(STRCOMPRESS(10^digits+k,/RE),0,digits+1)
    IF numflag THEN sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
  ENDIF
  PRINTF,cif,STRCOMPRESS(ShortName)+sub+'.eth',pv(14,k)-90,pv(15,k)-90,pv(16,k)
  OPENW ,unit, STRCOMPRESS(FileName)+sub+'.eth', /get_lun
  PRINT,STRCOMPRESS(ShortName,/RE)+sub+'.eth'
  ;PRINTF,unit,'# XYDATA ',strmid(STRCOMPRESS(wt) ,0,73)  
  ;PRINTF,unit,'# INTER ',1,1,0,0.1
  ;PRINTF,unit,'# TEMP ',pv([12,11,10],k)
  ;PRINTF,unit,'# ',strmid(ot ,0,76)   
  ;PRINTF,unit,'# ',strmid(ot  ,0,76)   
  ;PRINTF,unit,'# Monitor/counts, Counting time/sec: ',n(0,0,0),n(0,1<(N_ELEMENTS(n(0,*,0))-1),0)
  FOR i=0,N_ELEMENTS(data(*,k))-1 DO BEGIN
    IF x(i,k<(N_ELEMENTS(x(0,*))-1)) GE 0 THEN PRINTF,unit,FORMAT='(F9.4,F18.3,F12.3)',(x(i,k<(N_ELEMENTS(x(0,*))-1)))<(180.),(data(i,k))<(1.0E12),(e(i,k))<(1.0E6)
 ENDFOR
  FREE_LUN,unit
ENDFOR
FREE_LUN,cif

return

mis:print,!err_string
end
pro export_gsa, FileNameInit , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                               , PR=p, PV=pv, PAR_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot
;** *********
;**
;**	Standard call for a data-write procedure called by LAMP.
;**
;
;	This macro write_gsa exports data files readable for GSAS
;	Filename.gsa and Filename.gda (no line-feeds)
;   Depending on angular stepwidth and available ESDs one of three file formats will be written
;   so, no interpolation is necessary anymore!
;   At this stage, only the first diagram of a series is written out
;   Count rates and ESDs are written as integers
;   zero counts and negative angles are left out
;		  
;  *** modified by Thomas Hansen and Andrew Wills 31 August 2001		  
;  *** cleaned up by Thomas Hansen 19 September 2001
;  *** modern filenames established (Thomas Hansen, as done for Hermann Pauly)		  
;		  
;**	Keywords:		  
;**		  XC       =  vector of x coordinates.
;**		  YC       = [vector of y coordinates.]
;**		  ZC       = [vector of z coordinates.]
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to PR (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size) or 0

;CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
;ON_IOERROR,mis

Filename=FileNameInit
IF KEYWORD_SET(x) AND NOT KEYWORD_SET(e) THEN e=SQRT(data)
IF NOT (KEYWORD_SET(x) AND KEYWORD_SET(e) AND KEYWORD_SET(pv)) THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN BEGIN
    IF N_ELEMENTS(FilenameInit) GT 1 THEN BEGIN
      IF N_PARAMS() EQ 1 THEN data='data'
      tmp=FileNameInit
      Filename=data
      data=tmp
      flag=1
    ENDIF 
    TAKE_DATP,datpp
    datp=datpp
  ENDIF ELSE IF N_ELEMENTS(data) EQ 1 THEN BEGIN
    tmp=FileNameInit
    Filename=data
    data=tmp
  ENDIF 
  x=datp.x
  n=datp.n
  y=datp.y
  z=datp.z
  e=datp.e
  p=datp.p
  par_txt=datp.par_txt
  pv=datp.pv
  p_txt=datp.par_txt
  wt=datp.w_tit
  xt=datp.x_tit
  yt=datp.y_tit
  zt=datp.z_tit
  ot=datp.other_tit
ENDIF 
subs=N_ELEMENTS(data(0,*))
IF subs GT 1 THEN BEGIN
  FILENAME=FILENAME+'_'
;  FILENAME=STRMID(FILENAME,pos+1,3)
   PRINT,subs,' subsets'
  IF (pv(29,subs-1)-pv(29,0)) EQ (subs-1) THEN numflag=1 ELSE numflag=0
ENDIF

;** Begin of implementation for GSAS (containing ESDs)
;
FOR k=0,N_ELEMENTS(Data(0,*))-1 DO BEGIN
;	IF N_ELEMENTS(Data(0,*)) EQ 1 THEN OPENW ,unit, FileName+'.gsa', /get_lun ELSE BEGIN
;          IF numflag THEN BEGIN
;            sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
;            OPENW ,unit, FileName+'_'+sub+'.gsa', /get_lun
;          ENDIF ELSE BEGIN
;	    OPENW ,unit, FileName+'_'+STRCOMPRESS(ROUND(k+EXP(CEIL(ALOG10(N_ELEMENTS(Data(0,*))))*ALOG(10))),/RE)+'.gsa', /get_lun
;	  ENDELSE
;	ENDELSE
	IF N_ELEMENTS(Data(0,*)) EQ 1 THEN BEGIN 
		OPENW ,unit, FileName+'.gsa', /get_lun 
		PRINT ,FileName+'.gsa'
	ENDIF ELSE BEGIN
          IF numflag THEN BEGIN
            sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
            OPENW ,unit, FileName+sub+'.gsa', /get_lun
            PRINT ,FileName+sub+'.gsa'
          ENDIF ELSE BEGIN
	    OPENW ,unit, FileName+STRCOMPRESS(ROUND(k+EXP(CEIL(ALOG10(N_ELEMENTS(Data(0,*))))*ALOG(10))),/RE)+'.gsa', /get_lun
	    PRINT ,FileName+STRCOMPRESS(ROUND(k+EXP(CEIL(ALOG10(N_ELEMENTS(Data(0,*))))*ALOG(10))),/RE)+'.gsa'
	  ENDELSE
	ENDELSE
	;IF N_ELEMENTS(Data(0,*)) EQ 1 THEN PRINT,FileName+'.gsa/gda' ELSE PRINT, FileName+'_'+STRCOMPRESS(ROUND(k+EXP(CEIL(ALOG10(N_ELEMENTS(Data(0,*))))*ALOG(10))),/RE)+'.gsa/gda'
    WW=Data(*,k)
    EE=0
    IF KEYWORD_SET(E) THEN IF N_ELEMENTS(E) EQ N_ELEMENTS(Data) THEN EE=E(*,k)
    XX=X(*,k<(N_ELEMENTS(x(0,*))-1))
	index=WHERE(XX GT 0)
	IF KEYWORD_SET(E) THEN EE=EE(index)
	XX=X(index)
	WW=WW(index)
	index=WHERE(WW GT 0)
	IF KEYWORD_SET(E) THEN EE=EE(index)
 	XX=XX(index)
	WW=WW(index)
	; 
	;*********************************************************************************************
	;The input powder data file for GSAS is a direct access, fixed record length file. It contains
	;a few header records followed by blocks of data each corresponding to an individual	
	;powder pattern. Each block is preceded by its own header. All records must be 80
	;characters in length. The main header has one or two records:
	;(80A)TITLE
	;A title record is first; the information is used by GSAS for titles only. GSAS can only use
	;the first 66 characters of this record but it must be filled out to 80 characters.
	;('Instrument parameter',60A)FNAME
	;An optional record that must start with the 20 characters shown followed by the instrument
	;parameter file name. If this record is omitted, GSAS requests this file name from the user
	;in EXPEDT.
	;*********************************************************************************************
	;
	PRINTF,unit,strmid(wt+ot+'                                                                                        ',0,80)
	gout=strmid(wt+ot+'                                                                                        ',0,80)
	gout=gout+strmid('Instrument parameter'+' inst_d20.prm'+'                                                                                        ',0,80)
	PRINTF,unit,strmid('Instrument parameter'+' inst_d20.prm'+'                                                                                        ',0,80)
	step=0.0
	steps=x(1:N_ELEMENTS(XX)-1,0)-x(0:N_ELEMENTS(XX)-2,0)
	step=Moment(steps,sdev=stepdev)
	step=step(0)
	IF k EQ N_ELEMENTS(Data(0,*))-1 THEN PRINT,"Average angular steps: ", step,"+/-",stepdev, " degrees"
	;
	;*********************************************************************************************
	;Then follows a number of data blocks each beginning with a header. The header record is
	;in free format and has different forms depending on the type of data that follows it. For
	;standard type data the header is:
	;('BANK',3I,A,4F,' STD')IBANK,NCHAN,NREC,BINTYP,(BCOEF(I),I=1,4)
	;The fields are separated by spaces and 'BANK' must be upper case. IBANK is the bank
	;number; if it is zero the data block is from the incident beam monitor. The value of IBANK
	;must be unique within a data file. For TOF data the value of IBANK must corrrespond to
	;the bank number found in the instrument parameter file for the detectors which produced
	;the data. This correspondence is not needed for CW data. NCHAN is the number of data
	;points in the block of data and NREC is the number of records. There are 10 data points
	;per record so NREC is NCHAN/10 rounded up. The value of BINTYP depends on the
	;way the stepwidths are determined. This format is suitable only when the esd associated
	;with each profile point can be calculated directly from the given intensity (i.e. sI =  ` I ). If
	;the esd can not be obtained in this way, then one of the other data formats which explicitly
	;input the esd should be used (see below).
	;If BINTYP is 'CONST' then the data has a constant stepwidth; BCOEF(1) is the offset for
	;the first step and BCOEF(2) is the stepsize, both in microseconds or centidegrees. If
	;BINTYP is 'LOG6' then the data has a specific logarithmic scaling for the stepwidth;
	;BCOEF(1) is the offset in microseconds and BCOEF(2) is either 102.4 or 409.6 which is
	;the allowed stepsize increment for the Los Alamos Model 6 TOF clock. If BINTYP equals
	;'TIME_MAP' then a complete time map which defines the step sizes and positions is read
	;from another section of this file (see below) and BCOEF(1) is the number of the time map
	;to be read. If BINTYP is 'LPSD' then BCOEF(1) is the nominal 2Q value in centidegrees
	;for the linear position sensitive detector (LPSD), BCOEFF(2) is the channel number for
	;this 2Q angle, and BCOEF(3) is the width of one channel in centidegrees at this position.
	;Usually CW data has BINTYP equal to 'CONST' or 'LPSD' and TOF data can be any one
	;of the BINTYP`s mentioned above except 'LPSD'.
	;This header is followed by 'NREC' records containing the data in the following format.
	;(10(I2,F6.0))(NCTR(I),YO(I),I=1,NCHAN)
	;where NCTR is the number of counters used to collect the data for each step and YO is the
	;number of counts per counter observed. If NCTR is zero or missing then it is assumed to
	;be one.
	;*********************************************************************************************
	;
	outstr=$
		'BANK 1'+strcompress(string(N_ELEMENTS(WW)))+strcompress(string((N_ELEMENTS(WW)-1)/10+1))+$
		' CONST'+strcompress(string(round(100.*min(XX))))+strcompress(string(round(step*100.)))+' 0 0 STD     '
	;
	;*********************************************************************************************
	;The first alternate form for the header is designed to handle data which has been corrected
	;for some instrumental effects (incident intensity, absorption, etc.) so that the weights can
	;no longer be derived directly from the intensities. The header is:
	;('BANK',3I,A,4F,' ESD')IBANK,NCHAN,NREC,BINTYP,(BCOEF(I),I=1,4)
	;As above the value of IBANK must be unique within a data file. Each data point consists
	;of the intensity and an esd for that intensity. Thus there are 5 data points per record and
	;NREC is NCHAN/5 rounded up. The values of BINTYP and BCOEF are the same as
	;described for the standard data header.
	;The data records are in the following form:
	;(10F8)(YOT(I),YE(I),I=1,NCHAN)
	;where YOT is the intensity and YE is the esd for YOT. The decimal point must be given to
	;force its proper placement in these values.
	;*********************************************************************************************
	;
	IF N_ELEMENTS(EE) EQ N_ELEMENTS(WW) THEN outstr=$	
		'BANK 1'+strcompress(string(N_ELEMENTS(WW)))+strcompress(string((N_ELEMENTS(WW)-1)/5+1))+$
		' CONST'+strcompress(string(round(100.*min(XX))))+strcompress(string(round(step*100.)))+' 0 0 ESD     '
	;
	;*********************************************************************************************
	;The second alternate form for the header is designed to handle data which has been
	;collected on a diffractometer where the steps between values is somewhat uneven (e.g.
	;TOF data collected on the diffractometers at the ISIS Facility, Rutherford-Appleton
	;Laboratory, UK) The header is:
	;('BANK',3I,A,4F,' ALT')IBANK,NCHAN,NREC,BINTYP,(BCOEF(I),I=1,4)
	;As above the value of IBANK must be unique within a data file. For TOF data the value of
	;IBANK must corrrespond to the bank number found in the instrument parameter file for the
	;detectors which produced the data. This correspondence is not needed for CW data. Each
	;data point consists of the TOF, intensity and an esd for that intensity. Thus there are 4 data
	;points per record and NREC is NCHAN/4 rounded up. The values of BINTYP and
	;BCOEF are the same as described for the standard data header with the addition of
	;BINTYP = 'RALF' which forces the use of the TOFT values below for the positions. In
	;this case BCOEF(1) is the starting TOF in msec*32, BCOEF(2) is the width of the first step
	;in msec*32, BCOEF(3) is the start of the log scaled step portion of the data in msec*32 and
	;BCOEF(4) is the resolution to be used in approximating the size of each step beyond
	;BCOEF(3).
	;The data records are in the following form:
	;(4(F8.0,F7.4,F5.4))((TOFT(I),YOT(I),YE(I),I=1,NCHAN)
	;where TOFT is in microsteps (TOF in pulses of width CLCKWDT times 32 or
	;centidegrees times 32), YOT is the normalized count and YE is the esd for YOT. Normally
	;the decimal point is left off the values and the format statement properly scales the values.
	;*********************************************************************************************
	;
	IF ABS(stepdev) GT 1E-5 THEN outstr=$
		'BANK 1'+strcompress(string(N_ELEMENTS(WW)))+strcompress(string((N_ELEMENTS(WW)-1)/4+1))+$
		' RALF'+strcompress(string(round(32.*100.*XX(0))))+strcompress(string(round((XX(1)-XX(0))*100.*32.)))+strcompress(string(round(max(XX)*100.*32.)))+strcompress(string(round(step*100.*32.)))+' ALT     '
	outstr=outstr+'                                                                                              '
	PRINTF,unit,strmid(outstr,0,80)
	gout=gout+strmid(outstr,0,80)
	outstr=''
	IF ABS(stepdev) LE 1E-5 THEN BEGIN
		IF N_ELEMENTS(EE) EQ N_ELEMENTS(WW) THEN BEGIN
			IF k EQ N_ELEMENTS(Data(0,*))-1 THEN PRINT,'GSAS ESD format'
			FOR i=0,N_ELEMENTS(WW)-1,5 DO BEGIN
				FOR j=0,5 DO BEGIN
					IF (i+j) LT N_ELEMENTS(WW) THEN BEGIN
						strng='        '+STRING(ROUND(WW(i+j)))
						outstr=outstr+STRMID(strng,STRLEN(strng)-8,STRLEN(strng))
						strng='        '+STRING(ROUND(EE(i+j)))
						outstr=outstr+STRMID(strng,STRLEN(strng)-8,STRLEN(strng))
					ENDIF
				ENDFOR
				PRINTF,unit,strmid(outstr,0,80)
				gout=gout+strmid(outstr,0,80)
				outstr=''
			ENDFOR
		ENDIF ELSE BEGIN
			IF k EQ N_ELEMENTS(Data(0,*))-1 THEN PRINT,'GSAS STD (CONST) format'
			FOR i=0,N_ELEMENTS(WW)-1,10 DO BEGIN
				FOR j=0,10 DO BEGIN
					IF (i+j) LT N_ELEMENTS(WW) THEN BEGIN
						strng='  1'
						outstr=outstr+STRMID(strng,STRLEN(strng)-2,STRLEN(strng))
						strng='        '+STRING(ROUND(WW(i+j)))
						outstr=outstr+STRMID(strng,STRLEN(strng)-6,STRLEN(strng))
					ENDIF
				ENDFOR
				PRINTF,unit,strmid(outstr,0,80)
				PRINT,strmid(outstr,0,80)
				gout=gout+strmid(outstr,0,80)
				outstr=''
			ENDFOR
		ENDELSE
	ENDIF ELSE BEGIN
		IF N_ELEMENTS(EE) NE N_ELEMENTS(WW) THEN EE=SQRT(WW)
		IF k EQ N_ELEMENTS(Data(0,*))-1 THEN PRINT,'GSAS ALT (RALF) format'
		FOR i=0,N_ELEMENTS(WW)-1,4 DO BEGIN
			FOR j=0,4 DO BEGIN
				IF (i+j) LT N_ELEMENTS(WW) THEN BEGIN
					strng='        '+STRING(ROUND(100.*32.*XX(i+j)))
					outstr=outstr+STRMID(strng,STRLEN(strng)-8,STRLEN(strng))
					strng=STRCOMPRESS((WW(i+j)),/RE)
					IF strlen(strng) LT 7 THEN strng=strmid('       '+strng,strlen(strng),strlen(strng)+7)
					outstr=outstr+STRMID(strng,0,7)
					strng=STRCOMPRESS((EE(i+j)),/RE)
					IF strlen(strng) LT 5 THEN strng=strmid('     '+strng,strlen(strng),strlen(strng)+5)
					outstr=outstr+STRMID(strng,0,5)
				ENDIF
			ENDFOR
			PRINTF,unit,strmid(outstr,0,80)
			gout=gout+strmid(outstr,0,80)
			outstr=''
		ENDFOR
	ENDELSE
	FREE_LUN,unit
;	IF N_ELEMENTS(Data(0,*)) EQ 1 THEN OPENW ,unit, FileName+'.gda', /get_lun ELSE BEGIN
;          IF numflag THEN BEGIN
;            sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
;            OPENW ,unit, FileName+'_'+sub+'.gda', /get_lun
;          ENDIF ELSE BEGIN
;       	    OPENW ,unit, FileName+'_'+STRCOMPRESS(ROUND(k+EXP(CEIL(ALOG10(N_ELEMENTS(Data(0,*))))*ALOG(10))),/RE)+'.gda', /get_lun
;       	  ENDELSE
;	ENDELSE
	IF N_ELEMENTS(Data(0,*)) EQ 1 THEN BEGIN
		OPENW ,unit, FileName+'.gda', /get_lun 
	ENDIF ELSE BEGIN
          IF numflag THEN BEGIN
            sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
            OPENW ,unit, FileName+'_'+sub+'.gda', /get_lun
          ENDIF ELSE BEGIN
       	    OPENW ,unit, FileName+'_'+STRCOMPRESS(ROUND(k+EXP(CEIL(ALOG10(N_ELEMENTS(Data(0,*))))*ALOG(10))),/RE)+'.gda', /get_lun
       	  ENDELSE
	ENDELSE
	PRINTF,unit,gout
	FREE_LUN,unit
ENDFOR
;** End of implementation for GSAS

return

mis:print,!err_string
end
pro export_gtx, FileNameInit , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                                , PR=p, PV=pv, PAR_TXT=p_txt       $
                                , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                                , Z_tit=zt  , OTHER_TIT=ot
;** *********
;** 
;**	Standard call for a data-write procedure called by LAMP.
;**
;
;	This macro export_gtx exports data files readable for GSAS
;	Filename.gsa and Filename.gda (no line-feeds)
;   Depending on angular stepwidth and available ESDs one of three file formats will be written
;   so, no interpolation is necessary anymore!
;   At this stage, only the first diagram of a series is written out
;   Count rates and ESDs are written as integers
;   zero counts and negative angles are left out
;		  
;  *** modified by Thomas Hansen and Andrew Wills 31 August 2001		  
;  *** cleaned up by Thomas Hansen 19 September 2001
;  *** modern filenames established (Thomas Hansen, as done for Hermann Pauly)		  
;		  
;**	Keywords:		  
;**		  XC       =  vector of x coordinates.
;**		  YC       = [vector of y coordinates.]
;**		  ZC       = [vector of z coordinates.]
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to PR (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size) or 0

;CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
;ON_IOERROR,mis

Filename=FileNameInit
IF KEYWORD_SET(x) AND NOT KEYWORD_SET(e) THEN e=SQRT(data)
IF NOT (KEYWORD_SET(x) AND KEYWORD_SET(e) AND KEYWORD_SET(pv)) THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN BEGIN
    IF N_ELEMENTS(FilenameInit) GT 1 THEN BEGIN
      IF N_PARAMS() EQ 1 THEN data='data'
      tmp=FileNameInit
      Filename=data
      data=tmp
      flag=1
    ENDIF 
    TAKE_DATP,datpp
    datp=datpp
  ENDIF ELSE IF N_ELEMENTS(data) EQ 1 THEN BEGIN
    tmp=FileNameInit
    Filename=data
    data=tmp
  ENDIF 
  x=datp.x
  n=datp.n
  y=datp.y
  z=datp.z
  e=datp.e
  p=datp.p
  par_txt=datp.par_txt
  pv=datp.pv
  p_txt=datp.par_txt
  wt=datp.w_tit
  xt=datp.x_tit
  yt=datp.y_tit
  zt=datp.z_tit
  ot=datp.other_tit
ENDIF 
subs=N_ELEMENTS(data(0,*))
IF subs GT 1 THEN BEGIN
  FILENAME=FILENAME
   PRINT,subs,' subsets'
  IF (pv(29,subs-1)-pv(29,0)) EQ (subs-1) THEN numflag=1 ELSE numflag=0
ENDIF

OPENW ,unit, FileName+'.gsa', /get_lun 
OPENW ,script, FileName+'.cif', /get_lun 
PRINT ,FileName+'.gsa'
;*********************************************************************************************
;The input powder data file for GSAS is a direct access, fixed record length file. It contains
;a few header records followed by blocks of data each corresponding to an individual	
;powder pattern. Each block is preceded by its own header. All records must be 80
;characters in length. The main header has one or two records:
;(80A)TITLE
;A title record is first; the information is used by GSAS for titles only. GSAS can only use
;the first 66 characters of this record but it must be filled out to 80 characters.
;('Instrument parameter',60A)FNAME
;An optional record that must start with the 20 characters shown followed by the instrument
;parameter file name. If this record is omitted, GSAS requests this file name from the user
;in EXPEDT.
;*********************************************************************************************
PRINTF,script,'loop_'
PRINTF,script,'_riet_meas_datafile_name'
PRINTF,script,'_pd_meas_orientation_omega'
PRINTF,script,'_pd_meas_orientation_chi'
PRINTF,script,'_pd_meas_orientation_phi'
PRINTF,unit,strmid(wt+ot+'                                                                                        ',0,80)
;gout=strmid(wt+ot+'                                                                                        ',0,80)
;gout=gout+strmid('Instrument parameter'+' inst_d20.prm'+'                                                                                        ',0,80)
PRINTF,unit,strmid('Instrument parameter'+' inst_d20.prm'+'                                                                                        ',0,80)
step=0.0
PRINT,strmid(wt+ot+'                                                                                        ',0,80)
XX=x(*,0)
steps=x(1:N_ELEMENTS(XX)-1,0)-x(0:N_ELEMENTS(XX)-2,0)
step=Moment(steps,sdev=stepdev)
step=step(0)
PRINT,"Average angular steps: ", step,"+/-",stepdev, " degrees"
;** Begin of implementation for GSAS (containing ESDs)
FOR k=0,N_ELEMENTS(Data(0,*))-1 DO BEGIN
    WW=Data(*,k)
    EE=0
    IF KEYWORD_SET(E) THEN IF N_ELEMENTS(E) EQ N_ELEMENTS(Data) THEN EE=E(*,k)
    XX=X(*,k<(N_ELEMENTS(x(0,*))-1))
	index=WHERE(XX GT 0)
	IF KEYWORD_SET(E) THEN EE=EE(index)
	XX=X(index)
	WW=WW(index)
	index=WHERE(WW GT 0)
	IF KEYWORD_SET(E) THEN EE=EE(index)
 	XX=XX(index)
	WW=WW(index)
	IF KEYWORD_SET(pv) THEN BEGIN
	  PRINT,filename+'.gsa('+STRCOMPRESS(k,/RE)+')'+strcompress(pv(14,k))+strcompress(pv(15,k))+strcompress(pv(16,k))
      PRINTF,script,filename+'.gsa('+STRCOMPRESS(k,/RE)+')'+strcompress(pv(14,k))+strcompress(pv(15,k))+strcompress(pv(16,k))
    ENDIF
	;*********************************************************************************************
	;Then follows a number of data blocks each beginning with a header. The header record is
	;in free format and has different forms depending on the type of data that follows it. For
	;standard type data the header is:
	;('BANK',3I,A,4F,' STD')IBANK,NCHAN,NREC,BINTYP,(BCOEF(I),I=1,4)
	;The fields are separated by spaces and 'BANK' must be upper case. IBANK is the bank
	;number; if it is zero the data block is from the incident beam monitor. The value of IBANK
	;must be unique within a data file. For TOF data the value of IBANK must corrrespond to
	;the bank number found in the instrument parameter file for the detectors which produced
	;the data. This correspondence is not needed for CW data. NCHAN is the number of data
	;points in the block of data and NREC is the number of records. There are 10 data points
	;per record so NREC is NCHAN/10 rounded up. The value of BINTYP depends on the
	;way the stepwidths are determined. This format is suitable only when the esd associated
	;with each profile point can be calculated directly from the given intensity (i.e. sI =  ` I ). If
	;the esd can not be obtained in this way, then one of the other data formats which explicitly
	;input the esd should be used (see below).
	;If BINTYP is 'CONST' then the data has a constant stepwidth; BCOEF(1) is the offset for
	;the first step and BCOEF(2) is the stepsize, both in microseconds or centidegrees. If
	;BINTYP is 'LOG6' then the data has a specific logarithmic scaling for the stepwidth;
	;BCOEF(1) is the offset in microseconds and BCOEF(2) is either 102.4 or 409.6 which is
	;the allowed stepsize increment for the Los Alamos Model 6 TOF clock. If BINTYP equals
	;'TIME_MAP' then a complete time map which defines the step sizes and positions is read
	;from another section of this file (see below) and BCOEF(1) is the number of the time map
	;to be read. If BINTYP is 'LPSD' then BCOEF(1) is the nominal 2Q value in centidegrees
	;for the linear position sensitive detector (LPSD), BCOEFF(2) is the channel number for
	;this 2Q angle, and BCOEF(3) is the width of one channel in centidegrees at this position.
	;Usually CW data has BINTYP equal to 'CONST' or 'LPSD' and TOF data can be any one
	;of the BINTYP`s mentioned above except 'LPSD'.
	;This header is followed by 'NREC' records containing the data in the following format.
	;(10(I2,F6.0))(NCTR(I),YO(I),I=1,NCHAN)
	;where NCTR is the number of counters used to collect the data for each step and YO is the
	;number of counts per counter observed. If NCTR is zero or missing then it is assumed to
	;be one.
	;*********************************************************************************************
	outstr=$
		'BANK'+strcompress(k+1)+strcompress(string(N_ELEMENTS(WW)))+strcompress(string((N_ELEMENTS(WW)-1)/10+1))+$
		' CONST'+strcompress(string(round(100.*min(XX))))+strcompress(string(round(step*100.)))+' 0 0 STD     '
	;*********************************************************************************************
	;The first alternate form for the header is designed to handle data which has been corrected
	;for some instrumental effects (incident intensity, absorption, etc.) so that the weights can
	;no longer be derived directly from the intensities. The header is:
	;('BANK',3I,A,4F,' ESD')IBANK,NCHAN,NREC,BINTYP,(BCOEF(I),I=1,4)
	;As above the value of IBANK must be unique within a data file. Each data point consists
	;of the intensity and an esd for that intensity. Thus there are 5 data points per record and
	;NREC is NCHAN/5 rounded up. The values of BINTYP and BCOEF are the same as
	;described for the standard data header.
	;The data records are in the following form:
	;(10F8)(YOT(I),YE(I),I=1,NCHAN)
	;where YOT is the intensity and YE is the esd for YOT. The decimal point must be given to
	;force its proper placement in these values.
	;*********************************************************************************************
	IF N_ELEMENTS(EE) EQ N_ELEMENTS(WW) THEN outstr=$	
		'BANK'+strcompress(k+1)+strcompress(string(N_ELEMENTS(WW)))+strcompress(string((N_ELEMENTS(WW)-1)/5+1))+$
		' CONST'+strcompress(string(round(100.*min(XX))))+strcompress(string(round(step*100.)))+' 0 0 ESD     '
	;*********************************************************************************************
	;The second alternate form for the header is designed to handle data which has been
	;collected on a diffractometer where the steps between values is somewhat uneven (e.g.
	;TOF data collected on the diffractometers at the ISIS Facility, Rutherford-Appleton
	;Laboratory, UK) The header is:
	;('BANK',3I,A,4F,' ALT')IBANK,NCHAN,NREC,BINTYP,(BCOEF(I),I=1,4)
	;As above the value of IBANK must be unique within a data file. For TOF data the value of
	;IBANK must corrrespond to the bank number found in the instrument parameter file for the
	;detectors which produced the data. This correspondence is not needed for CW data. Each
	;data point consists of the TOF, intensity and an esd for that intensity. Thus there are 4 data
	;points per record and NREC is NCHAN/4 rounded up. The values of BINTYP and
	;BCOEF are the same as described for the standard data header with the addition of
	;BINTYP = 'RALF' which forces the use of the TOFT values below for the positions. In
	;this case BCOEF(1) is the starting TOF in msec*32, BCOEF(2) is the width of the first step
	;in msec*32, BCOEF(3) is the start of the log scaled step portion of the data in msec*32 and
	;BCOEF(4) is the resolution to be used in approximating the size of each step beyond
	;BCOEF(3).
	;The data records are in the following form:
	;(4(F8.0,F7.4,F5.4))((TOFT(I),YOT(I),YE(I),I=1,NCHAN)
	;where TOFT is in microsteps (TOF in pulses of width CLCKWDT times 32 or
	;centidegrees times 32), YOT is the normalized count and YE is the esd for YOT. Normally
	;the decimal point is left off the values and the format statement properly scales the values.
	;*********************************************************************************************
	IF ABS(stepdev) GT 1E-5 THEN outstr=$
		'BANK'+strcompress(k+1)+strcompress(string(N_ELEMENTS(WW)))+strcompress(string((N_ELEMENTS(WW)-1)/4+1))+$
		' RALF'+strcompress(string(round(32.*100.*XX(0))))+strcompress(string(round((XX(1)-XX(0))*100.*32.)))+strcompress(string(round(max(XX)*100.*32.)))+strcompress(string(round(step*100.*32.)))+' ALT     '
	outstr=outstr+'                                                                                              '
	PRINTF,unit,strmid(outstr,0,80)
;	gout=gout+strmid(outstr,0,80)
	outstr=''
	IF ABS(stepdev) LE 1E-5 THEN BEGIN
		IF N_ELEMENTS(EE) EQ N_ELEMENTS(WW) THEN BEGIN
			IF k EQ N_ELEMENTS(Data(0,*))-1 THEN PRINT,'GSAS ESD format'
			FOR i=0,N_ELEMENTS(WW)-1,5 DO BEGIN
				FOR j=0,5 DO BEGIN
					IF (i+j) LT N_ELEMENTS(WW) THEN BEGIN
						strng='        '+STRING(ROUND(WW(i+j)))
						outstr=outstr+STRMID(strng,STRLEN(strng)-8,STRLEN(strng))
						strng='        '+STRING(ROUND(EE(i+j)))
						outstr=outstr+STRMID(strng,STRLEN(strng)-8,STRLEN(strng))
					ENDIF
				ENDFOR
				PRINTF,unit,strmid(outstr,0,80)
;				gout=gout+strmid(outstr,0,80)
				outstr=''
			ENDFOR
		ENDIF ELSE BEGIN
			IF k EQ N_ELEMENTS(Data(0,*))-1 THEN PRINT,'GSAS STD (CONST) format'
			FOR i=0,N_ELEMENTS(WW)-1,10 DO BEGIN
				FOR j=0,10 DO BEGIN
					IF (i+j) LT N_ELEMENTS(WW) THEN BEGIN
						strng='  1'
						outstr=outstr+STRMID(strng,STRLEN(strng)-2,STRLEN(strng))
						strng='        '+STRING(ROUND(WW(i+j)))
						outstr=outstr+STRMID(strng,STRLEN(strng)-6,STRLEN(strng))
					ENDIF
				ENDFOR
				PRINTF,unit,strmid(outstr,0,80)
				PRINT,strmid(outstr,0,80)
;				gout=gout+strmid(outstr,0,80)
				outstr=''
			ENDFOR
		ENDELSE
	ENDIF ELSE BEGIN
		IF N_ELEMENTS(EE) NE N_ELEMENTS(WW) THEN EE=SQRT(WW)
		IF k EQ N_ELEMENTS(Data(0,*))-1 THEN PRINT,'GSAS ALT (RALF) format'
		FOR i=0,N_ELEMENTS(WW)-1,4 DO BEGIN
			FOR j=0,4 DO BEGIN
				IF (i+j) LT N_ELEMENTS(WW) THEN BEGIN
					strng='        '+STRING(ROUND(100.*32.*XX(i+j)))
					outstr=outstr+STRMID(strng,STRLEN(strng)-8,STRLEN(strng))
					strng=STRCOMPRESS((WW(i+j)),/RE)
					IF strlen(strng) LT 7 THEN strng=strmid('       '+strng,strlen(strng),strlen(strng)+7)
					outstr=outstr+STRMID(strng,0,7)
					strng=STRCOMPRESS((EE(i+j)),/RE)
					IF strlen(strng) LT 5 THEN strng=strmid('     '+strng,strlen(strng),strlen(strng)+5)
					outstr=outstr+STRMID(strng,0,5)
				ENDIF
			ENDFOR
			PRINTF,unit,strmid(outstr,0,80)
;			gout=gout+strmid(outstr,0,80)
			outstr=''
		ENDFOR
	ENDELSE
ENDFOR
FREE_LUN,script
FREE_LUN,unit
;OPENW ,unit, FileName+'.gda', /get_lun 
;PRINTF,unit,gout
;FREE_LUN,unit

return

mis:print,!err_string
end
pro export_prn, FileNameInit , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                               , PR=p, PV=pv, PAR_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot $
                               ,datp=datp $
                               ;, nolamp=nolamp;
                               ,par=par,comment=comment $
                               , bad=bad
;** *********
;**
;**	Standard call for a data-write procedure called by LAMP.
		  
;**	Keywords:		  
;**		  XC       =  vector of x coordinates.
;**		  YC       = [vector of y coordinates.]
;**		  ZC       = [vector of z coordinates.]
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to PR (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size) or 0
;
;+
; Export of3 column format data, e.g. for MAUD (Luca Lutterotti)
; Done by Thomas Hansen for Romana Frattini
;
;                       X,Y,Sigma format with header lines.
;                       In all cases the first 6 lines are considered
;                       as comments.
;                       If in the first line (left ajusted) appears the
;                       keyword XYDATA, then the following 5 lines are
;                       considered as the heading of the file. Among
;                       these 5 lines the following keywords and values
;                       have a meaning to the program:
;                        -> INTER  fac_x  fac_y  Interpol  Stepin
;                        -> TEMP  tsamp
;                        fac_x  internal multiplier of X-values
;                        fac_y  internal multiplier of Y and Sigma-values
;                        Interpol=0 data are given at constant step
;                                   or variable step is used in the program
;                                =1 The variable step data are interpolated
;                                   internally to the constant step Stepin.
;
;                       If no sigma values are provided the program assumes
;                       that sigma(Y)=sqrt(Y).
;                       You can add comments to the data file if they
;                       start with the character ! in the first position
;                       of the line. These lines are ignored by the program.
;-
if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION sys_dep')

CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
ON_IOERROR,mis

;IF NOT KEYWORD_SET(nolamp) THEN BEGIN
;    XiCute,'@lamp.cbk'
;ENDIF
Filename=FilenameInit
IF KEYWORD_SET(x) AND NOT KEYWORD_SET(e) THEN e=SQRT(data)
IF NOT (KEYWORD_SET(x) AND KEYWORD_SET(e) AND KEYWORD_SET(pv)) THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN BEGIN
    IF N_ELEMENTS(FilenameInit) GT 1 THEN BEGIN
      IF N_PARAMS() EQ 1 THEN data='data'
      tmp=FilenameInit
      Filename=data
      data=tmp
      flag=1
    ENDIF 
    TAKE_DATP,datpp
    datp=datpp
  ENDIF ELSE IF N_ELEMENTS(data) EQ 1 THEN BEGIN
    tmp=FilenameInit
    Filename=data
    data=tmp
  ENDIF 
  x=datp.x
  n=datp.n
  y=datp.y
  z=datp.z
  e=datp.e
  p=datp.p
  par_txt=datp.par_txt
  pv=datp.pv
  p_txt=datp.par_txt
  wt=datp.w_tit
  xt=datp.x_tit
  yt=datp.y_tit
  zt=datp.z_tit
  ot=datp.other_tit
ENDIF 
help,filename,data
subs=N_ELEMENTS(data(0,*))
newpos=0
flag=0
REPEAT BEGIN
  pos=newpos
  ii=execute("newpos=STRPOS(FILENAME,SYS_DEP('DIVIDER'),pos+1)")
  IF newpos GE 0 THEN flag=1
ENDREP UNTIL newpos LT 0
IF NOT flag THEN pos=-1
IF subs GT 1 THEN BEGIN
;  FILENAME=FILENAME+'_'
;  FILENAME=STRMID(FILENAME,pos+1,3)
  PRINT,subs,' subsets'
  IF (pv(29,subs-1)-pv(29,0)) EQ (subs-1) THEN numflag=1 ELSE numflag=0
ENDIF
shortname=filename
print,STRPOS(shortname,SYS_DEP('DIVIDER'))
while STRPOS(shortname,SYS_DEP('DIVIDER')) GE 0 do begin
  shortname=strmid(shortname,STRPOS(shortname,SYS_DEP('DIVIDER'))+1, strlen(shortname))
  print,shortname,STRPOS(shortname,SYS_DEP('DIVIDER'))
endwhile
OPENW ,cif, STRCOMPRESS(FileName)+'.cif', /get_lun,width=256
PRINTF,cif,'loop_'
PRINTF,cif,'_riet_meas_datafile_name'
PRINTF,cif,'_pd_meas_orientation_omega'
PRINTF,cif,'_pd_meas_orientation_chi'
PRINTF,cif,'_pd_meas_orientation_phi'
FOR k=0,subs-1 DO BEGIN
  sub=''
  IF subs GT 1 THEN BEGIN
    digits=STRLEN(STRCOMPRESS(subs,/RE))
    sub=STRMID(STRCOMPRESS(10^digits+k,/RE),0,digits+1)
    IF numflag THEN sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
  ENDIF
  PRINTF,cif,STRCOMPRESS(shortName)+sub+'.prn',pv(14,k)-90,pv(15,k)-90,pv(16,k)
  OPENW ,unit, STRCOMPRESS(FileName)+sub+'.prn', /get_lun
  PRINT,STRCOMPRESS(shortName,/RE)+sub+'.prn'
  ;PRINTF,unit,'# XYDATA ',strmid(STRCOMPRESS(wt) ,0,73)  
  ;PRINTF,unit,'# INTER ',1,1,0,0.1
  ;PRINTF,unit,'# TEMP ',pv([12,11,10],k)
  ;PRINTF,unit,'# ',strmid(ot ,0,76)   
  ;PRINTF,unit,'# ',strmid(ot  ,0,76)   
  ;PRINTF,unit,'# Monitor/counts, Counting time/sec: ',n(0,0,0),n(0,1<(N_ELEMENTS(n(0,*,0))-1),0)
  FOR i=0,N_ELEMENTS(data(*,k))-1 DO BEGIN
    IF x(i,k<(N_ELEMENTS(x(0,*))-1)) GE 0 THEN PRINTF,unit,FORMAT='(F9.4,F18.3,F12.3)',(x(i,k<(N_ELEMENTS(x(0,*))-1)))<(180.),(data(i,k))<(1.0E12),(e(i,k))<(1.0E6)
 ENDFOR
  FREE_LUN,unit
ENDFOR
FREE_LUN,cif

return

mis:print,!err_string
end
pro export_xy, FileNameInit , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                               , PR=p, PV=pv, PAR_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot $
                               ,datp=datp $
                               ;, nolamp=nolamp;
                               ,par=par,comment=comment $
                               , bad=bad
;** *********
;**
;**	Standard call for a data-write procedure called by LAMP.
		  
;**	Keywords:		  
;**		  XC       =  vector of x coordinates.
;**		  YC       = [vector of y coordinates.]
;**		  ZC       = [vector of z coordinates.]
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to PR (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size) or 0
;
;+
; Export of Fullprof data format INSTR=10
;
;                       X,Y,Sigma format with header lines.
;                       In all cases the first 6 lines are considered
;                       as comments.
;                       If in the first line (left ajusted) appears the
;                       keyword XYDATA, then the following 5 lines are
;                       considered as the heading of the file. Among
;                       these 5 lines the following keywords and values
;                       have a meaning to the program:
;                        -> INTER  fac_x  fac_y  Interpol  Stepin
;                        -> TEMP  tsamp
;                        fac_x  internal multiplier of X-values
;                        fac_y  internal multiplier of Y and Sigma-values
;                        Interpol=0 data are given at constant step
;                                   or variable step is used in the program
;                                =1 The variable step data are interpolated
;                                   internally to the constant step Stepin.
;
;                       If no sigma values are provided the program assumes
;                       that sigma(Y)=sqrt(Y).
;                       You can add comments to the data file if they
;                       start with the character ! in the first position
;                       of the line. These lines are ignored by the program.
;-
if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION sys_dep')

CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
ON_IOERROR,mis

;IF NOT KEYWORD_SET(nolamp) THEN BEGIN
;    XiCute,'@lamp.cbk'
;ENDIF
Filename=FilenameInit
IF KEYWORD_SET(x) AND NOT KEYWORD_SET(e) THEN e=SQRT(data)
IF NOT (KEYWORD_SET(x) AND KEYWORD_SET(e) AND KEYWORD_SET(pv)) THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN BEGIN
    IF N_ELEMENTS(FilenameInit) GT 1 THEN BEGIN
      IF N_PARAMS() EQ 1 THEN data='data'
      tmp=FilenameInit
      Filename=data
      data=tmp
      flag=1
    ENDIF 
    TAKE_DATP,datpp
    datp=datpp
  ENDIF ELSE IF N_ELEMENTS(data) EQ 1 THEN BEGIN
    tmp=FilenameInit
    Filename=data
    data=tmp
  ENDIF 
  x=datp.x
  n=datp.n
  y=datp.y
  z=datp.z
  e=datp.e
  p=datp.p
  par_txt=datp.par_txt
  pv=datp.pv
  p_txt=datp.par_txt
  wt=datp.w_tit
  xt=datp.x_tit
  yt=datp.y_tit
  zt=datp.z_tit
  ot=datp.other_tit
ENDIF 
help,filename,data
subs=N_ELEMENTS(data(0,*))
newpos=0
flag=0
REPEAT BEGIN
  pos=newpos
  ii=execute("newpos=STRPOS(FILENAME,SYS_DEP('DIVIDER'),pos+1)")
  IF newpos GE 0 THEN flag=1
ENDREP UNTIL newpos LT 0
IF NOT flag THEN pos=-1
IF subs GT 1 THEN BEGIN
  FILENAME=FILENAME+'_'
;  FILENAME=STRMID(FILENAME,pos+1,3)
  PRINT,subs,' subsets'
  IF (pv(29,subs-1)-pv(29,0)) EQ (subs-1) THEN numflag=1 ELSE numflag=0
ENDIF
FOR k=0,subs-1 DO BEGIN
  sub=''
  IF subs GT 1 THEN BEGIN
    digits=STRLEN(STRCOMPRESS(subs,/RE))
    sub=STRMID(STRCOMPRESS(10^digits+k,/RE),0,digits+1)
    IF numflag THEN sub=STRCOMPRESS(ROUND(pv(29,k)),/RE)
  ENDIF
  OPENW ,unit, STRCOMPRESS(FileName)+sub+'.xy', /get_lun
  PRINT,STRCOMPRESS(FileName,/RE)+sub+'.xy'
  PRINTF,unit,'# XYDATA ',strmid(STRCOMPRESS(wt) ,0,73)  
  PRINTF,unit,'# INTER ',1,1,0,0.1
  PRINTF,unit,'# TEMP ',pv([12,11,10],k)
  PRINTF,unit,'# ',strmid(ot ,0,76)   
  PRINTF,unit,'# ',strmid(ot  ,0,76)   
  PRINTF,unit,'# Monitor/counts, Counting time/sec: ',n(0,0,0),n(0,1<(N_ELEMENTS(n(0,*,0))-1),0)
  FOR i=0,N_ELEMENTS(data(*,k))-1 DO BEGIN
    IF x(i,k<(N_ELEMENTS(x(0,*))-1)) GE 0 THEN PRINTF,unit,FORMAT='(F9.4,F18.3,F12.3)',(x(i,k<(N_ELEMENTS(x(0,*))-1)))<(180.),(data(i,k))<(1.0E12),(e(i,k))<(1.0E6)
 ENDFOR

  FREE_LUN,unit

ENDFOR

return

mis:print,!err_string
end
PRO exriet ,w,filename,STEP=step,HELP=help,  general=general,illdat=illdat,numors=numors,n0=n0,n1=n1
IF KEYWORD_SET(help) THEN BEGIN
  print,''
  print,'                         PRO ExRiet.PRO'
  print,''
  print,'LAMP-IDL Macro (Procedure) started: 29-Oct-96 by Th.Hansen, ILL-Grenoble (D20)'
  print,'Output of single diagrams in D1B/D1A/D2B-format for Fullprof etc. (*.dat)
  print,'and in GSAS-Format (sequential *.gsas and direct access *.gdat format)'
  print,'for Rietveld refinement calculations, 2*Theta scans are normally not foreseen ...'
  print,'In case of a 2Theta-scan W_new=UNIC(W_old) has eventually to be executed before'
  print,'For multiple diagrams (scans, strob. acq.) use fild20.pro, creating D1B-format'
  print,"Finally it should act (I'm dreamin' ...) like a LAMP / D20 version of SUMD2B"
  ;print,'This macro should be replaced by SumD20.Pro ....'
  print,''
  print,"Call:      EXRIET,W[,'filename'][,STEP=0.1][,/HELP]"
  ;print,"OR:        SUMD20,W[,'filename'][,STEP=0.1][,/HELP]"
  print,"Variables: Workspace (necessary, won't be changed)"
  print,"           basic filename different from 'd20' (optional, will be changed)"
  print,'Keywords:  STEP:   different 2*Theta stepwidth'
  print,'           HELP:   this hopefully helping text'
  print,'           ILLDAT: *.dat and *.ill exchanged (good for plotd1a ...)'
  print,'           GENERAL: *.dat in General Format for Two Axis Instruments (Type 5 in FullProf)'
  print,''
  print,'     Modification: 21-Aug-97 by Th.Hansen: bug-fix'
  print,'     Modification: 28-Aug-97 by Th.Hansen: bug-fix for GSAS format, 2nd line'
  print,'     modification: 03-Sep-97 by Th.Hansen: bug-fix for GSAS format: errors (variable count)'
  print,'     Modification: 29-Sep-97 by Th.Hansen: Addition of standard ILL format (Cerius)'
  print,'     Modification: 13-Oct-97 by Th.Hansen: gout sometimes too long ..., very small steps'
  print,'     Modification: 17-Nov-97 by Th.Hansen: so-called ILL-format (D2B, PlotD1A) corrected (Prassides)'
  print,'     Modification: 18-Nov-97 by Th.Hansen: automatic reading of numors - and correct titles (Prassides)'
  print,'Last modification: 10-Feb-98 by Th.Hansen: General Format for Two Axis Instruments (FullProf 5) (Fischer/Fauth)'
  print,''
ENDIF
IF N_ELEMENTS(w(*,0,0)) NE 1600 THEN BEGIN
  PRINT,'ATTENTION : Do you really have D20 data? Be aware of bugs!'
ENDIF
IF KEYWORD_SET(n0) THEN BEGIN
  IF NOT KEYWORD_SET(n1) THEN n1=n0
  IF n1 LE n0 THEN BEGIN
    n2=n1
    n1=n0
    n0=n1
  ENDIF
  numors=indgen(n1-n0+1)+n0
ENDIF
IF n_elements(filename) EQ 0 THEN filename = 'sum'
IF KEYWORD_SET(numors) THEN IF N_ELEMENTS(w) EQ 1 THEN IF N_PARAMS() EQ 1 THEN filename=w
IF STRLEN(filename) EQ 0 THEN filename ='sum'
IF (KEYWORD_SET(numors) AND N_ELEMENTS(numors) GT 1) THEN BEGIN
  filename=strmid(string(filename)+'000',0,3)
ENDIF ELSE IF (N_ELEMENTS(w(0,*)) GT 1) THEN filename=strmid(string(filename)+'000',0,3)
filename=string(filename)
filename = strcompress(filename,/REMOVE_ALL)
IF NOT KEYWORD_SET(numors) THEN BEGIN
  magnitude=ceil(alog10(n_elements(w(0,*))))
  nnn=0 
ENDIF ELSE BEGIN
  nnn=N_ELEMENTS(numors)-1  
  magnitude=ceil(alog10(nnn))
ENDELSE
ii=0
FOR k=0,nnn DO BEGIN
 IF KEYWORD_SET(numors) THEN BEGIN
   datp=1   
   w=rdrun(numors(k),datp=datp)
 ENDIF ELSE take_datp,datp 
 IF NOT KEYWORD_SET(step) THEN BEGIN
   step=TOTAL(datp.x(1:N_elements(datp.x(*,0,0))-1,0,0)-datp.x(0:N_elements(datp.x(*,0,0))-2,0,0))/(N_elements(datp.x(*,0,0))-1)
   dev=TOTAL(ABS((datp.x(1:N_elements(datp.x(*,0,0))-1,0,0)-datp.x(0:N_elements(datp.x(*,0,0))-2,0,0))-step))/(N_elements(datp.x(*,0,0))-1)
   IF dev GE step/10000. THEN BEGIN
     PRINT,'ATTENTION : Do you really have equidistant data? Deviation/step =', dev
     PRINT,'Otherwise you should better choose another export format (d20reg),'
     PRINT,'or interpolate your workspace before!'
   ENDIF
   print,'2Theta step : ',step
   IF datp.p(10<(N_ELEMENTS(datp.p)-1)) EQ 3.0 THEN step=datp.p(25<(N_ELEMENTS(datp.p)-1))
 ENDIF
 ;print,'Step: ',step
 e=datp.e
 IF N_ELEMENTS(e) NE N_ELEMENTS(w) THEN BEGIN
   e= SQRT(w)
   PRINT,'ATTENTION : error created (square root of counting rate)!'
 ENDIF
 cell = indgen(n_elements(w(*,0)))
 cell(*) = ROUND((datp.x(*,0)-datp.x(0,0))/step)
 factor=long(1)
 WHILE long(max(w)/factor) ge 1000000 DO factor=factor+1
 IF factor GT 1 THEN PRINT,'Factor is ',factor
 FOR i=0,n_elements(w(0,*))-1 DO BEGIN
  filext = strcompress(string(long(10.0^magnitude)+ii),/REMOVE_ALL)
  filext = strmid(filext,strlen(filext)-magnitude,magnitude)
  IF KEYWORD_SET(numors) THEN BEGIN
    print,'Numor ',numors(k),' => files : ',filename+filext+'.dat/.ill/.gsas/.gdat'
  ENDIF ELSE print,'Workspace => files : ',filename+filext+'.dat/.ill/.gsas/.gdat'
  ii=ii+1
  IF KEYWORD_SET(illdat) THEN BEGIN
    OPENW,ill,filename+filext+'.dat',/get_lun
    OPENW,out,filename+filext+'.ill',/get_lun
    OPENW,gen,filename+filext+'.gen',/get_lun
  ENDIF ELSE BEGIN
    IF KEYWORD_SET(general) THEN BEGIN
      OPENW,gen,filename+filext+'.dat',/get_lun
      OPENW,out,filename+filext+'.gen',/get_lun
      OPENW,ill,filename+filext+'.ill',/get_lun
    ENDIF ELSE BEGIN
      OPENW,out,filename+filext+'.dat',/get_lun
      OPENW,gen,filename+filext+'.gen',/get_lun
      OPENW,ill,filename+filext+'.ill',/get_lun
    ENDELSE
  ENDELSE
  OPENW,gsas,filename+filext+'.gsas',/get_lun
  line=STRMID(datp.w_tit,0,STRLEN(datp.w_tit)-1)+' '+STRMID(datp.other_tit,0,STRLEN(datp.other_tit)-1)
  line=STRMID(line,0,80<STRLEN(line))
  PRINTF,gen,'D1A5 D1A6 '
  PRINTF,gen,format='(A80)',datp.w_tit
  PRINTF,gen,format='(A80)',datp.other_tit
  p1=(N_ELEMENTS(datp.pv(*,0))-1)
  p2=(N_ELEMENTS(datp.pv(*,0))-1)
  PRINTF,gen,format='(I6,1X,2F10.3,i5,2f10.1)',max(cell)+1,datp.pv(12<p1,i<p2)<9999,datp.pv(11<p1,i<p2)<9999,1,datp.pv(30<p1,i<p2)<9999999,datp.n(0,0,i<((N_ELEMENTS(datp.n(0,0,*))-1)>0))/factor
  IF datp.pv(30<p1,i<p2) NE datp.n(0,0,i<((N_ELEMENTS(datp.n(0,0,*))-1)>0)) THEN BEGIN
    PRINT,'ATTENTION to non-integer normalisation factor (use only GENeral data format!) ',datp.pv(30<p1,i<p2) / datp.n(0,0,i<((N_ELEMENTS(datp.n(0,0,*))-1)>0))
  ENDIF
  PRINTF,ill,format='(A80)',line
  PRINTF,ill,format='(2I8,F8.3,3I8)',100,0,step,1,0,0;(max(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0)))-min(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0))))/step+1
  PRINTF,ill,format='(F8.2)',min(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0)))
  PRINTF,ill,format='(2F8.0,3F8.2)',(datp.n(0,0,i<((N_ELEMENTS(datp.n(0,0,*))-1)>0))/factor)<9999999,0,datp.pv((indgen(3)+10)<p1,i<p2)
  PRINTF,out,min(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0))),step,max(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0)))
  PRINTF,gen,format='(F10.4,F10.4,F10.4)',min(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0))),step,max(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0)))
  PRINTF,gsas,strmid(datp.w_tit+datp.other_tit+'                                                                                        ',0,80)
  gout=strmid(datp.w_tit+datp.other_tit+'                                                                                        ',0,80)
  outstr='BANK 1'+strcompress(string(max(cell)+1))+strcompress(string(max(cell)/10+1))+' CONST'+strcompress(string(round(100.*min(datp.x(*,i<((N_ELEMENTS(datp.x(0,*))-1)>0))))))+strcompress(string(round(step*100.)))+' 0 0 STD     '
  outstr=outstr+'                                                                                              '
  PRINTF,gsas,strmid(outstr,0,80)
  gout=gout+strmid(outstr,0,80)
  outstr=''
  genstr=''
  FOR j=0,max(cell) DO BEGIN
    IF j NE 0 THEN count_old=count
    index = where (cell eq j,count)
    IF count gt 0 THEN BEGIN
      IF e(index(0),i) GT 0 THEN count=long(round((SQRT(ABS(w(index(0),i)))/e(index(0),i))^2)) ELSE count=long(1)
      count = factor*count
      rate=long((w(index(0),i)+0.49999999)/factor)
      IF rate EQ 0 THEN BEGIN
        count=long(1)
      ENDIF
    ENDIF ELSE BEGIN          ;  no cell for this angle in the workspace
      print,'ATTENTION : no cell for this angle in the workspace!'
      print,'exriet.pro problem',j,count,rate,count_old
      count = long(1) 
      rate=long(0)  
    ENDELSE
    outstr=outstr+strmid(string(count<99),10,2)+strmid(string(rate),6,6)
    IF count gt 0 THEN genstr=genstr+string(w(index(0),i)/factor,format='(F8.0)') ELSE genstr=genstr+string(0,format='(F8.0)') 
    IF strlen(outstr) gt 72 THEN BEGIN
      PRINTF,gen,genstr
      PRINTF,out,outstr
      PRINTF,ill,outstr
      PRINTF,gsas,outstr
      IF STRLEN (gout) LT 32000 THEN gout=gout+outstr
      outstr=''
      genstr=''
    ENDIF
  ENDFOR
  IF strlen(outstr) GT 1 THEN BEGIN
    outstr=outstr+'                                                                                              '
    genstr=genstr+'                                                                                              '
    PRINTF,gen, strmid(genstr,0,80)
    PRINTF,out, strmid(outstr,0,80)
    PRINTF,ill, strmid(outstr,0,80)
    PRINTF,gsas,strmid(outstr,0,80)
    IF STRLEN (gout) LT 32000 THEN gout=gout+strmid(outstr,0,80)
  ENDIF

  genstr=''
  FOR j=0,max(cell) DO BEGIN
    index = where (cell eq j,count)
    IF count gt 0 THEN genstr=genstr+string(e(index(0),i)/factor,format='(F8.1)') ELSE genstr=genstr+string(0,format='(F8.1)')
    IF strlen(genstr) gt 72 THEN BEGIN
      PRINTF,gen,genstr
      genstr=''
    ENDIF
  ENDFOR
  IF strlen(genstr) GT 1 THEN BEGIN
    genstr=genstr+'                                                                                              '
    PRINTF,gen, strmid(genstr,0,80)
  ENDIF


  PRINTF,out,'   -1000'
  PRINTF,out,'  -10000'
  PRINTF,ill,'   -1000'
  PRINTF,ill,'  -10000'
  FREE_LUN,ill,out,gsas,gen
  OPENW,gdat,filename+filext+'.gdat',/get_lun
  PRINTF,gdat,gout
  FREE_LUN,gdat
 ENDFOR
ENDFOR
END
PRO f10scan,sani,nsan,dsan,time

;sani = initial value
;nsan = no. data point
;dsan = step size
;time = counting time
co,1,' t n'
co,1,' t n'


dan0=1.7
mv,'san',sani


mv,'b1',0
mv,'b2',0


for i=0,nsan-1 do begin
        d17mad,'par sub flipper off'
	mv,'san',sani+float(i)*dsan
        mv,'dan',dan0+(sani+float(i)*dsan)*2.
        mv,'dan',dan0+(sani+float(i)*dsan)*2.
	co,time,' t'
	mv,'b1',1.8
	mv,'b2',.8
        d17mad,'par sub flipper on'
	co,time,' t'
	mv,'b1',0
	mv,'b2',0


endfor
mv,'b1',1.8
mv,'b2',.8

d17mad,'b1 off'
wait,2
d17mad,'b2 off'


end
PRO SimpleGauss ,x,w,f
    f=(w(0)*2*Sqrt(ALOG(2)/!pi)/w(2) * exp(-(x-w(1))^2/w(2)^2*4*ALOG(2))); +w(3)
End

PRO gauleg,x1,  x2,  x, w, n
   EPS=3.0e-08
	m=(n+1)/2
	xm=0.5*(x2+x1)
	xl=0.5*(x2-x1)
	for i=1,m DO BEGIN 
		z=cos(!PI*(i-0.25)/(n+0.5))
		REPEAT BEGIN
			p1=1.0
			p2=0.0
			for j=1,n DO BEGIN 
				p3=p2
				p2=p1
				p1=((2.0*j-1.0)*z*p2-(j-1.0)*p3)/j
			Endfor
			pp=n*(z*p1-p2)/(z*z-1.0)
			z1=z
			z=z1-p1/pp
		ENDREP UNTIL (abs(z-z1) LE EPS)
		x(i)=xm-xl*z
		x(n+1-i)=xm+xl*z
		w(i)=2.0*xl/((1.0-z*z)*pp*pp)
		w(n+1-i)=w(i)
      ;print,i,x(i),w(i),z,pp
	Endfor
End

PRO fcj,xx,a,y,pder ; FingerCoxJephcoat convoluted with simple Gauss shape
  ;w9=w10 & w=[14286,39.26,0.24162,0.096454,1311.1,0.019359,0.1485,1.5029,-0.0091623,1,0.07,50,40] & fcj,x9,w,w9 & see,w9
  COMMON fit,voigt,nterms,fitflag,key,undo,npeaks,rectangle,bragg,peakpars
  maxindex=N_ELEMENTS(A)-1
  IF voigt EQ 0 THEN peakpars=3 ELSE peakpars=4
  peakpars=peakpars+rectangle
  PDER       =FLTARR(N_ELEMENTS(XX),nterms+3+npeaks*peakpars) 
  k          =peakpars*npeaks
  y          =FLTARR(N_ELEMENTS(xx))
  denominator=y
  NPOINT     =30
  xgauleg   =FLTARR(NPOINT+1)
  wgauleg   =xgauleg
  gauleg,0,1,xgauleg,wgauleg,NPOINT
  tmp_peaks=npeaks
  tmp_terms=nterms
  S=a(k+nterms)
  H=a(k+nterms+1)
  L=a(k+nterms+2)
  npeaks=1
  nterms=0
  index=INDGEN(peakpars)
  FOR i=0,tmp_peaks-1 DO BEGIN
    denominator=denominator*0
    yy=y*0
    ddenominatordpos=yy
    ddenominatordH=yy
    ddenominatordS=yy
    ddenominatordL=yy
    dyydS=yy
    dyydH=yy
    dyydL=yy
    position=a(peakpars*i+1)
    cospos=COS(position*!pi/180)
    tt_min =ACOS(cospos*SQRT(((H+S)/L)^2+1))*180/!pi	
    tt_infl=ACOS(COSpos*SQRT(((H-S)/L)^2+1))*180/!pi
    x_gauleg=tt_min+xgauleg*(position-tt_min)
    w_gauleg=wgauleg*ABS(position-tt_min)
    FOR j=1,NPOINT DO BEGIN
      cosx=COS(x_gauleg(j)*!pi/180)
      h_tmp       =(cosx^2/cospos^2-1)>0
      h_          =L*SQRT(h_tmp)
    	cond1=(((x_gauleg(i) GE tt_min  AND x_gauleg(i) LT  tt_infl) AND (tt_min LE position)) OR ((x_gauleg(i) LE tt_min  AND x_gauleg(i) GT  tt_infl) AND ((tt_min GT position)))) 
    	cond2=(((x_gauleg(i) GE tt_infl AND x_gauleg(i) LE position) AND (tt_min LE position)) OR ((x_gauleg(i) LE tt_infl AND x_gauleg(i) GE position) AND ((tt_min GT position)))) 
		W_          =(H+S-h_)*cond1 + 2*min([H,S])*cond2
      D_tmp       =2*H*h_*cosx ; !!! NOT cospos !!!
      D =L/(D_tmp+(D_tmp EQ 0))*(D_tmp NE 0)*W_ 
      Gauss_Poly,xx-x_gauleg(j)+position,a(index),F,P
      FOR m=0,peakpars-1 DO PDER(*,index(m))=PDER(*,index(m))+D*P*w_gauleg(j)
      yy            =yy            +D*F*w_gauleg(j)
      denominator =denominator+D*  w_gauleg(j)
      dDdH =  D/(W_+(W_ EQ 0))*(W_ NE 0)*(NOT (cond2 AND (H LT S))) ;H
      dDdS = -L/S/S/2/h_/cospos*(cond1 OR (cond2 AND (H LT S)))     ;S
      dDdL =  D/L-W_/2/S/cospos/h_                                  ;L
      ;dDdpos=!PI*W_/360./S*SIN(position*!PI/180.)/cospos^2/(h_/L)*(1-cosx/cospos^2/h_tmp)
      dDdpos=!PI/180.*L^2*cosx*SIN(position*!pi/180.)/h_^2/H/cospos^3*(cond1+W_/h_)
      ;PRINT,xx(0)-x_gauleg(j)+position,P(0,1),D*P(0,1)*w_gauleg(j),dDdpos(0),F(0)*w_gauleg(j)*dDdpos(0)
      ;PDER(*,peakpars*i+1)=PDER(*,peakpars*i+1)+F*w_gauleg(j)*dDdpos
      ddenominatordpos=ddenominatordpos+w_gauleg(j)*dDdpos
      dyydS=         dyydS         +w_gauleg(j)*F*dDdS
      dyydH=         dyydH         +w_gauleg(j)*F*dDdH
      dyydL=         dyydL         +w_gauleg(j)*F*dDdL
      ddenominatordS=ddenominatordS+w_gauleg(j)*dDdS
      ddenominatordH=ddenominatordH+w_gauleg(j)*dDdH
      ddenominatordL=ddenominatordL+w_gauleg(j)*dDdL
      ;PRINT,PDER(0,peakpars*i+1),tmpder(0)
    ENDFOR
    idx=WHERE(denominator GT 0,count)
    ;PRINT,PDER(0,peakpars*i+1),tmpder(0)
    IF count GT 0 THEN BEGIN
      FOR j=0,peakpars-1 DO PDER(idx,index(j))=PDER(idx,index(j))/denominator(idx)
      PDER(*,peakpars*i+1)=PDER(*,peakpars*i+1) - yy(idx)/denominator(idx)^2*ddenominatordpos(idx)
      yy(idx)     =yy(idx)     /denominator(idx)
      PDER(*,k+nterms)  =PDER(*,k+nterms)  + dyydS(idx)/denominator(idx)-yy(idx)/denominator(idx)^2*ddenominatordS(idx) ;S
      PDER(*,k+nterms+1)=PDER(*,k+nterms+1)+ dyydH(idx)/denominator(idx)-yy(idx)/denominator(idx)^2*ddenominatordH(idx) ;H
      PDER(*,k+nterms+2)=PDER(*,k+nterms+2)+ dyydL(idx)/denominator(idx)-yy(idx)/denominator(idx)^2*ddenominatordL(idx) ;L
    ENDIF
    y=y+yy
    index=index+peakpars
  ENDFOR
  npeaks=tmp_peaks
  nterms=tmp_terms
  FOR i=0,nterms-1 DO BEGIN
    y          =y+A(k+i)*XX^i
    PDER(*,k+i)=         XX^i
  ENDFOR
End
PRO field2d, charge, xr, yr, zr, u, v, w, arrows=arrows, DAMPING=damp,size=size,$
             VELOVECT=velovect,sx=sx,sy=sy,sz=sz ,gap=gap, scale=scale,$
             probe=probe,nframes=nframes,progress=progress,$
             xtimes=xtimes,ztimes=ztimes,reduce=reduce,noprint=noprint,noplot=noplot
;+
;field2d,charge,[-.5,1.5,.1],[-.5,1.5,.1],[-.5,1.5,.1],u,v,w,sx=sx,sy=sy,sz=sz
;field2d,electrodes,[50,120,10],[380,420,10],[-1.5,1.5,1.],u,v,w,sx=sx,sy=sy,sz=sz,/prog
;SCALE3, X=[-2,2],Y=[-2,2],Z=[-2,2],ax=40,az=0
;flow3,u,v,w,arrowsize=.02,sx=sx,sy=sy,sz=sz
;-


charge(3,WHERE(charge(3,*) LT 0,tmp))=-N_ELEMENTS(WHERE(charge(3,*) GT 0))
charge(3,WHERE(charge(3,*) GT 0,tmp))=tmp

IF NOT KEYWORD_SET(probe) THEN probe=-1.
IF NOT KEYWORD_SET(reduce) THEN reduce=1. ELSE reduce=FLOAT(reduce)
xsize=ABS(xr(1)-xr(0))
ysize=ABS(yr(1)-yr(0))
zsize=ABS(zr(1)-zr(0))
u= FLTARR(xsize/xr(2)+1,ysize/yr(2)+1,zsize/zr(2)+1)
v= u
w= u
IF NOT KEYWORD_SET(scale) THEN scale=[0,MAX([N_ELEMENTS(u(*,0,0)),N_ELEMENTS(u(0,*,0)),N_ELEMENTS(u(0,0,*))])]
IF NOT KEYWORD_SET(gap) THEN gap=1
gap=ROUND(gap)
i=0
IF NOT KEYWORD_SET(damp) THEN BEGIN
  IF KEYWORD_SET(velovect) THEN damp=20. ELSE damp=200.
ENDIF
IF NOT KEYWORD_SET(arrows) THEN arrows=200
ASPECT=FLOAT(xsize)/FLOAT(ysize)
IF N_ELEMENTS(u(0,*,0)) LE 1 THEN ASPECT=FLOAT(xsize)/FLOAT(zsize)
IF aspect LT 1 THEN window,0,xsize=1000*(aspect>0.5),ysize=1000 ELSE window,0,xsize=1000,ysize=1000/(aspect<2)
i=0L
j=0L
k=0L
l=0L
sx=FLTARR(N_ELEMENTS(u))
sy=sx
sz=sx
for z= zr(0),zr(1)+zr(2)/10.,zr(2) DO BEGIN
   for y= yr(0),yr(1)+yr(2)/10.,yr(2) DO BEGIN
     for x= xr(0),xr(1)+xr(2)/10.,xr(2) DO BEGIN
       E= field([x,y,z,probe], charge, min([xr(2),yr(2)])/10.)
       IF NOT KEYWORD_SET(noprint) THEN print,x,y,z,SQRT(TOTAL(E^2))
       u(i,j,k)=E(0)
       v(i,j,k)=E(1)
       w(i,j,k)=E(2)
       i=i+1
    ENDFOR
    IF KEYWORD_SET(noprint) THEN print,x,y,z,SQRT(TOTAL(E^2))
    j=j+1
    i=0
  ENDFOR
  field=SQRT(u(*,*,k)^2+v(*,*,k)^2)/damp
  IF NOT KEYWORD_SET(noplot) THEN IF N_ELEMENTS(u(0,*,0)) GT 1 THEN BEGIN
     WSET,0
     IF KEYWORD_SET(VeloVect) THEN BEGIN
      VELOVECT,u(*,*,k),v(*,*,k),INDGEN(xsize/xr(2)+1)*xr(2)+xr(0),INDGEN(ysize/yr(2)+1)*yr(2)+yr(0),TITLE='z'+STRCOMPRESS(z),LENGTH=max(field)/reduce
    ENDIF ELSE BEGIN
      PLOT_FIELD,u(*,*,k),v(*,*,k),TITLE='z'+STRCOMPRESS(z),n=arrows,ASPECT=aspect,LENGTH=max(field)/reduce
    ENDELSE
  ENDIF
  k=k+1
  j=0
ENDFOR
IF NOT KEYWORD_SET(noplot) THEN IF N_ELEMENTS(u(0,*,0)) LE 1 AND N_ELEMENTS(u(*,0,0)) GT 1 AND N_ELEMENTS(u(0,0,*)) GT 1 THEN BEGIN
     field=SQRT(u(*,*,*)^2+v(*,*,*)^2+w(*,*,*)^2)/damp
     WSET,0
     IF KEYWORD_SET(VeloVect) THEN BEGIN
      VELOVECT,u(*,0,*),v(*,0,*),INDGEN(xsize/xr(2)+1)*xr(2)+xr(0),INDGEN(zsize/zr(2)+1)*zr(2)+zr(0),TITLE='y'+STRCOMPRESS(y);,LENGTH=max(field)/reduce
    ENDIF ELSE BEGIN
      PLOT_FIELD,u(*,0,*),w(*,0,*),TITLE='y'+STRCOMPRESS(y),n=arrows,ASPECT=aspect;,LENGTH=max(field)/reduce
    ENDELSE
ENDIF
k=0
l=0
sx=0L
sy=0L
sz=0L
FOR i=0L,N_ELEMENTS(u(*,0,0)),gap do FOR j=0L,N_ELEMENTS(u(0,*,0)),gap do FOR k=0L,N_ELEMENTS(u(0,0,*)),gap do begin
  sx=[sx,i]
  sy=[sy,j]
  sz=[sz,k]
  l=l+1
endfor
sx=sx(1:l-1)
sy=sy(1:l-1)
sz=sz(1:l-1)
END
FUNCTION field,probe,charge,mindist

;+
;FUNCTION field
;PARAMETERS
;	probe:		1D array (4)   of one position  in 3D and its charge
;	charge:		2D array (4,n) of n   positions in 3D (0:2,*) and n charges (3,*)
;	mindist:	minimum distance between probe and charge
;-

x=probe(0)-charge(0,*)
y=probe(1)-charge(1,*)
z=probe(2)-charge(2,*)

div = SQRT(x^2+y^2+z^2)^3 > mindist
f = [TOTAL(probe(3)*charge(3,*)*x), $
     TOTAL(probe(3)*charge(3,*)*y), $
     TOTAL(probe(3)*charge(3,*)*z)]

RETURN,f/div

END
PRO fieldlines,charge,x,y,z,probe=probe,len=len,nsteps=nsteps,sx=sx,sy=sy,sz=sz,nvecs=nvecs,noprint=noprint,pixel=pixel,$
                            ps=ps,color=color,noopen=noopen,file=file,noclose=noclose

;+
;fieldlines,charge2d(*,0:5*642+641),indgen(1000+1),[0],indgen(z2dr(1)-z2dr(0)+1),probe=-1.602E-19,sx=indgen(70)*10+280,sy=intarr(70),sz=intarr(70)+5
;-

IF KEYWORD_SET(ps) THEN BEGIN
  SET_PLOT, 'PS'
  IF NOT KEYWORD_SET(file) THEN file='fieldlines.ps'
  IF NOT KEYWORD_SET(noopen) THEN DEVICE, FILE=file, /COLOR
  TVLCT, [0,255,0,0], [0,0,255,0], [0,0,0,255]
  IF NOT KEYWORD_SET(color) THEN color=1 ; red
ENDIF
IF NOT KEYWORD_SET(pixel) THEN pixel=1E-6 ; 
IF NOT KEYWORD_SET(probe) THEN probe=-1. ; negative standard probe, might be an electron
;s = size(x)
;if s(0) ne 3 then message,'fieldlines: Vx, Vy, and Vz must be 3D arrays'
;nx = s(1)
;ny = s(2)
;nz = s(3)
nx = N_ELEMENTS(x)
ny = N_ELEMENTS(y)
nz = N_ELEMENTS(z)
dim=3
IF nx LE 1 THEN dim=0
IF ny LE 1 THEN dim=1
IF nz LE 1 THEN dim=2
xr=max(x)-min(x)
yr=max(y)-min(y)
zr=max(z)-min(z)
xs=min(x)
ys=min(y)
zs=min(z)
if n_elements(nsteps) le 0 then nsteps = (nx > ny > nz) /5
if n_elements(len) le 0 then len = 2.0  ;Default length
if n_elements(arrowsize) le 0 then arrowsize = 0.05
if n_elements(sx) le 0 then begin	;Starting points specified?
	if n_elements(nvecs) le 0 then nvecs = 200
	dummy=randomu(seed, nvecs)
	x1 = randomu(seed, nvecs) * xr + xs
	y1 = randomu(seed, nvecs) * yr + ys
	z1 = randomu(seed, nvecs) * zr + zs
endif else begin
	x1 = float(sx)
	y1 = float(sy)
	z1 = float(sz)
	nvecs = n_elements(x1) < n_elements(y1) < n_elements(z1)
endelse
HT=x1*0.
Joule=HT
flags=INTARR(nvecs)+1
E=FLTARR(3,nvecs)
xp1=(x1-xs)/xr*(nx-1)
yp1=(y1-ys)/yr*(ny-1)
zp1=(z1-zs)/zr*(nz-1)
i=0
WHILE i LT nsteps DO BEGIN
	x0 = x1
	y0 = y1
	z0 = z1
	;PRINT,x1(0),y1(0),z1(0)
	xp0=xp1
	yp0=yp1
	zp0=zp1
	;PRINT,xp1(0),yp1(0),zp1(0)
	FOR j=0,nvecs-1 DO BEGIN
	  IF flags(j) THEN E(*,j)=field([x0(j),y0(j),z0(j),probe],charge,len/2.)
	ENDFOR
	u0=e(0,*)
	v0=e(1,*)
	w0=e(2,*)
	;u0=interpolate(u,xp0,yp0,zp0)
	;v0=interpolate(v,xp0,yp0,zp0)
	;w0=interpolate(w,xp0,yp0,zp0)
	E0=sqrt(u0^2+v0^2+w0^2)
	dx=u0/E0*len*flags
	dy=v0/E0*len*flags
	dz=w0/E0*len*flags
	x1 = dx + x0
	y1 = dy + y0
	z1 = dz + z0
	index=WHERE(x1 LT min(x) OR y1 LT min(y) or z1 LT min(z) or x1 GT max(x) or y1 GT max(y), count)
	IF count GT 0 THEN flags(index)=0
	HT=HT+SQRT(((dx)^2+(dy)^2+(dz)^2))*E0*flags*pixel
	Joule=HT*probe
	eV=Joule/1.602E-19
	;velocity=SQRT(2.*ABS(Joule)/9.109E-31)
        xp1=(x1-xs)/xr*(nx-1)
        yp1=(y1-ys)/yr*(ny-1)
        zp1=(z1-zs)/zr*(nz-1)
	;IF NOT KEYWORD_SET(noprint) THEN IF flags(0) THEN PRINT,xp1(0),yp1(0),zp1(0)
	IF i NE 0 THEN BEGIN
	  FOR j=0,nvecs-1 DO BEGIN
	    IF flags(j) THEN BEGIN
              IF KEYWORD_SET(ps) THEN BEGIN
	        IF dim EQ 3 THEN plots, [xp0(j), xp1(j)],[yp0(j),yp1(j)],[zp0(j),zp1(j)],/t3d,color=color
	        IF dim EQ 0 THEN plots, [yp0(j),yp1(j)],[zp0(j),zp1(j)],color=color
	        IF dim EQ 1 THEN plots, [xp0(j),xp1(j)],[zp0(j),zp1(j)],color=color
	        IF dim EQ 2 THEN plots, [xp0(j),xp1(j)],[yp0(j),yp1(j)],color=color
	      ENDIF ELSE BEGIN
	        IF dim EQ 3 THEN plots, [xp0(j), xp1(j)],[yp0(j),yp1(j)],[zp0(j),zp1(j)],/t3d
	        IF dim EQ 0 THEN plots, [yp0(j),yp1(j)],[zp0(j),zp1(j)]
	        IF dim EQ 1 THEN plots, [xp0(j),xp1(j)],[zp0(j),zp1(j)]
	        IF dim EQ 2 THEN plots, [xp0(j),xp1(j)],[yp0(j),yp1(j)]
	      ENDELSE
            ENDIF
          ENDFOR
	ENDIF
	IF NOT KEYWORD_SET(noprint) THEN IF flags(0) THEN PRINT,x1(0),y1(0),z1(0),HT(0),u0(0),v0(0),w0(0),E0(0)
	IF count EQ nvecs THEN BEGIN
	  PRINT, 'all electrons arrived or left the box'
	  i=nsteps-1
	ENDIF
	i=i+1
ENDWHILE

;print,HT(WHERE(HT GT 0))
;print,''
print,MAX(HT)

IF KEYWORD_SET(ps) AND NOT KEYWORD_SET(noclose) THEN DEVICE, /CLOSE

ENDFUNCTION field,probe,charge,mindist

;+
;FUNCTION field
;PARAMETERS
;	probe:		1D array (4)   of one position  in 3D and its charge
;	charge:		2D array (4,n) of n   positions in 3D (0:2,*) and n charges (3,*)
;	mindist:	minimum distance between probe and charge
;-

x=probe(0)-charge(0,*)
y=probe(1)-charge(1,*)
z=probe(2)-charge(2,*)
div = 4*!PI*8.854E-12*(SQRT(x^2+y^2+z^2)^3 > mindist)
f = [TOTAL(probe(3)*charge(3,*)*x/div), $
     TOTAL(probe(3)*charge(3,*)*y/div), $
     TOTAL(probe(3)*charge(3,*)*z/div)]

RETURN,f

END
PRO fieldstrength,u,v,w,x,y,z,len=len,nsteps=nsteps,sx=sx,sy=sy,sz=sz,dir=dir

IF NOT KEYWORD_SET(dir) THEN dir=1.
s = size(u)
if s(0) ne 3 then message,'FLOW3: Vx, Vy, and Vz must be 3D arrays'
nx = s(1)
ny = s(2)
nz = s(3)
xr=max(x)-min(x)
yr=max(y)-min(y)
zr=max(z)-min(z)
xs=min(x)
ys=min(y)
zs=min(z)
if n_elements(nsteps) le 0 then nsteps = (nx > ny > nz) /5
if n_elements(len) le 0 then len = 2.0  ;Default length
if n_elements(arrowsize) le 0 then arrowsize = 0.05
zscale = len/max(sqrt(u^2+v^2+w^2))  ;Make max step = len
if n_elements(sx) le 0 then begin	;Starting points specified?
	if n_elements(nvecs) le 0 then nvecs = 200
	x1 = randomu(seed, nvecs) * xr + xs
	y1 = randomu(seed, nvecs) * yr + ys
	z1 = randomu(seed, nvecs) * zr + zs
endif else begin
	x1 = float(sx)
	y1 = float(sy)
	z1 = float(sz)
	nvecs = n_elements(x1) < n_elements(y1) < n_elements(z1)
endelse
HT=x1*0.
flags=INTARR(nsteps)
FOR i=0,nsteps DO BEGIN
	x0 = x1
	y0 = y1
	z0 = z1
	index=WHERE( x0 LE min(x) OR  y0 LE min(y) or  z0 LE min(z) or  x0 GE max(x) or  y0 GE max(y) or  z0 GE max(z), count )
	if count GT 0 THEN flag(index)=1
	xp0=(x0-xs)/xr*nx
	yp0=(y0-ys)/yr*ny
	zp0=(z0-zs)/zr*nz
	u0=interpolate(u,xp0,yp0,zp0)
	v0=interpolate(v,xp0,yp0,zp0)
	w0=interpolate(w,xp0,yp0,zp0)
	E0=sqrt(u0^2+v0^2+w0^2)
	dx=u0/E0*len*dir
	dy=v0/E0*len*dir
	dz=w0/E0*len*dir
	x1 = dx + x0
	y1 = dy + y0
	z1 = dz + z0
	HT=HT+SQRT(((dx)^2+(dy)^2+(dz)^2)*((u0)^2+(v0)^2+(w0)^2))
	IF i NE 0 THEN BEGIN
	  FOR j=0,nvecs-1 DO BEGIN
	    xp1=(x1-xs)/xr*nx
	    yp1=(y1-ys)/yr*ny
	    zp1=(z1-zs)/zr*nz
	    ;PRINT,j, x0(j), x1(j),y0(j),y1(j),z0(j),z1(j)
            plots, [xp0(j), xp1(j)],[yp0(j),yp1(j)],[zp0(j),zp1(j)],/t3d
            ;plots, [x0(j),y0(j),z0(j)],[ x1(j),y1(j),z1(j)],/t3d
          ENDFOR
	ENDIF
	PRINT,x0(0),y0(0),z0(0),x1(0),y1(0),z1(0),HT(0)
ENDFOR

print,HT

ENDFUNCTION fieldvec,probe,charge,mindist

;+
;FUNCTION field
;PARAMETERS
;	probe:		1D array (3)   of one position  in 3D
;	charge:		2D array (4,n) of n   positions in 3D (0:2,*) and n charges (3,*)
;	mindist:	minimum distance between probe and charge
;-

div=SQRT((probe[0]-charge[0,*])^2+(probe[1]-charge[1,*])^2+(probe[2]-charge[2,*])^2)^3>mindist
f=[TOTAL(charge[3,*]*(probe[0]-charge[0,*])/div),TOTAL(charge[3,*]*(probe[1]-charge[1,*])/div),TOTAL(charge[3,*]*(probe[2]-charge[2,*])/div)]

RETURN,f

END
PRO fild20,w,filename,STEP=step,HELP=help,numors=numors,virtual=virtual,$
                      submin=submin,submax=submax,bg=bg,b=b,c=c,mag=mag,$
                      start=start,n0=n0,n1=n1,$
                      nof20=nof20,nodat=nodat,nod20=nod20,nonum=nonum,$
                      append=append,equidist=equidist

IF KEYWORD_SET(help) THEN BEGIN
  print,''
  print,'                         PRO FilD20.PRO'
  print,''
  print,'LAMP-IDL Macro (Procedure) started: 07-Jun-97 by Th.Hansen, ILL-Grenoble (D20)'
  print,'Output of data in "new" D1B - and D20 (of course!) -format for FullProf (cyclic!), ABfit, XRFit etc.'
  print,"It acts (or better: should act) in some way like a LAMP / D20 version of FILD1B"
  print,''
  print,'Attention : Set your flags (efficiency correction, bad cell interpolation, normalisation before!'
  print,''
  print,"Call:      fild20,W[,'filename'][,STEP=0.1][,/HELP]"
  print,"Variables: Workspace (necessary, won't be changed)"
  print,"           basic filename, 3 letters, different from 'fil' (optional, will be changed)"
  print,'Keywords:  STEP :    evt. different 2*Theta stepwidth'
  print,'           HELP :    this hopefully helping text'
  print,'           VIRTUAL : first numor of incremented numors for each ACQ'
  print,'           NUMORS :  Array of numor-numbers to be read instead of using the given workspace (which will be changed)'
  print,'                     if just the keyword is given (/numors), filename.run, '
  print,'                     containing the number of numors and the numors, will be read in'
  print,'           SUBMIN :  First sub-numor to be used (or list of sub-numors for each numor in the numors-array)'
  print,'           SUBMAX :  Last  sub-numor to be used (or list of sub-numors for each numor in the numors-array)'
  print,'           BG :      Workspace containing background to be substracted (pay attention to normalisation!)'
  print,'           B :       Workspace containing 2Theta-depending correction coefficients'
  print,'           C :       Workspace containing 2Theta depending attenuation coefficients for substracted background'
  print,''
  print,'     Modification: 21-Aug-97 by Th.Hansen:'
  print,'                   Normalisation and Calibration now controlled by common flag_d20 (calibration) and procedure flag'
  print,'                   The old version (used by Rennie, Brown, Clarke, Chatteigner and Lutterotti is backuped'
  print,'     Modification: 03-Sep-97 by Th.Hansen: Bug-fix '
  print,'                   Errors not correct for normalized data (variable count were always 1)'
  print,'     Modification: 05-Sep-97 by Th.Hansen: Bug-fix'
  print,'                   fil.f20 file for sequential simple ACQs did not contain counts'
  print,'     Modification: 30-Sep-97 by Th.Hansen: Bug-fix'
  print,'                   one-dimensional array datp.x for multiple diagrams was not correctly treated'
  print,'     Modification: 22-Oct-97 by Th.Hansen: '
  print,'                   Background substraction (Ferrand) and temperature in *.num file (Soubeyroux)'
  print,'     Modification: 03-Nov-97 by Th.Hansen: '
  print,'                   first and last numor, longer filenames, *.d20 files and options not to create files (Ouladdiaf)'
  print,'Last modification: 30-Aug-01 by Th.Hansen: '
  print,'                   equidist keyword, avoiding 0 counts due to rebinning'
  print,'                   '
  print,''
ENDIF

zerocountingcells=0
IF KEYWORD_SET(n0) THEN BEGIN
  IF NOT KEYWORD_SET(n1) THEN n1=n0
  IF n1 LE n0 THEN BEGIN
    n2=n1
    n1=n0
    n0=n1
  ENDIF
  numors=indgen(n1-n0+1)+n0
ENDIF
iii=0
IF NOT KEYWORD_SET(b)  THEN b =1.
IF NOT KEYWORD_SET(c)  THEN c =1.
IF KEYWORD_SET(bg) THEN BEGIN
  take_w, wbg, w=bg
  take_datp, datbg, w=bg
  IF N_ELEMENTS(c) EQ N_ELEMENTS(wbg) OR N_ELEMENTS(c) EQ 1 THEN BEGIN
    datbg.e=datbg.e*c
    wbg=wbg*c  
  ENDIF ELSE PRINT,'No multiplication of background by coeff. C(theta)'
ENDIF


IF n_elements(filename) EQ 0 THEN filename = 'fil'
IF KEYWORD_SET(numors) THEN IF N_ELEMENTS(w) EQ 1 THEN IF N_PARAMS() EQ 1 THEN filename=w
IF STRLEN(filename) EQ 0 THEN filename ='fil'
longname=string(filename)
filename=strmid(string(filename)+'000',0,3)
filename = STRCOMPRESS(filename,/REMOVE_ALL)

line=' '
IF KEYWORD_SET(append) THEN BEGIN
  IF NOT KEYWORD_SET(nof20) THEN BEGIN
    PRINT,    'Append full multiple DataSet - FileName: ',filename+'.f20'
    XICUTE,'$mv '+longname+'.f20 '+longname+'.old'
    OPENR, in,longname+'.old',/get_lun
    OPENW, f20,longname+'.f20',/get_lun
    READF,in,line
    WHILE STRMID(line,0,10) NE '    -10000' DO BEGIN
      PRINTF,f20,line
      READF,in,line
    ENDWHILE
    FREE_LUN,in
  ENDIF
  IF NOT KEYWORD_SET(nonum) THEN BEGIN
    XICUTE,'$mv '+longname+'.num '+longname+'.old'
    OPENR, in,longname+'.old',/get_lun
    OPENW, num,longname+'.num',/get_lun
    READF,in,line
    WHILE STRMID(line,0,10) NE '    -10000' DO BEGIN
      PRINTF,num,line
      READF,in,line
    ENDWHILE
    FREE_LUN,in
  ENDIF
ENDIF ELSE BEGIN
  IF NOT KEYWORD_SET(nof20) THEN PRINT,    'Full multiple DataSet - FileName: ',filename+'.f20'
  IF NOT KEYWORD_SET(nof20) THEN OPENW, f20,longname+'.f20',/get_lun
  IF NOT KEYWORD_SET(nof20) THEN IF KEYWORD_SET(numors) THEN PRINTF,f20,FORMAT='(I5)',N_ELEMENTS(numors) ELSE PRINTF,f20,FORMAT='(I5)',n_elements(w(0,*,*))
  IF NOT KEYWORD_SET(nonum) THEN OPENW, num,longname+'.num',/get_lun
ENDELSE

IF NOT KEYWORD_SET(start) THEN start=0
counter=-1

IF KEYWORD_SET(numors) THEN BEGIN 
 IF N_ELEMENTS(numors) EQ 1 THEN IF numors EQ 1 THEN BEGIN
   numors=rdarr(filename+'.run') 
   PRINT,'Reading Numors from ',filename+'.run'
 ENDIF ELSE BEGIN
   IF N_ELEMENTS(numors) EQ 1 AND string(numors) GE string(999999) THEN BEGIN
     numors=rdarr(string(numors)) 
	 PRINT,'Reading Numors from ',string(numors)
   ENDIF
 ENDELSE
 numors=ROUND(numors)
 PRINT,'Reading Numor Files     ',numors
 IF KEYWORD_SET(submin) THEN BEGIN
  IF submin EQ 1 THEN BEGIN
    submin=rdarr(filename+'.min') 
    PRINT,'Reading min. Sub-Numors from ',filename+'.min'
  ENDIF ELSE BEGIN
    IF N_ELEMENTS(submin) EQ 1 AND string(submin) GE string(999999) THEN BEGIN
      submin=rdarr(string(submin)) 
 	  PRINT,'Reading min. Sub-Numors from ',string(submin)
    ENDIF
  ENDELSE
  submin=ROUND(submin)
  PRINT,'First Sub-Numors used   ',submin
 ENDIF
 IF KEYWORD_SET(submax) THEN BEGIN
  IF submax EQ 1 THEN BEGIN
    submax=rdarr(filename+'.max') 
    PRINT,'Reading max. Sub-Numors from ',filename+'.max'
  ENDIF ELSE BEGIN
    IF N_ELEMENTS(submax) EQ 1 AND string(submax) GE string(999999) THEN BEGIN
      submax=rdarr(string(submax)) 
	  PRINT,'Reading max. Sub-Numors from ',string(submax)
    ENDIF
  ENDELSE
  submax=ROUND(submax)
  PRINT,' Last Sub-Numors used   ',submax
 ENDIF ELSE submax=999999
 IF NOT KEYWORD_SET(mag) THEN mag=ceil(4)
 magnitude = ceil(alog10(start+n_elements(numors)))
 magnitude = ceil(alog10(long(10.0^(magnitude-1))+n_elements(numors)))
 magnitude = mag > magnitude
 virtual_numor=round(min(numors))
 factor=long(1)
  lastn=N_ELEMENTS(numors)-1 
  IF N_ELEMENTS(submin) EQ 1                  THEN submin=intarr(N_ELEMENTS(numors))+submin
  IF N_ELEMENTS(submin) NE N_ELEMENTS(numors) THEN submin=intarr(N_ELEMENTS(numors))
  IF N_ELEMENTS(submax) EQ 1                  THEN submax=intarr(N_ELEMENTS(numors))+submax
  IF N_ELEMENTS(submax) NE N_ELEMENTS(numors) THEN submax=intarr(N_ELEMENTS(numors))+9999
ENDIF ELSE BEGIN
  lastn=0
  IF NOT KEYWORD_SET(submin) THEN submin=0
  IF NOT KEYWORD_SET(submax) THEN submax=N_ELEMENTS(w(0,*,*))-1
  factor=long(1)
  WHILE long(max(w)/factor) ge 100000000 DO factor=factor+1
  PRINT,'Factor: ',factor
 IF NOT KEYWORD_SET(mag) THEN mag=ceil(0)
  magnitude=ceil(alog10(start+n_elements(w(0,*,*))))
  magnitude=ceil(alog10(long(10.0^(magnitude-1))+n_elements(w(0,*))))
  magnitude = mag > magnitude
  lastn=0
  IF NOT KEYWORD_SET(submin) THEN submin=0
  IF NOT KEYWORD_SET(submax) THEN submax=N_ELEMENTS(w(0,*,*))-1
ENDELSE
submin=submin>0
submax=submax>submin

FOR nnn=0,lastn DO BEGIN
  datp=1
  IF KEYWORD_SET(numors) THEN BEGIN
    w=rdrun(numors(nnn),datp=datp)
  ENDIF ELSE BEGIN
    take_datp,datp
    virtual_numor=LONG(datp.p(29)) MOD 100000
  ENDELSE
  first=submin(nnn)<(N_ELEMENTS(w(0,*))-1)
  last =submax(nnn)<(N_ELEMENTS(w(0,*))-1)
  IF KEYWORD_SET(numors) THEN BEGIN  
    IF N_ELEMENTS(w(0,*)) GT 1 THEN print,'Numor',LONG(datp.p(29)),' from subnumor',first,' to',last	ELSE print,'Numor',LONG(datp.p(29))
  ENDIF
  ; Modification TCH JLS 27/3/1
  IF N_ELEMENTS (datp.e) NE N_ELEMENTS(w) THEN mod_datp,datp,'e' ,SQRT(w)
  w      =w      (*,first:last)
  mod_datp,datp,'e' ,datp.e (*,first:last)
  IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN mod_datp,datp,'x',datp.x (*,first:last)
  mod_datp,datp,'y' ,datp.y (    first:last)
  mod_datp,datp,'n' ,datp.n (*,*,first<((N_ELEMENTS(datp.n(0,0,*))-1)>0):last<((N_ELEMENTS(datp.n(0,0,*))-1)>0))
  mod_datp,datp,'pv',datp.pv(*,  first:last)

pitch=TOTAL(datp.x(1:N_elements(datp.x(*,0,0))-1,0,0)-datp.x(0:N_elements(datp.x(*,0,0))-2,0,0))/(N_elements(datp.x(*,0,0))-1)
IF NOT KEYWORD_SET(step) THEN BEGIN
   step=pitch
   IF ROUND(datp.p(0)) EQ 3 THEN BEGIN
    step=datp.x(N_ELEMENTS(datp.x(*,0))/2,0)-datp.x(N_ELEMENTS(datp.x(*,0))/2-1,0) ; 2theta scan
  ENDIF
ENDIF ELSE PRINT,'The average angular pitch is',pitch,' degrees, but you want it to be',step
   dev=TOTAL(ABS((datp.x(1:N_elements(datp.x(*,0,0))-1,0,0)-datp.x(0:N_elements(datp.x(*,0,0))-2,0,0))-step))/(N_elements(datp.x(*,0,0))-1)
   IF dev GE step/10000. THEN BEGIN
     PRINT,'ATTENTION : You do not really have equidistant data: average deviation +/-', dev
     PRINT,'In such a case you should better choose another export format (d20reg), or interpolate your workspace before!'
     IF KEYWORD_SET(equidist) THEN PRINT,'The data will not be rebinned but supposed to be equidistant'
     IF NOT KEYWORD_SET(equidist) THEN PRINT,'The data will be rebinned to an equidistant grid'
   ENDIF
   print,'2Theta step : ',step
e=datp.e
cell     = INDGEN(n_elements(w(*,0)))
IF NOT KEYWORD_SET(equidist) THEN cell(*)  = ROUND((datp.x(*,0)-datp.x(0,0))/step)
counter=counter+start
FOR ii=0,n_elements(w(0,0,*))-1 DO FOR i=0,n_elements(w(0,*,0))-1 DO BEGIN
  IF datp.pv(30,i) NE datp.n(0,0,i<((N_ELEMENTS(datp.n(0,0,*))-1)>0)) THEN BEGIN
    PRINT,"Attention to non-integer normalisation factor (use exriet's GENeral data format or d20reg!) "+string(datp.pv(30,i) / datp.n(0,0,i<((N_ELEMENTS(datp.n(0,0,*))-1)>0)))
  ENDIF
  counter=counter+1
  filext = string(long(10.0^magnitude))+strcompress(string(counter+long(10.0^(magnitude-1))),/REMOVE_ALL)
  filext = strmid(filext,strlen(filext)-magnitude,magnitude)
  pp=datp.p 
  IF n_elements(datp.n(*,0)) GT 1 THEN BEGIN
    nn=datp.n(i,0:1) 
  ENDIF ELSE BEGIN
    nn=datp.n(0,0:1<((N_ELEMENTS(datp.n(0,*,0))-1)>0))
  ENDELSE
  IF N_ELEMENTS(w(*,i,ii)) EQ N_ELEMENTS(b ) OR N_ELEMENTS(b ) EQ 1 THEN BEGIN
    w(*,i,ii)=w(*,i,ii)*b  
    datp.e(*,i,ii)=datp.e(*,i,ii)*b  
  ENDIF ELSE PRINT,'No multiplication by coeff. B(theta)',nnn,i,ii
  IF KEYWORD_SET(bg) THEN BEGIN
    IF N_ELEMENTS(w(*,i,ii)) EQ N_ELEMENTS(wbg) OR N_ELEMENTS(wbg) EQ 1 THEN BEGIN
      w(*,i,ii)=w(*,i,ii)-wbg*nn/datbg.n 
      datp.e(*,i,ii)=datp.e(*,i,ii)+datbg.e*nn/datbg.n
    ENDIF ELSE PRINT,'No substraction by Background       ',nnn,i,ii
  ENDIF
  IF n_elements(w(0,*,*)) GT 1 THEN BEGIN
    pv=datp.pv(*,i,ii)
    xx=datp.x(*,i<(N_ELEMENTS(datp.x(0,*,0))-1),ii)
  ENDIF ELSE BEGIN
    pv=datp.pv
    xx=datp.x
  ENDELSE
  timemag=ceil(alog10(pv(5)))
  IF NOT KEYWORD_SET(nodat) THEN BEGIN
    IF (i EQ 0) or (i EQ n_elements(w(0,*))-1) THEN print,'FileName: ',filename+filext+'.dat'
  ENDIF ELSE IF NOT KEYWORD_SET(nod20) THEN BEGIN
    IF (i EQ 0) or (i EQ n_elements(w(0,*))-1) THEN print,'FileName: ',filename+filext+'.d20'
  ENDIF
  IF KEYWORD_SET(virtual) THEN  numor=virtual_numor+counter ELSE numor=round(pv(29)) mod 100000
  IF NOT KEYWORD_SET(nodat) THEN OPENW,out,filename+filext+'.dat',/get_lun
  IF NOT KEYWORD_SET(nod20) THEN OPENW,d20,filename+filext+'.d20',/get_lun
  IF NOT KEYWORD_SET(nodat) THEN PRINTF,out,FORMAT='(I5)',1
  IF NOT KEYWORD_SET(nod20) THEN PRINTF,d20,FORMAT='(I5)',1

; Write .DAT files and .NUM file

    outstr=' '+strmid(datp.other_tit,3,strlen(datp.other_tit)-3)+datp.w_tit+'                                                                                              '
    IF NOT KEYWORD_SET(nodat) THEN PRINTF,out,strmid(outstr,0,132)
    IF NOT KEYWORD_SET(nod20) THEN PRINTF,d20,strmid(outstr,0,132)
    IF NOT KEYWORD_SET(nonum) THEN PRINTF,num,strmid(outstr,0,132)
    outstr=''
    iii=iii+1
    IF NOT KEYWORD_SET(nodat) THEN PRINTF,out,FORMAT='(I4,I7,"                                                                                                                         ")',$
      iii,numor
    IF NOT KEYWORD_SET(nod20) THEN PRINTF,d20,FORMAT='(I4,I7,"                                                                                                                         ")',$
      iii,numor
    IF NOT KEYWORD_SET(nonum) THEN PRINTF,num,FORMAT='(I4,I7,"                                                                                                                         ")',$
      iii,numor
    IF timemag LE 0 THEN BEGIN
      IF NOT KEYWORD_SET(nodat) THEN printf,out,FORMAT="(F13.0,F9.6,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
        nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
      IF NOT KEYWORD_SET(nod20) THEN printf,d20,FORMAT="(F13.0,F9.6,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
        nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
      IF NOT KEYWORD_SET(nonum) THEN printf,num,FORMAT="(F13.0,F9.6,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
        nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
    ENDIF ELSE BEGIN 
      IF timemag LE 3 THEN BEGIN
        IF NOT KEYWORD_SET(nodat) THEN printf,out,FORMAT="(F13.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
          nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
        IF NOT KEYWORD_SET(nod20) THEN printf,d20,FORMAT="(F13.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
          nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
        IF NOT KEYWORD_SET(nonum) THEN printf,num,FORMAT="(F13.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
          nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
      ENDIF ELSE  BEGIN
        IF NOT KEYWORD_SET(nodat) THEN printf,out,FORMAT="(F13.0,F9.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
          nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
        IF NOT KEYWORD_SET(nod20) THEN printf,d20,FORMAT="(F13.0,F9.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
          nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
        IF NOT KEYWORD_SET(nonum) THEN printf,num,FORMAT="(F13.0,F9.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
          nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
      ENDELSE 
    ENDELSE
    outstr=''

    IF NOT KEYWORD_SET(nodat) THEN PRINTf,out,FORMAT='(I4," ",F9.3," ",F9.3," ",F9.3," ",F9.3," ",F9.3,"  EffCor=1,AngCal=2,Intpol=4: ",I6,"   ",I6,"                                 ")',$
      MAX(cell)+1,pv(17:21),pp(38),0
    IF NOT KEYWORD_SET(nod20) THEN PRINTf,d20,FORMAT='(I4," ",F9.3," ",F9.3," ",F9.3," ",F9.3," ",F9.3,"  EffCor=1,AngCal=2,Intpol=4: ",I6,"   ",I6,"                                 ")',$
      MAX(cell)+1,pv(17:21),pp(38),0

; Write .F20 file

      outstr=' '+strmid(datp.other_tit,3,strlen(datp.other_tit)-3)+datp.w_tit+'                                                                                              '
      IF NOT KEYWORD_SET(nof20) THEN PRINTF,f20,strmid(outstr,0,132)
      outstr=''
      IF NOT KEYWORD_SET(nof20) THEN PRINTF,f20,FORMAT='(I4,I7,"                                                                                                                         ")',$
        iii,numor
  IF timemag LE 0 THEN BEGIN
       IF NOT KEYWORD_SET(nof20) THEN printf,f20,FORMAT="(F13.0,F9.6,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
         nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
  ENDIF ELSE BEGIN 
    IF timemag LE 3 THEN BEGIN
      IF NOT KEYWORD_SET(nof20) THEN printf,f20,FORMAT="(F13.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
        nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
    ENDIF ELSE  BEGIN
      IF NOT KEYWORD_SET(nof20) THEN printf,f20,FORMAT="(F13.0,F9.0,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,F9.3,'                    ')",$
        nn,xx(0),pv(14:16),0.,pp(33),step,pv(10:12)<9999
    ENDELSE 
  ENDELSE
    outstr=''
    IF NOT KEYWORD_SET(nof20) THEN PRINTf,f20,FORMAT='(I4," ",F9.3," ",F9.3," ",F9.3," ",F9.3," ",F9.3,"  EffCor=1,AngCal=2,Intpol=4: ",I6,"   ",I6,"                                 ")',$
      MAX(cell)+1,pv(17:21),pp(38),0
  outstr=''

  FOR j=0,max(cell) DO BEGIN
    IF j NE 0 THEN count_old=count
    index = where (cell eq j,count)
    IF count gt 0 THEN BEGIN
      IF e(index(0),i) GT 0 THEN count=long(round((SQRT(ABS(w(index(0),i,ii)))/e(index(0),i,ii))^2)) ELSE count=long(1)
      count = factor*count
      rate=long((w(index(0),i,ii)+0.49999999)/factor)
      IF rate EQ 0 THEN BEGIN
        count=long(1)
      ENDIF
    ENDIF ELSE BEGIN          ;  no cell for this angle in the workspace
      IF (i EQ 0) THEN zerocountingcells=zerocountingcells+1
      IF (i EQ 0) THEN PRINT,j,count,rate,count_old,zerocountingcells
      count = long(1) 
      rate=long(0)  
    ENDELSE
    outstr=outstr+strmid(string(count),10,2)+strmid(string(rate),4,8)
    IF strlen(outstr) gt 90 THEN BEGIN
      outstr=outstr+'                                                                                              '
      IF NOT KEYWORD_SET(nodat) THEN PRINTF,out,strmid(outstr,0,132)
      IF NOT KEYWORD_SET(nod20) THEN PRINTF,d20,strmid(outstr,0,132)
      IF NOT KEYWORD_SET(nof20) THEN PRINTF,f20, strmid(outstr,0,132)
      outstr=''
    ENDIF
  ENDFOR
  IF strlen(outstr) GT 1 THEN BEGIN
    outstr=outstr+'                                                                                              '
    IF NOT KEYWORD_SET(nodat) THEN PRINTF,out, strmid(outstr,0,132)
    IF NOT KEYWORD_SET(nod20) THEN PRINTF,d20, strmid(outstr,0,132)
    IF NOT KEYWORD_SET(nof20) THEN PRINTF,f20, strmid(outstr,0,132)
  ENDIF
  IF NOT KEYWORD_SET(nof20) THEN PRINTF,f20,'     -1000                                                                                                                          '
  IF NOT KEYWORD_SET(nodat) THEN PRINTF,out,'     -1000                                                                                                                          '
  IF NOT KEYWORD_SET(nodat) THEN PRINTF,out,'    -10000                                                                                                                          '
  IF NOT KEYWORD_SET(nod20) THEN PRINTF,d20,'     -1000                                                                                                                          '
  IF NOT KEYWORD_SET(nod20) THEN PRINTF,d20,'    -10000                                                                                                                          '
  IF NOT KEYWORD_SET(nodat) THEN FREE_LUN,out
  IF NOT KEYWORD_SET(nod20) THEN FREE_LUN,d20
ENDFOR
ENDFOR

  IF NOT KEYWORD_SET(nof20) THEN PRINTF,f20,'    -10000                                                                                                                          '
  IF NOT KEYWORD_SET(nof20) THEN FREE_LUN,f20
  IF NOT KEYWORD_SET(nonum) THEN PRINTF,num,'    -10000                                                                                                                          '
  IF NOT KEYWORD_SET(nonum) THEN FREE_LUN,num
  IF zerocountingcells NE 0  THEN BEGIN
    PRINT,'You will find some zerocounting cells in your data set(s), which is most probably due to rebinning of non-equidistant scattering data to an equidistant grid.'
    PRINT,'You can use the keyword /equidist to force the scattering angles to be calculated as x(i)=x(0)+step. '
    PRINT,'If the keyword step is not given, it will be set to the average angular pitch, close to 0.1 degrees in the case of D20.'
  ENDIF
END

FUNCTION filters,n1,n2,a=aa,x=xxx,y=yyy,zz12=zzz,z1=z1,z2=z2,t1=trans1,t2=trans2
;
; Started  14-Nov-96 by Thomas Hansen
; Macro for analysis of Graphite filter plates for the HOPG Monochromator of D20
; Last changed 23-Nov-96 by Thomas Hansen
;
IF n_elements(n2) EQ 0 THEN n2=n1
result=fltarr(252,252)
trans1=fltarr(252,252)
trans2=fltarr(252,252)
xx=fltarr(252,252)
yy=fltarr(252,252)
numors=long(indgen(n2-n1+1)+n1)
IF n_elements(aa) THEN a=aa ELSE a=[[185,45.8,.22,0,0,0],[43,37.1,.22,0,0,0],[23,43.8,.22,0,0,0]]
w=concat(numors)
take_datp,datp
give_datp,datp
pretreat,w,126
take_datp,datp
calib,w
take_datp,datp
normalize,w,1.95646e+07,/noprint
take_datp,datp
;IF n_elements(w(0,*)) GT 1 THEN surface,w,datp.x,indgen(n_elements(w(0,*))) ELSE plot,w,datp.x
w=fit(w,a)
take_datp,datp
;IF n_elements(w(0,*)) GT 1 THEN surface,w,datp.x,indgen(n_elements(w(0,*))) ELSE plot,w,datp.x
FOR j=0,n_elements(datp.pv(17,*))-1 DO BEGIN
  t1=round(datp.pv(17,j))
  t2=round(datp.pv(18,j))
  xx(t1,t2)=t1
  yy(t1,t2)=t2
  result(t1,t2)=a(0,0,j)*a(2,0,j)/(a(0,1,j)*a(2,1,j))
  trans1(t1,t2)=a(0,0,j)*a(2,0,j)/4.23305
  trans2(t1,t2)=a(0,1,j)*a(2,1,j)/2.27065
ENDFOR
print
t1=where(total(result,2))
t2=where(total(result,1))
result=result(t1(*),*)
result=result(*,t2(*))
trans1=trans1(t1(*),*)
trans1=trans1(*,t2(*))
trans2=trans2(t1(*),*)
trans2=trans2(*,t2(*))
xx=xx(t1(*),*)
xx=xx(*,t2(*))
yy=yy(t1(*),*)
yy=yy(*,t2(*))
mod_datp,datp,'x',xx
mod_datp,datp,'y',yy
mod_datp,datp,'x_tit','T1/mm'
mod_datp,datp,'y_tit','T2/mm'
mod_datp,datp,'w_tit','[(111)/(lambda)]/[(220)/(lambda/2)]: Run'+string(round(n1))+' to'+string(round(n2))
mod_datp,datp,'other_tit','FILTERS.pro'
mod_datp,datp,'e',0*result
mod_datp,datp,'n',0*t2
give_datp,datp
IF KEYWORD_SET(xxx) THEN BEGIN
  xx=REFORM(xx,n_elements(result))
  yy=REFORM(yy,n_elements(result))
  ww=REFORM(result,n_elements(result))
  xx=xx(WHERE(ww))
  yy=yy(WHERE(ww))
  ww=ww(WHERE(ww))
  triangulate,xx,yy,zz
  xxx=min(xx)+float(indgen(max(xx)-min(xx)+1))
  yyy=min(yy)+float(indgen(max(yy)-min(yy)+1))
  zzz = trigrid(xx,yy,ww,zz,[1,1],/smooth)
  z1=REFORM(trans1,n_elements(trans1))
  z1=z1(WHERE(z1))
  z1 = trigrid(xx,yy,z1,zz,[1,1],/smooth)
  z2=REFORM(trans2,n_elements(trans2))
  z2=z2(WHERE(z2))
  z2 = trigrid(xx,yy,z2,zz,[1,1],/smooth)
 ;contour,zzz,xxx,yyy,/follow,nlevels=16
 ;surface,zzz,xxx,yyy
ENDIF
output=[reform(t2,1,n_elements(t2)),result]
output=[[0,t1],[output]]
print,strmid(strcompress(string(output)),1,4)
FOR i = 0,3 DO BEGIN
  index=WHERE(datp.x GE i*60 AND datp.x LT (i+1)*60 AND result NE 0.0 AND datp.y GE 150 AND datp.y LE 230,count)
  IF count gt 1 THEN m=moment(result(index),sdev=s)
  IF count gt 1 THEN print,i,':',m(0),' +/-',s
ENDFOR
print
output=[reform(t2,1,n_elements(t2)),trans1]
output=[[0,t1],[output]]
print,strmid(strcompress(string(output)),1,4)
FOR i = 0,3 DO BEGIN
  index=WHERE(datp.x GE i*60 AND datp.x LT (i+1)*60 AND result NE 0.0 AND datp.y GE 150 AND datp.y LE 230,count)
  IF count gt 1 THEN m=moment(trans1(index),sdev=s)
  IF count gt 1 THEN print,i,':',m(0),' +/-',s
ENDFOR
print
output=[reform(t2,1,n_elements(t2)),trans2]
output=[[0,t1],[output]]
print,strmid(strcompress(string(output)),1,4)
FOR i = 0,3 DO BEGIN
  index=WHERE(datp.x GE i*60 AND datp.x LT (i+1)*60 AND result NE 0.0 AND datp.y GE 150 AND datp.y LE 230,count)
  IF count gt 1 THEN m=moment(trans2(index),sdev=s)
  IF count gt 1 THEN print,i,':',m(0),' +/-',s
ENDFOR
;surface,zzz,xxx,yyy
return,result
END
PRO resize_window,event
  widget_control,event.top,get_uvalue=pointertodata
  widget_control,pointertodata,get_uvalue=info
  drawwidgetid=widget_info(event.id,/child)
  widget_control,drawwidgetid,draw_xsize=event.x,draw_ysize=event.y
  wset,info.wid
  IF n_elements(info.data(0,*)) gt 1 THEN shade_surf,info.data,info.p.x,info.p.y ELSE plot,info.p.x,info.data
END

PRO FirstWid_Event,event
widget_control,event.top,get_uvalue=info
wset,info.wid
Widget_control,event.id,Get_value=buttonValue
CASE buttonValue OF
  'Shaded Plot':	IF n_elements(info.data(0,*)) gt 1 THEN Shade_surf,info.data,info.p.x,info.p.y
  'Surface Plot':	IF n_elements(info.data(0,*)) gt 1 THEN surface,info.data,info.p.x,info.p.y
  'Contour Plot':	IF n_elements(info.data(0,*)) gt 1 THEN contour,info.data,info.p.x,info.p.y,nlevels=12,/follow,c_colors=indgen(6)*20+80
  'Default Plot':	see,info.data
  'Line Plot':		IF n_elements(info.data(0,*)) le 1 THEN plot,info.p.x,info.data
  'Current Path':	BEGIN	RDSET   ,inst="D20" ,base="Current Path"
				info.data=rdrun(numor)
				take_datp,info.p
				IF n_elements(info.data(0,*)) gt 1 THEN shade_surf,info.data,info.p.x,info.p.y ELSE plot,info.p.x,info.data
			END
  'Current Cycle':	BEGIN	RDSET   ,inst="D20" ,base="Current Cycle"
				info.data=rdrun(numor)
				take_datp,info.p
				IF n_elements(info.data(0,*)) gt 1 THEN shade_surf,info.data,info.p.x,info.p.y ELSE plot,info.p.x,info.data
			END
  'Previous Cycle':	BEGIN	RDSET   ,inst="D20" ,base="Previous Cycle"
  				info.data=rdrun(numor)
				take_datp,info.p
				IF n_elements(info.data(0,*)) gt 1 THEN shade_surf,info.data,info.p.x,info.p.y ELSE plot,info.p.x,info.data
			END
  'Change Colors':	XloadCt,Group=event.top
  'Pretreatment':	pretreat,info.data
  'Calibration':	calib,info.data
  'Single Pattern':	unic,info.data
  'Goodbye':		BEGIN
  			  print,'See you later!'
			  Widget_Control,event.top,/Destroy
			END
ENDCASE
END

FUNCTION FirstWid,numor
tlb=		Widget_BAse(Column=1,Title='First Widget Program',tlb_frame_attr=1)
topmenu=	widget_button(tlb,value='Plot Options',/menu)
shadedplot=	widget_button(topmenu,value='Shaded Plot')
surfaceplot=	widget_button(topmenu,value='Surface Plot')
contourplot=	widget_button(topmenu,value='Contour Plot')
defaultplot=	widget_button(topmenu,value='Default Plot')
lineplot=	widget_button(topmenu,value='Line Plot')
readmenu=	widget_button(tlb,value='Read Options',/menu)
path=		widget_button(readmenu,value='Current Path')
current=	widget_button(readmenu,value='Current Cycle')
previous=	widget_button(readmenu,value='Previous Cycle')
changecolors=	widget_button(tlb,value='Change Colors')
pretreat=	widget_button(tlb,value='Pretreatment')
calib=		widget_button(tlb,value='Calibration')
unic=		widget_button(tlb,value='Single Pattern')
byebutton=	widget_button(tlb,value='Goodbye')
graphicsbase=	widget_base(tlb_size_events=1,event_pro='Resize_Window',uvalue=tlb,xoffset=50,yoffset=75,group_leader=tlb)
draw=		Widget_Draw(graphicsbase,xsize=200,ysize=200)
widget_control,tlb,/realize
widget_control,graphicsbase,/realize
widget_control,draw,get_value=windowindex
wset,windowindex
loadct,5
w=rdrun(numor)
take_datp,datp
IF n_elements(w(0,*)) gt 1 THEN shade_surf,w,datp.x,datp.y ELSE plot,datp.x,w
info={n:numor,data:w,p:datp,wid:windowindex}
widget_control,tlb,set_uvalue=info
XManager,'FirstWid',tlb,Event='FirstWid_Event'
give_datp,datp
return,w
END
;----------------------------------------------------------------------------
;****************************************************************************
;
;	PRO fitgauss, x_in, y_in, e_in, xmin, xmax, par, dpar, ispec, $
;	    all=allpoints, plot=plot
;
; Fits a Gaussian plus a flat background, and calculates partial derivatives.
; Normally called from normalise.pro and elastic.pro
;
;ARGUMENTS
; xmin	:min limit of fit range
; xmax	:max limit of fit range
; par	:output of fitted Gaussian parameters :-- par(0) - flat background
;						  par(1) - height
;						  par(2) - centre
;						  par(3) - FWHM (sigma)
; dpar	:errors in fitted parameters
; ispec	:spectrum number (used by elastic.pro)
;
;KEYWORDS
; /all	: keeps all points in range xmin<x<xmax.
; 	  otherwise, Gaussian fitted in range x0-FWHM<x<x0+FWHM (default)
; /plot : plot data and fit while executing
;
;DIMENSIONS
; x_in, y_in and e_in ar all 1D arrays of the same dimension
;
;COMMAND SYNTAX
; fitgauss, x1, y1, e1, ,<min> ,<max> [,<ispec>][,/all][,/plot]
;
; (optional keywords/args shown in sqaure brackets) 
;
;						KHA,JRS 8/8/00
;----------------------------------------------------------------------------
;****************************************************************************

	PRO gaussian, x, par, gauss, PD

	bkgd=par(0)
	height=par(1)
	centre=par(2)
	sigma=par(3)

	peak=EXP(-0.5*((x-centre)/sigma)^2)
	gauss=bkgd+height*peak

	IF (N_PARAMS() GE 4) THEN BEGIN
		dfda=0.*x+1.
		dfdb=peak
		dfdc=height*peak*(x-centre)/sigma^2
		dfdd=height*peak*(x-centre)^2/sigma^3
		PD=[[dfda],[dfdb],[dfdc],[dfdd]]
	ENDIF

	END

;----------------------------------------------------------------------------
;****************************************************************************

	PRO fitgauss, x_in, y_in, e_in, xmin, xmax, par, dpar, ispec, all=all, $
		      plot=plot

	iprint=0
	IF KEYWORD_SET(plot) THEN iplot=1 ELSE iplot = 0

	IF (iprint GT 0) THEN PRINT,'Start fitgauss:'

	sx=SIZE(x_in)
	npts=sx(1)

	IF (N_ELEMENTS(ispec) LT 1) THEN ispec=0
	IF KEYWORD_SET(all) THEN allpoints=1 ELSE allpoints=0
	IF (iprint GT 0) THEN PRINT,'npts=',npts

;---------------------------------------------------------------------

	IF (iprint GT 0) THEN PRINT,'Starting x-range extraction section'

	i=WHERE(x_in GE xmin AND x_in LE xmax,ndat)
	xdat=x_in(i)
	ydat=y_in(i)
	edat=e_in(i)
	i1=WHERE(edat EQ 0.,n1)
	IF (n1 GE 1) THEN BEGIN
		i2=WHERE(edat GT 0.,n2)
		IF (n2 LE 0) THEN BEGIN
			par=[0.,0.,(xmin+xmax)/2.,xmax-xmin]
			dpar=[0.,0.,xmax-xmin,xmax-xmin]
			GOTO, finished
		ENDIF
		emin=MIN(edat(i2))
		edat(i1)=emin
	ENDIF

	bkgd=(ydat(0)+ydat(ndat-1))/2.
	height=MAX(ydat,imax)
	IF (imax EQ ndat-1 OR imax EQ 0) THEN notenough=1 ELSE notenough=0
	centre=xdat(imax)
	hh=(height-bkgd)/2.+bkgd
	hh1=WHERE(ydat(0:imax) LT hh, n)
	IF (n EQ 0) THEN i1=0 ELSE i1=MAX(hh1)
	hh2=WHERE(ydat(imax:ndat-1) LT hh, n)
	IF (n EQ 0) THEN i2=0 ELSE i2=MIN(hh2)	& i2=i2+imax
	FWHM=xdat(i2)-xdat(i1+1)

	IF (allpoints EQ 0) THEN BEGIN
		i=WHERE(ABS(xdat-centre) LE FWHM, n)
		IF (n LE 4) THEN BEGIN
			n=5
			i=[imax-2,imax-1,imax,imax+1,imax+2]
			IF (i(0) LT 0) THEN i=i+1
			IF (i(0) LT 0) THEN i=i+1
			IF (i(4) GE ndat) THEN i=i-1
			IF (i(4) GE ndat) THEN i=i-1
			FWHM=xdat(i(4))-xdat(i(0))
			centre=xdat(i(2))
		ENDIF
		ndat=n
		xdat=xdat(i)
		ydat=ydat(i)
		edat=edat(i)
	ENDIF
	wdat=1./edat^2

	IF (iplot GT 0) THEN BEGIN
		PLOT, xdat, ydat, PSYM=4, SYMSIZE=0.4, $
			TITLE='Spectrum '+STRING(STRTRIM(ispec,2))
		ERRPLOT, xdat, ydat-edat/2., ydat+edat/2.
	ENDIF

;---------------------------------------------------------------------

	IF (iprint GT 0) THEN PRINT,'Starting fitting section'

	par=FLTARR(4)	& dpar=par
	par(0)=bkgd	& par(1)=height	& par(2)=centre	& par(3)=FWHM/2.355

	IF (iplot GT 0) THEN BEGIN
		dx=(xmax-xmin)/1000.
		xplot=xmin+FLOAT(INDGEN(1000))*dx
		gaussian, xplot, par, ystart
		OPLOT, xplot, ystart, LINE=1
	ENDIF

	ymean=TOTAL(ydat,1)/FLOAT(ndat)
	i=WHERE(ABS(ydat-ymean) GT 2.*edat, n)
	IF (n LE 1 OR notenough EQ 1) THEN BEGIN
		PRINT,'fitgauss: Error - peak not found in spectrum',ispec
		dpar(*)=-1.
	ENDIF ELSE yfit=CURVEFIT(xdat,ydat,wdat,par,dpar,FUNCTION_NAME='gaussian')

	IF (iplot GT 0) THEN BEGIN
		gaussian, xplot, par, yfit
		OPLOT, xplot, yfit, LINE=0
		PRINT,'Hit return to continue'	& wait=''
		READ, wait
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of fitting section'

;---------------------------------------------------------------------

	IF (iprint GT 0) THEN BEGIN
		pname=STRARR(4)
		pname(0)='Background'
		pname(1)='Height'
		pname(2)='Centre'
		pname(3)='Sigma'
		FOR i=0,3 DO PRINT, pname(i), par(i), dpar(i), $
			FORMAT='(A10," =",F7.2," +/-",F6.2)'
	ENDIF

finished:
	RETURN
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION fit_poly, w_in, degree=npoly, np

; Fits a polynomial of degree npoly in the x-dimension to one- or 
; two-dimensional data
;
;ARGUMENTS:
; degree	:degree of polynomial to fit the data with
;
;DIMENSIONS:
; 1-d or 2d data
;
;COMMAND SYNTAX:
; w3=fit_poly(w2,degree=<degree>)
;
;						KHA,JRS 21/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	w_out=w_in

	take_datp, datp
	IF(N_ELEMENTS(np) GT 0) THEN npoly=np

	x_in=datp.x
	e_in=datp.e

	sw=SIZE(w_in)
	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN e_in=SQRT(w_in)

	IF (sw(0) EQ 1) THEN BEGIN
		poly=POLYFITW(x_in,w_in,1./e_in^2,npoly,w_out)
	ENDIF ELSE IF (sw(0) EQ 2) THEN BEGIN
		nx=sw(1)
		ny=sw(2)
		x0=x_in
		FOR iy=0,ny-1 DO BEGIN
			w0=w_in(*,iy)
			e0=e_in(*,iy)
			poly=POLYFITW(x0,w0,1./e0^2,npoly,w0)
			w_out(*,iy)=w0
		ENDFOR
	ENDIF ELSE BEGIN
		PRINT,'Fit_poly: Error - workspace dimensions cannot be greater than 2'
		GOTO, finished
	ENDELSE

finished:
	mod_datp, datp, "e", 0
	give_datp, datp

	RETURN, w_out
	END
FUNCTION freefit,xx,ww,aa,astep,amin,amax
;
success=0
a = aa(*,0,0)
x = xx(*,0,0)
w = ww(*,0,0)
inistep=astep
ncycles = 4
IF n_elements(x) gt 6 AND n_elements(w) eq n_elements(x) THEN BEGIN
  success = 1
  WHILE n_elements(a) lt 6 DO a = [a(0:n_elements(a)-1),0]
  FUNCT,x,a,f
  FOR cycle= 0,ncycles DO IF success EQ 1 THEN BEGIN
    FOR i=0,5 DO IF astep(i) GT 0 AND success EQ 1 THEN BEGIN
      step=inistep(i)
      Rnew=TOTAL(ABS(w-f))
	     Rold=Rnew
	     print,cycle,i,a(i),Rnew
      R1=0
						R2=0
						R3=0
      REPEAT BEGIN
						  R = Rnew
        IF R3 NE 0 THEN BEGIN
								  R2=R3
										a2=a3
								ENDIF
        IF R1 NE 0 THEN BEGIN
								  R3=R1
										a3=a1
								ENDIF
        a(i)=a(i)+step
	       FUNCT,x,a,f
        Rnew=TOTAL(ABS(w-f))
								step=step*2
	      print,cycle,i,a(i),Rnew,R
						  a1=a(i)
						  R1=Rnew
      ENDREP UNTIL Rnew GT R OR a(i) GE amax(i)+step; result becomes worse
						IF a(i) GE amax(i)+step THEN success = 0
      step=inistep(i)
      IF success EQ 1 THEN IF R2 EQ 0 THEN REPEAT BEGIN
						  R = Rnew
        a(i)=a(i)-step
	       FUNCT,x,a,f
        Rnew=TOTAL(ABS(w-f))
								step=step*2
	      print,cycle,i,a(i),Rnew,R
						  a2=a(i)
						  R2=Rnew
      ENDREP UNTIL Rnew GT R OR a(i) LE amin(i)-step; result becomes worse
      IF a(i) LE amin(i)-step THEN success = 0
			  	IF success EQ 1 THEN BEGIN
				  		a(i)=a2+R2/(R2+R1)*(a1-a2)
	       FUNCT,x,a,f
        R3=TOTAL(ABS(w-f))
				  		a3=a(i)
        print,a2,a3,a1,R3
        REPEAT BEGIN
						    a(i)=a3+R3/(R3+R1)*(a1-a3)
	         FUNCT,x,a,f
          R13=TOTAL(ABS(w-f))
						  	 a13=a(i)
  				  		a(i)=a2+R2/(R2+R3)*(a3-a2)
	         FUNCT,x,a,f
          R23=TOTAL(ABS(w-f))
						  		a23=a(i)
						  	 IF R13 LE R23 THEN BEGIN
								    R2=R3
								  		R3=R13
								  		a2=a3
								  		a3=a13
							  	ENDIF ELSE BEGIN
								    R1=R3
									  	R3=R23
								  		a1=a3
									  	a3=a23
						  		ENDELSE
          print,a2,a3,a1,R3
        ENDREP UNTIL (a1-a2) LE inistep(i)/10. ; OR  (a1-a2) LE ABS(a3)/1000000.; AND Rold GE R3; stepwidth
 					  a(i)=a3
						  IF a(i) GT amax(i) OR a(i) LT amin(i) THEN success = 0
      ENDIF
    ENDIF
  ENDIF
		aa=a
  return,success
 ; print,'freefallfit success: ',aa
ENDIF ELSE BEGIN
;  print,'freefallfit without success'
  return,success
ENDELSE
END

FUNCTION fit,w,a,PRINT=printing,freeprint=freeprint,PLOT=plot,$
                 freefall=free,xx=xx,datp=datp,$
                 xmin=xmin,xmax=xmax,$
                 nterms=nterms,$
                 pikmin=pikmin,pikmax=pikmax,$
                 sigmaa=sigmaa,$
                 voigt=voigt,asym=asym,peaks=NbOfPeaks,around=around
;
; Started: 04-Nov-96 by Th.Hansen, ILL-Grenoble
; Gaussian fit for sequential diagrams and multiple peaks 
;
; w is a LAMP workspace, it might be three-dimensional 
; - in that case sequential fits will be performed
; a is a vector with max. six elements or an array (<6 x number_of_peaks)
; each peak is fitted seperately sequentially after their intensities
; they are NOT simultaneously fitted and that may cause problems, even crashes of LAMP
;
; Modification 22-May-97 by Th. HANSEN:; 
; Modification 08-Sep-97 by Th. HANSEN:; several bugs fixed (array-indexing for a and x, etc.)
; Modification 04-Nov-97 by Th. HANSEN:; Voigt function and asymmetry correction ... ?

IF NOT KEYWORD_SET(datp) THEN take_datp,datp
f = 0.0*w
IF NOT KEYWORD_SET(xx) THEN x=datp.x ELSE x=xx
IF n_params() le 1 OR TOTAL(a) EQ 0 THEN BEGIN
  IF NOT KEYWORD_SET(xmin) THEN BEGIN
    a=[max(w(*,0),i),xx(i,0),xx(1)-xx(0),min(w(*,0))];,0.0,0.0] 
  ENDIF ELSE BEGIN
    a=FLTARR(4,N_ELEMENTS(xmin))
    FOR j=0,N_ELEMENTS(xmin)-1 DO BEGIN
      index=WHERE(xx(*,0) GE xmin AND xx(*,0) LE xmax)
      a(*,j)=[max(w(index,0),i),xx(i,0),xx(1)-xx(0),min(w(index,0))];,0.0,0.0] 
    ENDFOR  
  ENDELSE
ENDIF
IF NOT KEYWORD_SET(nterms) THEN nterms=(n_elements(a(*,0,0))>4)<6
IF n_elements(a(*,0,0)) lt 4 THEN BEGIN
  a=[a(0:n_elements(a(*,0,0))-1,*,*),fltarr(4-n_elements(a(*,0,0)),n_elements(a(0,*,0)),n_elements(a(0,0,*)))]
ENDIF
WHILE n_elements(a(0,0,*)) lt n_elements(w(0,*)) DO $
  a=[[[a(*,*,*)]],[[a(*,*,n_elements(a(0,0,*))-1)]]]
  sigmaa=a
WHILE n_elements(x(0,*)) lt n_elements(w(0,*)) DO $
  x=[[x(*,*)],[x(*,n_elements(x(0,*))-1)]]
IF keyword_set(printing) THEN print,'Step No Peak-Heigth    Position 2.355*Sigma Residu.' 
IF N_ELEMENTS(x(0,*)) LE 1 THEN BEGIN
  range=lindgen(n_elements(w(*,0)))
  points=n_elements(w(*,0))
  IF KEYWORD_SET(xmin)                     THEN range=min(range)+WHERE(x(range) GE xmin,points)
  IF points GT 6 THEN IF KEYWORD_SET(xmax) THEN range=min(range)+WHERE(x(range) LE xmax,points)
  IF points GT 6 THEN IF KEYWORD_SET(pikmin) THEN IF MAX(x(range)) LT pikmin THEN points=0
  IF points GT 6 THEN IF KEYWORD_SET(pikmax) THEN IF MIN(x(range)) GT pikmax THEN points=0
ENDIF
FOR i=0L,LONG(n_elements(w(0,*))-1) DO BEGIN
  IF NOT KEYWORD_SET(NbOfPeaks) THEN NbOfPeaks=n_elements(a(0,*))
  IF N_ELEMENTS(x(0,*)) GT 1 THEN BEGIN
    range=lindgen(n_elements(w(*,i)))
    points=n_elements(w(*,i))
    IF KEYWORD_SET(xmin)                     THEN range=min(range)+WHERE(x(range,i) GE xmin,points)
    IF points GT 6 THEN IF KEYWORD_SET(xmax) THEN range=min(range)+WHERE(x(range,i) LE xmax,points)
    IF points GT 6 THEN IF KEYWORD_SET(pikmin) THEN IF MAX(x(range,i)) LT pikmin THEN points=0
    IF points GT 6 THEN IF KEYWORD_SET(pikmax) THEN IF MIN(x(range,i)) GT pikmax THEN points=0
  ENDIF 
  outer_range=LONG(range)
  IF points GT 6 THEN BEGIN
   ws=smooth(w(range,i),3+N_ELEMENTS(w(range,i))/100)
   FOR j=0l,long(NbOfPeaks-1) DO BEGIN
    range=LONG(outer_range)
   ; print,points,min(range),max(range),x(min(range),i<(N_ELEMENTS(x(0,*))-1)),x(max(range),i<(N_ELEMENTS(x(0,*))-1))
	aa=fltarr(6)
	aa(3)=MIN(ws)>0
	aa(0)=MAX(ws,ind)-aa(3)
	aa(1)=x(LONG(min(range))+LONG(ind),i)
	tmp= (MAX(WHERE(ws(0:ind) LE aa(0)/2.+aa(3)))>0)-min(range)
	tmp2=(MIN(WHERE(ws(ind:N_ELEMENTS(ws)-1) LE aa(0)/2.+aa(3)))+ind)-min(range)
	IF tmp2 LT 0 THEN tmp2=N_ELEMENTS(ws)-1
	IF KEYWORD_SET(around) THEN range=WHERE((x(*,i) LE aa(1)+around) AND (x(*,i) GE aa(1)-around))
	aa(2)=(x(tmp2,i)-x(tmp,i))/2.5
    IF 9.*aa(0) LE ((2.*a(3,0,i)) > aa(3)) THEN BEGIN
      IF keyword_set(printing) THEN BEGIN
         print,FORMAT='(I4,I3,F12.2,F12.4,F12.4,F8.2," no peak")',i,j,aa(0),aa(1),aa(2),aa(3)
      ENDIF
	  aa=0
      j=long(NbOfPeaks-1)
	ENDIF ELSE BEGIN
      IF keyword_set(printing) AND KEYWORD_SET(freeprint) THEN BEGIN
         print,FORMAT='(I4,I3,F12.2,F12.4,F12.4,F8.2," okay")',i,j,aa(0),aa(1),aa(2),aa(3)
      ENDIF
	ENDELSE
	IF KEYWORD_SET(free) THEN BEGIN
      IF TOTAL(aa) NE 0 THEN BEGIN 
	    tmp=freefit(x(range,i), w(range,i)-f(range,i), aa,[1.,0.1,0.1,1.,0.,0.],[MIN(ws)>0,MIN(x(range,i)),0.05,MIN(ws),0,0],[MAX(ws)-(MIN(ws)<0),MAX(x(range,i)),10.,MAX(ws),0,0])
        IF keyword_set(printing) THEN BEGIN
          print,FORMAT='(I4,I3,F12.2,F12.4,F12.4,F8.2," freefit")',i,j,aa(0),aa(1),aa(2),aa(3)
        ENDIF
  	    IF tmp NE 1 OR aa(0) LE ((2.*a(3,0,i) > 3) > aa(3)) OR aa(1) LT MIN(x(range,i)) OR aa(1) GT MAX(x(range,i)) THEN BEGIN
          aa=0
          j=long(NbOfPeaks-1)
	    ENDIF ; freefallfit
	  ENDIF ; freefallfit
	ENDIF
    IF TOTAL(aa) NE 0 THEN BEGIN 
	  aa=aa(0:nterms-1)
	  sigmaaa=aa(0:nterms-1)
	  IF NOT KEYWORD_SET(voigt) THEN BEGIN     
        f(range,i) = f(range,i) + gaussfit (x(range,i), w(range,i)-f(range,i), aa,NTERMS=nterms,w=w(range,i)/datp.e(range,i),sigmaa=sigmaaa) 
      ENDIF ELSE BEGIN
        ;f(range,i) = f(range,i) + voigtfit (x(range,i), w(range,i)-f(range,i), aa,NTERMS=nterms,w=w(range,i)/datp.e(range,i),sigmaa=sigmaaa) 
      ENDELSE
      IF nterms LT 6 THEN aa=[aa,fltarr(6-nterms)]
      IF KEYWORD_SET(plot) THEN BEGIN
        PLOT,x(range,i),w(range,i),TITLE=STRING(i),YRANGE=[0,MAX(w(range,i))]
        PLOT,x(range,i),f(range,i),/NOERASE,TITLE=STRING(i),YRANGE=[0,MAX(w(range,i))]
      ENDIF
      siga=100.0*TOTAL(ABS(w(range,i)-f(range,i)))/TOTAL(w(range,i))
      a(0:nterms-1,j,i) = aa(0:nterms-1)
      sigmaa(0:nterms-1,j,i) = sigmaaa(0:nterms-1)
      IF keyword_set(printing) THEN print,FORMAT='(I4,I3,F12.2,F12.4,F12.4,F12.4,F12.4,F12.4)',i,j,a(0,j,i),a(1,j,i),a(2,j,i),a(3,j,i),siga,sigmaaa(0)
    ENDIF
    ws=smooth(w(range,i)-f(range,i),3+N_ELEMENTS(w(range,i))/100)
  ENDFOR
  ENDIF
ENDFOR
give_datp,datp
return,f
END

pro flag,bad=bad,nobad=nobad,int=int,noint=noint,ang=ang,noang=noang,$
         wav=wav,nowav=nowav,nor=nor,nonor=nonor,flp=flp,noflp=noflp,eff=eff,noeff=noeff,$
									old=old,new=new,noprint=noprint,cor=cor,nocor=nocor,soft=soft

;if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION P_LAMBDA')

;+
; Macro written by Thomas Hansen in 1997 to set some options for the import of D20 raw data
; Modification 2/98 : Monitor normalisation is long integer, otherwise bug ...
; Modification 2/98 : Monitor normalisation is floating point, otherwise bug ...
; Modification 6/98 : Monitor normalisation is floating point, otherwise bug ...
;-

common d20  , bad_d20 ,flag_d20, wav_d20, psd_d20  
common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6

IF NOT KEYWORD_SET(soft) OR N_ELEMENTS(flag_d20) LT 8 THEN BEGIN
    IF  KEYWORD_SET(soft) THEN PRINT,'No information in common flag_d20 (calibration)'
    tmf='rdid.flag'
    tmc=FINDFILE(tmf,count=tmp)
    p_lambda,plambda
    IF tmp EQ 0 THEN begin tmf=PLAMBDA+'/CALIBRATION/rdid.flag'
			   tmc=FINDFILE(tmf,count=tmp) & endif

    bad_flag=0 & interpol_flag=0 & ang_flag=0 & wav_flag=0 & normalize=float(0) & float_flag=0 & eff_flag=0 & cor_flag=0
    IF tmp EQ 1 THEN begin
	 			OPENR,tmp,tmf,/get_lun 
				IF NOT EOF(tmp) THEN READF,tmp,bad_flag
				IF NOT EOF(tmp) THEN READF,tmp,interpol_flag
				IF NOT EOF(tmp) THEN READF,tmp,ang_flag
				IF NOT EOF(tmp) THEN READF,tmp,wav_flag
				IF NOT EOF(tmp) THEN READF,tmp,normalize
				IF NOT EOF(tmp) THEN READF,tmp,float_flag
				IF NOT EOF(tmp) THEN READF,tmp,eff_flag
				IF NOT EOF(tmp) THEN READF,tmp,cor_flag 
				FREE_LUN,tmp
     ENDIF ELSE BEGIN
	cor_flag=0
	print,'rdid.flag not complete'
     ENDELSE
     old=[bad_flag,interpol_flag,ang_flag,wav_flag,normalize,float_flag,eff_flag,cor_flag]
ENDIF ELSE BEGIN
				bad_flag=     flag_d20(0)
				interpol_flag=flag_d20(1)
				ang_flag=     flag_d20(2)
			 wav_flag=     flag_d20(3)
				normalize=    flag_d20(4)
				float_flag=   flag_d20(5)
				eff_flag  =   flag_d20(6)
				cor_flag=     flag_d20(7)
ENDELSE

IF NOT KEYWORD_SET(bad)  THEN bad=bad_flag
IF KEYWORD_SET(nobad)    THEN bad=0
IF NOT KEYWORD_SET(int)  THEN int=interpol_flag
IF KEYWORD_SET(noint)    THEN int=0
IF NOT KEYWORD_SET(ang)  THEN ang=ang_flag
IF KEYWORD_SET(noang)    THEN ang=0
IF NOT KEYWORD_SET(wav)  THEN wav=wav_flag
IF KEYWORD_SET(nowav)    THEN wav=0
IF NOT KEYWORD_SET(nor)  THEN nor=float(normalize)
IF nor EQ 1              THEN nor=float(100000)
IF KEYWORD_SET(nonor)    THEN nor=float(0)
IF NOT KEYWORD_SET(flp)  THEN flp=float_flag
IF KEYWORD_SET(noflp)    THEN flp=0
IF NOT KEYWORD_SET(eff)  THEN eff=eff_flag
IF KEYWORD_SET(noeff)    THEN eff=0
IF NOT KEYWORD_SET(cor)  THEN cor=cor_flag
IF KEYWORD_SET(nocor)    THEN cor=0
IF NOT KEYWORD_SET(new)  THEN BEGIN
  IF NOT KEYWORD_SET(noprint) THEN BEGIN
    PRINT,'      RDID Flags                  old          new'
    PRINT,'BAD cell exclusion          ',bad_flag     ,bad    
    PRINT,'INTerpolation               ',interpol_flag,int
    PRINT,'ANGle calibration           ',ang_flag     ,ang
    PRINT,'WAVelength from *.cal       ',wav_flag     ,wav
    PRINT,'NORmalization to monitor    ',normalize    ,nor
    PRINT,'workspace in FLoating Point ',float_flag   ,flp
    PRINT,'EFFiciency correction       ',eff_flag     ,eff
    PRINT,'CORection of time/monitor   ',cor_flag     ,cor
		ENDIF
  IF NOT KEYWORD_SET(soft) THEN BEGIN 
    OPENW ,tmp,'rdid.flag',/get_lun 
    PRINTF,tmp,bad
    PRINTF,tmp,int
    PRINTF,tmp,ang
    PRINTF,tmp,wav
    PRINTF,tmp,nor
    PRINTF,tmp,flp
    PRINTF,tmp,eff
    PRINTF,tmp,cor
    CLOSE ,tmp
    free_lun ,tmp
		ENDIF
		new=[bad,int,ang,wav,nor,flp,eff,cor]
ENDIF ELSE BEGIN
new=[new,0,0,0,0,float(0),0,0,0]
new=new(0:7)
  IF NOT KEYWORD_SET(noprint) THEN BEGIN
    PRINT,'      RDID Flags                  old          new'
    PRINT,'BAD cell exclusion          ',bad_flag     ,new(0)   
    PRINT,'INTerpolation               ',interpol_flag,new(1)
    PRINT,'ANGle calibration           ',ang_flag     ,new(2)
    PRINT,'WAVelength from *.cal       ',wav_flag     ,new(3)
    PRINT,'NORmalization to monitor    ',normalize    ,new(4)
    PRINT,'workspace in FLoating Point ',float_flag   ,new(5)
    PRINT,'EFFiciency correction       ',eff_flag     ,new(6)
    PRINT,'CORection of time/monitor   ',cor_flag     ,new(7)
		ENDIF
  IF NOT KEYWORD_SET(soft) THEN BEGIN 
    OPENW ,tmp,'rdid.flag',/get_lun 
    for i=0,7 DO PRINTF,tmp,new(i)
    CLOSE ,tmp
    free_lun ,tmp
		ENDIF
ENDELSE
;IF new(6)-eff_flag GE 1 THEN inf_d20='autod20.cal'
flag_d20=new
;print,flag_d20
END

PRO florin,n1,n2,n3,w11,x11,y11,e11

saml=10.
beam=0.7

xpixels=286
mmpp=1.04
dpr=180./!pi
pcen=137.6
pp0=142.3
d0=0
points=n2-n1+1
san=fltarr(points)
dan=fltarr(points)
w10=fltarr(xpixels,points)
e10=fltarr(xpixels,points)
x10=fltarr(xpixels,points)
y10=fltarr(xpixels,points)
water=fltarr(xpixels)
close,3


;  open water correction file created by awater.pro
openr,3,'water_LAMPascii'

for  i=0,xpixels-1 do begin
  readf,3,a,b,c
  water(i)=b
endfor

; open background file read into wb
if n3 ne 0 then begin
  data_read,n3,wb,w2,y,m,q,th,s,d,dett,nx,timeb
endif else begin
  wb=0.
  timeb=1.
endelse


for j=0,points-1 do begin
  num=j+n1
  data_read,num,w1,w2,y,m,q,th,s,d,dett,nx,time
  san(j)=s
  dan(j)=d
  foot=saml*sin(s/dpr)
  w10(*,j)=(w1/(time*water))-wb/(timeb*water)
  e10(*,j)= sqrt(w1/(time*water)^2.+  wb/(timeb*water)^2.)


  x10(*,j)=(d+dpr*atan((pcen-indgen(xpixels))*mmpp/dett))-(d0+dpr*atan((pcen-pp0)*mmpp/dett))-s
endfor

print,'det dist=',dett
print,'time= ',time

for i=0,points-1 do begin
  for j=0,285 do begin
   y10(j,i)=san(i)
  endfor
endfor
close,3


sizex=300
sizey=100

gs=[(max(x10)-min(x10))/sizex,(max(y10)-min(y10))/sizey]


triangulate,x10,y10,triangles
x11=indgen(sizex+1)*(max(x10)-min(x10))/sizex+min(x10)
y11=indgen(sizey+1)*(max(y10)-min(y10))/sizey+min(y10)
w11=trigrid(x10,y10,w10,triangles,gs)
e11=trigrid(x10,y10,e10,triangles,gs)




end
;-----------------------------------------------------------------------------
;*****************************************************************************
;
	FUNCTION fold, w_in

;For single-crystal D7 data (omega scan mode)
;Folds the four quadrants of the Qx-Qy plane, output from QxQy.pro, into one.
;
;DIMENSIONS:
; w_in(nQ.nQ) -> w_out(nQ/2,nQ/2)
;
;COMMAND SYNTAX:
; w10=fold(w9)
;
;							KHA, 15/7/98
;------------------------------------------------------------------------------
;******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	take_datp, datp

	check=SIZE(w_in)

	nx=check(1)
	ny=check(2)
	x_in=datp.x
	y_in=datp.y

	se=SIZE(datp.e)
	IF (se(0) NE 2) THEN BEGIN
; If datp.e is not set, then assume w_in(ix,iy)=0 => outside the measured region
		e_in=FLTARR(nx,ny)
		FOR ix=0,nx-1 DO FOR iy=0,ny-1 DO $
		  IF (w_in(ix,iy) EQ 0.) THEN e_in(ix,iy)=-1. ELSE e_in(ix,iy)=1.
	ENDIF ELSE e_in=datp.e

	w_buf=w_in
	e_buf=e_in^2
	n_buf=w_in*0.

	xeven=0
	xodd=0
	IF (2*(nx/2) EQ nx) THEN xeven=1 ELSE xodd=1
	yeven=0
	yodd=0
	IF (2*(ny/2) EQ ny) THEN yeven=1 ELSE yodd=1

	IF (iprint GT 0) THEN BEGIN
		PRINT,'nx=',nx,' xeven=',xeven,' xodd=',xodd
		PRINT,'ny=',ny,' yeven=',yeven,' yodd=',yodd
	ENDIF

	ixL1=0
	IF (xeven EQ 1) THEN ixL2=nx/2-1 ELSE ixL2=nx/2
	ixR1=nx/2
	ixR2=nx-1

	iyB1=0
	IF (yeven EQ 1) THEN iyB2=ny/2-1 ELSE iyB2=ny/2
	iyT1=ny/2
	iyT2=ny-1

	n_buf(*)=0.
	i=WHERE(e_in GE 0., n)
	IF (n GE 1) THEN n_buf(i)=1.

	i=WHERE(e_in LT 0., n)
	IF (n GE 1) THEN e_buf(i)=0.

;	PRINT,'w_buf=',w_buf
;	PRINT,'e_buf=',e_buf
;	PRINT,'n_buf=',n_buf

	w_buf1=REVERSE(w_buf,1)	& w_buf=w_buf+w_buf1
	e_buf1=REVERSE(e_buf,1)	& e_buf=e_buf+e_buf1
	n_buf1=REVERSE(n_buf,1)	& n_buf=n_buf+n_buf1

	w_buf1=REVERSE(w_buf,2)	& w_buf=w_buf+w_buf1
	e_buf1=REVERSE(e_buf,2)	& e_buf=e_buf+e_buf1
	n_buf1=REVERSE(n_buf,2)	& n_buf=n_buf+n_buf1

	nx=ixR2-ixR1+1	& x_out=x_in(ixR1:ixR1+nx-1)

	ny=iyT2-iyT1+1	& y_out=y_in(iyT1:iyT1+ny-1)

	w_out=w_buf(ixR1:iXR1+nx-1,iyT1:iyT1+ny-1)
	e_out=SQRT(e_buf(ixR1:iXR1+nx-1,iyT1:iyT1+ny-1))
	n_out=n_buf(ixR1:iXR1+nx-1,iyT1:iyT1+ny-1)

	i=WHERE(n_out GT 0., n)
	IF (n GE 1) THEN w_out(i)=w_out(i)/n_out(i)
	IF (n GE 1) THEN e_out(i)=e_out(i)/n_out(i)

	i=WHERE(n_out LE 0., n)
	IF (n GE 1) THEN w_out(i)=0.
	IF (n GE 1) THEN e_out(i)=-1.

	mod_datp, datp, "x", x_out
	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	PRINT,'Fold: four quadrants folded into one'
	datp.other_tit=datp.other_tit+' -fo'
finished:
	give_datp, datp

	RETURN, w_out
	END
FUNCTION fpread2 ,name,first,last,searchstring
;********
;**
;** The call is w6=fpread2('khp',1000,1122,'Background')
; 

take_datp,datp
Wout=0.0
x=0
E=0.0
value=0.0
error=0.0
length=STRLEN(searchstring)
for i=first,last do begin
  files=FINDFILE(name+STRCOMPRESS(i,/RE)+'.sum',COUNT=count)
  IF count GT 0 THEN BEGIN
    openr,file,name+STRCOMPRESS(i,/RE)+'.sum',/get_lun
    line=""
    WHILE STRPOS(line,searchstring) EQ -1 AND NOT EOF(file) DO BEGIN
      READF,file,line
    ENDWHILE
    IF STRPOS(line,searchstring) NE -1 THEN BEGIN
      position=STRPOS(line,searchstring)
      text=STRMID(line,position+length,strlen(line)-position-length)
      READF,file,text
      reads,text,value,error
      Wout=[Wout,value]
      E=[E,error]
      X=[X,i]
    ENDIF ELSE PRINT,'string not found in ',i
    free_lun,file
  ENDIF ELSE PRINT,'file not found for ',i
endfor
Wout=Wout(1:N_ELEMENTS(Wout)-1)
E=E(1:N_ELEMENTS(E)-1)
x=x(1:N_ELEMENTS(x)-1)
MOD_DATP,datp,'e',E
MOD_DATP,datp,'x',X
give_datp,datp
return, Wout
end
FUNCTION fpread3 ,name,first,last,searchstring,searchstring2
;********
;**
;** The call is w14=fpread3('khp',1000,1102,'Conventional','Chi2:')

take_datp,datp
Wout=0.0
E=0.0
x=0
value=0.0
error=0.0
length=STRLEN(searchstring2)
for i=first,last do begin
  files=FINDFILE(name+STRCOMPRESS(i,/RE)+'.sum',COUNT=count)
  IF count GT 0 THEN BEGIN
    openr,file,name+STRCOMPRESS(i,/RE)+'.sum',/get_lun
    line=""
    WHILE STRPOS(line,searchstring) EQ -1 AND NOT EOF(file) DO BEGIN
      READF,file,line
    ENDWHILE
    IF STRPOS(line,searchstring) NE -1 THEN BEGIN
      WHILE STRPOS(line,searchstring2) EQ -1 AND NOT EOF(file) DO BEGIN
         READF,file,line
      ENDWHILE
      IF STRPOS(line,searchstring2) NE -1 THEN BEGIN
        position=STRPOS(line,searchstring2)
        text=STRMID(line,position+length,strlen(line)-position-length)
        ;READF,file,text
        reads,text,value;,error
        Wout=[Wout,value]
        x=[x,i]
        ;E=[E,error]
      ENDIF ELSE PRINT,'string not found in ',i
    ENDIF ELSE PRINT,'string not found in ',i
    free_lun,file
  ENDIF ELSE PRINT,'file not found for ',i
endfor
Wout=Wout(1:N_ELEMENTS(Wout)-1)
;E=E(1:N_ELEMENTS(E)-1)
x=x(1:N_ELEMENTS(x)-1)
;MOD_DATP,datp,'e',E
give_datp,datp
return, Wout
end
FUNCTION fpread4 ,name,first,last,searchstring,searchstring2,$
                  error=rd_error,nextline=nextline
;********
;**
;** The call is w12=fpread4('khp',1000,1102,'Phase No.  1','scale factor : ')

take_datp,datp
Wout=0.0
E=0.0
x=0.0
value=0.0
error=0.0
length=STRLEN(searchstring2)
for i=first,last do begin
  files=FINDFILE(name+STRCOMPRESS(i,/RE)+'.sum',COUNT=count)
  IF count GT 0 THEN BEGIN
    openr,file,name+STRCOMPRESS(i,/RE)+'.sum',/get_lun
    line=""
    WHILE STRPOS(line,searchstring) EQ -1 AND NOT EOF(file) DO BEGIN
      READF,file,line
    ENDWHILE
    IF STRPOS(line,searchstring) NE -1 THEN BEGIN
      WHILE STRPOS(line,searchstring2) EQ -1 AND NOT EOF(file) DO BEGIN
        READF,file,line
      ENDWHILE
      IF STRPOS(line,searchstring2) NE -1 THEN BEGIN
        position=STRPOS(line,searchstring2)
        text=STRMID(line,position+length,strlen(line)-position-length)
        IF KEYWORD_SET(nextline) THEN FOR j=1,nextline DO READF,file,text 
        IF KEYWORD_SET(rd_error) THEN READS,text,value,error ELSE BEGIN
	  READS,text,value
	ENDELSE
        Wout=[Wout,value]
        IF KEYWORD_SET(rd_error) THEN E=[E,error]
        x=[x,i]
      ENDIF ELSE PRINT,searchstring2,' not found in ',i
    ENDIF ELSE PRINT,searchstring,' not found in ',i
    free_lun,file
  ENDIF ELSE PRINT,'file not found for ',i
endfor
IF N_ELEMENTS(Wout) GT 1 THEN BEGIN
  Wout=Wout(1:N_ELEMENTS(Wout)-1)
  IF KEYWORD_SET(rd_error) THEN E=E(1:N_ELEMENTS(E)-1)
  x=x(1:N_ELEMENTS(x)-1)
  MOD_DATP,datp,'e',E
  MOD_DATP,datp,'x',x
  give_datp,datp
  return, Wout
ENDIF
END
FUNCTION fpread ,name,first,last,searchstring
;********
;**
;** The call is w12=fpread4('khp',1000,1102,'scale factor : ')

take_datp,datp
Wout=0.0
E=0.0
x=0
value=0.0
error=0.0
length=STRLEN(searchstring)
for i=first,last do begin
  files=FINDFILE(name+STRCOMPRESS(i,/RE)+'.sum',COUNT=count)
  IF count GT 0 THEN BEGIN
    openr,file,name+STRCOMPRESS(i,/RE)+'.sum',/get_lun
    line=""
    while STRPOS(line,searchstring) EQ -1 AND NOT EOF(file) DO BEGIN
      READF,file,line
    ENDWHILE
    IF STRPOS(line,searchstring) NE -1 THEN BEGIN
      position=STRPOS(line,searchstring)
      text=STRMID(line,position+length,strlen(line)-position-length)
      ;READF,file,text
      reads,text,value,error
      Wout=[Wout,value]
      E=[E,error]
      x=[x,i]
    ENDIF ELSE PRINT,'string not found in ',i
    free_lun,file
  ENDIF ELSE PRINT,'file not found for ',i
endfor
Wout=Wout(1:N_ELEMENTS(Wout)-1)
E=E(1:N_ELEMENTS(E)-1)
x=x(1:N_ELEMENTS(x)-1)
MOD_DATP,datp,'e',E
MOD_DATP,datp,'x',x
give_datp,datp
return, Wout
end
PRO fpscript0 ,name,first,last,hkl
;***
;**
;** The call is fpscript,...

IF NOT KEYWORD_SET(hkl) THEN hkl=0
LF=string(10b)
k=0
l=0
openw,unit,name+'.sh',/get_lun
IF STRPOS(!VERSION.os,'MacOS') NE -1 THEN BEGIN
    printf,unit,'tell application "Finder"'
ENDIF
step=1
if last lt first then step=-1
for i=first+1,last,step do begin
  IF STRPOS(!VERSION.os,'MacOS') NE -1 THEN BEGIN
    printf,unit,'  duplicate file "'+name+STRCOMPRESS(i-1,/REMOVE)+'.pcr"'
    printf,unit,'  try'
    printf,unit,'    delete file "'+name+STRCOMPRESS(i,/REMOVE)+'.pcr"'
    printf,unit,'  end try'
    printf,unit,'  set name of file "'+name+STRCOMPRESS(i-1,/REMOVE)+'.pcr copy" to "'+name+STRCOMPRESS(i,/REMOVE)+'.pcr"'
    FOR j=1,hkl DO BEGIN
      printf,unit,'  duplicate file "'+name+STRCOMPRESS(i-1,/REMOVE)+STRCOMPRESS(j,/REMOVE)+'.hkl"'
      printf,unit,'  try'
      printf,unit,'    delete file "'+name+STRCOMPRESS(i,/REMOVE)+STRCOMPRESS(j,/REMOVE)+'.hkl"'
      printf,unit,'  end try'
      printf,unit,'  set name of file "'+name+STRCOMPRESS(i-1,/REMOVE)+STRCOMPRESS(j,/REMOVE)+'.hkl copy" to "'+name+STRCOMPRESS(i,/REMOVE)+STRCOMPRESS(j,/REMOVE)+'.hkl"'
    ENDFOR
    printf,unit,'  open file "'+name+STRCOMPRESS(i,/REMOVE)+'.pcr" using file "HansenG3:Applications (Mac OS 9):JFullProf:FullProf"'
    printf,unit,'tell application "Igor Pro"'
    printf,unit,'  Do Script "dowindow/k graph1;LoadWave/T/O \"'+name+STRCOMPRESS(i,/REMOVE)+'.prf\""'
    printf,unit,'  Do Script "Redimension/N=(-1,'+STRCOMPRESS(i-first+1,/RE)+') calc obs;calc[]['+STRCOMPRESS(i-first,/RE)+']=icalc[p];obs[]['+STRCOMPRESS(i-first,/RE)+']=iobs[p]"'
    printf,unit,'end tell'
    k=k+1
    IF k EQ 40 THEN BEGIN
      printf,unit,'end tell'
      free_lun,unit
      openw,unit,name+STRCOMPRESS(l)+'.sh',/get_lun
      l=l+1
      k=0
    ENDIF
  ENDIF ELSE BEGIN
    printf,unit,"cp "+name+STRCOMPRESS(i-step,/REMOVE)+".pcr "+name+STRCOMPRESS(i,/REMOVE)+".pcr "
    printf,unit,"fullprof "+name+STRCOMPRESS(i,/REMOVE)
  ENDELSE
endfor
IF STRPOS(!VERSION.os,'MacOS') NE -1 THEN BEGIN
    printf,unit,'end tell'
ENDIF
free_lun,unit
end
PRO fpscript ,name,first,last,hkl=hkl
;***
;**
;** The call is fpscript,'khp',1216,1387,/hkl

IF NOT KEYWORD_SET(hkl) THEN hkl=0
openw,unit,name+'.sh',/get_lun
for i=first+1,last do begin
  printf,unit,"cp "+name+STRCOMPRESS(i-1,/REMOVE)+".pcr "+$
                    name+STRCOMPRESS(i,/REMOVE)+".pcr "
  FOR j=1,hkl DO BEGIN
    PRINTF,unit,"cp "+name+STRCOMPRESS(i-1,/REMOVE)+STRCOMPRESS(j,/REMOVE)+$
                ".hkl "+name+STRCOMPRESS(i,/REMOVE)+STRCOMPRESS(j,/REMOVE)+$
                ".hkl "
  ENDFOR
  printf,unit,"fullprof "+name+STRCOMPRESS(i,/REMOVE)
endfor
free_lun,unit
end
pro fred

openr,6,'data_d17b.'
nb_neutron=40000






time1=intarr(nb_neutron)
time2=intarr(nb_neutron)
time3=intarr(nb_neutron)
time4=intarr(nb_neutron)
timea=intarr(nb_neutron)
time1r=intarr(nb_neutron)
time2r=intarr(nb_neutron)
time3r=intarr(nb_neutron)
time4r=intarr(nb_neutron)
timear=intarr(nb_neutron)


ll=fltarr(10)
projx1=fltarr(800)
projx2=fltarr(800)
proja=fltarr(4000)

hit12=fltarr(3,3)
hit34=fltarr(3,3)


d1=0
d2=0
d3=0
d4=0
d5=0
d6=0
d7=0
d8=0
d9=0
d10=0


rejected=0

i=0.0
j=0.0
num=0.0
ix=0
while ( NOT eof(6) AND (i LT nb_neutron-1)AND (j LT nb_neutron-1)) do begin


readf,6,d1,d2,d3,d4,d5,d6,d7,d8,d9,d10
ix=ix+1
;put the values into time and hit arrays inside the loop otherwise we make statistics on 
;un-rejected data


;  single pulse neutrons
 if( (d5 EQ 1) AND (d6 EQ 1) AND (d7 EQ 1) AND (d8 EQ 1) AND (d9 EQ 1)  ) then begin


		


		time1(i)=d1
		time2(i)=d2
		time3(i)=d3
		time4(i)=d4
		timea(i)=d10
		
		i=i+1
	        if((d4-d3+400 GT 0) AND (d4-d3+400 LT 800)) then projx1(d4-d3+400)=projx1(d4-d3+400)+1 
	        if((d3 GT 0) AND (d3 LT 800)) then projx2(d3)=projx2(d3)+1
	        if(d10 LT 4000) then proja(d10)=proja(d10)+1
	
		
		
		if(d9 EQ 0) then begin


		time1r(j)=d1
		time2r(j)=d2
		time3r(j)=d3
		time4r(j)=d4
		timear(j)=d10
		
		j=j+1
	        
		end
		
	
	
	
        endif else begin
		rejected=rejected+1
	endelse

end
close,6
num=i
print,'number read in: ',ix
print,'good ones: ',num
print,'rejected: ',rejected



loadct,5
;window,0,retain=2,xsize=650,ysize=600

;plot,time3,time4,PSYM=3,color=69
;window,2,retain=2,xsize=650,ysize=600
;plot,time1,time2,PSYM=3,color=120



window,1,retain=2,xsize=800,ysize=400
plot,time3-time4,time1-time2,color=256,PSYM=3

;window,2,retain=2,xsize=800,ysize=400
;plot,time3r-time4r,time1r-time2r,color=256,PSYM=3

;window,3,retain=2
;plot,projx1,xrange=[600,700]

;window,4,retain=2
;plot,projx2


end ;of procedure fred
PRO functions

print,' '
print,'*** Overview of functions for LAMP on D20SGI ***'
print,' '
print,'Type "result=function(parameter1,parameter2,keyword1=value1,/keyword2)" etc. '
print,' '
print,'IDL Internal functions:'
print,' '
print,'If you have XWindows or an emulator you may call "?" for the exhaustive IDL help '
print,' '
print,'indgen     : Creates an integer array with increasing numbers 0,1,2,3,...'
print,'             "x6=indgen(1600)" replaces the x-values (2theta) for workspace W6'
print,'             by the detector cell numbers (if W6 has 1600 points, of course) '
print,'fltarr     : Creates a floating point array, e.g. "a=fltarr(1600)"'
print,'where      : Gives the indices fullfilling a condition, e.g. "W6(WHERE(X6 LE 0))=W7(WHERE(X6 LE 0))"'
print,'             replaces for negative x-values (2theta) the counts in W6 by the counts in W7'
print,'sort       : Create a sorted list of indices of an array'
print,'smooth     : Smoothes an array'
print,'reform     : Change dimensions of an array but not the number of elements '
print,'n_elements : Give the number of elements of any variable'
print,'total      : Give the sum of an array, or an array containing the sum '
print,'             of rows or columns etc. of a multi-dimensional array '
print,' '
print,' '
print,' '
print,'LAMP Internal functions '
print,' '
print,'You may get more help by clicking on "The Manual" if you are working with the XWindows version '
print,'Otherwise you connect to the LAMP Manual of the Computing for Science group on WWW.ILL.FR '
print,'or you work on WebLamp on BARNS.ILL.FR where you will find a button called "Manual"'
print,' '
print,'rdrun : read a single numor'
print,'rdand : read several numors into a 2D-workspace'
print,'rdsum : read several numors and add them up into one 1D-workspace'
print,' '
print,' '
print,'D20 LAMP functions '
print,' '
print,'You may get more help by typing "function_name,help" '
print,'You find the files function_name.pro in the directory d20sgi.ill.fr:~lambda/macros '
print,' '
print,'monit    : Monitor and check your data and create catalogues'
print,'caliscan : Create the original powder pattern and the efficiencies from'
print,'           a calibration scan'
print,'rdprf    : Reads a profile file (output of fullprof), '
print,'           returns calculated diagram'   
print,' '
print,' '
END
FUNCTION FWHM,U,tt
tt=float(tt)
RETURN,SQRT(U(0)*tan(tt/360*!pi)^2+U(1)*tan(tt/360*!pi)+U(2))
END
PRO	GAUSS_POLY,X,A,F,PDER
;+
; NAME:
;	GAUSS_FUNCT
;
; PURPOSE:
;	EVALUATE THE SUM OF A GAUSSIAN AND A 2ND ORDER POLYNOMIAL
;	AND OPTIONALLY RETURN THE VALUE OF IT`S PARTIAL DERIVATIVES.
;	NORMALLY, THIS FUNCTION IS USED BY CURVEFIT TO FIT THE
;	SUM OF A LINE AND A VARYING BACKGROUND TO ACTUAL DATA.
;
; CATEGORY:
;	E2 - CURVE AND SURFACE FITTING.
; CALLING SEQUENCE:
;	FUNCT,X,A,F,PDER
; INPUTS:
;	X = VALUES OF INDEPENDENT VARIABLE.
;	A = PARAMETERS OF EQUATION DESCRIBED BELOW.
; OUTPUTS:
;	F = VALUE OF FUNCTION AT EACH X(I).
;
; OPTIONAL OUTPUT PARAMETERS:
;	PDER = (N_ELEMENTS(X),6) ARRAY CONTAINING THE
;		PARTIAL DERIVATIVES.  P(I,J) = DERIVATIVE
;		AT ITH POINT W/RESPECT TO JTH PARAMETER.
; COMMON BLOCKS:
;	NONE.
; SIDE EFFECTS:
;	NONE.
; RESTRICTIONS:
;	NONE.
; PROCEDURE:
;	F = A(0)*EXP(-Z^2/2) + A(3) + A(4)*X + A(5)*X^2
;	Z = (X-A(1))/A(2)
; MODIFICATION HISTORY:
;	WRITTEN, DMS, RSI, SEPT, 1982.
;	Modified, DMS, Oct 1990.  Avoids divide by 0 if A(2) is 0.
;	Added to Gauss_fit, when the variable function name to
;		Curve_fit was implemented.  DMS, Nov, 1990.
;   Modified, TCH, Nov 2000. Multipeakfit
;-
  COMMON fit,voigt,nterms,fitflag,key,undo,npeaks,rectangle,bragg,peakpars
  maxindex=N_ELEMENTS(A)-1
  IF voigt EQ 0 THEN peakpars=3 ELSE peakpars=4
  IF rectangle EQ 1 THEN peakpars=peakpars+1
  
; Bragg-Gauss
;  	variable FWHM    =w[2]/tan(w[1]/360*pi)/360*pi 
;  	return (w[0]*2*Sqrt(ln(2)/pi)/w[2] * exp(-((sin(x/360*pi)/sin(w[1]/360*pi)-1)/FWHM)^2*4*ln(2)))+w[4]

; Gauss
;    	return (w[0]*2*Sqrt(ln(2)/pi)/w[2] * exp(-(x-w[1])^2/w[2]^2*4*ln(2)))+w[4]

; Bragg-pseudo-Voigt
;	variable eta=sin(pi/2*w[13])
;	eta*=eta
;	variable FWHM    =w[2]/tan(w[1]/360*pi)/360*pi  
;	variable dx      =sin(x/360*pi)/sin(w[1]/360*pi)-1
; 	variable G       =w[0]*2*Sqrt(ln(2)/pi)/w[2] * exp(-(dx/FWHM)^2*4*ln(2))
;	variable aL=2/pi/FWHM
;	variable bL=4/FWHM^2
;	variable L=aL/(1+bL*dx)
;   	return (1-eta)*G+eta*L+w[4]

; Bragg-Rectangle-Gauss
;	  variable FWHM    =w[2]/tan(w[1]/360*pi)/360*pi 
;	  variable b = 2*Sqrt(ln(2))/FWHM
;	  variable a1= (sin(x/360*pi)/sin((w[1]-w[3]/2)/360*pi)-1)
;	  variable a2= (sin(x/360*pi)/sin((w[1]+w[3]/2)/360*pi)-1)
;	  return w[0]/2/w[3]*(erf((a1)*b)-erf((a2)*b)) +w[4]

; Rectangle-Gauss
;	 variable b = 2*Sqrt(ln(2))/w[2]
;	 variable a = x-w[1]
;	 variable c = w[3]/2
;	 return w[0]/2/w[3]*(erf((a+c)*b)-erf((a-c)*b))  +w[4]

; Bragg-Rectangle-pseudo-Voigt
;	variable eta=sin(pi/2*w[13])
;	eta*=eta
;	variable FWHM    = w[2]/tan(w[1]/360*pi)/360*pi  
;	variable sinx    = sin(x/360*pi)
;	variable dx      = sinx/sin(w[1]/360*pi)-1
;	variable bG      = 2*Sqrt(ln(2))/FWHM
;	variable aG1     = (sinx/sin((w[1]-w[3]/2)/360*pi)-1)
;	variable aG2     = (sinx/sin((w[1]+w[3]/2)/360*pi)-1)
;	variable G       = w[0]               /2/w[3] *(erf((aG1)*bG)-erf((aG2)*bG)) 
;	variable aL=2/pi/FWHM
;	variable bL=4/FWHM^2
;	variable L=2*aL/w[3]*(ln(1+bL*x)-ln(1+bL*(x-w[3]/2)))/bL
;   	return (1-eta)*G+eta*L+w[4]

  PDER = FLTARR(N_ELEMENTS(X),nterms+npeaks*peakpars) 
  j=0
  F=FLTARR(N_ELEMENTS(X))
  FOR i=0,npeaks-1 DO BEGIN
    IF bragg THEN BEGIN
      tana=1./TAN(A(j+1)/360.*!PI)/360.*!PI 
      sigma=A(j+2)*tana
      sinx=SIN(x/360.*!PI)
      sina=SIN(A(j+1)/360*!PI)
      dx   =ABS(SINx/SINA-1)
    ENDIF ELSE BEGIN
      sigma=A(j+2)
      dx   =x-A(j+1)
    ENDELSE
    IF rectangle THEN BEGIN
      bG=1/SQRT(2)/sigma
      IF bragg THEN BEGIN
        aG1=(sinx/SIN((A(j+1)-A(j+3+voigt)/2)/360*!PI)-1)
        aG2=(sinx/SIN((A(j+1)+A(j+3+voigt)/2)/360*!PI)-1)
      ENDIF ELSE BEGIN
        aG1=x-A(j+1)+A(j+3+voigt)/2
        aG2=x-A(j+1)-A(j+3+voigt)/2
      ENDELSE
      G=A(j)*SQRT(2*!PI)*sigma/2./A(j+peakpars-1)*(ERRORF(aG1*bG)-ERRORF(aG2*bG))
      IF voigt THEN BEGIN
        sin_eta=SIN(!PI/2*A(j+3))
        eta=sin_eta^2
        G=G*(1.-eta)
        aL= A(j)/SQRT(!PI*ALOG(2.))
        bL=1./2./SQRT(    ALOG(2.))/sigma^2
        sqrtbl=SQRT(bL)
        L=2.*aL/A(j+4)/sqrtbL*(ATAN(sqrtbL*(A(j+4)-2.*dx)/2.)-ATAN(-bL*(dx)/sqrtbL))*180./!PI
        ;PRINT,al,sigma,bl,l
        F=F+L*eta
      ENDIF
    ENDIF ELSE BEGIN
      IF sigma ne 0.0 THEN Z= dx/sigma ELSE Z = 10.
      EZ = EXP(-Z^2/2.)*(ABS(Z) LE 7.) 
      G=A(j)*EZ
      PDER(*,j) = EZ
      IF sigma ne 0. THEN PDER(*,j+1) = A(j) * EZ * Z/sigma
      PDER(*,j+2) = PDER(*,j+1) * Z
      IF voigt EQ 1 THEN BEGIN
        sin_eta=SIN(!PI/2*A(j+3))
        eta=sin_eta^2
        G=G*(1.-eta)
        PDER(*,j+[0,1,2])=PDER(*,j+[0,1,2])*(1.-eta)
        nenner=(1.0+Z*Z/2.0)
        L=A(j)/nenner
        F=F+L*eta
        PDER(*,j) = PDER(*,j) + 1.0/nenner*eta
        nenner=A(j)*Z/sigma/nenner*eta
        PDER(*,j+1) = PDER(*,j+1) + nenner
        PDER(*,j+2) = PDER(*,j+2) + nenner * Z
        PDER(*,j+3) = (L - G)*!PI*sin_eta
      ENDIF
    ENDELSE
    IF bragg THEN BEGIN
      PDER(j+1)=PDER(j+1)*SINx/SINA^2*!PI/360
      PDER(j+2)=PDER(j+2)*tana
    ENDIF
    F=F+G
    j=j+peakpars
  ENDFOR
  FOR i=0,nterms-1 DO BEGIN
    F=F+A(j+i)*X^i
    PDER(*,j+i)=X^i
  ENDFOR
  RETURN
END
FUNCTION	GAUSS,X,A
;+
; NAME:
;	GAUSS
;
; PURPOSE:
;	EVALUATE THE SUM OF A GAUSSIAN AND A 2ND ORDER POLYNOMIAL
;	AND OPTIONALLY RETURN THE VALUE OF IT'S PARTIAL DERIVATIVES.
;	NORMALLY, THIS FUNCTION IS USED BY CURVEFIT TO FIT THE
;	SUM OF A LINE AND A VARYING BACKGROUND TO ACTUAL DATA.
;
; CATEGORY:
;	E2 - CURVE AND SURFACE FITTING.
; CALLING SEQUENCE:
;	Result=GAUSS(X,A)
; INPUTS:
;	X = VALUES OF INDEPENDENT VARIABLE.
;	A = PARAMETERS OF EQUATION DESCRIBED BELOW.
; OUTPUTS:
;	Result = VALUE OF FUNCTION AT EACH X(I).
;
; OPTIONAL OUTPUT PARAMETERS:
;	none
; COMMON BLOCKS:
;	NONE.
; SIDE EFFECTS:
;	NONE.
; RESTRICTIONS:
;	NONE.
; PROCEDURE:
;	F = A(0)*EXP(-Z^2/2) + A(3) + A(4)*X + A(5)*X^2
;	Z = (X-A(1))/A(2)
; MODIFICATION HISTORY:
;	WRITTEN, DMS, RSI, SEPT, 1982.
;	Modified, DMS, Oct 1990.  Avoids divide by 0 if A(2) is 0.
;	Added to Gauss_fit, when the variable function name to
;		Curve_fit was implemented.  DMS, Nov, 1990.
; June, 1998 Function GAUSS additionally to procedure GAUSS_FUNCT, TH.
; 
;-
 w=x
 Gauss_Funct,x,a,w
	RETURN,w
END



PRO	GAUSS_SQUARE,X,A,F,PDER
;+
; NAME:
;	GAUSS_FUNCT
;
; PURPOSE:
;	EVALUATE THE SUM OF A GAUSSIAN AND A 2ND ORDER POLYNOMIAL
;	AND OPTIONALLY RETURN THE VALUE OF IT`S PARTIAL DERIVATIVES.
;	NORMALLY, THIS FUNCTION IS USED BY CURVEFIT TO FIT THE
;	SUM OF A LINE AND A VARYING BACKGROUND TO ACTUAL DATA.
;
; CATEGORY:
;	E2 - CURVE AND SURFACE FITTING.
; CALLING SEQUENCE:
;	FUNCT,X,A,F,PDER
; INPUTS:
;	X = VALUES OF INDEPENDENT VARIABLE.
;	A = PARAMETERS OF EQUATION DESCRIBED BELOW.
; OUTPUTS:
;	F = VALUE OF FUNCTION AT EACH X(I).
;
; OPTIONAL OUTPUT PARAMETERS:
;	PDER = (N_ELEMENTS(X),6) ARRAY CONTAINING THE
;		PARTIAL DERIVATIVES.  P(I,J) = DERIVATIVE
;		AT ITH POINT W/RESPECT TO JTH PARAMETER.
; COMMON BLOCKS:
;	NONE.
; SIDE EFFECTS:
;	NONE.
; RESTRICTIONS:
;	NONE.
; PROCEDURE:
;	F = A(0)*EXP(-Z^2/2) + A(3) + A(4)*X + A(5)*X^2
;	Z = (X-A(1))/A(2)
; MODIFICATION HISTORY:
;	WRITTEN, DMS, RSI, SEPT, 1982.
;	Modified, DMS, Oct 1990.  Avoids divide by 0 if A(2) is 0.
;	Added to Gauss_fit, when the variable function name to
;		Curve_fit was implemented.  DMS, Nov, 1990.
;   Modified, TCH, Nov 2000. Multipeakfit
;-
  nterms=N_ELEMENTS(a)>1
  a=[a,0.,0.,0.,0.,0.,0.]
  a=a(0:nterms-1)
  F =FLTARR(N_ELEMENTS(X))
  IF (nterms-1)/3 GT 0 THEN BEGIN
    EZ=FLTARR(N_ELEMENTS(X),(nterms-1)/3)
    Z =EZ
  ENDIF
  FOR i=0,nterms-4,3 DO BEGIN
    IF A(i+2) ne 0.0 THEN Z(*,i/3) = (X-A(i+1))/A(i+2) ELSE Z(*,i/3) = 10.
    EZ(*,i/3) = EXP(-Z(*,i/3)^2/2.)*(ABS(Z(*,i/3)) LE 7.) 
    F = F + A(i)*EZ(*,i/3) 
  ENDFOR
  F = F + A((nterms-1)/3*3) 
  IF N_ELEMENTS(A) GT (nterms-1)/3*3+1 THEN F = F + A((nterms-1)/3*3+1)*X 
  IF N_ELEMENTS(A) GT (nterms-1)/3*3+2 THEN F = F + A((nterms-1)/3*3+2)*X^2 
  IF N_PARAMS(0) LE 3 THEN BEGIN
      a=a(0:nterms-1)
	  RETURN 
  ENDIF
  PDER = FLTARR(N_ELEMENTS(X),nterms) 
  FOR i=0,nterms-4,3 DO BEGIN
    PDER(*,i) = EZ(*,i/3)	
    if a(i+2) ne 0. then PDER(*,i+1) = A(i) * EZ(*,i/3) * Z(*,i/3)/A(i+2)
    PDER(*,i+2) = PDER(*,i+1) * Z(*,i/3)
  ENDFOR
  PDER(*,(nterms-1)/3*3) = 1.
  IF N_ELEMENTS(A) GT (nterms-1)/3*3+1 THEN PDER(*,(nterms-1)/3*3+1) = X
  IF N_ELEMENTS(A) GT (nterms-1)/3*3+2 THEN PDER(*,(nterms-1)/3*3+2) = X^2
  RETURN
END
FUNCTION gdos,w_in,Temp=temp,Emin=emin,Emax=emax
;** *********************************************************
;** S. Rols 11/01 srols@anl.gov
;** The call is w6=gdos(w_in,Temp=T)
;** Last modification 04.02.02 to include QENS_raw treatment
;**
;** *********************************************************

COMMON c_lamp_access, inst
COMMON printing, iprint, outstring

take_datp, datp
par=datp.p
x_in=datp.x
y_in=datp.y
e_in=datp.e
;--------------------------------------------
; Donnees experimentales

Print,'GDOS ## S.R 2002 ##'
lambda=0.

CASE inst OF
;		'MiBeMol':BEGIN
;		lambda=FLOAT(par(10))
;		temp=FLOAT(par(5))
;		ei=81.799/(lambda^2)+x_in*0.
;		END
		'DCSasc':BEGIN
		lambda=FLOAT(par(8))
		ei=81.799/(lambda^2)+x_in*0.
		END
		'QENS_raw':BEGIN
		ef=3.167 ;average final neutron energy in meV
		lambda=SQRT(81.799/ef)
		ei=x_in+ef
		END
		ELSE:BEGIN
		lambda=par(21)
		if (n_elements(temp) EQ 0) THEN temp=par(11)
		ei=81.799/(lambda^2)+x_in*0.
		END
ENDCASE
print,inst
IF (temp EQ 0.0) THEN temp=300.0
IF (n_elements(emax) EQ 0) THEN emax=MAX(x_in)
IF (n_elements(emin) EQ 0) THEN emin=MIN(x_in)
print, 'temp=',temp,'lambda=',lambda,'emin=',emin,'emax=',emax

points=where(x_in ge emin and x_in le emax)

w_buf=w_in & e_buf=e_in & y_out=y_in
;
;Calcul de Q^2
;************************
q2=w_in*0.0
x_in=FLOAT(x_in)
FOR itet=0,n_elements(y_in)-1 DO q2(*,itet)=2*ei(*)-x_in(*)-2*sqrt(ei(*)*ABS(ei(*)-x_in(*)))*cos(y_in(itet)*!pi/180)
q2=q2/2.072
;print,'q2=',q2
;
;Calcul de w/n(w) ou n(w) est le facteur de temperature dans le cas Stokes et anti Stokes
;****************************************************************************************
bosex=FLOAT(x_in)
bosex=bosex/(1-exp(-1.*bosex*11.6045/temp))
;
;Corrections
;******************************
indnul=WHERE(ABS(bosex) LE 1.e-12)
IF n_elements(indnul) GT 1 THEN BEGIN
w_buf(indnul,0:n_elements(y_in)-1)=0.
bosex(indnul)=1.
END
w_buf=w_in/q2
e_buf=e_buf/q2
FOR itet=0,n_elements(y_in)-1 DO BEGIN
w_buf(*,itet)=w_buf(*,itet)/bosex(*)
w_buf(*,itet)=w_buf(*,itet)*(x_in(*))^2
e_buf(*,itet)=e_buf(*,itet)/bosex(*)
e_buf(*,itet)=e_buf(*,itet)*(x_in(*))^2
ENDFOR

;
x_out=x_in(points)
e_out=e_buf(points,*)
w_out=w_buf(points,*)
mod_datp, datp, "e", e_out
mod_datp, datp, "x", x_out
mod_datp, datp, "y", y_out
give_datp, datp
return, w_out
end
pro geokey, key
;** ******

key=" "+key+" " & TB=byte(key)-1 & ntb=n_elements(TB)-1
key=""  &  if ntb lt 4  then return  else TB=long(TB)
TB(0)=TB(2)     & TB(ntb)=TB(ntb-2)
tmp  =TB(1)+2   & TB(1)  =TB(ntb-1)+2 & TB(ntb-1)=tmp
for i=0,ntb do key=key+string(TB(i))
key  =strtrim(strcompress(key),2)+" "
end
pro DialCommons
;** ***********
;**
@lamp.cbk
common c_geo, geo_stat, geo_w  , geo_vis, geo_alp, geo_freq, geo_isw, geo_onbas,$
              geo_bxy , geo_cur, geo_ran, geo_seq, geo_info, geo_lim, geo_timon,$
              geo_par2, geo_lead,geo_act

common c_geweb, geo_web,gew_act, gew_pth, gew_snd, gew_err, gew_pwd, gew_r,gew_g,gew_b,gew_v
end

function N2S, number
;******* ***
;**
return, strtrim(string(number),2)
end

function DialNameToNumber, name, find=find
;******* ****************
;**
;** Given the name of a dial, return its number
;** If keyword_set find then  return a free number if no name match

common dialshare2
common c_geo

named=strupcase(name) & nome=''
N=0   & Pn=(size(geo_w))(2)-1
k=1   & while k le Pn do begin di=strtrim(string(k),2)
		    ii=execute ('if n_tags(d'+di+') gt 1 then nome=d'+di+'.NAME')
		    if strupcase(nome) eq named then begin N=k & k=Pn & endif & k=k+1
        endwhile

if N eq 0 then if keyword_set(find) then begin
			k=1 & while k le Pn do begin di=strtrim(string(k),2)
			      ii=execute ('if n_tags(d'+di+') le 1 then N=k')
			      ii=execute ('if n_tags(d'+di+') gt 1 then if d'+di+'.NAME eq "" then N=k')
			      if N gt 0 then   k=Pn & k=k+1
				endwhile
			if N eq 0 then $
			k=1 & while k le Pn do begin di=strtrim(string(k),2) & onoff=1
			      ii=execute ('if (n_tags(d'+di+') gt 1) then onoff=d'+di+'.ONOFF')
			      if onoff ne 1 then begin N=k & k=Pn & endif & k=k+1
				endwhile
			endif
return,N
end

;******* **************************************************************************
;******* **************************************************************************
;******* **************************************************************************
pro DialTag, name, d=dnum, TAG=tag, SET=setv, GET=getv
;** *******
;**
;** Set or Get the tag value of named dial
common c_geo
common dialshare2
	getv=0
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then if n_elements(tag) eq 1 then begin
	   if n_elements(setv) gt 0 then begin
	      if strupcase(tag) eq "ONOFF"   then if setv gt 0 then DialStart, d=dnum $
	                                                       else DialStop , d=dnum else $
	      if strupcase(tag) eq "HISTORY" then DialHistory, d=dnum ,ONOFF=setv     else $
	      if strupcase(tag) eq "VALUE"   then DialModValue,d=dnum ,      setv     else $
	      if strupcase(tag) eq "ERROR"   then DialModValue,d=dnum ,      setv, tag='ERROR' $
		  else DialModValue,d=dnum ,      setv, tag=strupcase(tag)
	     ;else    ii=execute('d'+strtrim(string(dnum),2)+'.'+tag+'=setv')

	   endif else ii=execute('getv=d'+strtrim(string(dnum),2)+'.'+tag)
	endif    else getv={ONOFF:0,NUMBER:0,NAME:''} ;ii=execute('getv=d'+strtrim(string(dnum),2))
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialsFrequency, GET=getv, SET=setv, STOP=stop, START=start, DURATION=lim, SENS=sens
;** **************
;**
;** Settings of the Timer

common c_geo
	if n_elements(setv) eq 1 then begin
	   on_ioerror,miset & geo_freq=setv & v=strtrim(string(setv),2)
	   if geo_onbas(0) gt 0 then widget_control,geo_onbas(0),bad_id=ii,set_value=v
	   miset:
	endif
	if n_elements(lim)  eq 1 then begin
	   on_ioerror,mislm & geo_lim =lim  & v=strtrim(string(lim),2) & if lim le 0 then v=" "
	   if geo_onbas(2) gt 0 then widget_control,geo_onbas(2),bad_id=ii,set_value=v
	   mislm:
	endif
	if keyword_set(stop)  then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=0
	   geo_stat=0 & geo_w(8,*)=0 & endif
	if keyword_set(start) then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=1
	   geo_stat=1 & geo_timon(0)=systime(1)*1000 & P_GEO_TIMER, {id:geo_onbas(3)}
	   geo_w(8,*)=0 & endif

	if keyword_set(sens)  then if geo_stat  then   P_GEO_TIMER, {id:geo_onbas(3)}

	getv=geo_freq
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialNewValue, tope, NAME=name, d=dnum, SETVALUE=setvalue, COMMENT=ctxt, TYPE=tipe
;******* ************
;**
;** Get next value of the named dial by calling dial_"generic"_read interface function
;** (called from dial_macros)

common dialshare2
common c_lamp_par
common c_geo
val='0'
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if n_elements(ctxt) eq 0 then ctxt=""
	if n_elements(tope) eq 1 then if n_elements(tipe) ne 1 then tipe=tope

	 di=strtrim(string(dnum),2)

	   P_GEO_STATUS, dnum, "Get"

	   generic='' & nome='' & prox=-1
	   if n_elements(tipe) eq 1 then nome=tipe else $
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('generic=d' +di+'.GENERIC')
	   ii=execute('prox   =d' +di+'.PROX')
	   now=systime(1)
	   val=3.14

	   if generic eq 'lamp' then begin val=''
	      CASE strlowcase(nome) of
	      'flagus':	val=0
	      'status':	val='Idle'
	      'log':	DID_WRITE_JOURNAL, val
	      ELSE:
	      ENDCASE
	   endif else $
	   if prox(0) ge 0 then begin par1=nome & par2=now     & par3=ctxt & par4=val
	                              COMMCA, proxcod ,prox    & val =par4 ; GET THE VALUE !!!!!!!!!!!!
	   endif else begin
	    ii=execute('val=dial_'+generic+'_read(nome, now, ctxt)')       ; GET THE VALUE !!!!!!!!!!!!
	    if not ii then begin val='0' & DialErrMes & DialStop & endif
	   endelse

	   geo_w(9,dnum)=geo_w(9,dnum)+((systime(1)-now)*1000)
	   sv=SIZE(val)
	   if sv(sv(0)+1) eq 4 then if val(0) eq 3.14 then P_GEO_STATUS, dnum, "GetNone" $
	                                              else P_GEO_STATUS, dnum, "GetOk"   $
	                                              else P_GEO_STATUS, dnum, "GetOk"

	   if keyword_set(setvalue) then DialModValue, val, d=dnum
return, val
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialModValue, val, NAME=name, d=dnum ,tag=TAG
;** ************
;**
;** Used when dial.VALUE changes its type or dimension

common dialshare2
common c_geo

    if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
    if n_elements(dnum) ne 1 then dnum=geo_cur
    if dnum gt 0 then begin
      di=strtrim(string(dnum),2)
      sv=SIZE   (val)
      if n_elements(TAG) ne 1 then TAG='VALUE' else TAG=strupcase(TAG)
      sz=[0,0,0] & ii=execute('sz=SIZE(d'+di+'.'+TAG+')')
      if (sz(sz(0)+1) ne sv(sv(0)+1)) or (sz(sz(0)+1) eq 8) or  $
         (sz(0) ne sv(0)) or (sz(sz(0)+2) ne sv(sv(0)+2)) then begin
	 elsa = ''
	 tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
	 for k=0,n_elements(tlist)-1 do begin
          CASE tlist(k) of
           TAG:
           ELSE:      elsa =elsa+','+tlist(k)+':d'+di+'.'+tlist(k)
          ENDCASE
	 endfor
                 ii=execute('d'+di+'={'+TAG+':val'+ elsa +'}')
      endif else ii=execute('d'+di+'.' +TAG+'=val')
    endif
end

pro DialMix, A,B
;** *******
;**
;** Mixe Dial B into Dial A

    nA=n_tags(A)  & nB=n_tags(B)
    if nB lt 1 then return
    if nA lt 1 then begin A=B  & return & endif
    elsa=''
    lA=strupcase(tag_names(A))
    for k=0,nA-2 do  elsa =elsa    + lA(k)   +':A.'+lA(k)+','
                     elsa =elsa    + lA(nA-1)+':A.'+lA(nA-1)
    lB=strupcase(tag_names(B))
    for k=0,nB-1 do  if (where(lA eq lB(k)))(0) eq -1 then $
                     elsa =elsa+','+ lB(k)   +':B.'+lB(k)

    ii=execute('A={'+ elsa +'}')
end

pro DialHistory, name, d=dnum, ONOFF=v
;** ***********
;**
;** A short for DialTag procedure

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  ii=execute('d'+strtrim(string(dnum),2)+'.HISTORY=v')
	                   if v then lab ='History is on' else lab ='History is off'
				 if geo_isw then widget_control,bad_id=ii,geo_w(7,dnum),set_value=lab
				 endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStop, name, d=dnum
;** ********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geweb
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=0')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=0
				 geo_w(8,dnum)=0
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' stopped'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial stopped' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' stopped'
				 if geo_web then WebDo,'val',dnum,dnum
				 endif
end
;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStart, name, d=dnum
;** *********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=1')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=1
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
				 freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
				 geo_w(8,dnum)=0
				 geo_timon(dnum)=systime(1)*1000
				 if freq  gt 0  then  P_GEO_TIMER, {id:geo_w(11,dnum)} $
	                                  else  DialsFrequency, /SENS
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' started'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial started' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' started'
	endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialControl, command, d=dnum ,check=check ,name=nome
;******* ***********
;**
;** Back control to the instrument

common dialshare2
common c_lamp_par
common c_geo
common c_geweb

if n_elements(dnum)  ne 1 then dnum =geo_cur
if n_elements(nome)  eq 1 then dnum =DialNameToNumber(nome)
if n_elements(check) ne 1 then check=0.

di     =strtrim(string(dnum),2)
generic='' & ii=execute('generic=d' +di+'.GENERIC')
if generic eq 'lamp' then ctrl='' else ctrl='Ctrl:'

comm=[strtrim(command,2)]
comh= comm
for i=0,n_elements(comm)-1 do begin

	if strpos(strupcase(comm(i)),'CTRL:') eq 0 then comm(i)=strmid(comm(i),5,85)
	if i eq 0 then comh(i)= ctrl  +comm(i)+" ;; "+!stime $
	          else comh(i)='----:'+comm(i)
	to_don_history,-1,0,comh(0)
endfor
if geo_web then WebDo,'snd',comh,dnum

if generic ne "lamp" then begin
	   P_GEO_STATUS,dnum, "Send"

	   nome='' & prox=-1 & name=""
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('name   =d' +di+'.NAME')
	   ii=execute('prox   =d' +di+'.PROS')
	   now=systime(1)
	   val=3.14

	   if prox(0) ge 0 then begin par1=nome & par2=check & par3=comm & par4=val & par5=name
	                              COMMCA, proxcod ,prox  & val =par4     ; SEND THE COMMAND !!!!!!!!!!!!

	   endif else begin CoCo='val=dial_'+generic+'_send(nome, check, comm, name)'
				      ii=EXECUTE(CoCo)                       ; SEND THE COMMAND !!!!!!!!!!!!

	    if not ii then begin val=0 & DialErrMes & DialStop & endif
	   endelse

	   geo_w(10,dnum)=geo_w(10,dnum)+((systime(1)-now)*1000)

	   if val ne 3.14 then P_GEO_STATUS,dnum, "SendOk" $
                        else P_GEO_STATUS,dnum, "SendNone"

endif else begin val=0 & XICUTE,comm(0) & endelse
return,val
end

pro DialClear, name, d=dnum
;** *********
;**
;** Remove the named dial

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
				 DialStop,d=dnum
				 DialTag ,d=dnum, tag="NAME", set=""
				;DialTag ,d=dnum, tag="PWD",  set=""
				 geo_w(6,dnum)=0
				 geo_w(8,dnum)=0
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =0
				 if geo_w(1,dnum) gt 0 then begin
				    di=strtrim(string(dnum),2)
				    P_GEO_DISPLAY, 'd'+di, geo_w(1,dnum) ,-1 ,DNUM=dnum
	endif		&	 endif
end

pro DialMacro, name, d=dnum, Si=di
;** *********
;**
;** Execute the macro of the named dial
;** Display the result

@lamp.cbk
common c_geo
common c_geweb
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)   else name=''
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
	   if n_elements(di) ne 1 then di = strtrim(string(dnum),2)

	   geo_w(5,dnum)=geo_cur & geo_cur= dnum
	   geo_w(9,dnum)=0       & geo_w(10,dnum)=0
	   now=systime(1)

	   ii=execute('name =d'+di+'.NAME')
	   ii=execute('orig =d'+di+'.ORIGIN')
	   ii=execute('prox =n_elements(dt'+di+')') & jj=1

	   CATCH,stat & if stat ne 0 then begin catch,/cancel & DialErrMes & DialStop & return & endif

	   if prox gt 1 then begin DialFromD,keepd
	                     ii=execute('DialToD,  d'+di)
	                     jj=execute('COMMCA,  dt'+di)           ;EXECUTE THE MACRO OF THE DIAL from .prox
	                     ii=execute('DialFromD,d'+di)
	                                 DialToD  ,keepd
	   endif        else jj=execute('dial_'+orig+'_macro,d'+di) ;EXECUTE THE MACRO OF THE DIAL from .pro

	   if jj eq 0 then begin DialErrMes &  DialStop & endif

	   geo_w(8,dnum)=((systime(1)-now)*1000)>1

	   sz  =0  & ii=execute('sz   = SIZE (d'+di+'.VALUE)')
	   wupd=0  & ii=execute('wupd =d'+di+'.WUPDATE')
	   hiss=0  & ii=execute('hiss =d'+di+'.HISTORY')
	   if hiss then begin u=-1
		ii=execute('val=d'+di+'.VALUE(0)')
		if (val ne '') or (sz(sz(0)+2) gt 1) then begin
			on_ioerror,misopn & openw,u,"dial_"+name+".his",/append,/get_lun
			ii=execute('printf,u,d'+di+'.VALUE')
			misopn: if u gt 0 then free_lun,u
	   endif  & endif
	   val  =0
	   plt  =0      &         ii=execute('plt =       d'+di+'.PLOT')
	   histo=0

	   dw=di
	   if wupd le 0 then dw=strtrim(string(dnum+70),2)

	   if (sz(sz(0)+1) eq 7) and (plt gt -2) then begin
		ii=execute('val =  ";"+ d'+di+'.VALUE')
		if sz(sz(0)+2) gt 1 then begin
			if geo_web then WebDo,'log',val,dnum
			form_out,val & print,val & val='... '+val(n_elements(val)-1)
		endif else begin
			if val(0) le "; " then plt=-2
		endelse
		if plt ne -2 then begin ii=execute('w'+dw+' = val') & plt=-1 & endif

	   endif else if plt eq -1 then ii=execute('w'+dw+' = d'+di+'.VALUE') $

	   else if plt ge 0 then begin
		   sze=0.       &   ii=execute('sze  = d'+di+'.ERROR')
		   if n_elements(sze) ne sz(sz(0)+2) then sze=0.
				    alltag=[' '] & ii=execute('alltag = strupcase(TAG_NAMES(d'+di+'))')
				    xtl='' & ytl=''
				    idx=where(alltag eq 'X_TIT')  & idy=where(alltag eq 'Y_TIT')
				    if idx(0) ge 0 then  ii=execute ( 'xtl     = d'+di+'.X_TIT')
				    if idy(0) ge 0 then  ii=execute ( 'ytl     = d'+di+'.Y_TIT')
				    if wupd   gt 0 then  x_tit(dnum) = xtl    & !X.title=xtl
				    if wupd   gt 0 then  y_tit(dnum) = ytl    & !Y.title=ytl
				    if wupd   gt 0 then  w_tit(dnum) = name
				    if wupd   gt 0 then  other_tit(dnum) =  '(Dial)'
		   if sz(sz(0)+2) gt 1 then begin
				    ii=execute('w'+dw+' = d'+di+'.VALUE')
				    ii=execute('e'+dw+' = sze')
				    idx=where(alltag eq 'XVALUE') & idy=where(alltag eq 'YVALUE')
				    if idx(0) ge 0 then  ii=execute ( 'x'+dw+' = d'+di+'.XVALUE')
				    if idy(0) ge 0 then  ii=execute ( 'y'+dw+' = d'+di+'.YVALUE')
		   endif else begin
		     if plt gt 1 then  begin val=0 & ii=execute('val    = d'+di+'.VALUE')
			                             ii=execute('sz     = n_elements(w'+dw+')')
			if sz lt plt then begin      ii=execute('w'+dw+'=[(lonarr(plt-sz)+1)*val,w'+dw+']')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			if sz gt plt then begin      ii=execute('w'+dw+'= w'+dw+'(sz-plt:sz-1)')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			                 ii=execute('w'+dw+'=[w'+dw+'(1:plt-1),val]')
			if sze gt 0 then ii=execute('e'+dw+'=[e'+dw+'(1:plt-1),sze]')
			histo=1
		     endif          else ii=execute('w'+dw+'= d'+di+'.VALUE')
		   endelse
	   endif
	   if plt ge -1 then if (geo_w(1, dnum) gt 0) or (geo_w(13, dnum) gt 0) then begin
			ii=execute('P_GEO_DISPLAY, D'+di+', W'+dw+', error=E'+dw+', X=X'+dw+', Y=Y'+dw+', histo=histo')
	   endif
	   if geo_web then if geo_act eq 2 then WebDo,'dws',0,0,0

	   geo_cur=geo_w(5,dnum) & geo_w(5,dnum)=0
	   nel=n_elements(geo_timon)-1
	   if now - geo_timon(nel-dnum) gt 3. then begin
	   	if (dw eq di) and (plt gt -2) then TO_DON_HISTORY ,dnum,0,'W'+di+'=dial_'+name+'_macro result' ,/nojournal
		geo_timon(nel-dnum)=now
	   endif
	endif
end

pro DialFromD, Dial
;** *********
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
if n_elements(d) gt 0 then Dial=d
end
pro DialToD, Dial
;** *******
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
d=Dial
end
pro DialErrMes
;** **********
@lamp.cbk
common c_geo
common c_geweb
  if l_message gt 0 then widget_control,bad_id=ii,l_message,set_value=strmid(!err_string,0,65)+' ...'
  print, !err_string
  if geo_web then WebDo,'err',!err_string
end
pro DialWSet, Activity=activity
;** ********
@lamp.cbk
common c_geo
  if keyword_set(activity) then begin
	P_GEO_DISPLAY,did_win0,1,0
  	geo_act=0
  endif else begin
  	if geo_act ne 2 then P_GEO_DISPLAY,did_win0,-1,0
  	geo_act=2
  	p_did_setwin0,/map
  endelse
end

pro DialInit, name, d=dnum, path=pth, restore=restore, new=newed, herits=diaH, nostart=nostart
;** ********
;**
;** the dial_name.pro file is compiled
;** and dial_name function is used to initiate the Dial.
;** Check for dial consistency then put it in D'dnum'.
;** /restore is used when restore saved session.
;** If new is defined then after loaded, give it the name "newed".

@lamp.cbk
common c_geo
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

if n_elements(name)   eq 1 then begin
 if n_elements(newed) ne 1 then newed =strlowcase(name)
 if n_elements(dnum)  ne 1 then dnum  =DialNameToNumber( newed, /find)
 if (dnum ge 1) and (dnum lt (size(geo_w))(2)) then begin
  di=strtrim(string(dnum),2)
  if l_message gt 0 then widget_control,l_message,bad_id=ii,set_value=" "
  if n_elements(pth) ne 1 then pth =""
  CD,current=mee
  if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
  fname="dial_"+name
  dial =''
  proc =findfile(fname+".pro" ,count=nn)
  if nn eq 0 then begin
     prox =findfile(fname+".prox",count=nn)
     if  nn gt 0 then begin DialFromD,keepd
                         COMMSI,fname+".prox", /EXEC             & DialFromD,dial
                         COMMSI,fname+"_macro.prox", MACRO=extxt & ii=execute('dt'+di+'=extxt')
                         DialToD  ,keepd  &  nn=-2
     endif & CD,mee
  endif
  if  nn ne -2 then begin
       if  sys_dep ('VERSION') ge 4.0 then $
       if (not sys_dep("EMBEDDED")) and (not sys_dep("RUNTIME")) then $
       ii  =execute('RESOLVE_ROUTINE,fname,/is_f')
       rout=[strupcase(fname)]
       if  sys_dep ('VERSION') ge 5.1 then ii=execute('rout=routine_info(/functions)')
       idx=where(rout eq strupcase(fname))
       if idx(0) ge 0 then ii=execute('dial='+fname+'()')	;INITIATE THE DIAL
       CD,mee
       if not ii then DialErrMes
  endif

  if n_elements(restore) eq 0 then begin

   if n_tags(dial) lt 1 then dial={init:0}

	tlist=strupcase(tag_names(dial))
	idx=where(tlist eq 'INHERITS')
	if idx(0) ge 0 then if dial.inherits gt ' ' then begin    diaG=''
	    DialInit , string (dial.inherits) , d=dnum, path=pth, herits=diaG
	    DialMix  , dial ,  diaG
	    tlist=strupcase(tag_names(dial)) & endif

	if n_elements(diaH) gt 0 then begin
	    DialMix  ,diaH,dial  &   return  & endif

	named    =newed
	generic  ='mad'
	type     =name
	value    =""
	error    =0.
	onoff    =0
	number   =dnum
	frequency=0.
	wupdate  =0. & if GEORGE eq 1 then wupdate=1
	upperlim =0.
	lowerlim =0.
	plot     =50
	history  =0
	duration =0
	init     =0
	unit     =''
	elsa     =''
	for k=0,n_elements(tlist)-1 do begin

	    CASE tlist(k) of
	    'NAME':
	    'NUMBER':
	    'PATH':
	    'ONOFF':     onoff    =fix   (dial.onoff)
	    'VALUE':     value    =dial.value
	    'ERROR':     error    =float (dial.error)
	    'PLOT':      plot     =fix   (dial.plot)
	    'WUPDATE':   wupdate  =fix   (dial.wupdate)
	    'INIT':      init     =fix   (dial.init)
	    'UNIT':      unit     =string(dial.unit)
	    'UPPERLIM':  upperlim =float (dial.upperlim)
	    'LOWERLIM':  lowerlim =float (dial.lowerlim)
	    'GENERIC':   generic  =string(dial.generic)
	    'TYPE':      type     =string(dial.type)
	    'FREQUENCY': frequency=float (dial.frequency)
	    'HISTORY':   history  =fix   (dial.history)
	    'DURATION':  duration =float (dial.duration)
	     ELSE:       elsa=elsa+','+tlist(k)+':dial.'+tlist(k)
	     ENDCASE
	endfor

	if keyword_set(nostart) then onoff=0
	DialClear,named
	ii=execute('d'+di+'={NAME:named,ORIGIN:name,GENERIC:generic,TYPE:type,INIT:init'+ $
	                   ',PLOT:plot ,UPPERLIM:upperlim,LOWERLIM:lowerlim,WUPDATE:wupdate'    + $
	                   ',ONOFF:onoff,VALUE:value,ERROR:error,FREQUENCY:frequency,DURATION:duration' +$
	                   ',HISTORY:history,PROX:[-1L,0],PROS:[-1L,0],NUMBER:number,UNIT:unit,PATH:pth'+$
	                     elsa +'}')

	if (wupdate gt 0) then begin
		ii=execute('w'+di+'=0')
		CLEARPAR, dnum,di
		w_tit    (dnum)=named  +' dial'
		other_tit(dnum)=type   +' (type) <- '+generic
		y_tit    (dnum)=unit
	endif
	ii=execute('w'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('x'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('y'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('e'+strtrim(string(dnum+70),2)+'=0')

	if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
	SetDuduch, "_read", generic, PROX & ii=execute('d'+di+'.PROX=PROX')
	SetDuduch, "_send", generic, PROX & ii=execute('d'+di+'.PROS=PROX')
	CD,mee

  endif
  if geo_isw then begin
			widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
			P_GEO_DISPLAY, newed, dnum ,-2

			DialTag, d=dnum, TAG='ONOFF'  , GET=onoff
			DialTag, d=dnum, TAG='ONOFF'  , SET=onoff
			DialTag, d=dnum, TAG='HISTORY', GET=history
			DialTag, d=dnum, TAG='HISTORY', SET=history
			endif

  if geo_w(1,dnum) gt 0 then P_GEO_DISPLAY, newed, geo_w(1,dnum) ,-1 ,DNUM=dnum
  
  if geo_cur le 0 then geo_cur=dnum ; To prevent problems in DialControl & DialNewValue
  geo_w(6,dnum)=1
 endif
endif
end

pro SetDuduch, proo, generic, PROX
;** *********
;**
common dialshare2

PROX=[-1L,0]
	  proc  =findfile ("dial_"+generic+proo+".pro" ,count=nn)
	  if nn eq 0 then begin
	   prof =findfile ("dial_"+generic+proo+".prox",count=nn)
	   if nn gt 0 then begin
		idx=where(duduch3 eq generic+proo) & idx=idx(0)
		if idx eq -1 then begin              idx=n_elements(proxcod)
		   COMMSI,"dial_"+generic+proo+".prox",  MACRO=tmpcod
		   nn     =n_elements(tmpcod)
		   duduch3=[duduch3,generic+proo,string(idx),string(idx+nn-1)]
		   proxcod=[proxcod,tmpcod]
		   PROX   =[idx,idx+nn-1L]
		endif else PROX=[long(duduch3(idx+1)),long(duduch3(idx+2))]
	   endif
	  endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialOn, dial, d=dnum
;******* ******
;**
;** Check for a User interrupt

common dialshare2
common c_geo

R=1
if geo_isw then begin
	if geo_onbas(1) gt 0 then begin
	   evv=widget_event(geo_onbas(1),/nowait,bad_id=ii)
	   if evv.id    eq  geo_onbas(1) then begin geo_stat =evv.select & R=geo_stat
	                                            geo_timon(0)=systime(1)*1000  &  endif
	endif
	if R then begin
	   if n_elements(dnum) ne 1 then dnum=geo_cur
	   if n_tags(dial)     gt 1 then dnum=dial.number
	   if (dnum ge 1) and (dnum le (size(geo_w))(2)) then begin
	     evv=widget_event(geo_w(3,dnum),/nowait,bad_id=ii)
	     if evv.id    eq  geo_w(3,dnum) then DialTag, d=dnum, tag='ONOFF', set=evv.select
	     DialTag ,d=dnum,tag='ONOFF', get=R
	   endif
	endif
endif
return,R
end

;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
pro dial_webon_macro,D
;** ****************
;**
bid=FINDFILE(D.webpth,count=nn)
IF  nn gt 0 then begin wline=[''] & value=['']
    on_ioerror,misopn
    OPENR,u,D.webpth,/GET_LUN,/DELETE
	on_ioerror,misread
	line=''
	WHILE (not EOF(u)) do begin READF,u,line & wline=[wline,line] & ENDWHILE
	misread:  on_ioerror,misopn
	FREE_LUN ,u
	IF n_elements(wline) gt 2 then if wline(1) eq D.pwd then begin
		wline=wline(2:*)
		XICUTER,' ;--->WebOn '+!stime+' {'+wline(0)+'...}'
		CATCH,stat & if stat ne 0 then begin print,!err_string & return & endif
		FOR i=0,n_elements(wline)-1 do $
			IF wline(i) ne D.pwd then begin line=strtrim(wline(i),2)
			
			   if strpos(line,'ii=barns_i') ge 0 then jj=EXECUTE(line) $
			   else if line gt ' '	then begin XICUTER,(line+'') & value=[value,line]
			        endif
			ENDIF
		XICUTER,' ;---> '
		if n_elements(value) gt 1 then value=value(1:n_elements(value)-1)
		WebDo,'log',value,12
	ENDIF
	DialModValue,value, TAG='VALUE'
    misopn:
endif else if D.value(0) ne '' then DialModValue,[''], TAG='VALUE'
end

function dial_webon
;******* **********
;**
return,{NAME:"webon",PLOT:0,HISTORY:0,VALUE:[''],FREQUENCY:2,WEBPTH:'',PWD:'',WUPDATE:-1}
end

pro WebOn, PATH=wpth ,PASSWORD=pass, PASSWD=pasw
;** *****
common c_geo
common c_geweb

catch,stat & if stat ne 0 then return

if n_elements(gew_pwd) ne 1 then       gew_pwd= ''
if n_elements(   pass) eq 1 then begin gew_pwd=pass & ii=execute('geokey,gew_pwd') & endif
if n_elements(   pasw) eq 1 then begin gew_pwd=pasw & ii=execute('geokey,gew_pwd') & endif
Mach=strupcase(getenv('HOST')) & id=strpos(Mach,'.')
if id gt 0 then Mach=strmid(Mach,0,id)
dvd=sys_dep('DIVIDER')
if n_elements(gew_pth) lt 2 then begin gew_pth=['','','0']
		if Mach eq "" then begin F='C:\User\Didier\geoport\' & Mach='pcRichard'
		endif         else       F='/home/cs/lambda/geoport/'
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(0)=F+Mach
		F=F+'WebGeorge'+dvd
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(1)=F+Mach+dvd else gew_pwd=''
endif

if n_elements(wpth) eq 1 then gew_pth(0)=  wpth
nld=strlen(gew_pth(0))-1
if nld gt 0 then if strmid(gew_pth(0),nld,1) eq dvd then gew_pth(0)=strmid(gew_pth(0),0,nld)

if gew_pth(0) gt ' ' then begin
 gew_pth(0)=gew_pth(0)+dvd
 on_ioerror,misopn
 openw,u,gew_pth(0)+'geo_d_0.web',/get_lun & free_lun,u

 list=findfile(gew_pth(0)+'geo_d_*',count=nn)
 if  nn gt 0 then bid=sys_dep('DELIST',list)

    par1 =''
    if Mach ne '' then begin
	catch,stat
	if stat eq 0 then ii=execute('par1=dial_pad_init_'+(Mach)+'(dummy)') else catch,/cancel
    endif
    sz=SIZE(par1)
    if  sz(0) lt 2 then ii=execute("par1=dial_pad_init()") & sz=SIZE(par1)
    if (sz(0) eq 2) and (sz(1) eq 5) then begin
	  openw,u,gew_pth(0)+'dial_pad.web',/get_lun
	  printf,u,'# George Instrument PAD'
	  printf,u,'# ',strtrim(string(sz(2)),2),' * 5 entries (label command flag program check)'
	  printf,u,'# First 5 lines for input text, others for buttons'
	  printf,u,'# '
	  for j=0,sz(2)-1 do for i=0,sz(1)-1 do printf,u,par1(i,j)
	  free_lun,u & endif

 if sys_dep('MACHINE')  eq  'vms' then gew_v=';1' else gew_v=''
 gew_act=100 & gew_snd=['-'] & gew_err='-'
 tvlct,gew_r,gew_g,gew_b,/get
 if    gew_pwd gt ' ' then begin thif=gew_pth(1)+".geo_webon.txt"
				 list=findfile(thif,count=nn)
				 if  nn gt 0 then bid=sys_dep('DELIST',list)
				 DialInit ,"webon",d=12
				 DialTag  ,"webon",tag="WEBPTH",set=thif
				 DialTag  ,"webon",tag="PWD"   ,set=gew_pwd
				 DialStart,"webon" & endif
 geo_web=1
 WebDo,"sta","on",0
 return
 misopn: DialErrMes
endif
gew_pth='' & gew_pwd= ''
end

pro WebOff
;** ******
common c_geo
common c_geweb
if geo_web gt 0 then WebDo,"sta","off",0
geo_web=0
gew_pth='' & gew_pwd= '' & DialClear,"webon"
end

pro WebMess, val
;** *******
WebDo, 'log', val, 9
end

pro WebDo, flg, val, dnum, matx
;** *****
common c_geo
common dialshare2
common c_geweb

if geo_web eq 0 then return
on_ioerror,misopn
case flg of
'act':gew_act=100 + 100-val
'err':gew_err=val
'snd':gew_snd=val
'pth':begin val=gew_pth(0) & return & end
'log':begin openw,u,gew_pth(0)+'geo_d_'+strtrim(dnum,2)+'Lhtm.web'+gew_v,/get_lun
		printf,u,'<html><head></head><body><b>'
		if dnum eq 12 then printf,u,'<h3>Command executed:</h3><br>'
		for i=0,n_elements(val)-1 do printf,u,'<nobr>'+val(i)+'<br>'
		printf,u,'</body></html>'  & printf,u,''
		flush,u & close,u & free_lun,u
	    openr,u,gew_pth(0)+'geo_d_'+strtrim(dnum,2)+'Lhtm.web'+gew_v,/get_lun & free_lun,u
      end
 else:begin ds=strtrim(dnum,2)			;'gif' 'dws' ('val' 'wks')
       now=systime(1)
       nel=n_elements(geo_timon)-1
       onf=1     &  if dnum gt 0 then ii=execute('onf =d'+ds+'.onoff')
       if (now-geo_timon(nel-dnum) ge 3.) or (flg eq 'val') or (not onf) then begin ;Care 3. le that for history!!!!!!

	freq=0   &  if dnum gt 0 then ii=execute('freq=d'+ds+'.frequency')
	dur =0   &  if dnum gt 0 then ii=execute('dur =d'+ds+'.duration')
	his =0   &  if dnum gt 0 then ii=execute('his =d'+ds+'.history')
	nam ='z' &  if dnum gt 0 then ii=execute('nam =d'+ds+'.name')
	if (not onf) then nam=nam+'_stopped'
	
	dws =flg
	if flg eq 'dws' then begin flg='gif' & if not val then begin DialWSet & geo_act=1 & endif & endif
	if flg eq 'gif' then begin r=0       & matx=tvrdd(r,g,b) & endif
	if flg eq 'val' then flg='gif'
	if flg eq 'gif' then if sys_dep('VERSION') ge 5.4 then  flg='png'

	img=n_elements(matx)
	if img gt 1 then $
	   if flg ne 'wks' then $
	    if n_elements(r) le 1 then $
	         WRITE_KIF,gew_pth(0)+'geo_d_'+ds+'.'+flg+gew_v,matx,gew_r,gew_g,gew_b,transparent=0 $
	    else WRITE_KIF,gew_pth(0)+'geo_d_'+ds+'.'+flg+gew_v,matx, r,g,b,transparent=0

	if dws eq 'dws' then flg=dws

	openw,u,gew_pth(0)+'geo_d_'+ds+'.web'+gew_v,/get_lun
	printf,u, nam,gew_act,geo_freq,geo_lim
	printf,u, freq,dur,his,' '+flg
	printf,u, val
	if gew_err    ne '' then begin printf,u,'err:'+gew_err & gew_err=''   & endif
	if gew_snd(0) ne '' then begin printf,u,'snd:'+gew_snd & gew_snd=[''] & endif
	flush,u & close,u & free_lun,u
	openr,u,gew_pth(0)+'geo_d_'+ds+'.web'+gew_v,/get_lun & free_lun,u ;(nfs update!)
	
       endif
      end
endcase
misopn:
end
;************************************ END WEB MODULES *************************
;************************************ END WEB MODULES *************************

pro P_GEO_EVENT, ev, uv
;** ***********
;**
;** Widget events handler
@lamp.cbk
common c_geo

if uv(1) eq 667 then begin geo_stat  =ev.select  & uv(1)=666                        ;on/off General
                           geo_w(8,*)=0 & endif
case uv(1) of
	614: begin                                                                  ;Mad command
		widget_control,uv(3),bad_id=ii,get_value=comm
		comm=strtrim(comm(0),2)
		if strpos(strupcase(comm),'CTRL:') ne 0 then comm='Ctrl:'+comm
		XICUTER,comm
	     end
	660: if geo_act ne ev.select then begin geo_act=ev.select                   ;plot Activity
	        if geo_act gt 0 then P_GEO_DISPLAY,did_win0,0,0 $
			        else P_GEO_DISPLAY,did_win0,1,0
	     endif
	665: DialTag, d=uv(2), tag='ONOFF', set=ev.select                           ;on/off on Dials
	666: begin                                                                  ;Change frequency ?
		widget_control,uv(2),get_value=bid
		on_ioerror,mis666
		geo_freq=(float(bid(0))>0.) & duduch1=geo_freq
		bid=0
		widget_control,uv(4),get_value=bid,bad_id=ii                        ;Change duration  ?
		on_ioerror,misbid
		geo_lim =(float(bid(0))>0.) & duduch2=geo_lim & misbid:
                geo_timon(0)=systime(1)*1000
		P_GEO_TIMER, {id:uv(3)}
	     end
	670: begin case uv(2) of
	     1:  begin dnum=uv(3)                                                   ;Reset
	               pth   =''   & DialTag,d=dnum,tag="PATH"  ,get=pth
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               origin=''   & DialTag,d=dnum,tag="ORIGIN",get=origin
	               DialInit, origin, d=dnum, path=pth ,new=named
	                            DialTag,d=dnum,tag="ONOFF",set=onoff
	               end
	     2:  DialTag,d=uv(3),tag="HISTORY",set=0                                ;History off
	     3:  DialTag,d=uv(3),tag="HISTORY",set=1                                ;History on
	     4:  begin DialTag,d=uv(3),tag="NAME",get=named                         ;Clear history file
	               bid=sys_dep('DELET',"dial_"+named+".his")
	               end
	     5:  begin dn=uv(3) & dw=geo_w(13,dn)                                   ;large dial
		       keep_w=!D.window
	               if dw gt 0 then begin ii=execute('wset,dw')
	                                     if ii ne 1  then dw=0 else wshow,dw & endif
	               DialTag,d=uv(3),tag="WUPDATE",get= wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=(wupd<1)
		       
	               if dw le 0 then begin DialTag,d=dn,tag="NAME" ,get=named
		                               if geo_w(1,dn) gt 0 then P_GEO_DISPLAY, 'Large '+named,geo_w(1,dn),-1
	                                     WINDOW,xsize=geo_bxy(0)*2,ysize=geo_bxy(1)*2,title=named,/FREE
	                                     dw=!D.Window & endif
	               geo_w(13,dn)=dw
		       if keep_w gt 0 then wset,keep_w
	         end
	     6:  begin di=strtrim(string(uv(3)),2)                                  ;Properties list
	               tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
		       if geo_lead gt 0 then begin b0=widget_base(title="Dial "+di+" properties",resource_name="lamp")
						   b1=widget_base(b0,/column,resource_name="geo") & endif
	               for k=0,n_elements(tlist)-1 do begin
			   DialTag,d=uv(3),tag=tlist(k),get=V & tag='d'+di+'.'+tlist(k)
	                   CASE tlist(k) of
	                   'ERROR':
	                   'PROX':
	                   'PROS':
	                   'PWD':
	                    ELSE:   if geo_lead gt 0 then begin sz=SIZE(V)
			    		if sz(sz(0)+1) eq 8 then V='is a structure' $
			    		else if sz(sz(0)+2) gt 1 then begin  V=strtrim(string(sz(1)),2)
							if sz(0) gt 1 then V=V+','+strtrim(string(sz(2)),2)
							if sz(0) gt 2 then V=V+','+strtrim(string(sz(3)),2)
							if sz(0) gt 3 then V=V+',..'
							V='size('+V+')'
					endif else      V= strtrim(string(V(0)),2)
			    		b2=widget_base (b1,/row)
					bb=widget_label(b2,value=tag+"=",font=ft_b_normal)
					bb=widget_label(b2,value=V      ,font=ft_b_normal)
				    endif else print, tag+'= ',V
	                   ENDCASE
	               endfor
		       if geo_lead gt 0 then widget_control,b0,group_leader=geo_lead,/realize
	         end
	     7:  if ev.TYPE eq 0 then begin
	               di=strtrim(string(uv(3)),2) & N=0 & wupd=0				;plot in main window
	               geo_info(5)=did_win0							;case main window changed
	               DialTag,d=uv(3),tag="WUPDATE",get=wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=2
	               ii=execute('N=n_elements(D'+di+'.VALUE)')
	               if N  gt 1 then begin
	                  DialTag,d=uv(3),tag="XVALUE",get=XX
	                  DialTag,d=uv(3),tag="YVALUE",get=YY
	                  ii=execute('P_GEO_DISPLAY, D'+di+', D'+di+'.VALUE, error=D'+di+'.ERROR, X=XX, Y=YY')
	               endif
	               if ev.PRESS eq 2 then DialTag,d=uv(3),tag="WUPDATE",set=1 ;middle
	               if ev.PRESS eq 1 then DialTag,d=uv(3),tag="WUPDATE",set=0 ;left
		 endif
	     8:        DialClear,d=uv(3)                                            ;Remove the dial
	     else:
	     endcase
	     if (uv(2) ge 80) and (uv(2) le 95) then begin
			widget_control,ev.id,get_value=fq & DialTag,d=uv(3),tag="FREQUENCY",set=float(fq(0))
			;widget_control,uv(4),set_value='Own Frequency='+fq
			DialTag,d=uv(3),tag="ONOFF",get=V & if V eq 1 then DialTag,d=uv(3),tag="ONOFF",set=1
	     endif
	     end
	671: begin  DialTag,d=uv(3),tag="PLOT",set=uv(2)
	            if uv(2) eq -2 then if geo_w(1,uv(3)) gt 0 then P_GEO_DISPLAY,'no Plot',geo_w(1,uv(3)),-1, DNUM=uv(3)
	     end
	else:
endcase
mis666:
end

pro P_GEO_TIMER, ev
;** ***********
;**
;** Timer handler

common dialshare2
common c_geo

begtim=systime(1)
if ev.id eq geo_onbas(3) then begin
;  GENERAL TIMER
   if geo_lim gt 0  then if (begtim*1000 - geo_timon(0) gt geo_lim*1000) then DialsFrequency,/STOP
   if geo_stat      then begin
	 P_GEO_RETIM ,ev.id, geo_freq
	 Pn=((size(geo_w))(2))-1
	 dnum =0
	 R    =1
	 for i=1,Pn do if geo_w(6,i) eq 1 then begin

	   di   =strtrim(string(i),2)
	   onoff=0 & ii=execute('if n_tags(d'+di+') gt 1 then onoff=d'+di+'.ONOFF else geo_w(6,i)=0')
	   if onoff then begin
	    freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    if   freq le 0 then begin
	      if dnum eq 0 then P_GEO_STATUS, 0,"Loop",begtim  else   R=DIALON(d=(i+0))

	      if geo_stat  then if R then begin dnum=i
	                                        P_GEO_STATUS, dnum, "This" ,2
		                                DIALMACRO,  d=dnum, Si=di
	    					freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    					if freq gt 0 then P_GEO_RETIM ,geo_w(11,dnum), freq
	      endif
	    endif else if abs(geo_w(12,i)) eq 2 then  DialStart,d=(i+1-1)
	   endif else geo_w(8,i)=0
	 endif
	 if   dnum  gt 0   then P_GEO_STATUS, (geo_freq+0), "EndL" ,begtim
	 totim=geo_freq-(systime(1)-begtim)
	 if totim lt 0 then if geo_freq gt 0 then P_GEO_RETIM ,ev.id, totim ;GIVE TIME FOR OTHERS.
   endif
endif else begin

;  SPECIFIC TIMER
   widget_control,ev.id,get_uvalue=dnum
   di   = strtrim(string(dnum),2)
   freq = 0 & ii=execute('freq =d'+di+'.FREQUENCY')
   durat= 0 & ii=execute('durat=d'+di+'.DURATION')
   if durat gt 0 then if (begtim*1000 - geo_timon(dnum) gt durat*1000) then DialStop, d=dnum
   onoff= 0 & ii=execute('onoff=d'+di+'.ONOFF')
   if freq gt 0 then if onoff then begin
		P_GEO_RETIM ,ev.id,  freq
		P_GEO_STATUS, 0   , "Loop", begtim
		P_GEO_STATUS, dnum, "This" ,1
		DIALMACRO  ,d=dnum, Si=di
		P_GEO_STATUS, freq, "EndL" ,begtim
		fruq=freq & ii=execute('freq =d'+di+'.FREQUENCY')
		if freq ne fruq then P_GEO_RETIM ,ev.id,  freq $
		else begin
		  totim=(geo_freq*geo_stat)+freq - (systime(1)-begtim)
		  if totim lt 0 then P_GEO_RETIM ,ev.id, totim              ;GIVE TIME FOR OTHERS.
		endelse
   endif    else geo_w(8, dnum)=0
endelse
end

pro P_GEO_RETIM, id,freq
;** ***********
;**
;** RE-TIMER
			widget_control,bad_id=ii,id,/CLEAR_EVENTS
if freq gt 0 then	widget_control,bad_id=ii,id, TIMER=freq	else $
if freq lt 0 then	widget_control,bad_id=ii,id, TIMER=0.05<(-freq)
end

pro P_GEO_STATUS, dnum, way , flgtim
;** ************
;**
;** Display a scheme for the timer process

common dialshare2
common c_lamp_info
common c_geo
common c_geweb
common c_geostat,kpstr

if way eq "Loop" then       geo_seq=flgtim
if way eq "This" then       geo_w(12,dnum)=flgtim
if geo_isw then begin

   if geo_act eq 0 then begin keep_w=!D.window & wset,did_win0
   case way of

	"Loop":
	"This":     begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	            end

	"Get":      begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	                  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=120
	            end

	"GetOk":          plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0

	"GetNone":  begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Bad new Value !!!'
			  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0
	            end

	"Send":     begin if dnum gt 0 then $
			   if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
			  plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=120
	            end

	"SendOk":   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0

	"SendNone": begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Send Control error-code !!!'
			   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0
	            end

	"EndL":     begin device,copy=[0,0      ,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
	                  geo_info(4)= 0
				idx=where(geo_w(8,*) gt 0)
				totim= ((systime(1)-flgtim)*1000+geo_w(9,0))>1
				now  =   systime(1)
				if idx(0) ge 0 then begin
				   for i= 0,n_elements(idx)-1 do if geo_w(12,idx(i)) gt 0 then begin

				       j=idx(i)
				       geo_w(8 ,j)=(geo_w(8 ,j)*100./totim)>1
				       geo_w(9 ,j)=(geo_w(9 ,j)*100./totim)
				       geo_w(10,j)=(geo_w(10,j)*100./totim)
				       geo_w(12,j)=-geo_w(12,j)

				       endif else geo_w(8:10)=1

				   P_GEO_DISPLAY, idx ,dnum,totim
				   if geo_web then begin
				      if dnum gt 0 then ppm=long(dnum*1000*100./totim)<100 else ppm=100
				      WebDo,'act',ppm
				      endif
				endif
				device,copy=[0,0,geo_info(0)/2+30,geo_info(1)*2/3,geo_info(0)/2-32,geo_info(1)/3-2,geo_alp(4)]
				geo_w(9,0) =(systime(1)-now)*1000
	            end
	else:
	endcase
	if keep_w gt 0 then wset,keep_w

   endif else if geo_act gt 0 then begin di=string(dnum)
   case way of

	"Loop":      kpstr=''
	"This":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	                    di=strtrim(di,2) &  name="" & ii=execute('name=d'+di+'.NAME')
						wupd="" & ii=execute('wupd=d'+di+'.WUPDATE')
	             if wupd gt 0 then sws='W' else sws='D'
	             if wupd ge 0 then begin kpstr=kpstr+' ('+sws+di+')'+name
	             widget_control,l_message,bad_id=ii,set_value='............ Dial '+name+' running ...'
		     endif & endif
		     end
	"Get":      ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' requesting ...'
	"GetOk":    ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"GetNone":  ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad request !!!'
	"Send":     ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' sending control ...'
	"SendOk":   ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"SendNone": ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad control !!!'
	"EndL":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	               if kpstr gt ' ' then begin
	                  totim= ((systime(1)-flgtim)*1000)>1
	                  ppm  =long(dnum*1000*100./totim)
	                  if ppm lt 100 then miss=' mis:'+string(long(totim-dnum*1000)/1000.)+' sec' else miss=''
	                  widget_control,l_message,bad_id=ii,set_value=kpstr+string(ppm<100)+'%'+miss
	                  if geo_web then WebDo,'act',ppm<100
                       endif
	             endif
		     end
	else:
   endcase
   endif
endif
end

pro P_GEO_DISPLAY, D, W ,totim  ,error=E ,X=XXX ,Y=YYY ,histo=histo ,DNUM=dnum
;** *************
;**
;** Dial   display -> D=dial      ,  W=workspace
;** Scheme display -> D=dial index,  W=frequence,  totim= time
;** Backgr display -> D=did_win0  ,  W=big arrow,  totim= 0
;** Backgr reset   -> D=did_win0  ,  W=1        ,  totim= 0
;** Backgr erase   -> D=did_win0  ,  W=0        ,  totim= 0
;** di     xyouts  -> D=di        ,  W=winID    ,  totim=-1
;** Dial big name  -> D=name      ,  W=dnum     ,  totim=-2
;** c_did  info    -> D=return [] ,  W=0        ,  totim=-3

common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common c_draw
common c_did
common c_geo
common c_geweb

	keep_w=!D.window
	if n_elements(totim)  eq 0 then begin

			dw  =geo_w(13,D.NUMBER)
			if  (D.WUPDATE eq 2)  then begin if dw gt 0 then              ii=execute('wdelete,dw')
							 dw=geo_info(5)
							 geo_w(13,D.NUMBER)=0       & ii=execute('wset   ,dw')
			endif else if dw gt 0 then begin ii= execute('wset, dw')    & if ii ne 1  then    dw=0
							 geo_w(13,D.NUMBER)=dw      & endif
			trap_current=dw
			stime=strmid(!stime,12,8)
			sz =SIZE(W) & upl=D.UPPERLIM & lwl=D.LOWERLIM
			if sz(sz(0)+2) eq 1 then begin
			   if (D.PLOT le 0) or (upl le lwl) or (dw gt 0) then begin
				if  (dw le 0) or (geo_web) then begin
				     wset,geo_alp(1) & erase
				     xyouts,3,3,strtrim(string(W(0)),2), charsize=1.,/device
				     xyouts,3,geo_bxy(1)-10,D.NAME     , charsize=1.,/device
				     wset  ,geo_w(1,D.NUMBER)
				     device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				     if geo_web then WebDo,'gif',W(0),D.number
				     endif
				if  (dw gt 0) then begin
				     if geo_web then wset,dw & erase
				     xyouts,9,9,strtrim(string(W(0)),2), charsize=3.,charthick=3,font=-1,/device
				endif
			   endif else begin
				wset,geo_w(1,D.NUMBER)
				on_ioerror,notan & res=0
				res=fix(float(upl-W(0))/(upl-lwl) * geo_bxy(0))
				device,copy=[res,0,geo_bxy(0),geo_bxy(1)-3,0,3,geo_alp(0)]
				notan: if res eq 0 then erase
				xyouts,3,geo_bxy(1)-23,strtrim(string(W(0)),2),charsize=1.,/device
			        xyouts,3,geo_bxy(1)-10,D.NAME,charsize=.6,/device
				if geo_web then WebDo,'gif',W(0),D.number
			   endelse

			endif else if sz(0) eq 1 then begin
			   if n_elements(xxx) ne sz(1) then xxx=indgen(sz(1))
			   if keyword_set(histo) then velu=       strtrim(string(W(sz(1)-1)),2) $
			   		   else begin mox =max(W) & velu= 'Max:'  +strtrim(string(mox),2)     + $
					   				  ' at X:'+strtrim(string(xxx(!C)),2)
					   endelse
			   if (dw le 0) or (geo_web)   then begin
			      wset,geo_alp(1)
			      if upl le lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1,yrange=[lwl,upl]
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,D.NAME+'='+velu+'  ',charsize=.6,/device $
			                       else xyouts,3,geo_bxy(1)-10,velu+'      '       ,charsize=.6,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				if geo_web then WebDo,'gif',W(n_elements(W)-1),D.number
				endif
			   if (dw gt 0)  then begin
				if geo_web then wset,dw
			      erase
			      velu=velu+' Updated:'+stime
			      if n_elements(E) eq n_elements(W) then sym=4 else sym=10
			      if upl le lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,yrange=[lwl,upl],$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if n_elements(E) eq n_elements(W) then errplot,xxx,W-E,W+E
			   endif

			endif else if sz(0) eq 2 then begin
			   if (n_elements(xxx) ne sz(1)) and (n_elements(xxx) ne sz(1)*sz(2)) then xxx=indgen(sz(1))
			   if (n_elements(yyy) ne sz(2)) and (n_elements(yyy) ne sz(1)*sz(2)) then yyy=indgen(sz(2))
			   congw='w' & congx=',xxx' & congy=',yyy' & qq=128L
			   if upl gt lwl then congw='w>lwl<upl'
			   if (sz(sz(0)+2) gt qq*qq) and (D.PLOT ne 0) then begin
			   	                                 congw= 'congrid('+congw+',qq<sz(1),qq<sz(2))'
			   	if n_elements(xxx) eq sz(1) then congx=',congrid(xxx,qq<sz(1))'          else $
								 congx=',congrid(xxx,qq<sz(1),qq<sz(2))'
			   	if n_elements(yyy) eq sz(2) then congy=',congrid(yyy,qq<sz(2))'          else $
								 congy=',congrid(yyy,qq<sz(1),qq<sz(2))'
			   endif
			   if D.PLOT eq 0 then mmx=max(W)
			   if (dw le 0) or (geo_web)  then begin
			      wset,geo_alp(1)
			      if D.PLOT eq 0 then begin 
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',geo_bxy(0),geo_bxy(1))+1)>1)') $
					       else ii=execute('tvscl,      CONGRID('+congw+',geo_bxy(0),geo_bxy(1))      ')
			      endif else $
			      if D.PLOT ne 2 then ii=execute($
				'shade_surf,'+congw+congx+congy+',xstyle=4,ystyle=4,zstyle=4,xmargin=[0,0],ymargin=[0,0],az=rz,ax=rx') $
			                      else ii=execute($
				'contour,'   +congw+congx+congy+',xstyle=4,ystyle=4,/fill   ,xmargin=[0,0],ymargin=[0,0],nlevels=nlv')
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,    D.NAME,    charsize=1.,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				if geo_web then WebDo,'gif',0,D.number
			      endif
			   if (dw gt 0) then begin
			   	titil=D.NAME+' updated:'+stime
				if geo_web then wset,dw
			      ;sxx=[1,round(sz(1)/4),round(sz(1)/2),round(sz(1)*3/4),sz(1)] & sxx=strtrim(string(sxx),2)
			      ;syy=[1,round(sz(2)/4),round(sz(2)/2),round(sz(2)*3/4),sz(2)] & syy=strtrim(string(syy),2)
			      if D.PLOT eq 0 then begin
				dxsiz=!D.x_size & xo=40 & xf=10
				dysiz=!D.y_size & yo=40 & yf=20
				if (sz(1) eq sz(2)) and (D.WUPDATE eq 2) then begin
				   if dxsiz gt dysiz then dxsiz=dysiz else dysiz=dxsiz
				endif
				erase
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf)+1)>1),xo,yo') $
					       else ii=execute('tvscl,     (CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf))     ,xo,yo')
				ii=execute('plot,W,charsize=1.2 ,xrange=[xxx(0),xxx(sz(1)-1)],yrange=[0,sz(2)-1]'+$
				           ',/nodata,position=[xo,yo,dxsiz-xf-1,dysiz-yf-1],/noerase,/device,title=titil')
			      endif else $
			      if D.PLOT ne 2 then begin
				surfbody=congw+congx+congy+',az=rz,ax=rx,xticks=4,yticks=4,zticks=1,title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
			 	surfkey ='' & surf='surface,'
				if styles(0,0) eq 4 then surfkey =''             else $
				if styles(0,0) eq 5 then surfkey =',/lego'       else $
				if styles(0,0) eq 6 then surfkey =',/horizontal'      $
				                    else surf    ='shade_surf,'
				ii=execute( surf+surfbody+surfkey )
			      endif else begin
				surfbody=congw+congx+congy+',xticks=4,yticks=4,zticks=2,xmargin=[10,1],ymargin=[4,2],title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
				surf    ='contour,'
				if styles(1,0) ne 1 then surfkey =',/fill,nlevels=nlv' $
				                    else surfkey =',c_colors=(indgen(nlv)+1)*(180/nlv)+50,nlevels=nlv'
				ii=execute( surf+surfbody+surfkey )
			      endelse
			   endif
			endif

	endif else if totim gt 0 then begin

		if W gt 0 then ppm=long(W*1000*100./totim)<100 else ppm=100
		wset,geo_alp(4) & trap_current=geo_alp(4)
		nk =n_elements(D)
		YYt=reform(geo_w(8 ,D))
		YYl=reform(geo_w(10,D))
		YYm=reform(geo_w(9 ,D))+YYl

		if  nk eq 1 then begin
		    YYt=[YYt,0] & YYm=[YYm,0] & YYl=[YYl,0] & D=[D,0] & endif
		sx ='d'+strtrim(string(D),2)
		if  nk eq 1 then begin nk =2  & sx(1)='  '  & endif
		ttl=    strtrim(string(round(totim/10.)/100.),2)+' Elapse sec.'

		if nk gt 8 then begin
		plot, YYl,xmargin=[2,2],ymargin=[2,2],charsize=.8,font=0,yrange=[0,100],$
		          psym=10,xticks=nk-1,xtickname=sx,title=ttl,ystyle=4,xthick=2,linestyle=1

		oplot,YYm,psym=10,linestyle=2
		oplot,YYt,psym=10,linestyle=0
		if ppm lt 100 then begin YYl(*)=ppm & oplot,YYl,thick=2 & endif

		endif else begin
		YP =[[YYl],[YYm],[YYt]]
		sy =['Command    ','Request  ','Macro']
		sz =[ ' ' , strtrim(string(ppm),2)+'%' ]
		w4d=bytscl(YP,min=0,max=100)>20
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],xticks=nk-1,xtickname=sx,shades=w4d,$
		        title=ttl,/lego,charsize=1.2,font= 0,yticks=2,ytickname=sy,zticks=1,ztickname=sz

		if ppm lt 100 then begin
		YP(*)=ppm
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],/lego,/noerase,$
		        xstyle=4,ystyle=4,zstyle=4,charsize=1.2,font= 0
		endif
		endelse

	endif else if totim eq 0 then begin
		if n_elements(w) gt 1 then begin
		    wset,geo_alp(4) & erase
		    wset,geo_alp(3) & erase
		    wset,geo_alp(0) & erase & tv,W
		endif else begin
		 wset,D
		 if (n_elements(w) eq 1) and (w(0) le 0) then begin
		 ;if w(0) eq 0 then did_fu=0 else did_fu=1
		 endif else begin
		  erase
		 ;did_fu=1
		  inf=2.4
		  eng=sys_dep('MACHINE') & if (eng eq 'win') then inf=3. else if (eng eq 'mac') then inf=1.5
		  geo_info(3)= geo_info(1)-geo_bxy(1)-10
		  geo_info(2)= geo_info(0)-geo_bxy(0)-10
		  wdt=20 & cz=(geo_info(0)/341.33*2) & ct=round(cz) & cz=cz<inf
		  xyouts,wdt-4,14,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,13,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,10,"Values REQUEST ",font=-1,charsize=cz,charthick=ct,/device,color=255,width=wdt
		  wdt=geo_info(0)*wdt
		  wdt=geo_info(0)-1-wdt-20
		  xyouts,wdt-4,44,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,43,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,40,"COMMAND Control",font=-1,charsize=cz,charthick=ct,/device,color=255

		  xf1=(geo_info(0)*2/3) - ((geo_info(0)*2/3)-(geo_bxy(0)/2+20))/4
		  xf2=(geo_info(0)  /3) - ((geo_info(0)  /3)-(geo_bxy(0)/2+20))/4
		  yf1=70 + ((geo_info(3)-10)-(70))/4
		  yf2=40 + ((geo_info(3)-10)-(40))/4
		  plots,[xf1,geo_info(0)*2/3], [yf1,70],thick=2.,/device,color=255
		  plots,[xf2,geo_info(0)  /3], [yf2,40],thick=2.,/device,color=255
		 endelse
		endelse
	endif else if totim eq -1 then begin

		wset,W   &  erase
		xyouts,3,geo_bxy(1)-9,D,charsize=1,/device
		if n_elements(dnum) eq 1  then dw  =geo_w(13,dnum) else dw=0	    ;Delete the large Dial plot.
		if dw gt 0 then begin ii=execute('wdelete,dw')  & geo_w(13,dnum)=0 & endif

	endif else if totim eq -2 then begin

		wset, geo_alp(3)
		device,copy=[0,0, geo_bxy(0),geo_bxy(1)/2, 0,W*25]
		xyouts,0,W*25+1, D ,font=-1,charsize=1.5,charthick=2,/device,color=255

	endif else if totim eq -3 then D=[did_x,did_y,did_wd]

	if keep_w gt 0 then wset,keep_w
end

function P_GEO_Ndials & return,20 & end
;******* ************

pro GEORGEO, init=init, construct=base, timer=bs1, freq=freq, command=intxt, nowin=nowin, lim=lim, duduch=prox
;** *******
;**
;** Construct the base then initiate george (lamp startup)
;** handle a command line for instrument control (from dons)

@lamp.cbk
common c_geo
common c_geweb

	if n_elements(intxt) eq 1 then begin
	   comm=strtrim(intxt,2)
	   if strpos(strupcase(comm),'CTRL:') eq 0 then begin intxt=';' & ln=strlen(comm)
	   		comm=strmid(comm,5,ln)
			typ='PAD' & gen=geo_par2(3)
			if (geo_par2(4) eq '1') then check=1 else check=0
			if strpos(comm,'G:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								gen  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								typ  ='WEB'        & endif
			if strpos(comm,'T:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								typ  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								endif
			if strpos(comm,'K:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								check=strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								on_ioerror,mischk  & check=float(check)
								mischk:            & endif
			comm=str_sep(comm, '<br>') & if n_elements(comm) eq 1 then comm=comm(0)

			d0={GENERIC:gen,NAME:geo_par2(0),TYPE:typ,PROS:long(geo_par2(5:6))} & R=0
			R = DialControl(comm,   d=0, check=check)
			if (R lt 0) or (R gt 1)    then begin print,'error-code '+string(R)
					if geo_web then WebDo,'err','error-code '+string(R) & ENDIF
	   endif
	   return
	endif else $
	if n_elements(base) eq 1 then begin
	   Pn     =P_GEO_Ndials()
	   geo_w  =lonarr(14,Pn+1)
	   geo_vis=Pn/2 -Pn/10
	   geo_bxy=[100,50]
	   bid=widget_button(base,font=ft_biggest,value='....GET DIALS....',uvalue=[-88,380,0],resource_name="geo")
	   bas=widget_base (base,/column,y_scroll=fix(lamp_siz/2.1)<395)
	   for i=1,((size(geo_w))(2))-1 do begin
		di=strtrim(string(i),2)
		if sys_dep('VERSION') lt 4.0 then bod=widget_base(bas,/column) $
		else bod  =widget_base  (bas,/column,xsize=110)
		bud       =widget_base  (bod,/row)

		if i le geo_vis+4 then begin
	 	  byd     =widget_button(bud,value='d'+di                       ,font=ft_b_normal,menu=2,resource_name="geo")
			bed3   =widget_button(byd ,value='Large Dial'		,font=ft_normal,uvalue=[-88,670,5,i])
			bed1   =widget_button(byd ,value='Reset'		,font=ft_normal,uvalue=[-88,670,1,i])
			bed4   =widget_button(byd ,value='Properties'		,font=ft_normal,uvalue=[-88,670,6,i])
			bed8   =widget_button(byd ,value='Remove'		,font=ft_normal,uvalue=[-88,670,8,i])
			bed2   =widget_button(byd ,value='History is off'	,font=ft_normal,menu=2)
			  bed21=widget_button(bed2,value='Stop recording'	,font=ft_normal,uvalue=[-88,670,2,i])
			  bed22=widget_button(bed2,value='Start recording'	,font=ft_normal,uvalue=[-88,670,3,i])
			  bed23=widget_button(bed2,value='Clear History file'	,font=ft_normal,uvalue=[-88,670,4,i])
			if i le geo_vis  then begin
			bed5   =widget_button(byd ,value='Change Plot'		,font=ft_normal,menu=2)
			  bed51=widget_button(bed5,value='-2 (no plot)'         ,font=ft_normal,uvalue=[-88,671,-2 ,i,bed5])
			  bed51=widget_button(bed5,value='-1 (in W'+di+')'      ,font=ft_normal,uvalue=[-88,671,-1 ,i,bed5])
			  bed51=widget_button(bed5,value=' 0 (scalar,image)'    ,font=ft_normal,uvalue=[-88,671,0  ,i,bed5])
			  bed51=widget_button(bed5,value=' 1 (arrow,surface)'   ,font=ft_normal,uvalue=[-88,671,1  ,i,bed5])
			  bed51=widget_button(bed5,value=' 2 (contour)'         ,font=ft_normal,uvalue=[-88,671,2  ,i,bed5])
			  bed51=widget_button(bed5,value='10 (vector)'          ,font=ft_normal,uvalue=[-88,671,10 ,i,bed5])
			  bed51=widget_button(bed5,value='20 (  ..  )'          ,font=ft_normal,uvalue=[-88,671,20 ,i,bed5])
			  bed51=widget_button(bed5,value='30'                 ,font=ft_normal,uvalue=[-88,671,30 ,i,bed5])
			  bed51=widget_button(bed5,value='50'                 ,font=ft_normal,uvalue=[-88,671,50 ,i,bed5])
			  bed51=widget_button(bed5,value='100'                ,font=ft_normal,uvalue=[-88,671,100,i,bed5])
			  bed51=widget_button(bed5,value='200'                ,font=ft_normal,uvalue=[-88,671,200,i,bed5])
			  bed51=widget_button(bed5,value='500'                ,font=ft_normal,uvalue=[-88,671,500,i,bed5])
			bed6   =widget_button(byd ,value='Own Frequency'      ,font=ft_normal,menu=2)
			  bed61=widget_button(bed6,value='0.00'               ,font=ft_normal,uvalue=[-88,670,80,i,bed6])
			  bed61=widget_button(bed6,value=' .1 '               ,font=ft_normal,uvalue=[-88,670,81,i,bed6])
			  bed61=widget_button(bed6,value=' .5 '               ,font=ft_normal,uvalue=[-88,670,82,i,bed6])
			  bed61=widget_button(bed6,value='1   '               ,font=ft_normal,uvalue=[-88,670,83,i,bed6])
			  bed61=widget_button(bed6,value='2   '               ,font=ft_normal,uvalue=[-88,670,84,i,bed6])
			  bed61=widget_button(bed6,value='4   '               ,font=ft_normal,uvalue=[-88,670,85,i,bed6])
			  bed61=widget_button(bed6,value='10  '               ,font=ft_normal,uvalue=[-88,670,86,i,bed6])
			  bed61=widget_button(bed6,value='30  '               ,font=ft_normal,uvalue=[-88,670,87,i,bed6])
			  bed61=widget_button(bed6,value='60  '               ,font=ft_normal,uvalue=[-88,670,88,i,bed6])
			  bed61=widget_button(bed6,value='240 '               ,font=ft_normal,uvalue=[-88,670,89,i,bed6])
			  bed61=widget_button(bed6,value='600 '               ,font=ft_normal,uvalue=[-88,670,90,i,bed6])
			  bed61=widget_button(bed6,value='1800'               ,font=ft_normal,uvalue=[-88,670,91,i,bed6])
			  bed61=widget_button(bed6,value='3600'               ,font=ft_normal,uvalue=[-88,670,92,i,bed6])
			endif
		endif
		bidof=0
		if (i eq geo_vis+5) and (GEORGE eq 2) then begin
		 cap=0
		 eng=sys_dep('MACHINE') & if eng eq 'win' then cap=3 else if eng eq 'mac' then cap=-2

		 bs1_t =widget_label (bod,font=ft_b_normal,value ='General Freq.' , event_pro='P_GEO_TIMER')
		 bs1_f =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_freq),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bod,font=ft_b_normal,value='Duration:')
		 bs1_d =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_lim ),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bact  =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='no plot,resource_name="geo"')
		 widget_control,bact ,set_uvalue=[-88,660,0,0],set_button=1
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
		if i le geo_vis+4 then $
		   bidof  =widget_button(widget_base(bud,/nonexclusive),uvalue=[-88,665,i],$
						     value='on/off',font=ft_smaller)

		bedou     =widget_label (bud,value="", event_pro='P_GEO_TIMER',uvalue=i)

		geo_w(2 ,i)=bud
		geo_w(3 ,i)=bidof
		geo_w(4 ,i)=byd	;not used at this time!
		geo_w(7 ,i)=bed2
		geo_w(11,i)=bedou
		widget_control,bud  ,sensitive=0
		if i le geo_vis then geo_w(0,i)=widget_draw (bod,retain=2,xsize=geo_bxy(0),ysize=geo_bxy(1),$
							     /button_events,uvalue=[-88,670,7,i])
	   endfor

	endif else $
	if n_elements(bs1)  eq 1 then begin
		eng=sys_dep('MACHINE')
		if eng eq 'win' then begin cap= 3 & scheme=' SCHEME'        & reffre=' frequency:' & dur='Duration:'
		endif           else $
		if eng eq 'mac' then begin cap=-2 & scheme='SCHEME'         & reffre='freq:'      & dur='for:
		endif           else begin cap= 0 & scheme=' SCHEME'        & reffre='frequency:' & dur='Duration:' & endelse

		if n_elements(lim)  eq 1 then geo_lim =lim  else geo_lim =0
		if n_elements(freq) eq 1 then geo_freq=freq else geo_freq=0
		vaf=strtrim(string(geo_freq),2) & vaf =" 0 "  &  geo_freq=0
		vad=strtrim(string(geo_lim ),2) & if geo_lim le 0 then vad=" "
		geo_onbas=[0L,0L,0L,0L]
		if GEORGE eq 1 then begin
		 bs1_1 =widget_label (bs1,font=ft_biggest ,value = scheme)
		 bs1_t =widget_label (bs1,font=ft_b_normal,value = reffre , event_pro='P_GEO_TIMER')

		 bs1_f =widget_text  (bs1,font=ft_propor  ,value=vaf,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_label (bs1,font=ft_smallest,value='seconds')
		 bs1_1 =widget_button(widget_base(bs1,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bs1,font=ft_normal  ,value='Duration:')
		 bs1_d =widget_text  (bs1,font=ft_propor  ,value=vad,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")

		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]

		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
	endif else $
	if n_elements(prox)  gt 1 then begin
		geo_par2=prox
		SetDuduch,"_send", geo_par2(3,0), prox
		geo_par2=[geo_par2,string(prox)]
	endif else $
	if keyword_set(init) then begin
		setcol,27
		geo_info =lonarr(6)
		P_GEO_DISPLAY, info,0 ,-3                      ;return [did_x,did_y,did_wd]
		geo_info(0)  = info(0) & geo_info(1)=info(1)   ;r=widget_info(did_wd,/geometry)
		geo_info(5)  = did_win0
		P    =geo_bxy(0)   & N=geo_bxy(1)/2
		for i=1,((size(geo_w))(2))-1 do   begin
		    if geo_w(0,i) gt  0  then begin
			   widget_control,bad_id=ii,geo_w(0,i),get_value=j
			   geo_w(1,i)=j
			   di=strtrim(string(i),2)
			   P_GEO_DISPLAY, 'd'+di, j ,-1
		    endif
		endfor
		geo_alp =lonarr(5)
		bid  =widget_base(map=0)
	        geo_alp(0)=widget_draw(bid,retain=2,xsize=2*P,ysize=2 *N)
	        geo_alp(1)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(2)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(3)=widget_draw(bid,retain=2,xsize=  P,ysize=21*N)
	        geo_alp(4)=widget_draw(bid,retain=2,xsize=geo_info(0)/2+30,ysize=geo_info(1)*2/3)
		widget_control,bid,group_leader=lamp_b1,/realize
		widget_control,geo_alp(0),get_value=j & geo_alp(0)=j
		widget_control,geo_alp(1),get_value=j & geo_alp(1)=j
		widget_control,geo_alp(2),get_value=j & geo_alp(2)=j
		widget_control,geo_alp(3),get_value=j & geo_alp(3)=j
		widget_control,geo_alp(4),get_value=j & geo_alp(4)=j
		bid=bindgen(P)*2+55
		bis=bytarr(P,N)  & for i=0,n-1,2 do bis(0,i)=bid
		bid=reverse(bid) & for i=1,n-2,2 do bis(0,i)=bid
		bis=bytscl (bis)
		for i=0,N-1 do bis(P-1-abs((N-1)/2-i)/2:P-1,i)=253*0

		P_GEO_DISPLAY, did_win0, bis ,0

		if GEORGE eq 1 then geo_act=0 else geo_act=1
		if GEORGE eq 1 then P_GEO_DISPLAY, did_win0, 1 ,0

		geo_stat=1 & geo_isw=1 & geo_cur=0 & geo_seq=.0D & geo_timon=dblarr(((size(geo_w))(2))*2)
		geo_lead=lamp_b1       & geo_web=0

		if dial_ini then begin
		 for i=1,((size(geo_w))(2))-1 do begin    di=strtrim(string(i),2)
		    named=''
		    ii=execute ('if n_tags(d'+di+') gt 1 then named=d'+di+'.NAME')
		    if named ne '' then begin
			 dnum =i
			 pth  ='' & DialTag,d=dnum, tag="PATH",get=pth
			 DialInit , named,  d=dnum, path=pth, /restore
		    endif
		 endfor
		endif  else dial_ini=1

		webon
		;;;;;
	endif else $
	if keyword_set(nowin) then begin
		Pn       =P_GEO_Ndials()    ;
		geo_freq =0                 ;General Timer
		geo_timon=dblarr((Pn+1)*2)  ;Time on Timer start process
		geo_lim  =0                 ;General Timer limit
		geo_par2 =['','','','','','-1','0'] ;Contains "dial_pad_init" table
		dial_ini =1
		geo_stat =0                 ;General Timer is on or off
		geo_act  =0                 ;0:plot Activity  1:output strings
		geo_web  =0                 ;1:outputs for web mirror
		geo_alp  =[0L,0L,0L,0L,0L]  ;BaseId  for pixmap plotting
		geo_vis  =0                 ;Visible short Dials
		geo_w    =lonarr(14,Pn+1)   ;0:drawBase    1:drawId  2:sensBase  3:OnOffButton
		                            ;4:HiLightBase 5:previous active dial (geo_cur) 6:has a dial
		                            ;7:HistoryBase 8:time in Macro 9:time in Get 10:time in Send
		                            ;11:Specific timer base  12:in the general or spec loop(2,1)
		                            ;13:large drawId
		geo_info =lonarr(6)         ;0:draw.xsize  1:draw.ysize  4:last dial scheme  5:did_win0
		geo_bxy  =[0,0]             ;short drawBase size
		geo_isw  =0                 ;0 for noWindow
		geo_cur  =0                 ;Current active Dial
		geo_onbas=[0L,0L,0L,0L]     ;BaseId for text & on/off Timer button & limit & Timer
		geo_lead =lamp_b1           ;Group Leader
		geo_seq  =.0D               ;Current Time (double flt)
	endif
end
pro get_paras,num,y,m,q,th,r
close,3

par1 = fltarr(128)
par2 = fltarr(256)
txt=sindgen(34)
txt(*)='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
txt1=txt(1)
path='/users/data/'
;name=path+'00'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 1 then name=path+'00000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 2 then name=path+'0000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 3 then name=path+'000'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 4 then name=path+'00'+string(strtrim(num,2))
if strlen(string(strtrim(num,2))) eq 5 then name=path+'0'+string(strtrim(num,2))

print,' '
print,' '
print,'opening... ',name
openr,3,name
print,'opened: ',name
readf,3,txt
print,txt(4)
print,txt(25)
readf,3,par1
readf,3,txt1
readf,3,txt1
readf,3,par2
dpr=180./!pi
print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
nx=par1(101)
print,'nx= ',par1(101),' ny= ',par1(102)
print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)



; useful chopper variables
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))

; note offset for opening is 1.1 deg!!!!!!!


opena=opena-1.02

; inter chopper distance is cht
cht=0.085
period=60./par2(44)




dela=(283.754-opena)/2.
delt=(dela/360.)*period


chopsam=3.9475-cht/2.

tofd=chopsam+(par2(15)/1000.)
chanpa=(tofd/3956.)/(par1(95)*1e-6)
chanpam=(chopsam/3956.)/(par1(95)*1e-6)
r=chopsam/tofd
delchan=delt/(par1(95)*1e-6)
delechan=par1(96)/par1(95)
print,'channel offset: ',delchan-delechan
print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
;print,'     san= ',par2(2),' deg.'
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa
time=par1(2)/10.
print,'run time= ',time,' s',' det= ',par2(15),'dan = ',par2(16)
print,'san= ',par2(2)
dan=par2(16)
dett=par2(15)
readf,3,txt1
readf,3,txt1
readf,3,txt1
readf,3,tot
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'
print,'tsize= ',tsize,' detector size= ',dsize
print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

;make lambda array
yy=indgen(tsize)
y=(yy+delechan+.5-delchan)/chanpa
m=(yy+delechan+.5-delchan)/chanpam


;make 2th array

dpr=180./!pi
p0=135.79/nx

mmpp=1.04*nx
th=fltarr(xsize)

for i=0,xsize-1 do th(i)=dan+dpr*atan(((p0-i)*mmpp)/dett)




q=4*!pi*sin(par2(2)/dpr)/y

return
end
pro get_w_num ,q1,q2,q3,q4
;** *********  ***********
;**
@lamp.cbk

q1=one          ; W'one' = test (W'two' , W'three')
q2=two          ;        =
q3=three        ;        =
q4=alone        ; test,W'alone'

end

;			GKFIT
; A lamp interface to perform fits on plot.
;
; Fitit procedures were developped by Don Kearley
; Gfit was developped, improved and corrected by :
;					Don Kearley
;					Didier Richard
;					Stephane Thiers
;					Romuald Jouffrey
; During 1995-1996 
;
; This file contains both original fitit.pro and gfit.pro
; Version 1.14		Date: 6/10/96
; Modification History:
; gjk 22/9/96: Common gc_width_factor added with gw_fac and lw_fac. 
;	These take account width as sigma or real width. 
;	For sigma:      gw_fac = 0.5,    lw_fac=1.0
;	For real width: gw_fac = 2sqrt2, lw_fac=0.5
; gjk 22/9/96: If width or intensity set by cursor, g_resid=1.0e12
; gjk 23/9/96: Modified routine adapte to:
;		set symbol plotting if less than 200 points
;		set symbol size according to number of points
;		set error plotting if errors are present
;		to include most of the actual plotting:
;		plot_flag=0 no plot, 
;		         =1 plot all
;			 =2 no overplot
;			 =3 plot,/nodata
;gjk 1/10/96:  Change to middle mouse button for peak definition. Something
;              odd about event 2 2 with left button?
;gjk 5/10/96:  Derivatives for height corrected, and refienement altered,
;              now: ncycles of dumb routine with initial step decreasing
;                   with ncycles.
;              One cycle of derivative method, but 2 if ncycles > 1.
;gjk 6/10/96   Flag peaks with negative height or width with peak_neg equal
;              to offending peak number (0 if ok) and ht_or_wdth = 1 for height
;              and 2 for width. Set in sum_fit.
;gjk 10/10/96  Flat and sloping bg added when peak defined with mouse
;
;d.r 08/08/02  Detail balance added.
;d.r 09/08/02  scalling on Y is now possible.
;
; ***************************** Widgets Creating Procedure
; GFIT				Create main GKFIT interface
; CREER_EXCL, id		Create Excluding zone interface
; CREER_VIEW, id		Create viewing zone interface
; ***************************** Event processing procedures
; GFIT_EVENT		,Event
; TRAITVIEW_EVENT 	,Event
; TRAITEXCL_EVENT 	,Event
; ***************************** functions of this files are :
; JFIT		,x,y,w,a,stp,siga,g_ncycles,npk,poids
; GENFIT	,X,Y,W,A,stp,npk,resid,poids
; CALCULATE_ERROR,modele
; BELONG_TO	,elem,inter
; GK_FIT	,workspace
; ***************************** Procedures of this files are :
; CREATE_COMMONS
; GAUSS		,x,a,f
; LORENTZ	,x,a,f
; SUM_FIT_FCT	,x,a,f,g_npeaks,pder
; FITIT		,g_npeaks,w_in,w_out,...
; ADAPTE	,x_to_plot,w_to_plot
; AFF_EXCL	,excl_param
; DO_FIT	,option
; GET_PARAM	,g_parameters,idx,p1,p2,p3
; GFIT_HELP	, dummy, formu, formt
; GK_INITIALIZE
; GK_WARNING	,excl_param,viewarr
; PARAMETER_MENU,Ev
; PLOT_SUBF	,g_npeaks,g_parameters,x_ni,g_fct_type
; PUT_TIT	,x_dats,y_dats,f_tit,fx_tit,fy_tit
; PUT_VALS	,x_dats,y_dats,f_dats,plt_dev,poids,lamp_siz
; PRINT_VALS	,x_dats,y_dats,f_dats,plt_dev,poids
; READ_PAR_VALS
; SET_GFIT_PARAM,w,p,Fct_Type=ft
; WRITE_PAR_VALS
; WRITE_PAR_VALS_2
; GFIT		,GROUP=Group
; ERROR_MSG	,Error_Number
; ***************************** Little explanation on variables
; - Local variables are normaly named  			(ex. idx)
; - Each gkfit shared variable begins with g_ 		(ex. g_parameters)
; - gw_ stands for gkfit Widgets identifier variables	(ex. gw_base)
;
; Variables are ALWAYS lowercase, IDL Instructions are ALWAYS uppercase
; Keywords in IDL instructions are ALWAYS Capitalized.
; If you try this, you keep it ... very helpfull in reading ...

;===============================================================================
PRO create_commons				; ==============================
;===============================================================================
; Just to create correct commons while compiling. Explains also variables

COMMON gc_save,		keepw, 		$ ; keep w_ni for cutting
			keepe,		$ ; keep errors     ''
			w_ni,		$ ; input Workspace
			x_ni, 		$ ; input X
			e_ni,           $ ; input errors
			nw_ni,		$ ; in Workspace number
			nwt_in,		$ ; input Workspace number (str)
			nw_out,		$ ; out Workspace number
			sw_ni		  ; Size of input Workspace 

COMMON gc_data,		g_plot_wid, 	$ ; plot area id
			g_old_plot_wid, $ ; keep plot area id
			g_fct_name,	$ ; Name of the fitted function
			g_fct_type,	$ ; Array of function type for each peak
			g_npeaks,	$ ; Peak(s) number
			g_pk_nb,	$ ; Current peak number
			g_nb_pk_max,	$ ; Maximum number of peaks
			g_ncycles,	$ ; Cycle(s) number
			g_largeur,	$ ; Array of consecutive distances
			g_resid,	$ ; the residu after fitting
			g_print_nb,	$ ; Print filename incremental variable (Fix)
			g_step,		$ ; Array of extended parameters
			g_error, 	$ ; Errors on parameters
			g_tx_par, 	$ ; Tripx parameters string array
			g_parameters,	$ ; Array for Pos,Int&Width
			g_char		  ; for each defined peak plus at last
					  ; idx background and slope

					  ; ctrl_panel widget id
COMMON gc_cp,		cp_nb, 		$ ; Widget Id 
			cp_bck,	 	$ ; 	
			cp_pos, 	$ ;  
			cp_hgt,  	$ ; 
			cp_wid,  	$ ; 
			cp_pf,  	$ ; 
			cp_hf,  	$ ; 
			cp_wf,  	$ ; 
			cp_fb,  	$ ; 
			cp_sb,  	$ ; 
			cp_fbf,  	$ ; 
			cp_sbf  	  ; 

COMMON gc_flags,	g_bg_but,	$ ; State of background button
			g_show_subfct,	$ ; if set, subfunctions are plotted
			g_tripx, 	$ ; if set, tripx mode
			g_ctrl_panel, 	$ ; if set, ctrl_panel mode
			g_afitisdone	  ; set if a fit was done, for print fct

COMMON gc_wid,		gw_cycle_lab, 	$ ; Widget Id of cycle label
			gw_cut_slider,	$ ; Widget Id of cutting slider
			gw_cut_label,	$ ; Widget Id of cutting label
			gw_peak_but,	$ ; Array of widget id (peak buttons)
			gw_choice_but,	$ ; Widget Id of choice button
			gw_pk_slider,	$ ; Widget Id of peak slider
			gw_view_base,	$ ; Widget Id of view base
			gw_excl_base,	$ ; Widget Id of exclude base
			gw_pos_text,	$ ; Widget Id of position field text 
			gw_pos_pop,	$ ; Widget Id Array of menu
			gw_int_text,	$ ; Widget Id of integral text field 
			gw_int_pop,	$ ; Widget Id Array of menu
			gw_wdt_text,	$ ; Widget Id of width text field 
			gw_wdt_pop,	$ ; Widget Id Array of menu
			gw_fbg_text,	$ ; Widget Id of flat bg text field 
			gw_fbg_pop,	$ ; Widget Id Array of menu
			gw_sbg_text,	$ ; Widget Id of slope bg text field 
			gw_sbg_pop,	$ ; Widget Id Array of menu
			gw_resid_lab,	$ ; Widget Id of resid label
			gw_plot_area,	$ ; Widget Id of plot drawing area
			gw_err_lab,	$ ; Widget Id of error label
			gw_gkfit_base,	$ ; Widget Id of gkfit base
			gw_type_but,	$ ; Widget Id array of pop up menu button
			gw_bgfixed,	$ ; Widget Id of fixed background button
			gw_pk_no,	$ ; Widget Id of peak number label
			gw_get_but	  ; Widget Id of get button

COMMON gc_fit_excl,	gw_excl_but,	$ ; 
			bb1,		$ ; 
			bb2,		$ ; 
			intv_no,	$ ; 
			excl_widge,	$ ; 
			intv_nb,	$ ;
			ok_but,		$ ; 
			excl_param,	$ ; 
			max_nb_int	  ; 

COMMON gc_fit_view,	viewarr,	$ ; Array of view zone data
			no_zone,	$ ; 
			x_min,		$ ; 
			x_max,		$ ; 
			y_min,		$ ; 
			y_max,		$ ;
			sauv		  ;
			
COMMON gc_width_factor,  gw_fac, lw_fac

COMMON gc_negative, ht_or_wdth,peak_neg

COMMON gc_dids, ws_in_r, gw_temp, gw_bose, bose, curpic, gw_mimi,mimirange,mimion, ximion,gx_mim1,gx_mim2

END

;===============================================================================
pro Parameter_menu, Ev						; ==============
;===============================================================================
COMMON gc_wid
COMMON gc_data
COMMON gc_flags

fixed=0
IF Ev(1) EQ 0 then if g_bg_but EQ 1 then g_bg_but=0 else g_bg_but=1
IF Ev(1) GE 1 AND Ev(1) LE 5 THEN BEGIN
    IF Ev(1) eq 1 THEN gw_pop=gw_pos_pop
    IF Ev(1) eq 2 THEN gw_pop=gw_int_pop
    IF Ev(1) eq 3 THEN gw_pop=gw_wdt_pop
    IF Ev(1) eq 4 THEN gw_pop=gw_fbg_pop
    IF Ev(1) eq 5 THEN gw_pop=gw_sbg_pop
	    IF Ev(2) eq 0 THEN error_msg, 10		
	    IF Ev(2) eq 1 THEN BEGIN
		WIDGET_CONTROL, bad_id=i, gw_pop(Ev(2)), Get_Value=V
		IF STRPOS(V, 'Un') ge 0 THEN $
		    V=STRMID(V, 2, STRLEN(V)) $
		ELSE BEGIN
		    V='Un'+V & fixed=1
		ENDELSE
		WIDGET_CONTROL, bad_id=i, gw_pop(Ev(2)), Set_Value=V			    
	    ENDIF ELSE BEGIN
		IF Ev(1) GE 1 AND Ev(1) LE 3 THEN BEGIN
		    ; event generated by position, height width button
		    WIDGET_CONTROL, bad_id=i, gw_pop(2), Get_Value=V
		    IF STRLEN(V) GT 15 then V=STRMID(V, 0, 15)
		    IF Ev(2) NE 9 THEN BEGIN
			fixed=1
			WIDGET_CONTROL, bad_id=i, gw_pop(2), $
			    Set_Value=V+' '+STRTRIM(STRING(Ev(2)-2), 2)+' '
		    ENDIF ELSE WIDGET_CONTROL, bad_id=i, gw_pop(2), Set_Value=V
		ENDIF
	    ENDELSE
str=""
WIDGET_CONTROL, bad_id=i, gw_pop(0), Get_Value=str
IF fixed eq 1 THEN BEGIN
    if STRPOS(str, ' fx ') LT 0 THEN str=STRMID(str, 0,  STRPOS(str, '    '))+' fx '
ENDIF ELSE BEGIN
    p=STRPOS(str, ' fx ')
    if p GE 0 then str=STRMID(str,0, p)+'    ' 
ENDELSE
WIDGET_CONTROL, bad_id=i, gw_pop(0), Set_Value=str
ENDIF
read_par_vals
g_resid=1.0e12
END

;===============================================================================
FUNCTION jfit,x,y,w,a,stp,siga,ncycles,npk,poids		; ==============
;===============================================================================
;
; Free fall minimisation routine gjk March 1994
; Treats one parameter at a time: shifts value, if better then shifts
; twice as much, if worse shifts back half as much. Halts for each 
; parameter when change in residual is less than "tiny". 
; When all parameters are done this is one cycle. Repeated for ncycles.

 COMMON gc_negative

tiny=0.005
pc100=SQRT(TOTAL(y^2))
nvars=npk*3+2
nquit=2000
f=x

IF ncycles EQ 0 THEN BEGIN
    Sum_fit_fct,x,a,f,npk,dummy_par ;fifth parameter is not used here
    siga=100.0*SQRT(TOTAL(ABS(y-f)^2*poids))/pc100
    RETURN,f
ENDIF	

;.......Start loop round cycles 

FOR kk=1,ncycles DO BEGIN
    ;.......Get starting residual
	Sum_fit_fct,x,a,f,npk,dummy_par	;fifth parameter is not used here
    best=sqrt(total(abs(y-f)^2*poids))/pc100
    old_dify=0.0
    first_step=0.1/(kk^2)
    ;.......Start loop round each parameter
    FOR np=1,nvars DO BEGIN
	IF stp(np-1) gt 0 THEN BEGIN
	    ;.......Set up best value of parameter, default change in residual,
	    ;.......and initial shift (10% of parameter value)
	    bestp=a(np-1)
	    difydify=1.0
	    shifty=a(np-1)*first_step
	    a(np-1)=a(np-1)+shifty
	    ;.......Endless loop to minimise, quit after nquit tries and go home
	    iquit=0
	    WHILE abs(difydify) gt tiny DO BEGIN
		iquit=iquit+1
		if iquit gt nquit THEN return,f
		Sum_fit_fct,x,a,f,npk,dummy_par	;fifth parameter is not used here
		if peak_neg gt 0 then return,f
		chsq=sqrt(total(abs(y-f)^2*poids))/pc100
		dify=best-chsq
		difydify=old_dify-dify
		old_dify=dify
		;.......keep best value of parameter
		if chsq lt best THEN BEGIN
		   best=chsq
		   bestp=a(np-1)
		   shifty=shifty*2.
		endif
		if dify lt 0.0 THEN shifty=-shifty/2.0
		a(np-1)=bestp+shifty
		shifty=abs(shifty)
	    ENDWHILE
	    a(np-1)=bestp
	ENDIF ELSE BEGIN
	    ;.......Fixed or tied parameters
	    IF stp(np-1) lt 0 THEN BEGIN
		;Tie to which peak?
		n_piv=abs(stp(np-1))
		;What is current peak number?
		n_peak=fix((np-1)/3)
		ikind=np-(n_peak*3)
		a(np-1)=a((n_piv-1)*3+(ikind-1))
	    ENDIF
	ENDELSE
    ENDFOR

ENDFOR
Sum_fit_fct,x,a,f,npk,dummy_par	;fifth parameter is not used here
siga=100.0*SQRT(TOTAL(ABS(y-f)^2*poids))/pc100
return,f
END

;===============================================================================
FUNCTION genfit,X,Y,W,A,stp,npk,resid,poids 				; ======
;===============================================================================
;Doctored version of curvefit gjk March 95
;

;ON_ERROR,2		;return to caller if error ***removed gjk
yfit=fltarr(N_ELEMENTS(x))
nvars=npk*3+2
a=1.*a		;make params floating
nterms=N_ELEMENTS(a)	;# of params.
nfree=(N_ELEMENTS(y)<N_ELEMENTS(x))-nterms ;degs of freedom
if nfree le 0 THEN error_msg, 8
if nfree le 0 THEN return,yfit
flambda=0.001		;initial lambda
diag=indgen(nterms)*(nterms+1) ;subscripts of diagonal elements
total_y2=total(y^2)
pc100=sqrt(total_y2)
end_iter=total_y2/1.0e7/nfree
iter=0
while (iter le 20) DO BEGIN ;iteration loop, evaluate alpha and beta matricies.
    iter=iter+1
    Sum_fit_fct,x,a,yfit,npk,pder
    beta=(y-yfit)*w # pder
    alpha=transpose(pder) # (w # (fltarr(nterms)+1)*pder)
    chisq1=total(w*(y-yfit)^2*poids)/nfree ;present chi squared.

    ; if a good fit, no need to iterate
    IF chisq1 lt end_iter THEN BEGIN
	sigmaa=fltarr(nterms)	;return all 0's
	RETURN, yfit
    ENDIF

    ; invert modified curvature matrix to find new parameters.
    iescape=0
    REPEAT BEGIN
	c=SQRT(alpha(diag) # alpha(diag))
	iescape=iescape+1
	array=alpha/c
	array(diag)=array(diag)*(1.+flambda)		
	array=INVERT(array)
	b=a+(array/c # TRANSPOSE(beta)) ;new params
	    FOR np=1,nvars DO BEGIN
		IF stp(np-1) eq 0 THEN b(np-1)=a(np-1)
		;fixed or tied parameters
		if stp(np-1) lt 0 THEN BEGIN
		    ;tie to which peak?
		    n_piv=abs(stp(np-1))
		    ;what is current peak number?
		    n_peak=fix((np-1)/3)
		    ikind=np-(n_peak*3)
		    b(np-1)=b((n_piv-1)*3+(ikind-1))
		ENDIF
	    ENDFOR
	    Sum_fit_fct,x,b,yfit,npk,dummy_par	;fifth parameter is not used here
	    chisqr=TOTAL(w*(y-yfit)^2*poids)/nfree ;new chisqr
	    flambda=flambda*10.	;assume fit got worse
	    IF iescape gt 200 THEN RETURN,yfit
    ENDREP UNTIL chisqr le chisq1

    flambda=flambda/100.    	;decrease flambda by factor of 10
    a=b			  	;save new parameter estimate.	
    IF ((chisq1-chisqr)/chisq1) le .001 THEN iter=21  
endwhile

done:   pc100=SQRT(TOTAL(y^2*poids))
	resid=100.0*SQRT(TOTAL((y-yfit)^2*poids))/pc100
	RETURN,yfit		;return result
END

;===============================================================================
PRO Gauss,x_vector,p1,p2,p3,peak,partial_deriv			; ==============
;===============================================================================
; Define in peak a Gaussian on parameters p1 (pos),p2 (ht), p3 (wdth) into
; array peak. If partial_deriv parameters is done, partial_deriv contains
; partial_deriv for each parameters.
COMMON gc_width_factor
COMMON gc_dids

p2_tmp=p2*p3*2.50663		; compute integral for p2 height
z=(x_vector-p1)/p3
z2= (z^2) <15.
peak=p2_tmp*exp(-gw_fac*z2)/p3/2.50663
peakt=peak

temp=0 & det_bal=1. & peaks=0 & zs=0 & z2s=0 & expzs=0

if bose(curpic-1) then begin
   widget_control,gw_temp,get_value=tmpt & tmpt=tmpt(0)
   on_ioerror,mistmpt & tmpt=float(tmpt) & temp=tmpt & mistmpt:
endif
if temp gt 0 then begin                  ;STRUCTURE FACTOR ASKED (det_bal)
	w_t=x_vector/temp*11.6
	e_w_t=EXP(-w_t)
	det_bal=w_t*0+temp/11.6
	idx=where(abs(w_t) gt 0.0005)
	if idx(0) ge 0 then det_bal(idx)=w_t(idx)/(1.-e_w_t(idx))
	
	zs   =(x_vector+p1)/p3 & z2s= (zs^2) <15. ;symetric
	expzs=exp(-gw_fac*z2s)                    ;symetric
	peaks=p2_tmp*expzs/p3/2.50663             ;symetric
        peak =peak+peaks                          ;symetric
	peak =peak*det_bal
endif

IF N_PARAMS() GT 5 THEN BEGIN
    if gw_fac gt 0.5 then new_p3=p3*0.420448 else new_p3=p3
    partial_deriv=FLTARR(N_ELEMENTS(x_vector),3)           ; define partial_deriv array
    partial_deriv(*,0)=2.*gw_fac/new_p3*(peakt*z -peaks*zs) *det_bal ; partial deriv % p1
    partial_deriv(*,1)= (exp(-gw_fac*z2)+expzs)             *det_bal ; partial deriv % p2
    partial_deriv(*,2)=2.*gw_fac/new_p3*(peakt*z2+peaks*z2s)*det_bal ; partial deriv % p3
ENDIF
END

;===============================================================================
PRO Lorentz,x_vector,p1,p2,p3,peak,partial_deriv		; ==============
;===============================================================================
; Define in peak a Lorentzian on parameters p1 (pos),p2 (ht), p3 (wdth) into
; array peak. If partial_deriv parameters is done, partial_deriv contains
; partial_deriv for each parameters.
COMMON gc_width_factor
COMMON gc_dids

if lw_fac lt 1. then new_p3=p3*0.5 else new_p3=p3

p2_tmp=p2*new_p3*!PI			; compute integral for p2 height
xvt=(x_vector-p1)
peak=p2_tmp/(1+(xvt/new_p3)^2)/new_p3/!PI
peakt=peak

temp=0 & det_bal=1. & peaks=0 & xvs=0

if bose(curpic-1) then begin
   widget_control,gw_temp,get_value=tmpt & tmpt=tmpt(0)
   on_ioerror,mistmpt & tmpt=float(tmpt) & temp=tmpt & mistmpt:
endif
if temp gt 0 then begin                  ;STRUCTURE FACTOR ASKED (det_bal)
	w_t=x_vector/temp*11.6
	e_w_t=EXP(-w_t)
	det_bal=w_t*0+temp/11.6
	idx=where(abs(w_t) gt 0.0005)
	if idx(0) ge 0 then det_bal(idx)=w_t(idx)/(1.-e_w_t(idx))
	
	xvs =(x_vector+p1)                             ;symetric
        peak=peak+p2_tmp/(1+(xvs/new_p3)^2)/new_p3/!PI ;symetric
	peak=peak*det_bal
endif

IF N_PARAMS() GT 5 THEN BEGIN
    partial_deriv=FLTARR(N_ELEMENTS(x_vector),3); define partial_deriv array
    partial_deriv(*,0)=2./p2/new_p3^2 *( xvt*peakt ^2 - xvs*peaks ^2)*det_bal ;% p1
    partial_deriv(*,1)=   p2*(peakt+peaks)                           *det_bal ;% p2
    partial_deriv(*,2)=2./p2/new_p3^2 *((xvt*peakt)^2 +(xvs*peaks)^2)*det_bal ;% p3
ENDIF
END

;===============================================================================
PRO Sum_fit_fct,x,a,f,npk,pder					; ==============
;===============================================================================
; defines npk 'fct type' plus flat and sloping background
; parameters go pos,ht,wdth in array a

COMMON gc_data
COMMON gc_negative
COMMON gc_dids

nx =N_ELEMENTS(x)
pder=fltarr(nx,N_ELEMENTS(a))	; jacobienne
f(*)=0.0
peak=f
ht_or_wdth=0
peak_neg=0
FOR i=0,npk-1 DO BEGIN
    peak(*)=0.0 & ind=i*3
    p1=a(ind) & p2=a(ind+1) & p3=a(ind+2)
    curpic=i+1
    CALL_PROCEDURE, g_fct_type(i),x,p1,p2,p3,peak,partial_deriv
    if (p2 lt 0.0) or (p3 lt 0.0) then begin
       peak_neg=i+1
       if (p2 lt 0.0) then ht_or_wdth=1
       if (p3 lt 0.0) then ht_or_wdth=2
    endif
    f =f+peak
    pder(*,ind)  =partial_deriv(*,0)
    pder(*,ind+1)=partial_deriv(*,1)
    pder(*,ind+2)=partial_deriv(*,2)
ENDFOR

ilast=npk*3-1		; Add flat and sloping bg
get_bckg, npk, a, bbb, sss
f=f+bbb+sss*x

pder(*,ilast+1)=1	;.....Get partials for backgrounds
pder(0,ilast+2)=x
END

;===============================================================================
PRO fitit,	npeaks,	w_in, w_out, g_parameters, x_ci,$	; ==============
		ncycles,resid,g_step,gw_resid_lab,$		; ==============
		excl_param, poids				; ==============
;===============================================================================

;gjk April 1995

COMMON gc_save
COMMON gc_negative
peak_neg=0
npk	 =npeaks
tiny     =1.0e-4
g_step   =STRTRIM(g_step,2)
parstep  =fltarr((npk*3)+2)
wts	 =w_in
wts(*)   =1.0
size_of_x=N_ELEMENTS(x_ci)

;... calcul de la fonction poids associee a excl_param : (version zone de fit)
;on met 0 en dehors des intervalles entres, ie 1 dans les intervalles entres
poids=fltarr(size_of_x)
for i=1,N_ELEMENTS(excl_param)/2 DO BEGIN
    ;inclusion de l'intervalle [excl_param(2*i-2) , excl_param(2*i-1)] : 
    eps=abs((x_ci(size_of_x-1)-x_ci(0)))/(size_of_x-1) ; eps=distance moyenne 
    ; entre deux elements de x_ci
    FOR j=0,size_of_x-1 DO BEGIN
	IF ((x_ci(j) ge excl_param(2*i-2)) AND (x_ci(j) le excl_param(2*i-1)))$
	    THEN poids(j)=1
    ENDFOR  
ENDFOR
;... fin du calcul de la fonction poids associee a excl_param 

;........Copy across parameters and steps
FOR nvb=0,(npk*3)+1 DO BEGIN
    parstep(nvb)=1.
    ;do we know the step?
    IF STRPOS(g_step(nvb),'f') ge 0 THEN parstep(nvb)=0. ELSE BEGIN
	FOR jd=1,npk DO BEGIN
	    IF float(jd) eq float(g_step(nvb)) THEN BEGIN
 		  parstep(nvb)=-float(jd)
 	    ENDIF	
	ENDFOR
    ENDELSE 
ENDFOR

params=FLTARR((npk*3)+2)
params(0:(npk*3)+1)=g_parameters(0:(npk*3)+1)

if ncycles eq 0 then begin
    w_out=jfit(x_ci,w_in,wts,params,parstep,resid,ncycles,npk,poids)
endif else begin
    o_pars=params
    o_resid=resid
    t=systime(1)
    ; Dumb shifting routine to get it about right, ncycles times
    w_out=jfit(x_ci,w_in,wts,params,parstep,resid,ncycles,npk,poids)
   ; Hope that we are close enough for derivatives, do it twice if ncycles > 1
    if peak_neg eq 0 then begin
       w_out=genfit(x_ci,w_in,wts,params,parstep,npk,resid,poids)
       if ncycles gt 1 then $
       w_out=genfit(x_ci,w_in,wts,params,parstep,npk,resid,poids)
    endif
    IF (resid ge o_resid) or (peak_neg gt 0) THEN BEGIN
	resid=o_resid & params=o_pars
    ENDIF
    old_g=g_parameters
    g_parameters(0:(npk*3)+1)=params(0:(npk*3)+1)
endelse
END

; ************ END OF FITIT **********

;===============================================================================
FUNCTION calculate_error, modele					; ======
;===============================================================================
; retourne un vecteur contenant les erreurs faites sur les parametres
; de la fonction approximante.(cf. "variance-covariance matrix
; determination in non-linear least squares fitting" by R.F. Pettifer)

COMMON gc_data
COMMON gc_save
donnees=w_ni
points_mes=x_ni	

tiny=1e-10
m=N_ELEMENTS(points_mes)	; nombre de mesures
nvarf=0
FOR i=0,3*g_npeaks+1 DO BEGIN
    IF STRPOS(g_step(i),'f') ge 0 or (abs(g_parameters(i)) le tiny) THEN BEGIN
	nvarf=nvarf+1
	IF N_ELEMENTS(repf) eq 0 THEN repf=[i] ELSE repf=[repf,i]
    ENDIF
ENDFOR
IF N_ELEMENTS(repf) ne 0 THEN repfkept=repf
n=3*g_npeaks+2-nvarf		; nb de variables non fixees du modele
f=modele-donnees
s=total(f^2)
;... calcul de la jacobienne J: appel aux procedures de fitit
Sum_fit_fct,points_mes,g_parameters,f,g_npeaks,J
J=transpose(J)
J=J(0:3*g_npeaks+1,*)
nj=3*g_npeaks+2    ; nb de colonnes de J
FOR i=0,nvarf-1 DO BEGIN
    IF (repf(i) eq 0) THEN BEGIN	;cas ou on enleve la 1e colonne
	J=J(1:nj-1,*)
    END ELSE IF (repf(i) eq nj-1) THEN BEGIN	;cas ou on enleve la derniere
						;colonne
	J=J(0:nj-2,*)
    END ELSE BEGIN
	J=[J(0:repf(i)-1,*) , J(repf(i)+1:nj-1,*)]
    ENDELSE
    repf=repf-1
    nj  =nj-1
ENDFOR
; le J obtenu apres call_procedure etait la transposee de la jacobienne
G=2*j#transpose(J)	; produit matriciel !!
H=nr_invert(G)	; inversion matricielle !!
sigcarre=2*S/(m-n)*H
diag =fltarr(n)
FOR i=1,n DO BEGIN
    diag(i-1)=sigcarre(i-1,i-1)
ENDFOR
g_error(0)=sqrt(diag)
IF N_ELEMENTS(repf) ne 0 THEN BEGIN
    error2=fltarr(N_ELEMENTS(g_error))
    j=0 & k=0
    FOR i=0,N_ELEMENTS(error2)-1 DO BEGIN
	IF N_ELEMENTS(repfkept) gt j THEN IF repfkept(j) eq i THEN BEGIN
	    error2(i)=0.0
	    j=j+1
	ENDIF ELSE BEGIN
	    error2(i)=g_error(k)
	    k=k+1
	ENDELSE
    ENDFOR
g_error=error2
ENDIF
RETURN, g_error
END

;===============================================================================
PRO adapte 	,x_to_plot,w_to_plot,w_out,plot_flag				; ==============
;===============================================================================
; Adapt vector to current view zone

common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
COMMON gc_save
COMMON gc_data
COMMON gc_wid
COMMON gc_fit_view
COMMON gc_fit_excl
COMMON gc_dids

; Adapt vector to current plot zone
		noxrange=1
		if ximion then begin
		   widget_control,gx_mim1,get_value=tmpa  & tmpa=tmpa(0)
		   widget_control,gx_mim2,get_value=tmpb  & tmpb=tmpb(0)
		   if strpos(strlowcase(tmpa),'min') ge 0 then tmpa=min(x_to_plot)
		   if strpos(strlowcase(tmpb),'max') ge 0 then tmpb=max(x_to_plot)
		   on_ioerror,misximi & tmpa=float(tmpa) & tmpb=float(tmpb)
		   if tmpb gt tmpa then begin noxrange=0 & ximirange=[tmpa,tmpb] & viewarr(0)=tmpa & viewarr(1)=tmpb & endif
		   misximi:
		endif
		noyrange=1
		if mimion then begin
		   widget_control,gw_mimi,get_value=tmpt  & tmpt=tmpt(0)
		   if strpos(strlowcase(tmpt),'max') ge 0 then tmpt=max(w_to_plot)
		   on_ioerror,mismimi  & tmpt=float(tmpt)
		   if tmpt gt mimirange(0) then begin mimirange(1)=tmpt & noyrange=0 & viewarr(3)=tmpt & endif
		   mismimi:
		endif
ind =where((x_ni ge viewarr(0)) AND (x_ni le viewarr(1)) AND $
		(w_ni ge viewarr(2)) AND (w_ni le viewarr(3)), nb_pt1)

IF (nb_pt1 eq 0) THEN BEGIN
    error_msg, 1
    viewarr(0)=MIN(x_ni,MAX=ma) & viewarr(1)=ma
    viewarr(2)=MIN(w_ni,MAX=ma) & viewarr(3)=ma
    x_to_plot =x_ni
    w_to_plot =w_ni
    if n_elements(e_ni) gt 1 then e_to_plot=e_ni
ENDIF ELSE BEGIN
    x_to_plot =x_ni(ind) ; WE USE XRANGE !!!
    w_to_plot =w_ni(ind) ; WE USE YRANGE !!!
    if n_elements(e_ni) gt 1 then e_to_plot=e_ni(ind)
ENDELSE
    sym_test=size(x_to_plot)
    if sym_test(1) lt 200 then begin
    sym_to_plot=7
    size_to_plot=2.0-(sym_test(1)/200.)
    endif else begin 
    sym_to_plot=10
    size_to_plot=1.
    endelse
    if n_elements(e_ni) le 1 then e_to_plot=0
;
; Plot the data and errors if plot_flag set
    if plot_flag ge 1 then begin
        trap_current=!D.window
        if plot_flag eq 3 then plot,x_to_plot,w_to_plot,/noerase,/nodata $
	else begin
		if (noyrange and noxrange) then plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot $
		else   begin if (noyrange) then plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot,xrange=ximirange  $
		       else  if (noxrange) then plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot,yrange=mimirange  $
		     			   else plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot,xrange=ximirange,yrange=mimirange
		endelse
		if n_elements(e_to_plot) gt 1 and n_elements(e_to_plot) lt 100 then $
			errplot,x_to_plot,w_to_plot - e_to_plot,w_to_plot + e_to_plot
		aff_excl,excl_param
	endelse
	if plot_flag eq 1 then oplot,x_ni,w_out,linestyle=2,thick=2 
    endif
END

;===============================================================================
FUNCTION belong_to	,elem,inter				; ==============
;===============================================================================
; retourne un booleen indiquant si l'element elem est dans l'un des intervalles
; de inter ( sert a la procedure aff_excl)

nb  =N_ELEMENTS(inter)
i   =0
WHILE (i le nb/2-1) DO BEGIN
    IF ((elem ge inter(2*i)) AND (elem le inter(2*i+1))) THEN return ,1
    i=i+1
ENDWHILE

return ,0
END

;===============================================================================
PRO aff_excl	,excl_param					; ==============
;===============================================================================
; affichage des zones exclues du fit

COMMON gc_save

; calcul des zones exclues a partir des fit zones : l'ensemble complementaire
; de l'union des intervalles de excl_param dans le domaine de travail.
; on parcourt x_ni avec cour (element courant) et deux indicateurs :
; prec indique si l'element precedent cour etait dans une fit zone
; avprec indique si l'element precedent l'element precedent prec
; etait dans une fit zone.
; res est le tableau resultat contenant les bornes des intervalles
; complementaires de la fit zone

res=fltarr(1) & mini=MIN(x_ni)
IF (MIN(excl_param) le mini) THEN BEGIN
    prec=1 & res(0)=mini
ENDIF ELSE prec=0

FOR i=0,N_ELEMENTS(x_ni)-1 DO BEGIN
    cour=x_ni(i)
    IF belong_to(cour,excl_param) THEN BEGIN 	; We are in a fit zone  
	IF prec THEN avprec=1 ELSE BEGIN
	    avprec=0
	    prec=1
	ENDELSE
    ENDif ELSE BEGIN				; We are not in a fit zone    
	IF N_ELEMENTS(res) eq 1 THEN BEGIN
	    res(0)=cour
	    res=[res,cour]
	    prec  =0
	    avprec=0
	ENDIF ELSE BEGIN		; le nb d'elements de res est > 1   
	    IF prec THEN BEGIN		;prec etait dans une fit zone:
		res =[res,cour] ;on rajoute le min de l'intervalle exclu commence.
		prec  =0
		avprec=1
	    ENDIF ELSE BEGIN		; prec n'etait pas dans une fit zone ...
		prec=0
		IF avprec THEN res=[res,cour]$   ; ... mais avprec si :
		    ; il faut rajouter le max de l'intervalle courant.
		ELSE res(N_ELEMENTS(res)-1)=cour    ;prec n'etait pas dans une fit$
		    ; zone -> il suffit de deplacer la borne max de$
		    ;l'intervalle courant
		avprec=0
	    ENDELSE  
	ENDELSE
    ENDELSE
ENDFOR

; We can now plot fit excluded zone, only in view zone
w_out=1
adapte ,x_to_plot,w_to_plot,w_out,0
;x_to_plot=x_ni
;w_to_plot=w_ni

FOR i=0,N_ELEMENTS(res)/2-1 DO BEGIN
    ;affichage de l 'intervalle [res(i),res(i+1)]
    index=where((x_to_plot ge res(2*i)) AND (x_to_plot le res(2*i+1)),compt)
    IF compt ne 0 THEN BEGIN
	x	=fltarr(2*compt)
	x(0)	=x_to_plot(index)
	x(compt)=reverse(x(0:(compt-1)))
	w	=fltarr(2*compt)
	wmax	=MAX(w_to_plot,MIN=wmin)
	w(0)	=w_to_plot(index)
	w(compt)=reverse(w(0:(compt-1)))+(wmax-wmin)/10
	polyfill,x,w
    ENDIF
ENDFOR
END

FUNCTION gfit_event_func, event
gfit_event, event
RETURN, 0
END

;===============================================================================
PRO gfit_ctrl_panel, id						; ==============
;===============================================================================
; if id is defined,  then gfit_ctrl_panel has been destroyed, build it again

@lamp.cbk
COMMON gc_save
COMMON gc_wid
COMMON gc_data
COMMON gc_fit_excl
COMMON gc_cp
COMMON gc_flags
COMMON gc_fit_view

IF XREGISTERED('gfit_ctrl_panel') GT 0 AND N_PARAMS() EQ 0 THEN RETURN
IF XREGISTERED('gfit_ctrl_panel') GT 0 THEN WIDGET_CONTROL, bad_id=i, id, /Destroy
IF XREGISTERED('gfit') LE 0 then RETURN
if gw_gkfit_base       eq 0 then RETURN
BASE		=WIDGET_BASE  (Title='GFIT Control Panel', $
			       Group_Leader=gw_gkfit_base, $
			       Resource_Name='lampdon', /Column)
set_show_base	=WIDGET_BASE  (BASE, /Column, /frame)

peak_lab	=WIDGET_LABEL (set_show_base, Font= ft_b_bigger,$
				VALUE='Set fit parameters of function #')

peak_menu2	=WIDGET_BASE  (set_show_base , Column=g_nb_pk_max)
gw_type_but	=LONARR(g_nb_pk_max)  
gw_gau_but	=LONARR(g_nb_pk_max)
gw_lor_but	=LONARR(g_nb_pk_max)
gw_peak_but	=LONARR(g_nb_pk_max)

FOR i=1,g_nb_pk_max DO BEGIN
    gw_type_but(i-1)=WIDGET_BUTTON (peak_menu2, /Menu, Font=ft_propor, $
				UValue=[4,i,1], Value=STRMID(g_fct_type(i-1), 0, 3))
    gw_gau_but(i-1)=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,1],Value='Gauss', Font=ft_propor)
    gw_lor_but(i-1)=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,2],Value='Lorentz', Font=ft_propor)
    peak_base	   =WIDGET_BASE(peak_menu2, /Exclusive)
    gw_peak_but(i-1)=WIDGET_BUTTON(peak_base,/No_Release, Value=STRTRIM(STRING(i),2),$
				   UValue=[2,2,0], Font=ft_b_bigger) 
    IF i LE g_npeaks THEN sens=1 ELSE sens=0
    WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1) ,Sensitive=sens
ENDFOR
WIDGET_CONTROL, bad_id=i, gw_peak_but(g_pk_nb-1), Set_Button=1	; First button is set (Default)

gw_pk_slider=WIDGET_SLIDER(set_show_base, Maximum=g_nb_pk_max,$
				Minimum=1,/Suppress_Value, YSize=15,$
				UVALUE=[2,1,0],Value=g_npeaks)

button_base =WIDGET_BASE  (Title='GFIT Control Panel', BASE, /Column)
bloc_base   =WIDGET_BASE   (BASE , /row)		;.... gw_resid_lab .... 
resid_lab   =WIDGET_LABEL  (bloc_base,Value ='Residual:', Font=ft_normal)
gw_resid_lab=WIDGET_LABEL  (bloc_base,Value ='______________',Font=ft_b_normal)
bloc_baseb   =WIDGET_BASE   (BASE , /row)		;.... gw_resid_lab .... 
gw_cycle_lab=WIDGET_LABEL  (bloc_baseb, Font=ft_b_normal, Value='  '+$
				 STRTRIM(STRING(g_ncycles),2)+' Cycles')

cycles_sld  =WIDGET_SLIDER (bloc_baseb, Maximum=75 ,Minimum=0 , /Drag,$
				Value=g_ncycles,xsize=150, $
				YSize=16,/Suppress_Value, UValue=[2,3,0])

bloc_basec   =WIDGET_BASE   (BASE , /row)		;.... gw_resid_lab .... 
fit_but	    =WIDGET_BUTTON  (bloc_basec, Font=ft_biggest,$
				UValue=[2,4,0], Value ='FIT IT')
print_but   =WIDGET_BUTTON  (bloc_basec,Font=ft_biggest,$
				UValue=[3,1,0],Value=' Print ')
help_but    =WIDGET_BUTTON  (bloc_basec,Font=ft_biggest,$
				UValue=[3,2,0],Value=' Help ')
gw_exit_but =WIDGET_BUTTON  (bloc_basec,Font=ft_biggest,$
				UValue=[3,3,0], Value=' DONE ')


bloc_based  =WIDGET_BASE   (BASE , /Column, Frame=2)
title_lab   =WIDGET_LABEL  (bloc_based, Font=ft_propor, Value='Parameters')
bloc_based1 =WIDGET_BASE   (bloc_based, /Column, /Frame)
title_lab   =WIDGET_LABEL  (bloc_based1, Font=ft_smaller, Value='# bck.      Pos.     Fix.  Height   Fix.  HwHm  Fix.')
row	    =LONARR(g_nb_pk_max)
cp_nb	    =LONARR(g_nb_pk_max)
cp_bck	    =LONARR(g_nb_pk_max)
cp_pos	    =LONARR(g_nb_pk_max)
cp_hgt	    =LONARR(g_nb_pk_max)
cp_wid	    =LONARR(g_nb_pk_max)
cp_pf	    =LONARR(g_nb_pk_max)
cp_hf	    =LONARR(g_nb_pk_max)
cp_wf	    =LONARR(g_nb_pk_max)
FOR i=1, g_nb_pk_max DO BEGIN
    row(i-1)    =WIDGET_BASE   (bloc_based1, /Row, /Frame)
    cp_nb(i-1)  =WIDGET_LABEL  (row(i-1),Font=ft_smaller, Value=STRTRIM(STRING(i), 2))
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_bck(i-1) =WIDGET_BUTTON (basecp,Font=ft_propor, Value='')
    cp_pos(i-1) =WIDGET_TEXT   (row(i-1), Font=ft_smaller, Value='', XSize=6)
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_pf(i-1)  =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
    cp_hgt(i-1) =WIDGET_TEXT   (row(i-1), Font=ft_smaller, Value='', XSize=6)
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_hf(i-1)  =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
    cp_wid(i-1) =WIDGET_TEXT   (row(i-1), Font=ft_smaller, Value='', XSize=6)
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_wf(i-1)  =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
ENDFOR
bloc_based2 =WIDGET_BASE   (bloc_based, /Column, /Frame)
lab	    =WIDGET_LABEL  (bloc_based2, Font=ft_propor, Value='    Flat BKG Fix. Slope BKG Fix.')
row1	    =WIDGET_BASE   (bloc_based2, /Row)
bid	    =WIDGET_LABEL  (row1, Font=ft_smaller, Value='         ')
cp_fb	    =WIDGET_TEXT   (row1, Font=ft_smaller, Value='', XSize=7)
basecp	    =WIDGET_BASE   (row1, /NonExclusive)
cp_fbf	    =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
cp_sb	    =WIDGET_TEXT   (row1, Font=ft_smaller, Value='', XSize=7)
basecp	    =WIDGET_BASE   (row1, /NonExclusive)
cp_sbf	     =WIDGET_BUTTON(basecp,Font=ft_smaller, Value='f')
bid=sys_dep('DYNLAB', base, 1)
WIDGET_CONTROL, bad_id=i, BASE, /Realize
XMANAGER, 'gfit_ctrl_panel', BASE, /Just_reg, Cleanup='gfit_ctrl_panel'
WIDGET_CONTROL, bad_id=i, BASE, Event_Func='gfit_event_func'
RETURN
END

;===============================================================================
PRO do_fit, option						; ==============
;===============================================================================
; 
@lamp.cbk
COMMON gc_save
COMMON gc_wid
COMMON gc_data
COMMON gc_fit_excl
COMMON gc_flags
COMMON gc_fit_view
COMMON gc_negative

IF sw_ni(0) gt 0 THEN BEGIN
    ;calculation of the array used to calculate integrals for non-linear scales
    ;l(i)=(x(i+1)-x(i-1))/2 pour i variant de 1 a nombre mesures-1
    ;l(0)=(x(1)-x(0))/2  et  l(n)=(x(n)-x(n-1))/2
    larg =fltarr(N_ELEMENTS(x_ni))
    xprim=[x_ni(1:N_ELEMENTS(x_ni)-1),x_ni(N_ELEMENTS(x_ni)-1)]
    xsec =[x_ni(0),x_ni(0:N_ELEMENTS(x_ni)-2)]
    g_largeur=(xprim-xsec)/2
    read_par_vals
    gk_warning,excl_param,viewarr

    empty=0			; Check if each peaks is defined
    FOR i=0,g_npeaks-1 DO BEGIN
	if g_parameters(i*3+1) le 0 or g_parameters(i*3+2) le 0 THEN $
	    empty=empty+1
    ENDFOR
    IF empty gt 0 THEN BEGIN	; --- One of the peaks was undefined
	str=STRTRIM(STRING(empty),2)+' peak'
	if empty gt 1 THEN str=str +'s are ' ELSE str=str+' is '
	str=str+'not defined ! Define empty peak'
	if empty gt 1 THEN str=str+'s'
	error_msg, -1, str
    ENDIF ELSE BEGIN		; --- No peak is undefined
	old_resid=g_resid		; --- Push resid
	old_par=g_parameters	; --- Push parameters
	fitit,g_npeaks,w_ni,w_out,g_parameters,x_ni,g_ncycles,$
	      g_resid,g_step,gw_resid_lab ,excl_param,poids
	g_afitisdone=1		; a fit was done
	
	if peak_neg gt 0 then begin
	   if ht_or_wdth eq 1 then $
	   str='Height of peak '+ STRTRIM(STRING(peak_neg),2) + ' becomes negative'
           if ht_or_wdth eq 2 then $
	   str='Width of peak '+ STRTRIM(STRING(peak_neg),2) + ' becomes negative'
	   error_msg,-1,str 
	   g_resid=old_resid	    ; Pop resid
	   g_parameters=old_par    ; Pop parameters
	endif
	
	IF (g_resid ge old_resid) and (peak_neg eq 0) THEN BEGIN ; If worse, restore old values
	    g_resid=old_resid	    ; Pop resid
	    g_parameters=old_par    ; Pop parameters
	    error_msg, 4	    ; Alert user
	ENDIF ELSE $
;
; Plotting of results on screen here
	WIDGET_CONTROL, bad_id=i, gw_resid_lab, Set_Value=STRTRIM(STRING(g_resid),2)+'%'
	IF N_PARAMS() GT 0 THEN wset,did_win0 ELSE wset,g_plot_wid

	adapte ,x_to_plot,w_to_plot,w_out,1
	plt_dev=0
	;.....plot subfunctions if necessary
	IF g_show_subfct THEN plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
	; --- Error calculation
	g_error=calculate_error(w_out)
	put_vals,x_ni,w_ni,w_out,plt_dev,poids,lamp_siz
	write_par_vals, /No_Update
    ENDELSE
ENDIF
IF N_PARAMS() GT 0 THEN BEGIN
    option=w_out
ENDIF
END

;===============================================================================
PRO get_param, g_parameters, idx, p1, p2, p3	    		; ==============
;===============================================================================

ind=(idx-1)*3
p1=g_parameters(ind)
p2=g_parameters(ind+1)
p3=g_parameters(ind+2)
RETURN
END

;===============================================================================
PRO get_bckg, g_npeaks, g_parameters, bbb, sss	    		; ==============
;===============================================================================

ilast=g_npeaks*3-1
bbb  =g_parameters(ilast+1)
sss  =g_parameters(ilast+2)
RETURN
END

;===============================================================================
PRO gfit_help	, dummy, formu, formt
;===============================================================================

formu=''
formt='Fitting Routines by G.Kearley. Interface by Romuald JOUFFREY.'
formu=[formu,'What is to be plotted :']
formt=[formt,'']
formu=[formu,'']
formt=[formt,'Adjust workspace number (upper left) and Click "GetWs #" to fetch data.']
formu=[formu,'']
formt=[formt,'Cutting value can be set with the tiny slider']
formu=[formu,'How to perform a fit :']
formt=[formt,'']
formu=[formu,'High level details']
formt=[formt,'']
formu=[formu,'']
formt=[formt,'Once a scan is plotted, choose the number of subfonctions, Then choose the type of fitting subfonction(s)']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Clicks on plot are significant :']
formt=[formt,'']
formu=[formu,'Left mouse button ']
formt=[formt,'- click current subfunction Height(position) then drag and release on half-Width']
formu=[formu,'Right mouse button']
formt=[formt,'- Drag to set the fitting area ("Fit-zone" button is used for multiple areas)']
formu=[formu,'']
formt=[formt,'']
RETURN
END

;===============================================================================
PRO gk_initialize						; ==============
;===============================================================================

COMMON gc_data
COMMON gc_flags
COMMON gc_fit_excl
COMMON gc_wid

;g_parameters(*)=0.0 & g_step(*)=''
;gc_fit_flags=0
V=''

WIDGET_CONTROL, bad_id=i, gw_pos_text,	Set_Value='0.0'	;Clear field
WIDGET_CONTROL, bad_id=i, gw_int_text,	Set_Value='0.0'	;Clear field
WIDGET_CONTROL, bad_id=i, gw_wdt_text,	Set_Value='0.0'	;Clear field
WIDGET_CONTROL, bad_id=i, gw_fbg_text,	Set_Value='0.0'	;Clear field
WIDGET_CONTROL, bad_id=i, gw_sbg_text,	Set_Value='0.0'	;Clear field
WIDGET_CONTROL, bad_id=i, gw_cut_label,	Set_Value=''
WIDGET_CONTROL, bad_id=i, gw_resid_lab,	Set_Value=''

g_resid=1.0e12
WSET, g_plot_wid
ERASE, 0
excl_param=fltarr(2*max_nb_int)	; Reset excl_param to [0,0]
END 

;===============================================================================
PRO gfit_Event, Event						; ==============
;===============================================================================
; Called when a gfit event is generated

@lamp.cbk
common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
COMMON gc_save
COMMON gc_wid
COMMON gc_data
COMMON gc_fit_excl
COMMON gc_flags
COMMON gc_fit_view
COMMON gc_width_factor
COMMON gc_negative
COMMON gc_dids

stat=0
catch,stat
if stat  ne 0  then BEGIN
		catch,/cancel
 		set_plot,my_path(3)
		WIDGET_CONTROL, bad_id=i, gw_err_lab, Set_Value=!err_STRING
		RETURN & ENDIF
error_msg, 0				; Clear error msg fields

if  tag_names(Event,/structure_name) ne 'WIDGET_DRAW' then $
	WIDGET_CONTROL, bad_id=i, Event.Id, /Hourglass
	WIDGET_CONTROL, bad_id=i, Event.Id, GET_UVALUE=Ev, Get_Value=value
no_plot=0
CASE Ev(0) OF
    1 	: BEGIN
    CASE Ev(1) OF
    1 : BEGIN			; W slider event
	    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=nw_ni
	END

    2	: BEGIN			; Get Button event
	gk_initialize
	IF Ev(2) NE 0 THEN BEGIN
	    nw_ni=Ev(2)
	    tripx_mode=1
	ENDIF ELSE tripx_mode=0
	nwt_in=STRTRIM(STRING(nw_ni),2)	; Get W number id
	w_ni=0 & x_in=0 & y_in=0 & e_in=0
	iii=EXECUTE("w_ni=w"+nwt_in)
	iii=EXECUTE("x_in=x"+nwt_in) & x_ni=x_in(*,0)
	iii=EXECUTE("y_in=y"+nwt_in)
	iii=EXECUTE("e_ni=e"+nwt_in)
	if n_elements(e_ni) ne n_elements(w_ni) then e_ni=0
	w_ni=w_ni > 0
	sw_ni=SIZE(w_ni) & sx_ni=SIZE(x_ni)		    & sy_in=SIZE(y_in)
	if sy_in(1) gt 1  then begin y_in=reform(y_in(0,*)) & sy_in=SIZE(y_in) & endif
	keepw=w_ni
	keepe=e_ni
	IF sw_ni(0) gt 0 THEN BEGIN
	    IF sw_ni(0) gt 2 THEN BEGIN
		w_ni =TOTAL(w_ni,3) & e_ni=0
		sw_ni=SIZE(w_ni)
		error_msg, 2
	    ENDIF

	    IF (sw_ni(1) ne sx_ni(1)) or (sx_ni(0) ne 1) THEN BEGIN
		x_ni=indgen(sw_ni(1)) & x_in=x_ni      & ENDIF

	    IF sw_ni(0) gt 1 THEN BEGIN
		WIDGET_CONTROL, bad_id=i, ws_in_r      , Map=1
	    	WIDGET_CONTROL, bad_id=i, gw_cut_slider, /Sensitive
	    	; initializing regle
	    	WIDGET_CONTROL, bad_id=i, gw_cut_slider, Set_Slider_Max=sw_ni(2)
	    	; on cree un "y" par defaut :
		IF n_elements(y_in) ne sw_ni(2) THEN y_in=findgen(sw_ni(2))+1
	    	WIDGET_CONTROL, bad_id=i, gw_cut_slider, Get_Value=no_coupe
	    	w_ni =keepw(*,no_coupe-1)
	    	if n_elements(e_ni) gt 1 then $
		e_ni =keepe(*,no_coupe-1)
	    	sw_ni=size(w_ni)
		IF (size(x_in))(0) eq 2 then x_ni=x_in(*,no_coupe-1)

	    	; initialisation du label de la regle :
	    	WIDGET_CONTROL, bad_id=i, gw_cut_label, Set_Value='->'+$
	    	STRTRIM(STRING(y_in(no_coupe-1)),2)

	    ENDIF ELSE BEGIN
	        WIDGET_CONTROL, bad_id=i, gw_cut_slider, sensitive=0
		WIDGET_CONTROL, bad_id=i, ws_in_r      , Map=0 & ENDELSE

	    g_error=fltarr(3*g_nb_pk_max+2)

	    ;initialisation par defaut de excl_param :
	    excl_param(0)=MIN(x_in,MAX=ma)
	    excl_param(1)=ma
	    WIDGET_CONTROL, bad_id=i, excl_widge(0),Set_Value=$
				STRTRIM(STRING(excl_param(0)),2)
	    WIDGET_CONTROL, bad_id=i, excl_widge(1),Set_Value=$
				STRTRIM(STRING(excl_param(1)),2)
	    FOR i=1,max_nb_int-1 DO BEGIN
		excl_param(2*i)  =excl_param(0)-1
		excl_param(2*i+1)=excl_param(0)-1
		WIDGET_CONTROL, bad_id=iii, excl_widge(2*i)  ,Set_Value='***'
		WIDGET_CONTROL, bad_id=iii, excl_widge(2*i+1),Set_Value='***'
	    ENDFOR
	
	    ; initialisation de viewarr :
	    viewarr(0)=excl_param(0)	& viewarr(0+sauv)=excl_param(0)
	    viewarr(1)=excl_param(1)	& viewarr(1+sauv)=excl_param(1)
	    viewarr(2)=MIN(w_ni,MAX=ma)	& viewarr(2+sauv)=viewarr(2)
	    viewarr(3)=ma		& viewarr(3+sauv)=viewarr(3)
	    mimirange =[viewarr(2),viewarr(3)]

	    IF tripx_mode THEN WSET, did_win0 ELSE WSET,g_plot_wid
	   ;!p.title=w_tit(nw_ni)
	    !x.title=x_tit(nw_ni)
	    !y.title=y_tit(nw_ni)
	    
	    trap_current=!D.window
	    adapte ,x_ni,w_ni,w_ni,1 ;plot,x_ni,w_ni
    ENDIF ELSE error_msg, 3
    END
    3 : BEGIN			; Cut slider event
		    g_resid=1.0e12
		    ; --- Getting data to plot
		    WIDGET_CONTROL, bad_id=i, gw_cut_slider, Get_Value=no_coupe
		    w_ni=keepw(*,no_coupe-1)
		    if n_elements(e_ni) gt 1 then $
		    e_ni=keepe(*,no_coupe-1)
		    IF (size(x_in))(0) eq 2 then x_ni=x_in(*,no_coupe-1)

		    ; --- Initializing  viewarr(2) & viewarr(3)
		    viewarr(2)=MIN(w_ni,MAX=ma)	& viewarr(2+sauv)=viewarr(2)
		    viewarr(3)=ma		& viewarr(3+sauv)=viewarr(3)
		    mimirange =[viewarr(2),viewarr(3)]

		    ; update label of parameter
		    WIDGET_CONTROL, bad_id=i, gw_cut_label, Set_Value =$
			'->'+STRTRIM(STRING(y_in(no_coupe-1)),2)

		    ; do the plot
		    !x.title=x_tit(nw_ni)+' Spectrum '+STRTRIM(STRING(y_in(no_coupe-1)),2)
		    wset,g_plot_wid
		    adapte ,x_to_plot,w_to_plot,w_out,1
		  END
    4		: BEGIN			; --- W out Slider event
		    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=nw_out
		  END
    5		: IF sw_ni(0) gt 0 THEN BEGIN	; --- W out Button event
			xicuter, 'w'+STRTRIM(STRING(nw_out),2) +$
			'=gk_fit(w' +STRTRIM(STRING(nw_ni),2) +')'
		  ENDIF
    ENDCASE
    END
    2	: BEGIN
    CASE Ev(1) OF
    1		: BEGIN			; --- Peak Slider 
		new_npeaks=0
		WIDGET_CONTROL, bad_id=i, event.id, Get_Value=new_npeaks
		IF new_npeaks LT g_pk_nb THEN BEGIN
		    ; peak_number 1 button Simulated event
		    gfit_Event,{WIDGET_BUTTON, ID:gw_peak_but(0), $
				TOP:gw_gkfit_base, HANDLER:0L, SELECT:1} 
		ENDIF ELSE BEGIN
		    g_step(g_npeaks*3:g_npeaks*3+1)=''
		ENDELSE
		g_npeaks=new_npeaks
		; Make Peak buttons number > g_npeaks NonSensible
		FOR i=1,g_nb_pk_max DO BEGIN
		    IF i GT g_npeaks THEN BEGIN
			WIDGET_CONTROL, bad_id=iii, gw_pos_pop (i+3), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_int_pop (i+3), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_wdt_pop (i+3), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_type_but(i-1), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(g_nb_pk_max+i-1), map=0
		    ENDIF ELSE BEGIN
			WIDGET_CONTROL, bad_id=iii, gw_pos_pop (i+3), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_int_pop (i+3), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_wdt_pop (i+3), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_type_but(i-1), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(g_nb_pk_max+i-1), map=1
		    ENDELSE
		    g_resid=1.0e12
		ENDFOR
		g_resid=1.0e12
		 END
    2	       : BEGIN			; --- Peak number Button event
		    ; Get old selected peak parameters
		    read_par_vals
		    g_old_pk_nb=g_pk_nb
		    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=g_pk_nb
		    IF g_pk_nb ne g_old_pk_nb THEN BEGIN
		        WIDGET_CONTROL, bad_id=i, gw_bose , set_button=bose(g_pk_nb-1)
			WIDGET_CONTROL, bad_id=i, gw_pk_no, Get_value=V
			V='Peak #'+STRTRIM(STRING(g_pk_nb), 2)+' param'
			WIDGET_CONTROL, bad_id=i, gw_pk_no, Set_Value=V
			FOR i=0,g_npeaks-1 DO $
			    WIDGET_CONTROL, bad_id=iii, gw_peak_but(i), $
					    Set_Button=(i EQ g_pk_nb-1)
			write_par_vals
			error_msg, -2, g_pk_nb
		    ENDIF
		   END
		




    3		: BEGIN		; --- Number of cycle(s) slider event
			WIDGET_CONTROL, bad_id=i, event.id, Get_Value=g_ncycles
			str='  '	; --- Display number of cycle(s)
			IF g_ncycles gt 1 THEN str='s'
			IF strlen(STRTRIM(STRING(g_ncycles),2)) eq 1 THEN $
			WIDGET_CONTROL, bad_id=i, gw_cycle_lab, Set_Value='  '+$
			STRTRIM(STRING(g_ncycles),2)+' Cycle'+str $
			ELSE $
			WIDGET_CONTROL, bad_id=i, gw_cycle_lab, Set_Value=$
			STRTRIM(STRING(g_ncycles),2)+' Cycle'+str
		    END
    4	: do_fit
    5	: BEGIN				; --- Fitting Zone Button event
		WIDGET_CONTROL, bad_id=i, gw_excl_base, /Map ,/Show
	  END
    6  	: BEGIN			; --- Exit Button event
		    WIDGET_CONTROL, bad_id=i, gw_view_base, /Map, /Show
		  END
    7		: IF sw_ni(0) gt 0 THEN $	; --- Plot area event
		    ; IF released button or right button is pressed
		    IF ((event.TYPE eq 1) or ((event.TYPE eq 0) $
		    	AND ((event.press eq 4) or (event.press eq 1)))) THEN BEGIN 
			WSET ,g_plot_wid
			if trap_current ne g_plot_wid then adapte ,x_to_plot,w_to_plot,w_out,3
			CURSOR,xcurs,ycurs,/nowait
			read_par_vals
			ind=(g_pk_nb-1)*3
			affiche=1
			IF g_parameters(ind+1) le 0 THEN g_parameters(ind+1)=10e-12  ;intensite par defaut 
			IF g_parameters(ind+2) le 0.0 THEN BEGIN ;largeur par defaut
			    sx=size(x_ni)
			    g_parameters(ind+2)=ABS(x_ni(sx(3)-1)-x_ni(0))/30.0
			    ; ???
			ENDIF
			; Set Position and Intensity
			g_resid=1.0e12
			IF event.press eq 1 THEN BEGIN
			    DEVICE ,cursor_standard=16
			    g_parameters(ind)=xcurs
			    ;g_parameters(ind+1)=ycurs
			    get_bckg, g_npeaks, g_parameters, bbb, sss
			    g_parameters(ind+1)=ycurs-(bbb+xcurs*sss)
			    no_plot=1  ; prevent plotting
			ENDIF
			; fin de determination de la position et de l'intensite 

			;..... width determination  
			IF event.release eq 1 THEN BEGIN
			   DEVICE ,cursor_standard=2
			   g_resid=1.0e12 
			   p=g_parameters(ind) & h=g_parameters(ind+1)
			   old_w=g_parameters(ind+2)
		           get_bckg, g_npeaks, g_parameters, bbb, sss
			   ht_bg=ycurs-(bbb+xcurs*sss)
			   IF g_fct_type(g_pk_nb-1) eq 'Gauss' THEN BEGIN
			    ;calcul de la largeur =|pos-xcurs|/rac(2|log(h)-log(ht_bg)|)
 			    denom=sqrt((abs(ALOG(h)-ALOG(ht_bg)))/gw_fac)
			    g_parameters(ind+2)=ABS(p-xcurs)/denom
			   ENDIF
			   IF g_fct_type(g_pk_nb-1) eq 'Lorentz' THEN BEGIN
			    ;calcul de la largeur =|pos-xcurs|/rac(h/y-1)
			    IF h le ht_bg THEN g_parameters(ind+2)=1.0e12 $
			    ELSE g_parameters(ind+2)=ABS(p-xcurs)/(SQRT(h/ht_bg-1)*lw_fac)
			   ENDIF
		        ENDIF
		        ;..... fin de determination de la largeur

		        ;.... determination de la fit zone :
		        IF event.press eq 4 THEN BEGIN
			   affiche=0
			   bb1=xcurs
			   bb2=x_ni(0)
			   DEVICE ,cursor_standard=32
		        ENDIF

		        IF event.release eq 4 THEN BEGIN
			   affiche=1
			   DEVICE ,cursor_standard=2
			   bb2=xcurs
			   ma =MAX(x_ni,MIN=mi)
			   IF abs(bb2-bb1) gt (ma-mi)/30 THEN BEGIN
			    ma=MAX([bb1,bb2],MIN=mi)
			    excl_param(2*intv_no-2)=mi
			    excl_param(2*intv_no-1)=ma
				WIDGET_CONTROL, bad_id=i, excl_widge(2*intv_no-2),$
				Set_Value=STRTRIM(STRING(mi),2)
				WIDGET_CONTROL, bad_id=i, excl_widge(2*intv_no-1),$
				Set_Value=STRTRIM(STRING(ma),2)
			   ENDIF
		        ENDIF
		        ;....  fin de determination des intervalles a exclure

		    	if no_plot eq 0 then $
		    	adapte ,x_to_plot,w_to_plot,w_out,2
		    	IF affiche THEN aff_excl,excl_param
		    	;..... plot peaky(s)
		    	if no_plot eq 0 then $
		    	plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
		    	no_plot=0
		    	write_par_vals, /No_Update

;		    	IF event.release eq 2 THEN BEGIN
;		    	   read_par_vals
;		    	   new_pk_nb=g_pk_nb+1
;		    	   IF new_pk_nb GT g_npeaks THEN new_pk_nb=1
;		    	   gfit_Event,{WIDGET_BUTTON, ID:gw_peak_but(new_pk_nb-1), $
;				TOP:gw_gkfit_base, HANDLER:0L, SELECT:1} 
;		        ENDIF
		    ENDIF
    8		: IF sw_ni(0) gt 0 THEN BEGIN	; --- Show subfunctions
			g_show_subfct=event.select
		ENDIF
    9		: BEGIN	; --- Convolution Button event
			; To be continued ...
		END
    10:		bose(g_pk_nb-1)=event.select
    11:		begin mimion   =event.select & if not mimion then begin viewarr(2)=MIN(w_ni,MAX=ma) & viewarr(3)=ma & endif & end
    12:		begin ximion   =event.select & if not ximion then begin viewarr(0)=MIN(x_in,MAX=ma) & viewarr(1)=ma & endif & end

    ENDCASE
    END
    3	: BEGIN
    CASE Ev(1) OF
        1   : IF sw_ni(0) gt 0 AND g_afitisdone THEN BEGIN ; Print But event
		g_print_nb=g_print_nb+1
		psFile='fit'+STRTRIM(STRING(g_print_nb),2)+'.ps'
		wplot=!D.NAME
		err=1
		ON_IOERROR,IFerr
		set_plot,'PS'
		DEVICE, filename=psFile
		DEVICE, bits_per_pixel=8,color=0
		IF g_tripx THEN BEGIN		; Tripx printing mode
		    short_side	=17.0
		    small_offset=0.5
		    long_side	=14.0
		    big_offset	=14.0
		    w_out=0
		    DEVICE, /portrait, /inches
		    DEVICE, xsize=short_side, ysize=long_side
		    DEVICE, xoffset=small_offset, yoffset=big_offset
		    fitit,g_npeaks,w_ni,w_out,g_parameters,x_ni,0,g_resid,$ 
				g_step,gw_resid_lab,excl_param,poids

		    adapte ,x_to_plot,w_to_plot,w_out,1
		    IF g_show_subfct THEN plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
		    plt_dev=1
				; Printing -> big character size
		    FOR i=0, N_ELEMENTS(g_tx_par)-1 DO BEGIN
			XYOUTS, 100, -360.-(i-1)*320., g_tx_par(i), $
				    CharSize=g_char, /Device
		    ENDFOR
		    print_vals,x_ni,w_ni,w_out,plt_dev,poids
		    DEVICE, /color
		    P_DID_PS_HEADER, 5.5, 0, psFile
		ENDIF ELSE BEGIN		; gfit printing mode
		    sx=7. & sy=11.5
		    DEVICE,yoffset=sy-.5,xoffset=.5,/inches,/landscape
		    read_par_vals
		    w_out=0
		    fitit,g_npeaks,w_ni,w_out,g_parameters,x_ni,0,g_resid,$ 
				g_step,gw_resid_lab,excl_param,poids

		    adapte ,x_to_plot,w_to_plot,w_out,1
		    IF g_show_subfct THEN plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
		    plt_dev=1
				; Printing -> big character size
		    put_vals,x_ni,w_ni,w_out,plt_dev,poids,1000
		    print_vals,x_ni,w_ni,w_out,plt_dev,poids
		    DEVICE, bits_per_pixel=8, /color
		    P_DID_PS_HEADER, 7., nw_ni, psFile
		    err=0
		ENDELSE
		IFerr: DEVICE,/Close_File
		set_plot,wplot
		ENDIF
    2  	: BEGIN
		show_helps, [-88, 590]
	  END
    3  	: BEGIN			; --- Exit Button event
		gg=gw_gkfit_base & gw_gkfit_base=0
		WIDGET_CONTROL, bad_id=i, gg ,/Destroy & wait,.3
		IF g_old_plot_wid GT 0 then WSET,g_old_plot_wid
	  END
    ENDCASE
    END
    4	: BEGIN	; --- Peak pop up menu event
		if Ev(2) eq 1 then BEGIN
		g_fct_type(Ev(1)-1)='Gauss'
		v='Gau'
		ENDIF
		if Ev(2) eq 2 then BEGIN
		g_fct_type(Ev(1)-1)='Lorentz'
		v='Lor'
		ENDIF
		WIDGET_CONTROL, bad_id=i, gw_type_but(Ev(1)-1), Set_Value=v
		g_resid=1.0e12
	  END
    5   : Parameter_menu,Ev
    6	: BEGIN
		read_par_vals
		g_resid=1.0e12
		adapte ,x_to_plot,w_to_plot,w_out,1
		plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
	  END

    -88 : if Ev(1) eq 391 then p_did_mvlog, Event,Ev

    ELSE: error_msg, 5
    ENDCASE
END

;===============================================================================
PRO gk_warning	,excl_param, viewarr				; ==============
;===============================================================================
; Warning if points of fitting zone are not in viewing zone

COMMON gc_wid

FOR i=1,N_ELEMENTS(excl_param)/2 DO BEGIN ; parcours sur chaque intervalle de fit
    IF ((viewarr(0) gt excl_param(2*i-2)) or $
	   (viewarr(1) lt excl_param(2*i-1)) ) $
	   AND (excl_param(2*i-2) ne excl_param(2*i-1)) $
	THEN error_msg, 6
    ENDFOR
END

;===============================================================================
PRO plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type		; ==============
;===============================================================================
;Puts titles on plot
;
COMMON gc_dids

FOR idx=1,g_npeaks DO BEGIN
    get_param, g_parameters, idx, p1, p2, p3
    IF p2 gt 0 AND p3 gt 0 THEN BEGIN
	IF p2 lt 0.0 THEN peaky=0.0
	IF p2 gt 0.0 THEN BEGIN
	    curpic=idx
	    CALL_PROCEDURE, g_fct_type(idx-1), $
			x_ni,p1,p2,p3,peaky
	    get_bckg, g_npeaks, g_parameters, bbb, sss
	    ma=MAX(peaky,MIN=mi)
	    pp=0.3*(ma-mi)
	    peaky=peaky + (bbb + x_ni*sss) 
	    OPLOT,x_ni,peaky,linestyle=1,thick=2
	    pp=pp+(bbb+p1*sss)
	    XYOUTS,p1,pp,STRTRIM(STRING(idx),2),CharSize=1.2, NoClip=0
	ENDIF
    ENDIF
ENDFOR
RETURN
END

;===============================================================================
PRO put_tit	,x_dats,y_dats,f_tit,fx_tit,fy_tit		; ==============
;===============================================================================
;Puts titles on plot
;

ma  =MAX(x_dats,MIN=mi)
xrng=ma-mi
ma  =MAX(y_dats,MIN=mi)
yrng=ma-mi
anx_mid=xrng/2
any_mid=yrng/2
dispx=-(xrng)*0.06
dispy=-(yrng)*0.08
dispt=ma+(yrng)*0.02
xyouts,anx_mid,dispy,fx_tit,alignment=0.5,size=1.5
xyouts,dispx,any_mid,fy_tit,alignment=0.5,orientation=90,size=1.5
xyouts,anx_mid,dispt,f_tit,alignment=0.5,size=1.5
return
END

;===============================================================================
PRO put_vals	,x_dats,y_dats,f_dats,plt_dev,poids,lamp_siz	; ==============
;===============================================================================
;Puts result on plot
;

COMMON gc_wid
COMMON gc_fit_excl
COMMON gc_data
COMMON gc_fit_view

downy=0.08
if lamp_siz gt 800 then downy=0.06
if lamp_siz gt 900 then downy=0.04

if plt_dev eq 0 THEN wset,g_plot_wid
size_of_x=N_ELEMENTS(x_dats)
eps=abs((x_dats(size_of_x-1)-x_dats(0)))/(size_of_x-1) 
device_fac=1.5
;	IF plt_dev eq 1 THEN device_fac=2.
boxx   =fltarr(5)
boxy   =fltarr(5)
min_x  =viewarr(0) 
min_y  =viewarr(2) 
xrng   =viewarr(1)-min_x 
w_out=1
adapte ,x_vu,y_vu,w_out,0
yrng   =MAX(y_vu)-min_y 
dispx  =min_x+(xrng*0.02)
dispy  =min_y+(yrng*0.96)
boxx(0)=min_x+(xrng*0.01)
boxy(0)=min_y+(yrng*0.98)
boxx(4)=boxx(0)
boxy(4)=boxy(0)
boxx(3)=boxx(0)
boxy(1)=boxy(0)
boxx(1)=min_x+(xrng*0.3)
boxx(2)=boxx(1)
boxy(2)=min_y+(yrng*0.85)
boxy(3)=boxy(2)

; Get total of fitted peak without that marked background "b"
sum_fit=0 
FOR j=1,g_npeaks DO BEGIN
    pk_int=0.0
    ind=(j-1)*3
    iback=0
    ; Look FOR "b" on a parameter
    FOR ipmt=0,2 DO BEGIN
	IF STRPOS(g_step(ind+ipmt),'b') ge 0 THEN iback=1
    ENDFOR

    IF iback eq 0 THEN BEGIN
	get_param, g_parameters, j, p1, p2, p3
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then sum_fit=sum_fit+(p2*p3*0.420448*!pi)
    if g_fct_type(j-1) eq 'Lorentz' then sum_fit=sum_fit+(p2*p3*0.5*!pi)
    ENDIF
ENDFOR
get_bckg, g_npeaks, g_parameters, bbb, sss
dataIntegral=TOTAL(y_dats*poids*g_largeur)	; calculate Data integral

fittedbackground=TOTAL((bbb+x_dats*sss)*poids*g_largeur)
dataIntegral=dataIntegral-fittedbackground

partxt='Fit Integral ='+STRTRIM(STRING(sum_fit,format='(g10.2)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char
partxt='Data Int.-bg.= '+STRTRIM(STRING(dataIntegral,format='(g10.2)'),2)
dispy=dispy-((yrng*downy)/device_fac)
XYOUTS,dispx,dispy,partxt,charsize=g_char
dispy=dispy-((yrng*downy)/device_fac)
partxt='Fitted Bg.   ='+STRTRIM(STRING(fittedbackground,format='(g10.2)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char

IF (sum_fit gt 0.0) AND (dataIntegral GT 0) THEN BEGIN
    FOR j=1,g_npeaks DO BEGIN
	pk_int=0.0
	get_param, g_parameters, j, p1, p2, p3
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then pk_int=p2*p3*0.420448*!pi
    if g_fct_type(j-1) eq 'Lorentz' then pk_int=p2*p3*0.5*!pi
	percy=pk_int*100.0/dataIntegral
;	percy_txt=' ('+STRTRIM(STRING(percy,format='(f5.1)'),2)+'%)'
;Something wrong with data integral here - I removed it gjk.
	percy_txt=' '
	dispy1=dispy-(j*(yrng*downy)/device_fac)
	partxt='Inty'+STRTRIM(STRING(j),2)+'='+STRTRIM(STRING(pk_int),2)
	partxt=partxt+percy_txt
	XYOUTS,dispx,dispy1,partxt,charsize=g_char
   ENDFOR
ENDIF
;boxy(2)=yrng*(0.85-(g_npeaks*0.05))	; ???
;boxy(2)=yrng*(0.84-(g_npeaks*0.06))	; ???
;boxy(3)=boxy(2)
;IF plt_dev eq 0 THEN oplot,boxx,boxy
return
END

;===============================================================================
PRO print_vals	,x_dats,y_dats,f_dats,plt_dev,poids		; ==============
;===============================================================================
;Put other result on print
;

COMMON gc_wid
COMMON gc_fit_excl
COMMON gc_data
COMMON gc_fit_view
COMMON gc_dids

downy=0.05	; value to go down on y axis for youts

device_fac=1.5
w_out=1
adapte ,x_vu,y_vu,w_out,0
min_x  =viewarr(0) 
min_y  =viewarr(2) 
xrng   =viewarr(1)-min_x 
yrng   =MAX(y_vu)-min_y 

; Get total of fitted peak without that marked background "b"
sum_fit=0 



FOR j=1,g_npeaks DO BEGIN
    pk_int=0.0
    ind=(j-1)*3
    iback=0
    ; Look FOR "b" on a parameter
    FOR ipmt=0,2 DO BEGIN
	IF STRPOS(g_step(ind+ipmt),'b') ge 0 THEN iback=1
    ENDFOR
    IF iback eq 0 THEN BEGIN
	get_param, g_parameters, j, p1, p2, p3
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then sum_fit=sum_fit+(p2*p3*0.420448*!pi)
    if g_fct_type(j-1) eq 'Lorentz' then sum_fit=sum_fit+(p2*p3*0.5*!pi)
    ENDIF
ENDFOR



get_bckg, g_npeaks, g_parameters, bbb, sss
ilast=g_npeaks*3-1
dataIntegral=TOTAL(y_dats*poids*g_largeur)	; calculate Data integral
fittedbackground=TOTAL((bbb+x_dats*sss)*poids*g_largeur)
dataIntegral=dataIntegral-fittedbackground

dispx=min_x+xrng+(xrng*0.02)/device_fac
dispy=min_y+yrng+(yrng*0.02)/device_fac
dispy=dispy-((yrng*(downy+0.01))/device_fac)
partxt='Fit Int. = '+STRTRIM(STRING(sum_fit,format='(g10.2)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char
partxt='Data Int.-bg.= '+STRTRIM(STRING(dataIntegral,format='(g10.2)'),2)
dispy=dispy-((yrng*downy)/device_fac)
XYOUTS,dispx,dispy,partxt,charsize=g_char
dispy=dispy-((yrng*downy)/device_fac)
partxt='Fitted Bg.    = '+STRTRIM(STRING(fittedbackground,format='(g10.2)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char

FOR j=1,g_npeaks DO BEGIN
    pk_int=0.0
    get_param, g_parameters, j, p1, p2, p3
    IF p2 gt 0 AND p3 gt 0 THEN BEGIN
	curpic=j
	CALL_PROCEDURE, g_fct_type(j-1),x_dats,p1,p2,p3,peaky
    ENDIF
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then pk_int=p2*p3*0.420448*!pi
    if g_fct_type(j-1) eq 'Lorentz' then pk_int=p2*p3*0.5*!pi
;
; Error on intensity as average of height and width
    ht_er=(g_error(ind+1)/p2)^2
    w_er=(g_error(ind+2)/p3)^2
    pk_error=pk_int*sqrt(ht_er+w_er)
    p_txt=STRING(p1,format='(g10.3)')
    i_txt=STRING(pk_int,format='(g10.3)')
    w_txt=STRING(p3,format='(g10.3)')
    e_p_txt=STRING(ABS(g_error(ind))  ,format='(g10.3)')
    e_i_txt=STRING(ABS(pk_error),format='(g10.3)')
    e_w_txt=STRING(ABS(g_error(ind+2)),format='(g10.3)')
    str=' --- Error'
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'Peak '+STRTRIM(STRING(j),2)+str,charsize=1.0
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'P'+p_txt+' '+e_p_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'I'+i_txt+' '+e_i_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'W'+w_txt+' '+e_w_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    percy=pk_int*100.0/dataIntegral
    percy_txt=STRTRIM(STRING(percy,format='(f5.1)'),2)+'%'
    delta_i=ABS(g_error(ind+1))
    delta_ie=2*SQRT(dataIntegral)
    ind=(j-1)*3
    ; Look FOR "b" on a parameter
    FOR ipmt=0,2 DO IF STRPOS(g_step(ind+ipmt),'b') ge 0 THEN $
	delta_ie=delta_ie+ABS(g_error(ilast+1))+ABS(g_error(ilast+2))
    delta=(delta_i*dataIntegral+p2*delta_ie)/(dataIntegral*dataIntegral)
    delta_txt=STRTRIM(STRING(ABS(delta),format='(g10.3)'),2)
    txt='Pct '+STRTRIM(STRING(j),2)+' '+percy_txt+'      '+delta_txt
    XYOUTS,dispx,dispy,txt,charsize=g_char
ENDFOR
    ; Add flat AND sloping bg
    bg_txt=STRTRIM(STRING(ABS(g_parameters(ilast+1))),2)
    sl_txt=STRTRIM(STRING(ABS(g_parameters(ilast+2))),2)
    e_bg_txt=STRTRIM(STRING(ABS(g_error(ilast+1)),format='(g10.3)'),2)
    e_sl_txt=STRTRIM(STRING(ABS(g_error(ilast+2)),format='(g10.3)'),2)
    dispy=dispy-((yrng*(downy+0.01))/device_fac)
    XYOUTS,dispx,dispy,'background',charsize=1.0
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'flat  '+bg_txt+' '+e_bg_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'slope '+sl_txt+' '+e_sl_txt,charsize=g_char
    dispy=dispy-((yrng*(downy+0.01))/device_fac)
    XYOUTS,dispx,dispy,'P: Pos. I: Int. W: hwhm',charsize=g_char
return
END

;===============================================================================
FUNCTION gk_fit	,workspace					; ==============
;===============================================================================
;

@lamp.cbk
COMMON gc_save
COMMON gc_wid
COMMON gc_data

nwt_out=STRTRIM(STRING(nw_out),2)
par_txt(nw_out,*)=''

FOR ind_p=0,g_npeaks-1 DO BEGIN
    peak_num=STRTRIM(STRING(ind_p+1))
    i3=ind_p*3-1
    par_txt(nw_out,i3+1)="Gaussian "+peak_num+" position = "
    par_txt(nw_out,i3+2)="Gaussian "+peak_num+" Height   = "
    par_txt(nw_out,i3+3)="Gaussian "+peak_num+" Width    = "
ENDFOR

    jj=i3+6
    par_txt(nw_out,jj)  ="Spectrum number                = "

par_txt(nw_out,i3+4)="Flat background                = "
par_txt(nw_out,i3+5)="Sloping background             = "
read_par_vals
iii=execute("p"+nwt_out+"=g_parameters")
WIDGET_CONTROL, bad_id=i, gw_cut_slider, Get_Value=no_coupe
iii=execute("p"+nwt_out+"(jj)=no_coupe")

if strpos(x_tit(nw_out),'(Fitted)') lt 0 then x_tit(nw_out)=x_tit(nw_out)+' (Fitted)'

RETURN, w_out
END

;===============================================================================
PRO read_par_vals						; ==============
;===============================================================================
; Get parameters value from fields
;

COMMON gc_wid
COMMON gc_data
COMMON gc_cp
COMMON gc_flags

flag=" "
idx=(g_pk_nb-1)*3	;.......Read visible parameters for peak

FOR j=0,2 DO BEGIN
IF g_ctrl_panel THEN BEGIN
    CASE j OF
	0 : BEGIN & wid1=cp_pos(g_pk_nb-1) & END
	1 : BEGIN & wid1=cp_hgt(g_pk_nb-1) & END
	2 : BEGIN & wid1=cp_wid(g_pk_nb-1) & END
    ENDCASE
    ENDIF ELSE BEGIN
    CASE j OF
	0 : BEGIN & wid1=gw_pos_text & wid2=gw_pos_pop & END
	1 : BEGIN & wid1=gw_int_text & wid2=gw_int_pop & END
	2 : BEGIN & wid1=gw_wdt_text & wid2=gw_wdt_pop & END
    ENDCASE
    ENDELSE
    WIDGET_CONTROL, bad_id=i, wid1, Get_Value=parval
    g_parameters(idx+j)=float(parval(0))

 IF NOT(g_ctrl_panel) THEN BEGIN
    flag=''
    WIDGET_CONTROL, bad_id=i, wid2(1), Get_Value=str
    IF STRPOS(str, 'Un') GE 0 THEN flag=flag+'f'

    IF g_bg_but EQ 1 THEN flag=flag+'b'

    WIDGET_CONTROL, bad_id=i, wid2(3), Get_Value=str
    IF STRLEN(str) GT 15 THEN flag=flag+STRMID(str, 16, 1)
    g_step(idx+j)=flag
 ENDIF
ENDFOR

ilast=g_npeaks*3-1
WIDGET_CONTROL, bad_id=i, gw_fbg_text, Get_Value=parval
g_parameters(ilast+1)=float(parval(0))
flag=''
WIDGET_CONTROL, bad_id=i, gw_fbg_pop(0), Get_Value=str
IF STRPOS(str, 'fx') GE 0 THEN flag=flag+'f'
g_step(ilast+1)=flag

WIDGET_CONTROL, bad_id=i, gw_sbg_text, Get_Value=parval
g_parameters(ilast+2)= float(parval(0))

flag=''
WIDGET_CONTROL, bad_id=i, gw_sbg_pop(0), Get_Value=str
IF STRPOS(str, 'fx') GE 0 THEN flag=flag+'f'
g_step(ilast+2)=flag
END

;===============================================================================
PRO write_par_vals_2, wid, g_step, idx, j		; ======================
;===============================================================================
; Update interface parameters
; wid

str=''
fixed=0

WIDGET_CONTROL, bad_id=i, wid(1), Get_Value=str
IF STRPOS(g_step(idx+j), 'f') GE 0 THEN BEGIN
    fixed=1
    IF STRPOS(str, 'Un') LT 0 THEN str='Un'+str
ENDIF ELSE IF STRPOS(str, 'Un') GE 0 THEN str=STRMID(str, 2, STRLEN(str))
WIDGET_CONTROL, bad_id=i, wid(1), Set_Value=str

; ??? anciennement fix it as a parameter
;WIDGET_CONTROL, bad_id=i, wid(2), Get_Value=str
;IF STRPOS(g_step(idx+j), 'b') GE 0 THEN BEGIN
;    fixed=1
;    IF STRPOS(str, 'Un') LT 0 THEN str='Un'+str
;ENDIF ELSE IF STRPOS(str, 'Un') GE 0 THEN str=STRMID(str, 2, STRLEN(str))
;WIDGET_CONTROL, bad_id=i, wid(2), Set_Value=str

FOR k=0, strlen(g_step(idx+j)) do BEGIN
    IF (STRMID(g_step(idx+j),k, 1) NE 'f') AND (STRMID(g_step(idx+j),k, 1) NE 'b') THEN BEGIN
	IF  FIX(STRMID(g_step(idx+j),k, 1)) GE 48 AND $
	    FIX(STRMID(g_step(idx+j),k, 1)) LE 57 THEN BEGIN
	        fixed=1
		WIDGET_CONTROL, bad_id=i, wid(2), Set_Value=STRMID(g_step(idx+j),k, 1)
	ENDIF
    ENDIF
ENDFOR

WIDGET_CONTROL, bad_id=i, wid(0), Get_Value=str
IF fixed eq 1 THEN BEGIN
    if STRPOS(str, ' fx ') LT 0 then str=STRMID(str, 0,  STRPOS(str, '    '))+' fx '
ENDIF ELSE BEGIN
    p=STRPOS(str, ' fx ')
    if p GE 0 then str=STRMID(str, 0,  p)+'    '
ENDELSE
WIDGET_CONTROL, bad_id=i, wid(0), Set_Value=str
RETURN
END

;===============================================================================
PRO set_gfit_param, w, p, Fct_Type=ft				; ==============
;===============================================================================
;
COMMON gc_flags
COMMON gc_data
COMMON gc_wid
COMMON gc_save

g_resid		=   1e12	    ; residu is big
WIDGET_CONTROL, bad_id=i, gw_get_but, Set_UValue=[1, 2, w]
gfit_Event,{WIDGET_BUTTON, ID:gw_get_but, TOP:gw_gkfit_base, $
	    HANDLER:0L, SELECT:1}
WIDGET_CONTROL, bad_id=i, gw_get_but, Set_UValue=[1, 2, 0]

g_npeaks=N_ELEMENTS(p)/3
g_ncycles=1
FOR i=0, N_ELEMENTS(p)-1 DO g_parameters(i)=p(i)
IF KEYWORD_SET(ft)    THEN $
    FOR i=0, N_ELEMENTS(ft)-1 DO g_fct_type(i)=ft(i)

write_par_vals
read_par_vals
plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type

RETURN
END

;===============================================================================
PRO write_par_vals, No_Update=no_update			; ======================
;===============================================================================
; Display errors values in widget labels

COMMON gc_wid
COMMON gc_data
COMMON gc_cp
COMMON gc_flags

;........Writes parameters to visible window
nvarf =0	; nb de variables fixees avant le pic en question
idx=(g_pk_nb-1)*3
;
fixed=0
FOR j=0,2 DO BEGIN
    parval=STRTRIM(STRING(g_parameters(idx+j)),2)
    IF g_ctrl_panel THEN BEGIN
    CASE j OF
	0 : BEGIN & wid1=cp_pos(g_pk_nb-1) & END
	1 : BEGIN & wid1=cp_hgt(g_pk_nb-1) & END
	2 : BEGIN & wid1=cp_wid(g_pk_nb-1) & END
    ENDCASE
    ENDIF ELSE BEGIN
    CASE j OF
	0 : BEGIN & wid1=gw_pos_text & wid2=gw_pos_pop & END
	1 : BEGIN & wid1=gw_int_text & wid2=gw_int_pop & END
	2 : BEGIN & wid1=gw_wdt_text & wid2=gw_wdt_pop & END
    ENDCASE
    ENDELSE
    WIDGET_CONTROL, bad_id=i, wid1, Set_Value=parval
    IF NOT(g_ctrl_panel) THEN if not(KEYWORD_SET(No_Update)) THEN write_par_vals_2,wid2, g_step, idx, j
IF (STRPOS(g_step(idx+j), 'b') GE 0) THEN fixed=1
ENDFOR
IF fixed EQ 1 THEN g_bg_but=1 else g_bg_but=0
WIDGET_CONTROL, bad_id=i, gw_bgfixed, Set_Button=g_bg_but
IF g_ctrl_panel THEN WIDGET_CONTROL, bad_id=i, cp_bck(g_pk_nb-1), Set_Button=g_bg_but
ilast=g_npeaks*3-1

parval=STRTRIM(STRING(g_parameters(ilast+1)),2)

WIDGET_CONTROL, bad_id=i, gw_fbg_text, Set_Value=parval
IF g_ctrl_panel THEN WIDGET_CONTROL, bad_id=i, cp_sb, Set_Value=parval
IF not(KEYWORD_SET(No_Update)) THEN write_par_vals_2,gw_fbg_pop, g_step, ilast, 1

parval=STRTRIM(STRING(g_parameters(ilast+2)),2)
WIDGET_CONTROL, bad_id=i, gw_sbg_text, Set_Value=parval
IF g_ctrl_panel THEN WIDGET_CONTROL, bad_id=i, cp_fb, Set_Value=parval

IF NOT(g_ctrl_panel) THEN if not(KEYWORD_SET(No_Update)) THEN write_par_vals_2,gw_sbg_pop, g_step, ilast, 1

; Errors Display:
;****************
; ???
;index=where(g_error ne 0,combien)
;IF combien ne 0 THEN g_error=g_error(where(g_error ne 0))
    FOR i=0,3*(g_pk_nb-1)-1 DO BEGIN 
	IF STRPOS(g_step(i),'f') ge 0 THEN nvarf=nvarf+1
    ENDFOR    
    inderr=3*(g_pk_nb-1)-nvarf

    IF STRPOS(g_step(idx),'f') ge 0 THEN err='* FIXED'$
    ELSE BEGIN
	err=STRTRIM(STRING(g_error(inderr)),2)
	inderr=inderr + 1
    ENDELSE  
    WIDGET_CONTROL, bad_id=i, gw_pos_pop(3), Set_Value='Err: '+err

    IF STRPOS(g_step(idx+1),'f') ge 0 THEN err='* FIXED'$
    ELSE BEGIN
	err=STRTRIM(STRING(g_error(inderr)),2)
	inderr=inderr + 1
    ENDELSE  
    WIDGET_CONTROL, bad_id=i, gw_int_pop(3), Set_Value='Err: '+err
    
    IF STRPOS(g_step(idx+2),'f') ge 0 THEN err='* FIXED'$
    ELSE BEGIN
	err=STRTRIM(STRING(g_error(inderr)),2)
	inderr=inderr + 1
    ENDELSE
    WIDGET_CONTROL, bad_id=i, gw_wdt_pop(3), Set_Value='Err: '+err
 
    IF STRPOS(g_step(g_nb_pk_max*3+1),'f') ge 0 THEN BEGIN
	err='* FIXED' 
	ajust=0
    ENDIF ELSE BEGIN
	err=STRTRIM(STRING(g_error(N_ELEMENTS(g_error)-1)),2)
	ajust=1
    ENDELSE
    WIDGET_CONTROL, bad_id=i, gw_sbg_pop(3), Set_Value='Err: '+err
  
    IF STRPOS(g_step(g_nb_pk_max*3),'f') ge 0 THEN err='* FIXED'$
    ELSE err=STRTRIM(STRING(g_error(N_ELEMENTS(g_error)-1-ajust)),2) 
    WIDGET_CONTROL, bad_id=i, gw_fbg_pop(3), Set_Value='Err: '+err
END

;===============================================================================
PRO error_msg, error_number, str1				; ==============
;===============================================================================
; Display error message identified by error_number
;

COMMON gc_wid

CASE error_number OF
    -2: str='Use left mouse-button to define peak #'+STRTRIM(STRING(str1), 2)
    -1: str=str1
    0 : str=''
    1 : str='Invalid view zone.     *** ignored ***'
    2 : str='3D Workspace. Reduced to 2D by summing !'
    3 : str='Woops ...no data !'
    4 : BEGIN
	    print,STRING(7b)
	    str='No better fit found ** Click on peak-slider (above) to reset **'
	END
    5 : str='You can'+STRING(39b)+'t do that. Please fill in a value'
    6 : str='WARNING : defined zone is smaller than fitting zone'
    7 : str='Bum fit : negative height or width !'
    8 : str='Not enough data points in genfit function !'
    9 : BEGIN
    	    print,STRING(7b)
    	    str='Sorry, Not yet implemented !'
	END
    10 : BEGIN
    	    print,STRING(7b)
    	    str='Just a display of position error'
	END
    ELSE:str='!error '+error_number
ENDCASE
WIDGET_CONTROL, bad_id=i, gw_err_lab, Set_Value=str
END

;===============================================================================
PRO traitview_event	,event					; ==============
;===============================================================================
;

COMMON gc_fit_view	& COMMON gc_data	& COMMON gc_fit_excl

WIDGET_CONTROL, bad_id=i, Event.Id, GET_UVALUE=Ev
CASE Ev(0) OF
    'load' : BEGIN ; charge les valeurs des zones texte dans viewarr et
		   ; initialise la zone courante avec ces valeurs
		WIDGET_CONTROL, bad_id=i, x_min, Get_Value=xmin
		WIDGET_CONTROL, bad_id=i, x_max, Get_Value=xmax
		WIDGET_CONTROL, bad_id=i, y_min, Get_Value=ymin
		WIDGET_CONTROL, bad_id=i, y_max, Get_Value=ymax
		viewarr(0+sauv+4*no_zone)=xmin & viewarr(0)=xmin
		viewarr(1+sauv+4*no_zone)=xmax & viewarr(1)=xmax
		viewarr(2+sauv+4*no_zone)=ymin & viewarr(2)=ymin
		viewarr(3+sauv+4*no_zone)=ymax & viewarr(3)=ymax
	     END

    'recall' :	BEGIN ; initialise la zone courante avec les valeurs
		;  de la zone specifiee
		viewarr(0)=viewarr(0+sauv+4*no_zone)
		viewarr(1)=viewarr(1+sauv+4*no_zone)
		viewarr(2)=viewarr(2+sauv+4*no_zone)
		viewarr(3)=viewarr(3+sauv+4*no_zone)
		WIDGET_CONTROL, bad_id=i, x_min, Set_Value=STRTRIM(STRING(viewarr(0)),2)
		WIDGET_CONTROL, bad_id=i, x_max, Set_Value=STRTRIM(STRING(viewarr(1)),2)
		WIDGET_CONTROL, bad_id=i, y_min, Set_Value=STRTRIM(STRING(viewarr(2)),2)
		WIDGET_CONTROL, bad_id=i, y_max, Set_Value=STRTRIM(STRING(viewarr(3)),2)
		END

    'memzone' : BEGIN
		no_zone=Ev(1)
		END

    'done' :	BEGIN  ; on avertit l'utilisateur s'il existe des points de
		 ; la zone a fitter qui ne sont pas dans la zone a tracer :
		gk_warning,excl_param,viewarr
		WIDGET_CONTROL, bad_id=i, event.top, Map=0
		END

    'reset' :	BEGIN
		viewarr(0)=viewarr(0+sauv)
		viewarr(1)=viewarr(1+sauv)
		viewarr(2)=viewarr(2+sauv)
		viewarr(3)=viewarr(3+sauv)
		WIDGET_CONTROL, bad_id=i, x_min, Set_Value=STRTRIM(STRING(viewarr(0)),2)
		WIDGET_CONTROL, bad_id=i, x_max, Set_Value=STRTRIM(STRING(viewarr(1)),2)
		WIDGET_CONTROL, bad_id=i, y_min, Set_Value=STRTRIM(STRING(viewarr(2)),2)
		WIDGET_CONTROL, bad_id=i, y_max, Set_Value=STRTRIM(STRING(viewarr(3)),2)
		END

    ELSE : BEGIN
	   ; Do nothing !
	   END
ENDCASE
END

;===============================================================================
PRO traitexcl_event	,event					; ==============
;===============================================================================
;

@lamp.cbk

COMMON gc_save
COMMON gc_fit_excl
COMMON gc_data
COMMON gc_flags
COMMON gc_wid

g_resid=1.0e12
WIDGET_CONTROL, bad_id=i, Event.Id, GET_UVALUE=Ev
CASE Ev(0) OF 
    'coucou':	BEGIN
		    intv_no=float(Ev(1))
		END

    'done' :  	BEGIN
		    WIDGET_CONTROL, bad_id=i,event.top,Map=0
		END

    'reset':	BEGIN
		    ;initialisation par defaut de excl_param :
		    excl_param(0)=MIN(x_ni,MAX=ma)
		    excl_param(1)=ma
		    WIDGET_CONTROL, bad_id=i,excl_widge(0),$
			Set_Value=STRTRIM(STRING(excl_param(0)),2)
		    WIDGET_CONTROL, bad_id=i,excl_widge(1),$
			Set_Value=STRTRIM(STRING(excl_param(1)),2)
		    FOR i=1,max_nb_int-1 do BEGIN
			excl_param(2*i)  =excl_param(0)-1
			excl_param(2*i+1)=excl_param(0)-1
			WIDGET_CONTROL, bad_id=iii,excl_widge(2*i)  ,Set_Value='***'
			WIDGET_CONTROL, bad_id=iii,excl_widge(2*i+1),Set_Value='***'
		    ENDFOR
		    ; selection du bouton no 1 :
		    WIDGET_CONTROL, bad_id=i,gw_excl_but,set_button=1
		    intv_no=1
		    adapte ,x_to_plot,w_to_plot,w_out,1
		END
ENDCASE
END

;===============================================================================
pro creer_excl,		id					; ==============
;===============================================================================
; Create widget window to define determinant fitting zone

@lamp.cbk
COMMON gc_fit_excl
COMMON gc_wid

if XREGISTERED('gfit') le 0 then RETURN
if gw_gkfit_base       eq 0 then RETURN
;--------------------------------- gw_excl_base --------------------------------
gw_excl_base= WIDGET_BASE (Group_Leader=gw_gkfit_base ,Resource_Name='lamp', $
				/Column, Title= 'Fit zone', Map=0) 

conseil_lab=WIDGET_LABEL( gw_excl_base ,Font=ft_b_bigger,$
				Value='To choose your fit zone:')
conseil_lab=WIDGET_LABEL( gw_excl_base, Font=ft_b_bigger,$
				Value='Drag the right mouse-button')

; ..... all_but_base :
all_but_bse=WIDGET_BASE  (gw_excl_base, /Row)
reset_but  =WIDGET_BUTTON(all_but_bse, Font=ft_b_bigger ,$
				UValue=['reset'], Value='Reset')
empty_lab  =WIDGET_LABEL (all_but_bse, Font=ft_propor, Value='     ')
int_but_bse=WIDGET_BASE  (all_but_bse ,/Row ,/Exclusive)

FOR i=1,max_nb_int DO BEGIN
    coucou =WIDGET_BUTTON(int_but_bse ,font=ft_b_bigger, $
			    Value=STRTRIM(STRING(i),2)+'     ',$
			    UValue=['coucou',STRTRIM(STRING(i),2)])
    IF i EQ 1 THEN gw_excl_but=coucou
ENDFOR
intv_no=1
WIDGET_CONTROL, bad_id=i, coucou, /Set_Button 


ok_but	      =WIDGET_BUTTON(all_but_bse,Font=ft_b_bigger,$
				UValue=['done'],Value='Done')
; ..... END of all_but_base

int_defin  =WIDGET_BASE (gw_excl_base ,/Column)
lab_min_max=WIDGET_BASE (int_defin ,/Row)
intv_nb	   =WIDGET_LABEL(lab_min_max, Font=ft_propor, Value='          ')

FOR i=1,max_nb_int DO BEGIN
    lab_min_max=WIDGET_BASE(int_defin,/Row)
    intv_nb=WIDGET_LABEL(lab_min_max, Font=ft_propor, Value='interval #'+$
			   STRTRIM(STRING(i),2)+':   xmin=')
    xmin =WIDGET_LABEL(lab_min_max,Font=ft_propor,UValue=['xmin',STRTRIM(STRING(i),2)])
    excl_widge(2*(i-1))=xmin	; to be able to write in this label
    WIDGET_CONTROL, bad_id=iii,xmin,Set_Value=STRTRIM(STRING(excl_param(2*i-2)),2)
    xmax_lab=WIDGET_LABEL(lab_min_max ,Font=ft_propor,Value='     xmax=')
    xmax  =WIDGET_LABEL ( lab_min_max ,Font=ft_propor,UValue =['xmax',STRTRIM(STRING(i),2)])
    excl_widge(2*i-1)=xmax
    WIDGET_CONTROL, bad_id=iii, xmax, Set_Value=STRTRIM(STRING(excl_param(2*i-1)),2)
ENDFOR

bid=sys_dep('DYNLAB', gw_excl_base, 1)
WIDGET_CONTROL, bad_id=i, gw_excl_base, /Realize
XMANAGER, 'traitexcl', gw_excl_base, /Just_Reg, Cleanup='creer_excl'
END

;-------------------------------- END of gw_excl_base --------------------------

;===============================================================================
PRO creer_view,		id					; ============== 
;===============================================================================
;

@lamp.cbk
COMMON gc_fit_view	& COMMON gc_data	& COMMON gc_wid

if XREGISTERED('gfit') le 0 then RETURN
if gw_gkfit_base       eq 0 then RETURN
;----------------------------- gw_view_base --------------------------------------
gw_view_base=WIDGET_BASE(Group_Leader=gw_gkfit_base ,Resource_Name='lampdon' ,$
			 /Column, Title='View', Map=0)
invit_lab=WIDGET_LABEL	(gw_view_base , Font=ft_b_bigger ,$
			 Value='Select plot range :')
qwer_BASE=WIDGET_BASE 	( gw_view_base ,/row ) 
load_but =WIDGET_BUTTON	(qwer_base ,UValue=['load'] ,$
				Font=ft_b_bigger, Value=' Load ')
zone_base=WIDGET_BASE	(qwer_BASE ,/Row ,/Exclusive )

nbzone=3			    ; as defined in gfit
FOR i=1,nbzone DO BEGIN
    m=WIDGET_BUTTON(zone_base ,UValue=['memzone',STRTRIM(STRING(i),2)] ,$
				Font=ft_b_bigger, Value=STRTRIM(STRING(i),2))
    IF (i eq 1) THEN WIDGET_CONTROL, bad_id=iii, m, /Set_Button
ENDFOR

recall_but =WIDGET_BUTTON(qwer_base, UValue=['recall'] ,$
				Font=ft_b_bigger, value='Recall')
x_base	   =WIDGET_BASE  ( gw_view_base, /Row )
x_lab	   =WIDGET_LABEL ( x_base, Font=ft_b_bigger, Value='Xrange  :')
x_min	   =WIDGET_TEXT  ( x_base, /Editable, Font=ft_propor, $
				UValue=['x_min'] , Xsize=9 , Value='') 
x_max	   =WIDGET_TEXT  ( x_base, /Editable, Font=ft_propor, $
				UValue=['x_max'] , XSize=9, Value='') 
y_base	   =WIDGET_BASE  ( gw_view_base ,/Row )
y_lab	   =WIDGET_LABEL ( y_base, Font=ft_propor, Value='Yrange  :')
y_min	   =WIDGET_TEXT  ( y_base, /Editable ,Font=ft_propor, $
				UValue=['y_min'], Xsize=9, Value='')
y_max	   =WIDGET_TEXT  ( y_base, /Editable,Font=ft_propor, $
				UValue=['y_max'], Xsize=9, Value='')
  
  
small_base =WIDGET_BASE  ( gw_view_base ,/Row )

reset_but  =WIDGET_BUTTON(small_base, UValue=['reset'],$
				Font=ft_b_bigger, Value=' Reset ')
vide	   =WIDGET_LABEL (small_base , Font=ft_propor, Value='                           ')
done_but   =WIDGET_BUTTON(small_base , UValue=['done'] ,$
				Font=ft_b_bigger, Value=' Done ')
bid=sys_dep('DYNLAB', gw_view_base, 1)
WIDGET_CONTROL, bad_id=i, gw_view_base, /Realize
XMANAGER , 'traitview' , gw_view_base ,/Just_Reg, Cleanup='creer_view'
;------------------------------ END of gw_view_base ----------------------------
END

;===============================================================================
PRO gfit, Just=just, Group=group, Tripx=tripx, tx_param		; ==============
;===============================================================================
;

@lamp.cbk
COMMON gc_save
COMMON gc_fit_view
COMMON gc_wid
COMMON gc_data
COMMON gc_flags
COMMON gc_fit_excl
COMMON gc_cp
COMMON gc_width_factor
COMMON gc_dids

;Factors for using measured widths for peaks
;
gw_fac=2.0*sqrt(2.)
lw_fac=0.5

IF N_ELEMENTS(tx_param) EQ 0 THEN g_tx_par=[''] ELSE g_tx_par=tx_param
IF KEYWORD_SET(tripx) THEN g_tripx=1 ELSE g_tripx=0
IF KEYWORD_SET(just) THEN g_ctrl_panel=1 ELSE g_ctrl_panel=0
IF (!D.flags and 65536) eq 0  THEN print,'set_plot,"X" before using rdfilter' else  $
IF (XREGISTERED('gfit') le 0) THEN BEGIN
    cp_nb	=0
    cp_bck	=0 	
    cp_pos	=0  
    cp_hgt	=0
    cp_wid	=0 
    cp_pf	=0
    cp_hf	=0 
    cp_wf	=0
    cp_fb	=0
    cp_sb	=0
    cp_fbf	=0 
    cp_sbf	=0 
    
  g_old_plot_wid=!D.window
  P_MUS,'mus_harp'				; PLAY a tune
  g_fct_name	='Gauss' ; Default is Gauss
  g_old_pk_nb	=1	 ; old peak number
  g_afitisdone	=0	 ; No fit was done
  g_pk_nb	=1	 ; number of peak processed
  g_char	=0.8	 ;
  g_print_nb	=0	 ;
  g_show_subfct	=1	 ; if this flag is set, subfunctions are plotted
  bb1		=0	 ;l'une des bornes d'un intervalle a exclure (sert a la saisie)
  bb2		=0	 ;idem bb1 
  g_nb_pk_max	=6	 ;<----change peaks maximum number 
  max_nb_int	=3	 ;<----change excluded zone maximum number
  sauv		=4	 ;deplacement (dans viewarr) donnant la zone a afficher initiale
  nbzone	=3	 ;stored zones number
  no_zone	=1	 ;initializing zone number
  g_bg_but	=0	 ;fixed as background button is unset by default
  viewarr	=FLTARR(8+nbzone*4)	 ;dim zone to view array
  excl_param	=FLTARR(2*max_nb_int)	 ;bornes des intervalles exclus
  excl_widge	=LONARR(2*max_nb_int)	 ;widget IDs des fenetres d'affichage des bornes 
  g_parameters	=FLTARR(3*g_nb_pk_max+3) ;parametres position,height,width + flat,slope
  g_step	=STRARR(3*g_nb_pk_max+2) ;extensions des champs pos,height,width,flat,slope
  g_error	=FLTARR(3*g_nb_pk_max+2) ;erreurs sur les parametres correspondants de g_parameters
  g_fct_type	=STRARR(g_nb_pk_max)
  gw_pos_pop	=LONARR(10)		 ;widget ID of pos parameter menu
  gw_int_pop	=LONARR(10)		 ;widget ID of int parameter menu
  gw_wdt_pop	=LONARR(10)		 ;widget ID of wdt parameter menu
  gw_fbg_pop	=LONARR(10)		 ;widget ID of fbg parameter menu
  gw_sbg_pop	=LONARR(10)		 ;widget ID of sbg parameter menu
  sw_ni		=[0]
  g_npeaks	=1
  g_ncycles	=2
  peaky		=0.0
  g_resid	=1.0e12
  bose		=LONARR(g_nb_pk_max)
  mimirange	=[0,0]
  mimion	=0
  ximion	=0

  g_fct_type(*)	=g_fct_name
  nw_ni=0 & nw_out=1
  IF g_tripx THEN nw_ni=23 ELSE BEGIN
      if lamp_b1 ne 0 then p_did_getw_cur, nw_ni, wstr	; get current w number
      if nw_ni EQ 0 THEN nw_ni=1	; if not defined THEN w=1
      if nw_ni GT 20 THEN nw_ni=1
      nw_out	=nw_ni+1
  ENDELSE
  IF nw_out GT 20 THEN nw_out=20

IF N_ELEMENTS(Group) EQ 0 THEN GROUP=lamp_b1
junk		= { CW_PDMENU_S, flags:0, name:'' }

; the whole lamp size depending modifications is here
sl_size =16
if lamp_siz gt 900 then BEGIN
    xsiz=800 & ysiz=440
ENDIF ELSE BEGIN
    xsiz=700 & ysiz=280
ENDELSE
if lamp_siz lt 800 then BEGIN	; adapt to lamp size
    xsiz=550 & ysiz=250		; adapt plotting window size
    sl_size=15
ENDIF
txt_hlp=  '(LEFT press=position  release=width)....(RIGHT= Define Fitting Area)'

gw_gkfit_base=WIDGET_BASE(GROUP_LEADER=Group, /Row, $
				Title='Lamp GKfit Version 8th Aug 02 (gjk)',resource_name='lamp')
MAIN_BIS     =WIDGET_BASE  (gw_gkfit_base, /Column, Title='main_col_base')
; -------------------------  GET_WRITE_BASE  ------------------------------------
GET_WRITE_BASE=WIDGET_BASE  (MAIN_BIS, /Row, Frame=2,resource_name='don')
gw_get_but  =WIDGET_BUTTON(GET_WRITE_BASE, Font=ft_b_bigger,$
				UValue=[1,2,0], Value='Get Ws #')
ws_in_b	    =WIDGET_BASE  (GET_WRITE_BASE ,/column)
IF g_tripx THEN i=23 ELSE i=20
ws_in_sld   =WIDGET_SLIDER(ws_in_b, XSIZE=xsiz*.36,$
				Maximum=i,Minimum=1,Font=ft_b_bigger,$
				UValue=[1,1,0], Value=nw_ni)
ws_in_r	    =WIDGET_BASE  (ws_in_b,/row)
gw_cut_slider= WIDGET_SLIDER(ws_in_r, /Drag, Minimum=1, XSize=100,$
				UValue=[1,3,0], /Suppress)
WIDGET_CONTROL, bad_id=i, gw_cut_slider, Sensitive=0
WIDGET_CONTROL, bad_id=i, ws_in_r      , Map=0
gw_cut_label=WIDGET_LABEL (ws_in_r,Font=ft_b_normal,Value=' ',xsize=100)
ws_in_b	    =WIDGET_BASE  (GET_WRITE_BASE ,/column)
ws_out_sld  =WIDGET_SLIDER(ws_in_b, XSize=xsiz*.36, Maximum=20, Minimum=1,$
				Title='Out Workspace #', Font=ft_b_bigger,$
				UValue=[1,4,0], Value=nw_out)
ws_write_but=WIDGET_BUTTON(GET_WRITE_BASE ,Font=ft_b_bigger ,$
				UVALUE=[1,5,0] ,VALUE='Write to Ws #')
;---------------------- END of GET_WRITE_BASE  -------------------------
; Threerows : base of the 3 rows under the get and write buttons.
THREEROWS=WIDGET_BASE     (MAIN_BIS, /Column, Title='row_base')
; ----------- END of ROW1_BASE ------ BEGIN of ROW2_BASE ---------------
IF g_ctrl_panel THEN gfit_ctrl_panel ELSE BEGIN
    ROW2_BASE=WIDGET_BASE     (THREEROWS ,/Row)
    set_show_base= WIDGET_BASE  (ROW2_BASE, /Column, /frame,resource_name='don')
    
;   peak_menu2=WIDGET_BASE     (set_show_base , Column=g_nb_pk_max)
    peak_men2 =WIDGET_BASE     (set_show_base ,/row)
    gw_type_but=LONARR(g_nb_pk_max)  
    gw_gau_but=LONARR(g_nb_pk_max)
    gw_lor_but=LONARR(g_nb_pk_max)
    gw_peak_but=LONARR(g_nb_pk_max*2)
    
    FOR i=1,g_nb_pk_max DO BEGIN
	peak_menu2      =WIDGET_BASE   (peak_men2 , /Column) & gw_peak_but(g_nb_pk_max+i-1)=peak_menu2
	gw_type_but(i-1)=WIDGET_BUTTON (peak_menu2, /Menu, Font=ft_propor,$
				    UValue=[4,i,1], Value='Gau')
	gw_gau_but(i-1)	=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,1],Value='Gauss'  , Font=ft_propor)
	gw_lor_but(i-1)	=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,2],Value='Lorentz', Font=ft_propor)
	peak_base	=WIDGET_BASE(peak_menu2, /Exclusive)
	gw_peak_but(i-1)=WIDGET_BUTTON(peak_base,/No_Release , Value=STRTRIM(STRING(i),2),$
				       UValue=[2,2,0], Font=ft_b_bigger) 
	; only first button remains sensitive as g_npeaks=1
	floo=floor(1/i)
	WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1), Sensitive=floo
	WIDGET_CONTROL, bad_id=iii, gw_type_but(i-1), Sensitive=floo
	WIDGET_CONTROL, bad_id=iii, gw_peak_but(g_nb_pk_max+i-1), map=floo
    ENDFOR
    
    WIDGET_CONTROL, bad_id=iii, gw_peak_but(0), Set_Button=1    ; First button is set (Default)
    
    ;.... END of set/show peak
    szsl=0 & str=''
    if sys_dep('VERSION') ge 4.0 then ii=execute('str=WIDGET_INFO(peak_menu2,/geometry) & szsl=str.xsize')
    if szsl le 0 then $
    gw_pk_slider=WIDGET_SLIDER(set_show_base, Maximum=g_nb_pk_max,      $
				    Minimum=1,/Suppress_Value, YSize=15,$
				    UVALUE=[2,1,0],Value=g_npeaks) else $
    gw_pk_slider=WIDGET_SLIDER(set_show_base, Maximum=g_nb_pk_max,      $
				    Minimum=1,/Suppress_Value, YSize=15,$
				    UVALUE=[2,1,0],Value=g_npeaks,XSize=szsl>150)
    
    peak_lab    =WIDGET_LABEL (set_show_base, Font= ft_b_bigger,$
				    VALUE='The slider sets the # of functions')
    
    ;.... fit , cycle # , peak # , spectrum #.....
    
    base	   =WIDGET_BASE   (ROW2_BASE ,/Column, Map=1,/Frame,resource_name='don')
    bloc_base  =WIDGET_BASE   (base , /row)		;.... gw_resid_lab .... 
    resid_lab  =WIDGET_LABEL  (bloc_base,Value ='Residual:', Font=ft_normal)
    gw_resid_lab= WIDGET_LABEL  (bloc_base,Value ='______________',UValue='resid_field',Font=ft_b_normal)
    gw_cycle_lab= WIDGET_LABEL  (base, Font=ft_b_normal, Value='  '+$
				     STRTRIM(STRING(g_ncycles),2)+' Cycles')
    
    cycles_sld =WIDGET_SLIDER (base, Maximum=75, Minimum=0, /Drag,$
				    Value=g_ncycles, xsize=xsiz/4.8, $
				    YSize=sl_size, /Suppress_Value, UValue=[2,3,0])
    
    fit_but	   =WIDGET_BUTTON (base ,Font=ft_biggest, $
				    UValue=[2,4,0], Value ='FIT IT')
    
    base3	   =WIDGET_BASE   (ROW2_BASE, /Column, /Frame,resource_name='don')
    base3_row1 =WIDGET_BASE	  (base3, /Row)
;   view_but= WIDGET_BUTTON   (base3_row1, Font=ft_biggest,$
;				    UValue=[2,6,0], Value=' View  ')
;   WIDGET_CONTROL, bad_id=iii, view_but, Sensitive=0
    excl_but =WIDGET_BUTTON   (base3_row1, Font=ft_biggest ,$
				    UValue=[2,5,0], Value='Fit zone')
    
    base3r   =WIDGET_BASE     (base3 ,/Row )
    show_bse =WIDGET_BASE     (base3r,/NonExclusive, /Row )
    show_but =WIDGET_BUTTON   (show_bse, Font=ft_b_normal, UValue=[2, 8,0],$
				    Value='Show subfuncts')
    WIDGET_CONTROL, bad_id=iii,show_but, /Set_Button 
    gw_bose  =WIDGET_BUTTON   (show_bse, Font=ft_b_normal, UValue=[2,10,0],$
				    Value='T(K):')
    gw_temp  =WIDGET_TEXT     (base3r, Font=ft_propor,xsize=4,ysize=1,/editable)
    
    base3_row2 =WIDGET_BASE	  (base3, /Row)
    print_but=WIDGET_BUTTON   (base3_row2,Font=ft_biggest,$
				    UValue=[3,1,0],Value=' Print ')
    help_but =WIDGET_BUTTON   (base3_row2,Font=ft_biggest,$
				    UValue=[3,2,0],Value=' Help ')
    gw_exit_but=WIDGET_BUTTON (base3_row2,Font=ft_biggest,$
				    UValue=[3,3,0], Value=' DONE ')
ENDELSE    
;------------------------------- BEGIN of ROW3_BASE -------------------
err_base     =WIDGET_BASE   (MAIN_BIS, /Frame,resource_name='don')
blog	     =WIDGET_BASE   (err_base,/row)
	      put_logo	    ,blog
gw_err_lab   =WIDGET_LABEL  (blog, Value=' ', Font=ft_b_normal,xsize=xsiz-100)

membis       =WIDGET_BASE   (MAIN_bis ,/row)
gwmimi       =WIDGET_BUTTON (widget_base(membis,/NonExclusive),Font=ft_smaller,UValue=[2,11,0],Value='Yr:')
gw_mimi      =WIDGET_TEXT   (membis, Font=ft_smaller,xsize=6,ysize=1,/editable,Value=' Max')
gxmimi       =WIDGET_BUTTON (widget_base(membis,/NonExclusive),Font=ft_smaller,UValue=[2,12,0],Value='Xr:')
gx_mim1      =WIDGET_TEXT   (membis, Font=ft_smaller,xsize=6,ysize=1,/editable,Value=' Min')
gx_mim2      =WIDGET_TEXT   (membis, Font=ft_smaller,xsize=6,ysize=1,/editable,Value=' Max')
bid          =WIDGET_LABEL  (membis, Value=' ',Font=ft_propor)
help_label   =WIDGET_LABEL  (membis ,Value=txt_hlp,Font=ft_b_normal)
;------------------------------- BEGIN of gw_plot_area --------------------
gw_plot_area =WIDGET_DRAW    (MAIN_BIS, /Button_Events, Frame=5,Retain=2,$
			     UValue=[2,7,0],Colors=-8,XSize=xsiz,YSize=ysiz)
;------------------------------- BOTTOM BASE ---------------------------
bottom_base =WIDGET_BASE  (MAIN_BIS , /Row,resource_name='don')
IF lamp_siz GE 900 THEN $
    label_blanc =WIDGET_LABEL (bottom_base ,Value=' ',Font=ft_smaller)

gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_pk_no     =WIDGET_LABEL (gw_base, Font=ft_b_normal, Frame=2, Value='Peak #1 param')
;gw_peak_no  =WIDGET_BUTTON(gw_base, Font=ft_b_normal, Value='Peak # ')
gw_base	     =WIDGET_BASE  (gw_base, /NonExclusive)
gw_bgfixed   =WIDGET_BUTTON(gw_base, UValue=[5, 0], Value='is background',Font=ft_b_normal)
;.... position ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_pos_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_pos_pop(0)=WIDGET_BUTTON(gw_base, /Menu, Font=ft_propor,$
				UValue=[5,1,0], Value='Position    ')
gw_pos_pop(3)=WIDGET_BUTTON(gw_pos_pop(0), UValue=[5,1,0], $
			    Value='Err :',  Font=ft_propor)
gw_pos_pop(1)=WIDGET_BUTTON(gw_pos_pop(0) , UValue=[5,1,1], $
			    Value='Fix this parameter', Font=ft_propor)
gw_pos_pop(2)=WIDGET_BUTTON(gw_pos_pop(0), UValue=[5,1,2], $
			    Value='Fixed as peak #',/Menu, Font=ft_propor)
FOR j=1,6 do $
gw_pos_pop(3+j)=WIDGET_BUTTON(gw_pos_pop(2), UValue=[5,1,2+j], $
			      Value=' '+STRTRIM(STRING(j), 2)+' ', Font=ft_propor)
gw	     =WIDGET_BUTTON(gw_pos_pop(2),  UValue=[5,1,9], Value='None', Font=ft_propor)

;.... integral ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_int_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_int_pop(0)=WIDGET_BUTTON(gw_base, /Menu, Font=ft_propor, $
			    Value='Height    ')
gw_int_pop(3)=WIDGET_BUTTON(gw_int_pop(0), UValue=[5,2,0], $
			    Value='Err :', Font=ft_propor)
gw_int_pop(1)=WIDGET_BUTTON(gw_int_pop(0) , UValue=[5,2,1], $
			    Value='Fix this parameter', Font=ft_propor)
gw_int_pop(2)=WIDGET_BUTTON(gw_int_pop(0), UValue=[5,2,2], $
			    Value='Fixed as peak #', /Menu, Font=ft_propor)
FOR j=1,6 do $
gw_int_pop(3+j)=WIDGET_BUTTON(gw_int_pop(2), UValue=[5,2,2+j], $
			    Value=' '+STRTRIM(STRING(j), 2)+' ', Font=ft_propor)
gw	     =WIDGET_BUTTON(gw_int_pop(2),  UValue=[5,2,9], $
			    Value='None', Font=ft_propor)

;.... width ....  
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_wdt_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_wdt_pop(0)=WIDGET_BUTTON(gw_base, /Menu, Font=ft_propor, $
			    Value='Width    ')
gw_wdt_pop(3)=WIDGET_BUTTON(gw_wdt_pop(0), UValue=[5,3,0], $
			    Value='Err :', Font=ft_propor)
gw_wdt_pop(1)=WIDGET_BUTTON(gw_wdt_pop(0) ,UValue=[5,3,1], $
			    Value='Fix this parameter', Font=ft_propor)
gw_wdt_pop(2)=WIDGET_BUTTON(gw_wdt_pop(0), UValue=[5,3,2], $
			    Value='Fixed as peak #', /Menu, Font=ft_propor)
FOR j=1,6 do $
gw_wdt_pop(3+j)=WIDGET_BUTTON(gw_wdt_pop(2), UValue=[5,3,2+j], $
			    Value=' '+STRTRIM(STRING(j), 2)+' ', Font=ft_propor)
gw	     = WIDGET_BUTTON(gw_wdt_pop(2),  UValue=[5,3,9], $
			    Value='None', Font=ft_propor)

; .... flat_bg ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_fbg_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_fbg_pop(0)=WIDGET_BUTTON (gw_base, /Menu, Font=ft_propor,Value='Flat Bg.    ')
gw_fbg_pop(3)=WIDGET_BUTTON(gw_fbg_pop(0), UValue=[5,4,0], $
			    Value='Err :', Font=ft_propor)
gw_fbg_pop(1)=WIDGET_BUTTON(gw_fbg_pop(0) ,UValue=[5,4,1], $
			    Value='Fix this parameter', Font=ft_propor)

;.... slope_bg ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_sbg_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_sbg_pop(0)=WIDGET_BUTTON (gw_base, /Menu, Font=ft_propor, $
			    Value='Slope Bg.    ')
gw_sbg_pop(3)=WIDGET_BUTTON(gw_sbg_pop(0), UValue=[5,5,0], $
			    Value='Err :',  Font=ft_propor)
gw_sbg_pop(1)=WIDGET_BUTTON(gw_sbg_pop(0), UValue=[5,5,1], $
			    Value='Fix this parameter', Font=ft_b_normal)

;--------------------------- END of BOTTOM BASE --------------------------
FOR j=1,g_nb_pk_max DO BEGIN	    ; Make unsensitive peak popup menu
    ; only first button remains sensitive as g_npeaks=1
    WIDGET_CONTROL, bad_id=iii, gw_pos_pop(j+3) ,Sensitive=floor(1/j) 
    WIDGET_CONTROL, bad_id=iii, gw_int_pop(j+3), Sensitive=floor(1/j) 
    WIDGET_CONTROL, bad_id=iii, gw_wdt_pop(j+3), Sensitive=floor(1/j) 
ENDFOR

; If active, those lines disable the fix as line ...
WIDGET_CONTROL, bad_id=i, gw_pos_pop(2), Sensitive=0
WIDGET_CONTROL, bad_id=i, gw_int_pop(2), Sensitive=0
WIDGET_CONTROL, bad_id=i, gw_wdt_pop(2), Sensitive=0

bid=sys_dep('DYNLAB', gw_gkfit_base, 1)
WIDGET_CONTROL, bad_id=i, gw_gkfit_base, /Realize & put_logo

; Get drawable window index
WIDGET_CONTROL, bad_id=i, gw_plot_area, GET_VALUE=g_plot_wid
wset,g_plot_wid

if lamp_b1 gt 0 then XMANAGER, 'gfit', gw_gkfit_base, /just_reg $
else g_char=0.4

creer_excl		; creation de gw_excl_base
creer_view		; creation de gw_view_base
; Simulate a get workspace button event
gfit_event,{WIDGET_BUTTON,ID:gw_get_but,TOP:gw_gkfit_base,HANDLER:0L,SELECT:1}
error_msg, -2, 1

if lamp_b1 le 0 then XMANAGER, 'gfit', gw_gkfit_base

ENDIF ELSE IF g_tripx THEN $
    gfit_event,{WIDGET_BUTTON,ID:gw_get_but,TOP:gw_gkfit_base,HANDLER:0L,SELECT:1}
IF g_ctrl_panel THEN gfit_ctrl_panel
;mmmap=0 ELSE mmmap=1
;WIDGET_CONTROL, bad_id=i, gw_gkfit_base, Map=mmmap
END
pro grate,w,dan,nb,dq,f,g,h

w=w*!pi/180.

lmin=0
lmax=39

tthmin=-2.5-dan
tthmax=2.5-dan

;dq=7e-5
nth=286.
dth=(tthmax-tthmin)/nth
g=fltarr(nth)
g=findgen(nth)*dth+tthmin

nl=300.
dl=(lmax-lmin)/nl
h=fltarr(nl)
h=findgen(nl)*dl+lmin

;nb=3.9e-6
;nb=0
qc=sqrt(16*!pi*nb)
lamc=4*!pi*sin(w)/qc
print,'critical lambda = ',lamc,'critical q = ',qc

mmax=8

f=fltarr(nth,nl)
for i=1,nth-1 do begin
  for j=1,nl-1 do begin
     f(i,j)=1
  endfor
endfor


print,nth,lmax-lmin+1


for m=-mmax,mmax do begin
   for l=0,nl-1 do begin
      
         
      if(w^2 + ((m*dq*l*dl+lmin)/!pi) gt 0) then begin
      
      
      tth1=-(w+sqrt(w^2+m*dq*(l*dl+lmin)/!pi))*180./!pi
      n1=fix(round((tth1-tthmin)/dth))
      if (n1 lt nth and n1 gt 0 )then begin
;         f(n1,l)=f(n1,l)+1
          f(n1,l)=-1
      endif


;      refraction before diffraction
;      if (cos(w)/(1-(l*dl+lmin)^2*nb/(2*!pi)) lt 1) then begin
;        neww=acos(cos(w)/(1-(l*dl+lmin)^2*nb/(2*!pi)))
;        tth2=-(neww-sqrt(neww^2+m*dq*(l*dl+lmin)/!pi))*180./!pi
;        if(m eq 0)then tth2=tth2+(w-neww)*(-180./!pi)
;        n2=fix(round((tth2-tthmin)/dth)) 
;        if(n2 lt nth and n2 gt 0)then begin
;          f(n2,l)=f(n2,l)+1
;           print,n2,m,l*dl+lmin,tth2,neww*180/!pi
;        endif
;      endif 

;      diffraction before refraction

       tth2=-(w-sqrt(w^2+m*dq*(l*dl+lmin)/!pi))
       ttt=(w+tth2)

       if (cos(ttt)/(1-(l*dl+lmin)^2*nb/(2*!pi)) lt 1) then begin
          newth=acos(cos(ttt)/(1-(l*dl+lmin)^2*nb/(2*!pi)))*ttt/abs(ttt)
          tth2=(newth-w)*180/!pi

        n2=fix(round((tth2-tthmin)/dth)) 
        if(n2 lt nth and n2 gt 0)then begin
;           f(n2,l)=f(n2,l)+1
            f(n2,l)=-1
;           print,n2,m,l*dl+lmin,tth2
        endif
       endif else begin
;         print,'whoops',l,m,(w*180/!pi),t(ttt*180/!pi)
       endelse

      endif    
   endfor
endfor
f(fix(-tthmin/dth),*)=-1


end

;+
; NAME:
; GREAT
;
;-
; DO NOT REMOVE THIS COMMENT: END HEADER
; CODE MODIFICATIONS MADE BELOW THIS COMMENT WILL BE LOST.

; CODE MODIFICATIONS MADE ABOVE THIS COMMENT WILL BE LOST.
; DO NOT REMOVE THIS COMMENT: BEGIN PDMENU9

PRO PDMENU9_Event, Event
  CASE Event.Value OF 
  'Tetris': BEGIN
    PRINT, 'Tetris'
    tetris
    END
  'TWO.Four': BEGIN
    PRINT, 'Event for TWO.Four'
    END
  'TWO.Five': BEGIN
    PRINT, 'Event for TWO.Five'
    END
  'TWO.Six': BEGIN
    PRINT, 'Event for TWO.Six'
    END
  'Sinus': BEGIN
    PRINT, 'sin(x)'
    a=findgen(1000)/100.
    b=sin(a)
    plot,a,b
    END
  ENDCASE
END

; DO NOT REMOVE THIS COMMENT: END PDMENU9
; CODE MODIFICATIONS MADE BELOW THIS COMMENT WILL BE LOST.

; CODE MODIFICATIONS MADE ABOVE THIS COMMENT WILL BE LOST.
; DO NOT REMOVE THIS COMMENT: BEGIN MAIN13

PRO MAIN13_Event, Event
  WIDGET_CONTROL,Event.Id,GET_UVALUE=Ev
  CASE Ev OF 
 'DRAW5': BEGIN
      Print, 'Event for DRAW5'
      END
  ; Event for PDMENU9
  'PDMENU9': PDMENU9_Event, Event
  ENDCASE
END

; DO NOT REMOVE THIS COMMENT: END MAIN13
; CODE MODIFICATIONS MADE BELOW THIS COMMENT WILL BE LOST.

PRO great, GROUP=Group
  IF N_ELEMENTS(Group) EQ 0 THEN GROUP=0
  junk   = { CW_PDMENU_S, flags:0, name:'' }
  MAIN13 = WIDGET_BASE(GROUP_LEADER=Group, $
      ROW=1, $
      MAP=1, $
      TITLE='Function Plotter', $
      UVALUE='MAIN13')
  BASE2 = WIDGET_BASE(MAIN13, $
      COLUMN=1, $
      MAP=1, $
      UVALUE='BASE2')
  LABEL8 = WIDGET_LABEL( BASE2, $
      UVALUE='LABEL8', $
      VALUE='Choose your function to be plotted')
  DRAW5 = WIDGET_DRAW( BASE2, $
      RETAIN=2, $
      UVALUE='DRAW5', $
      XSIZE=400, $
      YSIZE=200)
  MenuDesc737 = [ $
      { CW_PDMENU_S,       0, 'Tetris' }, $ ;        0
      { CW_PDMENU_S,       1, 'TWO' }, $ ;        1
        { CW_PDMENU_S,       0, 'Four' }, $ ;        2
        { CW_PDMENU_S,       0, 'Five' }, $ ;        3
        { CW_PDMENU_S,       2, 'Six' }, $ ;        4
      { CW_PDMENU_S,       2, 'Sinus' } $  ;      5
  ]
  PDMENU9 = CW_PDMENU( BASE2, MenuDesc737, /RETURN_FULL_NAME, $
      UVALUE='PDMENU9')
  WIDGET_CONTROL, MAIN13, /REALIZE
  ; Get drawable window index
  COMMON DRAW5_Comm, DRAW5_Id
  WIDGET_CONTROL, DRAW5, GET_VALUE=DRAW5_Id
  XMANAGER, 'MAIN13', MAIN13
END
;*************************************************************************************************
;*               	         	    Main                                                 *
;*					  Procedure	                                         *
;*						                                                 *
;*************************************************************************************************

pro gres

;-------------------------------------------------
; Define All Global variables via common statement
;-------------------------------------------------
common initialvals,minres,maxres,r1,r2,q1,q2,base
common graph,m,c,info,k,lamda,r,graph,grp,draw,draw2
common vars,d,dis,w,phi,x,phil,bd,bw,bdis,global_flag,slit_chopper_dist,chopper_width
common qs,qmin,qmax,numblocks,currentblock,minq,maxq,sres,sample_angle,qrangeb,wid,perover,widmax,$
banner,slit_lock,qflag,rr1,rr2,ll1,ll2,s2v,s3v,sample_lenght,foot_print,slit_sample_dist,angres,sub,submenu,$
restart_flag,save_string,dr,disr,wr,slit,chopper_to_sample
common slitstuff,slit_separation
common error,errbase,errsnum


;----------------------------------------------------------
;Hitting the NewQ Button In the Data Window brings you here
;----------------------------------------------------------
newpass:


;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;Variables (Global and in main program only)
;
;d[low limit,high limit]      :Stores the limits of the Distance between the choppers (m) 
;dis[low limit,high limit]    :Stores the limits of the Chopper to sample Distance (m)
;w[low limit,high limit]      :Stores the limits of the Angular Velocity of the Chopper (rad/s)
;lamda[low limit,high limit]  :Stores the limits of the Wavelenght of the beam (amstrongs)
;phi[low limit,high limit]    :Stores the limits of the Chopper Phase Angle (Degrees)
;phil(x)                      :Stores the chopper angle the (x-1)th block (Degrees)
;r                            :Stores the radius of the chopper (m)
;perover                      :Stores the percentage of overlap of the blocks (decimal)
;maxres[low limit,high limit] :Stores the limits of the time resolution for the maximum point
;minres[low limit,high limit] :Stores the limits of the time resolution for the minimum point
;slit_separation              :Stores the value of the slit separation (m)
;slit_chopper_dist            :Stores the value of the distance from s2 to the chopper (m)
;chopper_width                :Stores the value of the effective sample lenght for chopper (m)
;sample_lenght                :Stores the value of the sample lenght (m)
;slit_sample_dist             :Stores the distance from s3 to the sample (m)
;bd, bdis, bw                 :Holds Default values for d,dis,w 
;sres(x,y)                    :sres hold the current value of the time resolution sliders
;      			      :		x=0 indexs the min slider, x=1 indexs the max slider
;			      :         y references the current block. 0=block1,1=block2,2=block3
;sample_angle(x)              :Stores the sample angle for the x'th block. (0=1st block etc) (degrees)
;global_flag                  :Is set to one when newq is pressed in data window otherwise=0
;errbase()                    :Stores the widget references for the message windows
;errsnum                      :Used as an index for errbase, cyles from 0 to 100
;                             :It increments by one everytime a message window appears
;slit_lock                    :Contains the status of the slit lock button, 0=off, 1=on
;qflag                        :Is set to 1 in intial setup window if quit is pressed
;s2v(x), s3v(x)               :Stores the slit opening distance of s2, s3 respect.
;                             :x stores the block refernce, x=0 is 1st block and so on
;graph()                      :Stores widget references for the illumination graph window
;                             :graph(3)=1 when window is open, else it is zero
;angres(x)                    :Stores the angular resolution for block x+1. x=0,1,2.
;submenu()                    :Stores widget references to the pop menu in the inital setup window
;			      :submenu(0)=1 when it is open, otherwise = 0
;restart_flag                 :Contains 1 if the perover variable has changed
;save_string                  :Contains the name of the save file
;                             :On saving the block number is concatenated with it and '.dat'
;k                            :stores the value of h/mass of neutron. In units of 1e10.
;numblocks                    :Stores the number of blocks, can take values of 1,2,3
;currentblock                 :Stores the current block, takes values of 0,1,2
;wid                          :Stores the widget references for the inital setup window
;qrangeb                      :Stores Maximum wavelenght/Minimum Wavelenght
;minq(x)                      :Stores the minimum q value for block (x+1), x=0,1,2. (amstrongs)^-1
;maxq(x)                      :Stores the maximum q value for block (x+1), x=0,1,2. (amstrongs)^-1
;widmax                       :Stores how many widgets are in intial setup window
;qmin, qmax                   :Stores q minimum and q maximum of current block
;val                          :many uses depends on context. All purpose variable. Not GLOBAL.
;info(),draw,draw2            :stores widget references, to data window, gfxs win1, gfxs win2
;gbase,frbase,pbase,dbase     :Stores base references
;r1,r2,q1,q2                  :tempory values. depends on context. *
;m                            :Contains the gradient of the time resolution graph, for the current block
;c                            :Contains the intercept of the time resolution grpah, for the current block
;foot_print                   :Holds the 'foot print' of the illumination of the slit (m)
;rr1,rr2,ll1,ll2              :Contains the coordinates for the illumination of the sample (m)
;x                            :Holds the value of delta x for the current block    
;banner                       :Holds a status which tells the program which buttons to deactivate
;grp                          :Hold the base reference to the illumination window
;sub                          :Contains the reference to the parameters window
;sres(min/max,block)          :Contains the slider resolutions. min=0,max=1, block=0,1,2 
;dr, wr, disr                 :Contains the saved values for d, w, and dis respectivly  
;slit(2)                      :Contains the minimum, maximum openings for the slits (in meters)
;chopper_to_sample            :Contains the chopper to sample lenght
;                   
;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

dr=fltarr(3)
wr=fltarr(3)
disr=fltarr(3)
d=[0.,0.]
dis=[0.,0.]
w=[80.,200.]
lamda=[0.,0.]
phi=[0.,0.]
r=0.
perover=0.
maxres=[0.,0.]
minres=[0.,0.]
sres=fltarr(2,3)
sample_angle=fltarr(3)
global_flag=0
slit_lock=0
qflag=0
s2v=fltarr(3)
s3v=fltarr(3)
graph=intarr(10)
graph=long(graph)
angres=fltarr(3)
submenu=intarr(30)
submenu=long(submenu)
restart_flag=0
save_string='block'
minq=fltarr(3)
maxq=fltarr(3)
wid=intarr(60)
info=intarr(50)
phil=fltarr(3)
chopper_to_sample=0.

;*************************************************
;Slit openings (m)
;*************************************************
slit=[0.,0.01]


;-------------------------------------------------
;default chopper angles
;-------------------------------------------------
phil(0)=.144688
;phil(1)=1.47802
;phil(2)=0

;-------------------------------------------------
;allows upto 100 messages at once
;-------------------------------------------------
errbase=intarr(100)
errbase=long(errbase)

;-------------------------------------------------
;currently no messages on screen
;-------------------------------------------------
errsnum=0

;-------------------------------------------------
;Constants
;-------------------------------------------------
k=3956.0346035 
;-------------------------------------------------
;Read in data from the file ranges.dat
;-------------------------------------------------
openr,1,'ranges.dat'
readf,1,chopper_to_sample,d,dis,w,lamda,phi,r,perover,minres,maxres,slit_separation,slit_chopper_dist,chopper_width,$
sample_lenght,slit_sample_dist,slit
close,1
bd=d & bdis=dis & bw=w

qrangeb=lamda(1)/lamda(0)
;*************************************************************************************************
;*                                      Initial Setup Window
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************

;-------------------------------------------------
;Default Data for intial setup window
;-------------------------------------------------
numblocks=2
currentblock=0
for u=0,2 do begin
  s2v(u)=.005
  s3v(u)=.005
endfor
minq(0)=0.005
maxq(0)=.05
minq(1)=.0455
maxq(1)=.455
sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi


;-------------------------------------------------
;Sets up the interface with default values
;See documentation for more information
;-------------------------------------------------
base=widget_base(title='Initial Setup, Press Next When Finished',uvalue='base')
wid(0)=widget_label(base,value='q min :',xoffset=0,yoffset=5)
wid(1)=widget_text(base,value=string(.005),xoffset=100,yoffset=0,uvalue=41,/editable)
wid(2)=widget_label(base,value='q max :',xoffset=380,yoffset=5)
wid(3)=widget_text(base,value=string(.5),xoffset=480,yoffset=0,uvalue=43,/editable)

wid(4)=widget_button(base,value="",xoffset=0,yoffset=50,xsize=870,ysize=7)

wid(5)=widget_label(base,value='- For Current Block -',xoffset=0,yoffset=70)

wid(6)=widget_label(base,value='q min :',xoffset=0,yoffset=105)
wid(7)=widget_label(base,value=string(.005),xoffset=100,yoffset=100,uvalue=47)
wid(8)=widget_label(base,value='q max :',xoffset=380,yoffset=100)
wid(9)=widget_label(base,value=string(.05),xoffset=480,yoffset=105,uvalue=49)

wid(10)=widget_label(base,value='l min :',xoffset=380,yoffset=150)
wid(11)=widget_label(base,value=string(lamda(0)),xoffset=480,yoffset=150)
wid(12)=widget_label(base,value='l max :',xoffset=0,yoffset=150)
wid(13)=widget_label(base,value=string(lamda(1)),xoffset=100,yoffset=150)

wid(14)=widget_button(base,value='ACTIVE ',xoffset=775,yoffset=72,uvalue=54)
wid(15)=widget_button(base,value='Block 2',xoffset=775,yoffset=102,uvalue=55)
wid(16)=widget_button(base,value='Block 3',xoffset=775,yoffset=132,uvalue=56)

wid(17)=widget_button(base,value='Quit',xoffset=792,yoffset=10,uvalue=57)

wid(18)=widget_label(base,value='Current Block is :',xoffset=380,yoffset=70)
wid(19)=widget_label(base,value=string(currentblock+1),xoffset=530,yoffset=71,uvalue=59)

wid(20)=widget_button(base,value="",xoffset=0,yoffset=180,xsize=870,ysize=5)

wid(21)=widget_label(base,value='S2 :',xoffset=0,yoffset=206)


wid(22)=widget_slider(base,minimum=slit(0)*1e7,maximum=slit(1)*1e7,value=slit(0)*1e7,uvalue=62,$
xoffset=70,yoffset=210,xsize=200,/suppress_value,/drag)
;bobchange
;wid(22)=widget_slider(base,minimum=slit(0)*1,maximum=slit(1)*1,value=slit(0)*1,uvalue=62,$
;xoffset=70,yoffset=210,xsize=200,/suppress_value,/drag)



wid(23)=widget_text(base,value=string(slit(0)),uvalue=63,xoffset=300,yoffset=200,/editable)

wid(24)=widget_label(base,value='S3 :',xoffset=0,yoffset=266)
wid(25)=widget_slider(base,minimum=slit(0)*1e7,maximum=slit(1)*1e7,value=slit(0)*1e7,uvalue=65,$
xoffset=70,yoffset=270,xsize=200,/suppress_value,/drag)
;bobchange
;wid(25)=widget_slider(base,minimum=slit(0)*1,maximum=slit(1)*1,value=slit(0)*1,uvalue=65,$
;xoffset=70,yoffset=270,xsize=200,/suppress_value,/drag)

wid(26)=widget_text(base,value=string(slit(0)),uvalue=66,xoffset=300,yoffset=260,/editable)

wid(35)=widget_button(base,value="OFF",uvalue=75,xoffset=140,yoffset=235,$
xsize=60,ysize=30)

wid(27)=widget_label(base,value='Sample Angle  :',xoffset=570,yoffset=205)
wid(28)=widget_label(base,value=string(.683934),uvalue=68,xoffset=710,yoffset=205)

wid(29)=widget_label(base,value='Sample Length :',xoffset=570,yoffset=245)
wid(30)=widget_label(base,value=string(sample_lenght),xoffset=710,yoffset=245)

wid(31)=widget_label(base,value='Slit-Sam Dist :',xoffset=570,yoffset=285)
wid(32)=widget_label(base,value=string(slit_sample_dist),xoffset=710,yoffset=285)

wid(33)=widget_label(base,value='Slit Separtn  :',xoffset=570,yoffset=325)
wid(34)=widget_label(base,value=string(slit_separation),xoffset=710,yoffset=325)

wid(36)=widget_button(base,value='Next',uvalue=76,xoffset=305,yoffset=305,xsize=250,ysize=45)

wid(37)=widget_label(base,value='Illumination :',xoffset=0,yoffset=295)
wid(38)=widget_label(base,value='Over',xoffset=210,yoffset=295,uvalue=78,xsize=70)

wid(39)=widget_button(base,value="",xoffset=0,yoffset=360,xsize=870,ysize=7)

wid(40)=widget_label(base,value='Block 1',xoffset=80,yoffset=380)
wid(41)=widget_label(base,value='Block 2',xoffset=380,yoffset=380)
wid(42)=widget_label(base,value='Block 3',xoffset=680,yoffset=380)

wid(43)=widget_label(base,value='Ang',xoffset=0,yoffset=420)
wid(44)=widget_label(base,value='Res',xoffset=0,yoffset=440)

wid(45)=widget_label(base,value='   0.119677',xoffset=35,yoffset=430,xsize=170)
wid(46)=widget_label(base,value='  0.0131257',xoffset=335,yoffset=430,xsize=170)
wid(47)=widget_label(base,value='Ready',xoffset=635,yoffset=430,xsize=170)
wid(48)=widget_button(base,value='Graph',xoffset=22,yoffset=323,uvalue=88)

wid(49)=widget_button(base,value='-',xoffset=50,yoffset=375,uvalue=89)
wid(50)=widget_button(base,value='-',xoffset=350,yoffset=375,uvalue=90)
wid(51)=widget_button(base,value='-',xoffset=650,yoffset=375,uvalue=91)

wid(52)=widget_label(base,value='Lock',xoffset=80,yoffset=238)

wid(53)=widget_label(base,value='F',xoffset=110,yoffset=317)
wid(54)=widget_label(base,value='%',xoffset=110,yoffset=336)
wid(55)=widget_label(base,value=string(0.),xoffset=120,yoffset=317,uvalue=95)
wid(56)=widget_label(base,value=string(0.),xoffset=120,yoffset=336,uvalue=96)

wid(57)=widget_button(base,value='>',xoffset=840,yoffset=395,uvalue=97)

widmax=57


;-------------------------------------------------
;to SEE the widgets one must call this
;-------------------------------------------------
widget_control,/realize,base

;-------------------------------------------------
;Make the separators inactive
;-------------------------------------------------
widget_control,wid(4),sensitive=0
widget_control,wid(20),sensitive=0
widget_control,wid(39),sensitive=0
widget_control,wid(16),sensitive=0

;-------------------------------------------------
;set footprint and illumination values
;-------------------------------------------------
;theone
gobob
;h=bob(.005,.005,sample_angle(currentblock),sample_lenght,slit_sample_dist)
update_ftper

;----------------------------------------------------------------------
;lets the interaction of mouse and user start and registers button hits
;it calls the proedure base_event in the case of an interaction
;----------------------------------------------------------------------
xmanager,'base',base


;-------------------------------------------------
;If the quit button is pressed exit program
;-------------------------------------------------
if qflag eq 1 then goto,pass





;*************************************************************************************************
;*                                         Data Window
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************

;-------------------------------------------------
;Allocate the 'bases' in memory for the widgets
;-------------------------------------------------
gbase=widget_base(title='Graphical Output')
grbase=widget_base(title='Graphival Output 2')
pbase=widget_base(title='Ranges',/column)
dbase=widget_base(title='Data Window')

;-------------------------------------------------
;Draw two gfxs widgets for the graphs
;-------------------------------------------------
draw=widget_draw(gbase,xsize=400,ysize=700,yoffset=0,xoffset=0,retain=2)
;draw2=widget_draw(grbase,xsize=400,ysize=350,yoffset=0,xoffset=0,retain=2)

;-------------------------------------------------
;Set default Values
;-------------------------------------------------
currentblock=0
sres(0,0)=0.01*1e7 & sres(1,0)=0.02*1e7
sres(0,1)=0.01*1e7 & sres(1,1)=0.05*1e7
sres(0,2)=0.01*1e7 & sres(1,2)=0.02*1e7
qmin=minq(currentblock)
qmax=maxq(currentblock)
;prelimanry guess as limits depend upon, w and d also. Works because limits dont change much!
;thetwo
golim
;val=lims(sres(0,currentblock)*1e-7,sres(1,currentblock)*1e-7,qmin,qmax)

;----------------------------------------
;Default slider values for w, d, and dis 
;----------------------------------------
disr(0)=6.75 & dr(0)=.06 & wr(0)=83.7758
disr(1)=6.75 & dr(1)=.0375 & wr(1)=83.7758
disr(2)=6.75 & dr(2)=.0375 & wr(2)=83.7758

;--------------------------------------------------------------
;Setup the widgets for the bases, see documentation for details
;--------------------------------------------------------------
info(0)=widget_label(pbase,value='TOF Range : '+string(dis(0))+'  '+string(dis(1)),/align_left)
info(1)=widget_label(pbase,value='d Range    : '+string(d(0))+'  '+string(d(1)),/align_left)
info(2)=widget_label(pbase,value='Rpms Range : '+string(w(1)*30/!pi)+'  '+string(w(0)*30/!pi),/align_left)
info(3)=widget_label(pbase,value='Chopper Ang: '+string(phil(0))+'  '+string(phil(0)),/align_left)
;-------------------------------------------------
;delta x update
;-------------------------------------------------
info(4)=widget_label(pbase,value='dtx/T      : '+string(0.)+'  '+string(0.),/align_left)

info(10)=widget_label(dbase,value='TOF Distance',xoffset=0,yoffset=0)
info(11)=widget_slider(dbase,minimum=dis(0)*1e7,maximum=dis(1)*1e7,uvalue=9,/drag,/suppress_value,$
xoffset=0,yoffset=30,xsize=257,value=disr(0)*1e7)
info(12)=widget_text(dbase,value=string(disr(0)),uvalue=10,xoffset=0,yoffset=50,/editable)

info(13)=widget_label(dbase,value='d',xoffset=0,yoffset=85)
info(14)=widget_slider(dbase,minimum=d(0)*1e7,maximum=d(1)*1e7,uvalue=11,/drag,/suppress_value,$
xoffset=0,yoffset=115,xsize=257,value=dr(0)*1e7)
info(15)=widget_text(dbase,value=string(dr(0)),uvalue=12,xoffset=0,yoffset=140,/editable)

info(16)=widget_label(dbase,value='Rpms',xoffset=0,yoffset=175)

info(17)=widget_slider(dbase,minimum=w(0)*1e7,maximum=w(1)*1e7,uvalue=13,/drag,/suppress_value,$
xoffset=0,yoffset=205,xsize=257,value=wr(0)*1e7)
info(18)=widget_text(dbase,value=string(wr(0)*30/!pi),uvalue=14,xoffset=0,yoffset=230,/editable)

info(19)=widget_label(dbase,value='Chopper Angle:'+string(.144688),xoffset=0,yoffset=275)
;-------------------------------------------------
;set delta x
;-------------------------------------------------
info(20)=widget_label(dbase,value='Transmission :',xoffset=0,yoffset=305)
info(45)=widget_label(dbase,value='    --------',xoffset=120,yoffset=305,xsize=250)
info(30)=widget_label(dbase,value='Sample Angle :'+string(sample_angle(currentblock)),yoffset=330,xoffset=0)

;resolution sliders
info(21)=widget_label(dbase,value='Minimum resolution',xoffset=320,yoffset=0)
info(22)=widget_slider(dbase,minimum=minres(0)*1e7,maximum=minres(1)*1e7,uvalue=15,/suppress_value,$
value=sres(0,currentblock),xoffset=320,yoffset=30,xsize=258)
info(23)=widget_text(dbase,value=string(sres(0,currentblock)*1e-7),/editable,xoffset=320,yoffset=55,uvalue=16)

info(24)=widget_label(dbase,value='Maximum resolution',xoffset=320,yoffset=130)
info(25)=widget_slider(dbase,minimum=maxres(0)*1e7,maximum=maxres(1)*1e7,uvalue=17,/suppress_value,$
value=sres(1,currentblock),xoffset=320,yoffset=160,xsize=258)
info(26)=widget_text(dbase,value=string(sres(1,currentblock)*1e-7),/editable,xoffset=320,yoffset=185,uvalue=18)

info(27)=widget_button(dbase,value='ACTIVE ',uvalue=19,xoffset=400,yoffset=230)
info(28)=widget_button(dbase,value='Block 2',uvalue=20,xoffset=400,yoffset=265)
info(29)=widget_button(dbase,value='Block 3',uvalue=21,xoffset=400,yoffset=300)
info(31)=widget_label(dbase,value=string(currentblock+1),xoffset=450,yoffset=310)

info(8)=widget_button(dbase,value='QUIT',uvalue=7,xoffset=510,yoffset=265)

info(38)=widget_button(dbase,value='NewQ',uvalue=26,xoffset=510,yoffset=230)

info(43)=widget_button(dbase,value="",xoffset=0,yoffset=355,xsize=600,ysize=5)

info(40)=widget_label(dbase,value='Angular Resolution Block 1 :'+string(angres(0)),yoffset=365,xoffset=0)
info(41)=widget_label(dbase,value='Angular Resolution Block 2 :'+string(angres(1)),yoffset=385,xoffset=0)
info(42)=widget_label(dbase,value='Angular Resolution Block 3 :'+string(angres(2)),yoffset=405,xoffset=0)

info(44)=widget_button(dbase,value='Save Blocks',yoffset=450,xoffset=0,uvalue=30,xsize=600)

;max=45 so use 46 next

;-------------------------------------------------
;show the widgets on screen
;-------------------------------------------------
widget_control,/realize,pbase
widget_control,/realize,gbase
widget_control,/realize,dbase
;widget_control,/realize,grbase

;-------------------------------------------------
;De-activate unwanted select block buttons
;-------------------------------------------------
if(numblocks lt 3) then begin
  widget_control,info(29),sensitive=0
endif
if(numblocks lt 2) then begin
 widget_control,info(29),sensitive=0
 widget_control,info(28),sensitive=0
endif

;-------------------------------------------------
;blank out separators
;-------------------------------------------------
widget_control,info(43),sensitive=1

;-------------------------------------------------
;draw plot in graphics window
;-------------------------------------------------
;drawplot

;--------------------------------------------------------
;lets roll baby, calls main_event upon a user interaction
;--------------------------------------------------------
xmanager,'main',dbase

;-------------------------------------------------
;Restart?
;-------------------------------------------------
if global_flag then goto,newpass

pass:
end

;*************************************************************************************************
;*               	         	    End Of                                               *
;*					  Main Program	                                         *
;*						                                                 *
;*************************************************************************************************






;*************************************************************************************************
;*					  Function Lims
;*
;*This function does. (a) Produces the new limits of d, dis and w. (b) Produces the chopper angle
;*(c) Produces delta x.
;*
;* Paramters :
;*
;* rmin  : minimum time resolution for particular block
;* rmax  : maximum time resolution for particular block
;* qminn : minimum q value for particular block
;* qmaxx : maximum q value for particular block
;*
;* Variables (local) :
;*
;* tflag             :Stores the status of the limits of d,w and phi
;*                   :tflag is 0 :OK
;*                   :tflag is 1 :d's out of range
;*                   :tflag is 2 :w's out of range
;*                   :tflag is 3 :phi's out of range
;* dismin            :contains tempory used to work out new range for dis
;* dismax            :contains tempory used to work out new range for dis
;* dmin              :contains tempory used to work out new range for d
;* dmax              :contains tempory used to work out new range for d
;* flag              :contains tempory infomation used to set tflag
;* o                 :a constant used for convenience in calulations
;* wmin              :contains tempory used to work out new range for w
;* wmax              :contains tempory used to work out new range for w
;* velchop           :Stores the velocity of the chopper 
;* velbeam           :Stores the velocity of the beam
;* b                 :a constant used for convenience in calulations
;* h                 :a constant used for convenience in calulations
;*
;*
;*************************************************************************************************


function lims,rmin,rmax,qminn,qmaxx
common graph
common vars
common qs

;-------------------------------------------------
;Set default ranges to start with
;-------------------------------------------------
d=bd & dis=bdis & w=bw

;-------------------------------------------------
;By default nothing out of range yet
;-------------------------------------------------
tflag=0

;-------------------------------------------------
;obtain gradient and intercept
;-------------------------------------------------
m=(rmax-rmin)/(qmaxx-qminn)
c=rmax-m*qmaxx

;-------------------------------------------------
;obtain new d and dis ranges
;-------------------------------------------------
flag=0
dismin=dis(0) & dismax=dis(1)
dmin=d(0) & dmax=d(1)
dmin=c*dis(0)
if(dmin lt d(0)) then dmin=d(0) & dismin=dmin/c
if(dmin gt d(1)) then flag=1
dmax=c*dis(1)
if(dmax gt d(1)) then dmax=d(1) & dismax=dmax/c
if(dmax lt d(0)) then flag=1
if flag then begin
  tflag=1
  goto, trigger
endif else begin
  d(0)=dmin & d(1)=dmax
  dis(0)=dismin & dis(1)=dismax
endelse


;-------------------------------------------------
;obtain new w
;-------------------------------------------------
flag=0
o=2*!pi*k/lamda(1)
dismin=dis(0) & dismax=dis(1)
wmin=w(0) & wmax=w(1)
wmin=o/dis(1)
if(wmin lt w(0)) then wmin=w(0) & dismax=o/wmin
if(wmin gt w(1)) then flag=1
wmax=o/dis(0)
if(wmax gt w(1)) then wmax=w(1) & dismin=o/wmax
if(wmax lt w(0)) then flag=1
if flag then begin
  tflag=2
  goto,trigger
endif else begin
  dis(0)=dismin & dis(1)=dismax
  w(0)=wmin & w(1)=wmax
  d(0)=c*dis(0) & d(1)=c*dis(1)
endelse

;-------------------------------------------------
;obtain new chopper angle
;-------------------------------------------------
phil(currentblock)=2*!pi*m/((1/qminn)-(1/qmaxx))
phil(currentblock)=phil(currentblock)/!pi*180 
if ((phil(currentblock) gt phi(1)) or (phil(currentblock) lt phi(0))) then begin
        tflag=3
	goto,trigger
endif


;-------------------------------------------------
;Calculate delta x's RANGE
;-------------------------------------------------
;velchop=w*r
;velbeam=k/lamda(1)
;b=atan(rotate(velchop,2)/velbeam)
;x=d*sin(b)+phil(currentblock)*!pi/180*r
;-----------------------------------------------------------
;the beam width part
;(nb make sure x here is consistent with the deltax function
;-----------------------------------------------------------
;h=bob(s3v(currentblock),s2v(currentblock),90,chopper_width,slit_chopper_dist)
;x=x+h

trigger:
return, tflag
end





;*************************************************************************************************
;*				     Function BOB
;*
;*This routine calculates the positions of illumination on a sample.
;*
;* Parameters  :
;*
;* s2          : Slit width (m)
;* s1          : Slit width (m)
;* th          : Sample angle (degrees)
;* sam         : sample lenght (m)
;* d2          : distance from slit to sample (m)
;*
;* Variables (local) :
;*
;* pi          : a contant containing Pi - here to make sure gives Exactly the same result
;*             : the fortran program
;* d1          : The distance between the slits (m)
;* amda        : Maximum wavelenght (1e10)
;* flag        : Contains 1 if there is neutron divergence otherwise 0
;* h           : Contains -1 if there is neutron divergence otherwise 0
;* 
;* (see bobs fortran program for details on this calulation and variables)
;*
;*
;* (Prgs note: slit references in the direction of the beam)
;*************************************************************************************************


function bob,s2,s1,th,sam,d2
common slitstuff,slit_separation
common qs


pi=3.1415926
d1=slit_separation
amda=30.
flag=0
th=th*pi/180 ; convert to radians
foot_print=sam*sin(th)


;-------------------------------------------------
;minimum s2 for under illimination
;-------------------------------------------------
s1min=((sam*sin(th)-s2)/((sam/2.)*cos(th)+d2))*d1-s2
;print,'Minimum mon slit for under illumination: ',s1min
div=.1*amda

if(s1 gt s2)then begin 
 fwhm=s1*180./(d1*pi)
endif else begin
 if(s2 ge s1)then begin
   fwhm=s2*180./(d1*pi)
 endif 
endelse
arange=2.*atan((s1+s2)/(2.*d1))
del=fwhm*pi/(th*180.)
arange=arange*180./pi
if(s1 ne s2)then begin
  x=d2-((d1*s2)/(s1-s2))
  w2=abs((s2*x)/(d2-x))
endif else begin
  w2=s1
  x=9999.
endelse
w1=s2+((d2*(s1+s2))/d1)
F=w2+(w1-w2)/2
if((arange/2.) gt div)then begin
  print,' Angular range limited by neutron divergence!'
  flag=1
endif

th1=atan((s1+s2)/(2.*d1))
if(s1 eq s2)then begin
 th2=0
endif else begin
  th2=atan(s2/(2.*(d2-x)))
endelse


;-------------------------------------------------
;Coordinates for the illumination of the slit
;-------------------------------------------------
rr1=(sam/2)+(w2/(2*cos(th)*(tan(th)+tan(th2))))
rr2=(sam/2)+(w1/(2*cos(th)*(tan(th)+tan(th1))))
ll1=(sam/2)-(w1/(2*cos(th)*(tan(th)-tan(th1))))
ll2=(sam/2)-(w2/(2*cos(th)*(tan(th)-tan(th2))))


if(flag eq 0) then begin
  ;half width at half maximum
  h=(rr1-ll2)+(ll2-ll1)/2+(rr2-rr1)/2
endif else begin
  h=-1
endelse

return,h
end




;*************************************************************************************************
;*				 function time_modification 
;*
;*This procedure calculates the modification to the time resolution entered by the user in the
;*'data window', window.
;*
;* Parameters :
;*
;* qq         : The q value in (amstrongs)^-1
;* ww         : The angular velocity of the choppers
;* disd       : The distance from the choppers to the detector
;*
;* Variables   :
;*
;* xx          : Contains the effect width of the choppers
;* tmp         : Variable used for ease in the calculations
;* tmp1        : Variable used for ease in the calculations
;* modification: Contains the modification to the time resolution
;*
;*************************************************************************************************


function time_modification,qq,ww,disd

common qs
common vars
common graph

;----------------------------------------------------------------------------------
;Calculates the full width at half maximum on the chopper, ie the effective delta x
;----------------------------------------------------------------------------------
xx=bob(s3v(currentblock),s2v(currentblock),90,chopper_width,slit_chopper_dist)

tmp=xx/ww/r

;print,xx,s2v(currentblock),s3v(currentblock),ww,r

tmp1=disd*4*!pi*sin(sample_angle(currentblock)*!pi/180)/qq/k

modification=tmp/tmp1

return, modification
end






;*************************************************************************************************
;*				  Function refresh 
;*
;*This procedure redraw the graphs, the range window the data window, basically everything.
;*This is required because changing any of the alterable parameters changes the effective 
;*resolution miniumum and maximum.
;*
;* Variables  : 
;*
;* sresb(2)   : Contains the modified time resolutions
;* err        : Contains the return of the function lims, 0 means no errors occured
;*
;*
;*
;*************************************************************************************************


function refresh
common vars
common qs
common graph
  
   ;calculate effective resolutions
   sresb=fltarr(2)
   
   sresb(0)=sres(0,currentblock)-time_modification(minq(currentblock),wr(currentblock),disr(currentblock))*1e7
   sresb(1)=sres(1,currentblock)-time_modification(maxq(currentblock),wr(currentblock),disr(currentblock))*1e7

   ;find new limits
   print,'before refresh',w
   err=lims(sresb(0)*1e-7,sresb(1)*1e-7,minq(currentblock),maxq(currentblock))
   ;if err gt 0 then print, 'No ranges exist'
   
   if err eq 0 then begin
     ;change slider limits
     widget_control,info(11),set_slider_min=dis(0)*1e7,set_slider_max=dis(1)*1e7
     widget_control,info(14),set_slider_min=d(0)*1e7,set_slider_max=d(1)*1e7
     widget_control,info(17),set_slider_min=w(0)*1e7,set_slider_max=w(1)*1e7
   endif

   ;redraw the paramters window
   redrawparams 

   ;redraw graphs
   drawplot

   ;redraw delta x
   ;widget_control,info(20),set_value='dx           :'+string(deltax(dr(currentblock),wr(currentblock),lamda(1),phil(currentblock)))
  
return,err
end







;*************************************************************************************************
;* 				Procedure main_event
;*
;*This proedure is called by xmanager when a user interaction has taken place. eq clicking a
;*button. 
;*
;*Variables (local):
;*
;* ev       :Contains the user value of the activated widget
;* val      :Contains the val of the widget itself that the user has activated
;* tmp1     :Tempory variable, use depends on context
;* err      :Tempory variable, use depends on context
;* a        :Tempory variable, use depends on context
;* sresb    :Contains the tempory modified time resolution
;*
;*(This is for the data window)  (Prgs note : delta x here)
;*************************************************************************************************


pro main_event,event
common graph
common qs
common vars
common slitstuff,slit_separation
err=0.
widget_control,event.id,get_uvalue=ev,get_value=val


;-------------------------------------------------
;pressed quit button
;-------------------------------------------------
if ev eq 7 then widget_control,/reset

;-------------------------------------------------
;newq button is pressed
;-------------------------------------------------
if ev eq 26 then begin
  widget_control,/reset
  global_flag=1
endif

;-------------------------------------------------
;slide sliders (dis,d,w)
;-------------------------------------------------
if(ev eq 9)or(ev eq 11)or(ev eq 13)or(ev eq 10)or(ev eq 12)or(ev eq 14) then begin
 if ev eq 9 then begin
 
   widget_control,info(12),set_value=string(val*1e-7)
   widget_control,info(14),set_value=c*val
   widget_control,info(15),set_value=string(c*val*1e-7)
   widget_control,info(17),set_value=2*!pi*k/val/lamda(1)*1e14
   widget_control,info(18),set_value=string(2*!pi*k/val/lamda(1)*1e14*1e-7*30/!pi)

   tmp1=val
   tmp2=c*val
   tmp3=2*!pi*k/val/lamda(1)*1e14

   err=refresh() 
 endif
  if ev eq 10 then begin
    val=long(val*1e7)
    widget_control,info(11),set_value=val(0)    
    widget_control,info(14),set_value=c*val(0)
    widget_control,info(15),set_value=string(c*val(0)*1e-7)
    widget_control,info(17),set_value=2*!pi*k/val(0)/lamda(1)*1e14
    widget_control,info(18),set_value=string(2*!pi*k/val(0)/lamda(1)*30/!pi*1e14*1e-7)
   
    tmp1=val(0)
    tmp2=c*val(0)
    tmp3=2*!pi*k/val(0)/lamda(1)*1e14

    ;redraw the window
    err=refresh()

  endif   
 if ev eq 11 then begin
   widget_control,info(15),set_value=string(val*1e-7)
   widget_control,info(11),set_value=val/c
   widget_control,info(12),set_value=string(val/c*1e-7)
   widget_control,info(17),set_value=2*!pi*k/(val/c)/lamda(1)*1e14
   widget_control,info(18),set_value=string(2*!pi*k/(val/c)/lamda(1)*1e14*1e-7*30/!pi)
   tmp1=val/c
   tmp2=val
   tmp3=2*!pi*k/(val/c)/lamda(1)*1e14

   ;redraw the window
   err=refresh()

 endif
 if ev eq 12 then begin
   val=long(val*1e7) 
   widget_control,info(14),set_value=val(0)
   widget_control,info(11),set_value=val(0)/c
   widget_control,info(12),set_value=string(val(0)/c*1e-7)
   widget_control,info(17),set_value=2*!pi*k/(val(0)/c)/lamda(1)*1e14
   widget_control,info(18),set_value=string(2*!pi*k/(val(0)/c)/lamda(1)*1e14*1e-7*30/!pi)
   tmp1=val(0)/c
   tmp2=val(0)
   tmp3=2*!pi*k/(val(0)/c)/lamda(1)*1e14

   ;redraw the window
   err=refresh()

 endif
 if ev eq 13 then begin
   widget_control,info(18),set_value=string(val*1e-7*30/!pi)
   widget_control,info(11),set_value=2*!pi*k/val/lamda(1)*1e14
   widget_control,info(12),set_value=string(2*!pi*k/val/lamda(1)*1e14*1e-7)
   widget_control,info(14),set_value=2*!pi*k/val/lamda(1)*1e14*c
   widget_control,info(15),set_value=string(2*!pi*k/val/lamda(1)*1e14*c*1e-7)
   tmp1=2*!pi*k/val/lamda(1)*1e14
   tmp2=2*!pi*k/val/lamda(1)*1e14*c
   tmp3=val

   ;redraw the window
   err=refresh()

 endif
 if ev eq 14 then begin
   val=long(val*1e7*!pi/30)
   widget_control,info(17),set_value=val(0)
   widget_control,info(11),set_value=2*!pi*k/val(0)/lamda(1)*1e14
   widget_control,info(12),set_value=string(2*!pi*k/val(0)/lamda(1)*1e14*1e-7)
   widget_control,info(14),set_value=2*!pi*k/val(0)/lamda(1)*1e14*c
   widget_control,info(15),set_value=string(2*!pi*k/val(0)/lamda(1)*1e14*c*1e-7)
   tmp1=2*!pi*k/val(0)/lamda(1)*1e14
   tmp2=2*!pi*k/val(0)/lamda(1)*1e14*c
   tmp3=val(0)

   ;redraw the window
   err=refresh()

 endif

   tmp1=tmp1*1e-7
   tmp2=tmp2*1e-7
   tmp3=tmp3*1e-7

   disr(currentblock)=tmp1
   dr(currentblock)=tmp2
   wr(currentblock)=tmp3
   
   ;-------------------------------------------------
   ;up date dx
   ;-------------------------------------------------
   ;widget_control,info(20),set_value='dx           :'+string(deltax(tmp2,tmp3,lamda(1),phil(currentblock)))
   ;*?*
   
endif




;-------------------------------------------------
;resolution sliders (maximum value)
;-------------------------------------------------
if(ev eq 15) then begin
 
  sres(0,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(23),set_value='Out Of Range'
    widget_control,info(26),set_value='Out Of Range'

    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0

  endif else begin
    widget_control,info(23),set_value=string(val*1e-7)
    widget_control,info(25),get_value=val1
    widget_control,info(26),set_value=string(val1*1e-7)

    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor

    ;drawplot
    redrawmain
    redrawparams
  endelse
endif


;-------------------------------------------------
;resolution text widget (maximum value)
;-------------------------------------------------
if(ev eq 16) then begin
  val=long(val*1e7)
  sres(0,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(23),set_value='Out Of Range'
    widget_control,info(26),set_value='Out Of Range'

    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0
 
  endif else begin
    widget_control,info(22),set_value=val(0)
    widget_control,info(25),get_value=val1
    widget_control,info(26),set_value=string(val1*1e-7)

    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor
    
    redrawparams
    ;drawplot
    redrawmain
  
  endelse
endif

;-------------------------------------------------
;resolution sliders (minimum value)
;-------------------------------------------------
if(ev eq 17) then begin
 
  sres(1,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(26),set_value='Out Of Range'
    widget_control,info(23),set_value='Out Of Range'

    ;block out unwanted
    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0

  endif else begin
    widget_control,info(26),set_value=string(val*1e-7)
    widget_control,info(22),get_value=val1
    widget_control,info(23),set_value=string(val1*1e-7)

    ;block out unwanted
    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor

    redrawparams
    ;drawplot
    redrawmain
    
  endelse
endif

;-------------------------------------------------
;resolution text widget (minimum value)
;-------------------------------------------------
if(ev eq 18) then begin
  val=long(val*1e7)
  sres(1,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(26),set_value='Out Of Range'
    widget_control,info(23),set_value='Out Of Range'
 
    ;block out unwanted
    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0

  endif else begin
    widget_control,info(25),set_value=val(0)
    widget_control,info(22),get_value=val1
    widget_control,info(23),set_value=string(val1*1e-7)

    ;block out unwanted
    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor

    redrawparams
    ;drawplot
    redrawmain
   
  endelse
endif

;-------------------------------------------------
;block button 1 pressed
;-------------------------------------------------
if(ev eq 19) then begin

  ;save
  widget_control,info(22),get_value=a
  sres(0,currentblock)=a
  widget_control,info(25),get_value=a
  sres(1,currentblock)=a
  ;widget_control,info(11),get_value=a

  ;restore three slider bars
  currentblock=0
  qmin=minq(0) & qmax=maxq(0)

  vall=refresh()
  
  widget_control,info(11),set_slider_max=dis(1)*1e7,set_slider_min=dis(0)*1e7,set_value=disr(currentblock)*1e7
  widget_control,info(12),set_value=string(disr(currentblock))
  widget_control,info(14),set_slider_max=d(1)*1e7,set_slider_min=d(0)*1e7,set_value=dr(currentblock)*1e7
  widget_control,info(15),set_value=string(dr(currentblock))
  widget_control,info(17),set_slider_max=w(1)*1e7,set_slider_min=w(0)*1e7,set_value=wr(currentblock)*1e7
  widget_control,info(18),set_value=string(wr(currentblock)*30/!pi)
 
  widget_control,info(22),set_value=sres(0,currentblock)
  widget_control,info(23),set_value=string(sres(0,currentblock)*1e-7)
  widget_control,info(25),set_value=sres(1,currentblock)
  widget_control,info(26),set_value=string(sres(1,currentblock)*1e-7)
 
  widget_control,info(30),set_value='Sample Angle :'+string(sample_angle(currentblock))
  widget_control,info(31),set_value=string(currentblock+1)

  if currentblock eq 0 then begin
    widget_control,info(27),set_value='ACTIVE'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 1 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='ACTIVE'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 2 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='ACTIVE'
  endif

endif

 
;-------------------------------------------------
;block button 2 pressed
;-------------------------------------------------
if(ev eq 20) then begin
  
  ;save
  widget_control,info(22),get_value=a
  sres(0,currentblock)=a
  widget_control,info(25),get_value=a
  sres(1,currentblock)=a
  ;widget_control,info(11),get_value=a

  ;restore three slider bars
  currentblock=1
  qmin=minq(1) & qmax=maxq(1)

  vall=refresh()
  
  widget_control,info(11),set_slider_max=dis(1)*1e7,set_slider_min=dis(0)*1e7,set_value=disr(currentblock)*1e7
  widget_control,info(12),set_value=string(disr(currentblock))
  widget_control,info(14),set_slider_max=d(1)*1e7,set_slider_min=d(0)*1e7,set_value=dr(currentblock)*1e7
  widget_control,info(15),set_value=string(dr(currentblock))
  widget_control,info(17),set_slider_max=w(1)*1e7,set_slider_min=w(0)*1e7,set_value=wr(currentblock)*1e7
  widget_control,info(18),set_value=string(wr(currentblock)*30/!pi)
 
  widget_control,info(22),set_value=sres(0,currentblock)
  widget_control,info(23),set_value=string(sres(0,currentblock)*1e-7)
  widget_control,info(25),set_value=sres(1,currentblock)
  widget_control,info(26),set_value=string(sres(1,currentblock)*1e-7)

  widget_control,info(30),set_value='Sample Angle :'+string(sample_angle(currentblock))
  widget_control,info(31),set_value=string(currentblock+1) 
 
  if currentblock eq 0 then begin
    widget_control,info(27),set_value='ACTIVE'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 1 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='ACTIVE'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 2 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='ACTIVE'
  endif

endif

;-------------------------------------------------
;Block button 3 pressed
;-------------------------------------------------
if(ev eq 21) then begin
  
  ;save
  widget_control,info(22),get_value=a
  sres(0,currentblock)=a
  widget_control,info(25),get_value=a
  sres(1,currentblock)=a
  widget_control,info(11),get_value=a
  
  currentblock=2
  qmin=minq(2) & qmax=maxq(2)

  vall=refresh()
  
  widget_control,info(11),set_slider_max=dis(1)*1e7,set_slider_min=dis(0)*1e7,set_value=disr(currentblock)*1e7
  widget_control,info(12),set_value=string(disr(currentblock))
  widget_control,info(14),set_slider_max=d(1)*1e7,set_slider_min=d(0)*1e7,set_value=dr(currentblock)*1e7
  widget_control,info(15),set_value=string(dr(currentblock))
  widget_control,info(17),set_slider_max=w(1)*1e7,set_slider_min=w(0)*1e7,set_value=wr(currentblock)*1e7
  widget_control,info(18),set_value=string(wr(currentblock)*30/!pi)
 
  widget_control,info(22),set_value=sres(0,currentblock)
  widget_control,info(23),set_value=string(sres(0,currentblock)*1e-7)
  widget_control,info(25),set_value=sres(1,currentblock)
  widget_control,info(26),set_value=string(sres(1,currentblock)*1e-7)

  widget_control,info(30),set_value='Sample Angle :'+string(sample_angle(currentblock))
  widget_control,info(31),set_value=string(currentblock+1)

  if currentblock eq 0 then begin
    widget_control,info(27),set_value='ACTIVE'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 1 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='ACTIVE'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 2 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='ACTIVE'
  endif

endif


;-------------------------------------------------
;save button pressed
;-------------------------------------------------
if ev eq 30 then begin
  tmp=save_string+'.dat'
  openw,1,tmp

  ;-------------------------------------------------
  ;Distance from chopper to sample
  ;-------------------------------------------------
  tmp1=chopper_to_sample

  ;output block 1 to file

  for u=1,numblocks do begin

  printf,1,'BLOCK'+strtrim(string(u),2)

  ;-------------------------------------------------
  ;angular, time, q resolutions
  ;-------------------------------------------------
  printf,1,';Time Resolution'
  printf,1,';start: '+strtrim(sres(0,u-1)*1e-7)+'   end:'+strtrim(sres(1,u-1)*1e-7)
  
  printf,1,';Angular Resolution'
  printf,1,';start: '+strtrim(angres(u-1))+'   end:'+strtrim(angres(u-1))

  a=sqrt((sres(0,u-1)*1e-7)^2+angres(u-1)^2)
  b=sqrt((sres(1,u-1)*1e-7)^2+angres(u-1)^2)

  printf,1,';Q resolution'
  printf,1,';start: '+strtrim(a)+'   end:'+strtrim(b)

;pig

  ;DET is distance from SAMPLE to DETECTOR
  printf,1,'DET',string(disr(u-1)+(dr(u-1)/2)-tmp1)
  
  ;CMT is chopper separation
  printf,1,'CHT',string(dr(u-1))

  ;CS1 is rpm of chopper 1
  printf,1,'CS1',string(wr(u-1)*30/!pi)

  ;CS2 is rpm of chopper 2
  printf,1,'CS2',string(wr(u-1)*30/!pi)

  ;PHA is phase angle between chopper plates in degrees
  printf,1,'PHA',string(phil(u-1))

  ;SAM is sample angle of sample in degrees
  printf,1,'SAM',string(sample_angle(u-1))

  endfor

  close,1

  errormessage,'Data has been Saved','As',tmp
endif

return
end 





;*******************************************************************************************************
;* 				      Procedure DrawPLot
;*
;*This procedure draws the resolution vs q graph, and the resolution vs q/qmin
;*
;*
;*Variables (local)   :
;*
;*  ng                :Number of points used to draw the graph
;*  Tt()              :Contains the time resolution data points
;*  q                 :Contains the corrosponding q values
;*  gval              :contains the gfxs window reference
;*  rangelow          :Contains the lowest q value (in block 1)
;*  rangehigh         :Contains the hightest q value (in block 3)
;*  low               :Contains the time resolution maximum, from slider value, for current block
;*  high              :Contains the time resolution minimum, from slider value, for current block
;*  mm                :Contains value of the gradient
;*  cc                :Contains value of the intercept
;*  thetax(2)         :Contains value of minimum q and maximum q for a given block
;*  thetay(2)         :Contains value of minimum ang. res. and maximum ang. res. for a given block
;*  y                 :Contains value of minimum and maximum time resolution
;*  u                 :Counter in the for loop
;*  bcurrentblk       :Stores the orginal currentblock
;*  thick             :Contains a number representing the thickness of the line (1=normal, 2=double etc)
;*  ceiling           :highest value for the y axis
;*
;*******************************************************************************************************

pro drawplot

common graph
common qs
!p.multi=[0,0,0,0,0]
plot,[0,0],xstyle=5,ystyle=5
ceiling=0.
;--------------------------------------------------
;Set graphics window for output for resolution vs q
;--------------------------------------------------
;widget_control,draw,get_value=gval
;wset,gval

ng=51 
Tt=fltarr(ng) 
q=fltarr(ng) 
rangelow=minq(0)
rangehigh=maxq(numblocks-1)
bcurrentblk=currentblock
!p.multi=[2,1,2,0,1]
thick=2

;-------------------------------------------------
;Draw Block 1 in selected graphics window
;-------------------------------------------------
;draw the time resolution

low=sres(0,0)*1e-7
high=sres(1,0)*1e-7

;-------------------------------------------------
;Modify resolutions
;-------------------------------------------------

;-------------------------------------------------
;Draw Block 1 in the selected graphics window
;-------------------------------------------------

currentblock=0

;low=low-time_modification(minq(0),wr(0),disr(0))
;high=high-time_modification(maxq(0),wr(0),disr(0))

q=minq(0)+(findgen(ng)*(maxq(0)-minq(0))/(ng-1))
mm=(high-low)/(maxq(0)-minq(0))
cc=high-mm*maxq(0)
Tt=mm*q+cc
ceiling=sres(1,0)
if(numblocks gt 1) then ceiling=(sres(1,0)>sres(1,1))
if(numblocks gt 2) then ceiling=(ceiling>sres(1,2))
ceiling=ceiling*1e-7+.01

plot,q,Tt,xrange=[rangelow,rangehigh],yrange=[0,ceiling],/xstyle,/ystyle,xtitle="q",$
ytitle="Time And Angle Resolutions",title="Resolutions vs q",thick=thick
!p.multi=[2,1,2,0,1]
;draw the angular resolution
thetax=[minq(0),maxq(0)]
thetay=[angres(0),angres(0)]
plot,thetax,thetay,/noerase,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,color=2^15,thick=thick

;-------------------------------------------------
;Draw Block 2 in selected graphics window
;-------------------------------------------------
;draw time resolution

if(numblocks gt 1) then begin
  
  low=sres(0,1)*1e-7
  high=sres(1,1)*1e-7
  
  currentblock=1	

;  low=low-time_modification(minq(1),wr(1),disr(1))
;  high=high-time_modification(maxq(1),wr(1),disr(1))

  mm=(high-low)/(maxq(1)-minq(1))
  cc=high-mm*maxq(1)
  q=minq(1)+(findgen(ng)*(maxq(1)-minq(1))/(ng-1))
  Tt=mm*q+cc
  plot,q,Tt,/noerase,xstyle=5,ystyle=5,xrange=[rangelow,rangehigh],yrange=[0,ceiling],thick=thick
  
  ;draw angular resolution
  thetax=[minq(1),maxq(1)]
  thetay=[angres(1),angres(1)]
  plot,thetax,thetay,/noerase,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,color=2^15,thick=thick
  
endif


;-------------------------------------------------
;Draw Block 3 in selected graphics window
;-------------------------------------------------
;draw time resolution
if(numblocks gt 2) then begin
  
  low=sres(0,2)*1e-7
  high=sres(1,2)*1e-7
  
  currentblock=2	

;  low=low-time_modification(minq(2),wr(2),disr(2))
;  high=high-time_modification(maxq(2),wr(2),disr(2))

  mm=(high-low)/(maxq(2)-minq(2))
  cc=high-mm*maxq(2)
  q=minq(2)+(findgen(ng)*(maxq(2)-minq(2))/(ng-1))
  Tt=mm*q+cc
  plot,q,Tt,/noerase,xstyle=5,ystyle=5,xrange=[rangelow,rangehigh],yrange=[0,ceiling],thick=thick

  ;draw angular resolution
  thetax=[minq(2),maxq(2)]
  thetay=[angres(2),angres(2)]
  plot,thetax,thetay,/noerase,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,color=2^15,thick=thick
endif

;-------------------------------------------------------angres
;Set graphics window for output for resolution vs q/qmin
;------------------------------------------------------- 
;widget_control,draw2,get_value=gval
;wset,gval


;----------------------------------------------------
;Draw the time and angular resolutions for the blocks
;----------------------------------------------------     
for u=1,numblocks do begin

  currentblock=u-1   

  rangelow=minq(u-1)/minq(u-1) 
  rangehigh=maxq(u-1)/minq(u-1)
  low=sres(0,u-1)*1e-7
  high=sres(1,u-1)*1e-7
;  low=low-time_modification(minq(u-1),wr(u-1),disr(u-1))
;  high=high-time_modification(maxq(u-1),wr(u-1),disr(u-1))

  q=[rangelow,rangehigh]
  y=[low,high]

  if u eq 1 then begin
    ;draw time resolution 
    !p.multi=[1,1,2,0,1]
    plot,q,y,xrange=[rangelow,rangehigh],yrange=[0,ceiling],/xstyle,/ystyle,title='Resolutions vs q/qmin',xtitle='q/qmin',$
ytitle='Time and Angle Resolutions',thick=thick
    ;draw angular resolution
    !p.multi=[1,1,2,0,1]
    plot,q,[angres(0),angres(0)],color=2^15,xstyle=5,ystyle=5,yrange=[0,ceiling],$
xrange=[rangelow,rangehigh],/noerase,thick=thick
  endif else begin
    !p.multi=[1,1,2,0,0]
    ;draw time resolution
    plot,q,y,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,/noerase,thick=thick,linestyle=2^(u-1)
    ;draw angular resolution
    plot,q,[angres(u-1),angres(u-1)],color=2^15,xstyle=5,ystyle=5,yrange=[0,ceiling],xrange=[rangelow,rangehigh],/noerase,$
thick=thick,linestyle=2^(u-1)
  endelse
endfor

currentblock=bcurrentblk

return
end





;*************************************************************************************************
;* 				     Procedure ErrorMessage
;*
;*This procedure produces a window with a text message. mes1 is a string holding the first line
;*of text. mes2 is a string holding the second line of text. mes3 is a string holding the third
;*line of text.
;*
;*  Procedure parameters :
;*   
;*  mes1  : string of any lenght
;*  mes2  : string of any lenght
;*  mes3  : string of sny lenght
;*
;*  
;*
;*************************************************************************************************


pro errormessage,mes1,mes2,mes3
common error,errbase,errsnum

errsnum=errsnum+1
if(errsnum eq 101) then errsnum=0

errbase(errsnum)=widget_base(title='MESSAGE WINDOW',/column)
mess1=widget_label(errbase(errsnum),value=mes1)
mess2=widget_label(errbase(errsnum),value=mes2)
mess3=widget_label(errbase(errsnum),value=mes3)
errbut=widget_button(errbase(errsnum),value='RETURN',uvalue=errsnum+300)

widget_control,/realize,errbase(errsnum)
xmanager,'error',errbase(errsnum)

return
end





;*************************************************************************************************
;*					 Procedure Error_event
;*
;*This procedure is called by 'xmanager' when a message window has been interacted with. The 
;*parameter -event- is a stucture that contains all the information about the widget that has
;*been interacted with.
;*
;* Parameters :
;*
;* event  : Structure
;*
;*
;* Variables (local)  :
;*
;* ev     :  Contains the user value of the interacted widget
;*************************************************************************************************


pro error_event,event
common error,errbase,errsnum

widget_control,event.id,get_uvalue=ev
widget_control,errbase(ev-300),/destroy

return
end





;*************************************************************************************************
;*					Procedure redrawparams
;*
;*
;*Procedure to Redraw the Ranges window. Thats all folks. 
;*
;*
;* Variables : (local)
;*
;* tmp       : Tempory variable 
;* vel       : Velocity of the neutrons
;* val       : Gives the time resolution at q half
;* mt        : Gradient of graph
;* ct        : Intercept of graph
;*
;*
;*(prgs note : call lims procedure before running this to ensure updated info)
;*
;*************************************************************************************************


pro redrawparams
common graph
common vars
common qs

widget_control,info(0),set_value='TOF Range  : '+string(dis(0))+'  '+string(dis(1))
widget_control,info(1),set_value='d Range    : '+string(d(0))+'  '+string(d(1))
widget_control,info(2),set_value='Rpms Range : '+string(w(1)*30/!pi)+'  '+string(w(0)*30/!pi)
widget_control,info(3),set_value='Chopper Ang: '+string(phil(currentblock))+'  '+string(phil(currentblock))
tmp=string(time_modification(minq(currentblock),wr(currentblock),disr(currentblock)))
tmp=tmp+'  '
tmp=tmp+string(time_modification(maxq(currentblock),wr(currentblock),disr(currentblock)))
widget_control,info(4),set_value='dtx/T      : '+tmp
widget_control,info(19),set_value='Chopper Angle:'+string(phil(currentblock))


;this is the calculation for the transmission or something proportional to it
mt=(sres(1,currentblock)*1e-7-sres(0,currentblock)*1e-7)/(maxq(currentblock)-minq(currentblock))
ct=sres(1,currentblock)*1e-7-mt*maxq(currentblock)

qhalf=(maxq(currentblock)-minq(currentblock))/2+minq(currentblock)

vel=k*qhalf/4/!pi/sin(sample_angle(currentblock)*!pi/180)

val=mt*qhalf+ct

tmp=wr(currentblock)/2./!pi*val*disr(currentblock)/vel

widget_control,info(45),set_value=string(tmp)

return
end






;*************************************************************************************************
;*				Procedure redrawmain
;*
;*This procedure centres the d, w and dis sliders
;*
;* Variables (local) :
;*
;* user1     :a constant used for convenience in calulations
;* user2     :a constant used for convenience in calulations
;* user3     :a constant used for convenience in calulations
;*
;*
;*
;*
;*
;* (Prgs note : delta x update here)  ***i think there is an error here***
;*************************************************************************************************


pro redrawmain
common graph
common vars
common qs

;-------------------------------------------------
;set some constants
;-------------------------------------------------
user1=(dis(1)-dis(0))/2+dis(0)
user2=(d(1)-d(0))/2+d(0)
user3=2*!pi*k/user1/lamda(1)

widget_control,info(12),set_value=string(user1)
widget_control,info(11),set_value=user1*1e7
disr(currentblock)=user1

widget_control,info(15),set_value=string(user2)
widget_control,info(14),set_value=user2*1e7
dr(currentblock)=user2

widget_control,info(18),set_value=string(user3*30/!pi)
widget_control,info(17),set_value=user3*1e7
wr(currentblock)=user3

return
end



;*************************************************************************************************
;*				    Procedure base_event
;*
;*This procedure is called by the xmanager. It controls the events in the initial setup window.
;*
;* Parameters :
;* 
;* event      : Structure
;*
;* 
;* Variables  (local) :
;*
;* ev              : Stores the user value of the widget begin interacted with
;* val             : Stores the value of the widget itself.
;* q1,q2           : Stores the miniumum and maximum q values for whole range
;* qrange          : a constant that stores q2/q1
;* tmp, qtmp,junk  : tempory variables depends on context
;* u               : variable used for the counter in for loops
;* overlap,overlap1: contains the amount of shift due to the overlap parameter
;* sep             : contains slit separation
;* res             : contains angular resolution
;* dtheata         : contains delta theata
;* f               : contains new slider values for s2 and s3
;* w               : tempory variable
;*
;*
;*
;*************************************************************************************************


pro base_event,event
common qs
common graph
common vars

widget_control,event.id,get_uvalue=ev,get_value=val



banner=0
 
;-------------------------------------------------
;Quit button pressed
;-------------------------------------------------
if(ev eq 57) then begin
  widget_control,/reset
  qflag=1
endif

;-------------------------------------------------
;qmin changed
;-------------------------------------------------
if(ev eq 41)or(restart_flag eq 1) then begin
  if restart_flag eq 1 then begin
    restart_flag=0
    widget_control,wid(1),get_value=tmp
    val=float(tmp(0))
  endif
  
  widget_control,wid(3),get_value=qtmp
  q1=float(val(0))
  q2=float(qtmp(0))

  if(q1 lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q min should","not be","negative"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(17),sensitive=1
    banner=1
  endif 

  if(q1 gt q2) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q min should be","smaller than","q max"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif 

  qrange=q2/q1

  if(qrange gt 1000) then begin
    for u=0, widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errmessage,"q max should not be more than 3 factors of","wavelenght max/wavelenght min","away from q min"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  junk=check_math(1,1)
  if(qrange le qrangeb) and (qrange gt 0) then begin
    numblocks=1
    minq(0)=q1
    maxq(0)=q1*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
  endif
  if(qrange le qrangeb^2) and (qrange gt qrangeb) then begin
    numblocks=2
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
    junk=check_math(0,0)
  endif
  if(qrange le qrangeb^3) and (qrange gt qrangeb^2) then begin
    numblocks=3
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    overlap1=perover*(maxq(1)-minq(1))
    minq(2)=(q1*qrangeb-overlap)*qrangeb-overlap1
    maxq(2)=((q1*qrangeb-overlap)*qrangeb-overlap1)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
    sample_angle(2)=asin(lamda(1)*minq(2)/4/!pi)*180/!pi
  endif
  
  if check_math(0,0) ne 0 then begin
    sample_angle(0)=-1.
    sample_angle(1)=-1.
    sample_angle(2)=-1.
  endif

  ;display current block
  widget_control,wid(19),set_value=string(currentblock+1)

  ;set the q for the block
  widget_control,wid(7),set_value=string(minq(0))
  widget_control,wid(9),set_value=string(maxq(0))

  ;set sample angle
  widget_control,wid(28),set_value=string(sample_angle(currentblock))

  if(sample_angle(currentblock) gt 25)or(sample_angle(currentblock) lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"Sample Angle Exceeds","Bounds","Change Q Range"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  ;in radians
  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  ;convert to degrees
  dtheata=dtheata*180/!pi

  ;set the angular resolution widgets
  for u=1,numblocks do begin
    res=dtheata/sample_angle(u-1)
    widget_control,wid(44+u),set_value=string(res)
  endfor

  ;set the angular resolution widget to ready, if it is not needed
  if(numblocks ne 3) then begin
    for u=numblocks+1,3 do begin
      widget_control,wid(44+u),set_value='Ready'
    endfor
  endif

  if banner eq 0 then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=1
    endfor

    ;de-activate unused block buttons
    if(numblocks lt 3) then begin
      widget_control,wid(16),sensitive=0
    endif
    if(numblocks lt 2) then begin
      widget_control,wid(15),sensitive=0
    endif
  endif

  ;close down illumination graph if it is active
  if graph(3) eq 1 then graph  

  ;update foot print, and illumination values
  update_ftper
endif


;-------------------------------------------------
;qmax changed
;-------------------------------------------------
if(ev eq 43) then begin
  banner=0
  widget_control,wid(1),get_value=qtmp
  q2=float(val(0))
  q1=float(qtmp(0))

  if(q2 lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q max should","not be","negative"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(17),sensitive=1
    banner=1
  endif
 
  if(q1 gt q2) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q min should be","smaller than","q max"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  qrange=q2/q1

  if(qrange gt 1000) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q max should not be more than 3 factors of","wavelenght max/wavelenght min","away from q min"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  junk=check_math(1,1)
  if(qrange le qrangeb) and (qrange gt 0) then begin
    numblocks=1
    minq(0)=q1
    maxq(0)=q1*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
  endif
  if(qrange le qrangeb^2) and (qrange gt qrangeb) then begin
    numblocks=2
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
  endif
  if(qrange le qrangeb^3) and (qrange gt qrangeb^2) then begin
    numblocks=3
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    overlap1=perover*(maxq(1)-minq(1))
    minq(2)=(q1*qrangeb-overlap)*qrangeb-overlap1
    maxq(2)=((q1*qrangeb-overlap)*qrangeb-overlap1)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
    sample_angle(2)=asin(lamda(1)*minq(2)/4/!pi)*180/!pi
  endif

  if check_math(0,0) ne 0 then begin
    sample_angle(0)=-1.
    sample_angle(1)=-1.
    sample_angle(2)=-1.
  endif

  ;display current block
  widget_control,wid(19),set_value=string(currentblock+1)

  ;set the q for the block
  widget_control,wid(7),set_value=string(minq(0))
  widget_control,wid(9),set_value=string(maxq(0))

  ;set sample angle
  widget_control,wid(28),set_value=string(sample_angle(currentblock))

  if(sample_angle(currentblock) gt 25)or(sample_angle(currentblock) lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"Sample Angle Exceeds","Bounds","Change Q Range"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))


  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  for u=1,numblocks do begin    
    res=dtheata/sample_angle(u-1)
    widget_control,wid(44+u),set_value=string(res)
  endfor

  ;blank out unused resolutions
  if(numblocks ne 3) then begin
    for u=numblocks+1,3 do begin
      widget_control,wid(44+u),set_value='Ready'
    endfor
  endif

  if banner eq 0 then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=1
    endfor

    ;blank out unneccesarry ones
    if(numblocks lt 3) then begin
      widget_control,wid(16),sensitive=0
    endif
    if(numblocks lt 2) then begin
      widget_control,wid(15),sensitive=0
    endif
  endif

  ;close down graph
  if graph(3) eq 1 then graph 

  update_ftper

endif

;-------------------------------------------------
;The s2 slider was moved
;-------------------------------------------------
if(ev eq 62) then begin
  ;update the text showing s2's value
  s2v(currentblock)=val*1e-7
  widget_control,wid(23),set_value=string(s2v(currentblock))
  if slit_lock eq 1 then begin
    s3v(currentblock)=s2v(currentblock)
    widget_control,wid(25),set_value=s3v(currentblock)*1e7
    widget_control,wid(26),set_value=string(s3v(currentblock))
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper  
endif

;-------------------------------------------------
;s3 slider was moved
;-------------------------------------------------
if(ev eq 65) then begin

  ;update text widget showing the value of s3
  s3v(currentblock)=val*1e-7
  widget_control,wid(26),set_value=string(s3v(currentblock))
  if slit_lock eq 1 then begin
    s2v(currentblock)=s3v(currentblock)
    widget_control,wid(22),set_value=s2v(currentblock)*1e7
    widget_control,wid(23),set_value=string(s2v(currentblock))
  endif
   
  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper

endif

;-------------------------------------------------
;text widget for s2 was altered
;-------------------------------------------------
if(ev eq 63) then begin

  ;update the slider s2
  val=long(val(0)*1e7)
  s2v(currentblock)=val*1e-7

  if s2v(currentblock) gt slit(1) then s2v(currentblock)=slit(1) 
  if s2v(currentblock) lt slit(0) then s2v(currentblock)=slit(0)
  widget_control,wid(23),set_value=string(s2v(currentblock))

  widget_control,wid(22),set_value=s2v(currentblock)*1e7
  if slit_lock eq 1 then begin
    s3v(currentblock)=s2v(currentblock)
    widget_control,wid(25),set_value=s3v(currentblock)*1e7
    widget_control,wid(26),set_value=string(s3v(currentblock))
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper 
endif 

;-------------------------------------------------
;the text widget for s3 was altered
;-------------------------------------------------
if(ev eq 66) then begin

  ;update the position of slider s3
  val=long(val(0)*1e7)
  s3v(currentblock)=val*1e-7

  if s3v(currentblock) gt slit(1) then s3v(currentblock)=slit(1) 
  if s3v(currentblock) lt slit(0) then s3v(currentblock)=slit(0)
  widget_control,wid(26),set_value=string(s3v(currentblock))

  widget_control,wid(25),set_value=s3v(currentblock)*1e7
  if slit_lock eq 1 then begin
    s2v(currentblock)=s3v(currentblock)
    widget_control,wid(22),set_value=s2v(currentblock)*1e7
    widget_control,wid(23),set_value=string(s2v(currentblock))
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper
endif 

;-------------------------------------------------
;Slit lock button was pressed
;-------------------------------------------------
if(ev eq 75) then begin
  slit_lock=(1-slit_lock)
  widget_control,wid(22),get_value=pos
  widget_control,wid(25),set_value=pos
  if slit_lock eq 0 then widget_control,wid(35),set_value='OFF'
  if slit_lock eq 1 then widget_control,wid(35),set_value='ON'  
endif


;-------------------------------------------------
;On of the block buttons was pressed
;-------------------------------------------------
for u=1,numblocks do begin
  if(ev eq 53+u) then begin    
    currentblock=u-1
    if (u-1) eq 0 then begin
      widget_control,wid(14),set_value='ACTIVE'
      widget_control,wid(15),set_value='Block 2'
      widget_control,wid(16),set_value='Block 3'
    endif
    if (u-1) eq 1 then begin
      widget_control,wid(14),set_value='Block 1'
      widget_control,wid(15),set_value='ACTIVE'
      widget_control,wid(16),set_value='Block 3'
    endif
    if (u-1) eq 2 then begin
      widget_control,wid(14),set_value='Block 1'
      widget_control,wid(15),set_value='Block 2'
      widget_control,wid(16),set_value='ACTIVE'
    endif
    widget_control,wid(7),set_value=string(minq(currentblock))
    widget_control,wid(9),set_value=string(maxq(currentblock))
    widget_control,wid(19),set_value=string(currentblock+1)
    widget_control,wid(28),set_value=string(sample_angle(currentblock))
    widget_control,wid(22),set_value=s2v(currentblock)*1e7
    widget_control,wid(23),set_value=string(s2v(currentblock))
    widget_control,wid(25),set_value=s3v(currentblock)*1e7
    widget_control,wid(26),set_value=string(s3v(currentblock))
    ;update graph
    if graph(3) eq 1 then begin
      ;update graph if it is on
      updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
    endif
    update_ftper
  endif
endfor

;-------------------------------------------------
;the graph button was pressed
;-------------------------------------------------
if(ev eq 88) then graph


;-------------------------------------------------------
;the level ang resolution button was pressed for block 1
;-------------------------------------------------------
if(ev eq 89) then begin
  
  for u=0,numblocks-2 do begin
    f=make_same(0,u+1)
    if(f eq -1) then begin
      errormessage,"Slider Values Can Not be Found","For A Block",""
    endif else begin
      
      widget_control,wid(45),get_value=num
      widget_control,wid(46+u),set_value=num

      if(currentblock eq u+1) then begin
        widget_control,wid(22),set_value=f*1e7
        widget_control,wid(25),set_value=f*1e7
        widget_control,wid(23),set_value=string(f)
        widget_control,wid(26),set_value=string(f)
      endif

      s2v(u+1)=f
      s3v(u+1)=f

    endelse
  endfor
endif

;-------------------------------------------------------
;the level ang resolution button was pressed for block 2
;-------------------------------------------------------
if numblocks gt 1 then begin
 if(ev eq 90) then begin

  for u=0,numblocks-2 do begin

    if(u eq 0) then w=0
    if(u eq 1) then w=2

    f=make_same(1,w)

    if(f eq -1) then begin
      errormessage,"Slider Values Can Not be Found","For A Block ",""
    endif else begin
      
      widget_control,wid(46),get_value=num
      widget_control,wid(45+w),set_value=num

      if(currentblock eq w) then begin
        widget_control,wid(22),set_value=f*1e7
        widget_control,wid(25),set_value=f*1e7
        widget_control,wid(23),set_value=string(f)
        widget_control,wid(26),set_value=string(f)
      endif

      s2v(w)=f
      s3v(w)=f

    endelse
  endfor
 endif
endif

;-------------------------------------------------------
;the level ang resolution button was pressed for block 3
;-------------------------------------------------------

if numblocks gt 2 then begin
 if(ev eq 91) then begin
  for u=0,numblocks-2 do begin
    w=u
    f=make_same(2,w)
    if(f eq -1) then begin
      errormessage,"Slider Values Can Not be Found","For A Block ",""
    endif else begin
     
      widget_control,wid(47),get_value=num
      widget_control,wid(45+w),set_value=num

      if(currentblock eq w) then begin
        widget_control,wid(22),set_value=f*1e7
        widget_control,wid(25),set_value=f*1e7
        widget_control,wid(23),set_value=string(f)
        widget_control,wid(26),set_value=string(f)
      endif

      s2v(w)=f
      s3v(w)=f

    endelse
  endfor
 endif
endif

;----------------------------------------------------------
;The > button was pressed to bring up the parameters window
;----------------------------------------------------------
if ev eq 97 then submenu

;-------------------------------------------------
;the next button was pressed
;-------------------------------------------------
if(ev eq 76) then begin  
  ;save some variable for next program
  ;resolutions delta theata over theata
 
  for u=1,numblocks do begin
    widget_control,wid(44+u),get_value=num
    angres(u-1)=float(num)
  endfor
  
  ;reset for next part of program
  widget_control,/reset
endif

ppass:
return
end






;*************************************************************************************************
;*				Procedure Graph 
;*
;*This procedure draw the illumination graph
;*
;* Variables (local) :
;*
;* x                 : holds the data for the x axis of the graph
;* y                 : holds the data for the y axis of the graph
;* h                 : hold the result from the bob() function
;* 
;*
;*
;*************************************************************************************************


pro graph
common qs
common vars
common graph
!p.multi=0

if(graph(3) eq 0) then begin
  h=bob(s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist)
  grp=widget_base(title='Illumination Graph',uvalue='grp')
  graph(0)=widget_draw(grp,xsize=600,ysize=550,yoffset=0,xoffset=0,retain=2)
  graph(1)=widget_button(grp,value="RETURN",xoffset=0,yoffset=551,uvalue=300,xsize=300)
  graph(2)=widget_button(grp,value="ReDraw",xoffset=300,yoffset=551,uvalue=301,xsize=300)
  graph(3)=1 ;graph on
  widget_control,grp,/realize
  xmanager,'grp',grp
  x=[ll1,ll2,rr1,rr2]
  y=[0,1,1,0]
  plot,x,y,thick=2,title='Illumination Of The Sample, block '+strtrim(string(currentblock+1),2),$
xtitle='Position',ytitle='Intensity',xrange=[0,sample_lenght],yrange=[0,1.1]
endif else begin
  graph(3)=0
  widget_control,grp,/destroy
endelse

return
end





;*************************************************************************************************
;*				Procedure updategraph
;*
;*This procedure updates the illumination graph  
;*
;* Parameters :
;*
;* s2         : holds the value of s2 (slit 2)
;* s3         : holds the value of s3 (slit 3)
;* sam        : holds the sample angle
;* samlen     : holds the sample lenght
;* slsamlen   : hold the distance from the slit to the sample
;*
;* Variables  :
;*
;* x          : holds the data for the x axis of the data
;* y          : holds the data for the y axis of the data
;* h          : holds the value of the bob() function
;*
;*
;*
;*************************************************************************************************


pro updategraph,s2,s3,sam,samlen,slsamlen
common qs

!p.multi=0
h=bob(s2,s3,sam,samlen,slsamlen)
if h eq -1 then print,'Procedure updategraph : bob() return -1 (neutron divergence)'
x=[ll1,ll2,rr1,rr2]
y=[0,1,1,0]
plot,x,y,thick=2,title='Illumination Of The Sample, block '+strtrim(string(currentblock+1),2),$
xtitle='Position',ytitle='Intensity',xrange=[0,sample_lenght],yrange=[0,1.1]
return
end





;*************************************************************************************************
;*				Procedure grp_event 
;*
;* Parameters :
;*
;* event      : holds information about the interacted widget (type: structure)
;*
;* Variables  :
;*
;* ev         : holds the value of the user value of the widget
;* val        : holds the actual value of the widget
;* x          : holds the x axis data for the graph
;* y          : holds the y axis data for the graph
;*
;*
;*
;************************************************************************************************* 


pro grp_event,event
common graph
common qs
common vars

widget_control,event.id,get_uvalue=ev,get_value=val


;-------------------------------------------------
;Return button was pressed
;-------------------------------------------------
if(ev eq 300) then begin
  graph(3)=0
  widget_control,grp,/destroy
endif

;-------------------------------------------------
;The redraw button was pressed
;-------------------------------------------------
if(ev eq 301) then begin
  h=bob(s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist)
  x=[ll1,ll2,rr1,rr2]
  y=[0,1,1,0]

;-------------------------------------------------
;plot graph
;-------------------------------------------------
plot,x,y,thick=2,title='Illumination Of The Sample, block '+strtrim(string(currentblock+1),2),$
xtitle='Position',ytitle='Intensity',xrange=[-.001,sample_lenght+.001],yrange=[0,1.1] 
endif   

return
end





;*************************************************************************************************
;*				    Procedure update_ftper
;*
;*This procedure updates the footprint and the illumination.
;*
;* Variables :
;*
;* p         : hold the illumination as a percentage
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************


pro update_ftper
common qs
h=bob(s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist)

;-------------------------------------------------
;updates the footprint
;-------------------------------------------------
widget_control,wid(55),set_value=string(foot_print)
;updates illumination
if(ll1 ge 0.) and (rr2 le sample_lenght) then begin
  widget_control,wid(38),set_value='Under'
endif else begin
  if(ll1 lt 0.)or(ll1 gt sample_lenght) then begin
    widget_control,wid(38),set_value='Over'
    ll1=0
  endif
  if(rr2 gt sample_lenght)or(rr2 lt 0.) then begin
    widget_control,wid(38),set_value='Over'
    rr2=sample_lenght
  endif
endelse

;-------------------------------------------------
;update the illumination
;-------------------------------------------------
p=(rr2-ll1)/sample_lenght*100
widget_control,wid(56),set_value=string(p)  
return
end





;*************************************************************************************************
;*				    Function Make_same
;*
;*This procedure attempts to make the angular resolutions the same by altering s2 and s3. 
;*
;*
;* Parameters :
;* 
;* indexa     : block number of the angular resolution to be copied to the other blocks
;* indexb     : block number of the angular resolution to be copied over
;* ang1       : sample angle of block with indexa (degrees)
;* ang2       : sample angle of block with indexb (degrees)
;* s21        : contains the slit value of s2 for block with indexa
;* s31        : contains the slit value of s3 for block with indexb
;* new_s      : this is the new slit value of slits s2 and s3 for block with indexb
;* 
;*
;*
;*
;*************************************************************************************************


function make_same,indexa,indexb
common qs

ang1=sample_angle(indexa)
ang2=sample_angle(indexb)

s21=s2v(indexa)
s31=s3v(indexa)

new_s=(s21>s31)*ang2/ang1

if(new_s gt .01) or (new_s lt 0) then new_s=-1

return,new_s
end





;*************************************************************************************************
;*				    Procedure submenu 
;*
;*This procedure creates the submenu window for the intial setup window when the > button
;*is pressed.
;*
;*
;*
;*
;*
;*
;*************************************************************************************************


pro submenu
  common qs
  common slitstuff,slit_separation

  if submenu(0) eq 0 then begin
    sub=widget_base(title='Parameters',uvalue='sub')
    submenu(1)=widget_label(sub,value='Sample Length    :',yoffset=5)
    submenu(2)=widget_text(sub,value=string(sample_lenght),xoffset=230,/editable,uvalue=202)
    submenu(3)=widget_label(sub,value='Slit Separation  :',yoffset=45)
    submenu(4)=widget_text(sub,value=string(Slit_separation),xoffset=230,/editable,uvalue=204,$
yoffset=40)
    submenu(5)=widget_label(sub,value='Slit Sample Dist :',yoffset=87)
    submenu(6)=widget_text(sub,value=string(slit_sample_dist),xoffset=230,/editable,uvalue=206,$
yoffset=80)

    submenu(7)=widget_label(sub,value='OverLap Parameter:',yoffset=127)
    submenu(8)=widget_text(sub,value=string(perover*100),uvalue=208,xoffset=230,yoffset=120,$
/editable)
    submenu(9)=widget_label(sub,value='%',xoffset=490,yoffset=127)

    submenu(10)=widget_button(sub,value='RETURN',xoffset=0,yoffset=210,xsize=510,uvalue=210)

    submenu(11)=widget_label(sub,value='Save Name       :',yoffset=173,xoffset=0)
    submenu(12)=widget_text(sub,value=save_string,/editable,uvalue=212,xoffset=230,yoffset=167)
    ;max=12
    
    submenu(0)=1 ; screen on
    widget_control,sub,/realize
    xmanager,'sub',sub

  endif else begin
    widget_control,sub,/destroy
    submenu(0)=0
  endelse
return
end





;*************************************************************************************************
;*				  Procedure sub_event 
;*
;* Paramters :
;*
;* event     : This contains the information of the interacted widget (Structure)
;*
;* 
;* Variables :
;*
;* ev        : This contains the uservalue for the widget that has been interacted with
;* val       : This contains the value of the widget that has been interacted with
;* tmp       : Holds the sample angle in radians
;* tmp1      : Holds the angular resolution
;*
;*
;*
;*
;*************************************************************************************************


pro sub_event,event
  common qs
  common slitstuff,slit_separation
  common graph
  widget_control,event.id,get_uvalue=ev,get_value=val
  
  ;-------------------------------------------------
  ;Sample lenght has been altered
  ;-------------------------------------------------
  if ev eq 202 then begin
    sample_lenght=float(val(0))
    update_ftper
    ;update graph if it is on
    if graph(3) eq 1 then begin
      updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
    endif
    widget_control,wid(30),set_value=string(sample_lenght)
  endif

  ;-------------------------------------------------
  ;Slit sepation has been altered
  ;-------------------------------------------------
  if ev eq 204 then begin
    slit_separation=float(val(0))
        for u=0,numblocks-1 do begin
      tmp=sample_angle(u)/180*!pi
      tmp1=(s2v(u)>s3v(u))/slit_separation/tmp
      widget_control,wid(45+u),set_value=string(tmp1)
    endfor
    widget_control,wid(34),set_value=string(val(0))
  endif 

  ;-------------------------------------------------
  ;Slit to sample distance has been changed
  ;-------------------------------------------------
  if ev eq 206 then begin
    slit_sample_dist=float(val(0))
    update_ftper
    if graph(3) eq 1 then begin
      ;update graph if it is on
      updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
    endif
    widget_control,wid(32),set_value=string(val(0))
  endif
  
  ;-------------------------------------------------
  ;The overlap parameter has been changed
  ;-------------------------------------------------
  if ev eq 208 then begin
    perover=float(val(0))/100.
    restart_flag=1
  endif

  ;-------------------------------------------------
  ;The return button has been pressed
  ;-------------------------------------------------
  if ev eq 210 then begin
    submenu(0)=0
    widget_control,sub,/destroy
  endif

  ;-------------------------------------------------
  ;The save string has been changed
  ;-------------------------------------------------
  if ev eq 212 then begin
    save_string=strtrim(string(val(0)),2)
  endif
    
return
end





;*************************************************************************************************
;*				Function deltax
;*
;*This function returns the delta x value. It is important to note any changes to the formulae
;*for delta x must also be changed in the lims() procedure.THIS procedure returns a VALUE not
;*the RANGE of delta x. ce bon.
;*
;* Parameters :
;* xd         : This contains the chopper distance (m)
;* xw         : This contains the angular velocity (rad/s)
;* xl         : This contains lamda
;* xphil      : This contains the chopper phase angle (degrees)
;*
;*
;* Variables  :
;*
;* xx         : Contains deltax
;*
;*
;*************************************************************************************************


;function deltax,xd,xw,xl,xphil

;common graph
;common vars
;common qs

;-------------------------------------------------
;1st contribution to delta x
;-------------------------------------------------
;xx=xd*sin(atan(xw*r*xl/k))

;-------------------------------------------------
;2nd contribution to delta x
;-------------------------------------------------
;xx=xx+(xphil/180.)*!pi*r*cos(atan(xw*r*xl/k))


;second contribution is zero if phi is negative

;-------------------------------------------------
;3rd contribution to delta x
;-------------------------------------------------
;xx=bob(s3v(currentblock),s2v(currentblock),90,chopper_width,slit_chopper_dist)

;return,xx
;end





;*************************************************************************************************
;*  				Procedure gobob and golim 
;*
;*These procedures exist becuase the calls the the funcions bob and lim arnt recognised in the
;*main program. This is becuase the two function bob and lim have not been compiled yet and the 
;*program takes them as variables (arrays) and subsequently provides an error becuase the computer
;*thinks they havent been defined. To get around this I put the calls after the functions in the program
;*and in that way the names bob and lim are reognised as functions and all is well
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************



;end


;gobob
pro gobob

common graph
common vars
common initialvals
common qs
common slitstuff,slit_separation
common error,errbase,errsnum

h=bob(.005,.005,sample_angle(currentblock),sample_lenght,slit_sample_dist)

return
end


pro golim

common graph
common vars
common initialvals
common qs
common slitstuff,slit_separation
common error,errbase,errsnum

val=lims(sres(0,currentblock)*1e-7,sres(1,currentblock)*1e-7,qmin,qmax)

return
end


;templates
  
;*************************************************************************************************
;* 
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************

;-------------------------------------------------
;
;-------------------------------------------------

;
;************************************************ End Of File ************************************************
;
;written by Floris Andre, August 2001; modifications by Roland May

;*******************************************************************************
;*******************************************************************************
pro time_display
;*******************************************************************************
;*******************************************************************************
common nb,n
common tablo,tabb
common total,ti,m,ti2,tx,txx,time_result_string
common totaltime,ttime			;to calculate total time

;print,"new version of time_display"

tx1=long(0)
tx2=long(0)
tx3=long(0)
a=0
b=0
m=0
ti=0
for i=1,n[0] do begin
  if tabb[i+500] ne 'x' then begin
    if tabb[i+300] eq 't' then begin
      a=tabb[i+400]
      for j=1,a do begin
	ti=ti+float(strtrim(tabb[i+200],2))
	; print,"ti: ",ti
      endfor
    endif
    ti2=0.
    if tabb[i+300] eq 'm' then begin
      if strlen(tabb[i+200]) ne 0 then begin
        l=float(tabb[1099])
        b=tabb[i+400]
	for j=1,b do begin
	  m=m+float(tabb[i+200])
	  arg=0.30449/l-0.017049-0.00011906*l+0.00033876*l^2
	  ti2=float(m)*float(arg)
	  ; print,"ti2: ",ti2
;	  ti2=long(ti2)
	endfor
      endif
    endif
  endif
endfor
tx=ti+ti2
;------------------ TIME FORMAT H/MIN/S -----------------------------------
tx1=tx/3600
tx1=strtrim(long(tx1),2)
tx=tx mod 3600

tx2=tx/60
tx2=strtrim(long(tx2),2)
tx=tx mod 60
tx3=strtrim(long(tx),2)
;--------------------- DISPLAY TIME OF EXPERIMENT ------------------------------
th=string(' h ')
tm=string(' min ')
ts=string(' s ')
if tx1 eq 0 then begin
  tx1=string(format='(A1)','')
  th=string(format='(A1)','')
endif 
if tx2 eq 0 then begin
  tx2=string(format='(A1)','')
  tm=string(format='(A1)','')
endif 
if tx eq 0 then begin
  tx=string(format='(A1)','')
  ts=string(format='(A1)','')
endif 
time_result_string=string('estimated time: ')+string(tx1) $
+string(th)+string(tx2)+string(tm)+string(tx3)+string(ts) $
+string('(without instrument settings)')

end


;*******************************************************************************
;*******************************************************************************
pro grille_event,ev
;*******************************************************************************
;*******************************************************************************

; Tabb   1-100: sample position  in experiment list
; Tabb 101-200: sample name		"
; Tabb 201-300: preset			"
; Tabb 301-400: t/m			"
; Tabb 401-500: # of repetitions	"
; Tabb 501-600: save/nosave		"

; modification (physical sample list is maintained in a separate list):
; Tabb 601-700: sample list in rack

widget_control,ev.id,get_uvalue=u

common tablo,tabb
common tabla,tabu
common nb,n
common bases,pre,t,rep,sav,pos
common sa,sam

common erreur,error2,error3
;------ var for repetition of a line -----------------------

common rrr,indicedeb,ind
common tablo2,tabb2
common stopit,stop
stop=1
;-----------------------------------------------------------
common nofile,exist_file,ex


;pos=strarr(100)
;sam=strarr(100)
;pre=strarr(100)
;t  =strarr(100)
;rep=strarr(100)
;sav=strarr(100)


;-------- condition for checking fields ----------------------------------------
ok=1
ok2=1
;-------------------------------------------------------------------------------

;--------------- to calculate duration of experiment ---------------------------
common total,ti,m,ti2,tx,txx,time_result_string
common totaltime,ttime

;-------------------------------------------------------------------------------
;++++++++++++++++++++ VALUE OF WAVELENGTH FOR AN EXISTING FILE +++++++++++++++++

;common check,chec
;if chec eq 1 and ex eq 0 then begin
;tabb[1099]=8
;endif
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; keep old values for position, samples, etc.
for i=1,700 do begin
  tabb2[i]=strtrim(tabb[i],2)
endfor
	
if u(0) lt 1000 then begin

;-------- POS EVENT: a position has changed; 
;-------- replace the sample name by the name corresponding to this position
;---------------------------------------------------------------------
  if u(0) gt 0 and u(0) le 100 then begin
	;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	for j=1,n[0] do begin
	  ; print, "n[0]: ",n[0],"  - pos(j): ",pos(j)
	  widget_control,pos(j),get_value=ech
	  tabb[j]=strtrim(ech[0],2)
	  j1=fix(tabb(j))
	  j2=fix(tabb2(j))
	  if j2 ne j1 then begin
	    ; print,'# ',j,' position has changed from ',j2,' to ',j1
	    widget_control,pos(j),set_value=tabb(j)		;position
	    ; print,'sample in position ',j1,' is [',tabb[j1+600],']'
	    if tabb[j1+600] ne '' then begin
	      widget_control,sam(j),set_value=tabb[j1+600]	;par sub
	    endif else begin
	      widget_control,sam(j),set_value=''		;par sub
	    endelse
	    tabb[j+100]=tabb[j1+600]				;par sub
	  endif
	endfor
	;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	cpt=0
	for i=1,n[0]-1 do begin
	  i1=i+1
	  for j=i1,n[0] do begin
	    if fix(tabb[i]) eq fix(tabb[j]) then begin
		ind=i
		cpt=cpt+1
	    endif
	  endfor
	endfor
;	print, 'ok: ', ok,' - cpt: ',cpt
 	if ok eq 1 then begin
	  if cpt ge 1 then begin
;--------------------------------- ERROR ---------------------------------------
	    err2='*** warning: position '
	    widget_control,error2,set_value=string(err2)$
	     +string(tabb[ind])+string(' is repeated ***')
	  endif else begin
	    widget_control,error2,set_value=''
	  endelse
;-------------------------------------------------------------------------------
	  ok=0
	endif
  endif


;-------- SAMPLE EVENT: a sample title has changed; 
;-------- replace the sample title in the sample list and change the sample 
;-------- title in all occurrences of the same position
if u(0) gt 100 and u(0) le 200 then begin
	ok=1
	for j=1,n[0] do begin
	  widget_control,pos(j),get_value=ech
	  tabb[j]=strtrim(ech,2)
	  ind1=fix(tabb[j])				
	  widget_control,sam(j),get_value=ech
	  tabb[j+100]=strtrim(ech,2)					
	  tabb[ind1+600]=strtrim(ech,2)					
	  snew=tabb(j+100)
	  sold=tabb2(j+100)
	  if snew ne sold then begin
	    ; print,'sample in position ',tabb[j],' has changed from [',$
	    ;  sold,'] to [',snew,']'
	    tabb[600+ind1]=snew
	    for i=1,n[0] do begin
	      widget_control,pos(i),get_value=ech
	      tabb[i]=strtrim(ech,2)
	      ind2=fix(tabb[i])
	      ; print, 'i: ',j,' - ind1: ',ind1,' - ind2: ',ind2
	      if ind1 eq ind2 then begin				
	        ; print,'sample in position ',ind2,' is [',snew,']'
	        widget_control,sam(i),set_value=tabb(600+ind1)
	        tabb[600+ind2]=snew
	        tabb(i+100)=snew
	      endif
	    endfor
	  endif
	endfor

	cpt=0
	for i=1,n[0]-1 do begin
	  i1=i+1
	  for j=i1,n[0] do begin
	    if tabb[100+i] eq tabb[100+j] then begin
		ind=i
		if tabb[i] ne tabb [j] then begin
		  cpt=cpt+1
		endif
	    endif
	  endfor
	endfor
;print, 'ok: ', ok,' - cpt: ',cpt
 	if ok eq 1 then begin
	  if cpt ge 1 then begin
;--------------------------------- ERROR ---------------------------------------
	    err2='*** warning: sample '
	    widget_control,error2,set_value=string(err2)$
	     +string(tabb[100+ind])+string(' is repeated ***')
	  endif else begin
	    widget_control,error2,set_value=''
	  endelse
;-------------------------------------------------------------------------------
	  ok=0
	endif
endif	


;-------- PRE EVENT (to calculate time at every change in the grid)
	;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  if u(0) gt 200 and u(0) le 600 then begin
	for j=1,n[0] do begin
;		widget_control,pos(j),get_value=ech
;		tabb[j]=strtrim(ech,2)			
;		widget_control,sam(j),get_value=ech
;		tabb[j+100]=strtrim(ech,2)			
		widget_control,pre(j),get_value=ech
		tabb[j+200]=strtrim(ech,2)				
		widget_control,t(j),get_value=ech
		tabb[j+300]=strtrim(ech,2)
		widget_control,rep(j),get_value=ech
		tabb[j+400]=strtrim(ech,2)
 		widget_control,sav(j),get_value=ech
		tabb[j+500]=strtrim(ech,2)
	endfor
	;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	time_display
	widget_control,u(2),set_value=time_result_string
  endif

endif else begin
	;-------------------------------------

	;--------- close button ---------------
	if u(0) eq 1000 then begin
	  widget_control,ev.top,/destroy
	endif
	
	;--------- new button ----------------
	if u(0) eq 1001 then begin
	  widget_control,ev.top,/destroy
	  grille

	;--------------- REMOVE VALUES IN THE SAMPLE AND PRESET FIELDS ---------
	  for i=1,n[0] do begin
	    ech=string(format='(A1)','')
	    ech=strtrim(ech,2)
	    widget_control,sam(i),set_value=ech
	    tabb[i+100]=ech
	    widget_control,pre(i),set_value=ech
	    tabb[i+200]=ech
	  endfor
	;-----------------------------------------------------------------------
	endif


	;------------------ add line button ------------------------------------
	if u(0) eq 1008 then begin
		b=string(format='(I2)',strtrim(n,2))
		bb=fix(b)

		;------ if n < 100 (nb max of samples) -----------
		if b lt 100 then begin
		;-------------------------------------------
			common newl,newline
			common newbut,base182
			newline=1
	;------------------ to keep value in memory -------------------	
			for i=1,n[0] do begin
				widget_control,u(i+1),get_value=ech
				tabb[i]=strtrim(ech,2)
				; pos[i]=strtrim(ech,2)
			endfor
			for i=101,100+n[0] do begin
				widget_control,u(i+1),get_value=ech
				tabb[i]=strtrim(ech,2)
				; sam[i-100]=strtrim(ech,2)
			endfor

			for i=201,200+n[0] do begin
				widget_control,u(i+1),get_value=ech
				tabb[i]=strtrim(ech,2)
				; pre[i-200]=strtrim(ech,2)
			endfor	
	
			for i=301,300+n[0] do begin
				widget_control,u(i+1),get_value=ech
				tabb[i]=strtrim(ech,2)	
				; t[i-300]=strtrim(ech,2)
			endfor
			
			for i=401,400+n[0] do begin
				widget_control,u(i+1),get_value=ech
				tabb[i]=strtrim(ech,2)
				; rep[i-400]=strtrim(ech,2)
			endfor

			for i=501,500+n[0] do begin
				widget_control,u(i+1),get_value=ech
				tabb[i]=strtrim(ech,2)	
				; sav[i-500]=strtrim(ech,2)
			endfor

			; for i=1,n[0] do begin
			;	ind=tabb(i)
			;	print, 'tabb[', ind,']: ',tabb(600+ind)
			; endfor

			widget_control,ev.top,/destroy
			n=n[0]+1
			tabb[1080]=n
		
			e=string(format='(I2)',n)
			e=strtrim(e,2)
			; print, "n: ",n, " - e: ", e
			none=string(format='(A1)','')

			grille

			; for i=1,n[0] do begin
			;	ind=tabb(i)
			;	print, 'tabb[', ind,']: ',tabb(600+ind)
			; endfor

			widget_control,pos(n),set_value=none
			widget_control,sam(n),set_value=string(none)
			widget_control,pre(n),set_value=string(none)
			widget_control,t(n),set_value='t'
			widget_control,rep(n),set_value='1'
			widget_control,sav(n),set_value='s'
	;----------- INITIALISATION ------------
			for i=1,700 do begin
			  tabb2[i]=tabb[i]
			endfor
			tabb[100+n[0]]='nonenonenone'
	;---------------------------------------
		endif else begin
			widget_control,base182,sensitive=0
		endelse
	endif

	;------------------ delete line button ---------------------------------
	
	if u(0) eq 1009 then begin
	
		b=string(format='(I2)',strtrim(n,2))
		bb=fix(b)
		
		;------ if n > 2 (1 = min nb of samples) -----------
		if b gt 1 then begin
		;---------------------------------------------------


		;------------------ to keep value in memory -------------------	
		
		for i=1,n[0] do begin
		  widget_control,u(i+1),get_value=ech
		  tabb[i]=strtrim(ech,2)
		  ; pos[i]=strtrim(ech,2)
		endfor
		
		for i=101,100+n[0] do begin
		  widget_control,u(i+1),get_value=ech
		  tabb[i]=strtrim(ech,2)
	  	  ind=fix(tabb[i-100])
		  ; sam[i-100]=strtrim(ech,2)
	  	  tabb[ind+600]=strtrim(ech,2)					
		endfor

		for i=201,200+n[0] do begin
		  widget_control,u(i+1),get_value=ech
		  tabb[i]=strtrim(ech,2)
		  ; pre[i-200]=strtrim(ech,2)
		endfor	
	
		for i=301,300+n[0] do begin
		  widget_control,u(i+1),get_value=ech
		  tabb[i]=strtrim(ech,2)	
		  ; t[i-300]=strtrim(ech,2)
		endfor
			
		for i=401,400+n[0] do begin
		  widget_control,u(i+1),get_value=ech
		  tabb[i]=strtrim(ech,2)
		  ; rep[i-400]=strtrim(ech,2)
		endfor

		for i=501,500+n[0] do begin
		  widget_control,u(i+1),get_value=ech
		  tabb[i]=strtrim(ech,2)	
		  ; sav[i-500]=strtrim(ech,2)
		endfor
		;--------------------------------------------------------------
		
		widget_control,ev.top,/destroy
		n=n-1
		tabb[1080]=n

		grille

		for i=1,n[0] do begin
			widget_control,pos(i),set_value=string(tabb[i])
; 2 lines inserted RPM
			ind=fix(tabb(i))
			widget_control,sam(i),set_value=string(tabb[ind+600])
			widget_control,pre(i),set_value=string(tabb[i+200])
			widget_control,t(i),set_value=string(tabb[i+300])
			widget_control,rep(i),set_value=string(tabb[i+400])
			widget_control,sav(i),set_value=string(tabb[i+500])
		endfor
		
		endif else begin

;--------------------------------- ERROR ---------------------------------------

			err2='*** cannot delete the last line ***'
			widget_control,error2,set_value=string(err2)
;-------------------------------------------------------------------------------
		endelse
		
	endif


;------------------ wavelength -------------------------------------------
	
	if u(0) eq 1010 then begin
		widget_control,u(1),get_value=l
		l=strtrim(strmid(l,0,4),2)
		widget_control,u(1),set_value=string(l)
		tabb[1099]=strtrim(l,2)
		for i=1,n[0] do begin
			widget_control,u(i+2),get_value=ech
			tabb[i+200]=strtrim(ech,2)
		endfor
		for i=101,n[0]+100 do begin
			widget_control,u(i+2),get_value=ech
			tabb[i+300-100]=strtrim(ech,2)
		endfor
		for i=201,n[0]+200 do begin
			widget_control,u(i+2),get_value=ech
			tabb[i+400-200]=strtrim(ech,2)
		endfor
		;for i=501,500+n[0] do begin
		;  widget_control,u(i+1),get_value=ech
		;  tabb[i]=strtrim(ech,2)	
		;  sav[i-500]=strtrim(ech,2)
		;endfor

	time_display			
	widget_control,u(302),set_value=time_result_string

;-------------------------------------------------------------------------------
		print,'l= ',l
	endif


;----------------- BUTTON =PRE1 FOR PRESET (PUT THE VALUE OF PRE1 EVERYWHERE) --
	
	if u(0) eq 1004 then begin
		widget_control,u(3),get_value=ech
		tabb[1+200]=strtrim(ech,2)
			
		
		if ev.select eq 1 then begin
			
			for i=1,n[0] do begin
			widget_control,pre(i),set_value=string(ech)
			tabb[i+200]=strtrim(ech,2)
			endfor

			for i=101,n[0]+100 do begin
			widget_control,u(i+2),get_value=string(ech)
			tabb[i+300-100]=strtrim(ech,2)
			endfor


			for i=201,n[0]+200 do begin
			widget_control,u(i+2),get_value=string(ech)
			tabb[i+400-200]=strtrim(ech,2)
			endfor

	time_display
	widget_control,u(302),set_value=time_result_string
	
;-------------------------------------------------------------------------------
	
	
;++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	
		endif
	endif






;----------------- BUTTON =T/M1 FOR T/M (PUT THE VALUE OF T/M1 EVERYWHERE)------
	
	if u(0) eq 1005 then begin
		widget_control,u(3),get_value=ech
		tabb[1+300]=strtrim(ech,2)
			
		
		if ev.select eq 1 then begin
			for i=1,n[0] do begin
				widget_control,t(i),set_value=string(ech)
				tabb[i+300]=strtrim(ech,2)
			endfor

			time_display
			widget_control,u(102),set_value=time_result_string
		endif 
	endif
;-------------------------------------------------------------------------------


;----------------- BUTTON =REP1 FOR REP (PUT THE VALUE OF REP1 EVERYWHERE)------
	if u(0) eq 1006 then begin
		widget_control,u(3),get_value=ech
		tabb[1+400]=ech
		if ev.select eq 1 then begin
			for i=1,n[0] do begin
				widget_control,rep(i),set_value=string(ech)
				tabb[i+400]=ech
			endfor
		endif 
	  	time_display
;		widget_control,u(102),set_value=time_result_string
	endif


;----------------- BUTTON =S/N1 FOR S/N (PUT THE VALUE OF S/N1 EVERYWHERE) -----
	if u(0) eq 1007 then begin
	  widget_control,u(3),get_value=ech
	  tabb[1+500]=strtrim(ech,2)
	  if ev.select eq 1 then begin
	    for i=1,n[0] do begin
	      widget_control,sav(i),set_value=string(ech)
	      tabb[i+500]=strtrim(ech,2)
	    endfor
	  endif 

	  time_display
	  widget_control,u(102),set_value=time_result_string

	endif

;-------------------------------------------------------------------------------
;------------------------ CREATION OF COMMAND FILE -----------------------------
	if u(0) eq 1003 then begin
		widget_control,error2,set_value=''
		print, "n[0]: ", n[0]
		for i=1,n[0] do begin
			widget_control,u(i+1),get_value=ech
			tabb[i]=strtrim(ech,2)
			; print, "tabb[",i,"]: ",tabb[i]
		endfor
		for i=101,100+n[0] do begin
			widget_control,u(i+1),get_value=ech
			tabb[i]=strtrim(ech,2)
			; print, "tabb[",i,"]: ",tabb[i]
		endfor
		for i=201,200+n[0] do begin
			widget_control,u(i+1),get_value=ech
			ech=strtrim(ech,2)
			if strlen(ech[0]) gt 0 then begin
				tabb[i]=strtrim(ech,2)
			endif else begin
				ok=0
;--------------------------------- ERROR ---------------------------------------
			err2='*** no value for the preset field for position '
			widget_control,error2,set_value=string(err2) $
			+string(tabb[i-200])+string(' ***')
;-------------------------------------------------------------------------------
			endelse
			; print, "tabb[",i,"]: ",tabb[i]
		endfor	
		for i=301,300+n[0] do begin
			widget_control,u(i+1),get_value=ech
			if ech[0] eq 't' or ech[0] eq 'm' then begin
				tabb[i]=strtrim(ech,2)
			endif else begin
				ok=0
;--------------------------------- ERROR ---------------------------------------
			err2='*** wrong value for the t/m field for position '
			widget_control,error2,set_value=string(err2) $
			+string(tabb[i-300])+string(' ***')
;-------------------------------------------------------------------------------
			endelse
			; print, "tabb[",i,"]: ",tabb[i]
		endfor
		for i=401,400+n[0] do begin
			widget_control,u(i+1),get_value=ech
			tabb[i]=strtrim(ech,2)
			; print, "tabb[",i,"]: ",tabb[i]
		endfor
		for i=501,500+n[0] do begin
			widget_control,u(i+1),get_value=ech
			if ech[0] eq 's' then begin
				tabb[i]=strtrim(ech,2)
			endif else if ech[0] eq 'n' then begin
				tabb[i]=strtrim(ech,2)
			endif else if ech[0] eq 'x' then begin
				tabb[i]=strtrim(ech,2)
				err2='*** warning: line '+strtrim(string(i),2) $
				+' cancelled ***'
				widget_control,error2,set_value=string(err2)
			endif else begin
				ok=0
;--------------------------------- ERROR ---------------------------------------
			err2='*** wrong value for the s/n field for position '
			widget_control,error2,set_value=string(err2) $
			+string(tabb[i-500])+string(' ***')
;-------------------------------------------------------------------------------
			endelse
			; print, "tabb[",i,"]: ",tabb[i]
		endfor
		for i=1,n[0] do begin
			widget_control,u(i+1),get_value=ech
			ind=fix(strtrim(ech[0],2))
			if ind le 100 and ind gt 0 then begin
				tabb[i]=ind
			endif else begin
				ok=0
;--------------------------------- ERROR ---------------------------------------
				err2='*** position'
				err3=' is out of range ***' 
				widget_control,error2,set_value=string(err2) $
				+string(ech[0])+string(err3)
;-------------------------------------------------------------------------------
			endelse
		endfor
		for i=1,n[0] do begin
			widget_control,u(i+1),get_value=ech
			tabb[i]=ech
			cpt=0
			for j=1,n[0] do begin
				a=strtrim(tabb[i],2)
				b=strtrim(tabb[j],2)
				aa=fix(a)
				bb=fix(b)
				if aa eq bb then begin
					cpt=cpt+1
				endif		
			endfor
			cpt=strtrim(cpt,2)
			if (cpt gt 1) and (ok eq 1) then begin
			;--------------------------------- ERROR ---------------
				err2='*** warning: position '
				widget_control,error2,set_value=string(err2) $
				+string(tabb[i])+string(' is repeated ***')
			;-------------------------------------------------------
				ok2=0
			endif
		endfor
		for i=101,100+n[0] do begin
			widget_control,u(i+1),get_value=ech
			tabb[i]=strtrim(ech,2)
			cpt=0
			for j=1,n[0] do begin
				a3=strtrim(tabb[i],2)
				b3=strtrim(tabb[j],2)
				if a3 eq b3 then begin
					cpt=cpt+1
				endif		
			endfor
			cpt=strtrim(cpt,2)
			if cpt ge 2 and ok eq 1 then begin
			;--------------------------------- ERROR ---------------
			err2='*** warning: position '
			widget_control,error2,set_value=string(err2) $
			+string(tabb[i])+string(' is repeated ***')
			;-------------------------------------------------------
				ok2=0
			endif
		endfor
;-------------------------------------------------------------------------------
		if ok eq 1 then begin
	
;------------------------- TOTAL TIME AND MONITOR (ADD EVERY TIME t AND m) -----
		time_display
;-------------------------------------------------------------------------------

			if ok2 eq 1 then begin			
;---------------------- ERROR --------------------------------------------------
				err2=' '
				widget_control,error2,set_value=string(err2)
				err3=' '
;-------------------------------------------------------------------------------
			endif


;----------------- VALUE OF DATE, TITLE, USER, PROP, LOG BOOK ------------------

			para =DialNewValue(TYPE='t_para',NAME='changer_file')

			user_n=string(para.c_user[0])
			for i=1,9 do begin
			  user_n=user_n+string(para.c_user[i])
			endfor

			prop_n=string(para.proposal_number[0])
			for i=1,7 do begin
			  prop_n=prop_n+string(para.proposal_number[i])
			endfor
	print,para.log_book_n[0], '   ',string(para.log_book_n[0])
;	print,para.log_book_n[1], '   ',string(para.log_book_n[1])

		book_n=string(para.log_book_n[0])+string(para.log_book_n[1])$
				+string(para.log_book_n[2])

			date_n=string(para.exp_start_time[0])
			for i=1,10 do begin
			  date_n=date_n+string(para.exp_start_time[i])
			endfor

			title_n=string(para.c_txt[0])
			for i=1,38 do begin
			title_n=title_n+string(para.c_txt[i])
			endfor
	
			tabb[1022]=user_n  
			tabb[1021]=date_n
			tabb[1023]=prop_n
			tabb[1026]=book_n
			tabb[1020]=title_n

;	print,user_n  
;	print,"date_n: [",date_n,"]"
;	print,prop_n
;	print,book_n
;	print,title_n
;-------------------------------------------------------------------------------


;----------------------------- CALL THE INFO PROCEDURE -------------------------
			info
;-------------------------------------------------------------------------------

		endif
	endif
endelse

end




;*******************************************************************************
;*******************************************************************************
pro grille
;*******************************************************************************
;*******************************************************************************
common nb,n
common tablo,tabb
common tabla,tabu
common nofile,exist_file,ex

common bases,pre,t,rep,sav,pos
common sa,sam

common erreur,error2,error3
common check,chec
common newl,newline
common newbut,base182
common total,ti,m,ti2,tx,txx,time_result_string
common totaltime,ttime			;to calculate total time
common top,changer_based0

pos=strarr(100)
sam=strarr(100)
pre=strarr(100)
t  =strarr(100)
rep=strarr(100)
sav=strarr(100)
;---------------------------------------- BASE CREATION  -----------------------

base0=widget_base(group_leader=changer_based0,title='Command File (4)',/column)

base01=widget_label(base0,frame='5',$
  value='enter all fields - carriage return after every modification')
;base02=widget_label(base0,value='**************')
base00=widget_base(base0,/column)
common errr,err2

;----------------- ERROR -------------------
	if exist_file eq 1 then begin
		err2=string(format='(A80)','')
	endif
	error2=widget_label(base00,value=err2)
	err3=string(format='(I3)','')
;-------------------------------------------


base1=widget_base(base00, /row)
base10=widget_base(base1,/column)
lab0=widget_label(base10,frame=4,value='nb')
base11=widget_base(base1,/column)
pos0=widget_label(base11,frame=4,value='pos')
base12=widget_base(base1,/column)
sam0=widget_label(base12,frame=4,value='samples')
base15=widget_base(base1,/column)
base151=widget_base(base15,/column)
base152=widget_base(base15,/align_center)
pre00=widget_label(base151,frame=4,value='preset')

base13=widget_base(base1,/column)
base131=widget_base(base13,/column)
base132=widget_base(base13,/align_center)

tm00=widget_label(base131,frame=4,value='t/m')

base16=widget_base(base1,/column)
base161=widget_base(base16,/column)
base162=widget_base(base16,/align_center)
rep00=widget_label(base161,frame=4,value='rep')

base17=widget_base(base1,/column)
base171=widget_base(base17,/column)
base172=widget_base(base17,/align_center)
sav00=widget_label(base171,frame=4,value='s/n/x')

base18=widget_base(base1,/column)
base181=widget_base(base18,/column)
base182=widget_base(base18,/column)

base19=widget_base(base0,/column)

n=tabb[1080]
for i=1,n[0] do begin
	txt1=string(format='(I2)',i)
	txt1=strtrim(txt1,2)
	indice=txt1
	txt=string(format='(I2)',tabb[i])
	txt=strtrim(txt,2)
	lab=widget_text(base10,value=indice,xsize=2)
	pos(i)=widget_text(base11,xsize=2,value=txt)
	widget_control,pos(i),/editable
	sam(i)=widget_text(base12,xsize=20,value=tabb(i+100))	
	widget_control,sam(i),/editable
	pre(i)=widget_text(base151,xsize=7)	
	widget_control,pre(i),/editable
	t(i)=widget_text(base131,xsize=1,value='t')
	widget_control,t(i),/editable
	rep(i)=widget_text(base161,xsize=3,value='1')	
	widget_control,rep(i),/editable
	sav(i)=widget_text(base171,xsize=3,value='s')	
	widget_control,sav(i),/editable
endfor

lab11=widget_label(base11,value='')
lab12=widget_label(base12,value='use 1st value for column:')

pre0=widget_button(base152,ysize=20,value='  ')
t0  =widget_button(base132,ysize=20,value='  ')
rep0=widget_button(base162,ysize=20,value='  ')
sav0=widget_button(base172,ysize=20,value='  ')


but14=widget_button(base18,value='add new line')
but15=widget_button(base18,value='delete last')
but13=widget_button(base18,frame=10,value='command file')
but12=widget_button(base18,value='new')
but11=widget_button(base18,value='close')


lambda=cw_field(base19, $
title='enter wavelength for estimation of time (in case of monitor preset): ', $
	xsize=4,value='8',/return_events)

tx=string(format='(I40)','')
tx=strtrim(tx,2)
ttime=widget_label(base19,xsize=800,value=tx)


widget_control,base0,/realize
	
	
;-------------------------------------------------------------------------------
;------------------------------------------ EVENTS -----------------------------


for i=1,n[0] do begin
	txt=string(format='(I2)',i)
	widget_control,pos(i),set_uvalue=[i,pos(i),ttime]
	widget_control,sam(i),set_uvalue=[i+100,sam(i),ttime]
	widget_control,pre(i),set_uvalue=[i+200,pre(i),ttime]
	widget_control,t(i)  ,set_uvalue=[i+300,t(i),ttime]
	widget_control,rep(i),set_uvalue=[i+400,rep(i),ttime]
	widget_control,sav(i),set_uvalue=[i+500,sav(i),ttime]
endfor

widget_control,pre0 ,set_uvalue=[1004,pre0,pre,t,rep,ttime]
widget_control,t0   ,set_uvalue=[1005,t0,t,ttime]
widget_control,rep0 ,set_uvalue=[1006,rep0,rep,ttime]
widget_control,sav0 ,set_uvalue=[1007,sav0,sav,ttime]

widget_control,but11,set_uvalue=[1000,but11,ttime]
widget_control,but12,set_uvalue=[1001,but12,ttime]

widget_control,error2,set_uvalue=[1002,error2]

;--------------------------  with a saved file ---------------
;print,'check',chec

if chec eq 1 then begin

	for i=1,n[0] do begin
		ind=fix(tabb[i])
		ech=tabb[ind+600]
		widget_control,sam(i),set_value=string(ech)
;		tabb[i+600]=strtrim(ech,2)
		widget_control,pos(i),set_value=string(tabb[i])
		widget_control,pre(i),set_value=string(tabb[i+200])
		widget_control,t(i)  ,set_value=string(tabb[i+300])
		widget_control,rep(i),set_value=string(tabb[i+400])
		widget_control,sav(i),set_value=string(tabb[i+500])
	endfor

;------------------- with a new file to create --------------
endif else begin
	print,'n= ',n
	for i=1,n[0] do begin
		;widget_control,pos(i),set_value=string(tabb[i])
		;print,'pos= ',pos(i)
		ind=tabb[i]
;		widget_control,sam(i),set_value=string(tabb[i+100])
		widget_control,sam(i),set_value=string(tabb[ind+600])
		if newline eq 1 then begin
			widget_control,pos(i),set_value=string(tabb[i])
			widget_control,pre(i),set_value=string(tabb[i+200])
			widget_control,t(i)  ,set_value=string(tabb[i+300])
			widget_control,rep(i),set_value=string(tabb[i+400])
			widget_control,sav(i),set_value=string(tabb[i+500])
		endif
	endfor
endelse


;------------- to add a line to the grid ---------------------
widget_control,but14,set_uvalue=[1008,pos,sam,pre,t,rep,sav,ttime]
;-------------------------------------------------------------

;------------- to delete last line of the grid ------------------
widget_control,but15,set_uvalue=[1009,pos,sam,pre,t,rep,sav,ttime]
;-------------------------------------------------------------

widget_control,but13,set_uvalue=[1003,pos,sam,pre,t,rep,sav,ttime]

;-------------------- wavelength -----------------------------
widget_control,lambda,set_uvalue=[1010,lambda,pre,t,rep,ttime]
widget_control,lambda,get_value=l
tabb[1099]=strtrim(l,2)
;-------------------------------------------------------------

;-------------------------- ERROR ------------------------------
if exist_file eq 1 then begin
	err2=' '
	widget_control,error2,set_value=string(err2)
	err3=' '
endif
;---------------------------------------------------------------

;--------------------- CALCULATE DURATION OF EXPERIMENT -------------
time_display
widget_control,ttime,set_value=time_result_string


;----------------------------------------------------------------

xmanager,'grille',base0,/just_reg,group_leader=changer_based0

end
function groupx, win ,by
;******* ******
;**
;** Group canals by by ... (J. COOK)
;** CALL: Wi=groupx(wj [,2])

dim =SIZE(win)

IF dim(0) GE 1 THEN IF dim(1) GE 4 THEN BEGIN

	IF n_elements(by) ne 1 THEN by=2
	by=by>2<(dim(1)/4)

	IF dim(0) EQ 1 THEN wout =FLTARR( dim(1)/by )
	IF dim(0) EQ 2 THEN wout =FLTARR( dim(1)/by ,dim(2) )
			    xout =wout(*,0)
;	Take all parameters
;	**** *** **********
	TAKE_DATP,P

	FOR i=0,dim(1)/by-1 DO BEGIN j=i*by
	    IF dim(0) EQ 1 THEN wout(i)  = total(win(j:j+by-1  ))
	    IF dim(0) EQ 2 THEN wout(i,*)= total(win(j:j+by-1,*),1)
				xout(i)  = total(P.x(j:j+by-1  ))/by
	ENDFOR

;	Errors
;	******
	IF n_elements(P.e) eq n_elements(win) then begin
	FOR i=0,dim(1)/by-1 DO BEGIN j=i*by
	    IF dim(0) EQ 1 THEN P.e(i)   = total(P.e(j:j+by-1  )^2)
	    IF dim(0) EQ 2 THEN P.e(i,*) = total(P.e(j:j+by-1,*)^2,1)
	ENDFOR
	P.e=SQRT(P.e)
	ENDIF

;	Give back parameters
;	**** **** **********
	P.X_TIT  =P.X_TIT+' (group*'+strtrim(string(by),2)+')'
	MOD_DATP ,P,'X'    ,xout	;P.X=xout is the normal formulation but it
					;d'nt work (because the size changed)
	GIVE_DATP,P			;Give back

	RETURN,wout
ENDIF

P_MUS ,'mus_cannon'
RETURN, win
END

pro groupy, w,y,e ,AVERAGE=average
;** ******
;**
;** To group spectra (w) having the same ordinate (y)
;** Spectra are added.

d=100 ;means check only 2 decimals

;** Check concistencies
    sw=SIZE(w)
    sy=SIZE(y)
    IF sw(0) eq 2 THEN IF sw(2) eq sy(1) THEN BEGIN

	IF n_elements(e) eq n_elements(w) THEN r=1 else r=0
	IF r THEN E=E^2
	flg =lonarr(sy(1))+1
	wout=w*0 & wout(*,0)=w(*,0)
	yout=y*0 & yout  (0)=y  (0)
	j   =  0

	FOR i=1,sy(1)-1 DO BEGIN

	    IF  round(y(i)*d) eq round(yout(j)*d) THEN BEGIN
		wout(*,j)= wout(*,j)+w(*,i)
		IF r THEN  E   (*,j)=E(*,j)+w(*,i)
		flg(j)=flg(j)+1

	    ENDIF ELSE BEGIN
		j=j+1
		wout(*,j)=w(*,i)
		yout(  j)=y(  i)
		IF r THEN E(*,j)=E(*,i)
	    ENDELSE
	ENDFOR

	IF r THEN E=SQRT(E)

	IF keyword_set(average) THEN FOR i=0,j DO BEGIN
					wout(*,i)=wout(*,i)/flg(i)
					IF r THEN E   (*,i)=E(*,i)/flg(i)
				     ENDFOR
	w=wout(*,0:j)
	y=yout(  0:j)
	IF r THEN E=E(*,0:j)

    ENDIF
RETURN
END
	FUNCTION grund_mask, w_in0, skip

; takes a 2-d SANS workspace and creates a mask, removing points 
; greater than 2 standard devs from mean.  Should be run on back-
; ground substracted water runs.
; Skip stops from saving to file


;						JRS 13/6/00

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start mask:'

	ON_IOERROR, finished

	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspace

	x_in0=datp.x
	y_in0=datp.y
	z_in0=datp.z
	e_in0=datp.e
	par=datp.p
	parv=datp.pv
	se=SIZE(e_in0)
	sw=SIZE(w_in0)

	IF (sw(0) EQ 3) THEN nruns=sw(3) ELSE nruns=1
	IF (nruns EQ 1) THEN parv=par
	nspectra=sw(1)
	IF(iprint GT 0) THEN PRINT, 'nspectra = ',nspectra

	IF (N_ELEMENTS(skip) EQ 0) THEN skip=0

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'


;-------------------------------------------------------------------------------
;       Find low/high points and make mask

	av=MEAN(w_in0)
	sd3=3*MEANABSDEV(w_in0)
	sd2=2*MEANABSDEV(w_in0)
	sd1=MEANABSDEV(w_in0)
	min=av-sd2
	max=av+sd2

	i=WHERE(w_in0 LT min, nmin)
	j=WHERE(w_in0 GT max, nmax)

	w_out=FLTARR(nspectra,nspectra)+1
	e_out=FLTARR(nspectra,nspectra)
	IF(N_ELEMENTS(i) GT 1) THEN BEGIN
		w_out(i)=0	& e_out(i)=-1
	ENDIF
	IF(N_ELEMENTS(j) GT 1) THEN BEGIN	
		w_out(j)=0	& e_out(j)=-1
	ENDIF
	x_out=x_in0
	y_out=y_in0

	IF (iprint GT 0) THEN PRINT,'End of "Create Mask" section'

;-------------------------------------------------------------------------------
;Write to mask file

	ispec=INDGEN(nspectra^2)+1

	numor=STRTRIM(STRING(LONG(datp.p(26))),2)
	title='Mask created from #'+numor

	IF (skip NE 0) THEN GOTO, dontsave

	out_file='mask_'+numor+'.dat'
	PRINT,'Writing mask file: ',out_file
	OPENW, 1, out_file
	PRINTF, 1, title
	PRINTF, 1, 'Spectrum     X	Y     1/0       0/-1'
	FOR i=0,nspectra-1 DO BEGIN
		FOR j=0,nspectra-1 DO BEGIN
			PRINTF, 1, FORMAT='(I7,1X,F5.1,1X,F5.1,2I4)', $
				ispec((j+1)+(i*nspectra)-1), x_out(i), y_out(j), w_out(i,j), e_out(i,j)
		ENDFOR
	ENDFOR
	CLOSE, 1


dontsave:
	IF (iprint GT 0) THEN PRINT,'End of "Write to mask file" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "e", e_out

	datp.w_tit=title
	datp.other_tit=datp.other_tit+' -ma'
	datp.y_tit='Intensity'

finished:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'End mask:'

	give_datp, datp

	RETURN, w_out
	END

FUNCTION hkl,max,F=F,I=I,A=A,B=B,C=C,screw=screw,glide=glide,n=n,d=d,cubic=cubic,si=si
;+
; Si : h=hkl(8,/F,/cub,d=[1,0,0])
;-
IF NOT KEYWORD_SET(max) THEN max=9
IF KEYWORD_SET(si) THEN BEGIN
  F=1
  I=0
  A=0
  B=0
  C=0
  screw=0
  glide=0
  n=0
  d=[1,0,0]
  cubic=1
ENDIF
all=[0,0,0]
FOR h=0,max DO FOR k=0,max DO FOR l=0,max DO all=[[all],[h,k,l]]
all=all(*,2:N_ELEMENTS(all(0,*))-1)
IF KEYWORD_SET(F) THEN BEGIN
  A=1
  B=1
  C=1
ENDIF
IF KEYWORD_SET(I) THEN BEGIN
  new=[0,0,0]
  FOR j=0,N_ELEMENTS(all(0,*))-1 DO IF (TOTAL(all(*,j)) MOD 2) EQ 0 THEN new=[[new],[all(*,j)]]
  all=new(*,1:N_ELEMENTS(new(0,*))-1)
ENDIF
IF KEYWORD_SET(A) THEN BEGIN
  new=[0,0,0]
  FOR j=0,N_ELEMENTS(all(0,*))-1 DO IF (TOTAL(all(1:2,j)) MOD 2) EQ 0 THEN new=[[new],[all(*,j)]]
  all=new(*,1:N_ELEMENTS(new(0,*))-1)
ENDIF
IF KEYWORD_SET(B) THEN BEGIN
  new=[0,0,0]
  FOR j=0,N_ELEMENTS(all(0,*))-1 DO IF (TOTAL(all([0,2],j)) MOD 2) EQ 0 THEN new=[[new],[all(*,j)]]
  all=new(*,1:N_ELEMENTS(new(0,*))-1)
ENDIF
IF KEYWORD_SET(C) THEN BEGIN
  new=[0,0,0]
  FOR j=0,N_ELEMENTS(all(0,*))-1 DO IF (TOTAL(all(0:1,j)) MOD 2) EQ 0 THEN new=[[new],[all(*,j)]]
  all=new(*,1:N_ELEMENTS(new(0,*))-1)
ENDIF
IF KEYWORD_SET(screw) THEN IF N_ELEMENTS(screw) EQ 3 THEN BEGIN
  all=all(*,WHERE(all(0,*) MOD screw(0) EQ 0 OR TOTAL(all([1,2],*),1) NE 0))
  all=all(*,WHERE(all(1,*) MOD screw(1) EQ 0 OR TOTAL(all([0,2],*),1) NE 0))
  all=all(*,WHERE(all(2,*) MOD screw(2) EQ 0 OR TOTAL(all([1,0],*),1) NE 0))
ENDIF
IF KEYWORD_SET(glide) THEN IF N_ELEMENTS(glide) EQ 3 THEN BEGIN
  IF glide(0) THEN all=all(*,WHERE(all(glide(0)-1,*) MOD 2 EQ 0 OR all(0,*) NE 0))
  IF glide(1) THEN all=all(*,WHERE(all(glide(1)-1,*) MOD 2 EQ 0 OR all(1,*) NE 0))
  IF glide(2) THEN all=all(*,WHERE(all(glide(2)-1,*) MOD 2 EQ 0 OR all(2,*) NE 0))
ENDIF
IF KEYWORD_SET(n) THEN IF N_ELEMENTS(n) EQ 3 THEN BEGIN
  IF n(0) THEN all=all(*,WHERE(TOTAL(all([1,2],*),1) MOD 2 EQ 0 OR all(0,*) NE 0))
  IF n(1) THEN all=all(*,WHERE(TOTAL(all([0,2],*),1) MOD 2 EQ 0 OR all(1,*) NE 0))
  IF n(2) THEN all=all(*,WHERE(TOTAL(all([1,0],*),1) MOD 2 EQ 0 OR all(2,*) NE 0))
ENDIF
IF KEYWORD_SET(d) THEN IF N_ELEMENTS(d) EQ 3 THEN BEGIN
  IF d(0) THEN all=all(*,WHERE(TOTAL(all([1,2],*),1) MOD 4 EQ 0 OR all(0,*) NE 0))
  IF d(1) THEN all=all(*,WHERE(TOTAL(all([0,2],*),1) MOD 4 EQ 0 OR all(1,*) NE 0))
  IF d(2) THEN all=all(*,WHERE(TOTAL(all([1,0],*),1) MOD 4 EQ 0 OR all(2,*) NE 0))
ENDIF
h=all
IF KEYWORD_SET(cubic) THEN h=h(*,WHERE(h(0,*) le h(1,*) and h(1,*) le h(2,*)))
h=h(*,sort((max+1)*(max+1)*h(0,*)+(max+1)*h(1,*)+h(2,*)))
RETURN,h
END
PRO holland,filename

@lamp.cbk
OPENR,unit,/get,filename
i=0
numors=' '
subnum=' '
WHILE NOT EOF(unit) DO BEGIN
READF, unit, numors
READF, unit, subnum

PRINT,"W1=num2merg(["+numors+"],/sdev,min=10,bin=.3,sub=["+subnum+"],/nopr)"
PRINT,"d20reg,w1,'dhm"+STRCOMPRESS(i,/REM)+"',par=indgen(39)"

XICUTE,"W1=num2merg(["+numors+"],/sdev,min=10,bin=.3,sub=["+subnum+"],/nopr)"
XICUTE,"d20reg,w1,'dhm"+STRCOMPRESS(i,/REM)+"',par=indgen(39)"
i=i+1
ENDWHILE

FREE_LUN,unit

END
; IDL Version 4.0.1 (IRIX mipseb)
; Journal File for hansen@d20sgi.ill.fr
; Working directory: /users/dif/hansen/lambda/983/defil
; Date: Wed Jul  8 10:41:10 1998
 
plotdfil,0,40.1,mul=5,/ps,pr='dj1_d20',thr=t,/por,scal=2.5,ysi=26,xoffs=1,yoffs=-0.5,inten=1000.,fwh=width,posi=pos,cel=cell,ov=.1,inters=is,interw=iw
;Create def_0_401.ps XSIZE=      20.4500 cm
;       1      0.00000      8.18000      8.18000          -2          81      83.4000
;   cell, integral, left, center, right, fwhm
;           1    -0.138281    0.0537944     0.178762     0.317043   -0.0462056      35819.1      1118.45
;           2    -0.146574    0.0922954     0.263293     0.409867    -0.107705      50485.2      1271.57
;           3     0.319920     0.159132     0.391879    0.0719587    -0.140868      128372.      2679.71
;           4     0.281492     0.205839     0.446791     0.165298    -0.194161      123815.      3323.10
;           5     0.201654     0.408531     0.584800     0.383145   -0.0914689      254184.      6398.48
;           6     0.423830     0.570380     0.695350     0.271520   -0.0296199      283049.      9648.06
;           7     0.592007     0.701791     0.803043     0.211036   0.00179094      291306.      12276.7
;           8     0.730291     0.818709     0.895817     0.165527    0.0187088      251656.      13495.9
;           9     0.844796     0.922421     0.986559     0.141762    0.0224206      237982.      14188.7
;          10     0.952560      1.02345      1.08377     0.131205    0.0234536      234314.      15437.8
;          11      1.05368      1.12441      1.18062     0.126936    0.0244067      230655.      15770.2
;          12      1.15383      1.22626      1.28460     0.130768    0.0262562      236546.      15839.2
;          13      1.26159      1.33026      1.38785     0.126251    0.0302591      238845.      16242.5
;          14      1.36388      1.43518      1.49358     0.129702    0.0351833      236550.      16000.7
;          15      1.47101      1.53957      1.59723     0.126225    0.0395740      235974.      16090.9
;          16      1.57291      1.64548      1.70502     0.132108    0.0454843      235022.      15680.5
;          17      1.68163      1.75026      1.80961     0.127984    0.0502642      233697.      15943.5
;          18      1.78402      1.85454      1.91335     0.129327    0.0545433      226247.      15648.3
;          19      1.88288      1.95255      2.01315     0.130263    0.0525512      243335.      15850.3
;          20      1.99039      2.05775      2.11986     0.129466    0.0577543      242885.      15726.0
;          21      2.09385      2.16542      2.22803     0.134172    0.0654182      242976.      15642.9
;          22      2.20141      2.27573      2.34361     0.142206    0.0757277      247233.      15058.2
;          23      2.31121      2.38627      2.45553     0.144315    0.0862720      237478.      14209.3
;          24      2.41294      2.48961      2.56001     0.147067    0.0896084      233536.      13348.7
;          26      2.75079      2.81702      2.89308     0.142289     0.217020      218483.      12654.2
;          27      2.85280      2.92377      3.01549     0.162691     0.223775      241117.      12319.0
;          28      2.79003      2.94454      3.11547     0.325436     0.144538      121825.      3341.04
;          29      2.94318      3.01806      3.11345     0.170269     0.118059      32045.6      1329.44
;          30      3.04573      3.12267      3.22417     0.178437     0.122670      40465.1      1716.36
;          31      3.06439      3.18277      3.28400     0.219611    0.0827663      16512.6      696.495
;          32      2.92231      3.10804      3.21332     0.291009   -0.0919645      89850.9      2465.15
;          33      2.96468      3.15216      3.37014     0.405460    -0.147838      82891.4      2352.47
;          34      3.07616      3.18496      3.25297     0.176817    -0.215038      235487.      12005.4
;          35      3.24454      3.34555      3.40713     0.162593    -0.154455      253057.      13071.3
;          36      3.40289      3.49071      3.55274     0.149855    -0.109290      239122.      13640.4
;          37      3.53446      3.61955      3.68357     0.149114   -0.0804453      242114.      14326.9
;          38      3.66435      3.74478      3.80891     0.144556   -0.0552249      252998.      15514.8
;          39      3.78456      3.85906      3.92114     0.136580   -0.0409365      248248.      16069.8
;          40      3.90124      3.97170      4.03301     0.131769   -0.0282991      255039.      16644.2
;          41      4.01035      4.07945      4.13918     0.128828   -0.0205498      241170.      16168.5
;          42      4.12266      4.19382      4.24964     0.126977  -0.00617504      246789.      16753.4
;          43      4.23143      4.30142      4.35015     0.118717   0.00141811      235073.      15922.3
;          44      4.33322      4.39396      4.44097     0.107749  -0.00604439      236370.      17319.4
;          45      4.41241      4.48083      4.53340     0.120985   -0.0191655      224596.      14817.4
;          46      4.51210      4.57802      4.63666     0.124563   -0.0219808      245734.      16457.0
;          47      4.62023      4.68649      4.74360     0.123374   -0.0135136      228180.      16633.6
;          48      4.72447      4.79439      4.85129     0.126824  -0.00561428      224452.      16447.6
;          49      4.83237      4.90251      4.96037     0.127994   0.00250769      224174.      16176.6
;          50      4.94051      5.00903      5.06094     0.120435   0.00903463      219993.      15954.1
;          51      5.04077      5.10818      5.16237     0.121600   0.00817633      241634.      15908.1
;          52      5.13259      5.19230      5.23801     0.105420  -0.00769901      238610.      18304.9
;          53      5.22099      5.28294      5.34043     0.119431   -0.0170612      226182.      15721.9
;          54      5.32217      5.38840      5.44364     0.121475   -0.0116043      226406.      16593.9
;          55      5.43056      5.49509      5.55030     0.119740  -0.00491285      230034.      16917.1
;          56      5.53329      5.60191      5.65752     0.124224   0.00191164      226324.      16530.1
;          57      5.64228      5.71009      5.76503     0.122749    0.0100889      225908.      16485.9
;          58      5.74354      5.81247      5.86950     0.125963    0.0124707      224698.      16315.6
;          59      5.85305      5.92062      5.97754     0.124485    0.0206223      228691.      16544.9
;          60      5.95523      6.02658      6.08265     0.127418    0.0265799      229459.      16494.1
;          61      6.07131      6.13971      6.19623     0.124924    0.0397091      228343.      16139.2
;          62      6.18039      6.24625      6.30180     0.121406    0.0462461      234289.      16214.9
;          63      6.24267      6.29795      6.34258    0.0999107  -0.00204563      72002.9      6070.91
;          64      6.28334      6.35752      6.41952     0.136188   -0.0424786      237914.      15538.3
;          65      6.39027      6.46096      6.52293     0.132659   -0.0390415      233727.      15504.6
;          66      6.50286      6.57344      6.63368     0.130816   -0.0265574      234482.      16230.6
;          67      6.61442      6.68618      6.74465     0.130233   -0.0138154      226426.      15928.6
;          68      6.72067      6.78572      6.84334     0.122669   -0.0142827      224556.      16188.6
;          69      6.82189      6.88734      6.94302     0.121136   -0.0126572      219169.      16094.5
;          70      6.93040      6.99437      7.05075     0.120354  -0.00563145      220246.      16086.5
;          71      7.02241      7.09105      7.14662     0.124214  -0.00895262      218196.      15850.5
;          72      7.13108      7.19649      7.25387     0.122795  -0.00351477      218701.      15764.5
;          73      7.23254      7.29708      7.35283     0.120286  -0.00292301      216457.      16018.4
;          74      7.33243      7.39793      7.45112     0.118692  -0.00206995      218928.      15792.0
;          75      7.43208      7.49832      7.55306     0.120981  -0.00168037      217921.      15579.4
;          76      7.53283      7.59721      7.65351     0.120680  -0.00279236      228209.      16299.1
;          77      7.63370      7.70278      7.75504     0.121342   0.00277758      212245.      16733.5
;          78      7.88714      7.90720      8.04988     0.162744     0.107198      212104.      9628.00
;          79      7.83437      7.90087      7.95416     0.119786  0.000869751      233664.      17893.3
;          80      7.74041      7.87420      7.85008     0.109671    -0.125798      215888.      9882.05
;          81      8.03394      8.09873      8.15486     0.120915  -0.00127316      233255.      17269.0
;       2      7.98000      16.1600      8.18000          77         160      83.4000
;   cell, integral, left, center, right, fwhm
;          82      8.13316      8.20230      8.25748     0.124318   0.00229740      212765.      16105.6
;          83      8.24078      8.30413      8.35901     0.118237   0.00412750      201822.      15469.2
;          84      8.34083      8.40485      8.45968     0.118854   0.00484848      204517.      15801.5
;          85      8.43586      8.50538      8.55873     0.122875   0.00537682      203103.      15540.2
;          86      8.54130      8.60636      8.66251     0.121202   0.00635529      206616.      15620.2
;          87      8.64222      8.71108      8.76720     0.124981    0.0110807      212560.      15867.0
;          88      8.74389      8.81219      8.86664     0.122746    0.0121880      209087.      15771.1
;          89      8.84406      8.91344      8.96728     0.123225    0.0134449      211201.      15725.8
;          90      8.94334      9.01135      9.06746     0.124116    0.0113468      207619.      15540.3
;          91      9.05113      9.11571      9.17271     0.121582    0.0157137      209937.      15570.3
;          92      9.14402      9.21377      9.26901     0.124984    0.0137739      207374.      15504.8
;          93      9.25116      9.31820      9.37457     0.123406    0.0181999      209129.      15702.6
;          94      9.35204      9.41944      9.47516     0.123113    0.0194435      210250.      15393.4
;          95      9.45329      9.52157      9.57611     0.122818    0.0215712      210666.      15217.6
;          96      9.55051      9.61908      9.67529     0.124778    0.0190783      210884.      14738.8
;          97      9.65355      9.72197      9.77866     0.125102    0.0219660      216659.      15079.7
;          98      9.75326      9.82052      9.87854     0.125279    0.0205164      209912.      14755.0
;          99      9.85268      9.91806      9.97134     0.118663    0.0180607      203769.      14819.0
;         100      9.95098      10.0186      10.0747     0.123766    0.0185862      207579.      14000.9
;         101      10.0306      10.0890      10.1423     0.111710   -0.0109911      193303.      14148.8
;         102      10.1135      10.1786      10.2347     0.121238   -0.0213900      207273.      14652.7
;         103      10.2115      10.2731      10.3313     0.119824   -0.0269184      202789.      14991.8
;         104      10.3114      10.3760      10.4335     0.122142   -0.0239553      213704.      15961.3
;         105      10.4129      10.4799      10.5374     0.124408   -0.0200577      212030.      16004.2
;         106      10.5146      10.5835      10.6407     0.126097   -0.0164766      214637.      16081.3
;         107      10.6107      10.6760      10.7334     0.122686   -0.0240459      213723.      15906.9
;         108      10.7124      10.7781      10.8344     0.121994   -0.0219212      211339.      15993.0
;         109      10.8126      10.8801      10.9374     0.124761   -0.0199223      212425.      16107.3
;         110      10.9203      10.9825      11.0388     0.118572   -0.0174532      210510.      16187.9
;         111      11.0154      11.0834      11.1383     0.122881   -0.0166035      208765.      16090.3
;         112      11.1201      11.1847      11.2413     0.121195   -0.0153017      210140.      16008.1
;         113      11.2221      11.2864      11.3406     0.118505   -0.0135565      209698.      16104.1
;         114      11.3215      11.3878      11.4446     0.123065   -0.0121927      209857.      16042.1
;         115      11.4233      11.4896      11.5452     0.121852   -0.0104151      210299.      16148.7
;         116      11.5236      11.5910      11.6472     0.123575  -0.00904369      211923.      15801.7
;         117      11.6135      11.6815      11.7377     0.124134   -0.0184660      217171.      16070.5
;         118      11.7143      11.7824      11.8386     0.124269   -0.0176125      216464.      16044.6
;         119      11.8147      11.8831      11.9375     0.122888   -0.0168667      217703.      16240.1
;         120      11.9203      11.9833      12.0382     0.117890   -0.0166779      216159.      16112.6
;         121      12.0206      12.0837      12.1388     0.118132   -0.0162535      216385.      15872.4
;         122      12.1150      12.1830      12.2385     0.123503   -0.0169592      214350.      15846.3
;         123      12.2131      12.2820      12.3372     0.124034   -0.0180082      214859.      15550.5
;         124      12.3133      12.3810      12.4356     0.122330   -0.0189753      215040.      15366.4
;         125      12.4126      12.4765      12.5298     0.117137   -0.0235157      202577.      14802.8
;         126      12.5034      12.5754      12.6353     0.131881   -0.0245705      244795.      16025.8
;         127      12.6107      12.6733      12.7280     0.117276   -0.0266628      207073.      14940.0
;         128      12.7041      12.7712      12.8280     0.123850   -0.0287895      213729.      15242.0
;         129      12.8031      12.8697      12.9259     0.122827   -0.0302753      212951.      15553.5
;         130      12.9007      12.9660      13.0234     0.122705   -0.0339899      215920.      15827.2
;         131      13.0016      13.0664      13.1216     0.120004   -0.0336313      214272.      15912.8
;         132      13.1018      13.1666      13.2218     0.120034   -0.0334044      212409.      15906.9
;         133      13.2034      13.2699      13.3262     0.122766   -0.0300932      214382.      16030.6
;         134      13.3029      13.3704      13.4266     0.123662   -0.0295515      216272.      16194.3
;         135      13.4042      13.4709      13.5273     0.123071   -0.0290537      214267.      16052.1
;         136      13.5044      13.5718      13.6284     0.124030   -0.0281849      214349.      15969.9
;         137      13.6105      13.6743      13.7288     0.118332   -0.0257196      214333.      15969.2
;         138      13.7044      13.7724      13.8288     0.124384   -0.0276127      212373.      15840.9
;         139      13.8101      13.8719      13.9279     0.117820   -0.0281057      213051.      16060.3
;         140      13.9102      13.9727      14.0290     0.118772   -0.0272684      214765.      16082.9
;         141      14.0053      14.0737      14.1302     0.124913   -0.0262747      212413.      15918.1
;         142      14.1109      14.1741      14.2316     0.120762   -0.0259247      214273.      16076.1
;         143      14.2122      14.2779      14.3337     0.121490   -0.0221148      211233.      15646.5
;         144      14.3119      14.3783      14.4345     0.122590   -0.0217209      212516.      15721.4
;         145      14.4133      14.4794      14.5342     0.120914   -0.0205851      212289.      16018.8
;         146      14.5134      14.5807      14.6367     0.123277   -0.0193167      212176.      15872.4
;         147      14.6144      14.6814      14.7360     0.121583   -0.0185642      211489.      16025.8
;         148      14.7134      14.7803      14.8353     0.121841   -0.0196753      213787.      15859.9
;         149      14.8140      14.8818      14.9372     0.123214   -0.0182467      216991.      16073.3
;         150      14.9141      14.9822      15.0371     0.122995   -0.0178442      211092.      15841.1
;         151      15.0211      15.0841      15.1391     0.118015   -0.0159168      210892.      15982.0
;         152      15.1201      15.1840      15.2400     0.119863   -0.0160131      214879.      15928.4
;         153      15.2212      15.2856      15.3414     0.120174   -0.0144110      213755.      15915.9
;         154      15.3211      15.3868      15.4433     0.122257   -0.0131836      212656.      15770.9
;         155      15.4217      15.4888      15.5462     0.124482   -0.0111799      214226.      15734.4
;         156      15.5226      15.5908      15.6474     0.124801  -0.00915623      213500.      15826.8
;         157      15.6223      15.6919      15.7483     0.126060  -0.00814819      217200.      15752.6
;         158      15.7230      15.7944      15.8526     0.129645  -0.00558186      218055.      15528.2
;         159      15.8241      15.8972      15.9557     0.131574  -0.00282478      219910.      15360.9
;         160      15.9240      15.9960      16.0546     0.130564  -0.00399971      215896.      15123.9
;       3      15.9600      24.1400      8.18000         156         239      83.4000
;   cell, integral, left, center, right, fwhm
;         161      16.0244      16.0957      16.1569     0.132500  -0.00432396      215479.      15145.7
;         162      16.1243      16.1962      16.2570     0.132660  -0.00377655      219500.      15380.4
;         163      16.2302      16.3006      16.3621     0.131884  0.000646591      218166.      15113.0
;         164      16.3321      16.4099      16.4754     0.143219   0.00994110      220348.      14312.4
;         165      16.4331      16.5168      16.5872     0.154041    0.0167732      219106.      13285.1
;         166      16.5225      16.5983      16.6585     0.136055  -0.00170135      201689.      12570.4
;         167      16.6136      16.6934      16.7604     0.146797  -0.00660706      253353.      15079.4
;         168      16.7016      16.7688      16.8185     0.116930   -0.0312233      168961.      11997.3
;         169      16.7808      16.8483      16.9074     0.126654   -0.0516624      233573.      14883.9
;         170      16.8528      16.9214      16.9843     0.131575   -0.0786247      193441.      13104.2
;         171      16.9511      17.0225      17.0829     0.131832   -0.0774899      222246.      14793.6
;         172      17.0521      17.1274      17.1931     0.141039   -0.0726128      246250.      15879.7
;         173      17.1706      17.2405      17.2999     0.129230   -0.0594578      229878.      16121.1
;         174      17.2754      17.3474      17.4054     0.130026   -0.0525627      224468.      16106.2
;         175      17.3836      17.4527      17.5091     0.125532   -0.0472889      228663.      16666.2
;         176      17.4909      17.5577      17.6155     0.124599   -0.0423489      228738.      16382.2
;         177      17.5930      17.6605      17.7170     0.123980   -0.0394650      219012.      16219.7
;         178      17.6940      17.7635      17.8194     0.125422   -0.0365028      221739.      16285.1
;         179      17.8010      17.8661      17.9226     0.121643   -0.0339451      220140.      16071.5
;         180      17.9019      17.9672      18.0239     0.122047   -0.0328369      224318.      16127.0
;         181      18.0026      18.0690      18.1249     0.122227   -0.0310173      216085.      15815.5
;         182      18.1031      18.1695      18.2272     0.124136   -0.0305195      219768.      15959.6
;         183      18.2039      18.2716      18.3278     0.123911   -0.0284004      216931.      15990.4
;         184      18.3037      18.3716      18.4271     0.123396   -0.0283794      215948.      15773.8
;         185      18.4040      18.4725      18.5282     0.124243   -0.0274773      217379.      15632.0
;         186      18.5041      18.5722      18.6272     0.123047   -0.0278149      213600.      15557.1
;         187      18.6101      18.6731      18.7282     0.118074   -0.0269489      211529.      15350.0
;         188      18.7025      18.7682      18.8228     0.120270   -0.0318012      211601.      15327.2
;         189      18.8020      18.8681      18.9241     0.122145   -0.0319328      211329.      14959.0
;         190      18.8933      18.9606      19.0164     0.123165   -0.0394077      210134.      14898.8
;         191      18.9903      19.0529      19.1119     0.121626   -0.0470562      211616.      14736.8
;         192      19.0840      19.1520      19.2087     0.124722   -0.0480385      215429.      15142.5
;         193      19.1905      19.2532      19.3087     0.118216   -0.0468311      214702.      15456.6
;         194      19.2850      19.3535      19.4088     0.123812   -0.0464783      213266.      15494.8
;         195      19.3851      19.4546      19.5122     0.127085   -0.0454273      215992.      15652.1
;         196      19.4854      19.5553      19.6124     0.126987   -0.0446644      214496.      15607.9
;         197      19.5914      19.6559      19.7095     0.118147   -0.0440693      213069.      15709.6
;         198      19.6906      19.7563      19.8098     0.119242   -0.0436974      212510.      15621.0
;         199      19.7920      19.8576      19.9142     0.122225   -0.0424156      214553.      15652.9
;         200      19.8930      19.9584      20.0155     0.122486   -0.0416489      212436.      15550.9
;         201      19.9934      20.0586      20.1150     0.121628   -0.0414066      211410.      15803.4
;         202      20.0936      20.1598      20.2165     0.122877   -0.0401783      213328.      15788.7
;         203      20.2212      20.2851      20.3409     0.119747   -0.0148888      211510.      15344.5
;         204      20.3218      20.3856      20.4414     0.119595   -0.0143833      213332.      15426.5
;         205      20.4224      20.4871      20.5436     0.121216   -0.0128822      212872.      15422.5
;         206      20.5226      20.5886      20.6431     0.120577   -0.0114155      211136.      15301.7
;         207      20.6208      20.6824      20.7372     0.116434   -0.0176334      212508.      15399.9
;         208      20.7209      20.7828      20.8377     0.116783   -0.0171909      211894.      15421.5
;         209      20.8231      20.8893      20.9442     0.121046   -0.0106602      211711.      15501.4
;         210      20.9214      20.9839      21.0366     0.115206   -0.0161476      210944.      15463.7
;         211      21.0153      21.0839      21.1379     0.122583   -0.0160770      214022.      15243.9
;         212      21.1301      21.1913      21.2467     0.116602  -0.00873566      209382.      15259.3
;         213      21.2206      21.2856      21.3402     0.119549   -0.0143585      213034.      15380.8
;         214      21.3207      21.3856      21.4389     0.118210   -0.0143909      213490.      15364.0
;         215      21.4210      21.4871      21.5409     0.119860   -0.0129128      215210.      15503.3
;         216      21.5224      21.5881      21.6432     0.120840   -0.0119267      212515.      15403.3
;         217      21.6238      21.6902      21.7436     0.119850  -0.00984573      212555.      15356.0
;         218      21.7230      21.7917      21.8479     0.124834  -0.00832939      217219.      15151.6
;         219      21.8220      21.8897      21.9441     0.122055   -0.0103111      213410.      15555.1
;         220      21.9231      21.9908      22.0452     0.122082  -0.00921059      211007.      15275.8
;         221      22.0238      22.0911      22.1461     0.122349  -0.00886154      211796.      15630.5
;         222      22.1237      22.1928      22.2490     0.125349  -0.00719643      213793.      14919.1
;         223      22.2235      22.2941      22.3500     0.126505  -0.00586700      216224.      14667.6
;         224      22.3221      22.3907      22.4475     0.125431  -0.00931168      211425.      14475.6
;         225      22.4215      22.4881      22.5453     0.123789   -0.0119076      217415.      14658.9
;         226      22.5212      22.5864      22.6426     0.121378   -0.0135670      213573.      14728.9
;         227      22.6212      22.6849      22.7403     0.119062   -0.0151310      209177.      14858.7
;         228      22.7205      22.7829      22.8383     0.117830   -0.0170708      211966.      15119.4
;         229      22.8220      22.8874      22.9447     0.122742   -0.0125847      223820.      15403.6
;         230      22.9117      22.9758      23.0296     0.117893   -0.0241508      222226.      16023.2
;         231      23.0059      23.0765      23.1340     0.128042   -0.0235062      224573.      15418.2
;         232      23.1120      23.1788      23.2336     0.121599   -0.0211926      227682.      15500.5
;         233      23.2127      23.2797      23.3359     0.123262   -0.0203362      226964.      15500.5
;         234      23.3205      23.3801      23.4355     0.114994   -0.0198956      225858.      15515.8
;         235      23.4204      23.4808      23.5373     0.116972   -0.0191917      224685.      15348.9
;         236      23.5205      23.5821      23.6385     0.117998   -0.0178585      225219.      15440.8
;         237      23.6209      23.6839      23.7401     0.119156   -0.0161362      224056.      15417.8
;         238      23.7108      23.7808      23.8316     0.120802   -0.0191593      231792.      15704.8
;         239      23.8114      23.8813      23.9315     0.120150   -0.0187092      246349.      16352.5
;       4      23.9400      32.1200      8.18000         235         318      83.4000
;   cell, integral, left, center, right, fwhm
;         240      23.9229      23.9860      24.0423     0.119322   -0.0140209      219340.      15485.8
;         241      24.0130      24.0844      24.1350     0.121990   -0.0155506      240219.      16461.0
;         242      24.1232      24.1881      24.2458     0.122532   -0.0119419      214992.      15320.0
;         243      24.2136      24.2873      24.3375     0.123953   -0.0126534      239704.      16101.3
;         244      24.3200      24.3878      24.4372     0.117176   -0.0122375      235384.      16021.8
;         245      24.4202      24.4890      24.5391     0.118959   -0.0110016      238208.      16085.0
;         246      24.5202      24.5909      24.6416     0.121418  -0.00909233      238840.      15957.8
;         247      24.6213      24.6922      24.7434     0.122183  -0.00775337      240233.      16043.9
;         248      24.7216      24.7936      24.8455     0.123962  -0.00640488      237202.      15794.9
;         249      24.8221      24.8938      24.9445     0.122387  -0.00619698      235988.      15910.8
;         250      24.9217      24.9932      25.0430     0.121269  -0.00676727      234093.      15656.4
;         251      25.0213      25.0920      25.1438     0.122471  -0.00802231      234587.      15483.5
;         252      25.1202      25.1901      25.2418     0.121634  -0.00994492      232708.      15438.5
;         253      25.2137      25.2903      25.3426     0.128977  -0.00969505      228378.      15197.4
;         254      25.3129      25.3905      25.4403     0.127399  -0.00953484      225967.      14552.4
;         255      25.4044      25.4865      25.5439     0.139475   -0.0134888      222930.      13420.0
;         256      25.5004      25.5811      25.6423     0.141926   -0.0188770      206350.      11900.4
;         257      25.5849      25.6567      25.7062     0.121319   -0.0433044      233175.      15873.3
;         258      25.6711      25.7390      25.7913     0.120167   -0.0609818      214222.      14515.8
;         259      25.7646      25.8366      25.8909     0.126268   -0.0633526      232127.      15821.6
;         260      25.8732      25.9455      26.0000     0.126858   -0.0545120      234906.      16219.1
;         261      25.9804      26.0496      26.1035     0.123129   -0.0503521      235585.      16532.9
;         262      26.0826      26.1533      26.2054     0.122854   -0.0467167      232635.      16523.3
;         263      26.1901      26.2575      26.3121     0.121967   -0.0425205      233890.      16303.1
;         264      26.2915      26.3606      26.4139     0.122326   -0.0394230      228446.      16242.9
;         265      26.3930      26.4642      26.5183     0.125322   -0.0357647      233282.      16160.1
;         266      26.4944      26.5697      26.6247     0.130310   -0.0302925      241806.      16190.1
;         267      26.6016      26.6777      26.7365     0.134869   -0.0222530      241453.      15437.7
;         268      26.6934      26.7748      26.8338     0.140398   -0.0252285      229809.      13957.9
;         269      26.8007      26.8690      26.9196     0.118917   -0.0309944      216256.      14928.5
;         270      26.8902      26.9700      27.0366     0.146322   -0.0300350      222409.      12947.5
;         271      26.9722      27.0509      27.1117     0.139442   -0.0490608      211125.      13911.8
;         272      27.0905      27.1601      27.2158     0.125322   -0.0398827      216440.      15608.2
;         273      27.1912      27.2619      27.3162     0.124971   -0.0380592      226613.      16543.5
;         274      27.2938      27.3652      27.4174     0.123631   -0.0347881      226935.      16535.2
;         275      27.4001      27.4676      27.5216     0.121483   -0.0323849      227772.      16207.9
;         276      27.5017      27.5702      27.6229     0.121183   -0.0297775      226757.      16370.2
;         277      27.6023      27.6718      27.7244     0.122143   -0.0282173      222040.      15802.9
;         278      27.7025      27.7722      27.8251     0.122622   -0.0278034      224410.      16006.4
;         279      27.8021      27.8696      27.9223     0.120203   -0.0303879      215922.      15632.7
;         280      27.9020      27.9695      28.0230     0.121035   -0.0305061      219484.      15637.4
;         281      28.0023      28.0714      28.1242     0.121977   -0.0286045      221656.      15771.6
;         282      28.1017      28.1703      28.2228     0.121048   -0.0297451      220202.      15601.6
;         283      28.2009      28.2668      28.3211     0.120167   -0.0332069      213567.      15217.7
;         284      28.2937      28.3643      28.4161     0.122358   -0.0357189      213961.      15373.4
;         285      28.3915      28.4635      28.5183     0.126837   -0.0364628      228717.      15589.8
;         286      28.4919      28.5586      28.6086     0.116686   -0.0413952      211775.      15634.2
;         287      28.5819      28.6521      28.7085     0.126581   -0.0478706      225292.      15208.1
;         288      28.6808      28.7496      28.8058     0.125023   -0.0504189      216739.      15047.2
;         289      28.7819      28.8511      28.9061     0.124186   -0.0489483      218624.      15646.5
;         290      28.8818      28.9525      29.0081     0.126234   -0.0475254      217499.      15579.0
;         291      28.9830      29.0531      29.1082     0.125198   -0.0468788      222403.      16061.6
;         292      29.0829      29.1540      29.2087     0.125834   -0.0459595      217905.      15919.5
;         293      29.1901      29.2560      29.3102     0.120096   -0.0439720      216496.      15753.6
;         294      29.2909      29.3569      29.4111     0.120291   -0.0430851      217278.      15918.8
;         295      29.3902      29.4582      29.5128     0.122585   -0.0418415      216856.      15606.5
;         296      29.4917      29.5589      29.6130     0.121378   -0.0410728      216656.      15664.6
;         297      29.5921      29.6598      29.7138     0.121651   -0.0401764      216496.      15781.1
;         298      29.6931      29.7604      29.8136     0.120476   -0.0396309      215338.      16014.9
;         299      29.7920      29.8596      29.9134     0.121395   -0.0403652      213418.      15780.8
;         300      29.8922      29.9603      30.0146     0.122356   -0.0397434      215705.      15824.1
;         301      29.9929      30.0613      30.1149     0.122042   -0.0387459      214571.      15781.1
;         302      30.0931      30.1618      30.2156     0.122517   -0.0381947      213668.      15823.2
;         303      30.1934      30.2627      30.3147     0.121315   -0.0372791      216905.      15994.3
;         304      30.2936      30.3635      30.4167     0.123068   -0.0364780      209917.      15471.1
;         305      30.4000      30.4638      30.5182     0.118233   -0.0362453      218868.      16059.1
;         306      30.5006      30.5658      30.6190     0.118387   -0.0341873      212941.      15855.3
;         307      30.6011      30.6668      30.7203     0.119247   -0.0331554      214091.      15925.7
;         308      30.7014      30.7679      30.8212     0.119778   -0.0320873      213085.      15946.6
;         309      30.7936      30.8624      30.9162     0.122663   -0.0376301      215404.      15939.2
;         310      30.8945      30.9640      31.0170     0.122585   -0.0360241      213345.      16025.8
;         311      31.0026      31.0709      31.1243     0.121614   -0.0290813      214713.      16084.1
;         312      31.1003      31.1669      31.2197     0.119360   -0.0330868      214579.      16080.4
;         313      31.2009      31.2685      31.3227     0.121897   -0.0314617      211548.      15905.7
;         314      31.3019      31.3703      31.4248     0.122900   -0.0297012      215021.      16099.8
;         315      31.4033      31.4729      31.5267     0.123474   -0.0270748      214831.      16294.5
;         316      31.5100      31.5758      31.6309     0.120874   -0.0242100      213749.      16165.1
;         317      31.6122      31.6792      31.7328     0.120636   -0.0207577      211499.      16307.5
;         318      31.7131      31.7840      31.8374     0.124313   -0.0160351      209235.      15992.4
;       5      31.9200      40.1000      8.18000         314         397      83.4000
;   cell, integral, left, center, right, fwhm
;         319      31.8210      31.8897      31.9436     0.122643   -0.0102825      203920.      15295.4
;         320      31.9141      31.9871      32.0397     0.125568   -0.0129375      215387.      15343.8
;         321      32.0028      32.0715      32.1233     0.120502   -0.0285454      202518.      14560.9
;         322      32.0927      32.1594      32.2119     0.119137   -0.0405693      205550.      14923.7
;         323      32.1902      32.2539      32.3069     0.116634   -0.0461388      208907.      14947.6
;         324      32.2831      32.3511      32.4046     0.121498   -0.0489502      207605.      15014.8
;         325      32.3826      32.4492      32.5026     0.119915   -0.0508232      210107.      15408.7
;         326      32.4822      32.5482      32.6018     0.119572   -0.0517731      206967.      15233.0
;         327      32.5817      32.6476      32.7024     0.120716   -0.0523796      210163.      15243.3
;         328      32.6818      32.7483      32.8028     0.120998   -0.0516815      210326.      15414.0
;         329      32.7836      32.8514      32.9052     0.121563   -0.0486412      210932.      15549.4
;         330      32.8838      32.9523      33.0062     0.122334   -0.0477219      209854.      15520.8
;         331      32.9844      33.0532      33.1069     0.122532   -0.0468140      211048.      15755.2
;         332      33.0831      33.1510      33.2053     0.122272   -0.0490341      209604.      15653.4
;         333      33.1903      33.2550      33.3099     0.119637   -0.0450172      210339.      15537.0
;         334      33.2906      33.3562      33.4100     0.119411   -0.0438156      210812.      15669.0
;         335      33.3908      33.4576      33.5109     0.120060   -0.0423965      210928.      15550.0
;         336      33.4918      33.5588      33.6121     0.120239   -0.0411987      210208.      15697.1
;         337      33.5923      33.6596      33.7129     0.120605   -0.0403557      210091.      15444.0
;         338      33.6925      33.7601      33.8140     0.121433   -0.0399017      209949.      15445.5
;         339      33.7929      33.8603      33.9128     0.119881   -0.0396538      208538.      15596.7
;         340      33.8919      33.9587      34.0132     0.121342   -0.0413437      212061.      15390.5
;         341      33.9926      34.0602      34.1135     0.120907   -0.0397530      206582.      15257.1
;         342      34.0918      34.1583      34.2117     0.119942   -0.0416985      209459.      15307.4
;         343      34.1918      34.2584      34.3124     0.120556   -0.0415878      210788.      15384.9
;         344      34.2917      34.3586      34.4124     0.120705   -0.0413551      209527.      15317.2
;         345      34.3917      34.4577      34.5114     0.119701   -0.0422745      207585.      15206.6
;         346      34.4909      34.5568      34.6105     0.119587   -0.0432281      207440.      15139.3
;         347      34.5844      34.6551      34.7084     0.123974   -0.0449371      205207.      15087.6
;         348      34.6837      34.7539      34.8073     0.123547   -0.0461159      208956.      15305.9
;         349      34.7835      34.8527      34.9061     0.122509   -0.0472565      204817.      14934.5
;         350      34.8825      34.9504      35.0041     0.121590   -0.0495605      207834.      15034.3
;         351      34.9741      35.0448      35.0997     0.125572   -0.0551529      206361.      14938.3
;         352      35.0728      35.1437      35.1991     0.126312   -0.0562744      205581.      14727.7
;         353      35.1732      35.2428      35.2990     0.125786   -0.0571938      207138.      15046.6
;         354      35.2729      35.3422      35.3974     0.124508   -0.0578041      205354.      15207.7
;         355      35.3722      35.4413      35.4961     0.123928   -0.0587044      208503.      15303.6
;         356      35.4723      35.5419      35.5982     0.125908   -0.0580635      208641.      15270.1
;         357      35.5729      35.6425      35.6980     0.125179   -0.0574760      208261.      15442.5
;         358      35.6735      35.7434      35.7974     0.123901   -0.0566139      209298.      15719.3
;         359      35.7810      35.8468      35.9011     0.120136   -0.0531883      205697.      15490.6
;         360      35.8743      35.9435      35.9978     0.123501   -0.0565033      209101.      15833.3
;         361      35.9803      36.0448      36.0991     0.118740   -0.0552292      208561.      15596.6
;         362      36.0822      36.1502      36.2057     0.123482   -0.0497971      207047.      15454.7
;         363      36.1830      36.2520      36.3069     0.123875   -0.0479507      206570.      15529.1
;         364      36.2901      36.3533      36.4082     0.118050   -0.0467453      206593.      15618.1
;         365      36.3907      36.4552      36.5105     0.119793   -0.0447540      207529.      15586.3
;         366      36.4911      36.5571      36.6113     0.120144   -0.0428734      206229.      15462.4
;         367      36.5923      36.6579      36.7118     0.119423   -0.0420647      206794.      15651.0
;         368      36.6911      36.7569      36.8104     0.119236   -0.0430603      207138.      15472.5
;         369      36.7903      36.8571      36.9108     0.120453   -0.0429077      206876.      15215.6
;         370      36.8916      36.9581      37.0112     0.119564   -0.0419197      208755.      15447.5
;         371      36.9921      37.0585      37.1114     0.119350   -0.0415306      204414.      15159.0
;         372      37.0911      37.1579      37.2106     0.119534   -0.0420914      209340.      15543.2
;         373      37.1920      37.2584      37.3098     0.117855   -0.0416489      206423.      15394.2
;         374      37.2923      37.3589      37.4126     0.120228   -0.0410576      208474.      15388.4
;         375      37.3925      37.4598      37.5133     0.120815   -0.0401917      207146.      15505.2
;         376      37.4927      37.5601      37.6144     0.121704   -0.0398712      208644.      15571.1
;         377      37.5931      37.6611      37.7149     0.121861   -0.0389404      207377.      15553.7
;         378      37.6930      37.7611      37.8144     0.121330   -0.0389481      205919.      15330.2
;         379      37.7943      37.8629      37.9161     0.121799   -0.0370522      207840.      15490.7
;         380      37.8923      37.9592      38.0140     0.121738   -0.0407677      205082.      15187.0
;         381      37.9914      38.0577      38.1116     0.120232   -0.0422554      204508.      15246.3
;         382      38.0913      38.1596      38.2142     0.122890   -0.0403557      204619.      14781.0
;         383      38.1919      38.2583      38.3102     0.118271   -0.0417023      204442.      14874.0
;         384      38.2908      38.3560      38.4096     0.118835   -0.0440407      205810.      14624.9
;         385      38.3830      38.4512      38.5054     0.122375   -0.0488243      202925.      14476.3
;         386      38.4821      38.5482      38.6018     0.119759   -0.0517998      204802.      14814.0
;         387      38.5813      38.6462      38.7009     0.119644   -0.0538406      206057.      15139.4
;         388      38.6806      38.7449      38.7991     0.118443   -0.0550652      205794.      15155.6
;         389      38.7819      38.8503      38.9060     0.124096   -0.0496864      208821.      15451.1
;         390      38.8832      38.9513      39.0061     0.122871   -0.0486565      205847.      15394.6
;         391      38.9809      39.0454      39.1008     0.119965   -0.0545921      206386.      15475.2
;         392      39.0836      39.1528      39.2076     0.123997   -0.0471916      208709.      15673.2
;         393      39.1903      39.2541      39.3070     0.116661   -0.0459442      206737.      15633.7
;         394      39.2905      39.3554      39.4103     0.119785   -0.0445747      209470.      15457.2
;         395      39.3914      39.4565      39.5114     0.119934   -0.0435181      208066.      15415.9
;         396      39.4919      39.5574      39.6116     0.119766   -0.0426483      208314.      15525.4
;         397      39.5810      39.6476      39.7013     0.120346   -0.0523720      206363.      15471.9
;Intersection Analysis
;At     0.298078 between       4 and       3
;At     0.209782 between       5 and       4
;At    0.0571646 between       6 and       5
;At   -0.0259963 between       7 and       6
;At   -0.0594684 between       8 and       7
;At   -0.0710539 between       9 and       8
;At   -0.0685778 between      10 and       9
;At   -0.0702989 between      11 and      10
;At   -0.0689542 between      12 and      11
;At   -0.0728956 between      13 and      12
;At   -0.0771294 between      14 and      13
;At   -0.0821145 between      15 and      14
;At   -0.0866359 between      16 and      15
;At   -0.0933617 between      17 and      16
;At   -0.0994127 between      18 and      17
;At   -0.0995895 between      19 and      18
;At    -0.102502 between      20 and      19
;At    -0.108605 between      21 and      20
;At    -0.116473 between      22 and      21
;At    -0.129915 between      23 and      22
;At    -0.139081 between      24 and      23
;At    -0.225086 between      26 and      24
;At    -0.275840 between      27 and      26
;At    -0.338128 between      28 and      27
;At    -0.255740 between      34 and      28
;At     0.151569 between      35 and      34
;At    0.0949328 between      36 and      35
;At    0.0563252 between      37 and      36
;At    0.0276041 between      38 and      37
;At   0.00245118 between      39 and      38
;At  -0.00780535 between      40 and      39
;At   -0.0206819 between      41 and      40
;At   -0.0332165 between      42 and      41
;At   -0.0450454 between      43 and      42
;At   -0.0429635 between      44 and      43
;At   -0.0295477 between      45 and      44
;At   -0.0220156 between      46 and      45
;At   -0.0268240 between      47 and      46
;At   -0.0362120 between      48 and      47
;At   -0.0446453 between      49 and      48
;At   -0.0529404 between      50 and      49
;At   -0.0537567 between      51 and      50
;At   -0.0451455 between      52 and      51
;At   -0.0334983 between      53 and      52
;At   -0.0305057 between      54 and      53
;At   -0.0362072 between      55 and      54
;At   -0.0432243 between      56 and      55
;At   -0.0499291 between      57 and      56
;At   -0.0564847 between      58 and      57
;At   -0.0613999 between      59 and      58
;At   -0.0695176 between      60 and      59
;At   -0.0780745 between      61 and      60
;At   -0.0887079 between      62 and      61
;At   -0.0969453 between      64 and      62
;At  -0.00415325 between      65 and      64
;At   -0.0119104 between      66 and      65
;At   -0.0267282 between      67 and      66
;At   -0.0325394 between      68 and      67
;At   -0.0315146 between      69 and      68
;At   -0.0367303 between      70 and      69
;At   -0.0388374 between      71 and      70
;At   -0.0394835 between      72 and      71
;At   -0.0431919 between      73 and      72
;At   -0.0427246 between      74 and      73
;At   -0.0439463 between      75 and      74
;At   -0.0415339 between      76 and      75
;At   -0.0452137 between      77 and      76
;At   -0.0631948 between      80 and      77
;At    -0.230318 between      81 and      78
;At   -0.0470343 between      82 and      81
;At   -0.0502329 between      83 and      82
;At   -0.0486965 between      84 and      83
;At   -0.0514641 between      85 and      84
;At   -0.0508919 between      86 and      85
;At   -0.0541840 between      87 and      86
;At   -0.0580635 between      88 and      87
;At   -0.0566330 between      89 and      88
;At   -0.0588875 between      90 and      89
;At   -0.0584354 between      91 and      90
;At   -0.0590601 between      92 and      91
;At   -0.0623455 between      93 and      92
;At   -0.0637312 between      94 and      93
;At   -0.0678930 between      95 and      94
;At   -0.0672598 between      96 and      95
;At   -0.0661516 between      97 and      96
;At   -0.0692253 between      98 and      97
;At   -0.0669003 between      99 and      98
;At   -0.0630426 between     100 and      99
;At   -0.0534964 between     101 and     100
;At   -0.0286436 between     102 and     101
;At   -0.0215225 between     103 and     102
;At   -0.0193748 between     104 and     103
;At   -0.0243607 between     105 and     104
;At   -0.0288839 between     106 and     105
;At   -0.0258198 between     107 and     106
;At   -0.0239611 between     108 and     107
;At   -0.0262661 between     109 and     108
;At   -0.0291834 between     110 and     109
;At   -0.0303507 between     111 and     110
;At   -0.0313702 between     112 and     111
;At   -0.0313005 between     113 and     112
;At   -0.0332432 between     114 and     113
;At   -0.0361309 between     115 and     114
;At   -0.0361776 between     116 and     115
;At   -0.0320492 between     117 and     116
;At   -0.0287914 between     118 and     117
;At   -0.0280428 between     119 and     118
;At   -0.0281258 between     120 and     119
;At   -0.0283642 between     121 and     120
;At   -0.0301304 between     122 and     121
;At   -0.0278492 between     123 and     122
;At   -0.0275059 between     124 and     123
;At   -0.0269279 between     125 and     124
;At   -0.0163708 between     126 and     125
;At   -0.0248747 between     127 and     126
;At   -0.0187206 between     128 and     127
;At   -0.0155296 between     129 and     128
;At   -0.0142097 between     130 and     129
;At   -0.0116911 between     131 and     130
;At   -0.0130806 between     132 and     131
;At   -0.0147829 between     133 and     132
;At   -0.0160456 between     134 and     133
;At   -0.0181875 between     135 and     134
;At   -0.0191288 between     136 and     135
;At   -0.0207024 between     137 and     136
;At   -0.0199718 between     138 and     137
;At   -0.0176058 between     139 and     138
;At   -0.0174732 between     140 and     139
;At   -0.0204859 between     141 and     140
;At   -0.0188599 between     142 and     141
;At   -0.0225983 between     143 and     142
;At   -0.0243330 between     144 and     143
;At   -0.0247869 between     145 and     144
;At   -0.0251236 between     146 and     145
;At   -0.0274324 between     147 and     146
;At   -0.0254612 between     148 and     147
;At   -0.0266514 between     149 and     148
;At   -0.0285378 between     150 and     149
;At   -0.0289621 between     151 and     150
;At   -0.0300913 between     152 and     151
;At   -0.0302238 between     153 and     152
;At   -0.0319166 between     154 and     153
;At   -0.0328846 between     155 and     154
;At   -0.0362320 between     156 and     155
;At   -0.0372362 between     157 and     156
;At   -0.0386992 between     158 and     157
;At   -0.0417347 between     159 and     158
;At   -0.0427637 between     160 and     159
;At   -0.0426445 between     161 and     160
;At   -0.0423813 between     162 and     161
;At   -0.0445557 between     163 and     162
;At   -0.0498428 between     164 and     163
;At   -0.0621395 between     165 and     164
;At   -0.0571537 between     166 and     165
;At   -0.0352783 between     167 and     166
;At   -0.0450401 between     168 and     167
;At   0.00176430 between     169 and     168
;At    0.0151234 between     170 and     169
;At    0.0377731 between     171 and     170
;At    0.0342655 between     172 and     171
;At    0.0170898 between     173 and     172
;At   0.00876808 between     174 and     173
;At   0.00421524 between     175 and     174
;At  0.000764847 between     176 and     175
;At  -0.00554848 between     177 and     176
;At  -0.00658035 between     178 and     177
;At  -0.00952339 between     179 and     178
;At   -0.0120068 between     180 and     179
;At   -0.0137405 between     181 and     180
;At   -0.0146408 between     182 and     181
;At   -0.0172462 between     183 and     182
;At   -0.0173779 between     184 and     183
;At   -0.0175800 between     185 and     184
;At   -0.0193405 between     186 and     185
;At   -0.0191936 between     187 and     186
;At   -0.0165520 between     188 and     187
;At   -0.0127525 between     189 and     188
;At   -0.0107002 between     190 and     189
;At  -0.00167465 between     191 and     190
;At  0.000795364 between     192 and     191
;At -0.000169754 between     193 and     192
;At  -0.00115585 between     194 and     193
;At  -0.00148773 between     195 and     194
;At  -0.00200844 between     196 and     195
;At  -0.00310898 between     197 and     196
;At  -0.00291252 between     198 and     197
;At  -0.00276566 between     199 and     198
;At  -0.00300980 between     200 and     199
;At  -0.00444984 between     201 and     200
;At  -0.00513077 between     202 and     201
;At   -0.0195885 between     203 and     202
;At   -0.0298271 between     204 and     203
;At   -0.0315990 between     205 and     204
;At   -0.0349312 between     206 and     205
;At   -0.0316448 between     207 and     206
;At   -0.0300503 between     208 and     207
;At   -0.0319080 between     209 and     208
;At   -0.0336533 between     210 and     209
;At   -0.0305557 between     211 and     210
;At   -0.0347595 between     212 and     211
;At   -0.0349407 between     213 and     212
;At   -0.0326195 between     214 and     213
;At   -0.0331039 between     215 and     214
;At   -0.0336723 between     216 and     215
;At   -0.0360832 between     217 and     216
;At   -0.0358028 between     218 and     217
;At   -0.0364971 between     219 and     218
;At   -0.0354481 between     220 and     219
;At   -0.0355930 between     221 and     220
;At   -0.0377235 between     222 and     221
;At   -0.0388851 between     223 and     222
;At   -0.0370140 between     224 and     223
;At   -0.0343723 between     225 and     224
;At   -0.0335884 between     226 and     225
;At   -0.0322914 between     227 and     226
;At   -0.0309887 between     228 and     227
;At   -0.0322304 between     229 and     228
;At   -0.0313854 between     230 and     229
;At   -0.0237083 between     231 and     230
;At   -0.0257473 between     232 and     231
;At   -0.0258789 between     233 and     232
;At   -0.0293694 between     234 and     233
;At   -0.0268612 between     235 and     234
;At   -0.0290585 between     236 and     235
;At   -0.0305920 between     237 and     236
;At   -0.0262909 between     238 and     237
;At   -0.0207767 between     239 and     238
;At   -0.0281010 between     240 and     239
;At   -0.0286446 between     241 and     240
;At   -0.0319920 between     242 and     241
;At   -0.0296917 between     243 and     242
;At   -0.0295963 between     244 and     243
;At   -0.0300961 between     245 and     244
;At   -0.0315914 between     246 and     245
;At   -0.0329609 between     247 and     246
;At   -0.0337887 between     248 and     247
;At   -0.0355816 between     249 and     248
;At   -0.0351391 between     250 and     249
;At   -0.0336304 between     251 and     250
;At   -0.0300846 between     252 and     251
;At   -0.0291710 between     253 and     252
;At   -0.0286064 between     254 and     253
;At   -0.0245075 between     255 and     254
;At   -0.0237694 between     256 and     255
;At  -0.00971603 between     257 and     256
;At   0.00697517 between     258 and     257
;At    0.0214462 between     259 and     258
;At    0.0167484 between     260 and     259
;At   0.00988197 between     261 and     260
;At   0.00530815 between     262 and     261
;At   0.00214386 between     263 and     262
;At  -0.00263214 between     264 and     263
;At  -0.00555420 between     265 and     264
;At  -0.00954628 between     266 and     265
;At   -0.0150681 between     267 and     266
;At   -0.0142269 between     268 and     267
;At   -0.0183659 between     269 and     268
;At  -0.00691605 between     270 and     269
;At   -0.0112305 between     271 and     270
;At   0.00166321 between     272 and     271
;At  -0.00306511 between     273 and     272
;At  -0.00687790 between     274 and     273
;At  -0.00826645 between     275 and     274
;At   -0.0121517 between     276 and     275
;At   -0.0142746 between     277 and     276
;At   -0.0148182 between     278 and     277
;At   -0.0145855 between     279 and     278
;At   -0.0120869 between     280 and     279
;At   -0.0130939 between     281 and     280
;At   -0.0145283 between     282 and     281
;At   -0.0119572 between     283 and     282
;At  -0.00842285 between     284 and     283
;At  -0.00396347 between     285 and     284
;At  -0.00590515 between     286 and     285
;At   0.00253868 between     287 and     286
;At   0.00504303 between     288 and     287
;At   0.00612259 between     289 and     288
;At   0.00433540 between     290 and     289
;At   0.00402641 between     291 and     290
;At   0.00217819 between     292 and     291
;At  0.000949860 between     293 and     292
;At -3.24249e-05 between     294 and     293
;At  0.000242233 between     295 and     294
;At  -0.00298309 between     296 and     295
;At  -0.00372124 between     297 and     296
;At  -0.00415230 between     298 and     297
;At  -0.00404549 between     299 and     298
;At  -0.00394630 between     300 and     299
;At  -0.00510216 between     301 and     300
;At  -0.00596619 between     302 and     301
;At  -0.00636673 between     303 and     302
;At  -0.00722694 between     304 and     303
;At  -0.00758553 between     305 and     304
;At  -0.00950432 between     306 and     305
;At  -0.00993919 between     307 and     306
;At   -0.0114079 between     308 and     307
;At  -0.00914955 between     309 and     308
;At  -0.00851440 between     310 and     309
;At   -0.0115852 between     311 and     310
;At   -0.0132713 between     312 and     311
;At   -0.0124779 between     313 and     312
;At   -0.0118885 between     314 and     313
;At   -0.0157204 between     315 and     314
;At   -0.0179100 between     316 and     315
;At   -0.0205097 between     317 and     316
;At   -0.0249596 between     318 and     317
;At   -0.0305252 between     319 and     318
;At   -0.0302544 between     320 and     319
;At   -0.0243607 between     321 and     320
;At  -0.00920868 between     322 and     321
;At  -0.00169373 between     323 and     322
;At   0.00357437 between     324 and     323
;At   0.00569916 between     325 and     324
;At   0.00667572 between     326 and     325
;At   0.00783920 between     327 and     326
;At   0.00745010 between     328 and     327
;At   0.00532532 between     329 and     328
;At   0.00267792 between     330 and     329
;At   0.00199127 between     331 and     330
;At   0.00265884 between     332 and     331
;At   0.00165176 between     333 and     332
;At  0.000865936 between     334 and     333
;At  -0.00212860 between     335 and     334
;At  -0.00350189 between     336 and     335
;At  -0.00431061 between     337 and     336
;At  -0.00472641 between     338 and     337
;At  -0.00523758 between     339 and     338
;At  -0.00370789 between     340 and     339
;At  -0.00502777 between     341 and     340
;At  -0.00413132 between     342 and     341
;At  -0.00288391 between     343 and     342
;At  -0.00352478 between     344 and     343
;At  -0.00340652 between     345 and     344
;At  -0.00147629 between     346 and     345
;At -0.000255585 between     347 and     346
;At   0.00252151 between     348 and     347
;At   0.00281906 between     349 and     348
;At   0.00532150 between     350 and     349
;At   0.00890732 between     351 and     350
;At    0.0119057 between     352 and     351
;At    0.0124245 between     353 and     352
;At    0.0128593 between     354 and     353
;At    0.0140991 between     355 and     354
;At    0.0139618 between     356 and     355
;At    0.0131226 between     357 and     356
;At    0.0124969 between     358 and     357
;At   0.00966644 between     359 and     358
;At    0.0100098 between     360 and     359
;At    0.0119591 between     361 and     360
;At   0.00742340 between     362 and     361
;At   0.00376129 between     363 and     362
;At   0.00237656 between     364 and     363
;At   0.00141144 between     365 and     364
;At -0.000450134 between     366 and     365
;At  -0.00173187 between     367 and     366
;At  -0.00167084 between     368 and     367
;At -0.000255585 between     369 and     368
;At  -0.00237274 between     370 and     369
;At  -0.00317001 between     371 and     370
;At  -0.00254059 between     372 and     371
;At  -0.00289536 between     373 and     372
;At  -0.00309753 between     374 and     373
;At  -0.00385666 between     375 and     374
;At  -0.00472641 between     376 and     375
;At  -0.00531769 between     377 and     376
;At  -0.00628281 between     378 and     377
;At  -0.00700760 between     379 and     378
;At  -0.00577164 between     380 and     379
;At  -0.00288391 between     381 and     380
;At  -0.00295639 between     382 and     381
;At  -0.00339890 between     383 and     382
;At  0.000801086 between     384 and     383
;At   0.00177765 between     385 and     384
;At   0.00469971 between     386 and     385
;At   0.00726318 between     387 and     386
;At   0.00867462 between     388 and     387
;At   0.00743866 between     389 and     388
;At   0.00311279 between     390 and     389
;At   0.00679016 between     391 and     390
;At   0.00627518 between     392 and     391
;At   0.00157928 between     393 and     392
;At   0.00158691 between     394 and     393
;At  -0.00102997 between     395 and     394
;At  -0.00282288 between     396 and     395
;At   0.00296783 between     397 and     396
;At    -0.292019 between     397 and     396
;At    -0.322109 between     397 and     396
;At    -0.398804 between     397 and     396
.run plotdfil
plotdfil,0,40.1,mul=5,/ps,pr='dj1_d20',thr=t,/por,scal=2.5,ysi=26,xoffs=1,yoffs=-0.5,inten=1000.,fwh=width,posi=pos,cel=cell,ov=.1,inters=is,interw=iw
;Create def_0_411.ps XSIZE=      20.4500 cm
;       1      0.00000      8.18000      8.18000     -2.00000      85.0000      87.0000
;   cell, integral, left, center, right, fwhm
;           1    -0.138281    0.0537944     0.178762     0.317043   -0.0462056      35819.1      1118.45
;           2    -0.146574    0.0922954     0.263293     0.409867    -0.107705      50485.2      1271.57
;           3     0.319920     0.159132     0.391879    0.0719587    -0.140868      128372.      2679.71
;           4     0.281492     0.205839     0.446791     0.165298    -0.194161      123815.      3323.10
;           5     0.201654     0.408531     0.584800     0.383145   -0.0914689      254184.      6398.48
;           6     0.423830     0.570380     0.695350     0.271520   -0.0296199      283049.      9648.06
;           7     0.592007     0.701791     0.803043     0.211036   0.00179094      291306.      12276.7
;           8     0.730291     0.818709     0.895817     0.165527    0.0187088      251656.      13495.9
;           9     0.844796     0.922421     0.986559     0.141762    0.0224206      237982.      14188.7
;          10     0.952560      1.02345      1.08377     0.131205    0.0234536      234314.      15437.8
;          11      1.05368      1.12441      1.18062     0.126936    0.0244067      230655.      15770.2
;          12      1.15383      1.22626      1.28460     0.130768    0.0262562      236546.      15839.2
;          13      1.26159      1.33026      1.38785     0.126251    0.0302591      238845.      16242.5
;          14      1.36388      1.43518      1.49358     0.129702    0.0351833      236550.      16000.7
;          15      1.47101      1.53957      1.59723     0.126225    0.0395740      235974.      16090.9
;          16      1.57291      1.64548      1.70502     0.132108    0.0454843      235022.      15680.5
;          17      1.68163      1.75026      1.80961     0.127984    0.0502642      233697.      15943.5
;          18      1.78402      1.85454      1.91335     0.129327    0.0545433      226247.      15648.3
;          19      1.88288      1.95255      2.01315     0.130263    0.0525512      243335.      15850.3
;          20      1.99039      2.05775      2.11986     0.129466    0.0577543      242885.      15726.0
;          21      2.09385      2.16542      2.22803     0.134172    0.0654182      242976.      15642.9
;          22      2.20141      2.27573      2.34361     0.142206    0.0757277      247233.      15058.2
;          23      2.31121      2.38627      2.45553     0.144315    0.0862720      237478.      14209.3
;          24      2.41294      2.48961      2.56001     0.147067    0.0896084      233536.      13348.7
;          26      2.75079      2.81702      2.89308     0.142289     0.217020      218483.      12654.2
;          27      2.85280      2.92377      3.01549     0.162691     0.223775      241117.      12319.0
;          28      2.79003      2.94454      3.11547     0.325436     0.144538      121825.      3341.04
;          29      2.94318      3.01806      3.11345     0.170269     0.118059      32045.6      1329.44
;          30      3.04573      3.12267      3.22417     0.178437     0.122670      40465.1      1716.36
;          31      3.06439      3.18277      3.28400     0.219611    0.0827663      16512.6      696.495
;          32      2.92231      3.10804      3.21332     0.291009   -0.0919645      89850.9      2465.15
;          33      2.96468      3.15216      3.37014     0.405460    -0.147838      82891.4      2352.47
;          34      3.07616      3.18496      3.25297     0.176817    -0.215038      235487.      12005.4
;          35      3.24454      3.34555      3.40713     0.162593    -0.154455      253057.      13071.3
;          36      3.40289      3.49071      3.55274     0.149855    -0.109290      239122.      13640.4
;          37      3.53446      3.61955      3.68357     0.149114   -0.0804453      242114.      14326.9
;          38      3.66435      3.74478      3.80891     0.144556   -0.0552249      252998.      15514.8
;          39      3.78456      3.85906      3.92114     0.136580   -0.0409365      248248.      16069.8
;          40      3.90124      3.97170      4.03301     0.131769   -0.0282991      255039.      16644.2
;          41      4.01035      4.07945      4.13918     0.128828   -0.0205498      241170.      16168.5
;          42      4.12266      4.19382      4.24964     0.126977  -0.00617504      246789.      16753.4
;          43      4.23143      4.30142      4.35015     0.118717   0.00141811      235073.      15922.3
;          44      4.33322      4.39396      4.44097     0.107749  -0.00604439      236370.      17319.4
;          45      4.41241      4.48083      4.53340     0.120985   -0.0191655      224596.      14817.4
;          46      4.51210      4.57802      4.63666     0.124563   -0.0219808      245734.      16457.0
;          47      4.62023      4.68649      4.74360     0.123374   -0.0135136      228180.      16633.6
;          48      4.72447      4.79439      4.85129     0.126824  -0.00561428      224452.      16447.6
;          49      4.83237      4.90251      4.96037     0.127994   0.00250769      224174.      16176.6
;          50      4.94051      5.00903      5.06094     0.120435   0.00903463      219993.      15954.1
;          51      5.04077      5.10818      5.16237     0.121600   0.00817633      241634.      15908.1
;          52      5.13259      5.19230      5.23801     0.105420  -0.00769901      238610.      18304.9
;          53      5.22099      5.28294      5.34043     0.119431   -0.0170612      226182.      15721.9
;          54      5.32217      5.38840      5.44364     0.121475   -0.0116043      226406.      16593.9
;          55      5.43056      5.49509      5.55030     0.119740  -0.00491285      230034.      16917.1
;          56      5.53329      5.60191      5.65752     0.124224   0.00191164      226324.      16530.1
;          57      5.64228      5.71009      5.76503     0.122749    0.0100889      225908.      16485.9
;          58      5.74354      5.81247      5.86950     0.125963    0.0124707      224698.      16315.6
;          59      5.85305      5.92062      5.97754     0.124485    0.0206223      228691.      16544.9
;          60      5.95523      6.02658      6.08265     0.127418    0.0265799      229459.      16494.1
;          61      6.07131      6.13971      6.19623     0.124924    0.0397091      228343.      16139.2
;          62      6.18039      6.24625      6.30180     0.121406    0.0462461      234289.      16214.9
;          63      6.24267      6.29795      6.34258    0.0999107  -0.00204563      72002.9      6070.91
;          64      6.28334      6.35752      6.41952     0.136188   -0.0424786      237914.      15538.3
;          65      6.39027      6.46096      6.52293     0.132659   -0.0390415      233727.      15504.6
;          66      6.50286      6.57344      6.63368     0.130816   -0.0265574      234482.      16230.6
;          67      6.61442      6.68618      6.74465     0.130233   -0.0138154      226426.      15928.6
;          68      6.72067      6.78572      6.84334     0.122669   -0.0142827      224556.      16188.6
;          69      6.82189      6.88734      6.94302     0.121136   -0.0126572      219169.      16094.5
;          70      6.93040      6.99437      7.05075     0.120354  -0.00563145      220246.      16086.5
;          71      7.02241      7.09105      7.14662     0.124214  -0.00895262      218196.      15850.5
;          72      7.13108      7.19649      7.25387     0.122795  -0.00351477      218701.      15764.5
;          73      7.23254      7.29708      7.35283     0.120286  -0.00292301      216457.      16018.4
;          74      7.33243      7.39793      7.45112     0.118692  -0.00206995      218928.      15792.0
;          75      7.43208      7.49832      7.55306     0.120981  -0.00168037      217921.      15579.4
;          76      7.53283      7.59721      7.65351     0.120680  -0.00279236      228209.      16299.1
;          77      7.63370      7.70278      7.75504     0.121342   0.00277758      212245.      16733.5
;          78      7.88714      7.90720      8.04988     0.162744     0.107198      212104.      9628.00
;          79      7.83437      7.90087      7.95416     0.119786  0.000869751      233664.      17893.3
;          80      7.74041      7.87420      7.85008     0.109671    -0.125798      215888.      9882.05
;          81      8.03394      8.09873      8.15486     0.120915  -0.00127316      233255.      17269.0
;          82      8.13316      8.20230      8.25748     0.124318   0.00229740      212765.      16105.6
;          83      8.24078      8.30413      8.35901     0.118237   0.00412750      201822.      15469.2
;          84      8.34083      8.40485      8.45968     0.118854   0.00484848      204517.      15801.5
;          85      8.43586      8.50538      8.55873     0.122875   0.00537682      203103.      15540.2
;       2      7.98000      16.1600      8.18000      81.0000      168.000      87.0000
;   cell, integral, left, center, right, fwhm
;          86      8.54130      8.60636      8.66251     0.121202   0.00635529      206616.      15620.2
;          87      8.64222      8.71108      8.76720     0.124981    0.0110807      212560.      15867.0
;          88      8.74389      8.81219      8.86664     0.122746    0.0121880      209087.      15771.1
;          89      8.84406      8.91344      8.96728     0.123225    0.0134449      211201.      15725.8
;          90      8.94334      9.01135      9.06746     0.124116    0.0113468      207619.      15540.3
;          91      9.05113      9.11571      9.17271     0.121582    0.0157137      209937.      15570.3
;          92      9.14402      9.21377      9.26901     0.124984    0.0137739      207374.      15504.8
;          93      9.25116      9.31820      9.37457     0.123406    0.0181999      209129.      15702.6
;          94      9.35204      9.41944      9.47516     0.123113    0.0194435      210250.      15393.4
;          95      9.45329      9.52157      9.57611     0.122818    0.0215712      210666.      15217.6
;          96      9.55051      9.61908      9.67529     0.124778    0.0190783      210884.      14738.8
;          97      9.65355      9.72197      9.77866     0.125102    0.0219660      216659.      15079.7
;          98      9.75326      9.82052      9.87854     0.125279    0.0205164      209912.      14755.0
;          99      9.85268      9.91806      9.97134     0.118663    0.0180607      203769.      14819.0
;         100      9.95098      10.0186      10.0747     0.123766    0.0185862      207579.      14000.9
;         101      10.0306      10.0890      10.1423     0.111710   -0.0109911      193303.      14148.8
;         102      10.1135      10.1786      10.2347     0.121238   -0.0213900      207273.      14652.7
;         103      10.2115      10.2731      10.3313     0.119824   -0.0269184      202789.      14991.8
;         104      10.3114      10.3760      10.4335     0.122142   -0.0239553      213704.      15961.3
;         105      10.4129      10.4799      10.5374     0.124408   -0.0200577      212030.      16004.2
;         106      10.5146      10.5835      10.6407     0.126097   -0.0164766      214637.      16081.3
;         107      10.6107      10.6760      10.7334     0.122686   -0.0240459      213723.      15906.9
;         108      10.7124      10.7781      10.8344     0.121994   -0.0219212      211339.      15993.0
;         109      10.8126      10.8801      10.9374     0.124761   -0.0199223      212425.      16107.3
;         110      10.9203      10.9825      11.0388     0.118572   -0.0174532      210510.      16187.9
;         111      11.0154      11.0834      11.1383     0.122881   -0.0166035      208765.      16090.3
;         112      11.1201      11.1847      11.2413     0.121195   -0.0153017      210140.      16008.1
;         113      11.2221      11.2864      11.3406     0.118505   -0.0135565      209698.      16104.1
;         114      11.3215      11.3878      11.4446     0.123065   -0.0121927      209857.      16042.1
;         115      11.4233      11.4896      11.5452     0.121852   -0.0104151      210299.      16148.7
;         116      11.5236      11.5910      11.6472     0.123575  -0.00904369      211923.      15801.7
;         117      11.6135      11.6815      11.7377     0.124134   -0.0184660      217171.      16070.5
;         118      11.7143      11.7824      11.8386     0.124269   -0.0176125      216464.      16044.6
;         119      11.8147      11.8831      11.9375     0.122888   -0.0168667      217703.      16240.1
;         120      11.9203      11.9833      12.0382     0.117890   -0.0166779      216159.      16112.6
;         121      12.0206      12.0837      12.1388     0.118132   -0.0162535      216385.      15872.4
;         122      12.1150      12.1830      12.2385     0.123503   -0.0169592      214350.      15846.3
;         123      12.2131      12.2820      12.3372     0.124034   -0.0180082      214859.      15550.5
;         124      12.3133      12.3810      12.4356     0.122330   -0.0189753      215040.      15366.4
;         125      12.4126      12.4765      12.5298     0.117137   -0.0235157      202577.      14802.8
;         126      12.5034      12.5754      12.6353     0.131881   -0.0245705      244795.      16025.8
;         127      12.6107      12.6733      12.7280     0.117276   -0.0266628      207073.      14940.0
;         128      12.7041      12.7712      12.8280     0.123850   -0.0287895      213729.      15242.0
;         129      12.8031      12.8697      12.9259     0.122827   -0.0302753      212951.      15553.5
;         130      12.9007      12.9660      13.0234     0.122705   -0.0339899      215920.      15827.2
;         131      13.0016      13.0664      13.1216     0.120004   -0.0336313      214272.      15912.8
;         132      13.1018      13.1666      13.2218     0.120034   -0.0334044      212409.      15906.9
;         133      13.2034      13.2699      13.3262     0.122766   -0.0300932      214382.      16030.6
;         134      13.3029      13.3704      13.4266     0.123662   -0.0295515      216272.      16194.3
;         135      13.4042      13.4709      13.5273     0.123071   -0.0290537      214267.      16052.1
;         136      13.5044      13.5718      13.6284     0.124030   -0.0281849      214349.      15969.9
;         137      13.6105      13.6743      13.7288     0.118332   -0.0257196      214333.      15969.2
;         138      13.7044      13.7724      13.8288     0.124384   -0.0276127      212373.      15840.9
;         139      13.8101      13.8719      13.9279     0.117820   -0.0281057      213051.      16060.3
;         140      13.9102      13.9727      14.0290     0.118772   -0.0272684      214765.      16082.9
;         141      14.0053      14.0737      14.1302     0.124913   -0.0262747      212413.      15918.1
;         142      14.1109      14.1741      14.2316     0.120762   -0.0259247      214273.      16076.1
;         143      14.2122      14.2779      14.3337     0.121490   -0.0221148      211233.      15646.5
;         144      14.3119      14.3783      14.4345     0.122590   -0.0217209      212516.      15721.4
;         145      14.4133      14.4794      14.5342     0.120914   -0.0205851      212289.      16018.8
;         146      14.5134      14.5807      14.6367     0.123277   -0.0193167      212176.      15872.4
;         147      14.6144      14.6814      14.7360     0.121583   -0.0185642      211489.      16025.8
;         148      14.7134      14.7803      14.8353     0.121841   -0.0196753      213787.      15859.9
;         149      14.8140      14.8818      14.9372     0.123214   -0.0182467      216991.      16073.3
;         150      14.9141      14.9822      15.0371     0.122995   -0.0178442      211092.      15841.1
;         151      15.0211      15.0841      15.1391     0.118015   -0.0159168      210892.      15982.0
;         152      15.1201      15.1840      15.2400     0.119863   -0.0160131      214879.      15928.4
;         153      15.2212      15.2856      15.3414     0.120174   -0.0144110      213755.      15915.9
;         154      15.3211      15.3868      15.4433     0.122257   -0.0131836      212656.      15770.9
;         155      15.4217      15.4888      15.5462     0.124482   -0.0111799      214226.      15734.4
;         156      15.5226      15.5908      15.6474     0.124801  -0.00915623      213500.      15826.8
;         157      15.6223      15.6919      15.7483     0.126060  -0.00814819      217200.      15752.6
;         158      15.7230      15.7944      15.8526     0.129645  -0.00558186      218055.      15528.2
;         159      15.8241      15.8972      15.9557     0.131574  -0.00282478      219910.      15360.9
;         160      15.9240      15.9960      16.0546     0.130564  -0.00399971      215896.      15123.9
;         161      16.0244      16.0957      16.1569     0.132500  -0.00432396      215479.      15145.7
;         162      16.1243      16.1962      16.2570     0.132660  -0.00377655      219500.      15380.4
;         163      16.2302      16.3006      16.3621     0.131884  0.000646591      218166.      15113.0
;         164      16.3321      16.4099      16.4754     0.143219   0.00994110      220348.      14312.4
;         165      16.4331      16.5168      16.5872     0.154041    0.0167732      219106.      13285.1
;         166      16.5225      16.5983      16.6585     0.136055  -0.00170135      201689.      12570.4
;         167      16.6136      16.6934      16.7604     0.146797  -0.00660706      253353.      15079.4
;         168      16.7016      16.7688      16.8185     0.116930   -0.0312233      168961.      11997.3
;       3      15.9600      24.1400      8.18000      164.000      251.000      87.0000
;   cell, integral, left, center, right, fwhm
;         169      16.7808      16.8483      16.9074     0.126654   -0.0516624      233573.      14883.9
;         170      16.8528      16.9214      16.9843     0.131575   -0.0786247      193441.      13104.2
;         171      16.9511      17.0225      17.0829     0.131832   -0.0774899      222246.      14793.6
;         172      17.0521      17.1274      17.1931     0.141039   -0.0726128      246250.      15879.7
;         173      17.1706      17.2405      17.2999     0.129230   -0.0594578      229878.      16121.1
;         174      17.2754      17.3474      17.4054     0.130026   -0.0525627      224468.      16106.2
;         175      17.3836      17.4527      17.5091     0.125532   -0.0472889      228663.      16666.2
;         176      17.4909      17.5577      17.6155     0.124599   -0.0423489      228738.      16382.2
;         177      17.5930      17.6605      17.7170     0.123980   -0.0394650      219012.      16219.7
;         178      17.6940      17.7635      17.8194     0.125422   -0.0365028      221739.      16285.1
;         179      17.8010      17.8661      17.9226     0.121643   -0.0339451      220140.      16071.5
;         180      17.9019      17.9672      18.0239     0.122047   -0.0328369      224318.      16127.0
;         181      18.0026      18.0690      18.1249     0.122227   -0.0310173      216085.      15815.5
;         182      18.1031      18.1695      18.2272     0.124136   -0.0305195      219768.      15959.6
;         183      18.2039      18.2716      18.3278     0.123911   -0.0284004      216931.      15990.4
;         184      18.3037      18.3716      18.4271     0.123396   -0.0283794      215948.      15773.8
;         185      18.4040      18.4725      18.5282     0.124243   -0.0274773      217379.      15632.0
;         186      18.5041      18.5722      18.6272     0.123047   -0.0278149      213600.      15557.1
;         187      18.6101      18.6731      18.7282     0.118074   -0.0269489      211529.      15350.0
;         188      18.7025      18.7682      18.8228     0.120270   -0.0318012      211601.      15327.2
;         189      18.8020      18.8681      18.9241     0.122145   -0.0319328      211329.      14959.0
;         190      18.8933      18.9606      19.0164     0.123165   -0.0394077      210134.      14898.8
;         191      18.9903      19.0529      19.1119     0.121626   -0.0470562      211616.      14736.8
;         192      19.0840      19.1520      19.2087     0.124722   -0.0480385      215429.      15142.5
;         193      19.1905      19.2532      19.3087     0.118216   -0.0468311      214702.      15456.6
;         194      19.2850      19.3535      19.4088     0.123812   -0.0464783      213266.      15494.8
;         195      19.3851      19.4546      19.5122     0.127085   -0.0454273      215992.      15652.1
;         196      19.4854      19.5553      19.6124     0.126987   -0.0446644      214496.      15607.9
;         197      19.5914      19.6559      19.7095     0.118147   -0.0440693      213069.      15709.6
;         198      19.6906      19.7563      19.8098     0.119242   -0.0436974      212510.      15621.0
;         199      19.7920      19.8576      19.9142     0.122225   -0.0424156      214553.      15652.9
;         200      19.8930      19.9584      20.0155     0.122486   -0.0416489      212436.      15550.9
;         201      19.9934      20.0586      20.1150     0.121628   -0.0414066      211410.      15803.4
;         202      20.0936      20.1598      20.2165     0.122877   -0.0401783      213328.      15788.7
;         203      20.2212      20.2851      20.3409     0.119747   -0.0148888      211510.      15344.5
;         204      20.3218      20.3856      20.4414     0.119595   -0.0143833      213332.      15426.5
;         205      20.4224      20.4871      20.5436     0.121216   -0.0128822      212872.      15422.5
;         206      20.5226      20.5886      20.6431     0.120577   -0.0114155      211136.      15301.7
;         207      20.6208      20.6824      20.7372     0.116434   -0.0176334      212508.      15399.9
;         208      20.7209      20.7828      20.8377     0.116783   -0.0171909      211894.      15421.5
;         209      20.8231      20.8893      20.9442     0.121046   -0.0106602      211711.      15501.4
;         210      20.9214      20.9839      21.0366     0.115206   -0.0161476      210944.      15463.7
;         211      21.0153      21.0839      21.1379     0.122583   -0.0160770      214022.      15243.9
;         212      21.1301      21.1913      21.2467     0.116602  -0.00873566      209382.      15259.3
;         213      21.2206      21.2856      21.3402     0.119549   -0.0143585      213034.      15380.8
;         214      21.3207      21.3856      21.4389     0.118210   -0.0143909      213490.      15364.0
;         215      21.4210      21.4871      21.5409     0.119860   -0.0129128      215210.      15503.3
;         216      21.5224      21.5881      21.6432     0.120840   -0.0119267      212515.      15403.3
;         217      21.6238      21.6902      21.7436     0.119850  -0.00984573      212555.      15356.0
;         218      21.7230      21.7917      21.8479     0.124834  -0.00832939      217219.      15151.6
;         219      21.8220      21.8897      21.9441     0.122055   -0.0103111      213410.      15555.1
;         220      21.9231      21.9908      22.0452     0.122082  -0.00921059      211007.      15275.8
;         221      22.0238      22.0911      22.1461     0.122349  -0.00886154      211796.      15630.5
;         222      22.1237      22.1928      22.2490     0.125349  -0.00719643      213793.      14919.1
;         223      22.2235      22.2941      22.3500     0.126505  -0.00586700      216224.      14667.6
;         224      22.3221      22.3907      22.4475     0.125431  -0.00931168      211425.      14475.6
;         225      22.4215      22.4881      22.5453     0.123789   -0.0119076      217415.      14658.9
;         226      22.5212      22.5864      22.6426     0.121378   -0.0135670      213573.      14728.9
;         227      22.6212      22.6849      22.7403     0.119062   -0.0151310      209177.      14858.7
;         228      22.7205      22.7829      22.8383     0.117830   -0.0170708      211966.      15119.4
;         229      22.8220      22.8874      22.9447     0.122742   -0.0125847      223820.      15403.6
;         230      22.9117      22.9758      23.0296     0.117893   -0.0241508      222226.      16023.2
;         231      23.0059      23.0765      23.1340     0.128042   -0.0235062      224573.      15418.2
;         232      23.1120      23.1788      23.2336     0.121599   -0.0211926      227682.      15500.5
;         233      23.2127      23.2797      23.3359     0.123262   -0.0203362      226964.      15500.5
;         234      23.3205      23.3801      23.4355     0.114994   -0.0198956      225858.      15515.8
;         235      23.4204      23.4808      23.5373     0.116972   -0.0191917      224685.      15348.9
;         236      23.5205      23.5821      23.6385     0.117998   -0.0178585      225219.      15440.8
;         237      23.6209      23.6839      23.7401     0.119156   -0.0161362      224056.      15417.8
;         238      23.7108      23.7808      23.8316     0.120802   -0.0191593      231792.      15704.8
;         239      23.8114      23.8813      23.9315     0.120150   -0.0187092      246349.      16352.5
;         240      23.9229      23.9860      24.0423     0.119322   -0.0140209      219340.      15485.8
;         241      24.0130      24.0844      24.1350     0.121990   -0.0155506      240219.      16461.0
;         242      24.1232      24.1881      24.2458     0.122532   -0.0119419      214992.      15320.0
;         243      24.2136      24.2873      24.3375     0.123953   -0.0126534      239704.      16101.3
;         244      24.3200      24.3878      24.4372     0.117176   -0.0122375      235384.      16021.8
;         245      24.4202      24.4890      24.5391     0.118959   -0.0110016      238208.      16085.0
;         246      24.5202      24.5909      24.6416     0.121418  -0.00909233      238840.      15957.8
;         247      24.6213      24.6922      24.7434     0.122183  -0.00775337      240233.      16043.9
;         248      24.7216      24.7936      24.8455     0.123962  -0.00640488      237202.      15794.9
;         249      24.8221      24.8938      24.9445     0.122387  -0.00619698      235988.      15910.8
;         250      24.9217      24.9932      25.0430     0.121269  -0.00676727      234093.      15656.4
;         251      25.0213      25.0920      25.1438     0.122471  -0.00802231      234587.      15483.5
;       4      23.9400      32.1200      8.18000      247.000      334.000      87.0000
;   cell, integral, left, center, right, fwhm
;         252      25.1202      25.1901      25.2418     0.121634  -0.00994492      232708.      15438.5
;         253      25.2137      25.2903      25.3426     0.128977  -0.00969505      228378.      15197.4
;         254      25.3129      25.3905      25.4403     0.127399  -0.00953484      225967.      14552.4
;         255      25.4044      25.4865      25.5439     0.139475   -0.0134888      222930.      13420.0
;         256      25.5004      25.5811      25.6423     0.141926   -0.0188770      206350.      11900.4
;         257      25.5849      25.6567      25.7062     0.121319   -0.0433044      233175.      15873.3
;         258      25.6711      25.7390      25.7913     0.120167   -0.0609818      214222.      14515.8
;         259      25.7646      25.8366      25.8909     0.126268   -0.0633526      232127.      15821.6
;         260      25.8732      25.9455      26.0000     0.126858   -0.0545120      234906.      16219.1
;         261      25.9804      26.0496      26.1035     0.123129   -0.0503521      235585.      16532.9
;         262      26.0826      26.1533      26.2054     0.122854   -0.0467167      232635.      16523.3
;         263      26.1901      26.2575      26.3121     0.121967   -0.0425205      233890.      16303.1
;         264      26.2915      26.3606      26.4139     0.122326   -0.0394230      228446.      16242.9
;         265      26.3930      26.4642      26.5183     0.125322   -0.0357647      233282.      16160.1
;         266      26.4944      26.5697      26.6247     0.130310   -0.0302925      241806.      16190.1
;         267      26.6016      26.6777      26.7365     0.134869   -0.0222530      241453.      15437.7
;         268      26.6934      26.7748      26.8338     0.140398   -0.0252285      229809.      13957.9
;         269      26.8007      26.8690      26.9196     0.118917   -0.0309944      216256.      14928.5
;         270      26.8902      26.9700      27.0366     0.146322   -0.0300350      222409.      12947.5
;         271      26.9722      27.0509      27.1117     0.139442   -0.0490608      211125.      13911.8
;         272      27.0905      27.1601      27.2158     0.125322   -0.0398827      216440.      15608.2
;         273      27.1912      27.2619      27.3162     0.124971   -0.0380592      226613.      16543.5
;         274      27.2938      27.3652      27.4174     0.123631   -0.0347881      226935.      16535.2
;         275      27.4001      27.4676      27.5216     0.121483   -0.0323849      227772.      16207.9
;         276      27.5017      27.5702      27.6229     0.121183   -0.0297775      226757.      16370.2
;         277      27.6023      27.6718      27.7244     0.122143   -0.0282173      222040.      15802.9
;         278      27.7025      27.7722      27.8251     0.122622   -0.0278034      224410.      16006.4
;         279      27.8021      27.8696      27.9223     0.120203   -0.0303879      215922.      15632.7
;         280      27.9020      27.9695      28.0230     0.121035   -0.0305061      219484.      15637.4
;         281      28.0023      28.0714      28.1242     0.121977   -0.0286045      221656.      15771.6
;         282      28.1017      28.1703      28.2228     0.121048   -0.0297451      220202.      15601.6
;         283      28.2009      28.2668      28.3211     0.120167   -0.0332069      213567.      15217.7
;         284      28.2937      28.3643      28.4161     0.122358   -0.0357189      213961.      15373.4
;         285      28.3915      28.4635      28.5183     0.126837   -0.0364628      228717.      15589.8
;         286      28.4919      28.5586      28.6086     0.116686   -0.0413952      211775.      15634.2
;         287      28.5819      28.6521      28.7085     0.126581   -0.0478706      225292.      15208.1
;         288      28.6808      28.7496      28.8058     0.125023   -0.0504189      216739.      15047.2
;         289      28.7819      28.8511      28.9061     0.124186   -0.0489483      218624.      15646.5
;         290      28.8818      28.9525      29.0081     0.126234   -0.0475254      217499.      15579.0
;         291      28.9830      29.0531      29.1082     0.125198   -0.0468788      222403.      16061.6
;         292      29.0829      29.1540      29.2087     0.125834   -0.0459595      217905.      15919.5
;         293      29.1901      29.2560      29.3102     0.120096   -0.0439720      216496.      15753.6
;         294      29.2909      29.3569      29.4111     0.120291   -0.0430851      217278.      15918.8
;         295      29.3902      29.4582      29.5128     0.122585   -0.0418415      216856.      15606.5
;         296      29.4917      29.5589      29.6130     0.121378   -0.0410728      216656.      15664.6
;         297      29.5921      29.6598      29.7138     0.121651   -0.0401764      216496.      15781.1
;         298      29.6931      29.7604      29.8136     0.120476   -0.0396309      215338.      16014.9
;         299      29.7920      29.8596      29.9134     0.121395   -0.0403652      213418.      15780.8
;         300      29.8922      29.9603      30.0146     0.122356   -0.0397434      215705.      15824.1
;         301      29.9929      30.0613      30.1149     0.122042   -0.0387459      214571.      15781.1
;         302      30.0931      30.1618      30.2156     0.122517   -0.0381947      213668.      15823.2
;         303      30.1934      30.2627      30.3147     0.121315   -0.0372791      216905.      15994.3
;         304      30.2936      30.3635      30.4167     0.123068   -0.0364780      209917.      15471.1
;         305      30.4000      30.4638      30.5182     0.118233   -0.0362453      218868.      16059.1
;         306      30.5006      30.5658      30.6190     0.118387   -0.0341873      212941.      15855.3
;         307      30.6011      30.6668      30.7203     0.119247   -0.0331554      214091.      15925.7
;         308      30.7014      30.7679      30.8212     0.119778   -0.0320873      213085.      15946.6
;         309      30.7936      30.8624      30.9162     0.122663   -0.0376301      215404.      15939.2
;         310      30.8945      30.9640      31.0170     0.122585   -0.0360241      213345.      16025.8
;         311      31.0026      31.0709      31.1243     0.121614   -0.0290813      214713.      16084.1
;         312      31.1003      31.1669      31.2197     0.119360   -0.0330868      214579.      16080.4
;         313      31.2009      31.2685      31.3227     0.121897   -0.0314617      211548.      15905.7
;         314      31.3019      31.3703      31.4248     0.122900   -0.0297012      215021.      16099.8
;         315      31.4033      31.4729      31.5267     0.123474   -0.0270748      214831.      16294.5
;         316      31.5100      31.5758      31.6309     0.120874   -0.0242100      213749.      16165.1
;         317      31.6122      31.6792      31.7328     0.120636   -0.0207577      211499.      16307.5
;         318      31.7131      31.7840      31.8374     0.124313   -0.0160351      209235.      15992.4
;         319      31.8210      31.8897      31.9436     0.122643   -0.0102825      203920.      15295.4
;         320      31.9141      31.9871      32.0397     0.125568   -0.0129375      215387.      15343.8
;         321      32.0028      32.0715      32.1233     0.120502   -0.0285454      202518.      14560.9
;         322      32.0927      32.1594      32.2119     0.119137   -0.0405693      205550.      14923.7
;         323      32.1902      32.2539      32.3069     0.116634   -0.0461388      208907.      14947.6
;         324      32.2831      32.3511      32.4046     0.121498   -0.0489502      207605.      15014.8
;         325      32.3826      32.4492      32.5026     0.119915   -0.0508232      210107.      15408.7
;         326      32.4822      32.5482      32.6018     0.119572   -0.0517731      206967.      15233.0
;         327      32.5817      32.6476      32.7024     0.120716   -0.0523796      210163.      15243.3
;         328      32.6818      32.7483      32.8028     0.120998   -0.0516815      210326.      15414.0
;         329      32.7836      32.8514      32.9052     0.121563   -0.0486412      210932.      15549.4
;         330      32.8838      32.9523      33.0062     0.122334   -0.0477219      209854.      15520.8
;         331      32.9844      33.0532      33.1069     0.122532   -0.0468140      211048.      15755.2
;         332      33.0831      33.1510      33.2053     0.122272   -0.0490341      209604.      15653.4
;         333      33.1903      33.2550      33.3099     0.119637   -0.0450172      210339.      15537.0
;         334      33.2906      33.3562      33.4100     0.119411   -0.0438156      210812.      15669.0
;       5      31.9200      40.1000      8.18000      330.000      417.000      87.0000
;   cell, integral, left, center, right, fwhm
;         335      33.3908      33.4576      33.5109     0.120060   -0.0423965      210928.      15550.0
;         336      33.4918      33.5588      33.6121     0.120239   -0.0411987      210208.      15697.1
;         337      33.5923      33.6596      33.7129     0.120605   -0.0403557      210091.      15444.0
;         338      33.6925      33.7601      33.8140     0.121433   -0.0399017      209949.      15445.5
;         339      33.7929      33.8603      33.9128     0.119881   -0.0396538      208538.      15596.7
;         340      33.8919      33.9587      34.0132     0.121342   -0.0413437      212061.      15390.5
;         341      33.9926      34.0602      34.1135     0.120907   -0.0397530      206582.      15257.1
;         342      34.0918      34.1583      34.2117     0.119942   -0.0416985      209459.      15307.4
;         343      34.1918      34.2584      34.3124     0.120556   -0.0415878      210788.      15384.9
;         344      34.2917      34.3586      34.4124     0.120705   -0.0413551      209527.      15317.2
;         345      34.3917      34.4577      34.5114     0.119701   -0.0422745      207585.      15206.6
;         346      34.4909      34.5568      34.6105     0.119587   -0.0432281      207440.      15139.3
;         347      34.5844      34.6551      34.7084     0.123974   -0.0449371      205207.      15087.6
;         348      34.6837      34.7539      34.8073     0.123547   -0.0461159      208956.      15305.9
;         349      34.7835      34.8527      34.9061     0.122509   -0.0472565      204817.      14934.5
;         350      34.8825      34.9504      35.0041     0.121590   -0.0495605      207834.      15034.3
;         351      34.9741      35.0448      35.0997     0.125572   -0.0551529      206361.      14938.3
;         352      35.0728      35.1437      35.1991     0.126312   -0.0562744      205581.      14727.7
;         353      35.1732      35.2428      35.2990     0.125786   -0.0571938      207138.      15046.6
;         354      35.2729      35.3422      35.3974     0.124508   -0.0578041      205354.      15207.7
;         355      35.3722      35.4413      35.4961     0.123928   -0.0587044      208503.      15303.6
;         356      35.4723      35.5419      35.5982     0.125908   -0.0580635      208641.      15270.1
;         357      35.5729      35.6425      35.6980     0.125179   -0.0574760      208261.      15442.5
;         358      35.6735      35.7434      35.7974     0.123901   -0.0566139      209298.      15719.3
;         359      35.7810      35.8468      35.9011     0.120136   -0.0531883      205697.      15490.6
;         360      35.8743      35.9435      35.9978     0.123501   -0.0565033      209101.      15833.3
;         361      35.9803      36.0448      36.0991     0.118740   -0.0552292      208561.      15596.6
;         362      36.0822      36.1502      36.2057     0.123482   -0.0497971      207047.      15454.7
;         363      36.1830      36.2520      36.3069     0.123875   -0.0479507      206570.      15529.1
;         364      36.2901      36.3533      36.4082     0.118050   -0.0467453      206593.      15618.1
;         365      36.3907      36.4552      36.5105     0.119793   -0.0447540      207529.      15586.3
;         366      36.4911      36.5571      36.6113     0.120144   -0.0428734      206229.      15462.4
;         367      36.5923      36.6579      36.7118     0.119423   -0.0420647      206794.      15651.0
;         368      36.6911      36.7569      36.8104     0.119236   -0.0430603      207138.      15472.5
;         369      36.7903      36.8571      36.9108     0.120453   -0.0429077      206876.      15215.6
;         370      36.8916      36.9581      37.0112     0.119564   -0.0419197      208755.      15447.5
;         371      36.9921      37.0585      37.1114     0.119350   -0.0415306      204414.      15159.0
;         372      37.0911      37.1579      37.2106     0.119534   -0.0420914      209340.      15543.2
;         373      37.1920      37.2584      37.3098     0.117855   -0.0416489      206423.      15394.2
;         374      37.2923      37.3589      37.4126     0.120228   -0.0410576      208474.      15388.4
;         375      37.3925      37.4598      37.5133     0.120815   -0.0401917      207146.      15505.2
;         376      37.4927      37.5601      37.6144     0.121704   -0.0398712      208644.      15571.1
;         377      37.5931      37.6611      37.7149     0.121861   -0.0389404      207377.      15553.7
;         378      37.6930      37.7611      37.8144     0.121330   -0.0389481      205919.      15330.2
;         379      37.7943      37.8629      37.9161     0.121799   -0.0370522      207840.      15490.7
;         380      37.8923      37.9592      38.0140     0.121738   -0.0407677      205082.      15187.0
;         381      37.9914      38.0577      38.1116     0.120232   -0.0422554      204508.      15246.3
;         382      38.0913      38.1596      38.2142     0.122890   -0.0403557      204619.      14781.0
;         383      38.1919      38.2583      38.3102     0.118271   -0.0417023      204442.      14874.0
;         384      38.2908      38.3560      38.4096     0.118835   -0.0440407      205810.      14624.9
;         385      38.3830      38.4512      38.5054     0.122375   -0.0488243      202925.      14476.3
;         386      38.4821      38.5482      38.6018     0.119759   -0.0517998      204802.      14814.0
;         387      38.5813      38.6462      38.7009     0.119644   -0.0538406      206057.      15139.4
;         388      38.6806      38.7449      38.7991     0.118443   -0.0550652      205794.      15155.6
;         389      38.7819      38.8503      38.9060     0.124096   -0.0496864      208821.      15451.1
;         390      38.8832      38.9513      39.0061     0.122871   -0.0486565      205847.      15394.6
;         391      38.9809      39.0454      39.1008     0.119965   -0.0545921      206386.      15475.2
;         392      39.0836      39.1528      39.2076     0.123997   -0.0471916      208709.      15673.2
;         393      39.1903      39.2541      39.3070     0.116661   -0.0459442      206737.      15633.7
;         394      39.2905      39.3554      39.4103     0.119785   -0.0445747      209470.      15457.2
;         395      39.3914      39.4565      39.5114     0.119934   -0.0435181      208066.      15415.9
;         396      39.4919      39.5574      39.6116     0.119766   -0.0426483      208314.      15525.4
;         397      39.5810      39.6476      39.7013     0.120346   -0.0523720      206363.      15471.9
;         398      39.6818      39.7485      39.8016     0.119797   -0.0515137      208603.      15612.4
;         399      39.7821      39.8498      39.9029     0.120804   -0.0501556      207921.      15664.2
;         400      39.8931      39.9611      40.0164     0.123302   -0.0389366      209045.      15492.6
;         401      39.9940      40.0627      40.1165     0.122562   -0.0372810      208400.      15583.6
;         402      40.0905      40.1544      40.2089     0.118343   -0.0455780      209259.      15645.0
;         403      40.1915      40.2564      40.3110     0.119465   -0.0436172      208221.      15592.0
;         404      40.2917      40.3580      40.4129     0.121262   -0.0419884      210405.      15417.1
;         405      40.3929      40.4599      40.5132     0.120266   -0.0400581      208775.      15561.6
;         406      40.4934      40.5609      40.6140     0.120583   -0.0391350      207014.      15267.3
;         407      40.5822      40.6497      40.7022     0.120026   -0.0502892      210835.      15392.2
;         408      40.6819      40.7486      40.8025     0.120590   -0.0513611      209295.      15169.7
;         409      40.7813      40.8467      40.8993     0.117989   -0.0532761      208606.      15304.9
;         410      40.8802      40.9450      40.9980     0.117786   -0.0550079      208884.      15223.2
;         411      40.9743      41.0434      41.0959     0.121590   -0.0566330      208708.      15264.1
;Intersection Analysis
;At     0.298078 between       4 and       3
;At     0.209782 between       5 and       4
;At    0.0571646 between       6 and       5
;At   -0.0259963 between       7 and       6
;At   -0.0594684 between       8 and       7
;At   -0.0710539 between       9 and       8
;At   -0.0685778 between      10 and       9
;At   -0.0702989 between      11 and      10
;At   -0.0689542 between      12 and      11
;At   -0.0728956 between      13 and      12
;At   -0.0771294 between      14 and      13
;At   -0.0821145 between      15 and      14
;At   -0.0866359 between      16 and      15
;At   -0.0933617 between      17 and      16
;At   -0.0994127 between      18 and      17
;At   -0.0995895 between      19 and      18
;At    -0.102502 between      20 and      19
;At    -0.108605 between      21 and      20
;At    -0.116473 between      22 and      21
;At    -0.129915 between      23 and      22
;At    -0.139081 between      24 and      23
;At    -0.225086 between      26 and      24
;At    -0.275840 between      27 and      26
;At    -0.338128 between      28 and      27
;At    -0.255740 between      34 and      28
;At     0.151569 between      35 and      34
;At    0.0949328 between      36 and      35
;At    0.0563252 between      37 and      36
;At    0.0276041 between      38 and      37
;At   0.00245118 between      39 and      38
;At  -0.00780535 between      40 and      39
;At   -0.0206819 between      41 and      40
;At   -0.0332165 between      42 and      41
;At   -0.0450454 between      43 and      42
;At   -0.0429635 between      44 and      43
;At   -0.0295477 between      45 and      44
;At   -0.0220156 between      46 and      45
;At   -0.0268240 between      47 and      46
;At   -0.0362120 between      48 and      47
;At   -0.0446453 between      49 and      48
;At   -0.0529404 between      50 and      49
;At   -0.0537567 between      51 and      50
;At   -0.0451455 between      52 and      51
;At   -0.0334983 between      53 and      52
;At   -0.0305057 between      54 and      53
;At   -0.0362072 between      55 and      54
;At   -0.0432243 between      56 and      55
;At   -0.0499291 between      57 and      56
;At   -0.0564847 between      58 and      57
;At   -0.0613999 between      59 and      58
;At   -0.0695176 between      60 and      59
;At   -0.0780745 between      61 and      60
;At   -0.0887079 between      62 and      61
;At   -0.0969453 between      64 and      62
;At  -0.00415325 between      65 and      64
;At   -0.0119104 between      66 and      65
;At   -0.0267282 between      67 and      66
;At   -0.0325394 between      68 and      67
;At   -0.0315146 between      69 and      68
;At   -0.0367303 between      70 and      69
;At   -0.0388374 between      71 and      70
;At   -0.0394835 between      72 and      71
;At   -0.0431919 between      73 and      72
;At   -0.0427246 between      74 and      73
;At   -0.0439463 between      75 and      74
;At   -0.0415339 between      76 and      75
;At   -0.0452137 between      77 and      76
;At   -0.0631948 between      80 and      77
;At    -0.230318 between      81 and      78
;At   -0.0470343 between      82 and      81
;At   -0.0502329 between      83 and      82
;At   -0.0486965 between      84 and      83
;At   -0.0514641 between      85 and      84
;At   -0.0508919 between      86 and      85
;At   -0.0541840 between      87 and      86
;At   -0.0580635 between      88 and      87
;At   -0.0566330 between      89 and      88
;At   -0.0588875 between      90 and      89
;At   -0.0584354 between      91 and      90
;At   -0.0590601 between      92 and      91
;At   -0.0623455 between      93 and      92
;At   -0.0637312 between      94 and      93
;At   -0.0678930 between      95 and      94
;At   -0.0672598 between      96 and      95
;At   -0.0661516 between      97 and      96
;At   -0.0692253 between      98 and      97
;At   -0.0669003 between      99 and      98
;At   -0.0630426 between     100 and      99
;At   -0.0534964 between     101 and     100
;At   -0.0286436 between     102 and     101
;At   -0.0215225 between     103 and     102
;At   -0.0193748 between     104 and     103
;At   -0.0243607 between     105 and     104
;At   -0.0288839 between     106 and     105
;At   -0.0258198 between     107 and     106
;At   -0.0239611 between     108 and     107
;At   -0.0262661 between     109 and     108
;At   -0.0291834 between     110 and     109
;At   -0.0303507 between     111 and     110
;At   -0.0313702 between     112 and     111
;At   -0.0313005 between     113 and     112
;At   -0.0332432 between     114 and     113
;At   -0.0361309 between     115 and     114
;At   -0.0361776 between     116 and     115
;At   -0.0320492 between     117 and     116
;At   -0.0287914 between     118 and     117
;At   -0.0280428 between     119 and     118
;At   -0.0281258 between     120 and     119
;At   -0.0283642 between     121 and     120
;At   -0.0301304 between     122 and     121
;At   -0.0278492 between     123 and     122
;At   -0.0275059 between     124 and     123
;At   -0.0269279 between     125 and     124
;At   -0.0163708 between     126 and     125
;At   -0.0248747 between     127 and     126
;At   -0.0187206 between     128 and     127
;At   -0.0155296 between     129 and     128
;At   -0.0142097 between     130 and     129
;At   -0.0116911 between     131 and     130
;At   -0.0130806 between     132 and     131
;At   -0.0147829 between     133 and     132
;At   -0.0160456 between     134 and     133
;At   -0.0181875 between     135 and     134
;At   -0.0191288 between     136 and     135
;At   -0.0207024 between     137 and     136
;At   -0.0199718 between     138 and     137
;At   -0.0176058 between     139 and     138
;At   -0.0174732 between     140 and     139
;At   -0.0204859 between     141 and     140
;At   -0.0188599 between     142 and     141
;At   -0.0225983 between     143 and     142
;At   -0.0243330 between     144 and     143
;At   -0.0247869 between     145 and     144
;At   -0.0251236 between     146 and     145
;At   -0.0274324 between     147 and     146
;At   -0.0254612 between     148 and     147
;At   -0.0266514 between     149 and     148
;At   -0.0285378 between     150 and     149
;At   -0.0289621 between     151 and     150
;At   -0.0300913 between     152 and     151
;At   -0.0302238 between     153 and     152
;At   -0.0319166 between     154 and     153
;At   -0.0328846 between     155 and     154
;At   -0.0362320 between     156 and     155
;At   -0.0372362 between     157 and     156
;At   -0.0386992 between     158 and     157
;At   -0.0417347 between     159 and     158
;At   -0.0427637 between     160 and     159
;At   -0.0426445 between     161 and     160
;At   -0.0423813 between     162 and     161
;At   -0.0445557 between     163 and     162
;At   -0.0498428 between     164 and     163
;At   -0.0621395 between     165 and     164
;At   -0.0571537 between     166 and     165
;At   -0.0352783 between     167 and     166
;At   -0.0450401 between     168 and     167
;At   0.00176430 between     169 and     168
;At    0.0151234 between     170 and     169
;At    0.0377731 between     171 and     170
;At    0.0342655 between     172 and     171
;At    0.0170898 between     173 and     172
;At   0.00876808 between     174 and     173
;At   0.00421524 between     175 and     174
;At  0.000764847 between     176 and     175
;At  -0.00554848 between     177 and     176
;At  -0.00658035 between     178 and     177
;At  -0.00952339 between     179 and     178
;At   -0.0120068 between     180 and     179
;At   -0.0137405 between     181 and     180
;At   -0.0146408 between     182 and     181
;At   -0.0172462 between     183 and     182
;At   -0.0173779 between     184 and     183
;At   -0.0175800 between     185 and     184
;At   -0.0193405 between     186 and     185
;At   -0.0191936 between     187 and     186
;At   -0.0165520 between     188 and     187
;At   -0.0127525 between     189 and     188
;At   -0.0107002 between     190 and     189
;At  -0.00167465 between     191 and     190
;At  0.000795364 between     192 and     191
;At -0.000169754 between     193 and     192
;At  -0.00115585 between     194 and     193
;At  -0.00148773 between     195 and     194
;At  -0.00200844 between     196 and     195
;At  -0.00310898 between     197 and     196
;At  -0.00291252 between     198 and     197
;At  -0.00276566 between     199 and     198
;At  -0.00300980 between     200 and     199
;At  -0.00444984 between     201 and     200
;At  -0.00513077 between     202 and     201
;At   -0.0195885 between     203 and     202
;At   -0.0298271 between     204 and     203
;At   -0.0315990 between     205 and     204
;At   -0.0349312 between     206 and     205
;At   -0.0316448 between     207 and     206
;At   -0.0300503 between     208 and     207
;At   -0.0319080 between     209 and     208
;At   -0.0336533 between     210 and     209
;At   -0.0305557 between     211 and     210
;At   -0.0347595 between     212 and     211
;At   -0.0349407 between     213 and     212
;At   -0.0326195 between     214 and     213
;At   -0.0331039 between     215 and     214
;At   -0.0336723 between     216 and     215
;At   -0.0360832 between     217 and     216
;At   -0.0358028 between     218 and     217
;At   -0.0364971 between     219 and     218
;At   -0.0354481 between     220 and     219
;At   -0.0355930 between     221 and     220
;At   -0.0377235 between     222 and     221
;At   -0.0388851 between     223 and     222
;At   -0.0370140 between     224 and     223
;At   -0.0343723 between     225 and     224
;At   -0.0335884 between     226 and     225
;At   -0.0322914 between     227 and     226
;At   -0.0309887 between     228 and     227
;At   -0.0322304 between     229 and     228
;At   -0.0313854 between     230 and     229
;At   -0.0237083 between     231 and     230
;At   -0.0257473 between     232 and     231
;At   -0.0258789 between     233 and     232
;At   -0.0293694 between     234 and     233
;At   -0.0268612 between     235 and     234
;At   -0.0290585 between     236 and     235
;At   -0.0305920 between     237 and     236
;At   -0.0262909 between     238 and     237
;At   -0.0207767 between     239 and     238
;At   -0.0281010 between     240 and     239
;At   -0.0286446 between     241 and     240
;At   -0.0319920 between     242 and     241
;At   -0.0296917 between     243 and     242
;At   -0.0295963 between     244 and     243
;At   -0.0300961 between     245 and     244
;At   -0.0315914 between     246 and     245
;At   -0.0329609 between     247 and     246
;At   -0.0337887 between     248 and     247
;At   -0.0355816 between     249 and     248
;At   -0.0351391 between     250 and     249
;At   -0.0336304 between     251 and     250
;At   -0.0300846 between     252 and     251
;At   -0.0291710 between     253 and     252
;At   -0.0286064 between     254 and     253
;At   -0.0245075 between     255 and     254
;At   -0.0237694 between     256 and     255
;At  -0.00971603 between     257 and     256
;At   0.00697517 between     258 and     257
;At    0.0214462 between     259 and     258
;At    0.0167484 between     260 and     259
;At   0.00988197 between     261 and     260
;At   0.00530815 between     262 and     261
;At   0.00214386 between     263 and     262
;At  -0.00263214 between     264 and     263
;At  -0.00555420 between     265 and     264
;At  -0.00954628 between     266 and     265
;At   -0.0150681 between     267 and     266
;At   -0.0142269 between     268 and     267
;At   -0.0183659 between     269 and     268
;At  -0.00691605 between     270 and     269
;At   -0.0112305 between     271 and     270
;At   0.00166321 between     272 and     271
;At  -0.00306511 between     273 and     272
;At  -0.00687790 between     274 and     273
;At  -0.00826645 between     275 and     274
;At   -0.0121517 between     276 and     275
;At   -0.0142746 between     277 and     276
;At   -0.0148182 between     278 and     277
;At   -0.0145855 between     279 and     278
;At   -0.0120869 between     280 and     279
;At   -0.0130939 between     281 and     280
;At   -0.0145283 between     282 and     281
;At   -0.0119572 between     283 and     282
;At  -0.00842285 between     284 and     283
;At  -0.00396347 between     285 and     284
;At  -0.00590515 between     286 and     285
;At   0.00253868 between     287 and     286
;At   0.00504303 between     288 and     287
;At   0.00612259 between     289 and     288
;At   0.00433540 between     290 and     289
;At   0.00402641 between     291 and     290
;At   0.00217819 between     292 and     291
;At  0.000949860 between     293 and     292
;At -3.24249e-05 between     294 and     293
;At  0.000242233 between     295 and     294
;At  -0.00298309 between     296 and     295
;At  -0.00372124 between     297 and     296
;At  -0.00415230 between     298 and     297
;At  -0.00404549 between     299 and     298
;At  -0.00394630 between     300 and     299
;At  -0.00510216 between     301 and     300
;At  -0.00596619 between     302 and     301
;At  -0.00636673 between     303 and     302
;At  -0.00722694 between     304 and     303
;At  -0.00758553 between     305 and     304
;At  -0.00950432 between     306 and     305
;At  -0.00993919 between     307 and     306
;At   -0.0114079 between     308 and     307
;At  -0.00914955 between     309 and     308
;At  -0.00851440 between     310 and     309
;At   -0.0115852 between     311 and     310
;At   -0.0132713 between     312 and     311
;At   -0.0124779 between     313 and     312
;At   -0.0118885 between     314 and     313
;At   -0.0157204 between     315 and     314
;At   -0.0179100 between     316 and     315
;At   -0.0205097 between     317 and     316
;At   -0.0249596 between     318 and     317
;At   -0.0305252 between     319 and     318
;At   -0.0302544 between     320 and     319
;At   -0.0243607 between     321 and     320
;At  -0.00920868 between     322 and     321
;At  -0.00169373 between     323 and     322
;At   0.00357437 between     324 and     323
;At   0.00569916 between     325 and     324
;At   0.00667572 between     326 and     325
;At   0.00783920 between     327 and     326
;At   0.00745010 between     328 and     327
;At   0.00532532 between     329 and     328
;At   0.00267792 between     330 and     329
;At   0.00199127 between     331 and     330
;At   0.00265884 between     332 and     331
;At   0.00165176 between     333 and     332
;At  0.000865936 between     334 and     333
;At  -0.00212860 between     335 and     334
;At  -0.00350189 between     336 and     335
;At  -0.00431061 between     337 and     336
;At  -0.00472641 between     338 and     337
;At  -0.00523758 between     339 and     338
;At  -0.00370789 between     340 and     339
;At  -0.00502777 between     341 and     340
;At  -0.00413132 between     342 and     341
;At  -0.00288391 between     343 and     342
;At  -0.00352478 between     344 and     343
;At  -0.00340652 between     345 and     344
;At  -0.00147629 between     346 and     345
;At -0.000255585 between     347 and     346
;At   0.00252151 between     348 and     347
;At   0.00281906 between     349 and     348
;At   0.00532150 between     350 and     349
;At   0.00890732 between     351 and     350
;At    0.0119057 between     352 and     351
;At    0.0124245 between     353 and     352
;At    0.0128593 between     354 and     353
;At    0.0140991 between     355 and     354
;At    0.0139618 between     356 and     355
;At    0.0131226 between     357 and     356
;At    0.0124969 between     358 and     357
;At   0.00966644 between     359 and     358
;At    0.0100098 between     360 and     359
;At    0.0119591 between     361 and     360
;At   0.00742340 between     362 and     361
;At   0.00376129 between     363 and     362
;At   0.00237656 between     364 and     363
;At   0.00141144 between     365 and     364
;At -0.000450134 between     366 and     365
;At  -0.00173187 between     367 and     366
;At  -0.00167084 between     368 and     367
;At -0.000255585 between     369 and     368
;At  -0.00237274 between     370 and     369
;At  -0.00317001 between     371 and     370
;At  -0.00254059 between     372 and     371
;At  -0.00289536 between     373 and     372
;At  -0.00309753 between     374 and     373
;At  -0.00385666 between     375 and     374
;At  -0.00472641 between     376 and     375
;At  -0.00531769 between     377 and     376
;At  -0.00628281 between     378 and     377
;At  -0.00700760 between     379 and     378
;At  -0.00577164 between     380 and     379
;At  -0.00288391 between     381 and     380
;At  -0.00295639 between     382 and     381
;At  -0.00339890 between     383 and     382
;At  0.000801086 between     384 and     383
;At   0.00177765 between     385 and     384
;At   0.00469971 between     386 and     385
;At   0.00726318 between     387 and     386
;At   0.00867462 between     388 and     387
;At   0.00743866 between     389 and     388
;At   0.00311279 between     390 and     389
;At   0.00679016 between     391 and     390
;At   0.00627518 between     392 and     391
;At   0.00157928 between     393 and     392
;At   0.00158691 between     394 and     393
;At  -0.00102997 between     395 and     394
;At  -0.00282288 between     396 and     395
;At   0.00296783 between     397 and     396
;At   0.00675583 between     398 and     397
;At   0.00558472 between     399 and     398
;At  0.000518799 between     400 and     399
;At  -0.00780106 between     401 and     400
;At  -0.00281525 between     402 and     401
;At  0.000278473 between     403 and     402
;At  0.000389099 between     404 and     403
;At  -0.00423813 between     405 and     404
;At  -0.00508499 between     406 and     405
;At   0.00147247 between     407 and     406
;At   0.00597000 between     408 and     407
;At   0.00671005 between     409 and     408
;At   0.00848770 between     410 and     409
;At    0.0103912 between     411 and     410
.run plotdfil
plotdfil,0,40.1,mul=5,/ps,pr='dj1_d20',thr=t,/por,scal=2.5,ysi=26,xoffs=1,yoffs=-0.5,inten=1000.,fwh=width,posi=pos,cel=cell,ov=.1,inters=is,interw=iw
;Create def_0_411.ps XSIZE=      20.4500 cm
;       1      0.00000      8.18000      8.18000     -6.00000      81.0000      87.0000
;   cell, integral, left, center, right, fwhm
;           1    -0.138281    0.0537944     0.178762     0.317043   -0.0462056      35819.1      1118.45
;           2    -0.146574    0.0922954     0.263293     0.409867    -0.107705      50485.2      1271.57
;           3     0.319920     0.159132     0.391879    0.0719587    -0.140868      128372.      2679.71
;           4     0.281492     0.205839     0.446791     0.165298    -0.194161      123815.      3323.10
;           5     0.201654     0.408531     0.584800     0.383145   -0.0914689      254184.      6398.48
;           6     0.423830     0.570380     0.695350     0.271520   -0.0296199      283049.      9648.06
;           7     0.592007     0.701791     0.803043     0.211036   0.00179094      291306.      12276.7
;           8     0.730291     0.818709     0.895817     0.165527    0.0187088      251656.      13495.9
;           9     0.844796     0.922421     0.986559     0.141762    0.0224206      237982.      14188.7
;          10     0.952560      1.02345      1.08377     0.131205    0.0234536      234314.      15437.8
;          11      1.05368      1.12441      1.18062     0.126936    0.0244067      230655.      15770.2
;          12      1.15383      1.22626      1.28460     0.130768    0.0262562      236546.      15839.2
;          13      1.26159      1.33026      1.38785     0.126251    0.0302591      238845.      16242.5
;          14      1.36388      1.43518      1.49358     0.129702    0.0351833      236550.      16000.7
;          15      1.47101      1.53957      1.59723     0.126225    0.0395740      235974.      16090.9
;          16      1.57291      1.64548      1.70502     0.132108    0.0454843      235022.      15680.5
;          17      1.68163      1.75026      1.80961     0.127984    0.0502642      233697.      15943.5
;          18      1.78402      1.85454      1.91335     0.129327    0.0545433      226247.      15648.3
;          19      1.88288      1.95255      2.01315     0.130263    0.0525512      243335.      15850.3
;          20      1.99039      2.05775      2.11986     0.129466    0.0577543      242885.      15726.0
;          21      2.09385      2.16542      2.22803     0.134172    0.0654182      242976.      15642.9
;          22      2.20141      2.27573      2.34361     0.142206    0.0757277      247233.      15058.2
;          23      2.31121      2.38627      2.45553     0.144315    0.0862720      237478.      14209.3
;          24      2.41294      2.48961      2.56001     0.147067    0.0896084      233536.      13348.7
;          26      2.75079      2.81702      2.89308     0.142289     0.217020      218483.      12654.2
;          27      2.85280      2.92377      3.01549     0.162691     0.223775      241117.      12319.0
;          28      2.79003      2.94454      3.11547     0.325436     0.144538      121825.      3341.04
;          29      2.94318      3.01806      3.11345     0.170269     0.118059      32045.6      1329.44
;          30      3.04573      3.12267      3.22417     0.178437     0.122670      40465.1      1716.36
;          31      3.06439      3.18277      3.28400     0.219611    0.0827663      16512.6      696.495
;          32      2.92231      3.10804      3.21332     0.291009   -0.0919645      89850.9      2465.15
;          33      2.96468      3.15216      3.37014     0.405460    -0.147838      82891.4      2352.47
;          34      3.07616      3.18496      3.25297     0.176817    -0.215038      235487.      12005.4
;          35      3.24454      3.34555      3.40713     0.162593    -0.154455      253057.      13071.3
;          36      3.40289      3.49071      3.55274     0.149855    -0.109290      239122.      13640.4
;          37      3.53446      3.61955      3.68357     0.149114   -0.0804453      242114.      14326.9
;          38      3.66435      3.74478      3.80891     0.144556   -0.0552249      252998.      15514.8
;          39      3.78456      3.85906      3.92114     0.136580   -0.0409365      248248.      16069.8
;          40      3.90124      3.97170      4.03301     0.131769   -0.0282991      255039.      16644.2
;          41      4.01035      4.07945      4.13918     0.128828   -0.0205498      241170.      16168.5
;          42      4.12266      4.19382      4.24964     0.126977  -0.00617504      246789.      16753.4
;          43      4.23143      4.30142      4.35015     0.118717   0.00141811      235073.      15922.3
;          44      4.33322      4.39396      4.44097     0.107749  -0.00604439      236370.      17319.4
;          45      4.41241      4.48083      4.53340     0.120985   -0.0191655      224596.      14817.4
;          46      4.51210      4.57802      4.63666     0.124563   -0.0219808      245734.      16457.0
;          47      4.62023      4.68649      4.74360     0.123374   -0.0135136      228180.      16633.6
;          48      4.72447      4.79439      4.85129     0.126824  -0.00561428      224452.      16447.6
;          49      4.83237      4.90251      4.96037     0.127994   0.00250769      224174.      16176.6
;          50      4.94051      5.00903      5.06094     0.120435   0.00903463      219993.      15954.1
;          51      5.04077      5.10818      5.16237     0.121600   0.00817633      241634.      15908.1
;          52      5.13259      5.19230      5.23801     0.105420  -0.00769901      238610.      18304.9
;          53      5.22099      5.28294      5.34043     0.119431   -0.0170612      226182.      15721.9
;          54      5.32217      5.38840      5.44364     0.121475   -0.0116043      226406.      16593.9
;          55      5.43056      5.49509      5.55030     0.119740  -0.00491285      230034.      16917.1
;          56      5.53329      5.60191      5.65752     0.124224   0.00191164      226324.      16530.1
;          57      5.64228      5.71009      5.76503     0.122749    0.0100889      225908.      16485.9
;          58      5.74354      5.81247      5.86950     0.125963    0.0124707      224698.      16315.6
;          59      5.85305      5.92062      5.97754     0.124485    0.0206223      228691.      16544.9
;          60      5.95523      6.02658      6.08265     0.127418    0.0265799      229459.      16494.1
;          61      6.07131      6.13971      6.19623     0.124924    0.0397091      228343.      16139.2
;          62      6.18039      6.24625      6.30180     0.121406    0.0462461      234289.      16214.9
;          63      6.24267      6.29795      6.34258    0.0999107  -0.00204563      72002.9      6070.91
;          64      6.28334      6.35752      6.41952     0.136188   -0.0424786      237914.      15538.3
;          65      6.39027      6.46096      6.52293     0.132659   -0.0390415      233727.      15504.6
;          66      6.50286      6.57344      6.63368     0.130816   -0.0265574      234482.      16230.6
;          67      6.61442      6.68618      6.74465     0.130233   -0.0138154      226426.      15928.6
;          68      6.72067      6.78572      6.84334     0.122669   -0.0142827      224556.      16188.6
;          69      6.82189      6.88734      6.94302     0.121136   -0.0126572      219169.      16094.5
;          70      6.93040      6.99437      7.05075     0.120354  -0.00563145      220246.      16086.5
;          71      7.02241      7.09105      7.14662     0.124214  -0.00895262      218196.      15850.5
;          72      7.13108      7.19649      7.25387     0.122795  -0.00351477      218701.      15764.5
;          73      7.23254      7.29708      7.35283     0.120286  -0.00292301      216457.      16018.4
;          74      7.33243      7.39793      7.45112     0.118692  -0.00206995      218928.      15792.0
;          75      7.43208      7.49832      7.55306     0.120981  -0.00168037      217921.      15579.4
;          76      7.53283      7.59721      7.65351     0.120680  -0.00279236      228209.      16299.1
;          77      7.63370      7.70278      7.75504     0.121342   0.00277758      212245.      16733.5
;          78      7.88714      7.90720      8.04988     0.162744     0.107198      212104.      9628.00
;          79      7.83437      7.90087      7.95416     0.119786  0.000869751      233664.      17893.3
;          80      7.74041      7.87420      7.85008     0.109671    -0.125798      215888.      9882.05
;          81      8.03394      8.09873      8.15486     0.120915  -0.00127316      233255.      17269.0
;       2      7.98000      16.1600      8.18000      73.0000      160.000      87.0000
;   cell, integral, left, center, right, fwhm
;          82      8.13316      8.20230      8.25748     0.124318   0.00229740      212765.      16105.6
;          83      8.24078      8.30413      8.35901     0.118237   0.00412750      201822.      15469.2
;          84      8.34083      8.40485      8.45968     0.118854   0.00484848      204517.      15801.5
;          85      8.43586      8.50538      8.55873     0.122875   0.00537682      203103.      15540.2
;          86      8.54130      8.60636      8.66251     0.121202   0.00635529      206616.      15620.2
;          87      8.64222      8.71108      8.76720     0.124981    0.0110807      212560.      15867.0
;          88      8.74389      8.81219      8.86664     0.122746    0.0121880      209087.      15771.1
;          89      8.84406      8.91344      8.96728     0.123225    0.0134449      211201.      15725.8
;          90      8.94334      9.01135      9.06746     0.124116    0.0113468      207619.      15540.3
;          91      9.05113      9.11571      9.17271     0.121582    0.0157137      209937.      15570.3
;          92      9.14402      9.21377      9.26901     0.124984    0.0137739      207374.      15504.8
;          93      9.25116      9.31820      9.37457     0.123406    0.0181999      209129.      15702.6
;          94      9.35204      9.41944      9.47516     0.123113    0.0194435      210250.      15393.4
;          95      9.45329      9.52157      9.57611     0.122818    0.0215712      210666.      15217.6
;          96      9.55051      9.61908      9.67529     0.124778    0.0190783      210884.      14738.8
;          97      9.65355      9.72197      9.77866     0.125102    0.0219660      216659.      15079.7
;          98      9.75326      9.82052      9.87854     0.125279    0.0205164      209912.      14755.0
;          99      9.85268      9.91806      9.97134     0.118663    0.0180607      203769.      14819.0
;         100      9.95098      10.0186      10.0747     0.123766    0.0185862      207579.      14000.9
;         101      10.0306      10.0890      10.1423     0.111710   -0.0109911      193303.      14148.8
;         102      10.1135      10.1786      10.2347     0.121238   -0.0213900      207273.      14652.7
;         103      10.2115      10.2731      10.3313     0.119824   -0.0269184      202789.      14991.8
;         104      10.3114      10.3760      10.4335     0.122142   -0.0239553      213704.      15961.3
;         105      10.4129      10.4799      10.5374     0.124408   -0.0200577      212030.      16004.2
;         106      10.5146      10.5835      10.6407     0.126097   -0.0164766      214637.      16081.3
;         107      10.6107      10.6760      10.7334     0.122686   -0.0240459      213723.      15906.9
;         108      10.7124      10.7781      10.8344     0.121994   -0.0219212      211339.      15993.0
;         109      10.8126      10.8801      10.9374     0.124761   -0.0199223      212425.      16107.3
;         110      10.9203      10.9825      11.0388     0.118572   -0.0174532      210510.      16187.9
;         111      11.0154      11.0834      11.1383     0.122881   -0.0166035      208765.      16090.3
;         112      11.1201      11.1847      11.2413     0.121195   -0.0153017      210140.      16008.1
;         113      11.2221      11.2864      11.3406     0.118505   -0.0135565      209698.      16104.1
;         114      11.3215      11.3878      11.4446     0.123065   -0.0121927      209857.      16042.1
;         115      11.4233      11.4896      11.5452     0.121852   -0.0104151      210299.      16148.7
;         116      11.5236      11.5910      11.6472     0.123575  -0.00904369      211923.      15801.7
;         117      11.6135      11.6815      11.7377     0.124134   -0.0184660      217171.      16070.5
;         118      11.7143      11.7824      11.8386     0.124269   -0.0176125      216464.      16044.6
;         119      11.8147      11.8831      11.9375     0.122888   -0.0168667      217703.      16240.1
;         120      11.9203      11.9833      12.0382     0.117890   -0.0166779      216159.      16112.6
;         121      12.0206      12.0837      12.1388     0.118132   -0.0162535      216385.      15872.4
;         122      12.1150      12.1830      12.2385     0.123503   -0.0169592      214350.      15846.3
;         123      12.2131      12.2820      12.3372     0.124034   -0.0180082      214859.      15550.5
;         124      12.3133      12.3810      12.4356     0.122330   -0.0189753      215040.      15366.4
;         125      12.4126      12.4765      12.5298     0.117137   -0.0235157      202577.      14802.8
;         126      12.5034      12.5754      12.6353     0.131881   -0.0245705      244795.      16025.8
;         127      12.6107      12.6733      12.7280     0.117276   -0.0266628      207073.      14940.0
;         128      12.7041      12.7712      12.8280     0.123850   -0.0287895      213729.      15242.0
;         129      12.8031      12.8697      12.9259     0.122827   -0.0302753      212951.      15553.5
;         130      12.9007      12.9660      13.0234     0.122705   -0.0339899      215920.      15827.2
;         131      13.0016      13.0664      13.1216     0.120004   -0.0336313      214272.      15912.8
;         132      13.1018      13.1666      13.2218     0.120034   -0.0334044      212409.      15906.9
;         133      13.2034      13.2699      13.3262     0.122766   -0.0300932      214382.      16030.6
;         134      13.3029      13.3704      13.4266     0.123662   -0.0295515      216272.      16194.3
;         135      13.4042      13.4709      13.5273     0.123071   -0.0290537      214267.      16052.1
;         136      13.5044      13.5718      13.6284     0.124030   -0.0281849      214349.      15969.9
;         137      13.6105      13.6743      13.7288     0.118332   -0.0257196      214333.      15969.2
;         138      13.7044      13.7724      13.8288     0.124384   -0.0276127      212373.      15840.9
;         139      13.8101      13.8719      13.9279     0.117820   -0.0281057      213051.      16060.3
;         140      13.9102      13.9727      14.0290     0.118772   -0.0272684      214765.      16082.9
;         141      14.0053      14.0737      14.1302     0.124913   -0.0262747      212413.      15918.1
;         142      14.1109      14.1741      14.2316     0.120762   -0.0259247      214273.      16076.1
;         143      14.2122      14.2779      14.3337     0.121490   -0.0221148      211233.      15646.5
;         144      14.3119      14.3783      14.4345     0.122590   -0.0217209      212516.      15721.4
;         145      14.4133      14.4794      14.5342     0.120914   -0.0205851      212289.      16018.8
;         146      14.5134      14.5807      14.6367     0.123277   -0.0193167      212176.      15872.4
;         147      14.6144      14.6814      14.7360     0.121583   -0.0185642      211489.      16025.8
;         148      14.7134      14.7803      14.8353     0.121841   -0.0196753      213787.      15859.9
;         149      14.8140      14.8818      14.9372     0.123214   -0.0182467      216991.      16073.3
;         150      14.9141      14.9822      15.0371     0.122995   -0.0178442      211092.      15841.1
;         151      15.0211      15.0841      15.1391     0.118015   -0.0159168      210892.      15982.0
;         152      15.1201      15.1840      15.2400     0.119863   -0.0160131      214879.      15928.4
;         153      15.2212      15.2856      15.3414     0.120174   -0.0144110      213755.      15915.9
;         154      15.3211      15.3868      15.4433     0.122257   -0.0131836      212656.      15770.9
;         155      15.4217      15.4888      15.5462     0.124482   -0.0111799      214226.      15734.4
;         156      15.5226      15.5908      15.6474     0.124801  -0.00915623      213500.      15826.8
;         157      15.6223      15.6919      15.7483     0.126060  -0.00814819      217200.      15752.6
;         158      15.7230      15.7944      15.8526     0.129645  -0.00558186      218055.      15528.2
;         159      15.8241      15.8972      15.9557     0.131574  -0.00282478      219910.      15360.9
;         160      15.9240      15.9960      16.0546     0.130564  -0.00399971      215896.      15123.9
;       3      15.9600      24.1400      8.18000      152.000      239.000      87.0000
;   cell, integral, left, center, right, fwhm
;         161      16.0244      16.0957      16.1569     0.132500  -0.00432396      215479.      15145.7
;         162      16.1243      16.1962      16.2570     0.132660  -0.00377655      219500.      15380.4
;         163      16.2302      16.3006      16.3621     0.131884  0.000646591      218166.      15113.0
;         164      16.3321      16.4099      16.4754     0.143219   0.00994110      220348.      14312.4
;         165      16.4331      16.5168      16.5872     0.154041    0.0167732      219106.      13285.1
;         166      16.5225      16.5983      16.6585     0.136055  -0.00170135      201689.      12570.4
;         167      16.6136      16.6934      16.7604     0.146797  -0.00660706      253353.      15079.4
;         168      16.7016      16.7688      16.8185     0.116930   -0.0312233      168961.      11997.3
;         169      16.7808      16.8483      16.9074     0.126654   -0.0516624      233573.      14883.9
;         170      16.8528      16.9214      16.9843     0.131575   -0.0786247      193441.      13104.2
;         171      16.9511      17.0225      17.0829     0.131832   -0.0774899      222246.      14793.6
;         172      17.0521      17.1274      17.1931     0.141039   -0.0726128      246250.      15879.7
;         173      17.1706      17.2405      17.2999     0.129230   -0.0594578      229878.      16121.1
;         174      17.2754      17.3474      17.4054     0.130026   -0.0525627      224468.      16106.2
;         175      17.3836      17.4527      17.5091     0.125532   -0.0472889      228663.      16666.2
;         176      17.4909      17.5577      17.6155     0.124599   -0.0423489      228738.      16382.2
;         177      17.5930      17.6605      17.7170     0.123980   -0.0394650      219012.      16219.7
;         178      17.6940      17.7635      17.8194     0.125422   -0.0365028      221739.      16285.1
;         179      17.8010      17.8661      17.9226     0.121643   -0.0339451      220140.      16071.5
;         180      17.9019      17.9672      18.0239     0.122047   -0.0328369      224318.      16127.0
;         181      18.0026      18.0690      18.1249     0.122227   -0.0310173      216085.      15815.5
;         182      18.1031      18.1695      18.2272     0.124136   -0.0305195      219768.      15959.6
;         183      18.2039      18.2716      18.3278     0.123911   -0.0284004      216931.      15990.4
;         184      18.3037      18.3716      18.4271     0.123396   -0.0283794      215948.      15773.8
;         185      18.4040      18.4725      18.5282     0.124243   -0.0274773      217379.      15632.0
;         186      18.5041      18.5722      18.6272     0.123047   -0.0278149      213600.      15557.1
;         187      18.6101      18.6731      18.7282     0.118074   -0.0269489      211529.      15350.0
;         188      18.7025      18.7682      18.8228     0.120270   -0.0318012      211601.      15327.2
;         189      18.8020      18.8681      18.9241     0.122145   -0.0319328      211329.      14959.0
;         190      18.8933      18.9606      19.0164     0.123165   -0.0394077      210134.      14898.8
;         191      18.9903      19.0529      19.1119     0.121626   -0.0470562      211616.      14736.8
;         192      19.0840      19.1520      19.2087     0.124722   -0.0480385      215429.      15142.5
;         193      19.1905      19.2532      19.3087     0.118216   -0.0468311      214702.      15456.6
;         194      19.2850      19.3535      19.4088     0.123812   -0.0464783      213266.      15494.8
;         195      19.3851      19.4546      19.5122     0.127085   -0.0454273      215992.      15652.1
;         196      19.4854      19.5553      19.6124     0.126987   -0.0446644      214496.      15607.9
;         197      19.5914      19.6559      19.7095     0.118147   -0.0440693      213069.      15709.6
;         198      19.6906      19.7563      19.8098     0.119242   -0.0436974      212510.      15621.0
;         199      19.7920      19.8576      19.9142     0.122225   -0.0424156      214553.      15652.9
;         200      19.8930      19.9584      20.0155     0.122486   -0.0416489      212436.      15550.9
;         201      19.9934      20.0586      20.1150     0.121628   -0.0414066      211410.      15803.4
;         202      20.0936      20.1598      20.2165     0.122877   -0.0401783      213328.      15788.7
;         203      20.2212      20.2851      20.3409     0.119747   -0.0148888      211510.      15344.5
;         204      20.3218      20.3856      20.4414     0.119595   -0.0143833      213332.      15426.5
;         205      20.4224      20.4871      20.5436     0.121216   -0.0128822      212872.      15422.5
;         206      20.5226      20.5886      20.6431     0.120577   -0.0114155      211136.      15301.7
;         207      20.6208      20.6824      20.7372     0.116434   -0.0176334      212508.      15399.9
;         208      20.7209      20.7828      20.8377     0.116783   -0.0171909      211894.      15421.5
;         209      20.8231      20.8893      20.9442     0.121046   -0.0106602      211711.      15501.4
;         210      20.9214      20.9839      21.0366     0.115206   -0.0161476      210944.      15463.7
;         211      21.0153      21.0839      21.1379     0.122583   -0.0160770      214022.      15243.9
;         212      21.1301      21.1913      21.2467     0.116602  -0.00873566      209382.      15259.3
;         213      21.2206      21.2856      21.3402     0.119549   -0.0143585      213034.      15380.8
;         214      21.3207      21.3856      21.4389     0.118210   -0.0143909      213490.      15364.0
;         215      21.4210      21.4871      21.5409     0.119860   -0.0129128      215210.      15503.3
;         216      21.5224      21.5881      21.6432     0.120840   -0.0119267      212515.      15403.3
;         217      21.6238      21.6902      21.7436     0.119850  -0.00984573      212555.      15356.0
;         218      21.7230      21.7917      21.8479     0.124834  -0.00832939      217219.      15151.6
;         219      21.8220      21.8897      21.9441     0.122055   -0.0103111      213410.      15555.1
;         220      21.9231      21.9908      22.0452     0.122082  -0.00921059      211007.      15275.8
;         221      22.0238      22.0911      22.1461     0.122349  -0.00886154      211796.      15630.5
;         222      22.1237      22.1928      22.2490     0.125349  -0.00719643      213793.      14919.1
;         223      22.2235      22.2941      22.3500     0.126505  -0.00586700      216224.      14667.6
;         224      22.3221      22.3907      22.4475     0.125431  -0.00931168      211425.      14475.6
;         225      22.4215      22.4881      22.5453     0.123789   -0.0119076      217415.      14658.9
;         226      22.5212      22.5864      22.6426     0.121378   -0.0135670      213573.      14728.9
;         227      22.6212      22.6849      22.7403     0.119062   -0.0151310      209177.      14858.7
;         228      22.7205      22.7829      22.8383     0.117830   -0.0170708      211966.      15119.4
;         229      22.8220      22.8874      22.9447     0.122742   -0.0125847      223820.      15403.6
;         230      22.9117      22.9758      23.0296     0.117893   -0.0241508      222226.      16023.2
;         231      23.0059      23.0765      23.1340     0.128042   -0.0235062      224573.      15418.2
;         232      23.1120      23.1788      23.2336     0.121599   -0.0211926      227682.      15500.5
;         233      23.2127      23.2797      23.3359     0.123262   -0.0203362      226964.      15500.5
;         234      23.3205      23.3801      23.4355     0.114994   -0.0198956      225858.      15515.8
;         235      23.4204      23.4808      23.5373     0.116972   -0.0191917      224685.      15348.9
;         236      23.5205      23.5821      23.6385     0.117998   -0.0178585      225219.      15440.8
;         237      23.6209      23.6839      23.7401     0.119156   -0.0161362      224056.      15417.8
;         238      23.7108      23.7808      23.8316     0.120802   -0.0191593      231792.      15704.8
;         239      23.8114      23.8813      23.9315     0.120150   -0.0187092      246349.      16352.5
;       4      23.9400      32.1200      8.18000      231.000      318.000      87.0000
;   cell, integral, left, center, right, fwhm
;         240      23.9229      23.9860      24.0423     0.119322   -0.0140209      219340.      15485.8
;         241      24.0130      24.0844      24.1350     0.121990   -0.0155506      240219.      16461.0
;         242      24.1232      24.1881      24.2458     0.122532   -0.0119419      214992.      15320.0
;         243      24.2136      24.2873      24.3375     0.123953   -0.0126534      239704.      16101.3
;         244      24.3200      24.3878      24.4372     0.117176   -0.0122375      235384.      16021.8
;         245      24.4202      24.4890      24.5391     0.118959   -0.0110016      238208.      16085.0
;         246      24.5202      24.5909      24.6416     0.121418  -0.00909233      238840.      15957.8
;         247      24.6213      24.6922      24.7434     0.122183  -0.00775337      240233.      16043.9
;         248      24.7216      24.7936      24.8455     0.123962  -0.00640488      237202.      15794.9
;         249      24.8221      24.8938      24.9445     0.122387  -0.00619698      235988.      15910.8
;         250      24.9217      24.9932      25.0430     0.121269  -0.00676727      234093.      15656.4
;         251      25.0213      25.0920      25.1438     0.122471  -0.00802231      234587.      15483.5
;         252      25.1202      25.1901      25.2418     0.121634  -0.00994492      232708.      15438.5
;         253      25.2137      25.2903      25.3426     0.128977  -0.00969505      228378.      15197.4
;         254      25.3129      25.3905      25.4403     0.127399  -0.00953484      225967.      14552.4
;         255      25.4044      25.4865      25.5439     0.139475   -0.0134888      222930.      13420.0
;         256      25.5004      25.5811      25.6423     0.141926   -0.0188770      206350.      11900.4
;         257      25.5849      25.6567      25.7062     0.121319   -0.0433044      233175.      15873.3
;         258      25.6711      25.7390      25.7913     0.120167   -0.0609818      214222.      14515.8
;         259      25.7646      25.8366      25.8909     0.126268   -0.0633526      232127.      15821.6
;         260      25.8732      25.9455      26.0000     0.126858   -0.0545120      234906.      16219.1
;         261      25.9804      26.0496      26.1035     0.123129   -0.0503521      235585.      16532.9
;         262      26.0826      26.1533      26.2054     0.122854   -0.0467167      232635.      16523.3
;         263      26.1901      26.2575      26.3121     0.121967   -0.0425205      233890.      16303.1
;         264      26.2915      26.3606      26.4139     0.122326   -0.0394230      228446.      16242.9
;         265      26.3930      26.4642      26.5183     0.125322   -0.0357647      233282.      16160.1
;         266      26.4944      26.5697      26.6247     0.130310   -0.0302925      241806.      16190.1
;         267      26.6016      26.6777      26.7365     0.134869   -0.0222530      241453.      15437.7
;         268      26.6934      26.7748      26.8338     0.140398   -0.0252285      229809.      13957.9
;         269      26.8007      26.8690      26.9196     0.118917   -0.0309944      216256.      14928.5
;         270      26.8902      26.9700      27.0366     0.146322   -0.0300350      222409.      12947.5
;         271      26.9722      27.0509      27.1117     0.139442   -0.0490608      211125.      13911.8
;         272      27.0905      27.1601      27.2158     0.125322   -0.0398827      216440.      15608.2
;         273      27.1912      27.2619      27.3162     0.124971   -0.0380592      226613.      16543.5
;         274      27.2938      27.3652      27.4174     0.123631   -0.0347881      226935.      16535.2
;         275      27.4001      27.4676      27.5216     0.121483   -0.0323849      227772.      16207.9
;         276      27.5017      27.5702      27.6229     0.121183   -0.0297775      226757.      16370.2
;         277      27.6023      27.6718      27.7244     0.122143   -0.0282173      222040.      15802.9
;         278      27.7025      27.7722      27.8251     0.122622   -0.0278034      224410.      16006.4
;         279      27.8021      27.8696      27.9223     0.120203   -0.0303879      215922.      15632.7
;         280      27.9020      27.9695      28.0230     0.121035   -0.0305061      219484.      15637.4
;         281      28.0023      28.0714      28.1242     0.121977   -0.0286045      221656.      15771.6
;         282      28.1017      28.1703      28.2228     0.121048   -0.0297451      220202.      15601.6
;         283      28.2009      28.2668      28.3211     0.120167   -0.0332069      213567.      15217.7
;         284      28.2937      28.3643      28.4161     0.122358   -0.0357189      213961.      15373.4
;         285      28.3915      28.4635      28.5183     0.126837   -0.0364628      228717.      15589.8
;         286      28.4919      28.5586      28.6086     0.116686   -0.0413952      211775.      15634.2
;         287      28.5819      28.6521      28.7085     0.126581   -0.0478706      225292.      15208.1
;         288      28.6808      28.7496      28.8058     0.125023   -0.0504189      216739.      15047.2
;         289      28.7819      28.8511      28.9061     0.124186   -0.0489483      218624.      15646.5
;         290      28.8818      28.9525      29.0081     0.126234   -0.0475254      217499.      15579.0
;         291      28.9830      29.0531      29.1082     0.125198   -0.0468788      222403.      16061.6
;         292      29.0829      29.1540      29.2087     0.125834   -0.0459595      217905.      15919.5
;         293      29.1901      29.2560      29.3102     0.120096   -0.0439720      216496.      15753.6
;         294      29.2909      29.3569      29.4111     0.120291   -0.0430851      217278.      15918.8
;         295      29.3902      29.4582      29.5128     0.122585   -0.0418415      216856.      15606.5
;         296      29.4917      29.5589      29.6130     0.121378   -0.0410728      216656.      15664.6
;         297      29.5921      29.6598      29.7138     0.121651   -0.0401764      216496.      15781.1
;         298      29.6931      29.7604      29.8136     0.120476   -0.0396309      215338.      16014.9
;         299      29.7920      29.8596      29.9134     0.121395   -0.0403652      213418.      15780.8
;         300      29.8922      29.9603      30.0146     0.122356   -0.0397434      215705.      15824.1
;         301      29.9929      30.0613      30.1149     0.122042   -0.0387459      214571.      15781.1
;         302      30.0931      30.1618      30.2156     0.122517   -0.0381947      213668.      15823.2
;         303      30.1934      30.2627      30.3147     0.121315   -0.0372791      216905.      15994.3
;         304      30.2936      30.3635      30.4167     0.123068   -0.0364780      209917.      15471.1
;         305      30.4000      30.4638      30.5182     0.118233   -0.0362453      218868.      16059.1
;         306      30.5006      30.5658      30.6190     0.118387   -0.0341873      212941.      15855.3
;         307      30.6011      30.6668      30.7203     0.119247   -0.0331554      214091.      15925.7
;         308      30.7014      30.7679      30.8212     0.119778   -0.0320873      213085.      15946.6
;         309      30.7936      30.8624      30.9162     0.122663   -0.0376301      215404.      15939.2
;         310      30.8945      30.9640      31.0170     0.122585   -0.0360241      213345.      16025.8
;         311      31.0026      31.0709      31.1243     0.121614   -0.0290813      214713.      16084.1
;         312      31.1003      31.1669      31.2197     0.119360   -0.0330868      214579.      16080.4
;         313      31.2009      31.2685      31.3227     0.121897   -0.0314617      211548.      15905.7
;         314      31.3019      31.3703      31.4248     0.122900   -0.0297012      215021.      16099.8
;         315      31.4033      31.4729      31.5267     0.123474   -0.0270748      214831.      16294.5
;         316      31.5100      31.5758      31.6309     0.120874   -0.0242100      213749.      16165.1
;         317      31.6122      31.6792      31.7328     0.120636   -0.0207577      211499.      16307.5
;         318      31.7131      31.7840      31.8374     0.124313   -0.0160351      209235.      15992.4
;       5      31.9200      40.1000      8.18000      310.000      397.000      87.0000
;   cell, integral, left, center, right, fwhm
;         319      31.8210      31.8897      31.9436     0.122643   -0.0102825      203920.      15295.4
;         320      31.9141      31.9871      32.0397     0.125568   -0.0129375      215387.      15343.8
;         321      32.0028      32.0715      32.1233     0.120502   -0.0285454      202518.      14560.9
;         322      32.0927      32.1594      32.2119     0.119137   -0.0405693      205550.      14923.7
;         323      32.1902      32.2539      32.3069     0.116634   -0.0461388      208907.      14947.6
;         324      32.2831      32.3511      32.4046     0.121498   -0.0489502      207605.      15014.8
;         325      32.3826      32.4492      32.5026     0.119915   -0.0508232      210107.      15408.7
;         326      32.4822      32.5482      32.6018     0.119572   -0.0517731      206967.      15233.0
;         327      32.5817      32.6476      32.7024     0.120716   -0.0523796      210163.      15243.3
;         328      32.6818      32.7483      32.8028     0.120998   -0.0516815      210326.      15414.0
;         329      32.7836      32.8514      32.9052     0.121563   -0.0486412      210932.      15549.4
;         330      32.8838      32.9523      33.0062     0.122334   -0.0477219      209854.      15520.8
;         331      32.9844      33.0532      33.1069     0.122532   -0.0468140      211048.      15755.2
;         332      33.0831      33.1510      33.2053     0.122272   -0.0490341      209604.      15653.4
;         333      33.1903      33.2550      33.3099     0.119637   -0.0450172      210339.      15537.0
;         334      33.2906      33.3562      33.4100     0.119411   -0.0438156      210812.      15669.0
;         335      33.3908      33.4576      33.5109     0.120060   -0.0423965      210928.      15550.0
;         336      33.4918      33.5588      33.6121     0.120239   -0.0411987      210208.      15697.1
;         337      33.5923      33.6596      33.7129     0.120605   -0.0403557      210091.      15444.0
;         338      33.6925      33.7601      33.8140     0.121433   -0.0399017      209949.      15445.5
;         339      33.7929      33.8603      33.9128     0.119881   -0.0396538      208538.      15596.7
;         340      33.8919      33.9587      34.0132     0.121342   -0.0413437      212061.      15390.5
;         341      33.9926      34.0602      34.1135     0.120907   -0.0397530      206582.      15257.1
;         342      34.0918      34.1583      34.2117     0.119942   -0.0416985      209459.      15307.4
;         343      34.1918      34.2584      34.3124     0.120556   -0.0415878      210788.      15384.9
;         344      34.2917      34.3586      34.4124     0.120705   -0.0413551      209527.      15317.2
;         345      34.3917      34.4577      34.5114     0.119701   -0.0422745      207585.      15206.6
;         346      34.4909      34.5568      34.6105     0.119587   -0.0432281      207440.      15139.3
;         347      34.5844      34.6551      34.7084     0.123974   -0.0449371      205207.      15087.6
;         348      34.6837      34.7539      34.8073     0.123547   -0.0461159      208956.      15305.9
;         349      34.7835      34.8527      34.9061     0.122509   -0.0472565      204817.      14934.5
;         350      34.8825      34.9504      35.0041     0.121590   -0.0495605      207834.      15034.3
;         351      34.9741      35.0448      35.0997     0.125572   -0.0551529      206361.      14938.3
;         352      35.0728      35.1437      35.1991     0.126312   -0.0562744      205581.      14727.7
;         353      35.1732      35.2428      35.2990     0.125786   -0.0571938      207138.      15046.6
;         354      35.2729      35.3422      35.3974     0.124508   -0.0578041      205354.      15207.7
;         355      35.3722      35.4413      35.4961     0.123928   -0.0587044      208503.      15303.6
;         356      35.4723      35.5419      35.5982     0.125908   -0.0580635      208641.      15270.1
;         357      35.5729      35.6425      35.6980     0.125179   -0.0574760      208261.      15442.5
;         358      35.6735      35.7434      35.7974     0.123901   -0.0566139      209298.      15719.3
;         359      35.7810      35.8468      35.9011     0.120136   -0.0531883      205697.      15490.6
;         360      35.8743      35.9435      35.9978     0.123501   -0.0565033      209101.      15833.3
;         361      35.9803      36.0448      36.0991     0.118740   -0.0552292      208561.      15596.6
;         362      36.0822      36.1502      36.2057     0.123482   -0.0497971      207047.      15454.7
;         363      36.1830      36.2520      36.3069     0.123875   -0.0479507      206570.      15529.1
;         364      36.2901      36.3533      36.4082     0.118050   -0.0467453      206593.      15618.1
;         365      36.3907      36.4552      36.5105     0.119793   -0.0447540      207529.      15586.3
;         366      36.4911      36.5571      36.6113     0.120144   -0.0428734      206229.      15462.4
;         367      36.5923      36.6579      36.7118     0.119423   -0.0420647      206794.      15651.0
;         368      36.6911      36.7569      36.8104     0.119236   -0.0430603      207138.      15472.5
;         369      36.7903      36.8571      36.9108     0.120453   -0.0429077      206876.      15215.6
;         370      36.8916      36.9581      37.0112     0.119564   -0.0419197      208755.      15447.5
;         371      36.9921      37.0585      37.1114     0.119350   -0.0415306      204414.      15159.0
;         372      37.0911      37.1579      37.2106     0.119534   -0.0420914      209340.      15543.2
;         373      37.1920      37.2584      37.3098     0.117855   -0.0416489      206423.      15394.2
;         374      37.2923      37.3589      37.4126     0.120228   -0.0410576      208474.      15388.4
;         375      37.3925      37.4598      37.5133     0.120815   -0.0401917      207146.      15505.2
;         376      37.4927      37.5601      37.6144     0.121704   -0.0398712      208644.      15571.1
;         377      37.5931      37.6611      37.7149     0.121861   -0.0389404      207377.      15553.7
;         378      37.6930      37.7611      37.8144     0.121330   -0.0389481      205919.      15330.2
;         379      37.7943      37.8629      37.9161     0.121799   -0.0370522      207840.      15490.7
;         380      37.8923      37.9592      38.0140     0.121738   -0.0407677      205082.      15187.0
;         381      37.9914      38.0577      38.1116     0.120232   -0.0422554      204508.      15246.3
;         382      38.0913      38.1596      38.2142     0.122890   -0.0403557      204619.      14781.0
;         383      38.1919      38.2583      38.3102     0.118271   -0.0417023      204442.      14874.0
;         384      38.2908      38.3560      38.4096     0.118835   -0.0440407      205810.      14624.9
;         385      38.3830      38.4512      38.5054     0.122375   -0.0488243      202925.      14476.3
;         386      38.4821      38.5482      38.6018     0.119759   -0.0517998      204802.      14814.0
;         387      38.5813      38.6462      38.7009     0.119644   -0.0538406      206057.      15139.4
;         388      38.6806      38.7449      38.7991     0.118443   -0.0550652      205794.      15155.6
;         389      38.7819      38.8503      38.9060     0.124096   -0.0496864      208821.      15451.1
;         390      38.8832      38.9513      39.0061     0.122871   -0.0486565      205847.      15394.6
;         391      38.9809      39.0454      39.1008     0.119965   -0.0545921      206386.      15475.2
;         392      39.0836      39.1528      39.2076     0.123997   -0.0471916      208709.      15673.2
;         393      39.1903      39.2541      39.3070     0.116661   -0.0459442      206737.      15633.7
;         394      39.2905      39.3554      39.4103     0.119785   -0.0445747      209470.      15457.2
;         395      39.3914      39.4565      39.5114     0.119934   -0.0435181      208066.      15415.9
;         396      39.4919      39.5574      39.6116     0.119766   -0.0426483      208314.      15525.4
;         397      39.5810      39.6476      39.7013     0.120346   -0.0523720      206363.      15471.9
;Intersection Analysis
;At     0.298078 between       4 and       3
;At     0.209782 between       5 and       4
;At    0.0571646 between       6 and       5
;At   -0.0259963 between       7 and       6
;At   -0.0594684 between       8 and       7
;At   -0.0710539 between       9 and       8
;At   -0.0685778 between      10 and       9
;At   -0.0702989 between      11 and      10
;At   -0.0689542 between      12 and      11
;At   -0.0728956 between      13 and      12
;At   -0.0771294 between      14 and      13
;At   -0.0821145 between      15 and      14
;At   -0.0866359 between      16 and      15
;At   -0.0933617 between      17 and      16
;At   -0.0994127 between      18 and      17
;At   -0.0995895 between      19 and      18
;At    -0.102502 between      20 and      19
;At    -0.108605 between      21 and      20
;At    -0.116473 between      22 and      21
;At    -0.129915 between      23 and      22
;At    -0.139081 between      24 and      23
;At    -0.225086 between      26 and      24
;At    -0.275840 between      27 and      26
;At    -0.338128 between      28 and      27
;At    -0.255740 between      34 and      28
;At     0.151569 between      35 and      34
;At    0.0949328 between      36 and      35
;At    0.0563252 between      37 and      36
;At    0.0276041 between      38 and      37
;At   0.00245118 between      39 and      38
;At  -0.00780535 between      40 and      39
;At   -0.0206819 between      41 and      40
;At   -0.0332165 between      42 and      41
;At   -0.0450454 between      43 and      42
;At   -0.0429635 between      44 and      43
;At   -0.0295477 between      45 and      44
;At   -0.0220156 between      46 and      45
;At   -0.0268240 between      47 and      46
;At   -0.0362120 between      48 and      47
;At   -0.0446453 between      49 and      48
;At   -0.0529404 between      50 and      49
;At   -0.0537567 between      51 and      50
;At   -0.0451455 between      52 and      51
;At   -0.0334983 between      53 and      52
;At   -0.0305057 between      54 and      53
;At   -0.0362072 between      55 and      54
;At   -0.0432243 between      56 and      55
;At   -0.0499291 between      57 and      56
;At   -0.0564847 between      58 and      57
;At   -0.0613999 between      59 and      58
;At   -0.0695176 between      60 and      59
;At   -0.0780745 between      61 and      60
;At   -0.0887079 between      62 and      61
;At   -0.0969453 between      64 and      62
;At  -0.00415325 between      65 and      64
;At   -0.0119104 between      66 and      65
;At   -0.0267282 between      67 and      66
;At   -0.0325394 between      68 and      67
;At   -0.0315146 between      69 and      68
;At   -0.0367303 between      70 and      69
;At   -0.0388374 between      71 and      70
;At   -0.0394835 between      72 and      71
;At   -0.0431919 between      73 and      72
;At   -0.0427246 between      74 and      73
;At   -0.0439463 between      75 and      74
;At   -0.0415339 between      76 and      75
;At   -0.0452137 between      77 and      76
;At   -0.0631948 between      80 and      77
;At    -0.230318 between      81 and      78
;At   -0.0470343 between      82 and      81
;At   -0.0502329 between      83 and      82
;At   -0.0486965 between      84 and      83
;At   -0.0514641 between      85 and      84
;At   -0.0508919 between      86 and      85
;At   -0.0541840 between      87 and      86
;At   -0.0580635 between      88 and      87
;At   -0.0566330 between      89 and      88
;At   -0.0588875 between      90 and      89
;At   -0.0584354 between      91 and      90
;At   -0.0590601 between      92 and      91
;At   -0.0623455 between      93 and      92
;At   -0.0637312 between      94 and      93
;At   -0.0678930 between      95 and      94
;At   -0.0672598 between      96 and      95
;At   -0.0661516 between      97 and      96
;At   -0.0692253 between      98 and      97
;At   -0.0669003 between      99 and      98
;At   -0.0630426 between     100 and      99
;At   -0.0534964 between     101 and     100
;At   -0.0286436 between     102 and     101
;At   -0.0215225 between     103 and     102
;At   -0.0193748 between     104 and     103
;At   -0.0243607 between     105 and     104
;At   -0.0288839 between     106 and     105
;At   -0.0258198 between     107 and     106
;At   -0.0239611 between     108 and     107
;At   -0.0262661 between     109 and     108
;At   -0.0291834 between     110 and     109
;At   -0.0303507 between     111 and     110
;At   -0.0313702 between     112 and     111
;At   -0.0313005 between     113 and     112
;At   -0.0332432 between     114 and     113
;At   -0.0361309 between     115 and     114
;At   -0.0361776 between     116 and     115
;At   -0.0320492 between     117 and     116
;At   -0.0287914 between     118 and     117
;At   -0.0280428 between     119 and     118
;At   -0.0281258 between     120 and     119
;At   -0.0283642 between     121 and     120
;At   -0.0301304 between     122 and     121
;At   -0.0278492 between     123 and     122
;At   -0.0275059 between     124 and     123
;At   -0.0269279 between     125 and     124
;At   -0.0163708 between     126 and     125
;At   -0.0248747 between     127 and     126
;At   -0.0187206 between     128 and     127
;At   -0.0155296 between     129 and     128
;At   -0.0142097 between     130 and     129
;At   -0.0116911 between     131 and     130
;At   -0.0130806 between     132 and     131
;At   -0.0147829 between     133 and     132
;At   -0.0160456 between     134 and     133
;At   -0.0181875 between     135 and     134
;At   -0.0191288 between     136 and     135
;At   -0.0207024 between     137 and     136
;At   -0.0199718 between     138 and     137
;At   -0.0176058 between     139 and     138
;At   -0.0174732 between     140 and     139
;At   -0.0204859 between     141 and     140
;At   -0.0188599 between     142 and     141
;At   -0.0225983 between     143 and     142
;At   -0.0243330 between     144 and     143
;At   -0.0247869 between     145 and     144
;At   -0.0251236 between     146 and     145
;At   -0.0274324 between     147 and     146
;At   -0.0254612 between     148 and     147
;At   -0.0266514 between     149 and     148
;At   -0.0285378 between     150 and     149
;At   -0.0289621 between     151 and     150
;At   -0.0300913 between     152 and     151
;At   -0.0302238 between     153 and     152
;At   -0.0319166 between     154 and     153
;At   -0.0328846 between     155 and     154
;At   -0.0362320 between     156 and     155
;At   -0.0372362 between     157 and     156
;At   -0.0386992 between     158 and     157
;At   -0.0417347 between     159 and     158
;At   -0.0427637 between     160 and     159
;At   -0.0426445 between     161 and     160
;At   -0.0423813 between     162 and     161
;At   -0.0445557 between     163 and     162
;At   -0.0498428 between     164 and     163
;At   -0.0621395 between     165 and     164
;At   -0.0571537 between     166 and     165
;At   -0.0352783 between     167 and     166
;At   -0.0450401 between     168 and     167
;At   0.00176430 between     169 and     168
;At    0.0151234 between     170 and     169
;At    0.0377731 between     171 and     170
;At    0.0342655 between     172 and     171
;At    0.0170898 between     173 and     172
;At   0.00876808 between     174 and     173
;At   0.00421524 between     175 and     174
;At  0.000764847 between     176 and     175
;At  -0.00554848 between     177 and     176
;At  -0.00658035 between     178 and     177
;At  -0.00952339 between     179 and     178
;At   -0.0120068 between     180 and     179
;At   -0.0137405 between     181 and     180
;At   -0.0146408 between     182 and     181
;At   -0.0172462 between     183 and     182
;At   -0.0173779 between     184 and     183
;At   -0.0175800 between     185 and     184
;At   -0.0193405 between     186 and     185
;At   -0.0191936 between     187 and     186
;At   -0.0165520 between     188 and     187
;At   -0.0127525 between     189 and     188
;At   -0.0107002 between     190 and     189
;At  -0.00167465 between     191 and     190
;At  0.000795364 between     192 and     191
;At -0.000169754 between     193 and     192
;At  -0.00115585 between     194 and     193
;At  -0.00148773 between     195 and     194
;At  -0.00200844 between     196 and     195
;At  -0.00310898 between     197 and     196
;At  -0.00291252 between     198 and     197
;At  -0.00276566 between     199 and     198
;At  -0.00300980 between     200 and     199
;At  -0.00444984 between     201 and     200
;At  -0.00513077 between     202 and     201
;At   -0.0195885 between     203 and     202
;At   -0.0298271 between     204 and     203
;At   -0.0315990 between     205 and     204
;At   -0.0349312 between     206 and     205
;At   -0.0316448 between     207 and     206
;At   -0.0300503 between     208 and     207
;At   -0.0319080 between     209 and     208
;At   -0.0336533 between     210 and     209
;At   -0.0305557 between     211 and     210
;At   -0.0347595 between     212 and     211
;At   -0.0349407 between     213 and     212
;At   -0.0326195 between     214 and     213
;At   -0.0331039 between     215 and     214
;At   -0.0336723 between     216 and     215
;At   -0.0360832 between     217 and     216
;At   -0.0358028 between     218 and     217
;At   -0.0364971 between     219 and     218
;At   -0.0354481 between     220 and     219
;At   -0.0355930 between     221 and     220
;At   -0.0377235 between     222 and     221
;At   -0.0388851 between     223 and     222
;At   -0.0370140 between     224 and     223
;At   -0.0343723 between     225 and     224
;At   -0.0335884 between     226 and     225
;At   -0.0322914 between     227 and     226
;At   -0.0309887 between     228 and     227
;At   -0.0322304 between     229 and     228
;At   -0.0313854 between     230 and     229
;At   -0.0237083 between     231 and     230
;At   -0.0257473 between     232 and     231
;At   -0.0258789 between     233 and     232
;At   -0.0293694 between     234 and     233
;At   -0.0268612 between     235 and     234
;At   -0.0290585 between     236 and     235
;At   -0.0305920 between     237 and     236
;At   -0.0262909 between     238 and     237
;At   -0.0207767 between     239 and     238
;At   -0.0281010 between     240 and     239
;At   -0.0286446 between     241 and     240
;At   -0.0319920 between     242 and     241
;At   -0.0296917 between     243 and     242
;At   -0.0295963 between     244 and     243
;At   -0.0300961 between     245 and     244
;At   -0.0315914 between     246 and     245
;At   -0.0329609 between     247 and     246
;At   -0.0337887 between     248 and     247
;At   -0.0355816 between     249 and     248
;At   -0.0351391 between     250 and     249
;At   -0.0336304 between     251 and     250
;At   -0.0300846 between     252 and     251
;At   -0.0291710 between     253 and     252
;At   -0.0286064 between     254 and     253
;At   -0.0245075 between     255 and     254
;At   -0.0237694 between     256 and     255
;At  -0.00971603 between     257 and     256
;At   0.00697517 between     258 and     257
;At    0.0214462 between     259 and     258
;At    0.0167484 between     260 and     259
;At   0.00988197 between     261 and     260
;At   0.00530815 between     262 and     261
;At   0.00214386 between     263 and     262
;At  -0.00263214 between     264 and     263
;At  -0.00555420 between     265 and     264
;At  -0.00954628 between     266 and     265
;At   -0.0150681 between     267 and     266
;At   -0.0142269 between     268 and     267
;At   -0.0183659 between     269 and     268
;At  -0.00691605 between     270 and     269
;At   -0.0112305 between     271 and     270
;At   0.00166321 between     272 and     271
;At  -0.00306511 between     273 and     272
;At  -0.00687790 between     274 and     273
;At  -0.00826645 between     275 and     274
;At   -0.0121517 between     276 and     275
;At   -0.0142746 between     277 and     276
;At   -0.0148182 between     278 and     277
;At   -0.0145855 between     279 and     278
;At   -0.0120869 between     280 and     279
;At   -0.0130939 between     281 and     280
;At   -0.0145283 between     282 and     281
;At   -0.0119572 between     283 and     282
;At  -0.00842285 between     284 and     283
;At  -0.00396347 between     285 and     284
;At  -0.00590515 between     286 and     285
;At   0.00253868 between     287 and     286
;At   0.00504303 between     288 and     287
;At   0.00612259 between     289 and     288
;At   0.00433540 between     290 and     289
;At   0.00402641 between     291 and     290
;At   0.00217819 between     292 and     291
;At  0.000949860 between     293 and     292
;At -3.24249e-05 between     294 and     293
;At  0.000242233 between     295 and     294
;At  -0.00298309 between     296 and     295
;At  -0.00372124 between     297 and     296
;At  -0.00415230 between     298 and     297
;At  -0.00404549 between     299 and     298
;At  -0.00394630 between     300 and     299
;At  -0.00510216 between     301 and     300
;At  -0.00596619 between     302 and     301
;At  -0.00636673 between     303 and     302
;At  -0.00722694 between     304 and     303
;At  -0.00758553 between     305 and     304
;At  -0.00950432 between     306 and     305
;At  -0.00993919 between     307 and     306
;At   -0.0114079 between     308 and     307
;At  -0.00914955 between     309 and     308
;At  -0.00851440 between     310 and     309
;At   -0.0115852 between     311 and     310
;At   -0.0132713 between     312 and     311
;At   -0.0124779 between     313 and     312
;At   -0.0118885 between     314 and     313
;At   -0.0157204 between     315 and     314
;At   -0.0179100 between     316 and     315
;At   -0.0205097 between     317 and     316
;At   -0.0249596 between     318 and     317
;At   -0.0305252 between     319 and     318
;At   -0.0302544 between     320 and     319
;At   -0.0243607 between     321 and     320
;At  -0.00920868 between     322 and     321
;At  -0.00169373 between     323 and     322
;At   0.00357437 between     324 and     323
;At   0.00569916 between     325 and     324
;At   0.00667572 between     326 and     325
;At   0.00783920 between     327 and     326
;At   0.00745010 between     328 and     327
;At   0.00532532 between     329 and     328
;At   0.00267792 between     330 and     329
;At   0.00199127 between     331 and     330
;At   0.00265884 between     332 and     331
;At   0.00165176 between     333 and     332
;At  0.000865936 between     334 and     333
;At  -0.00212860 between     335 and     334
;At  -0.00350189 between     336 and     335
;At  -0.00431061 between     337 and     336
;At  -0.00472641 between     338 and     337
;At  -0.00523758 between     339 and     338
;At  -0.00370789 between     340 and     339
;At  -0.00502777 between     341 and     340
;At  -0.00413132 between     342 and     341
;At  -0.00288391 between     343 and     342
;At  -0.00352478 between     344 and     343
;At  -0.00340652 between     345 and     344
;At  -0.00147629 between     346 and     345
;At -0.000255585 between     347 and     346
;At   0.00252151 between     348 and     347
;At   0.00281906 between     349 and     348
;At   0.00532150 between     350 and     349
;At   0.00890732 between     351 and     350
;At    0.0119057 between     352 and     351
;At    0.0124245 between     353 and     352
;At    0.0128593 between     354 and     353
;At    0.0140991 between     355 and     354
;At    0.0139618 between     356 and     355
;At    0.0131226 between     357 and     356
;At    0.0124969 between     358 and     357
;At   0.00966644 between     359 and     358
;At    0.0100098 between     360 and     359
;At    0.0119591 between     361 and     360
;At   0.00742340 between     362 and     361
;At   0.00376129 between     363 and     362
;At   0.00237656 between     364 and     363
;At   0.00141144 between     365 and     364
;At -0.000450134 between     366 and     365
;At  -0.00173187 between     367 and     366
;At  -0.00167084 between     368 and     367
;At -0.000255585 between     369 and     368
;At  -0.00237274 between     370 and     369
;At  -0.00317001 between     371 and     370
;At  -0.00254059 between     372 and     371
;At  -0.00289536 between     373 and     372
;At  -0.00309753 between     374 and     373
;At  -0.00385666 between     375 and     374
;At  -0.00472641 between     376 and     375
;At  -0.00531769 between     377 and     376
;At  -0.00628281 between     378 and     377
;At  -0.00700760 between     379 and     378
;At  -0.00577164 between     380 and     379
;At  -0.00288391 between     381 and     380
;At  -0.00295639 between     382 and     381
;At  -0.00339890 between     383 and     382
;At  0.000801086 between     384 and     383
;At   0.00177765 between     385 and     384
;At   0.00469971 between     386 and     385
;At   0.00726318 between     387 and     386
;At   0.00867462 between     388 and     387
;At   0.00743866 between     389 and     388
;At   0.00311279 between     390 and     389
;At   0.00679016 between     391 and     390
;At   0.00627518 between     392 and     391
;At   0.00157928 between     393 and     392
;At   0.00158691 between     394 and     393
;At  -0.00102997 between     395 and     394
;At  -0.00282288 between     396 and     395
;At   0.00296783 between     397 and     396
;At    -0.292019 between     397 and     396
;At    -0.322109 between     397 and     396
;At    -0.398804 between     397 and     396
.run plotdfil
plotdfil,0,40.1,mul=5,/ps,pr='dj1_d20',thr=t,/por,scal=2.5,ysi=26,xoffs=1,yoffs=-0.5,inten=1000.,fwh=width,posi=pos,cel=cell,ov=.1,inters=is,interw=iw
;Create def_0_411.ps XSIZE=      20.4500 cm
;       1      0.00000      8.18000      8.18000     -4.00000      83.0000      87.0000
;   cell, integral, left, center, right, fwhm
;           1    -0.138281    0.0537944     0.178762     0.317043   -0.0462056      35819.1      1118.45
;           2    -0.146574    0.0922954     0.263293     0.409867    -0.107705      50485.2      1271.57
;           3     0.319920     0.159132     0.391879    0.0719587    -0.140868      128372.      2679.71
;           4     0.281492     0.205839     0.446791     0.165298    -0.194161      123815.      3323.10
;           5     0.201654     0.408531     0.584800     0.383145   -0.0914689      254184.      6398.48
;           6     0.423830     0.570380     0.695350     0.271520   -0.0296199      283049.      9648.06
;           7     0.592007     0.701791     0.803043     0.211036   0.00179094      291306.      12276.7
;           8     0.730291     0.818709     0.895817     0.165527    0.0187088      251656.      13495.9
;           9     0.844796     0.922421     0.986559     0.141762    0.0224206      237982.      14188.7
;          10     0.952560      1.02345      1.08377     0.131205    0.0234536      234314.      15437.8
;          11      1.05368      1.12441      1.18062     0.126936    0.0244067      230655.      15770.2
;          12      1.15383      1.22626      1.28460     0.130768    0.0262562      236546.      15839.2
;          13      1.26159      1.33026      1.38785     0.126251    0.0302591      238845.      16242.5
;          14      1.36388      1.43518      1.49358     0.129702    0.0351833      236550.      16000.7
;          15      1.47101      1.53957      1.59723     0.126225    0.0395740      235974.      16090.9
;          16      1.57291      1.64548      1.70502     0.132108    0.0454843      235022.      15680.5
;          17      1.68163      1.75026      1.80961     0.127984    0.0502642      233697.      15943.5
;          18      1.78402      1.85454      1.91335     0.129327    0.0545433      226247.      15648.3
;          19      1.88288      1.95255      2.01315     0.130263    0.0525512      243335.      15850.3
;          20      1.99039      2.05775      2.11986     0.129466    0.0577543      242885.      15726.0
;          21      2.09385      2.16542      2.22803     0.134172    0.0654182      242976.      15642.9
;          22      2.20141      2.27573      2.34361     0.142206    0.0757277      247233.      15058.2
;          23      2.31121      2.38627      2.45553     0.144315    0.0862720      237478.      14209.3
;          24      2.41294      2.48961      2.56001     0.147067    0.0896084      233536.      13348.7
;          26      2.75079      2.81702      2.89308     0.142289     0.217020      218483.      12654.2
;          27      2.85280      2.92377      3.01549     0.162691     0.223775      241117.      12319.0
;          28      2.79003      2.94454      3.11547     0.325436     0.144538      121825.      3341.04
;          29      2.94318      3.01806      3.11345     0.170269     0.118059      32045.6      1329.44
;          30      3.04573      3.12267      3.22417     0.178437     0.122670      40465.1      1716.36
;          31      3.06439      3.18277      3.28400     0.219611    0.0827663      16512.6      696.495
;          32      2.92231      3.10804      3.21332     0.291009   -0.0919645      89850.9      2465.15
;          33      2.96468      3.15216      3.37014     0.405460    -0.147838      82891.4      2352.47
;          34      3.07616      3.18496      3.25297     0.176817    -0.215038      235487.      12005.4
;          35      3.24454      3.34555      3.40713     0.162593    -0.154455      253057.      13071.3
;          36      3.40289      3.49071      3.55274     0.149855    -0.109290      239122.      13640.4
;          37      3.53446      3.61955      3.68357     0.149114   -0.0804453      242114.      14326.9
;          38      3.66435      3.74478      3.80891     0.144556   -0.0552249      252998.      15514.8
;          39      3.78456      3.85906      3.92114     0.136580   -0.0409365      248248.      16069.8
;          40      3.90124      3.97170      4.03301     0.131769   -0.0282991      255039.      16644.2
;          41      4.01035      4.07945      4.13918     0.128828   -0.0205498      241170.      16168.5
;          42      4.12266      4.19382      4.24964     0.126977  -0.00617504      246789.      16753.4
;          43      4.23143      4.30142      4.35015     0.118717   0.00141811      235073.      15922.3
;          44      4.33322      4.39396      4.44097     0.107749  -0.00604439      236370.      17319.4
;          45      4.41241      4.48083      4.53340     0.120985   -0.0191655      224596.      14817.4
;          46      4.51210      4.57802      4.63666     0.124563   -0.0219808      245734.      16457.0
;          47      4.62023      4.68649      4.74360     0.123374   -0.0135136      228180.      16633.6
;          48      4.72447      4.79439      4.85129     0.126824  -0.00561428      224452.      16447.6
;          49      4.83237      4.90251      4.96037     0.127994   0.00250769      224174.      16176.6
;          50      4.94051      5.00903      5.06094     0.120435   0.00903463      219993.      15954.1
;          51      5.04077      5.10818      5.16237     0.121600   0.00817633      241634.      15908.1
;          52      5.13259      5.19230      5.23801     0.105420  -0.00769901      238610.      18304.9
;          53      5.22099      5.28294      5.34043     0.119431   -0.0170612      226182.      15721.9
;          54      5.32217      5.38840      5.44364     0.121475   -0.0116043      226406.      16593.9
;          55      5.43056      5.49509      5.55030     0.119740  -0.00491285      230034.      16917.1
;          56      5.53329      5.60191      5.65752     0.124224   0.00191164      226324.      16530.1
;          57      5.64228      5.71009      5.76503     0.122749    0.0100889      225908.      16485.9
;          58      5.74354      5.81247      5.86950     0.125963    0.0124707      224698.      16315.6
;          59      5.85305      5.92062      5.97754     0.124485    0.0206223      228691.      16544.9
;          60      5.95523      6.02658      6.08265     0.127418    0.0265799      229459.      16494.1
;          61      6.07131      6.13971      6.19623     0.124924    0.0397091      228343.      16139.2
;          62      6.18039      6.24625      6.30180     0.121406    0.0462461      234289.      16214.9
;          63      6.24267      6.29795      6.34258    0.0999107  -0.00204563      72002.9      6070.91
;          64      6.28334      6.35752      6.41952     0.136188   -0.0424786      237914.      15538.3
;          65      6.39027      6.46096      6.52293     0.132659   -0.0390415      233727.      15504.6
;          66      6.50286      6.57344      6.63368     0.130816   -0.0265574      234482.      16230.6
;          67      6.61442      6.68618      6.74465     0.130233   -0.0138154      226426.      15928.6
;          68      6.72067      6.78572      6.84334     0.122669   -0.0142827      224556.      16188.6
;          69      6.82189      6.88734      6.94302     0.121136   -0.0126572      219169.      16094.5
;          70      6.93040      6.99437      7.05075     0.120354  -0.00563145      220246.      16086.5
;          71      7.02241      7.09105      7.14662     0.124214  -0.00895262      218196.      15850.5
;          72      7.13108      7.19649      7.25387     0.122795  -0.00351477      218701.      15764.5
;          73      7.23254      7.29708      7.35283     0.120286  -0.00292301      216457.      16018.4
;          74      7.33243      7.39793      7.45112     0.118692  -0.00206995      218928.      15792.0
;          75      7.43208      7.49832      7.55306     0.120981  -0.00168037      217921.      15579.4
;          76      7.53283      7.59721      7.65351     0.120680  -0.00279236      228209.      16299.1
;          77      7.63370      7.70278      7.75504     0.121342   0.00277758      212245.      16733.5
;          78      7.88714      7.90720      8.04988     0.162744     0.107198      212104.      9628.00
;          79      7.83437      7.90087      7.95416     0.119786  0.000869751      233664.      17893.3
;          80      7.74041      7.87420      7.85008     0.109671    -0.125798      215888.      9882.05
;          81      8.03394      8.09873      8.15486     0.120915  -0.00127316      233255.      17269.0
;          82      8.13316      8.20230      8.25748     0.124318   0.00229740      212765.      16105.6
;          83      8.24078      8.30413      8.35901     0.118237   0.00412750      201822.      15469.2
;       2      7.98000      16.1600      8.18000      77.0000      164.000      87.0000
;   cell, integral, left, center, right, fwhm
;          84      8.34083      8.40485      8.45968     0.118854   0.00484848      204517.      15801.5
;          85      8.43586      8.50538      8.55873     0.122875   0.00537682      203103.      15540.2
;          86      8.54130      8.60636      8.66251     0.121202   0.00635529      206616.      15620.2
;          87      8.64222      8.71108      8.76720     0.124981    0.0110807      212560.      15867.0
;          88      8.74389      8.81219      8.86664     0.122746    0.0121880      209087.      15771.1
;          89      8.84406      8.91344      8.96728     0.123225    0.0134449      211201.      15725.8
;          90      8.94334      9.01135      9.06746     0.124116    0.0113468      207619.      15540.3
;          91      9.05113      9.11571      9.17271     0.121582    0.0157137      209937.      15570.3
;          92      9.14402      9.21377      9.26901     0.124984    0.0137739      207374.      15504.8
;          93      9.25116      9.31820      9.37457     0.123406    0.0181999      209129.      15702.6
;          94      9.35204      9.41944      9.47516     0.123113    0.0194435      210250.      15393.4
;          95      9.45329      9.52157      9.57611     0.122818    0.0215712      210666.      15217.6
;          96      9.55051      9.61908      9.67529     0.124778    0.0190783      210884.      14738.8
;          97      9.65355      9.72197      9.77866     0.125102    0.0219660      216659.      15079.7
;          98      9.75326      9.82052      9.87854     0.125279    0.0205164      209912.      14755.0
;          99      9.85268      9.91806      9.97134     0.118663    0.0180607      203769.      14819.0
;         100      9.95098      10.0186      10.0747     0.123766    0.0185862      207579.      14000.9
;         101      10.0306      10.0890      10.1423     0.111710   -0.0109911      193303.      14148.8
;         102      10.1135      10.1786      10.2347     0.121238   -0.0213900      207273.      14652.7
;         103      10.2115      10.2731      10.3313     0.119824   -0.0269184      202789.      14991.8
;         104      10.3114      10.3760      10.4335     0.122142   -0.0239553      213704.      15961.3
;         105      10.4129      10.4799      10.5374     0.124408   -0.0200577      212030.      16004.2
;         106      10.5146      10.5835      10.6407     0.126097   -0.0164766      214637.      16081.3
;         107      10.6107      10.6760      10.7334     0.122686   -0.0240459      213723.      15906.9
;         108      10.7124      10.7781      10.8344     0.121994   -0.0219212      211339.      15993.0
;         109      10.8126      10.8801      10.9374     0.124761   -0.0199223      212425.      16107.3
;         110      10.9203      10.9825      11.0388     0.118572   -0.0174532      210510.      16187.9
;         111      11.0154      11.0834      11.1383     0.122881   -0.0166035      208765.      16090.3
;         112      11.1201      11.1847      11.2413     0.121195   -0.0153017      210140.      16008.1
;         113      11.2221      11.2864      11.3406     0.118505   -0.0135565      209698.      16104.1
;         114      11.3215      11.3878      11.4446     0.123065   -0.0121927      209857.      16042.1
;         115      11.4233      11.4896      11.5452     0.121852   -0.0104151      210299.      16148.7
;         116      11.5236      11.5910      11.6472     0.123575  -0.00904369      211923.      15801.7
;         117      11.6135      11.6815      11.7377     0.124134   -0.0184660      217171.      16070.5
;         118      11.7143      11.7824      11.8386     0.124269   -0.0176125      216464.      16044.6
;         119      11.8147      11.8831      11.9375     0.122888   -0.0168667      217703.      16240.1
;         120      11.9203      11.9833      12.0382     0.117890   -0.0166779      216159.      16112.6
;         121      12.0206      12.0837      12.1388     0.118132   -0.0162535      216385.      15872.4
;         122      12.1150      12.1830      12.2385     0.123503   -0.0169592      214350.      15846.3
;         123      12.2131      12.2820      12.3372     0.124034   -0.0180082      214859.      15550.5
;         124      12.3133      12.3810      12.4356     0.122330   -0.0189753      215040.      15366.4
;         125      12.4126      12.4765      12.5298     0.117137   -0.0235157      202577.      14802.8
;         126      12.5034      12.5754      12.6353     0.131881   -0.0245705      244795.      16025.8
;         127      12.6107      12.6733      12.7280     0.117276   -0.0266628      207073.      14940.0
;         128      12.7041      12.7712      12.8280     0.123850   -0.0287895      213729.      15242.0
;         129      12.8031      12.8697      12.9259     0.122827   -0.0302753      212951.      15553.5
;         130      12.9007      12.9660      13.0234     0.122705   -0.0339899      215920.      15827.2
;         131      13.0016      13.0664      13.1216     0.120004   -0.0336313      214272.      15912.8
;         132      13.1018      13.1666      13.2218     0.120034   -0.0334044      212409.      15906.9
;         133      13.2034      13.2699      13.3262     0.122766   -0.0300932      214382.      16030.6
;         134      13.3029      13.3704      13.4266     0.123662   -0.0295515      216272.      16194.3
;         135      13.4042      13.4709      13.5273     0.123071   -0.0290537      214267.      16052.1
;         136      13.5044      13.5718      13.6284     0.124030   -0.0281849      214349.      15969.9
;         137      13.6105      13.6743      13.7288     0.118332   -0.0257196      214333.      15969.2
;         138      13.7044      13.7724      13.8288     0.124384   -0.0276127      212373.      15840.9
;         139      13.8101      13.8719      13.9279     0.117820   -0.0281057      213051.      16060.3
;         140      13.9102      13.9727      14.0290     0.118772   -0.0272684      214765.      16082.9
;         141      14.0053      14.0737      14.1302     0.124913   -0.0262747      212413.      15918.1
;         142      14.1109      14.1741      14.2316     0.120762   -0.0259247      214273.      16076.1
;         143      14.2122      14.2779      14.3337     0.121490   -0.0221148      211233.      15646.5
;         144      14.3119      14.3783      14.4345     0.122590   -0.0217209      212516.      15721.4
;         145      14.4133      14.4794      14.5342     0.120914   -0.0205851      212289.      16018.8
;         146      14.5134      14.5807      14.6367     0.123277   -0.0193167      212176.      15872.4
;         147      14.6144      14.6814      14.7360     0.121583   -0.0185642      211489.      16025.8
;         148      14.7134      14.7803      14.8353     0.121841   -0.0196753      213787.      15859.9
;         149      14.8140      14.8818      14.9372     0.123214   -0.0182467      216991.      16073.3
;         150      14.9141      14.9822      15.0371     0.122995   -0.0178442      211092.      15841.1
;         151      15.0211      15.0841      15.1391     0.118015   -0.0159168      210892.      15982.0
;         152      15.1201      15.1840      15.2400     0.119863   -0.0160131      214879.      15928.4
;         153      15.2212      15.2856      15.3414     0.120174   -0.0144110      213755.      15915.9
;         154      15.3211      15.3868      15.4433     0.122257   -0.0131836      212656.      15770.9
;         155      15.4217      15.4888      15.5462     0.124482   -0.0111799      214226.      15734.4
;         156      15.5226      15.5908      15.6474     0.124801  -0.00915623      213500.      15826.8
;         157      15.6223      15.6919      15.7483     0.126060  -0.00814819      217200.      15752.6
;         158      15.7230      15.7944      15.8526     0.129645  -0.00558186      218055.      15528.2
;         159      15.8241      15.8972      15.9557     0.131574  -0.00282478      219910.      15360.9
;         160      15.9240      15.9960      16.0546     0.130564  -0.00399971      215896.      15123.9
;         161      16.0244      16.0957      16.1569     0.132500  -0.00432396      215479.      15145.7
;         162      16.1243      16.1962      16.2570     0.132660  -0.00377655      219500.      15380.4
;         163      16.2302      16.3006      16.3621     0.131884  0.000646591      218166.      15113.0
;         164      16.3321      16.4099      16.4754     0.143219   0.00994110      220348.      14312.4
;       3      15.9600      24.1400      8.18000      158.000      245.000      87.0000
;   cell, integral, left, center, right, fwhm
;         165      16.4331      16.5168      16.5872     0.154041    0.0167732      219106.      13285.1
;         166      16.5225      16.5983      16.6585     0.136055  -0.00170135      201689.      12570.4
;         167      16.6136      16.6934      16.7604     0.146797  -0.00660706      253353.      15079.4
;         168      16.7016      16.7688      16.8185     0.116930   -0.0312233      168961.      11997.3
;         169      16.7808      16.8483      16.9074     0.126654   -0.0516624      233573.      14883.9
;         170      16.8528      16.9214      16.9843     0.131575   -0.0786247      193441.      13104.2
;         171      16.9511      17.0225      17.0829     0.131832   -0.0774899      222246.      14793.6
;         172      17.0521      17.1274      17.1931     0.141039   -0.0726128      246250.      15879.7
;         173      17.1706      17.2405      17.2999     0.129230   -0.0594578      229878.      16121.1
;         174      17.2754      17.3474      17.4054     0.130026   -0.0525627      224468.      16106.2
;         175      17.3836      17.4527      17.5091     0.125532   -0.0472889      228663.      16666.2
;         176      17.4909      17.5577      17.6155     0.124599   -0.0423489      228738.      16382.2
;         177      17.5930      17.6605      17.7170     0.123980   -0.0394650      219012.      16219.7
;         178      17.6940      17.7635      17.8194     0.125422   -0.0365028      221739.      16285.1
;         179      17.8010      17.8661      17.9226     0.121643   -0.0339451      220140.      16071.5
;         180      17.9019      17.9672      18.0239     0.122047   -0.0328369      224318.      16127.0
;         181      18.0026      18.0690      18.1249     0.122227   -0.0310173      216085.      15815.5
;         182      18.1031      18.1695      18.2272     0.124136   -0.0305195      219768.      15959.6
;         183      18.2039      18.2716      18.3278     0.123911   -0.0284004      216931.      15990.4
;         184      18.3037      18.3716      18.4271     0.123396   -0.0283794      215948.      15773.8
;         185      18.4040      18.4725      18.5282     0.124243   -0.0274773      217379.      15632.0
;         186      18.5041      18.5722      18.6272     0.123047   -0.0278149      213600.      15557.1
;         187      18.6101      18.6731      18.7282     0.118074   -0.0269489      211529.      15350.0
;         188      18.7025      18.7682      18.8228     0.120270   -0.0318012      211601.      15327.2
;         189      18.8020      18.8681      18.9241     0.122145   -0.0319328      211329.      14959.0
;         190      18.8933      18.9606      19.0164     0.123165   -0.0394077      210134.      14898.8
;         191      18.9903      19.0529      19.1119     0.121626   -0.0470562      211616.      14736.8
;         192      19.0840      19.1520      19.2087     0.124722   -0.0480385      215429.      15142.5
;         193      19.1905      19.2532      19.3087     0.118216   -0.0468311      214702.      15456.6
;         194      19.2850      19.3535      19.4088     0.123812   -0.0464783      213266.      15494.8
;         195      19.3851      19.4546      19.5122     0.127085   -0.0454273      215992.      15652.1
;         196      19.4854      19.5553      19.6124     0.126987   -0.0446644      214496.      15607.9
;         197      19.5914      19.6559      19.7095     0.118147   -0.0440693      213069.      15709.6
;         198      19.6906      19.7563      19.8098     0.119242   -0.0436974      212510.      15621.0
;         199      19.7920      19.8576      19.9142     0.122225   -0.0424156      214553.      15652.9
;         200      19.8930      19.9584      20.0155     0.122486   -0.0416489      212436.      15550.9
;         201      19.9934      20.0586      20.1150     0.121628   -0.0414066      211410.      15803.4
;         202      20.0936      20.1598      20.2165     0.122877   -0.0401783      213328.      15788.7
;         203      20.2212      20.2851      20.3409     0.119747   -0.0148888      211510.      15344.5
;         204      20.3218      20.3856      20.4414     0.119595   -0.0143833      213332.      15426.5
;         205      20.4224      20.4871      20.5436     0.121216   -0.0128822      212872.      15422.5
;         206      20.5226      20.5886      20.6431     0.120577   -0.0114155      211136.      15301.7
;         207      20.6208      20.6824      20.7372     0.116434   -0.0176334      212508.      15399.9
;         208      20.7209      20.7828      20.8377     0.116783   -0.0171909      211894.      15421.5
;         209      20.8231      20.8893      20.9442     0.121046   -0.0106602      211711.      15501.4
;         210      20.9214      20.9839      21.0366     0.115206   -0.0161476      210944.      15463.7
;         211      21.0153      21.0839      21.1379     0.122583   -0.0160770      214022.      15243.9
;         212      21.1301      21.1913      21.2467     0.116602  -0.00873566      209382.      15259.3
;         213      21.2206      21.2856      21.3402     0.119549   -0.0143585      213034.      15380.8
;         214      21.3207      21.3856      21.4389     0.118210   -0.0143909      213490.      15364.0
;         215      21.4210      21.4871      21.5409     0.119860   -0.0129128      215210.      15503.3
;         216      21.5224      21.5881      21.6432     0.120840   -0.0119267      212515.      15403.3
;         217      21.6238      21.6902      21.7436     0.119850  -0.00984573      212555.      15356.0
;         218      21.7230      21.7917      21.8479     0.124834  -0.00832939      217219.      15151.6
;         219      21.8220      21.8897      21.9441     0.122055   -0.0103111      213410.      15555.1
;         220      21.9231      21.9908      22.0452     0.122082  -0.00921059      211007.      15275.8
;         221      22.0238      22.0911      22.1461     0.122349  -0.00886154      211796.      15630.5
;         222      22.1237      22.1928      22.2490     0.125349  -0.00719643      213793.      14919.1
;         223      22.2235      22.2941      22.3500     0.126505  -0.00586700      216224.      14667.6
;         224      22.3221      22.3907      22.4475     0.125431  -0.00931168      211425.      14475.6
;         225      22.4215      22.4881      22.5453     0.123789   -0.0119076      217415.      14658.9
;         226      22.5212      22.5864      22.6426     0.121378   -0.0135670      213573.      14728.9
;         227      22.6212      22.6849      22.7403     0.119062   -0.0151310      209177.      14858.7
;         228      22.7205      22.7829      22.8383     0.117830   -0.0170708      211966.      15119.4
;         229      22.8220      22.8874      22.9447     0.122742   -0.0125847      223820.      15403.6
;         230      22.9117      22.9758      23.0296     0.117893   -0.0241508      222226.      16023.2
;         231      23.0059      23.0765      23.1340     0.128042   -0.0235062      224573.      15418.2
;         232      23.1120      23.1788      23.2336     0.121599   -0.0211926      227682.      15500.5
;         233      23.2127      23.2797      23.3359     0.123262   -0.0203362      226964.      15500.5
;         234      23.3205      23.3801      23.4355     0.114994   -0.0198956      225858.      15515.8
;         235      23.4204      23.4808      23.5373     0.116972   -0.0191917      224685.      15348.9
;         236      23.5205      23.5821      23.6385     0.117998   -0.0178585      225219.      15440.8
;         237      23.6209      23.6839      23.7401     0.119156   -0.0161362      224056.      15417.8
;         238      23.7108      23.7808      23.8316     0.120802   -0.0191593      231792.      15704.8
;         239      23.8114      23.8813      23.9315     0.120150   -0.0187092      246349.      16352.5
;         240      23.9229      23.9860      24.0423     0.119322   -0.0140209      219340.      15485.8
;         241      24.0130      24.0844      24.1350     0.121990   -0.0155506      240219.      16461.0
;         242      24.1232      24.1881      24.2458     0.122532   -0.0119419      214992.      15320.0
;         243      24.2136      24.2873      24.3375     0.123953   -0.0126534      239704.      16101.3
;         244      24.3200      24.3878      24.4372     0.117176   -0.0122375      235384.      16021.8
;         245      24.4202      24.4890      24.5391     0.118959   -0.0110016      238208.      16085.0
;       4      23.9400      32.1200      8.18000      239.000      326.000      87.0000
;   cell, integral, left, center, right, fwhm
;         246      24.5202      24.5909      24.6416     0.121418  -0.00909233      238840.      15957.8
;         247      24.6213      24.6922      24.7434     0.122183  -0.00775337      240233.      16043.9
;         248      24.7216      24.7936      24.8455     0.123962  -0.00640488      237202.      15794.9
;         249      24.8221      24.8938      24.9445     0.122387  -0.00619698      235988.      15910.8
;         250      24.9217      24.9932      25.0430     0.121269  -0.00676727      234093.      15656.4
;         251      25.0213      25.0920      25.1438     0.122471  -0.00802231      234587.      15483.5
;         252      25.1202      25.1901      25.2418     0.121634  -0.00994492      232708.      15438.5
;         253      25.2137      25.2903      25.3426     0.128977  -0.00969505      228378.      15197.4
;         254      25.3129      25.3905      25.4403     0.127399  -0.00953484      225967.      14552.4
;         255      25.4044      25.4865      25.5439     0.139475   -0.0134888      222930.      13420.0
;         256      25.5004      25.5811      25.6423     0.141926   -0.0188770      206350.      11900.4
;         257      25.5849      25.6567      25.7062     0.121319   -0.0433044      233175.      15873.3
;         258      25.6711      25.7390      25.7913     0.120167   -0.0609818      214222.      14515.8
;         259      25.7646      25.8366      25.8909     0.126268   -0.0633526      232127.      15821.6
;         260      25.8732      25.9455      26.0000     0.126858   -0.0545120      234906.      16219.1
;         261      25.9804      26.0496      26.1035     0.123129   -0.0503521      235585.      16532.9
;         262      26.0826      26.1533      26.2054     0.122854   -0.0467167      232635.      16523.3
;         263      26.1901      26.2575      26.3121     0.121967   -0.0425205      233890.      16303.1
;         264      26.2915      26.3606      26.4139     0.122326   -0.0394230      228446.      16242.9
;         265      26.3930      26.4642      26.5183     0.125322   -0.0357647      233282.      16160.1
;         266      26.4944      26.5697      26.6247     0.130310   -0.0302925      241806.      16190.1
;         267      26.6016      26.6777      26.7365     0.134869   -0.0222530      241453.      15437.7
;         268      26.6934      26.7748      26.8338     0.140398   -0.0252285      229809.      13957.9
;         269      26.8007      26.8690      26.9196     0.118917   -0.0309944      216256.      14928.5
;         270      26.8902      26.9700      27.0366     0.146322   -0.0300350      222409.      12947.5
;         271      26.9722      27.0509      27.1117     0.139442   -0.0490608      211125.      13911.8
;         272      27.0905      27.1601      27.2158     0.125322   -0.0398827      216440.      15608.2
;         273      27.1912      27.2619      27.3162     0.124971   -0.0380592      226613.      16543.5
;         274      27.2938      27.3652      27.4174     0.123631   -0.0347881      226935.      16535.2
;         275      27.4001      27.4676      27.5216     0.121483   -0.0323849      227772.      16207.9
;         276      27.5017      27.5702      27.6229     0.121183   -0.0297775      226757.      16370.2
;         277      27.6023      27.6718      27.7244     0.122143   -0.0282173      222040.      15802.9
;         278      27.7025      27.7722      27.8251     0.122622   -0.0278034      224410.      16006.4
;         279      27.8021      27.8696      27.9223     0.120203   -0.0303879      215922.      15632.7
;         280      27.9020      27.9695      28.0230     0.121035   -0.0305061      219484.      15637.4
;         281      28.0023      28.0714      28.1242     0.121977   -0.0286045      221656.      15771.6
;         282      28.1017      28.1703      28.2228     0.121048   -0.0297451      220202.      15601.6
;         283      28.2009      28.2668      28.3211     0.120167   -0.0332069      213567.      15217.7
;         284      28.2937      28.3643      28.4161     0.122358   -0.0357189      213961.      15373.4
;         285      28.3915      28.4635      28.5183     0.126837   -0.0364628      228717.      15589.8
;         286      28.4919      28.5586      28.6086     0.116686   -0.0413952      211775.      15634.2
;         287      28.5819      28.6521      28.7085     0.126581   -0.0478706      225292.      15208.1
;         288      28.6808      28.7496      28.8058     0.125023   -0.0504189      216739.      15047.2
;         289      28.7819      28.8511      28.9061     0.124186   -0.0489483      218624.      15646.5
;         290      28.8818      28.9525      29.0081     0.126234   -0.0475254      217499.      15579.0
;         291      28.9830      29.0531      29.1082     0.125198   -0.0468788      222403.      16061.6
;         292      29.0829      29.1540      29.2087     0.125834   -0.0459595      217905.      15919.5
;         293      29.1901      29.2560      29.3102     0.120096   -0.0439720      216496.      15753.6
;         294      29.2909      29.3569      29.4111     0.120291   -0.0430851      217278.      15918.8
;         295      29.3902      29.4582      29.5128     0.122585   -0.0418415      216856.      15606.5
;         296      29.4917      29.5589      29.6130     0.121378   -0.0410728      216656.      15664.6
;         297      29.5921      29.6598      29.7138     0.121651   -0.0401764      216496.      15781.1
;         298      29.6931      29.7604      29.8136     0.120476   -0.0396309      215338.      16014.9
;         299      29.7920      29.8596      29.9134     0.121395   -0.0403652      213418.      15780.8
;         300      29.8922      29.9603      30.0146     0.122356   -0.0397434      215705.      15824.1
;         301      29.9929      30.0613      30.1149     0.122042   -0.0387459      214571.      15781.1
;         302      30.0931      30.1618      30.2156     0.122517   -0.0381947      213668.      15823.2
;         303      30.1934      30.2627      30.3147     0.121315   -0.0372791      216905.      15994.3
;         304      30.2936      30.3635      30.4167     0.123068   -0.0364780      209917.      15471.1
;         305      30.4000      30.4638      30.5182     0.118233   -0.0362453      218868.      16059.1
;         306      30.5006      30.5658      30.6190     0.118387   -0.0341873      212941.      15855.3
;         307      30.6011      30.6668      30.7203     0.119247   -0.0331554      214091.      15925.7
;         308      30.7014      30.7679      30.8212     0.119778   -0.0320873      213085.      15946.6
;         309      30.7936      30.8624      30.9162     0.122663   -0.0376301      215404.      15939.2
;         310      30.8945      30.9640      31.0170     0.122585   -0.0360241      213345.      16025.8
;         311      31.0026      31.0709      31.1243     0.121614   -0.0290813      214713.      16084.1
;         312      31.1003      31.1669      31.2197     0.119360   -0.0330868      214579.      16080.4
;         313      31.2009      31.2685      31.3227     0.121897   -0.0314617      211548.      15905.7
;         314      31.3019      31.3703      31.4248     0.122900   -0.0297012      215021.      16099.8
;         315      31.4033      31.4729      31.5267     0.123474   -0.0270748      214831.      16294.5
;         316      31.5100      31.5758      31.6309     0.120874   -0.0242100      213749.      16165.1
;         317      31.6122      31.6792      31.7328     0.120636   -0.0207577      211499.      16307.5
;         318      31.7131      31.7840      31.8374     0.124313   -0.0160351      209235.      15992.4
;         319      31.8210      31.8897      31.9436     0.122643   -0.0102825      203920.      15295.4
;         320      31.9141      31.9871      32.0397     0.125568   -0.0129375      215387.      15343.8
;         321      32.0028      32.0715      32.1233     0.120502   -0.0285454      202518.      14560.9
;         322      32.0927      32.1594      32.2119     0.119137   -0.0405693      205550.      14923.7
;         323      32.1902      32.2539      32.3069     0.116634   -0.0461388      208907.      14947.6
;         324      32.2831      32.3511      32.4046     0.121498   -0.0489502      207605.      15014.8
;         325      32.3826      32.4492      32.5026     0.119915   -0.0508232      210107.      15408.7
;         326      32.4822      32.5482      32.6018     0.119572   -0.0517731      206967.      15233.0
;       5      31.9200      40.1000      8.18000      320.000      407.000      87.0000
;   cell, integral, left, center, right, fwhm
;         327      32.5817      32.6476      32.7024     0.120716   -0.0523796      210163.      15243.3
;         328      32.6818      32.7483      32.8028     0.120998   -0.0516815      210326.      15414.0
;         329      32.7836      32.8514      32.9052     0.121563   -0.0486412      210932.      15549.4
;         330      32.8838      32.9523      33.0062     0.122334   -0.0477219      209854.      15520.8
;         331      32.9844      33.0532      33.1069     0.122532   -0.0468140      211048.      15755.2
;         332      33.0831      33.1510      33.2053     0.122272   -0.0490341      209604.      15653.4
;         333      33.1903      33.2550      33.3099     0.119637   -0.0450172      210339.      15537.0
;         334      33.2906      33.3562      33.4100     0.119411   -0.0438156      210812.      15669.0
;         335      33.3908      33.4576      33.5109     0.120060   -0.0423965      210928.      15550.0
;         336      33.4918      33.5588      33.6121     0.120239   -0.0411987      210208.      15697.1
;         337      33.5923      33.6596      33.7129     0.120605   -0.0403557      210091.      15444.0
;         338      33.6925      33.7601      33.8140     0.121433   -0.0399017      209949.      15445.5
;         339      33.7929      33.8603      33.9128     0.119881   -0.0396538      208538.      15596.7
;         340      33.8919      33.9587      34.0132     0.121342   -0.0413437      212061.      15390.5
;         341      33.9926      34.0602      34.1135     0.120907   -0.0397530      206582.      15257.1
;         342      34.0918      34.1583      34.2117     0.119942   -0.0416985      209459.      15307.4
;         343      34.1918      34.2584      34.3124     0.120556   -0.0415878      210788.      15384.9
;         344      34.2917      34.3586      34.4124     0.120705   -0.0413551      209527.      15317.2
;         345      34.3917      34.4577      34.5114     0.119701   -0.0422745      207585.      15206.6
;         346      34.4909      34.5568      34.6105     0.119587   -0.0432281      207440.      15139.3
;         347      34.5844      34.6551      34.7084     0.123974   -0.0449371      205207.      15087.6
;         348      34.6837      34.7539      34.8073     0.123547   -0.0461159      208956.      15305.9
;         349      34.7835      34.8527      34.9061     0.122509   -0.0472565      204817.      14934.5
;         350      34.8825      34.9504      35.0041     0.121590   -0.0495605      207834.      15034.3
;         351      34.9741      35.0448      35.0997     0.125572   -0.0551529      206361.      14938.3
;         352      35.0728      35.1437      35.1991     0.126312   -0.0562744      205581.      14727.7
;         353      35.1732      35.2428      35.2990     0.125786   -0.0571938      207138.      15046.6
;         354      35.2729      35.3422      35.3974     0.124508   -0.0578041      205354.      15207.7
;         355      35.3722      35.4413      35.4961     0.123928   -0.0587044      208503.      15303.6
;         356      35.4723      35.5419      35.5982     0.125908   -0.0580635      208641.      15270.1
;         357      35.5729      35.6425      35.6980     0.125179   -0.0574760      208261.      15442.5
;         358      35.6735      35.7434      35.7974     0.123901   -0.0566139      209298.      15719.3
;         359      35.7810      35.8468      35.9011     0.120136   -0.0531883      205697.      15490.6
;         360      35.8743      35.9435      35.9978     0.123501   -0.0565033      209101.      15833.3
;         361      35.9803      36.0448      36.0991     0.118740   -0.0552292      208561.      15596.6
;         362      36.0822      36.1502      36.2057     0.123482   -0.0497971      207047.      15454.7
;         363      36.1830      36.2520      36.3069     0.123875   -0.0479507      206570.      15529.1
;         364      36.2901      36.3533      36.4082     0.118050   -0.0467453      206593.      15618.1
;         365      36.3907      36.4552      36.5105     0.119793   -0.0447540      207529.      15586.3
;         366      36.4911      36.5571      36.6113     0.120144   -0.0428734      206229.      15462.4
;         367      36.5923      36.6579      36.7118     0.119423   -0.0420647      206794.      15651.0
;         368      36.6911      36.7569      36.8104     0.119236   -0.0430603      207138.      15472.5
;         369      36.7903      36.8571      36.9108     0.120453   -0.0429077      206876.      15215.6
;         370      36.8916      36.9581      37.0112     0.119564   -0.0419197      208755.      15447.5
;         371      36.9921      37.0585      37.1114     0.119350   -0.0415306      204414.      15159.0
;         372      37.0911      37.1579      37.2106     0.119534   -0.0420914      209340.      15543.2
;         373      37.1920      37.2584      37.3098     0.117855   -0.0416489      206423.      15394.2
;         374      37.2923      37.3589      37.4126     0.120228   -0.0410576      208474.      15388.4
;         375      37.3925      37.4598      37.5133     0.120815   -0.0401917      207146.      15505.2
;         376      37.4927      37.5601      37.6144     0.121704   -0.0398712      208644.      15571.1
;         377      37.5931      37.6611      37.7149     0.121861   -0.0389404      207377.      15553.7
;         378      37.6930      37.7611      37.8144     0.121330   -0.0389481      205919.      15330.2
;         379      37.7943      37.8629      37.9161     0.121799   -0.0370522      207840.      15490.7
;         380      37.8923      37.9592      38.0140     0.121738   -0.0407677      205082.      15187.0
;         381      37.9914      38.0577      38.1116     0.120232   -0.0422554      204508.      15246.3
;         382      38.0913      38.1596      38.2142     0.122890   -0.0403557      204619.      14781.0
;         383      38.1919      38.2583      38.3102     0.118271   -0.0417023      204442.      14874.0
;         384      38.2908      38.3560      38.4096     0.118835   -0.0440407      205810.      14624.9
;         385      38.3830      38.4512      38.5054     0.122375   -0.0488243      202925.      14476.3
;         386      38.4821      38.5482      38.6018     0.119759   -0.0517998      204802.      14814.0
;         387      38.5813      38.6462      38.7009     0.119644   -0.0538406      206057.      15139.4
;         388      38.6806      38.7449      38.7991     0.118443   -0.0550652      205794.      15155.6
;         389      38.7819      38.8503      38.9060     0.124096   -0.0496864      208821.      15451.1
;         390      38.8832      38.9513      39.0061     0.122871   -0.0486565      205847.      15394.6
;         391      38.9809      39.0454      39.1008     0.119965   -0.0545921      206386.      15475.2
;         392      39.0836      39.1528      39.2076     0.123997   -0.0471916      208709.      15673.2
;         393      39.1903      39.2541      39.3070     0.116661   -0.0459442      206737.      15633.7
;         394      39.2905      39.3554      39.4103     0.119785   -0.0445747      209470.      15457.2
;         395      39.3914      39.4565      39.5114     0.119934   -0.0435181      208066.      15415.9
;         396      39.4919      39.5574      39.6116     0.119766   -0.0426483      208314.      15525.4
;         397      39.5810      39.6476      39.7013     0.120346   -0.0523720      206363.      15471.9
;         398      39.6818      39.7485      39.8016     0.119797   -0.0515137      208603.      15612.4
;         399      39.7821      39.8498      39.9029     0.120804   -0.0501556      207921.      15664.2
;         400      39.8931      39.9611      40.0164     0.123302   -0.0389366      209045.      15492.6
;         401      39.9940      40.0627      40.1165     0.122562   -0.0372810      208400.      15583.6
;         402      40.0905      40.1544      40.2089     0.118343   -0.0455780      209259.      15645.0
;         403      40.1915      40.2564      40.3110     0.119465   -0.0436172      208221.      15592.0
;         404      40.2917      40.3580      40.4129     0.121262   -0.0419884      210405.      15417.1
;         405      40.3929      40.4599      40.5132     0.120266   -0.0400581      208775.      15561.6
;         406      40.4934      40.5609      40.6140     0.120583   -0.0391350      207014.      15267.3
;         407      40.5822      40.6497      40.7022     0.120026   -0.0502892      210835.      15392.2
;Intersection Analysis
;At     0.298078 between       4 and       3
;At     0.209782 between       5 and       4
;At    0.0571646 between       6 and       5
;At   -0.0259963 between       7 and       6
;At   -0.0594684 between       8 and       7
;At   -0.0710539 between       9 and       8
;At   -0.0685778 between      10 and       9
;At   -0.0702989 between      11 and      10
;At   -0.0689542 between      12 and      11
;At   -0.0728956 between      13 and      12
;At   -0.0771294 between      14 and      13
;At   -0.0821145 between      15 and      14
;At   -0.0866359 between      16 and      15
;At   -0.0933617 between      17 and      16
;At   -0.0994127 between      18 and      17
;At   -0.0995895 between      19 and      18
;At    -0.102502 between      20 and      19
;At    -0.108605 between      21 and      20
;At    -0.116473 between      22 and      21
;At    -0.129915 between      23 and      22
;At    -0.139081 between      24 and      23
;At    -0.225086 between      26 and      24
;At    -0.275840 between      27 and      26
;At    -0.338128 between      28 and      27
;At    -0.255740 between      34 and      28
;At     0.151569 between      35 and      34
;At    0.0949328 between      36 and      35
;At    0.0563252 between      37 and      36
;At    0.0276041 between      38 and      37
;At   0.00245118 between      39 and      38
;At  -0.00780535 between      40 and      39
;At   -0.0206819 between      41 and      40
;At   -0.0332165 between      42 and      41
;At   -0.0450454 between      43 and      42
;At   -0.0429635 between      44 and      43
;At   -0.0295477 between      45 and      44
;At   -0.0220156 between      46 and      45
;At   -0.0268240 between      47 and      46
;At   -0.0362120 between      48 and      47
;At   -0.0446453 between      49 and      48
;At   -0.0529404 between      50 and      49
;At   -0.0537567 between      51 and      50
;At   -0.0451455 between      52 and      51
;At   -0.0334983 between      53 and      52
;At   -0.0305057 between      54 and      53
;At   -0.0362072 between      55 and      54
;At   -0.0432243 between      56 and      55
;At   -0.0499291 between      57 and      56
;At   -0.0564847 between      58 and      57
;At   -0.0613999 between      59 and      58
;At   -0.0695176 between      60 and      59
;At   -0.0780745 between      61 and      60
;At   -0.0887079 between      62 and      61
;At   -0.0969453 between      64 and      62
;At  -0.00415325 between      65 and      64
;At   -0.0119104 between      66 and      65
;At   -0.0267282 between      67 and      66
;At   -0.0325394 between      68 and      67
;At   -0.0315146 between      69 and      68
;At   -0.0367303 between      70 and      69
;At   -0.0388374 between      71 and      70
;At   -0.0394835 between      72 and      71
;At   -0.0431919 between      73 and      72
;At   -0.0427246 between      74 and      73
;At   -0.0439463 between      75 and      74
;At   -0.0415339 between      76 and      75
;At   -0.0452137 between      77 and      76
;At   -0.0631948 between      80 and      77
;At    -0.230318 between      81 and      78
;At   -0.0470343 between      82 and      81
;At   -0.0502329 between      83 and      82
;At   -0.0486965 between      84 and      83
;At   -0.0514641 between      85 and      84
;At   -0.0508919 between      86 and      85
;At   -0.0541840 between      87 and      86
;At   -0.0580635 between      88 and      87
;At   -0.0566330 between      89 and      88
;At   -0.0588875 between      90 and      89
;At   -0.0584354 between      91 and      90
;At   -0.0590601 between      92 and      91
;At   -0.0623455 between      93 and      92
;At   -0.0637312 between      94 and      93
;At   -0.0678930 between      95 and      94
;At   -0.0672598 between      96 and      95
;At   -0.0661516 between      97 and      96
;At   -0.0692253 between      98 and      97
;At   -0.0669003 between      99 and      pro idl
print,' '
print,'*** TIPS and TRICKS on IDL - the language in which LAMP is written ***'
print,' '
print,'In LAMP you can use the whole power of IDL - LAMP itself is just a huge macro'
print,'You may find some help by typing "functions" or "procedures" to get help"
print,'for some internal IDL functions and procedures.'
print,'However there are some other syntax information you might want to know ...'
print,' '
print,'Capital letters'
print,' '
print,' Unlike UNIX or C, IDL is insensible to upper- or lowercase letters'
print,' '
print,'Operators :'
print,' ' 
print,' You may use operators in a very obvious way :'
print,' a=4+sin(23)^2*sqrt(9) - the result is in the variable a'
print,' ' 
print,'UNIX commands :'
print,' ' 
print,' You may call system commands by putting a "$" ahead :'
print,' "$ ls -l " will show you the content of your current directory'
print,' ' 
print,'Indices :'
print,' ' 
print,' Indices of arrays are given in round brackets, separated by comma:'
print,' a=fltarr(3,4) & a(0,*)=indgen(4) & print,a(0:1,0:2)'
print,' ' 
print,'Loops :'
print,' ' 
print,' In macros (see ~lambda/macros for examples) you may use for-do or do-while loops:'
print,' a=fltarr(3,4) & for i=0,3 do a(0,*)=i & print,a(0:1,0:2)'
print,' Only in macros you can put several commands in a loop:'
print,' pro mytest,count_to'
print,'   i=0'
print,'   do begin'
print,'     print,i'
print,'     i=i+1'
print,'   while i LE count_to'
print,' end'  
print,' This file called "mytest.pro" has to be in the directory you work in.'
print,' If you type now in LAMP "mytest,10" the procedure will count to 10.'
print,' If you change the file you have to recompile it, in the nowindows version'
print,' "lamp -nw" you type "ctrl-c", then ".run mytest", "retall" and "lamp",'
print,' then you care back in lamp and you will now work with the most recent version'
print,' of your macro.'
print,' '
print,'IF-conditions :'
print,' ' 
print,' In macros (see ~lambda/macros for examples) you may use if-clauses:'
print,' a=fltarr(3,4) & for i=0,3 do if i mod 2 ge 1 then a(0,*)=i & print,a(0:1,0:2)'
print,' Only in macros you can put several commands in a condition:'
print,' pro mytest,count_to'
print,'   i=0'
print,'   do begin'
print,'     if i mod 2 eq 0 then begin
print,'         print,i'
print,'     endif else begin  ' 
print,'         print,i," is odd"'
print,'     endelse '
print,'     i=i+1'
print,'   while i LE count_to'
print,' end'  
print,' This file called "mytest.pro" has to be in the directory you work in.'
print,' If you type now in LAMP "mytest,10" the procedure will count to 10.'
print,' If you change the file you have to recompile it, in the nowindows version'
print,' "lamp -nw" you type "ctrl-c", then ".run mytest", "retall" and "lamp",'
print,' then you care back in lamp and you will now work with the most recent version'
print,' of your macro.'
print,' '
end
; IDL Version 4.0.1 (IRIX mipseb)
; Journal File for hansen@d20sgi.ill.fr
; Working directory: /users/dif/hansen/lambda/983/defil
; Date: Wed Jul  8 10:40:02 1998
 
;Enter PRO or FUNCTION macro below. (the call is macro or a=macros() )

PRO igor,x,w,e
    print,!stime+' by macro'
FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
  openw,/get,fil,"fil"+strcompress(i,/re)
  FOR j=0,N_ELEMENTS(w(*,0))-1 DO BEGIN
    printf,fil,x(j),w(j,i),e(j,i)
  ENDFOR
  free_lun,fil
ENDFOR
return
end
;*******************************************************************************
;*******************************************************************************
pro info_event,ev
;*******************************************************************************
;*******************************************************************************

widget_control,ev.id,get_uvalue=uva
common tablo,tabb
common nb,n
common erreur2,error4
common bases,pre,t,rep,sav
common sa,sam
common vale,val
common check,chec
common top,changer_based0
common total,ti,m,ti2,tx,txx,time_result_string
;common totaltime,ttime			;to calculate total time

case uva(0) of

1020: begin 
	widget_control,ev.id,get_value=inf 
	tabb[1020]=inf
end

1021:begin widget_control,ev.id,get_value=date0
	tabb[1021]=date0
end

1022:begin widget_control,ev.id,get_value=user0
	tabb[1022]=user0
end

1023:begin widget_control,ev.id,get_value=prop0
	tabb[1023]=prop0
end

1024:begin widget_control,ev.id,get_value=set0
	tabb[1024]=set0
end

1025:begin widget_control,ev.id,get_value=data0
	tabb[1025]=data0
end


1026:begin widget_control,ev.id,get_value=book0
	tabb[1026]=book0
end


1011:begin 
	widget_control,ev.top,/destroy
end

1012:begin 
	widget_control,ev.top,/destroy
	info
end

1013:begin 
;------ OK is the condition that allows to write the file (=1) or not (=0) -----
	okk=1
	for i=1,7 do begin
		widget_control,uva(i),get_value=inf
		tabb[1019+i]=inf
		if i ne 5 then begin
;--------------------------------- FIELD CHECKING ------------------------------
			if strlen(inf[0]) le 0 then begin
				case i of
					1:begin
						temp='title'
					end
					2:begin
						temp='date'
					end
					3:begin
						temp='user'
					end
					4:begin
						temp='prop'
					end
					5:begin
					end
					6:begin
						temp='file name'
					end
					7:begin
						temp='book number'
					end
				end
;--------------------------------- ERROR ---------------------------------------
				err4='*** enter value for '
				widget_control,error4,set_value=string(err4) $
					+string(temp)+' field ***'
;-------------------------------------------------------------------------------
				okk=0
			endif	
		endif
	endfor
;-------------------------------------------------------------------------------
;---------------------------- AFFICHAGE ----------------------------------------
	if okk eq 1 then begin
;		print,'par user ',tabb[1022]
;		print,'par prop ',tabb[1023]
;		print,'par title ',tabb[1020]
;		print,'par date ',tabb[1021]
;		print,'par log ',tabb[1026]
;		print,'!'
;		print,'date'
;		print,'!'
		if strlen(tabb[1024]) ge 1 then begin
			;print,'start setting_',tabb[1024]
		endif
;		print,'!'
;		for d=1,tabb[1081] do begin
	  	  for i=1,n[0] do begin
;		    if tabb[i] eq d then begin
		      if (tabb[i+500] eq 's') or (tabb[i+500] eq 'n') then begin
;			print,'cha '+string(d)
;			print,'cha '+string(tabb[i])
			strsub='par sub '
			if strlen(tabb[1024]) ge 1 then begin
			  strsub=strsub+tabb[1024]+'_'
			endif
;			print,strsub,tabb[i+100]
;			print,'run ',tabb[i+200],' ', $
;			tabb[i+300],' ',tabb[i+400],' ',tabb[i+500]
;			print,'!'
		      endif
;	  	    endif
		  endfor
;		endfor
;------------------------------------------- WRITE THE FILE --------------------
		filesaved=string(format='(A30)','')
		filesaved=tabb[1025]+string('.cmd')	
		close,1
		u=1

		openw,u,filesaved
		printf,u,'par user ', tabb[1022]
		printf,u,'par prop ',tabb[1023]
		printf,u,'par title ',tabb[1020]
		printf,u,'par date ',tabb[1021]
		printf,u,'par prop ',tabb[1023]
		printf,u,'par log ',tabb[1026]
		printf,u,'! '
		printf,u,'date '
		printf,u,'! '
		if strlen(tabb[1024]) ge 1 then begin
		  printf,u,'start setting_',tabb[1024]
		endif
		printf,u,'! '
;		for d=1,tabb[1081] do begin
		  for i=1,n[0] do begin
;		    if tabb[i] eq d then begin
		      if (tabb[i+500] eq 's') or (tabb[i+500] eq 'n') then begin
;			printf,u,'cha '+ string(d)
			printf,u,'cha '+ string(tabb[i])
			strsub='par sub '
			if strlen(tabb[1024]) ge 1 then begin
			  strsub=strsub+tabb[1024]+'_'
			endif
			printf,u,strsub,tabb[i+100]
			printf,u,'run ',tabb[i+200],' ',tabb[i+300],' ',$
			  tabb[i+400],' ',tabb[i+500]
			printf,u,'!'
		      endif
;		    endif
		  endfor
;		endfor 
		close,1
;--------------------------------- INFORMATION ON THE FILE----------------------
			err4='*** The file is called '
			widget_control,error4,set_value=string(err4) $
				+string(filesaved)+string(' ***')
;-------------------------------------------------------------------------------
	endif 
end

1014:begin 
	widget_control,changer_based0,/destroy
	DialClear, 'changer_file'
end

;------- GET VALUE OF DATE, TITLE, USER, PROP, LOG BOOK FROM INSTRUMENT --------
1015:begin
	para =DialNewValue(TYPE='t_para',NAME='changer_file')

	user_n=string(para.c_user[0])
	for i=1,9 do begin
		user_n=user_n+string(para.c_user[i])
	endfor

	prop_n=string(para.proposal_number[0])
	for i=1,7 do begin
		prop_n=prop_n+string(para.proposal_number[i])
	endfor
;	print,para.log_book_n[0], '   ',string(para.log_book_n[0])
;	print,para.log_book_n[1], '   ',string(para.log_book_n[1])

	book_n=string(para.log_book_n[0])+string(para.log_book_n[1])$
		+string(para.log_book_n[2])

	date_n=string(para.exp_start_time[0])
	for i=1,10 do begin
		date_n=date_n+string(para.exp_start_time[i])
	endfor

	title_n=string(para.c_txt[0])
	for i=1,38 do begin
		title_n=title_n+string(para.c_txt[i])
	endfor
	
	tabb[1022]=user_n  
	tabb[1021]=date_n
	tabb[1023]=prop_n
	tabb[1026]=book_n
	tabb[1020]=title_n

	widget_control,uva(1),set_value=tabb[1020];	title
	widget_control,uva(2),set_value=tabb[1021];	date
	widget_control,uva(3),set_value=tabb[1022];	user
	widget_control,uva(4),set_value=tabb[1023];	prop
	widget_control,uva(5),set_value=tabb[1026];	book
end
;-------------------------------------------------------------------------------

1016:begin
	filewritten=string(format='(A30)','')
	filewritten=tabb[1025]+'.cmd'
	; print, "new version 2"
	; print, "filewritten: [",filewritten,"]"
	xdisplayfile,filewritten,group=ev.top,height=30,width=60
end

end
end


;*******************************************************************************
;*******************************************************************************
pro info
;*******************************************************************************
;*******************************************************************************



common tablo,tabb
common nb,n
common erreur2,error4
common vale,val
common check,chec
common top,changer_based0
common total,ti,m,ti2,tx,txx,time_result_string
;common totaltime,ttime			;to calculate total time

base0=widget_base(group_leader=changer_based0,title='Command File (5)',/column)

base01=widget_label(base0,frame='5',value='fill in user and file information')
getinst=widget_button(base0,frame='5',value='get from instrument')
;base03=widget_label(base0,value='*********************')

err4=string(format='(I80)','')
error4=widget_label(base0,value=err4)


base1=widget_base(base0, /row)
base10=widget_base(base1, /column)
base11=widget_base(base10,/column)
base111=widget_base(base10,/row)
base12=widget_base(base1,/column)

base13=widget_base(base0,/column,/align_center)
base14=widget_base(base0,/column)
base15=widget_base(base0,/column)

;-------------------------------- BASE CREATION --------------------------------


user=cw_field(base11,xsize=10,title='user:',/return_events)
prop=cw_field(base11,xsize=8,title='proposal #:',/return_events)
title=cw_field(base11,xsize=32,title='title:',/return_events)
date=cw_field(base11,xsize=11,title='starting date:',/return_events)
set=cw_field(base11,xsize=2,title='setting:',/return_events)
book=cw_field(base11,xsize=2,title='log book #:',/return_events)
data=cw_field(base111,xsize=10,title='file name:',value='',/return_events)
data2=widget_label(base111,value='.cmd')


but33=widget_button(base13,frame=10,xsize=250,value='write command file')
but55=widget_button(base13,xsize=250,value='check this file')
but22=widget_button(base13,xsize=250,value='reset')
but11=widget_button(base13,xsize=250,value='close')
but44=widget_button(base13,xsize=250,value='done')

ttime1=widget_label(base15,value=err4)
;-------------------------------------------------------------------------------
;---------------- TO DISPLAY TIME ----------------------------------------------

	time_display


;-------------------------------------------------------------------------------



;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------



widget_control,base0,/realize

;------------------------------------- EVENTS ----------------------------------

widget_control,user,set_uvalue=[1022,user]
widget_control,prop,set_uvalue=[1023,prop]
widget_control,title,set_uvalue=[1020,title]
widget_control,date,set_uvalue=[1021,date]
widget_control,set,set_uvalue=[1024,set]
widget_control,book,set_uvalue=[1026,book]
widget_control,data,set_uvalue=[1025,data]

;++++++++++++++++++++++ VALUE READ ON D22 OR IN FILE +++++++++++++++++++++++++++

widget_control,title,set_value=tabb[1020]
widget_control,date,set_value=tabb[1021]
widget_control,user,set_value=tabb[1022]
widget_control,prop,set_value=tabb[1023]
widget_control,book,set_value=tabb[1026]
widget_control,ttime1,set_value=string(time_result_string)


;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


widget_control,error4,set_uvalue=[1027,error4]

widget_control,but11,set_uvalue=[1011,but11]
widget_control,but22,set_uvalue=[1012,but22]
widget_control,but33,set_uvalue=[1013,title,date,user,prop,set,data,book]
widget_control,but44,set_uvalue=[1014,but44]
widget_control,getinst,set_uvalue=[1015,title,date,user,prop,book]
widget_control,but55,set_uvalue=[1016,data]

;-------------------------------------------
err4=' '
widget_control,error4,set_value=string(err4)
;--------------------------------------------

;------------ fill the widgets with the value of the saved file ----------------
if chec eq 1 then begin
widget_control,title,set_value=val[0]
widget_control,date,set_value=val[1]
widget_control,user,set_value=val[2]
widget_control,prop,set_value=val[3]
endif

xmanager,'info',base0,/just_reg,group_leader=changer_based0

end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION input, file=in_file, fin

;Reads a file previously saved by output.pro (with titles), or any XYE 
;formatted file.
;
;ARGUMENTS
; file	:name of file to input
; (the argument fin is obsolete, kept for backwards compatability)
;
;COMMAND SYNTAX:
; w1=input(file='<in_file>')
; NB - don't forget to include single quotes
;
;							KHA,JRS 14/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start input:'

	take_datp, datp

	IF(N_ELEMENTS(fin) GT 0) THEN in_file=fin

;-------------------------------------------------------------------------------
;Open and read from input file

	line=' '
	IF (iprint GT 0) THEN PRINT,'Opening input file'
	OPENR, 1, in_file, ERROR=err	& IF (err NE 0) THEN BEGIN
		PRINT, !ERR_STRING
		GOTO, finished
	ENDIF

	READF, 1, line
	IF (STRPOS(line,'SIZE(workspace)') EQ -1) THEN oned=1 ELSE oned=0

	IF (oned) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'1-D data format'
		POINT_LUN, 1, 0
		ON_IOERROR, nomoredata
		m=10000	& n=0
		x_in=FLTARR(m)	& w_in=x_in	& e_in=x_in
		FOR i=0,m-1 DO BEGIN
			READF, 1, x, w, e
			x_in(i)=x	& w_in(i)=w	& e_in(i)=e
		ENDFOR
nomoredata:
		x_in=x_in(0:i-1)
		w_in=w_in(0:i-1)
		e_in=e_in(0:i-1)
		n=i

		ON_IOERROR, endoffile
		POINT_LUN, 1, 0
		FOR i=0,n-1 DO READF, 1, x
		READF, 1, line	& datp.x_tit=line
		READF, 1, line	& datp.y_tit=line
		READF, 1, line	& datp.w_tit=line
		READF, 1, line	& datp.other_tit=line

	ENDIF ELSE BEGIN
		IF (iprint GT 0) THEN PRINT,'More than 1-D data format'

		i=STRPOS(line,'=') & n=STRLEN(line) & sw=STRMID(line,i+1,n-i-1)
		ndims=FIX(STRMID(sw,0,12))	& dim=INTARR(ndims)
		FOR i=0,ndims-1 DO dim(i)=FIX(STRMID(sw,12*(i+1),12))
		IF (ndims EQ 2) THEN w_in=FLTARR(dim(0),dim(1)) $
			ELSE IF (ndims EQ 3) THEN w_in=FLTARR(dim(0),dim(1),dim(2)) $
			ELSE w_in=FLTARR(dim(0),dim(1),dim(2),dim(3))
		READF, 1, w_in
		IF (iprint GT 0) THEN PRINT,'w_in read OK'
		e_in=w_in*0.
		READF, 1, e_in
		IF (iprint GT 0) THEN PRINT,'e_in read OK'
		READF, 1, line
		i=STRPOS(line,'=') & n=STRLEN(line) & sx=STRMID(line,i+1,n-i-1)
		ndims=FIX(STRMID(sx,0,12))
		IF (ndims GE 1) THEN BEGIN
			dim=INTARR(ndims) & FOR i=0,ndims-1 DO dim(i)=FIX(STRMID(sx,12*(i+1),12))
			IF (ndims EQ 1) THEN x_in=FLTARR(dim(0)) $
				ELSE IF (ndims EQ 2) THEN x_in=FLTARR(dim(0),dim(1)) $
				ELSE x_in=FLTARR(dim(0),dim(1),dim(2))
		ENDIF ELSE x_in=0
		READF, 1, x_in
		IF (iprint GT 0) THEN PRINT,'x_in read OK'
		READF, 1, line
		i=STRPOS(line,'=') & n=STRLEN(line) & sy=STRMID(line,i+1,n-i-1)
		ndims=FIX(STRMID(sy,0,12))
		IF (ndims GE 1) THEN BEGIN
			dim=INTARR(ndims) & FOR i=0,ndims-1 DO dim(i)=FIX(STRMID(sy,12*(i+1),12))
			IF (ndims EQ 1) THEN y_in=FLTARR(dim(0)) $
				ELSE IF (ndims EQ 2) THEN y_in=FLTARR(dim(0),dim(1)) $
				ELSE y_in=FLTARR(dim(0),dim(1),dim(2))
		ENDIF ELSE y_in=0
		READF, 1, y_in
		IF (iprint GT 0) THEN PRINT,'y_in read OK'
		READF, 1, line
		i=STRPOS(line,'=') & n=STRLEN(line) & sz=STRMID(line,i+1,n-i-1)
		ndims=FIX(STRMID(sz,0,12))
		IF (ndims GE 1) THEN BEGIN
			dim=INTARR(ndims) & FOR i=0,ndims-1 DO dim(i)=FIX(STRMID(sz,12*(i+1),12))
			IF (ndims EQ 1) THEN z_in=FLTARR(dim(0)) $
				ELSE IF (ndims EQ 2) THEN z_in=FLTARR(dim(0),dim(1)) $
				ELSE IF (ndims EQ 3) THEN z_in=FLTARR(dim(0),dim(1),dim(2)) $
				ELSE z_in=FLTARR(dim(0),dim(1),dim(2),dim(3))
		ENDIF ELSE z_in=0
		READF, 1, z_in
		IF (iprint GT 0) THEN PRINT,'z_in read OK'
		READF, 1, line	& datp.x_tit=line
		READF, 1, line	& datp.y_tit=line
		READF, 1, line	& datp.z_tit=line
		READF, 1, line	& datp.w_tit=line
		READF, 1, line	& datp.other_tit=line
		IF (iprint GT 0) THEN PRINT,'titles read OK'

	ENDELSE

endoffile:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'End of "Read from input file" section'

;-------------------------------------------------------------------------------
;Return and exit

	mod_datp, datp, "x", x_in
	mod_datp, datp, "e", e_in
	mod_datp, datp, "p", par
	IF (oned NE 1) THEN BEGIN
		mod_datp, datp, "y", y_in
		mod_datp, datp, "z", z_in
	ENDIF

	give_datp, datp

finished:
	PRINT,'input: workspace data read from '+in_file

	RETURN, w_in
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION input_quartz, numor=numor, temp=temp, nm, tm

;Read a quartz flipping ratio file 'quartz_<numor>_<temp>.dat' and loads it
;into desired workspace
;
;ARGUMENTS:
; numor	: numor corresponding to quatzfile of interest
; temp	: temperature parameter of corrected quartzfile (see quartz.pro)
; (nm and tm are obsolete, kept for backwards compatability)
;
;COMMAND SYNTAX:
; w1=input_quartz(numor=<numor>[,temp=<temp>])
; (optional arguments shown in square brackets)
;
;							KHA,JRS 14/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start input_quartz:'

	take_datp, datp

	IF(N_ELEMENTS(nm) GT 0) THEN numor=nm
	IF(N_ELEMENTS(tm) GT 0) THEN temp=tm
;-------------------------------------------------------------------------------
;Open and read from input file

	IF (N_ELEMENTS(TEMP) GT 0) THEN BEGIN
		in_file='quartz_'+STRTRIM(numor,2)+'_'+STRTRIM(temp,2)+'.dat'
	ENDIF ELSE BEGIN
		in_file='quartz_'+STRTRIM(numor,2)+'.dat'
	ENDELSE	
	line=' '
	ispec=0	& iangle=0
	flip=0.	& dflip=0.	& test=0.
	buf=FLTARR(4,32)
	IF (iprint GT 0) THEN PRINT,'Opening input file'
	OPENR, 1, in_file, ERROR=err	& IF (err NE 0) THEN BEGIN
		PRINT, !ERR_STRING
		GOTO, finished
	ENDIF
	READF, 1, line	& READF, 1, line	& READF, 1, line
	line=line+' -1'
	READS, line, ispec, iangle, flip, dflip, test
	IF (FIX(test) EQ -1) THEN xyz=0 ELSE xyz=1

	datp.x_tit='Spectrum Number'
	IF (xyz EQ 0) THEN BEGIN
		buf=FLTARR(4,32)
		w_in=FLTARR(32)
		datp.y_tit='Flipping Ratio'
	ENDIF ELSE BEGIN
		buf=FLTARR(8,32)
		w_in=FLTARR(32,3)
		y_in=INDGEN(3)
		datp.y_tit='Phase'
		datp.z_tit='Flipping Ratio'
	ENDELSE
	x_in=FLTARR(32)
	e_in=w_in

	POINT_LUN, 1, 0
	READF, 1, line	& datp.w_tit=line	& READF, 1, line
	READF, 1, buf
	CLOSE, 1

	x_in(*)=buf(0,*)
	w_in(*,0)=buf(2,*)	& e_in(*,0)=buf(3,*)
	IF (xyz EQ 1) THEN BEGIN
		w_in(*,1)=buf(4,*)	& e_in(*,1)=buf(5,*)
		w_in(*,2)=buf(6,*)	& e_in(*,2)=buf(7,*)
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of "Read from input file" section'

;-------------------------------------------------------------------------------
;Return and exit

	mod_datp, datp, "x", x_in
	IF (xyz EQ 1) THEN mod_datp, datp, "y", y_in
	mod_datp, datp, "e", e_in

	give_datp, datp

finished:
	IF (iprint GT 0) THEN PRINT,'End input_quartz:'

	RETURN, w_in
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION input_vanadium, numor=numor, number=number, angle=angle,$
		 nspectra=nsp, nm, nix, np

;Reads the vanadium file 'vanadium_<numor>.dat', and puts it into a 
;1-D workspace.  Also reads in multiple numors (e.g. numor=[47324,47336]) and 
;puts them into a 2-d workspace.
; 
;ARGUMENTS:
; numor		:numor(s) corresponding to vanadium file(s) to be read in
; nspectra	:number of spectra to read in from file
; (nix and np are obsolete, kept for backwards compatability)
;
;KEYWORDS:
; /number	:x-axis is spectrum number (default)
; /angle	:x-axis is scattering angle
;
;COMMAND SYNTAX:
; w1=input_vanadium(<numor>[,nspectra=<nspectra>][,/number][,/angle])
; (optional keywords/arguments are shown in square brackets)
;
;							KHA,JRS  30/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start input_vanadium:'

	take_datp, datp
	
	ix=0
	IF(N_ELEMENTS(nm) GT 0) THEN numor=nm
	IF(N_ELEMENTS(nix) GT 0) THEN ix=nix
	IF(N_ELEMENTS(np) GT 0) THEN nsp=np
	IF KEYWORD_SET(number) THEN ix=0
	IF KEYWORD_SET(angle) THEN ix=1

;-------------------------------------------------------------------------------
;Open and read from input file

	IF (N_ELEMENTS(ix) EQ 0) THEN ix=0
	IF (N_ELEMENTS(nsp) EQ 0) THEN nsp=32

	nruns=1
	IF(N_ELEMENTS(numor) GT 0) THEN BEGIN
		IF(N_ELEMENTS(numor) EQ 2) THEN BEGIN
			nruns=numor(1)-numor(0)+1
			nm=LONARR(nruns)
			FOR i=0,nruns-1 DO nm(i)=numor(0)+i
			numor=nm
		ENDIF ELSE BEGIN
			nruns=N_ELEMENTS(numor)
		ENDELSE
	ENDIF

	x_out=FLTARR(nsp)
	w_out=FLTARR(nsp,nruns)	& e_out=w_out & y_out=w_out
	
	FOR irun=0,nruns-1 DO BEGIN
		in_file='vanadium_'+STRTRIM(numor(irun),2)+'.dat'
		line=' '
		buf=FLTARR(4,nsp)
		IF (iprint GT 0) THEN PRINT,'Opening input file ',in_file
		OPENR, 1, in_file, ERROR=err	& IF (err NE 0) THEN BEGIN
			PRINT, !ERR_STRING
			GOTO, finished
		ENDIF
		READF, 1, line	& READF, 1, line
		READF, 1, buf
		CLOSE, 1

		IF(irun EQ 0) THEN x_out(*)=buf(ix,*)
		y_out(*,irun)=buf(ix,*)	& w_out(*,irun)=buf(2,*) & e_out(*,irun)=buf(3,*)
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of "Read from input file" section'

;-------------------------------------------------------------------------------
;Return and exit

	datp.x_tit='Spectrum Number'
	IF(ix EQ 1) THEN datp.x_tit='2-theta (degrees)'
	
	IF(nruns EQ 1) THEN datp.y_tit='Vanadium Integral' ELSE $
		datp.z_tit='Vanadium Integral'

	IF(nruns EQ 1) THEN nums='#'+STRTRIM(STRING(numor(0)),2) ELSE $
		nums='#'+STRTRIM(STRING(numor(0)),2)+':'+STRTRIM(STRING(numor(nruns-1)),2)

	datp.w_tit='Vanadium Intensities from '+nums	

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out
	mod_datp, datp, "y", y_out

	give_datp, datp

finished:
	IF (iprint GT 0) THEN PRINT,'End input_vanadium:'

	RETURN, w_out
	END
function inx_in, INST , PATH , FILENAME , STATUS , DATP
;
; Read INX files
stat=0 & catch,stat
if stat ne 0 then begin catch,/cancel & print,string(7b),!err_string & return,1 & endif
;	code 11 for open error
        if n_elements(datp) gt 0 then full_call=1 $
	else full_call=0
        if   full_call eq 0 then in_file=inst $
	else in_file=filename

	w_out  =11
	e_out  =0
	status =11
        on_ioerror, no_f
        openr,in,in_file,/get_lun
		w_out  =14
		nzone  =intarr(6)
        	nchans =0 & nlines=0
		tit_in =' '
		tmp_ang=0.0
        	p_out  =fltarr(31)
		einc   =0.0 & qinc=0.0 & temp=0.0 & amass=0.0 & isym=0
		deltaen=0.0 & deltatau=0.0 & deltak=0.0
	
       		on_ioerror, end_f
		   i=0
		   
		   while (1) do begin
			readf,in,nlines,nzone,nchans
			readf,in,tit_in
			readf,in,tmp_ang,einc,qinc,temp,amass,isym
			readf,in,deltaen,deltatau,deltak
			tmp=fltarr(3,nchans)
			readf,in,tmp,format='(5x,f10.5,e13.5,e12.4)'
			if i eq 0 then x_buf=tmp(0,*) $
			  	  else x_buf=[[x_buf],[tmp(0,*)]]
 			if i eq 0 then w_out=tmp(1,*) $
			  	  else w_out=[[w_out],[tmp(1,*)]]
 			if i eq 0 then e_out=tmp(2,*) $
			  	  else e_out=[[e_out],[tmp(2,*)]]
			if i eq 0 then y_buf=[tmp_ang] $
			  	  else y_buf=[[y_buf],[tmp_ang]]
			i=i+1
		   endwhile
 		end_f: free_lun,in

		if (i gt 0) and (nchans gt 1) then begin

		w_out=reform(reform(w_out,nchans,i))
		e_out=reform(reform(e_out,nchans,i))
		x_buf=reform(reform(x_buf,nchans,i))
		y_buf=reform(y_buf,i)
		
		if x_buf(0) gt x_buf(1)  then x_buf=-x_buf
		if (size(x_buf))(0) eq 2 then begin
					 y_buf=transpose([[y_buf],[y_buf]])
					 y_buf=congrid  (  y_buf ,nchans,i)
		endif

		status=9
         	datp={x:x_buf,y:y_buf,p:fltarr(31), $
		      e:e_out,w_tit:' ',x_tit:' ',y_tit:' ',$
     		      par_txt:strarr(31),other_tit:' '}

		datp.p(8)  =tmp_ang
		datp.p(11) =temp
		datp.p(15) =amass
		datp.p(16) =1				;data read by inx_in
		datp.p(17) =1				;scale=eV
		datp.p(18) =deltatau			;channel width
		datp.p(19) =nchans
		datp.p(30) =i
		datp.p(21) =sqrt(81.799/einc)
		datp.par_txt(8)= 'Sample Angle (deg.)                 '
		datp.par_txt(11)='Sample Temperature (K)              '
		datp.par_txt(15)='Sample Mass                         '
		datp.par_txt(16)='Energy Conversion                   '
		datp.par_txt(17)='Energy Scale                        '
		datp.par_txt(18)='Channel width                       '
 		datp.par_txt(19)='Number of channels used             '
		datp.par_txt(30)='Number of angles                    '
		datp.par_txt(21)='Wavelength (angstroms)              '
		datp.w_tit= tit_in
		datp.x_tit='Energy Transfer'
		datp.y_tit='Angle'
		datp.other_tit='INX file: '+in_file

		if (datp.p(21) gt 1.) then status=0

		endif
 no_f:
        
if full_call eq 0 then give_datp,datp 
return,w_out
end
pro inx_event, event,uv
;** *********
;**
@lamp.cbk
common c_inx,inx_base,iws,iwv,iwe,iwc,iwr,its,itv,islab,ilo,ith0,ith1,ith2,ialph,ires,ibgmod

if uv(2) eq 1 then begin

   on_ioerror,mis
   text='? Bad workspace number... '
   widget_control,bad_id=i,uv(3) ,get_value=str & str=strlowcase (str(0))
	  iws   =strmid(str,strpos(str,'w')+1,10)  & nws=fix(strtrim(iws   ,2))
   widget_control,bad_id=i,uv(5) ,get_value=str & str=strlowcase (str(0))
	  iwe   =strmid(str,strpos(str,'w')+1,10)  & nwe=fix(strtrim(iwe   ,2))
   widget_control,bad_id=i,uv(6) ,get_value=str & str=strlowcase (str(0))
	  iwr   =strmid(str,strpos(str,'w')+1,10)  & nwr=fix(strtrim(iwr   ,2))
   widget_control,bad_id=i,uv(7) ,get_value=str & str=strlowcase (str(0))
	  iwv(0)=strmid(str,strpos(str,'w')+1,10)  & nwv=fix(strtrim(iwv(0),2))
   widget_control,bad_id=i,uv(15),get_value=str & str=strlowcase (str(0))
	  iwv(1)=strmid(str,strpos(str,'w')+1,10)  & nwd=fix(strtrim(iwv(1),2))
   widget_control,bad_id=i,uv(11),get_value=str & str=strlowcase (str(0))
	  iwc   =strmid(str,strpos(str,'w')+1,10)  & nwc=fix(strtrim(iwc   ,2))
   
   text='? Bad transmission value... '
   widget_control,bad_id=i,uv(4) ,get_value=str & str=str(0) & nts=float(str) 	  & its=str
   widget_control,bad_id=i,uv(8) ,get_value=str & str=str(0) & ntv=float(str) 	  & itv=str

   text='? Bad discrimination factor... '
   widget_control,bad_id=i,uv(10),get_value=str & str=str(0) & nlo=float(str)/100 & ilo=str

   text='? Bad slab angle... ' & nalph=0
   if islab gt 0 then begin widget_control,bad_id=i,uv(14),get_value=str & str=str(0)
			    nalph=float(str) & ialph=strcompress(str) & endif

   text=''
   on_ioerror,norange & n=-400 & nth1=n & nth2=n
   widget_control,bad_id=i,uv(12),get_value=str & str=str(0) & nth1=float(str)    & ith1=strcompress(str)
   widget_control,bad_id=i,uv(13),get_value=str & str=str(0) & nth2=float(str)    & ith2=strcompress(str)
   str=''
   norange:if (nth1 eq n) or (nth2 eq n) or (nth1 ge nth2)  then  begin
   			if ith0 eq 1 then text='? Bad angle range values...'
   			nth1=0 & nth2=0
   	   endif else   if ith0 eq 0 then begin nth1=0 & nth2=0 & endif
   
   if (nws gt 20) or (nwe gt 20) or  (nwr gt 20) or (nwd gt 20) or $
   		     (nwv gt 20) or  (nwc gt 20) then text='? Workspace gt 20... '
   if (nwr le 0 ) then  text='? Resulting workspace must be specified... '
   if (nws le 0 ) then  text='? Sample workspace must be specified... '
   mis:
   if text ne ''  then  widget_control,bad_id=i,uv(9),set_value=text+str  $
   else begin
  	widget_control,bad_id=i,uv(9),set_value='Working ...'
	ibgm=ibgmod(0)+ibgmod(1)*2+ibgmod(2)*4+ibgmod(3)*8
   	wk=[nwr,nws,nwv,nwe,nwc,nwd]     	 	 & wks= strtrim(string(wk),2)
   	rt=[nts,ntv,islab,nlo,nth1,nth2,ires,ibgm,nalph] & rtp= strtrim(string(rt),2)
   	
   	text='w'+wks(0)+'=didline (samp='+wks(1)+',vana='+wks(2)+',empty='+wks(3)+',canva='+wks(4)+ $
   				 ',cadm='+wks(5)+',trans_abs=['+rtp(0)+','+rtp(1)+','+rtp(2)+','+rtp(3)+ $
   				 	    ','+rtp(4)+','+rtp(5)+','+rtp(6)+','+rtp(7)+','+rtp(8)+'])'
   	XICUTE,text
	to_don_history,-1,0,'w'+wks(0)+'=didline(w'+wks(1)+')'
  	widget_control,bad_id=i,event.top,/destroy
   endelse
   
endif
if uv(2) eq 2 then islab  = uv(3)
if uv(2) eq 3 then ith0   = event.select
if uv(2) eq 4 then ires   = event.select
if uv(2) eq 5 then ibgmod(uv(3)) = event.select

return
end

pro inx ,o,t
;** ***
;**
@lamp.cbk
common c_inx

i=xregistered('Inx')
if i le 0 then begin

if n_elements(iws) eq 0 then begin
   iws=' 0  '  & iwv=[' 0  ',' 0  ']   & iwe=' 0  ' & iwc=' 0  ' & iwr=' 0  '    & ires=0  & ialph='      '
   its=' 0.90' & itv=' 0.85' & islab=0 & ilo='15.'  & ith0=0     & ith1='      ' & ith2 ='      '
   ibgmod=intarr(4) & ibgmod(0)=1
endif

if n_elements(o) eq 1 then begin iws=strtrim(string(t),2) & iwr=strtrim(string(o),2) & endif
if lamp_siz ge  900 then p_set_font,1
if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

inx_base =widget_base  (title='Lamp parameters for DIDLINE',/column,resource_name='lamp')

base =widget_base  (inx_base,/column,resource_name='mic')
bsamp=widget_base  (base  ,/row)
blab =widget_label (bsamp ,value='Sample workspace'  	 ,font=ft_b_bigger)
bsamw=widget_text  (bsamp ,value=iws    ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bsamp ,value='Transmission'      	 ,font=ft_b_bigger)
bsamt=widget_text  (bsamp ,value=its    ,/editable   	 ,font=ft_propor  ,xsize=8,ysize=1)

bempt=widget_base  (base  ,/row)
blab =widget_label (bempt ,value='Empty-C workspace'	 ,font=ft_b_bigger)
bempw=widget_text  (bempt ,value=iwe    ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bempt ,value='Transmission 0.97'     ,font=ft_b_bigger)

bvana=widget_base  (base  ,/row)
blab =widget_label (bvana ,value='Vanadium workspace'	 ,font=ft_b_bigger)
bvanw=widget_text  (bvana ,value=iwv(0) ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bvana ,value='Transmission'      	 ,font=ft_b_bigger)
bvant=widget_text  (bvana ,value=itv    ,/editable   	 ,font=ft_propor  ,xsize=8,ysize=1)

bvaca=widget_base  (base  ,/row)
blab =widget_label (bvaca ,value='Empty-Van workspace'	 ,font=ft_b_bigger)
bvanc=widget_text  (bvaca ,value=iwc    ,/editable    	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bvaca ,value='Transmission 0.97'     ,font=ft_b_bigger)

bresu=widget_base  (base  ,/row)
blab =widget_label (bresu ,value='RESULTING..workspace'  ,font=ft_b_bigger)
bresw=widget_text  (bresu ,value=iwr    ,/editable       ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bresu ,value='(Cadmium wks'          ,font=ft_b_bigger)
bcadm=widget_text  (bresu ,value=iwv(1) ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bresu ,value=')'                     ,font=ft_b_bigger)

;blab =widget_label (base  ,value='.......'		 ,font=ft_propor)

base =widget_base  (inx_base,/column,resource_name='did')
bslab=widget_base  (base  ,/row)
blab =widget_label (bslab ,value='Self-absorption'   	 ,font=ft_b_bigger)
btog =widget_base  (bslab ,/column,/exclusive)
ntog =4
btg  =lonarr(ntog)
blab =['None','Single slab','Full cylinder','Hollow cylinder']
for i=0,ntog-1 do btg(i)=widget_button(btog  ,value=blab(i),font=ft_propor,/no_release,$
					     uvalue=[-88,341,2,i])
bslab=widget_base  (bslab ,/column)
blab =widget_label (bslab ,value='Angle:',font=ft_b_bigger)
balph=widget_text  (bslab ,value= ialph  ,/editable   ,font=ft_propor  ,xsize=6,ysize=1)

;blab =widget_label (base  ,value='...............'    ,font=ft_propor)

base =widget_base  (inx_base,/column,resource_name='don')
btlow=widget_base  (base  ,/row)
blab =widget_label (btlow ,value='Discrimination spectrum factor (%)' ,font=ft_b_bigger)
bdisc=widget_text  (btlow ,value=ilo    ,/editable   ,font=ft_propor  ,xsize=4+cap,ysize=1)

bteta=widget_base  (base  ,/row)
btete=widget_base  (bteta ,/nonexclusive)
btetb=widget_button(btete ,value='Use 2*Theta range from' ,font=ft_b_bigger,uvalue=[-88,341,3])
btet1=widget_text  (bteta ,value=ith1,/editable   ,font=ft_propor  ,xsize=6+cap,ysize=1)
blab =widget_label (bteta ,value='to',font=ft_b_bigger)
btet2=widget_text  (bteta ,value=ith2,/editable   ,font=ft_propor  ,xsize=6+cap,ysize=1)

;blab =widget_label (base  ,value='.....................'	   ,font=ft_propor)

base =widget_base  (inx_base,/column,resource_name='ben')
baso =widget_base  (base    ,/row)
bid  =widget_label (baso    ,value="Align from: ",font=ft_b_bigger)
bbgmo=widget_base  (baso    ,/row,/nonexclusive)
bbgm1=widget_button(bbgmo   ,value='vana'      ,font=ft_b_normal,uvalue=[-88,341,5,0])
bbgm2=widget_button(bbgmo   ,value='sample'    ,font=ft_b_normal,uvalue=[-88,341,5,1])
bbgm3=widget_button(bbgmo   ,value='empty'     ,font=ft_b_normal,uvalue=[-88,341,5,2])
bbgm4=widget_button(bbgmo   ,value='empty_v'   ,font=ft_b_normal,uvalue=[-88,341,5,3])

breso=widget_base  (base  ,/row,/nonexclusive)
bresb=widget_button(breso ,value='Use vana as instrument resolution' ,font=ft_b_bigger,$
			  uvalue=[-88,341,4])

berr =widget_label (base  ,value='____________________________________________',font=ft_propor)

uv   =[-88,341,1,bsamw,bsamt,bempw,bresw,bvanw,bvant,berr,bdisc,bvanc,btet1,btet2,balph,bcadm]
bgo  =widget_button(base  ,value='NEXT STEP' ,uvalue=uv,font=ft_b_bigger)
bexit=widget_button(base  ,value='CANCEL'    ,uvalue=[-88,399])

widget_control , btg(islab),set_button=1
widget_control , btetb     ,set_button=ith0
widget_control , bresb     ,set_button=ires
widget_control , bbgm1     ,set_button=ibgmod(0)
widget_control , bbgm2     ,set_button=ibgmod(1)
widget_control , bbgm3     ,set_button=ibgmod(2)
widget_control , bbgm4     ,set_button=ibgmod(3)
widget_control , btg(2)    ,sensitive =0
widget_control , btg(3)    ,sensitive =0
widget_control , bresb     ,sensitive =0
widget_control , inx_base  ,group_leader=lamp_b1,/realize
if lamp_siz ge 900 then p_set_font,0

XMANAGER, 'Inx', inx_base  ,event_handler='LAMP_EVENT_PARSER',/just_reg

endif else widget_control,bad_id=i,inx_base,map=1

return
end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION isotropic_ms, w_in0, roh=roh, muR=muR, abs_xs=sigmaa, $
		 nuc_xs=sigmanuc, inc_xs=sigmasi, mag_xs=sigmamag
;
; Takes background subtracted D7 data of 1, 2 or 6 phases and corrects for
; multiple scattering using the isotropic approximation of Wells and Cywinski,
; and the secondary scattering coefficients of Blech and Averbach.  At present,
; deals only with cylindrical samples.  Correction of TOF data not yet implemented. 
;
; References
; ----------
; P. Wells and R. Cywinski, Aust. J. Phys. 34 (1981) 193
; T. M. Harders, T. J. Hicks and P. Wells, J. Appl. Cryst. 18 (1985) 131
; J. Mayers and R. Cywinski, Nucl. Inst. Meth. Phys. Res. A241 (1985) 519
; I. A. Blech and B. L. Averbach, Phys. Rev. 137 (1965) A1113
;
;ARGUMENTS:
; roh	: R/h - radius of cylinder over height
; muR	: Nsigmat*R calculated from transmission measurements
; abs_xs: Absorption Cross-section (actual) in barns
; nuc_xs: Nuclear Cross-section in barns
; inc_xs: Spin-Incoherent cross-section in barns
; mag_xs: Magnetic cross-section in barns (optional)
;
;DIMENSIONS
; w_in = w_out(nspectra,nphases,nruns) - unless nruns=1
;
;COMMAND SYNTAX:
; w6=isotropic_ms(w5,roh=<roh>,muR=<muR>,abs_xs=<abs_xs>,nuc_xs=<nuc_xs>,inc_xs=<inc_xs>[,mag_xs=<mag_xs>])
;
; (optional arguments shown in square brackets)
;
;							JRS 18/4/02
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint = 0	; if iprint > 0, show debugging messages
	
	COMMON c_lamp
	IF iprint GT 0 THEN PRINT,'Start isotropic_ms:'	

	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	sw = SIZE(w_in0)
	IF iprint GT 0 THEN PRINT,'SIZE(w_in0)=',sw

	par = datp.p
	nspectra = FIX(par(1))
	nphases = FIX(par(2))
	nruns = FIX(par(3))
	TOF = FIX(par(8))
	nchannels = FIX(par(6))
	chw = par(7)

	IF nruns EQ 1 THEN x_in = datp.x ELSE x_in = datp.z
	y_in = datp.y
	e_in0 = datp.e
	se = SIZE(e_in0)
	IF (se(0) NE sw(0)) OR (se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in0)=',sw
		PRINT,'        SIZE(e_in0)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	IF (TOF EQ 0) THEN BEGIN
		w_in = w_in0
		e_in = e_in0
	ENDIF ELSE BEGIN
		w_in = REFORM(w_in0,nchannels,nspectra,nphases)
		e_in = REFORM(e_in0,nchannels,nspectra,nphases)
	ENDELSE

	IF iprint GT 0 THEN BEGIN
		PRINT,'TOF       =',TOF
		PRINT,'nspectra  =',nspectra
		PRINT,'nphases   =',nphases
		PRINT,'nchannels =',nchannels
		PRINT,'nruns     =',nruns
	ENDIF
        IF (N_ELEMENTS(roh) EQ 0) OR (N_ELEMENTS(muR) EQ 0) OR (N_ELEMENTS(sigmaa) EQ 0) OR $
	   (N_ELEMENTS(sigmanuc) EQ 0) OR (N_ELEMENTS(sigmasi) EQ 0) THEN BEGIN
		PRINT,'Isotropic_ms: Error -  All parameters must be specified'
		GOTO, finished
	ENDIF
	IF N_ELEMENTS(sigmamag) EQ 0 THEN BEGIN 
		PRINT,'Isotropic ms: Assuming zero magnetic cross-section'
		sigmamag=0.0
	ENDIF
	IF (muR LT 0.1) OR (muR GT 0.9) THEN BEGIN
		PRINT,'muR= ',muR,'  No value of delta tabulted for muR= ', muR
		GOTO, finished
	ENDIF 

	IF iprint GT 0 THEN PRINT,'End of "w_in dimensions check etc." section'

;----------------------------------------------------------------------------
; Open blech.dat and read appeopriate delta

	line=''
	delarray = FLTARR(10,18)
        ba_file=FILEPATH('blech.dat',ROOT_DIR=lamp_macro+'/D7')

	IF (iprint GT 0) THEN PRINT,'Opening blech.dat'
	OPENR, 1, ba_file, ERROR=err
	IF (err NE 0) THEN PRINT, !ERR_STRING
	FOR i = 1,5 DO READF, 1, line
	READF, 1, delarray
	CLOSE, 1
	
	del=FLTARR(1)
        FOR i=0,16 DO BEGIN
		IF (delarray(0,i) LE roh) AND (delarray(0,i+1) GT roh) THEN BEGIN
			IF(muR EQ 0.9) THEN j=FLOOR(muR*10.)-1 ELSE j=FLOOR(muR*10.)
			del1=FLTARR(2)
			delx1=[0.1*j,(0.1*j)+0.1]
			del1(0)=INTERPOL(delarray(j,*),delarray(0,*),roh)
			del1(1)=INTERPOL(delarray(j+1,*),delarray(0,*),roh)	
			del=INTERPOL(del1,delx1,muR)
		ENDIF ELSE BEGIN
			IF((i EQ 16 AND del(0) EQ 0) OR (i EQ 16 AND del(0) EQ -1.)) THEN BEGIN
				PRINT,' Isotropic_ms: no value of Delta tabulated for:'
				PRINT,' R/h =',roh
				PRINT,' muR =',mur
				GOTO, finished
			ENDIF
		ENDELSE
	ENDFOR
	PRINT, 'Isotropic_ms: Delta from B-A table =', del

	IF (iprint GT 0) THEN PRINT,'End of "read from Blech-Averbach Table" section'
;------------------------------------------------------------------------------
; Do multiple scattering correction

        zeroed=WHERE(e_in(*,0,0) LT -0.9)
	irun=INDGEN(nruns)
	iphase=INDGEN(nphases)

	CASE nphases OF

	1: BEGIN
	   PRINT, 'Multiple scattering correction for unpolarized neutrons'

	   IF (TOF EQ 0) THEN BEGIN
		sigmas=sigmanuc+simgasi+sigmamag
		IF (iprint GT 0) THEN PRINT, 'SigmaS =', sigmas, ' barns/atom'

		capdelta = del(0)*(sigmas/(sigmas+sigmaa))
		w_out = w_in*(1 - capdelta)
		e_out = e_in*(1 - capdelta)

	   ENDIF ELSE BEGIN
		PRINT, 'Isotropic_ms: TOF option not yet implemented'
	   ENDELSE			
	   END
	2: BEGIN
	   PRINT, 'Multiple scattering correction for z-polarization analysis'

	   IF (TOF EQ 0) THEN BEGIN
		sigmansf = sigmanuc + 0.3333*sigmasi + 0.5*sigmamag
		sigmasf  = 0.66667*sigmasi + 0.5*sigmamag
		sigmas   = sigmansf + sigmasf
		IF (iprint GT 0) THEN BEGIN
			PRINT, 'SigmaS   =', sigmas, ' barns/atom'
			PRINT, 'SigmaNSF =', sigmansf, ' barns/atom'
			PRINT, 'SigmaSF  =', sigmasf, ' barns/atom'
		ENDIF

		alpha  = del(0)*(sigmasf/(sigmas + sigmaa))
		beta   = del(0)*(sigmansf/(sigmas + sigmaa))
		w_out=w_in & e_out=e_in
		inv=REVERSE(iphase)
		w_out(*,iphase,irun) = (1-beta)*w_in(*,iphase,irun)-alpha*w_in(*,inv,irun)
		e_out(*,iphase,irun) = SQRT(((1-beta)*e_in(*,iphase,irun))^2+(alpha*e_in(*,inv,irun))^2)

	   ENDIF ELSE BEGIN
		PRINT, 'Isotropic_ms: TOF option not yet implemented'
	   ENDELSE			
	   END
	6: BEGIN
	   PRINT, 'Multiple scattering correction for xyz-polarization analysis'

	   IF (TOF EQ 0) THEN BEGIN

; these are the Schaerpf equations, averaged over alpha between 0 and pi/2
; so that isotropic approximation may be used.

		sigma = FLTARR(nphases)
		sigma(0) = sigmanuc + 0.3333*sigmasi + 0.5*sigmamag
		sigma(1)  = 0.66667*sigmasi + 0.5*sigmamag
		sigma(2) = sigmanuc + 0.3333*sigmasi + 0.25*sigmamag
		sigma(3)  = 0.66667*sigmasi + 0.75*sigmamag
		sigma(4) = sigmanuc + 0.3333*sigmasi + 0.25*sigmamag
		sigma(5)  = 0.66667*sigmasi + 0.75*sigmamag

		IF (iprint GT 0) THEN BEGIN
			PRINT, 'SigmaZNSF =', sigma(0), ' barns/atom'
			PRINT, 'SigmaZSF  =', sigma(1), ' barns/atom'
			PRINT, 'SigmaXNSF =', sigma(2), ' barns/atom'
			PRINT, 'SigmaXSF  =', sigma(3), ' barns/atom'
			PRINT, 'SigmaYNSF =', sigma(4), ' barns/atom'
			PRINT, 'SigmaYSF  =', sigma(5), ' barns/atom'
		ENDIF
		alp = del(0)*(sigma/(sigma(0)+sigma(1)+sigmaa))
		alpha = w_in
		FOR i = 0,5 DO alpha(*,i,*) = alp(i)

		w_out=w_in & e_out=e_in
		inv=[1,0,3,2,5,4]
		a = [0,0,2,2,4,4]
		b = [1,1,3,3,5,5]
		w_out(*,iphase,irun) = (1-alpha(*,a,irun))*w_in(*,iphase,irun)-alpha(*,b,irun)*w_in(*,inv,irun)
		e_out(*,iphase,irun) = SQRT(((1-alpha(*,a,irun))*e_in(*,iphase,irun))^2+(alpha(*,b,irun)*e_in(*,inv,irun))^2)

	   ENDIF ELSE BEGIN
		PRINT, 'Isotropic_ms: TOF option not yet implemented'
	   ENDELSE
	   END
	ENDCASE

	IF (iprint GT 0) THEN BEGIN
		PRINT,''
		PRINT,'Output for comparison with MSCATT'
		R=w_out/w_in
		angle=x_in
		tarr=FLTARR(nspectra,nphases,nruns)
		a=1.7133			; a1
		b=-0.0368			; b1
		c=-0.0927			; a2
		d=-0.375			; b2
		x_hew=angle*!pi/180.		;convert deg to rad
		t0=EXP(-(a+b*sin(0./2)^2)*muR-(c+d*sin(0./2)^2)*muR^2)
		PRINT,'Transmission of Straight through beam =',t0,'%'
		FOR ispec = 0,nspectra-1 DO BEGIN
			tarr(ispec,*,*)=EXP(-(a+b*sin(x_hew(ispec)/2)^2)*muR-(c+d*sin(x_hew(ispec)/2)^2)*muR^2)
		ENDFOR
		R=R/tarr
		FOR irun=0, nruns-1 DO BEGIN
			CASE nphases OF
			1: BEGIN
			   PRINT,'    ispec      angle       R'
			   FOR i=0,31 DO PRINT, i+1, angle(i,irun), R(i,*,irun)
			   END
			2: BEGIN
			   PRINT,'    ispec      angle       Rnf          Rfl'
			   FOR i=0,31 DO PRINT, 2*(i+1), angle(i,irun), R(i,0,irun), R(i,1,irun)
			   END
			6: BEGIN			
			   PRINT,'    ispec      angle       R(X)nf       R(X)fl   ', $
				 '    R(Y)nf       R(Y)fl       R(Z)nf       R(Z)fl'
			   FOR i=0,31 DO PRINT, 2*(i+1), angle(i,irun), R(i,2,irun),R(i,3,irun),$
					R(i,4,irun),R(i,5,irun),R(i,0,irun),R(i,1,irun)
			   END
			ENDCASE
		ENDFOR
	ENDIF
				
;-------------------------------------------------------------------------------
;rezero the zeroed detectors

	IF (N_ELEMENTS(zeroed) GT 1) THEN BEGIN
		irun = INDGEN(nruns)
		e_out(zeroed,*,irun)=-1.
		w_out(zeroed,*,irun)=0.
	ENDIF

;----------------------------------------------------------------------------------------
; Return Paramters and exit
	
	datp.e = e_out
	param = [roh,muR,sigmaa,sigmanuc,sigmasi,sigmamag]
	parstr = STRTRIM(STRING(param),2)
	pos00 = STRPOS(parstr,'00')
	FOR i=0, 5 DO BEGIN
		IF(pos00(i) NE -1) THEN parstr(i) = STRMID(parstr(i),0,pos00(i))
		last = STRLEN(parstr(i))
		IF(STRPOS(parstr(i),'.') EQ last - 1) THEN parstr(i) = parstr(i)+'0'
		IF(STRPOS(parstr(i),'0') EQ last - 1) THEN parstr(i) = STRMID(parstr(i),0,last-1)
	ENDFOR

	rohs = 'roh='+parstr(0)
	muRs = 'muR='+parstr(1)
	sigmaas = 'abs='+parstr(2)
	sigmanucs = 'nuc='+parstr(3)
	sigmasis = 'si='+parstr(4)
	sigmamags = 'mag='+parstr(5)
	datp.other_tit=datp.other_tit+' -im('+rohs $
		+','+muRs+','+sigmaas+','+sigmanucs $
		+','+sigmasis+','+sigmamags+')'
finished:
	IF (iprint GT 0) THEN PRINT,'End Isotropic_ms:'

	give_datp, datp

	RETURN, w_out
	END
	FUNCTION l2e, w_in

;converts from cts/lambda to cts/energy
;
; input=output format: w(128,nspectra)
;							KHA, 30/10/96


	take_datp, datp

	sw=SIZE(w_in)
	PRINT,'SIZE(w_in)=',sw
	IF (sw(0) EQ 1) THEN nspectra=1 $
			ELSE nspectra=sw(2)
	nchannels=sw(1)

	PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	x_in=datp.x
	e_in=datp.e

	const1=5.22697		; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571	; E(meV)=const2*Q(A^-1)^2 for neutron
	const3=3.956076		; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066		; E(meV)=const4/lambda(A)^2 for neutron

	x_out=const4/x_in^2

	x_out=REVERSE(x_out)
	w_out=REVERSE(w_in,1)
	e_out=REVERSE(e_in,1)

	datp.x=x_out
	datp.x_tit='Neutron Energy (meV)'
	datp.e=e_out

	give_datp, datp

	RETURN, w_out
	END
function logoidl,ab
;******* *******
;**
blnc=255B & noir=4B & vert=60B & viol=200B & jaun=85
a   = long(ab)  & b=long(ab)
w   = bytarr(a ,b)+blnc
idx =(indgen(a*(b/2))*2)
w(idx)  =vert
w(*,3)  =blnc & w(*,(b-2)/3+2)=blnc & w(*,(b-2)/3*2+1)=blnc & w(*,b-2)=blnc
w(1,*)  =blnc & w((a-2)/3,*)  =blnc & w((a-2)/3*2-1,*)=blnc & w(a-4,*)=blnc
w(*,b-1)=noir
w(0,*)  =noir
w(*,2)  =noir
w(a-3,*)=noir
w(*,0)  =0  & w(5:*,0)    =noir+35
w(*,1)  =0  & w(5:*,1)    =noir+35
w(a-1,*)=0  & w(a-1,0:b-6)=noir+35
w(a-2,*)=0  & w(a-2,0:b-6)=noir+35
w( 2       :(a-2)/3-1   ,  4         :(b-2)/3+1)=jaun
w((a-2)/3+1:(a-2)/3*2-2 , (b-2)/3*2+2: b-3)     =jaun
w((a-2)/3*2:(a-5)       , (b-2)/3+3  :(b-2)/3*2)=jaun
return,w
end

pro lampico, cocone, ldi=ldi
;**********
;**
if n_elements(ldi) eq 1 then cocone=logoidl(ldi) $
else begin
 cocone=[ $
 145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,144,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,140,132,136,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,137,128,130,125,128,136,144,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,141,139,128,129,125,128,124,126,122,128,138,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,142,130,127,131,125,127,124,125,122,123,118,116,118,131,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,142,132,127,127,125,129,122,127,120,120,116,115,115,112,118,105,115 ] & cocone=[cocone $
,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,135,130,127,127,125,128,122,127,120,124,116,120,112,112,109,105,105,105 ] & cocone=[cocone $
,100,103,108,119,136,144,143,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,139,128,129,125,128,122,126,122,120,119,116,123,112,118,109,105,105,113,99 ] & cocone=[cocone $
,94,94,94,94,94,94,98,124,128,142,141,145,145,145,145,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,142,137 ] & cocone=[cocone $
,127,129,125,127,124,125,122,123,118,116,115,112,116,109,105,105,102,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,102,105,105,108,112,119,116,118,123,123,128,133,136 ] & cocone=[cocone $
,136,142,140,140,140,140,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,144,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,132,127 ] & cocone=[cocone $
,130,125,129,122,125,120,123,116,121,115,112,118,105,105,105,112,94,94,94 ] & cocone=[cocone $
,94,94,94,94,96,105,105,105,110,112,115,116,119,120,122,124,125,127,129 ] & cocone=[cocone $
,129,130,131,132,133,134,134,135,135,137,140,142,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138,134,127,127 ] & cocone=[cocone $
,125,129,122,127,120,124,116,120,115,112,114,105,105,105,112,94,94,94,94 ] & cocone=[cocone $
,94,94,94,96,105,105,105,110,112,115,116,119,121,122,125,126,128,129,129 ] & cocone=[cocone $
,130,131,133,133,134,134,135,135,135,135,135,142,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,139,127,126,126,125 ] & cocone=[cocone $
,124,122,122,120,119,116,123,112,118,109,105,105,113,99,94,94,94,94,94 ] & cocone=[cocone $
,94,94,102,105,105,106,112,112,116,116,120,121,123,125,126,128,129,130,131 ] & cocone=[cocone $
,131,133,134,134,135,135,135,135,135,136,145,145,145,145,145,145,140,137,140 ] & cocone=[cocone $
,144,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,144,136,127,129,125,128,124 ] & cocone=[cocone $
,125,122,123,116,116,119,112,118,109,105,105,113,99,94,94,94,94,94,94 ] & cocone=[cocone $
,94,102,105,105,106,112,112,116,117,120,121,124,125,127,129,129,130,131,132 ] & cocone=[cocone $
,133,134,134,135,135,135,135,135,137,145,145,145,145,145,145,137,135,135,136 ] & cocone=[cocone $
,135,137,141,144,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,133,127,130,125,127,122,125 ] & cocone=[cocone $
,120,123,116,121,115,112,120,105,105,105,112,94,94,94,94,94,94,94,96 ] & cocone=[cocone $
,102,105,105,110,112,115,116,119,120,122,124,125,127,129,129,130,131,132,133 ] & cocone=[cocone $
,134,134,135,135,135,135,135,140,145,145,145,145,145,144,136,135,135,137,135 ] & cocone=[cocone $
,135,136,134,135,135,144,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,138,133,127,127,125,125,122,127,120 ] & cocone=[cocone $
,126,116,121,115,112,118,105,105,105,112,94,94,94,94,94,94,94,96,105 ] & cocone=[cocone $
,105,105,110,112,115,116,119,120,122,125,126,127,129,129,130,131,133,133,134 ] & cocone=[cocone $
,134,135,135,135,135,135,140,145,145,145,145,145,141,135,135,135,136,135,135 ] & cocone=[cocone $
,136,134,135,133,134,132,134,142,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,140,129,130,126,125,124,122,122,120,119 ] & cocone=[cocone $
,120,130,119,119,113,105,105,113,110,94,94,94,94,94,94,94,96,105,105 ] & cocone=[cocone $
,105,112,112,115,116,120,121,123,125,126,128,129,130,130,131,133,133,134,135 ] & cocone=[cocone $
,135,135,135,135,136,145,145,145,145,145,144,136,135,135,136,135,135,136,134 ] & cocone=[cocone $
,134,135,133,133,131,134,130,132,131,141,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,144,135,128,129,126,128,124,122,122,120,119,126 ] & cocone=[cocone $
,124,104,94,120,115,104,125,99,94,94,94,94,94,94,94,102,105,105,106 ] & cocone=[cocone $
,112,112,116,116,120,121,123,125,126,128,129,130,131,132,133,134,134,135,135 ] & cocone=[cocone $
,135,135,135,136,145,145,145,145,145,141,135,135,135,136,135,135,136,134,134 ] & cocone=[cocone $
,135,133,134,131,133,130,133,129,131,127,131,135,144,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,133,127,131,125,127,122,125,120,123,116,124,122 ] & cocone=[cocone $
,68,62,141,94,94,109,125,110,110,99,104,94,94,94,102,105,105,108,112 ] & cocone=[cocone $
,113,116,118,120,122,124,125,127,129,129,130,131,132,133,134,134,135,135,135 ] & cocone=[cocone $
,135,135,140,145,145,145,145,145,141,135,135,135,137,135,135,136,134,135,133 ] & cocone=[cocone $
,134,132,131,131,130,130,129,128,130,126,125,124,126,128,136,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,138,133,127,129,125,127,122,125,120,123,121,124,106,36 ] & cocone=[cocone $
,62,47,109,109,125,125,109,94,94,94,109,73,94,99,110,105,120,112,115 ] & cocone=[cocone $
,116,119,120,122,125,125,127,129,129,130,131,133,133,134,134,135,135,135,135 ] & cocone=[cocone $
,135,140,145,145,145,145,145,139,135,135,135,137,135,135,136,134,135,133,134 ] & cocone=[cocone $
,132,133,131,132,130,131,127,126,126,128,124,126,122,124,119,122,141,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,141,129,130,127,125,124,122,122,120,124,115,126,94,47,47 ] & cocone=[cocone $
,62,47,94,125,109,94,94,94,109,109,109,109,109,36,110,125,115,114,116 ] & cocone=[cocone $
,119,120,123,125,126,128,129,130,130,131,133,133,134,136,135,135,135,135,136 ] & cocone=[cocone $
,142,145,145,145,145,144,136,135,135,136,137,135,136,134,134,135,133,134,131 ] & cocone=[cocone $
,133,130,132,129,131,127,130,125,127,122,127,120,123,118,121,119,112,116,128 ] & cocone=[cocone $
,144,145,145,145,145,145,145,145,145,145,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,144,138,129,130,126,125,124,122,122,120,119,126,124,84,47,47,62 ] & cocone=[cocone $
,47,62,47,47,73,94,125,109,125,94,125,109,94,81,63,109,94,99,120 ] & cocone=[cocone $
,121,123,125,126,128,129,130,130,131,133,135,137,137,137,134,135,135,135,141 ] & cocone=[cocone $
,144,145,145,145,144,135,135,135,136,135,135,136,134,134,135,133,134,131,131 ] & cocone=[cocone $
,130,133,129,131,127,130,125,129,122,127,120,126,116,121,115,112,118,105,105 ] & cocone=[cocone $
,105,111,119,136,142,145,145,145,145,145,142,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,133,127,131,125,127,124,121,122,124,118,125,122,83,47,47,62,62 ] & cocone=[cocone $
,47,83,94,94,94,73,73,78,62,125,109,94,43,117,21,78,62,120,121 ] & cocone=[cocone $
,123,125,127,129,129,130,131,132,133,137,137,137,136,134,135,137,138,138,138 ] & cocone=[cocone $
,136,145,145,141,135,135,135,135,135,135,136,134,134,134,133,132,131,131,130 ] & cocone=[cocone $
,130,129,128,130,126,125,128,126,127,120,125,116,121,115,112,117,105,105,105 ] & cocone=[cocone $
,110,94,94,94,94,108,125,142,142,143,135,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,138,137,127,130,125,127,122,125,120,123,121,124,112,68,62,47,31,47,57 ] & cocone=[cocone $
,94,94,94,94,94,94,94,95,105,93,66,68,96,79,15,31,68,122,125 ] & cocone=[cocone $
,125,127,129,129,130,131,134,136,136,137,136,135,138,131,138,136,136,137,136 ] & cocone=[cocone $
,145,145,139,135,135,135,137,135,135,136,134,135,133,134,131,133,131,130,130 ] & cocone=[cocone $
,129,128,130,126,128,124,126,122,124,119,116,122,112,118,105,105,105,113,100 ] & cocone=[cocone $
,94,94,94,94,94,94,94,95,105,111,135,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,141 ] & cocone=[cocone $
,129,130,130,125,126,122,127,120,125,121,126,94,47,62,47,47,31,62,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,105,110,112,113,31,15,15,107,128,130 ] & cocone=[cocone $
,131,132,132,130,131,135,136,136,135,134,133,135,129,136,136,134,130,141,134 ] & cocone=[cocone $
,144,139,135,135,135,137,135,135,134,134,135,133,134,131,133,130,132,129,131 ] & cocone=[cocone $
,127,127,126,124,124,125,122,124,118,116,122,112,116,109,105,105,110,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,140,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138,129 ] & cocone=[cocone $
,130,126,125,124,122,122,120,119,126,122,99,47,62,62,47,62,73,94,94 ] & cocone=[cocone $
,94,94,94,94,94,100,105,105,105,112,112,115,69,15,0,31,137,137,135 ] & cocone=[cocone $
,133,134,134,133,135,136,135,133,132,131,127,104,137,135,132,130,126,131,141 ] & cocone=[cocone $
,135,135,135,136,135,135,136,134,134,136,133,134,131,133,130,132,129,131,127 ] & cocone=[cocone $
,130,125,127,122,127,120,126,116,121,112,112,120,105,105,105,110,94,94,94 ] & cocone=[cocone $
,94,94,94,94,94,98,105,105,140,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,130,128,130 ] & cocone=[cocone $
,126,128,124,126,122,124,118,125,122,73,47,47,62,31,47,83,94,94,94 ] & cocone=[cocone $
,94,94,94,94,102,105,105,108,112,113,116,112,5,0,0,94,141,141,121 ] & cocone=[cocone $
,131,131,126,134,135,133,129,128,99,99,61,137,134,130,130,122,100,100,135 ] & cocone=[cocone $
,135,135,137,135,135,136,134,134,134,133,132,131,131,133,133,129,130,127,130 ] & cocone=[cocone $
,125,129,122,127,120,125,116,121,115,112,117,105,105,105,110,94,94,94,94 ] & cocone=[cocone $
,94,94,94,94,102,105,119,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,141,137,127,130,125 ] & cocone=[cocone $
,127,122,125,122,119,118,125,112,68,62,47,62,47,57,83,94,94,94,94 ] & cocone=[cocone $
,94,94,95,105,105,105,108,112,114,116,121,65,15,0,15,141,94,94,141 ] & cocone=[cocone $
,94,99,101,133,131,128,99,83,62,91,137,135,130,127,121,106,66,136,137 ] & cocone=[cocone $
,138,139,139,136,136,134,134,134,133,132,131,133,136,135,135,128,130,126,125 ] & cocone=[cocone $
,124,126,120,124,122,116,120,112,112,109,105,105,105,100,94,94,94,94,94 ] & cocone=[cocone $
,94,94,95,102,105,119,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,139,130,127,130,125,129 ] & cocone=[cocone $
,122,127,120,125,116,123,116,68,62,47,47,47,47,94,94,94,94,94,94 ] & cocone=[cocone $
,94,95,105,105,105,110,112,115,116,119,121,31,0,15,15,94,125,141,109 ] & cocone=[cocone $
,94,62,37,121,109,83,62,75,136,136,133,132,128,117,110,112,138,138,138 ] & cocone=[cocone $
,138,138,138,134,134,135,133,134,131,133,134,134,132,141,133,127,126,128,124 ] & cocone=[cocone $
,125,122,124,118,116,122,112,118,109,105,105,110,95,94,94,94,94,94,94 ] & cocone=[cocone $
,94,95,105,105,136,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,144,129,130,126,125,128,122 ] & cocone=[cocone $
,125,120,125,116,120,97,47,62,47,47,62,67,94,94,94,94,94,94,94 ] & cocone=[cocone $
,100,105,105,105,112,112,116,116,120,123,93,15,0,15,78,94,94,94,94 ] & cocone=[cocone $
,94,62,47,94,62,61,121,137,135,132,129,125,115,68,122,138,137,138,138 ] & cocone=[cocone $
,135,137,137,127,136,133,134,131,133,135,132,127,118,129,121,125,127,128,134 ] & cocone=[cocone $
,127,127,118,116,115,112,116,105,105,105,110,94,94,94,94,94,94,94,94 ] & cocone=[cocone $
,98,105,105,140,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,134,131,130,126,128,124,126,122 ] & cocone=[cocone $
,124,118,116,122,112,118,15,47,47,62,88,94,94,94,94,94,94,94,100 ] & cocone=[cocone $
,105,105,107,112,113,116,116,120,121,119,42,0,0,47,47,47,0,15,62 ] & cocone=[cocone $
,109,62,94,46,135,136,137,133,132,130,122,103,84,122,138,135,136,137,133 ] & cocone=[cocone $
,132,133,131,127,133,134,131,132,134,131,124,112,68,94,76,129,129,127,129 ] & cocone=[cocone $
,131,129,123,115,112,112,105,105,105,114,94,94,94,94,94,94,94,94,100 ] & cocone=[cocone $
,105,113,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,137,127,127,125,124,124,126,122,124 ] & cocone=[cocone $
,118,116,122,112,116,105,46,31,47,83,94,94,94,94,94,94,95,105,105 ] & cocone=[cocone $
,105,108,112,114,116,118,120,122,122,114,0,0,15,44,39,41,15,31,31 ] & cocone=[cocone $
,78,31,75,135,137,137,135,130,130,121,106,68,137,136,133,134,133,131,128 ] & cocone=[cocone $
,120,115,94,131,132,131,133,134,130,123,107,36,47,94,113,131,124,90,109 ] & cocone=[cocone $
,109,65,112,112,109,105,105,105,100,94,94,94,94,94,94,94,95,102,105 ] & cocone=[cocone $
,119,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,142,133,127,130,125,129,122,127,120,125,116 ] & cocone=[cocone $
,121,112,112,120,105,105,105,52,83,94,94,94,94,94,94,95,105,105,105 ] & cocone=[cocone $
,108,112,114,116,119,120,122,125,122,90,0,0,71,127,109,78,78,94,60 ] & cocone=[cocone $
,75,135,135,136,136,134,132,128,116,110,91,135,134,133,127,131,116,109,75 ] & cocone=[cocone $
,93,55,61,130,133,133,134,129,121,100,47,47,47,101,127,119,94,47,78 ] & cocone=[cocone $
,94,87,118,109,105,105,105,100,94,94,94,94,94,94,94,95,105,105,131 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,144,130,127,127,125,129,122,127,120,125,116,120 ] & cocone=[cocone $
,115,112,109,105,105,105,100,94,94,94,94,94,94,94,100,105,105,105,112 ] & cocone=[cocone $
,112,116,116,120,121,122,125,126,120,38,0,15,99,78,94,94,61,120,135 ] & cocone=[cocone $
,135,135,137,135,133,132,125,115,58,90,132,132,131,127,109,57,76,119,129 ] & cocone=[cocone $
,111,37,69,134,133,133,127,118,73,47,47,62,112,127,119,47,62,47,78 ] & cocone=[cocone $
,75,116,105,105,105,110,94,94,94,94,94,94,94,94,98,105,105,140,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,134,131,130,126,128,124,126,124,124,124,116,120,112 ] & cocone=[cocone $
,112,109,105,105,105,100,94,94,94,94,94,94,94,100,105,105,105,112,112 ] & cocone=[cocone $
,116,116,120,121,123,125,127,128,129,5,0,78,94,31,76,119,135,135,135 ] & cocone=[cocone $
,135,136,135,134,130,124,109,84,115,132,124,121,99,62,90,134,134,133,124 ] & cocone=[cocone $
,80,15,106,132,131,123,121,68,47,47,44,112,129,112,52,62,62,47,47 ] & cocone=[cocone $
,104,105,105,105,110,94,94,94,94,94,94,94,94,100,105,110,140,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,144,144,135,128,129,125,128,124,126,122,124,118,116,122,112,116 ] & cocone=[cocone $
,109,105,105,110,99,94,94,94,94,94,94,95,102,105,105,108,112,114,116 ] & cocone=[cocone $
,118,120,122,124,125,127,128,129,130,43,62,61,119,134,135,135,135,135,135 ] & cocone=[cocone $
,137,139,132,130,121,102,73,133,131,121,83,62,105,136,134,134,135,130,118 ] & cocone=[cocone $
,37,31,133,130,123,103,57,47,62,56,131,124,102,52,47,62,31,47,97 ] & cocone=[cocone $
,105,105,105,110,94,94,94,94,94,94,94,95,100,105,119,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,141,132,127,130,125,129,124,123,122,123,118,116,115,112,116,105 ] & cocone=[cocone $
,105,105,110,94,94,94,94,94,94,94,95,105,105,105,108,112,114,116,118 ] & cocone=[cocone $
,120,122,124,125,127,129,129,130,131,117,46,134,134,135,135,135,135,135,139 ] & cocone=[cocone $
,145,145,125,120,94,57,115,94,115,137,120,135,136,134,135,134,132,127,106 ] & cocone=[cocone $
,0,50,130,122,100,47,47,62,89,126,123,94,47,47,47,62,53,109,105 ] & cocone=[cocone $
,105,105,100,94,94,94,94,94,94,94,95,105,105,127,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,133,127,125,129,122,127,120,125,116,120,115,112,111,105,105 ] & cocone=[cocone $
,105,109,94,94,94,94,94,94,94,95,105,105,105,110,112,115,116,120,121 ] & cocone=[cocone $
,122,125,126,127,129,129,130,131,132,133,134,134,135,135,135,135,135,142,145 ] & cocone=[cocone $
,145,145,127,73,62,31,90,135,135,135,135,134,134,135,133,134,132,121,60 ] & cocone=[cocone $
,31,78,121,90,47,62,47,85,127,116,89,62,47,31,47,58,121,117,105 ] & cocone=[cocone $
,102,99,94,94,94,94,94,94,94,95,105,105,132,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,134,122,127,120,125,116,120,112,112,109,105,105,105 ] & cocone=[cocone $
,100,94,94,94,94,94,94,94,100,105,105,105,112,112,116,116,120,121,122 ] & cocone=[cocone $
,125,126,128,129,130,130,131,133,133,134,134,135,135,135,135,135,142,145,145 ] & cocone=[cocone $
,145,145,144,60,60,135,135,135,135,136,134,134,136,133,135,131,133,114,5 ] & cocone=[cocone $
,31,123,68,31,62,44,112,127,112,52,62,47,47,31,78,110,141,94,115 ] & cocone=[cocone $
,99,104,94,94,94,94,94,94,100,105,109,140,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,142,125,116,116,112,110,109,105,105,113,100 ] & cocone=[cocone $
,94,94,94,94,94,94,94,100,105,105,106,112,113,116,117,120,121,124,125 ] & cocone=[cocone $
,127,128,129,130,130,131,133,134,134,135,135,135,135,135,137,145,145,145,145 ] & cocone=[cocone $
,145,141,135,135,135,136,135,135,136,134,134,135,133,134,131,133,128,100,0 ] & cocone=[cocone $
,0,94,47,47,44,131,121,112,52,62,47,47,47,109,94,94,109,141,94 ] & cocone=[cocone $
,78,68,109,104,94,94,94,100,105,113,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,141,123,116,105,105,105,110,94,94 ] & cocone=[cocone $
,94,94,94,94,94,95,105,105,105,108,112,114,116,118,120,122,124,125,127 ] & cocone=[cocone $
,128,129,130,131,132,133,134,134,135,135,135,135,135,137,145,145,145,145,145 ] & cocone=[cocone $
,141,135,135,135,136,135,135,136,134,135,134,134,132,133,131,132,126,55,31 ] & cocone=[cocone $
,47,78,62,69,126,123,94,52,47,62,31,47,125,94,141,141,125,109,94 ] & cocone=[cocone $
,94,94,78,57,89,95,105,105,127,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,131,118,114,94,94,94 ] & cocone=[cocone $
,94,94,94,94,95,105,105,105,110,112,115,116,119,120,122,124,126,127,129 ] & cocone=[cocone $
,129,130,131,132,133,134,134,135,135,135,135,135,141,145,145,145,145,145,138 ] & cocone=[cocone $
,135,135,135,135,135,135,135,134,135,133,134,132,133,131,132,130,131,26,62 ] & cocone=[cocone $
,94,78,85,126,121,89,62,47,47,47,31,109,109,125,94,94,141,109,125 ] & cocone=[cocone $
,109,94,62,15,68,105,105,132,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,139,122,111,105 ] & cocone=[cocone $
,94,94,94,98,105,105,105,110,112,116,116,120,121,122,125,126,127,129,129 ] & cocone=[cocone $
,130,131,133,133,134,134,135,135,135,135,135,142,145,145,145,145,145,136,135 ] & cocone=[cocone $
,135,135,135,135,136,134,134,136,133,135,131,134,131,131,130,131,128,56,31 ] & cocone=[cocone $
,31,94,120,105,84,62,47,47,47,78,94,94,94,109,94,94,94,125,125 ] & cocone=[cocone $
,109,78,47,0,55,109,140,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,128,117,118,105,106,112,112,116,116,120,121,123,125,126,128,129,130,130 ] & cocone=[cocone $
,131,133,134,134,135,135,135,135,135,136,142,145,145,145,145,141,135,135,135 ] & cocone=[cocone $
,135,135,135,136,134,134,135,133,134,131,133,130,133,129,132,127,127,125,13 ] & cocone=[cocone $
,108,125,120,63,47,47,47,62,62,15,47,47,31,47,0,31,47,94,109 ] & cocone=[cocone $
,109,78,47,0,110,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,141,145,145,139,137,137,131,133,132,129,131,132,132 ] & cocone=[cocone $
,133,134,134,135,135,135,135,135,137,145,145,145,145,145,141,135,135,135,136 ] & cocone=[cocone $
,135,135,136,134,135,134,134,134,133,132,130,133,129,132,127,127,125,128,122 ] & cocone=[cocone $
,122,120,124,116,31,47,62,62,31,15,0,15,0,0,15,0,0,0,0 ] & cocone=[cocone $
,31,47,15,39,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,142,141,138,135,135,139,145,145,145,145,145,141,135,135,135,137,135 ] & cocone=[cocone $
,135,136,134,135,133,134,132,133,131,132,130,131,128,129,126,128,124,126,122 ] & cocone=[cocone $
,120,119,116,123,53,47,70,23,15,0,15,0,0,47,0,78,94,141,94 ] & cocone=[cocone $
,62,31,31,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,136,135,135,135,135,135,136 ] & cocone=[cocone $
,135,134,134,133,134,132,133,131,132,130,131,128,129,125,128,124,125,120,123 ] & cocone=[cocone $
,118,116,122,112,110,109,105,105,0,15,0,0,15,0,47,94,109,94,141 ] & cocone=[cocone $
,125,62,80,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,139,135,136,135,135,136,134 ] & cocone=[cocone $
,134,135,133,134,131,133,130,130,129,132,127,130,125,127,122,127,120,123,116 ] & cocone=[cocone $
,121,115,112,118,105,105,105,112,83,0,31,15,0,31,94,109,125,141,109 ] & cocone=[cocone $
,78,96,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,142,139,137,134,134 ] & cocone=[cocone $
,135,133,134,131,133,130,133,129,132,127,127,125,129,122,127,120,123,116,121 ] & cocone=[cocone $
,115,112,118,105,105,105,112,94,94,94,41,0,0,0,78,78,109,141,63 ] & cocone=[cocone $
,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138 ] & cocone=[cocone $
,134,132,133,130,132,130,129,128,130,126,125,124,126,122,120,119,116,123,112 ] & cocone=[cocone $
,118,109,105,105,113,105,94,94,94,94,94,94,62,74,46,35,92,112,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,140,131,132,130,131,128,129,125,128,122,121,122,124,119,116,122,112,118 ] & cocone=[cocone $
,109,105,105,113,99,94,94,94,94,94,94,94,96,105,105,132,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,139,133,127,130,125,127,122,127,120,123,116,121,115,112,120,109 ] & cocone=[cocone $
,105,105,106,99,94,94,94,94,94,94,94,96,105,110,140,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,140,129,127,122,127,120,123,116,121,115,112,118,105,105 ] & cocone=[cocone $
,105,112,94,94,94,94,94,94,94,94,102,105,110,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,136,120,124,116,117,115,112,118,105,105,105 ] & cocone=[cocone $
,112,94,94,94,94,94,94,94,94,102,105,119,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,135,123,112,118,109,105,105,113,99 ] & cocone=[cocone $
,94,94,94,94,94,94,94,96,102,105,132,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,122,105,105,113,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,140,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,134,111,105,94 ] & cocone=[cocone $
,94,94,94,94,94,98,105,110,140,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,128,111,94,94,102,105,119,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,140,131,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145]

 cocone=reform(cocone,128,64)
endelse
return
end
PRO lerch,ww,ff,extension

@lamp.cbk
IF N_ELEMENTS(ff) LT 1 THEN extension='rtv'
IF N_ELEMENTS(ff) LT 1 THEN ff=W_NUMOR(alone)
IF STRPOS(ff,'.') GT 0 THEN ff=STRMID(ff,0,STRPOS(ff,'.'))
ff=ff+'.'+extension
TAKE_DATP,datp
xx=datp.x
openw,aa,ff,/get_lun            
printf,aa,xx(0),xx(1)-xx(0),max(xx)            
printf,aa,F='('+STRCOMPRESS(N_ELEMENTS(ww),/RE)+'I10)',ww
free_lun,aa            
PRINT,'Export of W'+STRCOMPRESS(alone,/RE),' with',STRCOMPRESS(N_ELEMENTS(ww)), ' counts to ',ff
END
function LINEUP, win ,elas ,goodx ,exclu ,decl ,TOLOW ,ERRORS=wer
;******* ******
;**
;** aline  elastic peaks having a shift less that TOBAD canals  (D. Richard).
;** Output:ELAS  for the peaks position.
;**        GOODX for a list of spectra having a good intensity and placement peak.
;**        EXCLU for a list of spectra having a bad  intensity or  placement peak.

wout=0
siz =size(win)
if   siz (0) eq 2 then begin

;  ********    				      *************
   TOBAD=60  & if n_elements(TOLOW) eq 0 then TOLOW=15./100 else TOLOW=TOLOW>0.01
;  ********    				      *************
   sy  =siz(2)
   wout=win
   cm  =fltarr(sy)
   eldx=intarr(sy)

   for  i=0,sy-1 do begin
        tmp      =win(*,i)                                         ;make one peak
	wout(*,i)=smooth(smooth(median(tmp,3),3),4)	           ;
	cm  (  i)=max   (tmp,elas)                                 ;get peak index
	eldx(  i)=elas                                             ;
   endfor

   a   =max(eldx,min=b) & elas=eldx(0)
   if a ne b then begin   his =histogram(eldx)                     ;elastic peak
   			  tmp =max(his  ,c)                        ;
   			  elas=min(eldx)+c        		   ;position
			  endif
   exclu =-1 & idg=0

   for  i=0,sy-1 do begin					   ;verify index
	if abs(elas-eldx(i)) ge TOBAD  then begin		   ;
		    eldx(i)=elas & exclu=[exclu,i]		   ;
	endif else  idg   =[idg,i]				   ;
   endfor

   decl=elas - eldx						   ;how  to  shift

   for  i=0,sy-1 do wout(*,i) =shift(win(*,i),decl(i))		   ;do the work
   if n_elements(wer) eq n_elements(wout) then $		   ;** *** ****
   for  i=0,sy-1 do wer (*,i) =shift(wer(*,i),decl(i))		   ;** *** ****
	
   idg =idg(1:*)						   ;minimum peak
   ng  =n_elements(idg)						   ;
   off =ng/10                                                      ;
   pri =cm(idg)                                                    ;
   pri =pri(sort(pri))                                             ;
   c   =total  (pri(off:ng-off-1))/(ng-2*off)                      ;
   c1  =c*TOLOW  &  c2=c/TOLOW                                     ;

   pry =total (wout(*,idg)>0,2)                                    ;noisy spectra
   pidx=sort  (pry)                                                ;
   pidx=pidx  (4:(n_elements(pidx)/40)>5)                          ;
   tmp =wout  (*,idg)>0                                            ;
   tmp =total (tmp(pidx,*),1) / n_elements(pidx)                   ;
   c   =total (tmp)/ng/TOLOW                                       ;
   for i=0,ng-1 do if tmp(i) gt c+1 then cm(idg(i))=0              ;

   goodx =-1
   for  i=0,ng-1 do if (cm(idg(i)) ge c1) and (cm(idg(i)) le c2) $ ;make goodx
		 then goodx=[goodx,idg(i)] $			   ;
		 else exclu=[exclu,idg(i)]			   ;

   if n_elements(goodx) gt 1 then goodx =goodx(1:*)
   if n_elements(exclu) gt 1 then begin
				  exclu =exclu(1:*)
   				  exclu =exclu(sort(exclu))
   endif
endif else P_MUS,'mus_cannon'

return,wout
end
; $Id: curvefit.pro,v 1.7 1995/06/15 16:24:13 dave Exp $
function lsfit, x, y, w, a, sigmaa, Function_Name = Function_Name, $
                        itmax=itmax, iter=iter, tol=tol, chi2=chi2, $
                        noderivative=noderivative,damping=damping,plot=plot,print=print
; Copyright (c) 1988-1995, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       CURVEFIT
;
; PURPOSE:
;       Non-linear least squares fit to a function of an arbitrary 
;       number of parameters.  The function may be any non-linear 
;       function.  If available, partial derivatives can be calculated by 
;       the user function, else this routine will estimate partial derivatives
;       with a forward difference approximation.
;
; CATEGORY:
;       E2 - Curve and Surface Fitting.
;
; CALLING SEQUENCE:
;       Result = CURVEFIT(X, Y, W, A, SIGMAA, FUNCTION_NAME = name, $
;                         ITMAX=ITMAX, ITER=ITER, TOL=TOL, /NODERIVATIVE)
;
; INPUTS:
;       X:  A row vector of independent variables.  This routine does
;		not manipulate or use values in X, it simply passes X
;		to the user-written function.
;
;       Y:  A row vector containing the dependent variable.
;
;       W:  A row vector of weights, the same length as Y.
;               For no weighting,
;               w(i) = 1.0.
;               For instrumental weighting,
;               w(i) = 1.0/y(i), etc.
;
;       A:  A vector, with as many elements as the number of terms, that 
;           contains the initial estimate for each parameter.  If A is double-
;           precision, calculations are performed in double precision, 
;           otherwise they are performed in single precision.
;
; KEYWORDS:
;       FUNCTION_NAME:  The name of the function (actually, a procedure) to 
;       fit.  If omitted, "FUNCT" is used. The procedure must be written as
;       described under RESTRICTIONS, below.
;
;       ITMAX:  Maximum number of iterations. Default = 20.
;       ITER:   The actual number of iterations which were performed
;       TOL:    The convergence tolerance. The routine returns when the
;               relative decrease in chi-squared is less than TOL in an 
;               interation. Default = 1.e-3.
;       CHI2:   The value of chi-squared on exit
;       NODERIVATIVE:   If this keyword is set then the user procedure will not
;               be requested to provide partial derivatives. The partial
;               derivatives will be estimated in CURVEFIT using forward
;               differences. If analytical derivatives are available they
;               should always be used.
;
; OUTPUTS:
;       Returns a vector of calculated values.
;       A:  A vector of parameters containing fit.
;
; OPTIONAL OUTPUT PARAMETERS:
;       Sigmaa:  A vector of standard deviations for the parameters in A.
;
; COMMON BLOCKS:
;       NONE.
;
; SIDE EFFECTS:
;       None.
;
; RESTRICTIONS:
;       The function to be fit must be defined and called FUNCT,
;       unless the FUNCTION_NAME keyword is supplied.  This function,
;       (actually written as a procedure) must accept values of
;       X (the independent variable), and A (the fitted functions
;       parameter values), and return F (the function`s value at
;       X), and PDER (a 2D array of partial derivatives).
;       For an example, see FUNCT in the IDL User`s Libaray.
;       A call to FUNCT is entered as:
;       FUNCT, X, A, F, PDER
; where:
;       X = Variable passed into CURVEFIT.  It is the job of the user-written
;		function to interpret this variable.
;       A = Vector of NTERMS function parameters, input.
;       F = Vector of NPOINT values of function, y(i) = funct(x), output.
;       PDER = Array, (NPOINT, NTERMS), of partial derivatives of funct.
;               PDER(I,J) = DErivative of function at ith point with
;               respect to jth parameter.  Optional output parameter.
;               PDER should not be calculated if the parameter is not
;               supplied in call. If the /NODERIVATIVE keyword is set in the
;               call to CURVEFIT then the user routine will never need to
;               calculate PDER.
;
; PROCEDURE:
;       Copied from "CURFIT", least squares fit to a non-linear
;       function, pages 237-239, Bevington, Data Reduction and Error
;       Analysis for the Physical Sciences.
;
;       "This method is the Gradient-expansion algorithm which
;       combines the best features of the gradient search with
;       the method of linearizing the fitting function."
;
;       Iterations are performed until the chi square changes by
;       only TOL or until ITMAX iterations have been performed.
;
;       The initial guess of the parameter values should be
;       as close to the actual values as possible or the solution
;       may not converge.
;
; EXAMPLE:  Fit a function of the form f(x) = a * exp(b*x) + c to
;	sample pairs contained in x and y.
;	In this example, a=a(0), b=a(1) and c=a(2).
;	The partials are easily computed symbolicaly:
;		df/da = exp(b*x), df/db = a * x * exp(b*x), and df/dc = 1.0
;
;		Here is the user-written procedure to return F(x) and
;		the partials, given x:
;       pro gfunct, x, a, f, pder	; Function + partials
;	  bx = exp(a(1) * x)
;         f= a(0) * bx + a(2)		;Evaluate the function
;         if N_PARAMS() ge 4 then $	;Return partials?
;		pder= [[bx], [a(0) * x * bx], [replicate(1.0, N_ELEMENTS(y))]]
;       end
;
;         x=findgen(10)			;Define indep & dep variables.
;         y=[12.0, 11.0,10.2,9.4,8.7,8.1,7.5,6.9,6.5,6.1]
;         w=1.0/y			;Weights
;         a=[10.0,-0.1,2.0]		;Initial guess
;         yfit=curvefit(x,y,w,a,sigmaa,function_name='gfunct')
;	  print, 'Function parameters: ', a
;         print, yfit
;       end
;
; MODIFICATION HISTORY:
;       Written, DMS, RSI, September, 1982.
;       Does not iterate if the first guess is good.  DMS, Oct, 1990.
;       Added CALL_PROCEDURE to make the function`s name a parameter.
;              (Nov 1990)
;       12/14/92 - modified to reflect the changes in the 1991
;            edition of Bevington (eq. II-27) (jiy-suggested by CreaSo)
;       Mark Rivers, U of Chicago, Feb. 12, 1995
;           - Added following keywords: ITMAX, ITER, TOL, CHI2, NODERIVATIVE
;             These make the routine much more generally useful.
;           - Removed Oct. 1990 modification so the routine does one iteration
;             even if first guess is good. Required to get meaningful output
;             for errors. 
;           - Added forward difference derivative calculations required for 
;             NODERIVATIVE keyword.
;           - Fixed a bug: PDER was passed to user`s procedure on first call, 
;             but was not defined. Thus, user`s procedure might not calculate
;             it, but the result was then used.
;           
;-
;       on_error,2              ;Return to caller if error
COMMON fit,voigt,nterms,fitflag,key,undo,npeaks,rectangle,bragg,peakpars
IF KEYWORD_SET(damping) THEN damp=damping ELSE damp=FLTARR(N_ELEMENTS(a))+1.
IF N_ELEMENTS(damp) NE N_ELEMENTS(a) THEN damp=a*0.+1.
       ;Name of function to fit
       if n_elements(function_name) le 0 then function_name = "FUNCT"
       if n_elements(tol) eq 0 then tol = 1.e-3		;Convergence tolerance
       if n_elements(itmax) eq 0 then itmax = 20	;Maximum # iterations
	type = size(a)
	type = type(type(0)+1)
	double = type eq 5
	if (type ne 4) and (type ne 5) then a = float(a)  ;Make params floating

       ; If we will be estimating partial derivatives then compute machine
       ; precision
       if keyword_set(NODERIVATIVE) then begin
          res = nr_machar(DOUBLE=double)
          eps = sqrt(res.eps)
       endif

       terms2fit = n_elements(a)   ; # of parameters
       nfree = n_elements(y) - terms2fit ; Degrees of freedom
       if nfree le 0 then message, 'Curvefit - not enough data points.'
       flambda = 0.001          ;Initial lambda
       diag = lindgen(terms2fit)*(terms2fit+1) ; Subscripts of diagonal elements

;      Define the partial derivative array
       if double then pder = dblarr(n_elements(y), terms2fit) $
	else pder = fltarr(n_elements(y), terms2fit)
;
       for iter = 1, itmax do begin   ; Iteration loop

;PRINT,'Least-squares iteration no.',iter
if ITER EQ 0 then begin
  if NOT keyword_set(NODERIVATIVE) then begin
          res = nr_machar(DOUBLE=double)
          eps = sqrt(res.eps)
  endif
  call_procedure, Function_name, x, a, yfit
  for term=0, terms2fit-1 do begin
                p = a       ; Copy current parameters
                inc = eps * abs(p(term))    
                if (inc eq 0.) then inc = eps
                p(term) = p(term) + inc
                call_procedure, function_name, x, p, yfit1
                pder(0,term) = (yfit1-yfit)/inc
  endfor
  PRINT,'Evaluated  derivatives:',pder
  call_procedure, function_name, x, a, yfit, pder 
  PRINT,'Analytical derivatives:',pder
endif

          if keyword_set(NODERIVATIVE) then begin
;            Evaluate function and estimate partial derivatives
             call_procedure, Function_name, x, a, yfit
             for term=0, terms2fit-1 do begin
                p = a       ; Copy current parameters
                ; Increment size for forward difference derivative
                inc = eps * abs(p(term))    
                if (inc eq 0.) then inc = eps
                p(term) = p(term) + inc
                call_procedure, function_name, x, p, yfit1
                pder(0,term) = (yfit1-yfit)/inc
             endfor
          endif else begin
             ; The user`s procedure will return partial derivatives
             call_procedure, function_name, x, a, yfit, pder 
          endelse

          beta = (y-yfit)*w # pder
          alpha = transpose(pder) # (w # (fltarr(terms2fit)+1)*pder)
          chisq1 = total(w*(y-yfit)^2)/nfree ; Present chi squared.

				; If a good fit, no need to iterate
	  all_done = chisq1 lt total(abs(y))/1e7/NFREE
;
;         Invert modified curvature matrix to find new parameters.

          repeat begin
             c = sqrt(alpha(diag) # alpha(diag))
             array = alpha/(c>1e-45)
             array(diag) = array(diag)*(1.+flambda)              
             array = invert(array)
             tmp=damp*(array/(c>1e-45) # transpose(beta))
             ;b = a+ damp*(array/(c>1e-45) # transpose(beta)); New params
             
             b=a+tmp
             IF npeaks GE 1 THEN BEGIN
               b(INDGEN(npeaks)*peakpars)=b(INDGEN(npeaks)*peakpars)>0
               smallpeak=WHERE(b(INDGEN(npeaks)*peakpars) LE (MIN(y)*1e-3),smallpeaks)
               IF smallpeaks GT 0 THEN BEGIN
                 b(smallpeak*peakpars)=0
                 FOR peak=0,smallpeaks-1 DO BEGIN
                   b(smallpeak(peak)*peakpars+1+INDGEN(peakpars-1))=a(smallpeak(peak)*peakpars+1+INDGEN(peakpars-1))
                 ENDFOR
               ENDIF
               b(INDGEN(npeaks)*peakpars+2)=ABS(b(INDGEN(npeaks)*peakpars+2))
               IF rectangle THEN b(INDGEN(npeaks)*peakpars+3+voigt)=ABS(b(INDGEN(npeaks)*peakpars+3+voigt))
               ;IF voigt THEN b(INDGEN(npeaks)*peakpars+3)=ABS(FLOOR(ABS(b(INDGEN(npeaks)*peakpars+3))/2.)*2.-1.)
               IF voigt THEN b(INDGEN(npeaks)*peakpars+3)=ABS(b(INDGEN(npeaks)*peakpars+3))
             ENDIF
             call_procedure, function_name, x, b, yfit  ; Evaluate function
             chisqr = total(w*(y-yfit)^2)/nfree         ; New chisqr
           
;IF KEYWORD_SET(print) THEN PRINT,'chi2=',chisqr,', flambda=',flambda
	     if all_done then goto, done
             flambda = flambda*10.                      ; Assume fit got worse
          endrep until (chisqr le chisq1) OR NOT FINITE(chisqr)
;
          flambda = flambda/100.  ; Decrease flambda by factor of 10
          IF FINITE(chisqr) THEN BEGIN
            a=b                     ; Save new parameter estimate.
            IF KEYWORD_SET(print) THEN PRINT,iter,chisqr,a
            IF KEYWORD_SET(plot) THEN BEGIN
              PLOT,x,y,TITLE='Iteration'+STRCOMPRESS(iter)+', chi2='+STRCOMPRESS(chisqr,/RE),YRANGE=[0,MAX(y)],background=255,color=0
              OPLOTERR,x,y,w,0
              OPLOT,x,yfit,color=1
              OPLOT,x,y-yfit+MIN(y)/2.,color=3
              OPLOT,x,yfit*0.0+MIN(y)/2.,color=0
              OPLOT,x,y-yfit+w+MIN(y)/2.,color=2,LINE=0
              OPLOT,x,y-yfit-w+MIN(y)/2.,color=2,LINE=0
            ENDIF
            if ((chisq1-chisqr)/chisq1) le tol then goto,done  ; Finished?
          ENDIF ELSE BEGIN
            PRINT,'infinite chi2 -> stopped iteration loop'
            fitflag=1
            sigmaa = sqrt(array(diag)/alpha(diag))
            call_procedure, function_name, x, a, yfit, pder 
            chi2 = total(w*(y-yfit)^2)/nfree ; Present chi squared.
            return,yfit
          ENDELSE
          
       endfor                        ;iteration loop
;
       message, 'Failed to converge', /INFORMATIONAL
;
done:  sigmaa = sqrt(array(diag)/alpha(diag)) ; Return sigma`s
       ;nansigma=WHERE(NOT FINITE(sigmaa),nansigmas)
       ;IF nansigmas GT 0 THEN sigmaa(nansigma) =0.0
       chi2 = chisqr                          ; Return chi-squared
       return,yfit              ;return result
END
;*************************************************************************************************
;*               	         	    Main                                                 *
;*					  Procedure	                                         *
;*						                                                 *
;*************************************************************************************************

pro gres

;-------------------------------------------------
; Define All Global variables via common statement
;-------------------------------------------------
common initialvals,minres,maxres,r1,r2,q1,q2,base
common graph,m,c,info,k,lamda,r,graph,grp,draw,draw2
common vars,d,dis,w,phi,x,phil,bd,bw,bdis,global_flag,slit_chopper_dist,chopper_width
common qs,qmin,qmax,numblocks,currentblock,minq,maxq,sres,sample_angle,qrangeb,wid,perover,widmax,$
banner,slit_lock,qflag,rr1,rr2,ll1,ll2,s2v,s3v,sample_lenght,foot_print,slit_sample_dist,angres,sub,submenu,$
restart_flag,save_string,dr,disr,wr,slit,chopper_to_sample
common slitstuff,slit_separation
common error,errbase,errsnum


;----------------------------------------------------------
;Hitting the NewQ Button In the Data Window brings you here
;----------------------------------------------------------
newpass:


;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------
;Variables (Global and in main program only)
;
;d[low limit,high limit]      :Stores the limits of the Distance between the choppers (m) 
;dis[low limit,high limit]    :Stores the limits of the Chopper to sample Distance (m)
;w[low limit,high limit]      :Stores the limits of the Angular Velocity of the Chopper (rad/s)
;lamda[low limit,high limit]  :Stores the limits of the Wavelenght of the beam (amstrongs)
;phi[low limit,high limit]    :Stores the limits of the Chopper Phase Angle (Degrees)
;phil(x)                      :Stores the chopper angle the (x-1)th block (Degrees)
;r                            :Stores the radius of the chopper (m)
;perover                      :Stores the percentage of overlap of the blocks (decimal)
;maxres[low limit,high limit] :Stores the limits of the time resolution for the maximum point
;minres[low limit,high limit] :Stores the limits of the time resolution for the minimum point
;slit_separation              :Stores the value of the slit separation (m)
;slit_chopper_dist            :Stores the value of the distance from s2 to the chopper (m)
;chopper_width                :Stores the value of the effective sample lenght for chopper (m)
;sample_lenght                :Stores the value of the sample lenght (m)
;slit_sample_dist             :Stores the distance from s3 to the sample (m)
;bd, bdis, bw                 :Holds Default values for d,dis,w 
;sres(x,y)                    :sres hold the current value of the time resolution sliders
;      			      :		x=0 indexs the min slider, x=1 indexs the max slider
;			      :         y references the current block. 0=block1,1=block2,2=block3
;sample_angle(x)              :Stores the sample angle for the x'th block. (0=1st block etc) (degrees)
;global_flag                  :Is set to one when newq is pressed in data window otherwise=0
;errbase()                    :Stores the widget references for the message windows
;errsnum                      :Used as an index for errbase, cyles from 0 to 100
;                             :It increments by one everytime a message window appears
;slit_lock                    :Contains the status of the slit lock button, 0=off, 1=on
;qflag                        :Is set to 1 in intial setup window if quit is pressed
;s2v(x), s3v(x)               :Stores the slit opening distance of s2, s3 respect.
;                             :x stores the block refernce, x=0 is 1st block and so on
;graph()                      :Stores widget references for the illumination graph window
;                             :graph(3)=1 when window is open, else it is zero
;angres(x)                    :Stores the angular resolution for block x+1. x=0,1,2.
;submenu()                    :Stores widget references to the pop menu in the inital setup window
;			      :submenu(0)=1 when it is open, otherwise = 0
;restart_flag                 :Contains 1 if the perover variable has changed
;save_string                  :Contains the name of the save file
;                             :On saving the block number is concatenated with it and '.dat'
;k                            :stores the value of h/mass of neutron. In units of 1e10.
;numblocks                    :Stores the number of blocks, can take values of 1,2,3
;currentblock                 :Stores the current block, takes values of 0,1,2
;wid                          :Stores the widget references for the inital setup window
;qrangeb                      :Stores Maximum wavelenght/Minimum Wavelenght
;minq(x)                      :Stores the minimum q value for block (x+1), x=0,1,2. (amstrongs)^-1
;maxq(x)                      :Stores the maximum q value for block (x+1), x=0,1,2. (amstrongs)^-1
;widmax                       :Stores how many widgets are in intial setup window
;qmin, qmax                   :Stores q minimum and q maximum of current block
;val                          :many uses depends on context. All purpose variable. Not GLOBAL.
;info(),draw,draw2            :stores widget references, to data window, gfxs win1, gfxs win2
;gbase,frbase,pbase,dbase     :Stores base references
;r1,r2,q1,q2                  :tempory values. depends on context. *
;m                            :Contains the gradient of the time resolution graph, for the current block
;c                            :Contains the intercept of the time resolution grpah, for the current block
;foot_print                   :Holds the 'foot print' of the illumination of the slit (m)
;rr1,rr2,ll1,ll2              :Contains the coordinates for the illumination of the sample (m)
;x                            :Holds the value of delta x for the current block    
;banner                       :Holds a status which tells the program which buttons to deactivate
;grp                          :Hold the base reference to the illumination window
;sub                          :Contains the reference to the parameters window
;sres(min/max,block)          :Contains the slider resolutions. min=0,max=1, block=0,1,2 
;dr, wr, disr                 :Contains the saved values for d, w, and dis respectivly  
;slit(2)                      :Contains the minimum, maximum openings for the slits (in meters)
;chopper_to_sample            :Contains the chopper to sample lenght
;                   
;--------------------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------------------

dr=fltarr(3)
wr=fltarr(3)
disr=fltarr(3)
d=[0.,0.]
dis=[0.,0.]
w=[0.,0.]
lamda=[0.,0.]
phi=[0.,0.]
r=0.
perover=0.
maxres=[0.,0.]
minres=[0.,0.]
sres=fltarr(2,3)
sample_angle=fltarr(3)
global_flag=0
slit_lock=0
qflag=0
s2v=fltarr(3)
s3v=fltarr(3)
graph=intarr(10)
graph=long(graph)
angres=fltarr(3)
submenu=intarr(30)
submenu=long(submenu)
restart_flag=0
save_string='block'
minq=fltarr(3)
maxq=fltarr(3)
wid=intarr(60)
info=intarr(50)
phil=fltarr(3)
chopper_to_sample=0.

;*************************************************
;Slit openings (m)
;*************************************************
slit=[0.,0.01]


;-------------------------------------------------
;default chopper angles
;-------------------------------------------------
phil(0)=.144688
;phil(1)=1.47802
;phil(2)=0

;-------------------------------------------------
;allows upto 100 messages at once
;-------------------------------------------------
errbase=intarr(100)
errbase=long(errbase)

;-------------------------------------------------
;currently no messages on screen
;-------------------------------------------------
errsnum=0

;-------------------------------------------------
;Constants
;-------------------------------------------------
k=3956.0346035 
;-------------------------------------------------
;Read in data from the file ranges.dat
;-------------------------------------------------
openr,1,'ranges.dat'
readf,1,chopper_to_sample,d,dis,w,lamda,phi,r,perover,minres,maxres,slit_separation,slit_chopper_dist,chopper_width,$
sample_lenght,slit_sample_dist
close,1
bd=d & bdis=dis & bw=w
qrangeb=lamda(1)/lamda(0)
;*************************************************************************************************
;*                                      Initial Setup Window
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************

;-------------------------------------------------
;Default Data for intial setup window
;-------------------------------------------------
numblocks=2
currentblock=0
for u=0,2 do begin
  s2v(u)=.005
  s3v(u)=.005
endfor
minq(0)=0.005
maxq(0)=.05
minq(1)=.0455
maxq(1)=.455
sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi


;-------------------------------------------------
;Sets up the interface with default values
;See documentation for more information
;-------------------------------------------------
base=widget_base(title='Initial Setup, Press Next When Finished',uvalue='base')
wid(0)=widget_label(base,value='q min :',xoffset=0,yoffset=5)
wid(1)=widget_text(base,value=string(.005),xoffset=100,yoffset=0,uvalue=41,/editable)
wid(2)=widget_label(base,value='q max :',xoffset=380,yoffset=5)
wid(3)=widget_text(base,value=string(.5),xoffset=480,yoffset=0,uvalue=43,/editable)

wid(4)=widget_button(base,value="",xoffset=0,yoffset=50,xsize=870,ysize=7)

wid(5)=widget_label(base,value='- For Current Block -',xoffset=0,yoffset=70)

wid(6)=widget_label(base,value='q min :',xoffset=0,yoffset=105)
wid(7)=widget_text(base,value=string(.005),xoffset=100,yoffset=100,uvalue=47)
wid(8)=widget_label(base,value='q max :',xoffset=380,yoffset=100)
wid(9)=widget_text(base,value=string(.05),xoffset=480,yoffset=105,uvalue=49)

wid(10)=widget_label(base,value='l min :',xoffset=380,yoffset=150)
wid(11)=widget_label(base,value=string(lamda(0)),xoffset=480,yoffset=150)
wid(12)=widget_label(base,value='l max :',xoffset=0,yoffset=150)
wid(13)=widget_label(base,value=string(lamda(1)),xoffset=100,yoffset=150)

wid(14)=widget_button(base,value='ACTIVE ',xoffset=775,yoffset=72,uvalue=54)
wid(15)=widget_button(base,value='Block 2',xoffset=775,yoffset=102,uvalue=55)
wid(16)=widget_button(base,value='Block 3',xoffset=775,yoffset=132,uvalue=56)

wid(17)=widget_button(base,value='Quit',xoffset=792,yoffset=10,uvalue=57)

wid(18)=widget_label(base,value='Current Block is :',xoffset=380,yoffset=70)
wid(19)=widget_label(base,value=string(currentblock+1),xoffset=530,yoffset=71,uvalue=59)

wid(20)=widget_button(base,value="",xoffset=0,yoffset=180,xsize=870,ysize=5)

wid(21)=widget_label(base,value='S2 :',xoffset=0,yoffset=206)
wid(22)=widget_slider(base,minimum=slit(0)*1e7,maximum=slit(1)*1e7,value=slit(0)*1e7,uvalue=62,$
xoffset=70,yoffset=210,xsize=200,/suppress_value,/drag)
wid(23)=widget_text(base,value=string(slit(0)),uvalue=63,xoffset=300,yoffset=200,/editable)

wid(24)=widget_label(base,value='S3 :',xoffset=0,yoffset=266)
wid(25)=widget_slider(base,minimum=slit(0)*1e7,maximum=slit(1)*1e7,value=slit(0)*1e7,uvalue=65,$
xoffset=70,yoffset=270,xsize=200,/suppress_value,/drag)
wid(26)=widget_text(base,value=string(slit(0)),uvalue=66,xoffset=300,yoffset=260,/editable)

wid(35)=widget_button(base,value="OFF",uvalue=75,xoffset=140,yoffset=235,$
xsize=60,ysize=30)

wid(27)=widget_label(base,value='Sample Angle  :',xoffset=570,yoffset=205)
wid(28)=widget_label(base,value=string(.683934),uvalue=68,xoffset=710,yoffset=205)

wid(29)=widget_label(base,value='Sample Length :',xoffset=570,yoffset=245)
wid(30)=widget_label(base,value=string(sample_lenght),xoffset=710,yoffset=245)

wid(31)=widget_label(base,value='Slit-Sam Dist :',xoffset=570,yoffset=285)
wid(32)=widget_label(base,value=string(slit_sample_dist),xoffset=710,yoffset=285)

wid(33)=widget_label(base,value='Slit Separtn  :',xoffset=570,yoffset=325)
wid(34)=widget_label(base,value=string(slit_separation),xoffset=710,yoffset=325)

wid(36)=widget_button(base,value='Next',uvalue=76,xoffset=305,yoffset=305,xsize=250,ysize=45)

wid(37)=widget_label(base,value='Illumination :',xoffset=0,yoffset=295)
wid(38)=widget_label(base,value='Over',xoffset=210,yoffset=295,uvalue=78,xsize=70)

wid(39)=widget_button(base,value="",xoffset=0,yoffset=360,xsize=870,ysize=7)

wid(40)=widget_label(base,value='Block 1',xoffset=80,yoffset=380)
wid(41)=widget_label(base,value='Block 2',xoffset=380,yoffset=380)
wid(42)=widget_label(base,value='Block 3',xoffset=680,yoffset=380)

wid(43)=widget_label(base,value='Ang',xoffset=0,yoffset=420)
wid(44)=widget_label(base,value='Res',xoffset=0,yoffset=440)

wid(45)=widget_label(base,value='   0.119677',xoffset=35,yoffset=430,xsize=170)
wid(46)=widget_label(base,value='  0.0131257',xoffset=335,yoffset=430,xsize=170)
wid(47)=widget_label(base,value='Ready',xoffset=635,yoffset=430,xsize=170)
wid(48)=widget_button(base,value='Graph',xoffset=22,yoffset=323,uvalue=88)

wid(49)=widget_button(base,value='-',xoffset=50,yoffset=375,uvalue=89)
wid(50)=widget_button(base,value='-',xoffset=350,yoffset=375,uvalue=90)
wid(51)=widget_button(base,value='-',xoffset=650,yoffset=375,uvalue=91)

wid(52)=widget_label(base,value='Lock',xoffset=80,yoffset=238)

wid(53)=widget_label(base,value='F',xoffset=110,yoffset=317)
wid(54)=widget_label(base,value='%',xoffset=110,yoffset=336)
wid(55)=widget_label(base,value=string(0.),xoffset=120,yoffset=317,uvalue=95)
wid(56)=widget_label(base,value=string(0.),xoffset=120,yoffset=336,uvalue=96)

wid(57)=widget_button(base,value='>',xoffset=840,yoffset=395,uvalue=97)

widmax=57


;-------------------------------------------------
;to SEE the widgets one must call this
;-------------------------------------------------
widget_control,/realize,base

;-------------------------------------------------
;Make the separators inactive
;-------------------------------------------------
widget_control,wid(4),sensitive=0
widget_control,wid(20),sensitive=0
widget_control,wid(39),sensitive=0
widget_control,wid(16),sensitive=0

;-------------------------------------------------
;set footprint and illumination values
;-------------------------------------------------
h=bob(.005,.005,sample_angle(currentblock),sample_lenght,slit_sample_dist)
update_ftper

;----------------------------------------------------------------------
;lets the interaction of mouse and user start and registers button hits
;it calls the proedure base_event in the case of an interaction
;----------------------------------------------------------------------
xmanager,'base',base


;-------------------------------------------------
;If the quit button is pressed exit program
;-------------------------------------------------
if qflag eq 1 then goto,pass





;*************************************************************************************************
;*                                         Data Window
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************

;-------------------------------------------------
;Allocate the 'bases' in memory for the widgets
;-------------------------------------------------
gbase=widget_base(title='Graphical Output')
grbase=widget_base(title='Graphival Output 2')
pbase=widget_base(title='Ranges',/column)
dbase=widget_base(title='Data Window')

;-------------------------------------------------
;Draw two gfxs widgets for the graphs
;-------------------------------------------------
draw=widget_draw(gbase,xsize=400,ysize=700,yoffset=0,xoffset=0,retain=2)
;draw2=widget_draw(grbase,xsize=400,ysize=350,yoffset=0,xoffset=0,retain=2)

;-------------------------------------------------
;Set default Values
;-------------------------------------------------
currentblock=0
sres(0,0)=0.01*1e7 & sres(1,0)=0.02*1e7
sres(0,1)=0.01*1e7 & sres(1,1)=0.05*1e7
sres(0,2)=0.01*1e7 & sres(1,2)=0.02*1e7
qmin=minq(currentblock)
qmax=maxq(currentblock)
;prelimanry guess as limits depend upon, w and d also. Works because limits dont change much!
val=lims(sres(0,currentblock)*1e-7,sres(1,currentblock)*1e-7,qmin,qmax)

;----------------------------------------
;Default slider values for w, d, and dis 
;----------------------------------------
disr(0)=6.75 & dr(0)=.06 & wr(0)=122.7483
disr(1)=6.75 & dr(1)=.0375 & wr(1)=122.7483
disr(2)=6.75 & dr(2)=.0375 & wr(2)=122.7483

;--------------------------------------------------------------
;Setup the widgets for the bases, see documentation for details
;--------------------------------------------------------------
info(0)=widget_label(pbase,value='TOF Range : '+string(dis(0))+'  '+string(dis(1)),/align_left)
info(1)=widget_label(pbase,value='d Range    : '+string(d(0))+'  '+string(d(1)),/align_left)
info(2)=widget_label(pbase,value='Rpms Range : '+string(w(1)*30/!pi)+'  '+string(w(0)*30/!pi),/align_left)
info(3)=widget_label(pbase,value='Chopper Ang: '+string(phil(0))+'  '+string(phil(0)),/align_left)
;-------------------------------------------------
;delta x update
;-------------------------------------------------
info(4)=widget_label(pbase,value='dtx/T      : '+string(0.)+'  '+string(0.),/align_left)

info(10)=widget_label(dbase,value='TOF Distance',xoffset=0,yoffset=0)
info(11)=widget_slider(dbase,minimum=dis(0)*1e7,maximum=dis(1)*1e7,uvalue=9,/drag,/suppress_value,$
xoffset=0,yoffset=30,xsize=257,value=disr(0)*1e7)
info(12)=widget_text(dbase,value=string(disr(0)),uvalue=10,xoffset=0,yoffset=50,/editable)

info(13)=widget_label(dbase,value='d',xoffset=0,yoffset=85)
info(14)=widget_slider(dbase,minimum=d(0)*1e7,maximum=d(1)*1e7,uvalue=11,/drag,/suppress_value,$
xoffset=0,yoffset=115,xsize=257,value=dr(0)*1e7)
info(15)=widget_text(dbase,value=string(dr(0)),uvalue=12,xoffset=0,yoffset=140,/editable)

info(16)=widget_label(dbase,value='Rpms',xoffset=0,yoffset=175)
info(17)=widget_slider(dbase,minimum=w(0)*1e7,maximum=w(1)*1e7,uvalue=13,/drag,/suppress_value,$
xoffset=0,yoffset=205,xsize=257,value=wr(0)*1e7)
info(18)=widget_text(dbase,value=string(wr(0)*30/!pi),uvalue=14,xoffset=0,yoffset=230,/editable)

info(19)=widget_label(dbase,value='Chopper Angle:'+string(.144688),xoffset=0,yoffset=275)
;-------------------------------------------------
;set delta x
;-------------------------------------------------
info(20)=widget_label(dbase,value='Transmission :',xoffset=0,yoffset=305)
info(45)=widget_label(dbase,value='    --------',xoffset=120,yoffset=305,xsize=250)
info(30)=widget_label(dbase,value='Sample Angle :'+string(sample_angle(currentblock)),yoffset=330,xoffset=0)

;resolution sliders
info(21)=widget_label(dbase,value='Minimum resolution',xoffset=320,yoffset=0)
info(22)=widget_slider(dbase,minimum=minres(0)*1e7,maximum=minres(1)*1e7,uvalue=15,/suppress_value,$
value=sres(0,currentblock),xoffset=320,yoffset=30,xsize=258)
info(23)=widget_text(dbase,value=string(sres(0,currentblock)*1e-7),/editable,xoffset=320,yoffset=55,uvalue=16)

info(24)=widget_label(dbase,value='Maximum resolution',xoffset=320,yoffset=130)
info(25)=widget_slider(dbase,minimum=maxres(0)*1e7,maximum=maxres(1)*1e7,uvalue=17,/suppress_value,$
value=sres(1,currentblock),xoffset=320,yoffset=160,xsize=258)
info(26)=widget_text(dbase,value=string(sres(1,currentblock)*1e-7),/editable,xoffset=320,yoffset=185,uvalue=18)

info(27)=widget_button(dbase,value='ACTIVE ',uvalue=19,xoffset=400,yoffset=230)
info(28)=widget_button(dbase,value='Block 2',uvalue=20,xoffset=400,yoffset=265)
info(29)=widget_button(dbase,value='Block 3',uvalue=21,xoffset=400,yoffset=300)
info(31)=widget_label(dbase,value=string(currentblock+1),xoffset=450,yoffset=310)

info(8)=widget_button(dbase,value='QUIT',uvalue=7,xoffset=510,yoffset=265)

info(38)=widget_button(dbase,value='NewQ',uvalue=26,xoffset=510,yoffset=230)

info(43)=widget_button(dbase,value="",xoffset=0,yoffset=355,xsize=600,ysize=5)

info(40)=widget_label(dbase,value='Angular Resolution Block 1 :'+string(angres(0)),yoffset=365,xoffset=0)
info(41)=widget_label(dbase,value='Angular Resolution Block 2 :'+string(angres(1)),yoffset=385,xoffset=0)
info(42)=widget_label(dbase,value='Angular Resolution Block 3 :'+string(angres(2)),yoffset=405,xoffset=0)

info(44)=widget_button(dbase,value='Save Blocks',yoffset=450,xoffset=0,uvalue=30,xsize=600)

;max=45 so use 46 next

;-------------------------------------------------
;show the widgets on screen
;-------------------------------------------------
widget_control,/realize,pbase
widget_control,/realize,gbase
widget_control,/realize,dbase
;widget_control,/realize,grbase

;-------------------------------------------------
;De-activate unwanted select block buttons
;-------------------------------------------------
if(numblocks lt 3) then begin
  widget_control,info(29),sensitive=0
endif
if(numblocks lt 2) then begin
 widget_control,info(29),sensitive=0
 widget_control,info(28),sensitive=0
endif

;-------------------------------------------------
;blank out separators
;-------------------------------------------------
widget_control,info(43),sensitive=1

;-------------------------------------------------
;draw plot in graphics window
;-------------------------------------------------
;drawplot

;--------------------------------------------------------
;lets roll baby, calls main_event upon a user interaction
;--------------------------------------------------------
xmanager,'main',dbase

;-------------------------------------------------
;Restart?
;-------------------------------------------------
if global_flag then goto,newpass

pass:
end

;*************************************************************************************************
;*               	         	    End Of                                               *
;*					  Main Program	                                         *
;*						                                                 *
;*************************************************************************************************











;*************************************************************************************************
;* 				Procedure main_event
;*
;*This proedure is called by xmanager when a user interaction has taken place. eq clicking a
;*button. 
;*
;*Variables (local):
;*
;* ev       :Contains the user value of the activated widget
;* val      :Contains the val of the widget itself that the user has activated
;* tmp1     :Tempory variable, use depends on context
;* err      :Tempory variable, use depends on context
;* a        :Tempory variable, use depends on context
;* sresb    :Contains the tempory modified time resolution
;*
;*(This is for the data window)  (Prgs note : delta x here)
;*************************************************************************************************


pro main_event,event
common graph
common qs
common vars
common slitstuff
err=0.
widget_control,event.id,get_uvalue=ev,get_value=val


;-------------------------------------------------
;pressed quit button
;-------------------------------------------------
if ev eq 7 then widget_control,/reset

;-------------------------------------------------
;newq button is pressed
;-------------------------------------------------
if ev eq 26 then begin
  widget_control,/reset
  global_flag=1
endif

;-------------------------------------------------
;slide sliders (dis,d,w)
;-------------------------------------------------
if(ev eq 9)or(ev eq 11)or(ev eq 13)or(ev eq 10)or(ev eq 12)or(ev eq 14) then begin
 if ev eq 9 then begin
 
   widget_control,info(12),set_value=string(val*1e-7)
   widget_control,info(14),set_value=c*val
   widget_control,info(15),set_value=string(c*val*1e-7)
   widget_control,info(17),set_value=2*!pi*k/val/lamda(1)*1e14
   widget_control,info(18),set_value=string(2*!pi*k/val/lamda(1)*1e14*1e-7*30/!pi)

   tmp1=val
   tmp2=c*val
   tmp3=2*!pi*k/val/lamda(1)*1e14

   err=refresh() 
 endif
  if ev eq 10 then begin
    val=long(val*1e7)
    widget_control,info(11),set_value=val(0)    
    widget_control,info(14),set_value=c*val(0)
    widget_control,info(15),set_value=string(c*val(0)*1e-7)
    widget_control,info(17),set_value=2*!pi*k/val(0)/lamda(1)*1e14
    widget_control,info(18),set_value=string(2*!pi*k/val(0)/lamda(1)*30/!pi*1e14*1e-7)
   
    tmp1=val(0)
    tmp2=c*val(0)
    tmp3=2*!pi*k/val(0)/lamda(1)*1e14

    ;redraw the window
    err=refresh()

  endif   
 if ev eq 11 then begin
   widget_control,info(15),set_value=string(val*1e-7)
   widget_control,info(11),set_value=val/c
   widget_control,info(12),set_value=string(val/c*1e-7)
   widget_control,info(17),set_value=2*!pi*k/(val/c)/lamda(1)*1e14
   widget_control,info(18),set_value=string(2*!pi*k/(val/c)/lamda(1)*1e14*1e-7*30/!pi)
   tmp1=val/c
   tmp2=val
   tmp3=2*!pi*k/(val/c)/lamda(1)*1e14

   ;redraw the window
   err=refresh()

 endif
 if ev eq 12 then begin
   val=long(val*1e7) 
   widget_control,info(14),set_value=val(0)
   widget_control,info(11),set_value=val(0)/c
   widget_control,info(12),set_value=string(val(0)/c*1e-7)
   widget_control,info(17),set_value=2*!pi*k/(val(0)/c)/lamda(1)*1e14
   widget_control,info(18),set_value=string(2*!pi*k/(val(0)/c)/lamda(1)*1e14*1e-7*30/!pi)
   tmp1=val(0)/c
   tmp2=val(0)
   tmp3=2*!pi*k/(val(0)/c)/lamda(1)*1e14

   ;redraw the window
   err=refresh()

 endif
 if ev eq 13 then begin
   widget_control,info(18),set_value=string(val*1e-7*30/!pi)
   widget_control,info(11),set_value=2*!pi*k/val/lamda(1)*1e14
   widget_control,info(12),set_value=string(2*!pi*k/val/lamda(1)*1e14*1e-7)
   widget_control,info(14),set_value=2*!pi*k/val/lamda(1)*1e14*c
   widget_control,info(15),set_value=string(2*!pi*k/val/lamda(1)*1e14*c*1e-7)
   tmp1=2*!pi*k/val/lamda(1)*1e14
   tmp2=2*!pi*k/val/lamda(1)*1e14*c
   tmp3=val

   ;redraw the window
   err=refresh()

 endif
 if ev eq 14 then begin
   val=long(val*1e7*!pi/30)
   widget_control,info(17),set_value=val(0)
   widget_control,info(11),set_value=2*!pi*k/val(0)/lamda(1)*1e14
   widget_control,info(12),set_value=string(2*!pi*k/val(0)/lamda(1)*1e14*1e-7)
   widget_control,info(14),set_value=2*!pi*k/val(0)/lamda(1)*1e14*c
   widget_control,info(15),set_value=string(2*!pi*k/val(0)/lamda(1)*1e14*c*1e-7)
   tmp1=2*!pi*k/val(0)/lamda(1)*1e14
   tmp2=2*!pi*k/val(0)/lamda(1)*1e14*c
   tmp3=val(0)

   ;redraw the window
   err=refresh()

 endif

   tmp1=tmp1*1e-7
   tmp2=tmp2*1e-7
   tmp3=tmp3*1e-7

   disr(currentblock)=tmp1
   dr(currentblock)=tmp2
   wr(currentblock)=tmp3
   
   ;-------------------------------------------------
   ;up date dx
   ;-------------------------------------------------
   ;widget_control,info(20),set_value='dx           :'+string(deltax(tmp2,tmp3,lamda(1),phil(currentblock)))
   ;*?*
   
endif




;-------------------------------------------------
;resolution sliders (maximum value)
;-------------------------------------------------
if(ev eq 15) then begin
 
  sres(0,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(23),set_value='Out Of Range'
    widget_control,info(26),set_value='Out Of Range'

    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0

  endif else begin
    widget_control,info(23),set_value=string(val*1e-7)
    widget_control,info(25),get_value=val1
    widget_control,info(26),set_value=string(val1*1e-7)

    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor

    ;drawplot
    redrawmain
    redrawparams
  endelse
endif


;-------------------------------------------------
;resolution text widget (maximum value)
;-------------------------------------------------
if(ev eq 16) then begin
  val=long(val*1e7)
  sres(0,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(23),set_value='Out Of Range'
    widget_control,info(26),set_value='Out Of Range'

    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0
 
  endif else begin
    widget_control,info(22),set_value=val(0)
    widget_control,info(25),get_value=val1
    widget_control,info(26),set_value=string(val1*1e-7)

    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor
    
    redrawparams
    ;drawplot
    redrawmain
  
  endelse
endif

;-------------------------------------------------
;resolution sliders (minimum value)
;-------------------------------------------------
if(ev eq 17) then begin
 
  sres(1,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(26),set_value='Out Of Range'
    widget_control,info(23),set_value='Out Of Range'

    ;block out unwanted
    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0

  endif else begin
    widget_control,info(26),set_value=string(val*1e-7)
    widget_control,info(22),get_value=val1
    widget_control,info(23),set_value=string(val1*1e-7)

    ;block out unwanted
    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor

    redrawparams
    ;drawplot
    redrawmain
    
  endelse
endif

;-------------------------------------------------
;resolution text widget (minimum value)
;-------------------------------------------------
if(ev eq 18) then begin
  val=long(val*1e7)
  sres(1,currentblock)=val
  err=refresh()

  if(err gt 0) then begin
    widget_control,info(26),set_value='Out Of Range'
    widget_control,info(23),set_value='Out Of Range'
 
    ;block out unwanted
    widget_control,info(11),sensitive=0
    widget_control,info(12),sensitive=0
    widget_control,info(14),sensitive=0
    widget_control,info(15),sensitive=0
    widget_control,info(17),sensitive=0
    widget_control,info(18),sensitive=0
    widget_control,info(27),sensitive=0
    widget_control,info(28),sensitive=0
    widget_control,info(29),sensitive=0

  endif else begin
    widget_control,info(25),set_value=val(0)
    widget_control,info(22),get_value=val1
    widget_control,info(23),set_value=string(val1*1e-7)

    ;block out unwanted
    widget_control,info(11),sensitive=1
    widget_control,info(12),sensitive=1
    widget_control,info(14),sensitive=1
    widget_control,info(15),sensitive=1
    widget_control,info(17),sensitive=1
    widget_control,info(18),sensitive=1
    for u=0,numblocks-1 do begin
     widget_control,info(27+u),sensitive=1
    endfor

    redrawparams
    ;drawplot
    redrawmain
   
  endelse
endif

;-------------------------------------------------
;block button 1 pressed
;-------------------------------------------------
if(ev eq 19) then begin

  ;save
  widget_control,info(22),get_value=a
  sres(0,currentblock)=a
  widget_control,info(25),get_value=a
  sres(1,currentblock)=a
  ;widget_control,info(11),get_value=a

  ;restore three slider bars
  currentblock=0
  qmin=minq(0) & qmax=maxq(0)

  vall=refresh()
  
  widget_control,info(11),set_slider_max=dis(1)*1e7,set_slider_min=dis(0)*1e7,set_value=disr(currentblock)*1e7
  widget_control,info(12),set_value=string(disr(currentblock))
  widget_control,info(14),set_slider_max=d(1)*1e7,set_slider_min=d(0)*1e7,set_value=dr(currentblock)*1e7
  widget_control,info(15),set_value=string(dr(currentblock))
  widget_control,info(17),set_slider_max=w(1)*1e7,set_slider_min=w(0)*1e7,set_value=wr(currentblock)*1e7
  widget_control,info(18),set_value=string(wr(currentblock)*30/!pi)
 
  widget_control,info(22),set_value=sres(0,currentblock)
  widget_control,info(23),set_value=string(sres(0,currentblock)*1e-7)
  widget_control,info(25),set_value=sres(1,currentblock)
  widget_control,info(26),set_value=string(sres(1,currentblock)*1e-7)
 
  widget_control,info(30),set_value='Sample Angle :'+string(sample_angle(currentblock))
  widget_control,info(31),set_value=string(currentblock+1)

  if currentblock eq 0 then begin
    widget_control,info(27),set_value='ACTIVE'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 1 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='ACTIVE'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 2 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='ACTIVE'
  endif

endif

 
;-------------------------------------------------
;block button 2 pressed
;-------------------------------------------------
if(ev eq 20) then begin
  
  ;save
  widget_control,info(22),get_value=a
  sres(0,currentblock)=a
  widget_control,info(25),get_value=a
  sres(1,currentblock)=a
  ;widget_control,info(11),get_value=a

  ;restore three slider bars
  currentblock=1
  qmin=minq(1) & qmax=maxq(1)

  vall=refresh()
  
  widget_control,info(11),set_slider_max=dis(1)*1e7,set_slider_min=dis(0)*1e7,set_value=disr(currentblock)*1e7
  widget_control,info(12),set_value=string(disr(currentblock))
  widget_control,info(14),set_slider_max=d(1)*1e7,set_slider_min=d(0)*1e7,set_value=dr(currentblock)*1e7
  widget_control,info(15),set_value=string(dr(currentblock))
  widget_control,info(17),set_slider_max=w(1)*1e7,set_slider_min=w(0)*1e7,set_value=wr(currentblock)*1e7
  widget_control,info(18),set_value=string(wr(currentblock)*30/!pi)
 
  widget_control,info(22),set_value=sres(0,currentblock)
  widget_control,info(23),set_value=string(sres(0,currentblock)*1e-7)
  widget_control,info(25),set_value=sres(1,currentblock)
  widget_control,info(26),set_value=string(sres(1,currentblock)*1e-7)

  widget_control,info(30),set_value='Sample Angle :'+string(sample_angle(currentblock))
  widget_control,info(31),set_value=string(currentblock+1) 
 
  if currentblock eq 0 then begin
    widget_control,info(27),set_value='ACTIVE'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 1 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='ACTIVE'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 2 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='ACTIVE'
  endif

endif

;-------------------------------------------------
;Block button 3 pressed
;-------------------------------------------------
if(ev eq 21) then begin
  
  ;save
  widget_control,info(22),get_value=a
  sres(0,currentblock)=a
  widget_control,info(25),get_value=a
  sres(1,currentblock)=a
  widget_control,info(11),get_value=a
  
  currentblock=2
  qmin=minq(2) & qmax=maxq(2)

  vall=refresh()
  
  widget_control,info(11),set_slider_max=dis(1)*1e7,set_slider_min=dis(0)*1e7,set_value=disr(currentblock)*1e7
  widget_control,info(12),set_value=string(disr(currentblock))
  widget_control,info(14),set_slider_max=d(1)*1e7,set_slider_min=d(0)*1e7,set_value=dr(currentblock)*1e7
  widget_control,info(15),set_value=string(dr(currentblock))
  widget_control,info(17),set_slider_max=w(1)*1e7,set_slider_min=w(0)*1e7,set_value=wr(currentblock)*1e7
  widget_control,info(18),set_value=string(wr(currentblock)*30/!pi)
 
  widget_control,info(22),set_value=sres(0,currentblock)
  widget_control,info(23),set_value=string(sres(0,currentblock)*1e-7)
  widget_control,info(25),set_value=sres(1,currentblock)
  widget_control,info(26),set_value=string(sres(1,currentblock)*1e-7)

  widget_control,info(30),set_value='Sample Angle :'+string(sample_angle(currentblock))
  widget_control,info(31),set_value=string(currentblock+1)

  if currentblock eq 0 then begin
    widget_control,info(27),set_value='ACTIVE'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 1 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='ACTIVE'
    widget_control,info(29),set_value='Block 3'
  endif
  if currentblock eq 2 then begin
    widget_control,info(27),set_value='Block 1'
    widget_control,info(28),set_value='Block 2'
    widget_control,info(29),set_value='ACTIVE'
  endif

endif


;-------------------------------------------------
;save button pressed
;-------------------------------------------------
if ev eq 30 then begin
  tmp=save_string+'.dat'
  openw,1,tmp

  ;-------------------------------------------------
  ;Distance from chopper to sample
  ;-------------------------------------------------
  tmp1=chopper_to_sample

  ;output block 1 to file

  for u=1,numblocks do begin

  
  printf,1,'BLOCK'+strtrim(string(u),2)

  ;DET is distance from SAMPLE to DETECTOR
  printf,1,'DET',string(disr(u-1)+(dr(u-1)/2)-tmp1)
  
  ;CMT is chopper separation
  printf,1,'CHT',string(dr(u-1))

  ;CS1 is rpm of chopper 1
  printf,1,'CS1',string(wr(u-1)*30/!pi)

  ;CS2 is rpm of chopper 2
  printf,1,'CS2',string(wr(u-1)*30/!pi)

  ;PHA is phase angle between chopper plates in degrees
  printf,1,'PHA',string(phil(u-1))

  ;SAM is sample angle of sample in degrees
  printf,1,'SAM',string(sample_angle(u-1))

  endfor

  close,1

  errormessage,'Data has been Saved','As',tmp
endif

return
end 





;*******************************************************************************************************
;* 				      Procedure DrawPLot
;*
;*This procedure draws the resolution vs q graph, and the resolution vs q/qmin
;*
;*
;*Variables (local)   :
;*
;*  ng                :Number of points used to draw the graph
;*  Tt()              :Contains the time resolution data points
;*  q                 :Contains the corrosponding q values
;*  gval              :contains the gfxs window reference
;*  rangelow          :Contains the lowest q value (in block 1)
;*  rangehigh         :Contains the hightest q value (in block 3)
;*  low               :Contains the time resolution maximum, from slider value, for current block
;*  high              :Contains the time resolution minimum, from slider value, for current block
;*  mm                :Contains value of the gradient
;*  cc                :Contains value of the intercept
;*  thetax(2)         :Contains value of minimum q and maximum q for a given block
;*  thetay(2)         :Contains value of minimum ang. res. and maximum ang. res. for a given block
;*  y                 :Contains value of minimum and maximum time resolution
;*  u                 :Counter in the for loop
;*  bcurrentblk       :Stores the orginal currentblock
;*  thick             :Contains a number representing the thickness of the line (1=normal, 2=double etc)
;*  ceiling           :highest value for the y axis
;*
;*******************************************************************************************************
;coool

pro drawplot

common graph
common qs
!p.multi=[0,0,0,0,0]
plot,[0,0],xstyle=5,ystyle=5
ceiling=0.
;--------------------------------------------------
;Set graphics window for output for resolution vs q
;--------------------------------------------------
;widget_control,draw,get_value=gval
;wset,gval

ng=51 
Tt=fltarr(ng) 
q=fltarr(ng) 
rangelow=minq(0)
rangehigh=maxq(numblocks-1)
bcurrentblk=currentblock
!p.multi=[2,1,2,0,1]
thick=2

;-------------------------------------------------
;Draw Block 1 in selected graphics window
;-------------------------------------------------
;draw the time resolution

low=sres(0,0)*1e-7
high=sres(1,0)*1e-7

;-------------------------------------------------
;Modify resolutions
;-------------------------------------------------

;-------------------------------------------------
;Draw Block 1 in the selected graphics window
;-------------------------------------------------

currentblock=0

;low=low-time_modification(minq(0),wr(0),disr(0))
;high=high-time_modification(maxq(0),wr(0),disr(0))

q=minq(0)+(findgen(ng)*(maxq(0)-minq(0))/(ng-1))
mm=(high-low)/(maxq(0)-minq(0))
cc=high-mm*maxq(0)
Tt=mm*q+cc
ceiling=sres(1,0)
if(numblocks gt 1) then ceiling=(sres(1,0)>sres(1,1))
if(numblocks gt 2) then ceiling=(ceiling>sres(1,2))
ceiling=ceiling*1e-7+.01

plot,q,Tt,xrange=[rangelow,rangehigh],yrange=[0,ceiling],/xstyle,/ystyle,xtitle="q",$
ytitle="Time And Angle Resolutions",title="Resolutions vs q",thick=thick
!p.multi=[2,1,2,0,1]
;draw the angular resolution
thetax=[minq(0),maxq(0)]
thetay=[angres(0),angres(0)]
plot,thetax,thetay,/noerase,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,color=2^15,thick=thick

;-------------------------------------------------
;Draw Block 2 in selected graphics window
;-------------------------------------------------
;draw time resolution

if(numblocks gt 1) then begin
  
  low=sres(0,1)*1e-7
  high=sres(1,1)*1e-7
  
  currentblock=1	

;  low=low-time_modification(minq(1),wr(1),disr(1))
;  high=high-time_modification(maxq(1),wr(1),disr(1))

  mm=(high-low)/(maxq(1)-minq(1))
  cc=high-mm*maxq(1)
  q=minq(1)+(findgen(ng)*(maxq(1)-minq(1))/(ng-1))
  Tt=mm*q+cc
  plot,q,Tt,/noerase,xstyle=5,ystyle=5,xrange=[rangelow,rangehigh],yrange=[0,ceiling],thick=thick
  
  ;draw angular resolution
  thetax=[minq(1),maxq(1)]
  thetay=[angres(1),angres(1)]
  plot,thetax,thetay,/noerase,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,color=2^15,thick=thick
  
endif


;-------------------------------------------------
;Draw Block 3 in selected graphics window
;-------------------------------------------------
;draw time resolution
if(numblocks gt 2) then begin
  
  low=sres(0,2)*1e-7
  high=sres(1,2)*1e-7
  
  currentblock=2	

;  low=low-time_modification(minq(2),wr(2),disr(2))
;  high=high-time_modification(maxq(2),wr(2),disr(2))

  mm=(high-low)/(maxq(2)-minq(2))
  cc=high-mm*maxq(2)
  q=minq(2)+(findgen(ng)*(maxq(2)-minq(2))/(ng-1))
  Tt=mm*q+cc
  plot,q,Tt,/noerase,xstyle=5,ystyle=5,xrange=[rangelow,rangehigh],yrange=[0,ceiling],thick=thick

  ;draw angular resolution
  thetax=[minq(2),maxq(2)]
  thetay=[angres(2),angres(2)]
  plot,thetax,thetay,/noerase,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,color=2^15,thick=thick
endif

;-------------------------------------------------------
;Set graphics window for output for resolution vs q/qmin
;------------------------------------------------------- 
;widget_control,draw2,get_value=gval
;wset,gval


;----------------------------------------------------
;Draw the time and angular resolutions for the blocks
;----------------------------------------------------     
for u=1,numblocks do begin

  currentblock=u-1   

  rangelow=minq(u-1)/minq(u-1) 
  rangehigh=maxq(u-1)/minq(u-1)
  low=sres(0,u-1)*1e-7
  high=sres(1,u-1)*1e-7
;  low=low-time_modification(minq(u-1),wr(u-1),disr(u-1))
;  high=high-time_modification(maxq(u-1),wr(u-1),disr(u-1))

  q=[rangelow,rangehigh]
  y=[low,high]

  if u eq 1 then begin
    ;draw time resolution 
    !p.multi=[1,1,2,0,1]
    plot,q,y,xrange=[rangelow,rangehigh],yrange=[0,ceiling],/xstyle,/ystyle,title='Resolutions vs q/qmin',xtitle='q/qmin',$
ytitle='Time and Angle Resolutions',thick=thick
    ;draw angular resolution
    !p.multi=[1,1,2,0,1]
    plot,q,[angres(0),angres(0)],color=2^15,xstyle=5,ystyle=5,yrange=[0,ceiling],$
xrange=[rangelow,rangehigh],/noerase,thick=thick
  endif else begin
    !p.multi=[1,1,2,0,0]
    ;draw time resolution
    plot,q,y,xrange=[rangelow,rangehigh],yrange=[0,ceiling],xstyle=5,ystyle=5,/noerase,thick=thick,linestyle=2^(u-1)
    ;draw angular resolution
    plot,q,[angres(u-1),angres(u-1)],color=2^15,xstyle=5,ystyle=5,yrange=[0,ceiling],xrange=[rangelow,rangehigh],/noerase,$
thick=thick,linestyle=2^(u-1)
  endelse
endfor

currentblock=bcurrentblk

return
end





;*************************************************************************************************
;* 				     Procedure ErrorMessage
;*
;*This procedure produces a window with a text message. mes1 is a string holding the first line
;*of text. mes2 is a string holding the second line of text. mes3 is a string holding the third
;*line of text.
;*
;*  Procedure parameters :
;*   
;*  mes1  : string of any lenght
;*  mes2  : string of any lenght
;*  mes3  : string of sny lenght
;*
;*  
;*
;*************************************************************************************************


pro errormessage,mes1,mes2,mes3
common error

errsnum=errsnum+1
if(errsnum eq 101) then errsnum=0

errbase(errsnum)=widget_base(title='MESSAGE WINDOW',/column)
mess1=widget_label(errbase(errsnum),value=mes1)
mess2=widget_label(errbase(errsnum),value=mes2)
mess3=widget_label(errbase(errsnum),value=mes3)
errbut=widget_button(errbase(errsnum),value='RETURN',uvalue=errsnum+300)

widget_control,/realize,errbase(errsnum)
xmanager,'error',errbase(errsnum)

return
end





;*************************************************************************************************
;*					 Procedure Error_event
;*
;*This procedure is called by 'xmanager' when a message window has been interacted with. The 
;*parameter -event- is a stucture that contains all the information about the widget that has
;*been interacted with.
;*
;* Parameters :
;*
;* event  : Structure
;*
;*
;* Variables (local)  :
;*
;* ev     :  Contains the user value of the interacted widget
;*************************************************************************************************


pro error_event,event
common error

widget_control,event.id,get_uvalue=ev
widget_control,errbase(ev-300),/destroy

return
end





;*************************************************************************************************
;*					  Function Lims
;*
;*This function does. (a) Produces the new limits of d, dis and w. (b) Produces the chopper angle
;*(c) Produces delta x.
;*
;* Paramters :
;*
;* rmin  : minimum time resolution for particular block
;* rmax  : maximum time resolution for particular block
;* qminn : minimum q value for particular block
;* qmaxx : maximum q value for particular block
;*
;* Variables (local) :
;*
;* tflag             :Stores the status of the limits of d,w and phi
;*                   :tflag is 0 :OK
;*                   :tflag is 1 :d's out of range
;*                   :tflag is 2 :w's out of range
;*                   :tflag is 3 :phi's out of range
;* dismin            :contains tempory used to work out new range for dis
;* dismax            :contains tempory used to work out new range for dis
;* dmin              :contains tempory used to work out new range for d
;* dmax              :contains tempory used to work out new range for d
;* flag              :contains tempory infomation used to set tflag
;* o                 :a constant used for convenience in calulations
;* wmin              :contains tempory used to work out new range for w
;* wmax              :contains tempory used to work out new range for w
;* velchop           :Stores the velocity of the chopper 
;* velbeam           :Stores the velocity of the beam
;* b                 :a constant used for convenience in calulations
;* h                 :a constant used for convenience in calulations
;*
;*
;*************************************************************************************************


function lims,rmin,rmax,qminn,qmaxx
common graph
common vars
common qs

;-------------------------------------------------
;Set default ranges to start with
;-------------------------------------------------
d=bd & dis=bdis & w=bw

;-------------------------------------------------
;By default nothing out of range yet
;-------------------------------------------------
tflag=0

;-------------------------------------------------
;obtain gradient and intercept
;-------------------------------------------------
m=(rmax-rmin)/(qmaxx-qminn)
c=rmax-m*qmaxx

;-------------------------------------------------
;obtain new d and dis ranges
;-------------------------------------------------
flag=0
dismin=dis(0) & dismax=dis(1)
dmin=d(0) & dmax=d(1)
dmin=c*dis(0)
if(dmin lt d(0)) then dmin=d(0) & dismin=dmin/c
if(dmin gt d(1)) then flag=1
dmax=c*dis(1)
if(dmax gt d(1)) then dmax=d(1) & dismax=dmax/c
if(dmax lt d(0)) then flag=1
if flag then begin
  tflag=1
  goto, trigger
endif else begin
  d(0)=dmin & d(1)=dmax
  dis(0)=dismin & dis(1)=dismax
endelse


;-------------------------------------------------
;obtain new w
;-------------------------------------------------
flag=0
o=2*!pi*k/lamda(1)
dismin=dis(0) & dismax=dis(1)
wmin=w(0) & wmax=w(1)
wmin=o/dis(1)
if(wmin lt w(0)) then wmin=w(0) & dismax=o/wmin
if(wmin gt w(1)) then flag=1
wmax=o/dis(0)
if(wmax gt w(1)) then wmax=w(1) & dismin=o/wmax
if(wmax lt w(0)) then flag=1
if flag then begin
  tflag=2
  goto,trigger
endif else begin
  dis(0)=dismin & dis(1)=dismax
  w(0)=wmin & w(1)=wmax
  d(0)=c*dis(0) & d(1)=c*dis(1)
endelse

;-------------------------------------------------
;obtain new chopper angle
;-------------------------------------------------
phil(currentblock)=2*!pi*m/((1/qminn)-(1/qmaxx))
phil(currentblock)=phil(currentblock)/!pi*180 
if ((phil(currentblock) gt phi(1)) or (phil(currentblock) lt phi(0))) then begin
        tflag=3
	goto,trigger
endif


;-------------------------------------------------
;Calculate delta x's RANGE
;-------------------------------------------------
;velchop=w*r
;velbeam=k/lamda(1)
;b=atan(rotate(velchop,2)/velbeam)
;x=d*sin(b)+phil(currentblock)*!pi/180*r
;-----------------------------------------------------------
;the beam width part
;(nb make sure x here is consistent with the deltax function
;-----------------------------------------------------------
;h=bob(s3v(currentblock),s2v(currentblock),90,chopper_width,slit_chopper_dist)
;x=x+h

trigger:
return, tflag
end






;*************************************************************************************************
;*					Procedure redrawparams
;*
;*
;*Procedure to Redraw the Ranges window. Thats all folks. 
;*
;*
;* Variables : (local)
;*
;* tmp       : Tempory variable 
;* vel       : Velocity of the neutrons
;* val       : Gives the time resolution at q half
;* mt        : Gradient of graph
;* ct        : Intercept of graph
;*
;*
;*(prgs note : call lims procedure before running this to ensure updated info)
;*
;*************************************************************************************************


pro redrawparams
common graph
common vars
common qs

widget_control,info(0),set_value='TOF Range  : '+string(dis(0))+'  '+string(dis(1))
widget_control,info(1),set_value='d Range    : '+string(d(0))+'  '+string(d(1))
widget_control,info(2),set_value='Rpms Range : '+string(w(1)*30/!pi)+'  '+string(w(0)*30/!pi)
widget_control,info(3),set_value='Chopper Ang: '+string(phil(currentblock))+'  '+string(phil(currentblock))
tmp=string(time_modification(minq(currentblock),wr(currentblock),disr(currentblock)))
tmp=tmp+'  '
tmp=tmp+string(time_modification(maxq(currentblock),wr(currentblock),disr(currentblock)))
widget_control,info(4),set_value='dtx/T      : '+tmp
widget_control,info(19),set_value='Chopper Angle:'+string(phil(currentblock))


;this is the calculation for the transmission or something proportional to it
mt=(sres(1,currentblock)*1e-7-sres(0,currentblock)*1e-7)/(maxq(currentblock)-minq(currentblock))
ct=sres(1,currentblock)*1e-7-mt*maxq(currentblock)

qhalf=(maxq(currentblock)-minq(currentblock))/2+minq(currentblock)

vel=k*qhalf/4/!pi/sin(sample_angle(currentblock)*!pi/180)

val=mt*qhalf+ct

tmp=wr(currentblock)/2./!pi*val*disr(currentblock)/vel

widget_control,info(45),set_value=string(tmp)

return
end






;*************************************************************************************************
;*				Procedure redrawmain
;*
;*This procedure centres the d, w and dis sliders
;*
;* Variables (local) :
;*
;* user1     :a constant used for convenience in calulations
;* user2     :a constant used for convenience in calulations
;* user3     :a constant used for convenience in calulations
;*
;*
;*
;*
;*
;* (Prgs note : delta x update here)  ***i think there is an error here***
;*************************************************************************************************


pro redrawmain
common graph
common vars
common qs

;-------------------------------------------------
;set some constants
;-------------------------------------------------
user1=(dis(1)-dis(0))/2+dis(0)
user2=(d(1)-d(0))/2+d(0)
user3=2*!pi*k/user1/lamda(1)

widget_control,info(12),set_value=string(user1)
widget_control,info(11),set_value=user1*1e7
disr(currentblock)=user1

widget_control,info(15),set_value=string(user2)
widget_control,info(14),set_value=user2*1e7
dr(currentblock)=user2

widget_control,info(18),set_value=string(user3*30/!pi)
widget_control,info(17),set_value=user3*1e7
wr(currentblock)=user3

return
end





;*************************************************************************************************
;*				     Function BOB
;*
;*This routine calculates the positions of illumination on a sample.
;*
;* Parameters  :
;*
;* s2          : Slit width (m)
;* s1          : Slit width (m)
;* th          : Sample angle (degrees)
;* sam         : sample lenght (m)
;* d2          : distance from slit to sample (m)
;*
;* Variables (local) :
;*
;* pi          : a contant containing Pi - here to make sure gives Exactly the same result
;*             : the fortran program
;* d1          : The distance between the slits (m)
;* amda        : Maximum wavelenght (1e10)
;* flag        : Contains 1 if there is neutron divergence otherwise 0
;* h           : Contains -1 if there is neutron divergence otherwise 0
;* 
;* (see bobs fortran program for details on this calulation and variables)
;*
;*
;* (Prgs note: slit references in the direction of the beam)
;*************************************************************************************************


function bob,s2,s1,th,sam,d2
common slitstuff
common qs


pi=3.1415926
d1=slit_separation
amda=30.
flag=0
th=th*pi/180 ; convert to radians
foot_print=sam*sin(th)


;-------------------------------------------------
;minimum s2 for under illimination
;-------------------------------------------------
s1min=((sam*sin(th)-s2)/((sam/2.)*cos(th)+d2))*d1-s2
;print,'Minimum mon slit for under illumination: ',s1min
div=.1*amda

if(s1 gt s2)then begin 
 fwhm=s1*180./(d1*pi)
endif else begin
 if(s2 ge s1)then begin
   fwhm=s2*180./(d1*pi)
 endif 
endelse
arange=2.*atan((s1+s2)/(2.*d1))
del=fwhm*pi/(th*180.)
arange=arange*180./pi
if(s1 ne s2)then begin
  x=d2-((d1*s2)/(s1-s2))
  w2=abs((s2*x)/(d2-x))
endif else begin
  w2=s1
  x=9999.
endelse
w1=s2+((d2*(s1+s2))/d1)
F=w2+(w1-w2)/2
if((arange/2.) gt div)then begin
  print,' Angular range limited by neutron divergence!'
  flag=1
endif

th1=atan((s1+s2)/(2.*d1))
if(s1 eq s2)then begin
 th2=0
endif else begin
  th2=atan(s2/(2.*(d2-x)))
endelse


;-------------------------------------------------
;Coordinates for the illumination of the slit
;-------------------------------------------------
rr1=(sam/2)+(w2/(2*cos(th)*(tan(th)+tan(th2))))
rr2=(sam/2)+(w1/(2*cos(th)*(tan(th)+tan(th1))))
ll1=(sam/2)-(w1/(2*cos(th)*(tan(th)-tan(th1))))
ll2=(sam/2)-(w2/(2*cos(th)*(tan(th)-tan(th2))))


if(flag eq 0) then begin
  ;half width at half maximum
  h=(rr1-ll2)+(ll2-ll1)/2+(rr2-rr1)/2
endif else begin
  h=-1
endelse

return,h
end





;*************************************************************************************************
;*				    Procedure base_event
;*
;*This procedure is called by the xmanager. It controls the events in the initial setup window.
;*
;* Parameters :
;* 
;* event      : Structure
;*
;* 
;* Variables  (local) :
;*
;* ev              : Stores the user value of the widget begin interacted with
;* val             : Stores the value of the widget itself.
;* q1,q2           : Stores the miniumum and maximum q values for whole range
;* qrange          : a constant that stores q2/q1
;* tmp, qtmp,junk  : tempory variables depends on context
;* u               : variable used for the counter in for loops
;* overlap,overlap1: contains the amount of shift due to the overlap parameter
;* sep             : contains slit separation
;* res             : contains angular resolution
;* dtheata         : contains delta theata
;* f               : contains new slider values for s2 and s3
;* w               : tempory variable
;*
;*
;*
;*************************************************************************************************


pro base_event,event
common qs
common graph
common vars

widget_control,event.id,get_uvalue=ev,get_value=val



banner=0
 
;-------------------------------------------------
;Quit button pressed
;-------------------------------------------------
if(ev eq 57) then begin
  widget_control,/reset
  qflag=1
endif

;-------------------------------------------------
;qmin changed
;-------------------------------------------------
if(ev eq 41)or(restart_flag eq 1) then begin
  if restart_flag eq 1 then begin
    restart_flag=0
    widget_control,wid(1),get_value=tmp
    val=float(tmp(0))
  endif
  
  widget_control,wid(3),get_value=qtmp
  q1=float(val(0))
  q2=float(qtmp(0))

  if(q1 lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q min should","not be","negative"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(17),sensitive=1
    banner=1
  endif 

  if(q1 gt q2) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q min should be","smaller than","q max"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif 

  qrange=q2/q1

  if(qrange gt 1000) then begin
    for u=0, widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errmessage,"q max should not be more than 3 factors of","wavelenght max/wavelenght min","away from q min"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  junk=check_math(1,1)
  if(qrange le qrangeb) and (qrange gt 0) then begin
    numblocks=1
    minq(0)=q1
    maxq(0)=q1*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
  endif
  if(qrange le qrangeb^2) and (qrange gt qrangeb) then begin
    numblocks=2
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
    junk=check_math(0,0)
  endif
  if(qrange le qrangeb^3) and (qrange gt qrangeb^2) then begin
    numblocks=3
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    overlap1=perover*(maxq(1)-minq(1))
    minq(2)=(q1*qrangeb-overlap)*qrangeb-overlap1
    maxq(2)=((q1*qrangeb-overlap)*qrangeb-overlap1)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
    sample_angle(2)=asin(lamda(1)*minq(2)/4/!pi)*180/!pi
  endif
  
  if check_math(0,0) ne 0 then begin
    sample_angle(0)=-1.
    sample_angle(1)=-1.
    sample_angle(2)=-1.
  endif

  ;display current block
  widget_control,wid(19),set_value=string(currentblock+1)

  ;set the q for the block
  widget_control,wid(7),set_value=string(minq(0))
  widget_control,wid(9),set_value=string(maxq(0))

  ;set sample angle
  widget_control,wid(28),set_value=string(sample_angle(currentblock))

  if(sample_angle(currentblock) gt 25)or(sample_angle(currentblock) lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"Sample Angle Exceeds","Bounds","Change Q Range"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  ;in radians
  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  ;convert to degrees
  dtheata=dtheata*180/!pi

  ;set the angular resolution widgets
  for u=1,numblocks do begin
    res=dtheata/sample_angle(u-1)
    widget_control,wid(44+u),set_value=string(res)
  endfor

  ;set the angular resolution widget to ready, if it is not needed
  if(numblocks ne 3) then begin
    for u=numblocks+1,3 do begin
      widget_control,wid(44+u),set_value='Ready'
    endfor
  endif

  if banner eq 0 then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=1
    endfor

    ;de-activate unused block buttons
    if(numblocks lt 3) then begin
      widget_control,wid(16),sensitive=0
    endif
    if(numblocks lt 2) then begin
      widget_control,wid(15),sensitive=0
    endif
  endif

  ;close down illumination graph if it is active
  if graph(3) eq 1 then graph  

  ;update foot print, and illumination values
  update_ftper
endif


;-------------------------------------------------
;qmax changed
;-------------------------------------------------
if(ev eq 43) then begin
  banner=0
  widget_control,wid(1),get_value=qtmp
  q2=float(val(0))
  q1=float(qtmp(0))

  if(q2 lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q max should","not be","negative"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(17),sensitive=1
    banner=1
  endif
 
  if(q1 gt q2) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q min should be","smaller than","q max"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  qrange=q2/q1

  if(qrange gt 1000) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"q max should not be more than 3 factors of","wavelenght max/wavelenght min","away from q min"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif

  junk=check_math(1,1)
  if(qrange le qrangeb) and (qrange gt 0) then begin
    numblocks=1
    minq(0)=q1
    maxq(0)=q1*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
  endif
  if(qrange le qrangeb^2) and (qrange gt qrangeb) then begin
    numblocks=2
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
  endif
  if(qrange le qrangeb^3) and (qrange gt qrangeb^2) then begin
    numblocks=3
    minq(0)=q1
    maxq(0)=q1*qrangeb
    overlap=perover*(maxq(0)-minq(0))
    minq(1)=q1*qrangeb-overlap
    maxq(1)=(q1*qrangeb-overlap)*qrangeb
    overlap1=perover*(maxq(1)-minq(1))
    minq(2)=(q1*qrangeb-overlap)*qrangeb-overlap1
    maxq(2)=((q1*qrangeb-overlap)*qrangeb-overlap1)*qrangeb
    sample_angle(0)=asin(lamda(1)*minq(0)/4/!pi)*180/!pi
    sample_angle(1)=asin(lamda(1)*minq(1)/4/!pi)*180/!pi
    sample_angle(2)=asin(lamda(1)*minq(2)/4/!pi)*180/!pi
  endif

  if check_math(0,0) ne 0 then begin
    sample_angle(0)=-1.
    sample_angle(1)=-1.
    sample_angle(2)=-1.
  endif

  ;display current block
  widget_control,wid(19),set_value=string(currentblock+1)

  ;set the q for the block
  widget_control,wid(7),set_value=string(minq(0))
  widget_control,wid(9),set_value=string(maxq(0))

  ;set sample angle
  widget_control,wid(28),set_value=string(sample_angle(currentblock))

  if(sample_angle(currentblock) gt 25)or(sample_angle(currentblock) lt 0) then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=0
    endfor
    errormessage,"Sample Angle Exceeds","Bounds","Change Q Range"
    widget_control,wid(1),sensitive=1    
    widget_control,wid(3),sensitive=1  
    widget_control,wid(28),sensitive=1
    widget_control,wid(17),sensitive=1
    banner=1
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))


  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  for u=1,numblocks do begin    
    res=dtheata/sample_angle(u-1)
    widget_control,wid(44+u),set_value=string(res)
  endfor

  ;blank out unused resolutions
  if(numblocks ne 3) then begin
    for u=numblocks+1,3 do begin
      widget_control,wid(44+u),set_value='Ready'
    endfor
  endif

  if banner eq 0 then begin
    for u=0,widmax do begin
      widget_control,wid(u),sensitive=1
    endfor

    ;blank out unneccesarry ones
    if(numblocks lt 3) then begin
      widget_control,wid(16),sensitive=0
    endif
    if(numblocks lt 2) then begin
      widget_control,wid(15),sensitive=0
    endif
  endif

  ;close down graph
  if graph(3) eq 1 then graph 

  update_ftper

endif

;-------------------------------------------------
;The s2 slider was moved
;-------------------------------------------------
if(ev eq 62) then begin
  ;update the text showing s2's value
  s2v(currentblock)=val*1e-7
  widget_control,wid(23),set_value=string(s2v(currentblock))
  if slit_lock eq 1 then begin
    s3v(currentblock)=s2v(currentblock)
    widget_control,wid(25),set_value=s3v(currentblock)*1e7
    widget_control,wid(26),set_value=string(s3v(currentblock))
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper  
endif

;-------------------------------------------------
;s3 slider was moved
;-------------------------------------------------
if(ev eq 65) then begin

  ;update text widget showing the value of s3
  s3v(currentblock)=val*1e-7
  widget_control,wid(26),set_value=string(s3v(currentblock))
  if slit_lock eq 1 then begin
    s2v(currentblock)=s3v(currentblock)
    widget_control,wid(22),set_value=s2v(currentblock)*1e7
    widget_control,wid(23),set_value=string(s2v(currentblock))
  endif
   
  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper

endif

;-------------------------------------------------
;text widget for s2 was altered
;-------------------------------------------------
if(ev eq 63) then begin

  ;update the slider s2
  val=long(val(0)*1e7)
  s2v(currentblock)=val*1e-7

  if s2v(currentblock) gt slit(1) then s2v(currentblock)=slit(1) 
  if s2v(currentblock) lt slit(0) then s2v(currentblock)=slit(0)
  widget_control,wid(23),set_value=string(s2v(currentblock))

  widget_control,wid(22),set_value=s2v(currentblock)*1e7
  if slit_lock eq 1 then begin
    s3v(currentblock)=s2v(currentblock)
    widget_control,wid(25),set_value=s3v(currentblock)*1e7
    widget_control,wid(26),set_value=string(s3v(currentblock))
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper 
endif 

;-------------------------------------------------
;the text widget for s3 was altered
;-------------------------------------------------
if(ev eq 66) then begin

  ;update the position of slider s3
  val=long(val(0)*1e7)
  s3v(currentblock)=val*1e-7

  if s3v(currentblock) gt slit(1) then s3v(currentblock)=slit(1) 
  if s3v(currentblock) lt slit(0) then s3v(currentblock)=slit(0)
  widget_control,wid(26),set_value=string(s3v(currentblock))

  widget_control,wid(25),set_value=s3v(currentblock)*1e7
  if slit_lock eq 1 then begin
    s2v(currentblock)=s3v(currentblock)
    widget_control,wid(22),set_value=s2v(currentblock)*1e7
    widget_control,wid(23),set_value=string(s2v(currentblock))
  endif  

  widget_control,wid(34),get_value=sep
  sep=float(sep(0))

  dtheata=(s2v(currentblock)>s3v(currentblock))/sep
  dtheata=dtheata*180/!pi

  res=dtheata/sample_angle(currentblock)
  widget_control,wid(45+currentblock),set_value=string(res)

  ;update graph if it is on
  if graph(3) eq 1 then begin
    updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
  endif

  update_ftper
endif 

;-------------------------------------------------
;Slit lock button was pressed
;-------------------------------------------------
if(ev eq 75) then begin
  slit_lock=(1-slit_lock)
  widget_control,wid(22),get_value=pos
  widget_control,wid(25),set_value=pos
  if slit_lock eq 0 then widget_control,wid(35),set_value='OFF'
  if slit_lock eq 1 then widget_control,wid(35),set_value='ON'  
endif


;-------------------------------------------------
;On of the block buttons was pressed
;-------------------------------------------------
for u=1,numblocks do begin
  if(ev eq 53+u) then begin    
    currentblock=u-1
    if (u-1) eq 0 then begin
      widget_control,wid(14),set_value='ACTIVE'
      widget_control,wid(15),set_value='Block 2'
      widget_control,wid(16),set_value='Block 3'
    endif
    if (u-1) eq 1 then begin
      widget_control,wid(14),set_value='Block 1'
      widget_control,wid(15),set_value='ACTIVE'
      widget_control,wid(16),set_value='Block 3'
    endif
    if (u-1) eq 2 then begin
      widget_control,wid(14),set_value='Block 1'
      widget_control,wid(15),set_value='Block 2'
      widget_control,wid(16),set_value='ACTIVE'
    endif
    widget_control,wid(7),set_value=string(minq(currentblock))
    widget_control,wid(9),set_value=string(maxq(currentblock))
    widget_control,wid(19),set_value=string(currentblock+1)
    widget_control,wid(28),set_value=string(sample_angle(currentblock))
    widget_control,wid(22),set_value=s2v(currentblock)*1e7
    widget_control,wid(23),set_value=string(s2v(currentblock))
    widget_control,wid(25),set_value=s3v(currentblock)*1e7
    widget_control,wid(26),set_value=string(s3v(currentblock))
    ;update graph
    if graph(3) eq 1 then begin
      ;update graph if it is on
      updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
    endif
    update_ftper
  endif
endfor

;-------------------------------------------------
;the graph button was pressed
;-------------------------------------------------
if(ev eq 88) then graph


;-------------------------------------------------------
;the level ang resolution button was pressed for block 1
;-------------------------------------------------------
if(ev eq 89) then begin
  
  for u=0,numblocks-2 do begin
    f=make_same(0,u+1)
    if(f eq -1) then begin
      errormessage,"Slider Values Can Not be Found","For A Block",""
    endif else begin
      
      widget_control,wid(45),get_value=num
      widget_control,wid(46+u),set_value=num

      if(currentblock eq u+1) then begin
        widget_control,wid(22),set_value=f*1e7
        widget_control,wid(25),set_value=f*1e7
        widget_control,wid(23),set_value=string(f)
        widget_control,wid(26),set_value=string(f)
      endif

      s2v(u+1)=f
      s3v(u+1)=f

    endelse
  endfor
endif

;-------------------------------------------------------
;the level ang resolution button was pressed for block 2
;-------------------------------------------------------
if numblocks gt 1 then begin
 if(ev eq 90) then begin

  for u=0,numblocks-2 do begin

    if(u eq 0) then w=0
    if(u eq 1) then w=2

    f=make_same(1,w)

    if(f eq -1) then begin
      errormessage,"Slider Values Can Not be Found","For A Block ",""
    endif else begin
      
      widget_control,wid(46),get_value=num
      widget_control,wid(45+w),set_value=num

      if(currentblock eq w) then begin
        widget_control,wid(22),set_value=f*1e7
        widget_control,wid(25),set_value=f*1e7
        widget_control,wid(23),set_value=string(f)
        widget_control,wid(26),set_value=string(f)
      endif

      s2v(w)=f
      s3v(w)=f

    endelse
  endfor
 endif
endif

;-------------------------------------------------------
;the level ang resolution button was pressed for block 3
;-------------------------------------------------------

if numblocks gt 2 then begin
 if(ev eq 91) then begin
  for u=0,numblocks-2 do begin
    w=u
    f=make_same(2,w)
    if(f eq -1) then begin
      errormessage,"Slider Values Can Not be Found","For A Block ",""
    endif else begin
     
      widget_control,wid(47),get_value=num
      widget_control,wid(45+w),set_value=num

      if(currentblock eq w) then begin
        widget_control,wid(22),set_value=f*1e7
        widget_control,wid(25),set_value=f*1e7
        widget_control,wid(23),set_value=string(f)
        widget_control,wid(26),set_value=string(f)
      endif

      s2v(w)=f
      s3v(w)=f

    endelse
  endfor
 endif
endif

;----------------------------------------------------------
;The > button was pressed to bring up the parameters window
;----------------------------------------------------------
if ev eq 97 then submenu

;-------------------------------------------------
;the next button was pressed
;-------------------------------------------------
if(ev eq 76) then begin  
  ;save some variable for next program
  ;resolutions delta theata over theata
 
  for u=1,numblocks do begin
    widget_control,wid(44+u),get_value=num
    angres(u-1)=float(num)
  endfor
  
  ;reset for next part of program
  widget_control,/reset
endif

ppass:
return
end






;*************************************************************************************************
;*				Procedure Graph 
;*
;*This procedure draw the illumination graph
;*
;* Variables (local) :
;*
;* x                 : holds the data for the x axis of the graph
;* y                 : holds the data for the y axis of the graph
;* h                 : hold the result from the bob() function
;* 
;*
;*
;*************************************************************************************************


pro graph
common qs
common vars
common graph

if(graph(3) eq 0) then begin
  h=bob(s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist)
  grp=widget_base(title='Illumination Graph',uvalue='grp')
  graph(0)=widget_draw(grp,xsize=600,ysize=550,yoffset=0,xoffset=0,retain=2)
  graph(1)=widget_button(grp,value="RETURN",xoffset=0,yoffset=551,uvalue=300,xsize=300)
  graph(2)=widget_button(grp,value="ReDraw",xoffset=300,yoffset=551,uvalue=301,xsize=300)
  graph(3)=1 ;graph on
  widget_control,grp,/realize
  xmanager,'grp',grp
  x=[ll1,ll2,rr1,rr2]
  y=[0,1,1,0]
  plot,x,y,thick=2,title='Illumination Of The Sample, block '+strtrim(string(currentblock+1),2),$
xtitle='Position',ytitle='Intensity',xrange=[0,sample_lenght],yrange=[0,1.1]
endif else begin
  graph(3)=0
  widget_control,grp,/destroy
endelse

return
end





;*************************************************************************************************
;*				Procedure updategraph
;*
;*This procedure updates the illumination graph  
;*
;* Parameters :
;*
;* s2         : holds the value of s2 (slit 2)
;* s3         : holds the value of s3 (slit 3)
;* sam        : holds the sample angle
;* samlen     : holds the sample lenght
;* slsamlen   : hold the distance from the slit to the sample
;*
;* Variables  :
;*
;* x          : holds the data for the x axis of the data
;* y          : holds the data for the y axis of the data
;* h          : holds the value of the bob() function
;*
;*
;*
;*************************************************************************************************


pro updategraph,s2,s3,sam,samlen,slsamlen
common qs
h=bob(s2,s3,sam,samlen,slsamlen)
if h eq -1 then print,'Procedure updategraph : bob() return -1 (neutron divergence)'
x=[ll1,ll2,rr1,rr2]
y=[0,1,1,0]
plot,x,y,thick=2,title='Illumination Of The Sample, block '+strtrim(string(currentblock+1),2),$
xtitle='Position',ytitle='Intensity',xrange=[0,sample_lenght],yrange=[0,1.1]
return
end





;*************************************************************************************************
;*				Procedure grp_event 
;*
;* Parameters :
;*
;* event      : holds information about the interacted widget (type: structure)
;*
;* Variables  :
;*
;* ev         : holds the value of the user value of the widget
;* val        : holds the actual value of the widget
;* x          : holds the x axis data for the graph
;* y          : holds the y axis data for the graph
;*
;*
;*
;************************************************************************************************* 


pro grp_event,event
common graph
common qs
common vars

widget_control,event.id,get_uvalue=ev,get_value=val


;-------------------------------------------------
;Return button was pressed
;-------------------------------------------------
if(ev eq 300) then begin
  graph(3)=0
  widget_control,grp,/destroy
endif

;-------------------------------------------------
;The redraw button was pressed
;-------------------------------------------------
if(ev eq 301) then begin
  h=bob(s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist)
  x=[ll1,ll2,rr1,rr2]
  y=[0,1,1,0]

;-------------------------------------------------
;plot graph
;-------------------------------------------------
plot,x,y,thick=2,title='Illumination Of The Sample, block '+strtrim(string(currentblock+1),2),$
xtitle='Position',ytitle='Intensity',xrange=[-.001,sample_lenght+.001],yrange=[0,1.1] 
endif   

return
end





;*************************************************************************************************
;*				    Procedure update_ftper
;*
;*This procedure updates the footprint and the illumination.
;*
;* Variables :
;*
;* p         : hold the illumination as a percentage
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************


pro update_ftper
common qs
h=bob(s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist)

;-------------------------------------------------
;updates the footprint
;-------------------------------------------------
widget_control,wid(55),set_value=string(foot_print)
;updates illumination
if(ll1 ge 0.) and (rr2 le sample_lenght) then begin
  widget_control,wid(38),set_value='Under'
endif else begin
  if(ll1 lt 0.)or(ll1 gt sample_lenght) then begin
    widget_control,wid(38),set_value='Over'
    ll1=0
  endif
  if(rr2 gt sample_lenght)or(rr2 lt 0.) then begin
    widget_control,wid(38),set_value='Over'
    rr2=sample_lenght
  endif
endelse

;-------------------------------------------------
;update the illumination
;-------------------------------------------------
p=(rr2-ll1)/sample_lenght*100
widget_control,wid(56),set_value=string(p)  
return
end





;*************************************************************************************************
;*				    Function Make_same
;*
;*This procedure attempts to make the angular resolutions the same by altering s2 and s3. 
;*
;*
;* Parameters :
;* 
;* indexa     : block number of the angular resolution to be copied to the other blocks
;* indexb     : block number of the angular resolution to be copied over
;* ang1       : sample angle of block with indexa (degrees)
;* ang2       : sample angle of block with indexb (degrees)
;* s21        : contains the slit value of s2 for block with indexa
;* s31        : contains the slit value of s3 for block with indexb
;* new_s      : this is the new slit value of slits s2 and s3 for block with indexb
;* 
;*
;*
;*
;*************************************************************************************************


function make_same,indexa,indexb
common qs

ang1=sample_angle(indexa)
ang2=sample_angle(indexb)

s21=s2v(indexa)
s31=s3v(indexa)

new_s=(s21>s31)*ang2/ang1

if(new_s gt .01) or (new_s lt 0) then new_s=-1

return,new_s
end





;*************************************************************************************************
;*				    Procedure submenu 
;*
;*This procedure creates the submenu window for the intial setup window when the > button
;*is pressed.
;*
;*
;*
;*
;*
;*
;*************************************************************************************************


pro submenu
  common qs
  common slitstuff

  if submenu(0) eq 0 then begin
    sub=widget_base(title='Parameters',uvalue='sub')
    submenu(1)=widget_label(sub,value='Sample Length    :',yoffset=5)
    submenu(2)=widget_text(sub,value=string(sample_lenght),xoffset=230,/editable,uvalue=202)
    submenu(3)=widget_label(sub,value='Slit Separation  :',yoffset=45)
    submenu(4)=widget_text(sub,value=string(Slit_separation),xoffset=230,/editable,uvalue=204,$
yoffset=40)
    submenu(5)=widget_label(sub,value='Slit Sample Dist :',yoffset=87)
    submenu(6)=widget_text(sub,value=string(slit_sample_dist),xoffset=230,/editable,uvalue=206,$
yoffset=80)

    submenu(7)=widget_label(sub,value='OverLap Parameter:',yoffset=127)
    submenu(8)=widget_text(sub,value=string(perover*100),uvalue=208,xoffset=230,yoffset=120,$
/editable)
    submenu(9)=widget_label(sub,value='%',xoffset=490,yoffset=127)

    submenu(10)=widget_button(sub,value='RETURN',xoffset=0,yoffset=210,xsize=510,uvalue=210)

    submenu(11)=widget_label(sub,value='Save Name       :',yoffset=173,xoffset=0)
    submenu(12)=widget_text(sub,value=save_string,/editable,uvalue=212,xoffset=230,yoffset=167)
    ;max=12
    
    submenu(0)=1 ; screen on
    widget_control,sub,/realize
    xmanager,'sub',sub

  endif else begin
    widget_control,sub,/destroy
    submenu(0)=0
  endelse
return
end





;*************************************************************************************************
;*				  Procedure sub_event 
;*
;* Paramters :
;*
;* event     : This contains the information of the interacted widget (Structure)
;*
;* 
;* Variables :
;*
;* ev        : This contains the uservalue for the widget that has been interacted with
;* val       : This contains the value of the widget that has been interacted with
;* tmp       : Holds the sample angle in radians
;* tmp1      : Holds the angular resolution
;*
;*
;*
;*
;*************************************************************************************************


pro sub_event,event
  common qs
  common slitstuff
  common graph
  widget_control,event.id,get_uvalue=ev,get_value=val
  
  ;-------------------------------------------------
  ;Sample lenght has been altered
  ;-------------------------------------------------
  if ev eq 202 then begin
    sample_lenght=float(val(0))
    update_ftper
    ;update graph if it is on
    if graph(3) eq 1 then begin
      updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
    endif
    widget_control,wid(30),set_value=string(sample_lenght)
  endif

  ;-------------------------------------------------
  ;Slit sepation has been altered
  ;-------------------------------------------------
  if ev eq 204 then begin
    slit_separation=float(val(0))
        for u=0,numblocks-1 do begin
      tmp=sample_angle(u)/180*!pi
      tmp1=(s2v(u)>s3v(u))/slit_separation/tmp
      widget_control,wid(45+u),set_value=string(tmp1)
    endfor
    widget_control,wid(34),set_value=string(val(0))
  endif 

  ;-------------------------------------------------
  ;Slit to sample distance has been changed
  ;-------------------------------------------------
  if ev eq 206 then begin
    slit_sample_dist=float(val(0))
    update_ftper
    if graph(3) eq 1 then begin
      ;update graph if it is on
      updategraph,s2v(currentblock),s3v(currentblock),sample_angle(currentblock),sample_lenght,slit_sample_dist
    endif
    widget_control,wid(32),set_value=string(val(0))
  endif
  
  ;-------------------------------------------------
  ;The overlap parameter has been changed
  ;-------------------------------------------------
  if ev eq 208 then begin
    perover=float(val(0))/100.
    restart_flag=1
  endif

  ;-------------------------------------------------
  ;The return button has been pressed
  ;-------------------------------------------------
  if ev eq 210 then begin
    submenu(0)=0
    widget_control,sub,/destroy
  endif

  ;-------------------------------------------------
  ;The save string has been changed
  ;-------------------------------------------------
  if ev eq 212 then begin
    save_string=strtrim(string(val(0)),2)
  endif
    
return
end





;*************************************************************************************************
;*				Function deltax
;*
;*This function returns the delta x value. It is important to note any changes to the formulae
;*for delta x must also be changed in the lims() procedure.THIS procedure returns a VALUE not
;*the RANGE of delta x. ce bon.
;*
;* Parameters :
;* xd         : This contains the chopper distance (m)
;* xw         : This contains the angular velocity (rad/s)
;* xl         : This contains lamda
;* xphil      : This contains the chopper phase angle (degrees)
;*
;*
;* Variables  :
;*
;* xx         : Contains deltax
;*
;*
;*************************************************************************************************


;function deltax,xd,xw,xl,xphil

;common graph
;common vars
;common qs

;-------------------------------------------------
;1st contribution to delta x
;-------------------------------------------------
;xx=xd*sin(atan(xw*r*xl/k))

;-------------------------------------------------
;2nd contribution to delta x
;-------------------------------------------------
;xx=xx+(xphil/180.)*!pi*r*cos(atan(xw*r*xl/k))


;second contribution is zero if phi is negative

;-------------------------------------------------
;3rd contribution to delta x
;-------------------------------------------------
;xx=bob(s3v(currentblock),s2v(currentblock),90,chopper_width,slit_chopper_dist)

;return,xx
;end





;*************************************************************************************************
;*				 function time_modification 
;*
;*This procedure calculates the modification to the time resolution entered by the user in the
;*'data window', window.
;*
;* Parameters :
;*
;* qq         : The q value in (amstrongs)^-1
;* ww         : The angular velocity of the choppers
;* disd       : The distance from the choppers to the detector
;*
;* Variables   :
;*
;* xx          : Contains the effect width of the choppers
;* tmp         : Variable used for ease in the calculations
;* tmp1        : Variable used for ease in the calculations
;* modification: Contains the modification to the time resolution
;*
;*************************************************************************************************


function time_modification,qq,ww,disd

common qs
common vars
common graph

;----------------------------------------------------------------------------------
;Calculates the full width at half maximum on the chopper, ie the effective delta x
;----------------------------------------------------------------------------------
xx=bob(s3v(currentblock),s2v(currentblock),90,chopper_width,slit_chopper_dist)

tmp=xx/ww/r

;print,xx,s2v(currentblock),s3v(currentblock),ww,r

tmp1=disd*4*!pi*sin(sample_angle(currentblock)*!pi/180)/qq/k

modification=tmp/tmp1

return, modification
end





;*************************************************************************************************
;*				  Function refresh 
;*
;*This procedure redraw the graphs, the range window the data window, basically everything.
;*This is required because changing any of the alterable parameters changes the effective 
;*resolution miniumum and maximum.
;*
;* Variables  : 
;*
;* sresb(2)   : Contains the modified time resolutions
;* err        : Contains the return of the function lims, 0 means no errors occured
;*
;*
;*
;*************************************************************************************************


function refresh
common vars
common qs
common graph
  
   ;calculate effective resolutions
   sresb=fltarr(2)
   
   sresb(0)=sres(0,currentblock)-time_modification(minq(currentblock),wr(currentblock),disr(currentblock))*1e7
   sresb(1)=sres(1,currentblock)-time_modification(maxq(currentblock),wr(currentblock),disr(currentblock))*1e7

   ;find new limits
   err=lims(sresb(0)*1e-7,sresb(1)*1e-7,minq(currentblock),maxq(currentblock))
   ;if err gt 0 then print, 'No ranges exist'

   if err eq 0 then begin
     ;change slider limits
     widget_control,info(11),set_slider_min=dis(0)*1e7,set_slider_max=dis(1)*1e7
     widget_control,info(14),set_slider_min=d(0)*1e7,set_slider_max=d(1)*1e7
     widget_control,info(17),set_slider_min=w(0)*1e7,set_slider_max=w(1)*1e7
   endif

   ;redraw the paramters window
   redrawparams 

   ;redraw graphs
   drawplot

   ;redraw delta x
   ;widget_control,info(20),set_value='dx           :'+string(deltax(dr(currentblock),wr(currentblock),lamda(1),phil(currentblock)))
  
return,err
end



;templates
  
;*************************************************************************************************
;* 
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*
;*************************************************************************************************

;-------------------------------------------------
;
;-------------------------------------------------

;
;************************************************ End Of File ************************************************
;
pro arne,first,last

XICUTE,"W1=RDRUN("+STRING(first)+")"
XICUTE,"W2=sumscan(1)"
XICUTE,"W3=W2"

FOR i=first+1,last DO BEGIN
  XICUTE,"W1=RDRUN("+STRING(i)+")"
  XICUTE,"W2=sumscan(1)"
  XICUTE,"W3=W3+W2"
ENDFOR
END
PRO makemicrostripplate,plate,charge

plate = INTARR(82176L)

FOR cell=0L,31L DO BEGIN

  cellpos = cell * 2568L

  FOR strip=0L,3L DO BEGIN
    
    strippos = cellpos + strip * 642L
    plate (strippos + 315L        : strippos + 315L +  12L        - 1L) =  1
    plate (strippos               : strippos + 145L               - 1L) = -1
    plate (strippos + 145L + 352L : strippos + 145L + 352L + 145L - 1L) = -1
    
  ENDFOR

  plate (cellpos               : cellpos        + 60L - 1L) = 0
  plate (cellpos + 2568L - 60L : cellpos + 2568L      - 1L) = 0

ENDFOR

index       = WHERE (plate NE 0, count)
charge      = LONARR (4, count)
charge(0,*) = FLOAT (index) 
charge(3,*) = plate (index) 
zerocharge, charge

ENDFUNCTION make_volume, Win,thresh=thresh
;******* ***********
;**
;**
s=SIZE(Win)
if s(0) ne 3 then return,Win

mx=max(Win,min=mi)
if n_elements(thresh) ne 1 then thresh=mi+(mx-mi)/6.
if (thresh lt mi) or (thresh gt mx) then return,Win

shade_volume,Win,thresh,v,p

v=reform(v,3,n_elements(v)/3)
TAKE_DATP,datp

x=reform(v(0,*)) & MOD_DATP,datp,'X',x
y=reform(v(1,*)) & MOD_DATP,datp,'Y',y
z=reform(v(2,*)) & MOD_DATP,datp,'Z',z

MOD_DATP,datp,'PV',p
MOD_DATP,datp,'PAR_TXT',['OBJECT: 1:Mol 2:Shape ','Thresh ']
MOD_DATP,datp,'P'      ,[               2.       , Thresh  ]
GIVE_DATP,datp
help,datp.x,datp.y,datp.z
return, x*0 +1
end
	FUNCTION man_mask, w_in0, box, xlines, ylines, add 

; creates a mask with manual input of beamstop limits and bad lines.

;						JRS 13/6/00

	iprint=1	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start man_mask:'

	ON_IOERROR, finished

	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspace

	x_in0=datp.x
	y_in0=datp.y
	z_in0=datp.z
	e_in0=datp.e
	par=datp.p
	parv=datp.pv
	se=SIZE(e_in0)
	sw=SIZE(w_in0)

	IF (sw(0) EQ 3) THEN nruns=sw(3) ELSE nruns=1
	IF (nruns EQ 1) THEN parv=par
	nspectra=sw(1)

	IF (N_ELEMENTS(skip) EQ 0) THEN skip=0

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'


;-------------------------------------------------------------------------------
;       Make mask

	IF(N_ELEMENTS(box) NE 4) THEN BEGIN
		PRINT, 'man_mask: Central beamstop position needs to be specified'
		GOTO, finished
	ENDIF

        boxxmin=box(0)
	boxxmax=box(1)
	boxymin=box(2)
	boxymax=box(3)

	IF (N_ELEMENTS(add) GT 0 AND add EQ 1) THEN BEGIN
		m_out=w_in0
		me_out=e_in0
	ENDIF ELSE BEGIN
		m_out=FLTARR(nspectra,nspectra)+1
		me_out=FLTARR(nspectra,nspectra)
	ENDELSE

	m_out(boxxmin:boxxmax,boxymin:boxymax)=0	& me_out(boxxmin:boxxmax,boxymin:boxymax)=-1
	IF(N_ELEMENTS(xlines) NE 0) THEN BEGIN
		m_out(xlines,*)=0	& me_out(xlines,*)=-1
	ENDIF
	IF(N_ELEMENTS(ylines) NE 0) THEN BEGIN
		m_out(*,ylines)=0	& me_out(*,ylines)=-1	
	ENDIF
	mx_out=x_in0
	my_out=y_in0

	IF (iprint GT 0) THEN PRINT,'End of "Create Mask" section'

;-------------------------------------------------------------------------------
;Write to mask file

	ispec=INDGEN(nspectra^2)+1

	numor=STRTRIM(STRING(LONG(datp.p(26))),2)
	title='Mask created from #'+numor

	IF (skip NE 0) THEN GOTO, dontsave

	out_file='mask_'+numor+'.dat'
	PRINT,'Writing mask file: ',out_file
	OPENW, 1, out_file
	PRINTF, 1, title
	PRINTF, 1, 'Spectrum     X	Y     1/0       0/-1'
	FOR i=0,nspectra-1 DO BEGIN
		FOR j=0,nspectra-1 DO BEGIN
			PRINTF, 1, FORMAT='(I7,1X,F5.1,1X,F5.1,2I4)', $
				ispec((j+1)+(i*nspectra)-1), mx_out(i), my_out(j), m_out(i,j), me_out(i,j)
		ENDFOR
	ENDFOR
	CLOSE, 1


dontsave:
	IF (iprint GT 0) THEN PRINT,'End of "Write to mask file" section'

;-------------------------------------------------------------------------------
;mask input data
	w_out=w_in0*m_out
	e_out=e_in0
	i=WHERE(w_out EQ 0, nz)
	e_out(i)=-1
	x_out=x_in0
	y_out=y_in0

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "e", e_out

	datp.w_tit=title
	datp.other_tit=datp.other_tit+' -manma'
	datp.y_tit='Intensity'

finished:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'End man_mask:'

	give_datp, datp

	RETURN, w_out
	END

pro matovr ,pw,px,py ,row=row,column=col,poly=poly,iso=thresh
;** ******
;Surface to VRML file "lamp.wrl" (D.Richard oct 96)

if n_elements(pw) lt 3 then return

s   =size(pw) & if s(0) eq 1 then begin s(2)=1 & poly=0 & endif
p=75. & d=1.
if keyword_set(poly) then d=3.
fmt='(f4.1)'


IF s(0) LT 3 THEN BEGIN
;**************************************************************************************************
;****************
;TWO DIMENSIONAL*
;****************
;****************

w=pw		 & if n_elements(px) lt s(1) then x=findgen(s(1)) else x=px
if s(0) eq 2 then  if n_elements(py) lt s(2) then y=findgen(s(2)) else y=py else y=1
sx=(size(x))(0) & sy=(size(y))(0)

;*******
;RESIZE*
;*******
rz=200 & if keyword_set(poly) then rz=100
n1=(s(1)/rz)>1 & n2=(s(2)/rz)>1
if  n1+n2 gt 2 then begin if s(0) eq 2  then w=congrid(w,s(1)/n1,s(2)/n2) else $
			  if n1   gt 1  then w=congrid(w,s(1)/n1)
			  if sx   eq 2  then x=congrid(x,s(1)/n1,s(2)/n2) else $
			  if n1   gt 1  then x=congrid(x,s(1)/n1)
			  if sy   eq 2  then y=congrid(y,s(1)/n1,s(2)/n2)
			  if n2   gt 1  then y=congrid(y,s(2)/n2)
			  endif
;**********
;NORMALIZE*
;**********
maxw=max( w,min=minw) &  maxx=max( x,min=minx) & maxy=max( y,min=miny)
w   =( w-minw)*p/d/(maxw-minw)
x   =( x-minx)*p  /(maxx-minx)
if s(0) gt 1 then y   =( y-miny)*p  /(maxy-miny) else y=0

;*******
;COLUMN*
;*******
if keyword_set(col) and (s(0) eq 2) then begin w=transpose(w) & a=x
			if sx eq 2  then x=transpose(y) else x=y
			if sy eq 2  then y=transpose(a) else y=a & endif

s  =size(w) & s1=s(1) & if s(0) eq 2 then s2=s(2) else s2=1L

;************
;DERIVATIVES*
;************
w   =fix(w/2*10)/10.*d
if s(0) eq 2		then wx=   (w-shift(w,1,0)) + (w-shift(w,-1,0))
if s(0) eq 1		then wx=   (w-shift(w,1))   + (w-shift(w,-1)) else $
if keyword_set(poly)	then begin
			     wx=wx+(w-shift(w,0,1)) + (w-shift(w,0,-1))
			     wx=(abs(wx)-.5)>0 & endif
wx(0,*)=1 & wx(s1-1,*)=1

;********************
;ASCII TRANSCRIPTION*
;********************
buf=strarr(3,s1*s2)
if sx lt 2 then xb =transpose(string(x,format=fmt)+' ')
if sy lt 2 then y  =string(y,format=fmt)+' '
if sy lt 2 then yb =strarr(1,s1)

;POLYGONS*
;*********
if keyword_set(poly) and (s(0) eq 2) then begin
   bof=strarr((s1-1)*4*s2/2)
   tr4=lonarr(3,4)+s1
   trs=[[0,-s1-1,-s1],[0,-1,-s1-1],[0,s1-1,-1],[0,s1,s1-1]]
   j=1L & p=0L
   WHILE j le s2-2 do begin
	 i=1L & trj=tr4*j & a1=s1*(j+1) & a2=s1*(j-1)
	 WHILE i le s1-1 do begin
	   k=i
	   while (k le s1-2) and (wx(k,j) eq 0) and (wx(k,j+1) eq 0) do k=k+1

	   if k eq i then begin t=strtrim(string(trj+trs+k),1)
				for q=0,3 do bof(p+q)=t(0,q)+','+t(1,q)+','+t(2,q)
				p=p+4

	   endif     else begin trq=strtrim(string([a1+k ,a1+i-1 ,a2+i-1 ,a2+k]),1)
				bof(p)=trq(0)+','+trq(1)+','+trq(2)+','+trq(3)
				p=p+1
	   			endelse
	   i=k+1
	 ENDWHILE
	 for k=j-1,j do begin q=k*s1
	     if sx eq 2 then xb   =transpose(string(x(*,k),format=fmt)+' ')
	     if sy eq 2 then yb   =transpose(string(y(*,k),format=fmt)+' ') $
		        else yb(*)=y(k)
	     buf(0,q)=xb
	     buf(1,q)=yb
	     buf(2,q)=transpose(string(w(*,k),format=fmt))+','
	 endfor
	 j=j+2
   ENDWHILE
   for k=j-1,j-1+s2-j do begin q=k*s1
	     if sx eq 2 then xb   =transpose(string(x(*,k),format=fmt)+' ')
	     if sy eq 2 then yb   =transpose(string(y(*,k),format=fmt)+' ') $
		        else yb(*)=y(k)
	     buf(0,q)=xb
	     buf(1,q)=yb
	     buf(2,q)=transpose(string(w(*,k),format=fmt))+','
   endfor
   if j lt s2 then begin trj=lonarr(3,2)+s1*j & trs=trs(*,0:1)
	     for i=1,s1-1 do begin t=strtrim(string(trj+trs+i),1)
				   for q=0,1 do bof(p+q)=t(0,q)+','+t(1,q)+','+t(2,q)
				   p=p+2
	     endfor & endif
   bof=bof(0:p-1)+',-1,'

;LINES*
;******
endif else begin
  bof=strarr(2,s1*s2)
  a  =indgen(1,s1-1)
  i  =0L
  FOR j=0L,s2-1 do begin idx=where(wx(*,j) ne 0)
			 n  =n_elements(idx)
			 if sx eq 2 then xb   =transpose(string(x(*,j),format=fmt)+' ')
			 if sy eq 2 then yb   =transpose(string(y(*,j),format=fmt)+' ') $
				    else yb(*)=y(j)
			 buf(0,i)=xb(0,idx)
			 buf(1,i)=yb(0,idx)
			 buf(2,i)=transpose(string(w(idx,j),format=fmt))+','
			 a	 =indgen(1,n-1)+i
			 bof(0,i)=strtrim(string(a)  ,1)+','
			 bof(1,i)=strtrim(string(a+1),1)+','
			 i=i+n
			 bof(1,i-1)=bof(1,i-1)+'-1,' &  ENDFOR
  buf=buf(*,0:i-1)
  bof=bof(*,0:i-1)
endelse

ENDIF ELSE BEGIN
;**************************************************************************************************
;******************
;THREE DIMENSIONAL*
;******************
;******************
buf='' & bof=''
if n_elements(thresh) ne 1 then begin maxw=max(pw,min=minw) & thresh=minw+(maxw-minw)/3 & endif
shade_volume, pw  ,thresh,v,po

sp=n_elements(po)
if sp gt 3 then begin
;**********
;NORMALIZE*
;**********
   sv =size(v) & maxv=max(v(0,*),min=minv) & v(0,*)=transpose((v(0,*)-minv)*p*10/(maxv-minv))
		 maxv=max(v(1,*),min=minv) & v(1,*)=transpose((v(1,*)-minv)*p*10/(maxv-minv))
		 maxv=max(v(2,*),min=minv) & v(2,*)=transpose((v(2,*)-minv)*p*10/(maxv-minv))
   v   =round(v)
   bof=strarr(sp/3)
   buf=strarr(3,sv(2))
   buf(0,*)=strtrim(string(v(0,*)),1)+' '
   buf(1,*)=strtrim(string(v(1,*)),1)+' '
   buf(2,*)=strtrim(string(v(2,*)),1)+','
   i=0L & k=0L
   WHILE i lt sp do begin
	 j=po(i) & str=''
	 for n=i+1,i+j do str=str+strtrim(string(po(n)),1)+','
	 bof(k)=str
	 i=i+j+1 & k=k+1
   ENDWHILE
   bof=bof(0:k-1)+'-1,'
endif
ENDELSE

;**************************************************************************************************
;***********
;WRITE VRML*
;***********
;***********
head='#VRML V1.0 ascii'
tail='}'

ON_IOERROR,prob
OPENW,u,'lamp.wrl',/get_lun

PRINTF,u,head
PRINTF,u,'Separator {'

PRINTF,u,'DirectionalLight { direction 0  0 -1  }'
PRINTF,u,'PointLight       { location  0  0 200 }'

 PRINTF,u,'Material  { ambientColor    .4 0. 0.'
if keyword_set(poly) then $
 PRINTF,u,'            diffuseColor    .6 .6 .1' else $
 PRINTF,u,'            diffuseColor    1. 0. 0.'
 PRINTF,u,'            specularColor   1. 0. 0.'
if keyword_set(poly) then $
 PRINTF,u,'            emissiveColor   .6 0. 0.' else $
 PRINTF,u,'            emissiveColor   1. 0. 0.'
 PRINTF,u,'            shininess       1.'
 PRINTF,u,'            transparency    0. }'

PRINTF,u,'MaterialBinding { value OVERALL }'

;PRINTF,u,'SpotLight { on TRUE'
;PRINTF,u,'            intensity 1.'
;PRINTF,u,'            color     1. 1. 1.'
;PRINTF,u,'            location  0  0 300'
;PRINTF,u,'            direction 0  0 -1 }'

PRINTF,u,'DEF Surface Separator {'

PRINTF,u,'DEF SurfCoord Coordinate3 { point ['
PRINTF,u,buf
PRINTF,u,']}'

if keyword_set(poly) then PRINTF,u,'IndexedFaceSet { coordIndex [' $
		     else PRINTF,u,'IndexedLineSet { coordIndex ['
PRINTF,u,bof
PRINTF,u,']}'

PRINTF,u,tail & PRINTF,u,tail

FREE_LUN,u
prob:
end
Function maxlike,w,jmax,pj=p,i=i,prob=prob,dx=dx,x=x,sigma=sigma,e=e

window,1
N=n_ELEMENTS(w)
;print,jmax
likelihood=FLTARR((N-1)<jmax)
x=FLTARR(N)
dx=x
p=x
sigma=x
FOR j=3,N-2 DO BEGIN
  x(j)=mode(w,j,pj=pj,i=i,/plot)
  p(j)=pj
  dx(j)=w(i+j)-w(i)
  ;print, j, x(j),p(j), dx(j),i,w(i+j),w(i)
ENDFOR
maxi=0
;print,LONG(3),jmax,N-1
FOR j=LONG(3),(jmax<(N-1))-1 DO BEGIN
  likelihood(j)=1
  FOR k=3, (N-2) DO BEGIN
    if (k NE j) THEN BEGIN
      likelihood(j)=likelihood(j)*igamma(k,j*dx(k)/dx(j))
      ;print ,k,j,dx(k),dx(j),j*dx(k)/dx(j),igamma(k,j*dx(k)/dx(j)),likelihood(j)
    endif
  ENDFOR
   print, j,likelihood(j),x(j) ;,sigma(j)
  if (likelihood(j) GT maxi) THEN BEGIN
    maxi=likelihood(j)
    best=j
  endif
ENDFOR
j=best
x(j)=mode(w,j,pj=pj,i=i,/plot,prob=prob,e=e,s=sigma)
p(j)=pj
dx(j)=w(i+j)-w(i)
print, " "
print, j,likelihood(j),x(j) ;,sigma(j),p(j)
x1=(e(i)+e(i-1))/2.
x2=(e(i)+e(i+1))/2.
y1=(alog(prob(i))-alog(prob(i-1)))/(e(i)-e(i-1))
y2=(alog(prob(i+1))-alog(prob(i)))/(e(i+1)-e(i))
;print,e(i-1),prob(i-1),alog(prob(i-1))
;print,e(i),prob(i),alog(prob(i))
;print,e(i+1),prob(i+1),alog(prob(i+1))
;print,x1,y1
;print,x2,y2
;print,(y2-y1)/(x2-x1)
print,1./SQRT(-(y2-y1)/(x2-x1)),j,1./SQRT(-(y2-y1)/(x2-x1))/SQRT(j)

end 
FUNCTION med, w
;********
;**
;** The call is w6=med(...)
Wout=w(*,0)
FOR i=0,N_ELEMENTS(w(0,*)) DO BEGIN
	Wout(i)=median(w(i,*))
ENDFOR
return, Wout
end
Function merg2theta,wn,nosum=nosum

;+
; Merge twotheta scan of n steps
; W1 = merg2theta (2)
; Function
; Parameters
;   Number of workspace to be merged
; Output
;   Workspace containing merged diagram
;-

COMMON C_LAMP_INFO 

IF N_ELEMENTS(wn) GT 1 THEN BEGIN
  n=two
ENDIF
IF N_ELEMENTS(wn) EQ 1 THEN n=wn
IF N_ELEMENTS(n) EQ 1 THEN BEGIN
  take_w,w,w=n
  take_datp,d,w=n
  e=d.e
  n=d.n
  x=d.x
  IF N_ELEMENTS(w(0,*)) GT 2 THEN BEGIN
    ;############# Normalisation #############
    norm=TOTAL(d.n(0,0,*))/N_ELEMENTS(d.n(0,0,*))
    FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
      w(*,i)  =  w(*,i)*norm/d.n(0,0,i)
      e(*,i)  =  e(*,i)*norm/d.n(0,0,i)
      n(*,*,i)=n(*,*,i)*norm/d.n(0,0,i)
    ENDFOR
    ;############# 2Theta ####################
    delta=(10.*d.x(0,*)-FLOOR(10.*d.x(0,*)))/10.
    ;print,REFORM(delta)
    ;print,MEDIAN(delta),TOTAL(delta)/N_ELEMENTS(d.x(0,*))
    test=ABS(median(delta)-total(delta)/N_ELEMENTS(d.x(0,*)))
    delta=(10.*(d.x(0,*)-.05)-FLOOR(10.*(d.x(0,*)-.05)))/10.
    ;print,REFORM(delta+.05)
    ;print,MEDIAN(delta+.05),total(delta+.05)/N_ELEMENTS(d.x(0,*))
    IF test LT ABS(median(delta+.05)-total(delta+.05)/N_ELEMENTS(d.x(0,*))) THEN BEGIN
      delta=(10.*d.x(0,*)-FLOOR(10.*d.x(0,*)))/10.
      delta=MEDIAN(delta)
    ENDIF ELSE BEGIN
      delta=MEDIAN(delta+.05)
      delta=((10.*delta)-FLOOR(10.*delta))/10.
    ENDELSE
    PRINT,delta
    xrange=[FLOOR(min(d.x))+delta,CEIL(max(d.x))+delta]
    x=0
    e=0
    y=0
    IF NOT KEYWORD_SET(nosum)  THEN BEGIN
     FOR i=xrange(0),xrange(1),0.1 DO BEGIN
      index=WHERE(d.x GE i-.05 AND d.x LT i+.05,count)
      IF count GT 0 THEN BEGIN
        tmp_w=  w(index)
        tmp_m=MEDIAN(tmp_w)
        tmp_e=d.e(index)
        tmp_i=WHERE(ABS(tmp_w-tmp_m) LE 3.*tmp_e,count)
        IF count GT 0 THEN index=index(tmp_i)
      ENDIF
      IF count GT 0 THEN BEGIN
        x=[x,i]
        
        y=[y,TOTAL(w(index))/count]
        e=[e,y(N_ELEMENTS(y)-1)/SQRT(TOTAL(w(index)^2/d.e(index)^2))] 
      ENDIF
     ENDFOR
     x=x[1:N_ELEMENTS(x)-1]
     w=y[1:N_ELEMENTS(y)-1]
     e=e[1:N_ELEMENTS(e)-1]
    ENDIF
  ENDIF ELSE PRINT,'WorkSpace should be a 2theta scan of >2 steps'
ENDIF ELSE PRINT,'WorkSpace Numbers missing'
IF KEYWORD_SET(nosum) THEN BEGIN
    index=SORT(d.x)
    w=w(index)
    e=d.e(index)
    x=d.x(index)
ENDIF
mod_datp,d,'e',e
mod_datp,d,'x',x
give_datp,d
RETURN,w
END
Function mergd20,wn,nosum=nosum,nointerpolation=noint,threshold=thresh,$
                    sdev=sdev,noprint=noprint,bad=bad,mult=bad_mult,bin=bin,$
                    norm=norm,datp=datp,min_count=min_count
                    

;+
; Merge twotheta scan of n steps (PSD cell width must be 0.1 deg!)
; W1 = mergd20 (W2,/nosum)
; Function
; Parameters
;   Number of workspace to be merged 
; Keywords
;   NOSUM : no sum ...
; Output
;   Workspace containing merged diagram
;-

COMMON C_LAMP_INFO 

bad_mult=INTARR(1600)
IF NOT KEYWORD_SET(bin) THEN bin=.05 ELSE bin=bin/2.
IF NOT KEYWORD_SET(thresh) THEN thresh=3.
IF N_ELEMENTS(wn) GT 1 THEN BEGIN
  n=two
ENDIF
IF N_ELEMENTS(wn) EQ 1 THEN n=wn
workspace_number=n
IF N_ELEMENTS(n) EQ 1 THEN BEGIN
  IF NOT KEYWORD_SET(datp) THEN take_w,w,w=n ELSE w=wn
  IF NOT KEYWORD_SET(datp) THEN take_datp,d,w=n ELSE d=datp
  e=d.e
  n=d.n
  x=d.x
  scans=N_ELEMENTS(d.x(0,*))
  cells=N_ELEMENTS(d.x(*,0))
  IF N_ELEMENTS(w(0,*)) GT 2 THEN BEGIN
    ;############# Normalisation #############
    norm=TOTAL(d.n(0,0,*))/N_ELEMENTS(d.n(0,0,*))
    time=TOTAL(d.n(0,1,*))/N_ELEMENTS(d.n(0,1,*))
    FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
      w(*,i)  =  w(*,i)*norm/d.n(0,0,i)
      e(*,i)  =  e(*,i)*norm/d.n(0,0,i)
      n(*,*,i)=n(*,*,i)*norm/d.n(0,0,i)
    ENDFOR
    ;############# 2Theta ####################
    delta=(10.*d.x(0,*)-FLOOR(10.*d.x(0,*)))/10.
    test=ABS(median(delta)-total(delta)/N_ELEMENTS(d.x(0,*)))
    delta=(10.*(d.x(0,*)-.05)-FLOOR(10.*(d.x(0,*)-.05)))/10.
    IF test LT ABS(median(delta+.05)-total(delta+.05)/N_ELEMENTS(d.x(0,*))) THEN BEGIN
      delta=(10.*d.x(0,*)-FLOOR(10.*d.x(0,*)))/10.
      delta=MEDIAN(delta)
      x=FLOOR(10.*d.x)/10.+delta
      print,'+ ','Delta: ',delta
    ENDIF ELSE BEGIN
      delta=MEDIAN(delta+.05)
      delta=((10.*delta)-FLOOR(10.*delta))/10.
      x=FLOOR(10.*(d.x-.05))/10.+delta
      print,'- ','Delta: ',delta
    ENDELSE
    FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN
        IF ABS(d.x(0,i)-x(0,i)) GE bin THEN BEGIN
          IF NOT KEYWORD_SET(noint) THEN BEGIN
            PRINT,'Step',STRCOMPRESS(i),' outside limit, interpolated: ' ,d.x(0,i),x(0,i)
            w(*,i)=INTERPOL(w(*,i),d.x(*,i),x(*,i))
            d.e(*,i)=INTERPOL(d.e(*,i),d.x(*,i),x(*,i))
            d.x(*,i)=x(*,i)
          ENDIF ELSE PRINT,'Step',STRCOMPRESS(i),' outside limit, rejected: ' ,d.x(0,i),x(0,i) 
        ENDIF ;ELSE   PRINT,'Step',STRCOMPRESS(i),' inside limit: ' ,d.x(0,i),x(0,i) 
    ENDFOR  
    xrange=[FLOOR(10.*min(d.x))/10.+delta,CEIL(10.*max(d.x))/10.+delta]
    x=0
    e=0
    y=0
    IF NOT KEYWORD_SET(min_count) THEN BEGIN
      IF KEYWORD_SET(sdev) THEN min_count=2 ELSE min_count=1  
    ENDIF ELSE BEGIN
      IF KEYWORD_SET(sdev) THEN min_count=min_count>2 ELSE min_count=min_count>1
    ENDELSE 
    IF NOT KEYWORD_SET(nosum)  THEN BEGIN
      FOR i=xrange(0),xrange(1),0.1 DO BEGIN
        index=WHERE(d.x GE i-bin AND d.x LT i+bin,count)
        IF count GT 0 THEN BEGIN
          tmp_w = w(index)
          tmp_m = MEDIAN(tmp_w)
          tmp_e = d.e(index)
          tmp_i= WHERE(ABS(tmp_w-tmp_m) LE thresh*tmp_e,count)
          tmp_n= WHERE(ABS(tmp_w-tmp_m) GT thresh*tmp_e,count_n)
          IF count EQ 1 THEN BEGIN
            tmp=min(tmp_w(WHERE(tmp_w GE tmp_m))-tmp_m,tmp_pos)
            tmp=max(tmp_w(WHERE(tmp_w LE tmp_m))-tmp_m,tmp_neg)
            tmp_i= [tmp_pos,tmp_neg]
            count=2
            ;tmp_n= WHERE(index NE tmp_pos AND index NE tmp_neg,count_n)
          ENDIF 
          IF count_n GT 0 THEN BEGIN
            index_n=index(tmp_n)
            new_bad=ROUND(10*(d.x(index_n/scans,index_n/cells)-d.x(0,index_n/cells)))
            bad_mult(new_bad)=bad_mult(new_bad)+1
            IF N_ELEMENTS(bad) LT 1 THEN BEGIN
              bad=new_bad
            ENDIF ELSE BEGIN
              bad=[bad,new_bad]
            ENDELSE    
          ENDIF    
          IF count GT 0 THEN index=index(tmp_i)
        ENDIF
        IF count GE min_count THEN BEGIN
          tmp_0=TOTAL(w(index)^2/d.e(index)^2)
          IF tmp_0 GT 0 THEN BEGIN
            mean=TOTAL(w(index))/count
            x=[x,i]
            y=[y,mean]
            IF count GT 1 THEN BEGIN
              sdev=SQRT(TOTAL((w(index)-mean)^2))/((count-1)>1)
            ENDIF ELSE sdev=mean/SQRT(TOTAL(w(index)^2/d.e(index)^2))
            tmp_0=mean/SQRT(tmp_0>0)
            IF NOT KEYWORD_SET(noprint) THEN BEGIN
              print,i,mean,count,sdev,tmp_0
            ENDIF
            IF KEYWORD_SET(sdev) THEN e=[e,sdev] ELSE BEGIN
              e=[e,tmp_0] 
            ENDELSE
          ENDIF
        ENDIF
      ENDFOR
      x=x[1:N_ELEMENTS(x)-1]
      w=y[1:N_ELEMENTS(y)-1]
      e=e[1:N_ELEMENTS(e)-1]
    ENDIF
  ENDIF ELSE PRINT,'WorkSpace should be a 2theta scan of at least 2 steps'
ENDIF ELSE PRINT,'WorkSpace Numbers missing'
IF KEYWORD_SET(nosum) THEN BEGIN
  index=SORT(d.x)
  w=w(index)
  e=d.e(index)
  x=d.x(index)
ENDIF
bad=bad(sort(bad))
bad=bad(uniq(bad))
bad=bad(sort(bad_mult(bad)))
new_bad=[bad,bad]
nb_bad=N_ELEMENTS(bad)
new_bad(INDGEN(nb_bad)*2)=bad
new_bad(INDGEN(nb_bad)*2+1)=bad_mult(bad)
PRINT,STRCOMPRESS(N_ELEMENTS(where(bad_mult eq max(bad_mult))),/RE),' cells are',STRCOMPRESS(max(bad_mult)),' of',STRCOMPRESS(scans),' times excluded : '
print,STRCOMPRESS(where(bad_mult eq max(bad_mult)))
d.w_tit=d.w_tit+' - merged W'+STRCOMPRESS(workspace_number,/RE)+STRCOMPRESS(ROUND(norm))
mod_datp,d,'e',e
mod_datp,d,'x',x
mod_datp,d,'n',[[norm,time,0]]
IF NOT KEYWORD_SET(datp) THEN give_datp,d ELSE datp=d
RETURN,w
END
PRO merge,w,n,norm=norm,help=help

IF KEYWORD_SET(help) THEN BEGIN
  print,''
  print,'                         PRO Merge.PRO'
  print,''
  print,'LAMP-IDL Macro (Procedure) started: 03-Nov-97 by Th.Hansen, ILL-Grenoble (D20)'
  print,'Modification of a workspace w, merging each n single diagrams together'
  print,'Usefull tool to regroup thermodiffractometries where counting times were too short'
  print,'Afterwards the workspace w contains n times less single diagrams'
  print,'Monitor normalisation to the common monitor counting rate of the original workspace may be done by choosing the keyword norm'
ENDIF

take_datp,datp
n=ceil(n)>1
n=     n <N_ELEMENTS(w(0,*))
IF KEYWORD_SET(norm) THEN IF datp.n(0,0,0) EQ datp.n(0,0,N_ELEMENTS(w(0,*))-1) THEN norm=datp.n(0,0)
ww=     w   (*,0:N_ELEMENTS(w(0,*))/n-1)
ee=datp.e   (*,0:N_ELEMENTS(w(0,*))/n-1)
nn=datp.n (*,*,0:N_ELEMENTS(w(0,*))/n-1)
pv=datp.pv  (*,0:N_ELEMENTS(w(0,*))/n-1)
yy=datp.y   (  0:N_ELEMENTS(w(0,*))/n-1)
datp.other_tit=datp.other_tit+' merg'+STRING(n)
FOR i=0,N_ELEMENTS(w(0,*))/n-1 DO BEGIN
  ww   (*,i)=     TOTAL     (w  (*,  i*n:(i+1)*n-1),  2)
  ee   (*,i)=SQRT(TOTAL(datp.e  (*,  i*n:(i+1)*n-1)^2,2))
  pv   (*,i)=           datp.pv (*,  i*n)
  yy   (  i)=           datp.y  (    i*n)
  nn (0,0,i)=     TOTAL(datp.n  (0,0,i*n:(i+1)*n-1))
  nn (0,1,i)=     TOTAL(datp.n  (0,1,i*n:(i+1)*n-1))
  pv   (5,i)=     TOTAL(datp.pv (5,  i*n:(i+1)*n-1))
  pv  (30,i)=     TOTAL(datp.pv(30,  i*n:(i+1)*n-1))
  IF KEYWORD_SET(norm) THEN BEGIN
    ww(*,i)=ww(*,i)/nn(0,0,i)*norm
    ee(*,i)=ee(*,i)/nn(0,0,i)*norm
    nn(0,0,i)      =norm
  ENDIF
ENDFOR
datp.p( 5)=TOTAL(datp.pv( 5,*))
datp.p(30)=TOTAL(datp.pv(30,*))
mod_datp,datp,'e', ee
mod_datp,datp,'y', yy
mod_datp,datp,'n', nn
mod_datp,datp,'pv',pv
w=ww
give_datp,datp
END
FUNCTION mib_group,w_in
;** ***************************************************************** **;
;** S. Rols 11/01 srols@anl.gov                                       **;
;** The call is w6=mib-grouping(...)                                  **;
;** This program performs a grouping of different angles of mibemol   **;
;** data using the classical scheme in defining 10 different groups   **;
;** ***************************************************************** **;


COMMON c_lamp_access, inst
COMMON printing, iprint, outstring
ON_ERROR,1
take_datp, datp
par=datp.p

x_in=datp.x
y_in=datp.y
e_in=datp.e
IF N_ELEMENTS(y_in) NE 71 THEN message,'ERROR: Dimension of Y NE 71'

; ** w_buf ... = working variables
w_buf=FLTARR(N_ELEMENTS(x_in),10) & e_buf=w_buf & y_buf=FLTARR(10)

;** First Group : from detector#0(23.5) to detector#3(27.5)
w_buf(*,0)=TOTAL(w_in(*,0:3),2)/4. & y_buf(0)=TOTAL(y_in(0:3))/4. & e_buf(*,0)=SQRT(TOTAL((e_in(*,0:3))^2,2))/4.
;** Second Group : from detector#4(37.6) to detector#8(42.6)
w_buf(*,1)=TOTAL(w_in(*,4:8),2)/5. & y_buf(1)=TOTAL(y_in(4:8))/5. & e_buf(*,1)=SQRT(TOTAL((e_in(*,4:8))^2,2))/5.
;** Third Group : from detector#9(44.6) to detector#13(49.6)
w_buf(*,2)=TOTAL(w_in(*,9:13),2)/5. & y_buf(2)=TOTAL(y_in(9:13))/5. & e_buf(*,2)=SQRT(TOTAL((e_in(*,9:13))^2,2))/5.
;** Fourth Group : from detector#14(52.6) to detector#18(57.6)
w_buf(*,3)=TOTAL(w_in(*,14:18),2)/5. & y_buf(3)=TOTAL(y_in(14:18))/5. & e_buf(*,3)=SQRT(TOTAL((e_in(*,14:18))^2,2))/5.
;** Fith Group : from detector#19(60.5) to detector#23(65.6)
w_buf(*,4)=TOTAL(w_in(*,19:23),2)/5. & y_buf(4)=TOTAL(y_in(19:23))/5. & e_buf(*,4)=SQRT(TOTAL((e_in(*,19:23))^2,2))/5.
;** Sixth Group : from detector#24(69.5) to detector#33(80.5)
w_buf(*,5)=TOTAL(w_in(*,24:33),2)/10. & y_buf(5)=TOTAL(y_in(24:33))/10. & e_buf(*,5)=SQRT(TOTAL((e_in(*,24:33))^2,2))/10.
;** Seventh Group : from detector#34(84.5) to detector#43(95.5)
w_buf(*,6)=TOTAL(w_in(*,34:43),2)/10. & y_buf(6)=TOTAL(y_in(34:43))/10. & e_buf(*,6)=SQRT(TOTAL((e_in(*,34:43))^2,2))/10.
;** Eighth Group : from detector#44(100.2) to detector#53(111.7)
w_buf(*,7)=TOTAL(w_in(*,44:53),2)/10. & y_buf(7)=TOTAL(y_in(44:53))/10. & e_buf(*,7)=SQRT(TOTAL((e_in(*,44:53))^2,2))/10.
;** Nineth Group : from detector#54(117) to detector#62(127)
w_buf(*,8)=TOTAL(w_in(*,54:62),2)/9. & y_buf(8)=TOTAL(y_in(54:62))/9. & e_buf(*,8)=SQRT(TOTAL((e_in(*,54:62))^2,2))/9.
;** Tenth Group : from detector#63(133) to detector#70(141.8)
w_buf(*,9)=TOTAL(w_in(*,63:70),2)/8. & y_buf(9)=TOTAL(y_in(63:70))/8. & e_buf(*,9)=SQRT(TOTAL((e_in(*,63:70))^2,2))/4.
;
;** Return the values and the modified parameters (errors and Ymean)
y_out=y_buf
x_out=x_in
e_out=e_buf
w_out=w_buf
mod_datp, datp, "e", e_out
mod_datp, datp, "y", y_out
give_datp, datp
Print,'** Grouping MiBeMol Data into the classical 11 groups',y_out
return, w_out
; ** End of program
end
FUNCTION mix,w

take_datp,datp
x=datp.x
e=datp.e
flag=0*indgen(n_elements(x))
index=0*indgen(n_elements(x))
newx=sort(x)
plot,x,newx
FOR i=0,n_elements(x) DO BEGIN
  j=WHERE (flag eq 0,count)
  k=0
  WHILE NOT x(i) eq newx(j(k)) DO k=k+1
  flag(j(k))=1
  index(i)=j(k)
ENDFOR
FOR i=0,n_elements(w) DO BEGIN
  neww(i) = w(index(i))
  newe(i) = e(index(i))
ENDFOR
datp.e=newe
datp.x=newx
RETURN,neww
give_datp,datp
END
FUNCTION mkcal3,win,i,last,pattern,w,xx,x
;********
;**
;** The call is w6=mkcal2(w5,32,1567,w7,w8,x7)
take_datp,datp
w=win
pv=datp.pv
x=datp.x
window,0
window,1
window,2
j=i+1
pattern=REFORM(w(i,*))
xx=reform(pv(13,*))+x(i)-x(0)
Wout=FLTARR(N_ELEMENTS(w(*,0)))
Wout(i)=1.0
;;;pattern=smooth(pattern,9)
FOR j=i+1,last DO BEGIN
  ;pattern=smooth(pattern,3)
  wset,0
  plot,xx,pattern
  oplot,pv(13,*)+x(j)-x(0),w(j,*)
  a=MIN(pv(13,*)+x(j)-x(0))
  b=MAX(xx)
  x0=[xx,REFORM(pv(13,*)+x(j)-x(0))]
  x0=x0(SORT(x0))
  x0=x0(UNIQ(x0))
  x0=x0(WHERE(x0 GE a AND x0 LE b))
  x0=FINDGEN((b-a)*10-1)*0.1+a
  c=INTERPOL(pattern,xx,x0)
  ;;;;c=c(where(x0 ge 7 or x0 le -7))
  ;;c=smooth(c,3)
  d=INTERPOL(w(j,*),pv(13,*)+x(j)-x(0),x0)
  ;;;;d=d(where(x0 ge 7 or x0 le -7))
  ;;;d=smooth(d,9)
  oplot,x0,c
  oplot,x0,d
  idx=where(x0 ge 8 or x0 le -8,points)
 PRINT,min(c(idx)),min(d(idx)),points,a,b
  Wout(j)=TOTAL(c(idx)/d(idx)*SQRT((c(idx)+d(idx))/2.))/TOTAL(SQRT((c(idx)+d(idx))/2.))
  Wout(j)=TOTAL(c(idx)/d(idx))/points
  print,j,Wout(j),N_ELEMENTS(x0),N_ELEMENTS(xx),min(x0),max(x0),a,b
wset,2
plot,x0(idx),c(idx),psym=7
oplot,x0(idx),d(idx),psym=1
  wset,1
  plot,wout(i:j)
  d=d*Wout(j)
  w(j,*)=w(j,*)*Wout(j)
  d=(c+d)/2.0
  ;;d=smooth(d,3)
  x1=WHERE(xx LT a)
  x2=REFORM(pv(13,*)+x(j)-x(0))
  x3=WHERE(x2 GT b)
  xx=[xx(x1),x0,x2(x3)]
  pattern=[pattern(x1),d,w(j,x3)]
  ;;pattern=smooth(pattern,3)
ENDFOR
return, Wout
end
FUNCTION mkcal5,win,i,last,pattern,w,xx,x,error
;********
;**
;** The call is w6=mkcal4(w5,32,1567,w7,w8,x7)
take_datp,datp
w=win
pv=datp.pv
x=datp.x
e=datp.e
window,0
window,1
window,2
j=i+1
pattern=REFORM(w(i,*))
error  =REFORM(e(i,*))
xx     =REFORM(pv(13,*))+x(i)-pv(13,0)
Wout=FLTARR(N_ELEMENTS(w(*,0)))
Eout=Wout
Wout(i)=1.0
FOR j=i+1,last DO BEGIN
  wset,0
  plot,xx,pattern
  oplot,pv(13,*)+x(j)-pv(13,0),w(j,*)
  a=MIN(pv(13,*)+x(j)-pv(13,0))
  b=MAX(xx)
  x0=xx(WHERE(xx gt a))
  ;rounding=10.
  ;x0=[x0,REFORM(x(j,WHERE(x(j,*) lt b)))]
  ;x0=ROUND(x0*rounding)
  ;x0=x0(SORT(x0))
  ;x0=x0(UNIQ(x0))
  ;x0=FLOAT(x0)*rounding
  ;c=INTERPOL(pattern,xx,x0)
  ;c_err=INTERPOL(error,xx,x0)
  c=pattern(WHERE(xx ge a))
  c_err=error(WHERE(xx ge a))
  d=INTERPOL(w(j,*),pv(13,*)+x(j)-pv(13,0),x0)
  d_err=INTERPOL(e(j,*),pv(13,*)+x(j)-pv(13,0),x0)
  oplot,x0,c
  oplot,x0,d
  idx=where(x0 ge 7.5 or x0 le -8.5,points)
  Wout(j)=TOTAL(c(idx)/d(idx)*c_err(idx)*d_err(idx)/d(idx)^2)
  Wout(j)=Wout(j)/TOTAL(c_err(idx)*d_err(idx)/d(idx)^2)
  Eout(j)=TOTAL((c(idx)/d(idx)-wout(j))^2*c_err(idx)*d_err(idx)/d(idx)^2)
  Eout(j)=Eout(j)/TOTAL(c_err(idx)*d_err(idx)/d(idx)^2)
  Eout(j)=sqrt(Eout(j))
  print,j,Wout(j),Eout(j),N_ELEMENTS(x0),a,b,points
  wset,2
  plot,x0(idx),c(idx),psym=7,yr=[min([c(idx),d(idx)]),max([c(idx),d(idx)])]
  plot,x0(idx),d(idx),/noer, yr=[min([c(idx),d(idx)]),max([c(idx),d(idx)])]
  wset,1
  plot,wout(i:j)
  d     =d     *Wout(j)
  d_err =d_err *Wout(j)+d     *Eout(j)
  w(j,*)=w(j,*)*Wout(j)
  e(j,*)=e(j,*)*Wout(j)+w(j,*)*Eout(j)
  d_tmp=c*(SQRT(c)/c_err)^2+d*(SQRT(d)/d_err)^2
  d_div=  (SQRT(c)/c_err)^2+  (SQRT(d)/d_err)^2
  d    =     d_tmp /d_div
  d_err=SQRT(d_tmp)/d_div
  x1=WHERE(xx LT a)
  x2=REFORM(pv(13,*)+x(j)-pv(13,0))
  x3=WHERE(x2 GT b)
  xx=[xx(x1),x0,x2(x3)]
  pattern=[pattern(x1),d,REFORM(w(j,x3))]
  error=[error(x1),d_err,REFORM(e(j,x3))]
ENDFOR
mod_datp,datp,'e',Eout
;help,datp.e,wout
mod_datp,datp,'x',indgen(n_elements(wout))
give_datp,datp
return, Wout
end
FUNCTION mkcal  , w2 , w1
;********
;**
;** The call is w6=mkcal(...)
w1=w2
take_datp,datp
a=N_ELEMENTS(w1(0,*))
b=N_ELEMENTS(w1(*,0))
Wout=FLTARR(b)+1.0
w=FLTARR(a+b)
n=w*0.0
FOR i=1,b-1 DO BEGIN
  n(i-1:i+a-2)=n(i-1:i+a-2)+1.0
  w(i-1:i+a-2)=w(i-1:i+a-2)+w1(i-1,0:a-1)
  Wout(i)=total(w(i:i+a-2)/n(i:i+a-2))/total(w1(i,0:a-2))
ENDFOR
Wout=Wout/mean(Wout)
FOR i=0,b-1 DO w1(i,*)=w1(i,*)*Wout(i)
mod_datp,datp,'x_tit','cell'
mod_datp,datp,'e',0
mod_datp,datp,'x',INDGEN(b)
give_datp,datp
RETURN, Wout
end
PRO mkxbu, xbu,motor,start,stop,step,time,flag,save,rep
;***
;**
;** The call is mkxbu,'sth.xbu','2theta',-5,-3,.1,10,1,1,1

OPENW,file,xbu,/get_lun
start=float(start)
stop=float(stop)
FOR value=start,stop,step DO BEGIN
	PRINTF,file,"pos ",motor,value
	PRINTF,file,"acq",time,flag,save,rep
ENDFOR
FREE_LUN,file
end
function mnorm13, w_in
;******* *******
;**
;** Normalize W_in with monitor spectrum for in13

;** Check for consistancies

    w_out=float(w_in)
    s    =size (w_in)

    if (s(0) gt 0) and (s(0) lt 3) then begin 
       TAKE_DATP,P
       if s(0) eq 2 then for i =0,s(2)-1 do w_out(0,i)=w_out(*,i)/(P.n(i)>1)
       if s(0) eq 1 then 		    w_out     =w_out     /(P.n>1)
       P.n(*)=1
       P.x_tit=P.x_tit+' normalized'
       GIVE_DATP,P
    endif

return,w_out
end
pro mod_datp,datp,tag,val
;** ********
sz=size(tag)
if (n_tags(datp) gt 0) and (sz(1) gt 0) and (sz(2) eq 1) and (n_elements(val) gt 0) then begin

	    		     x=0 & y=0 & z=0 & e=0 & n=0 & pv=0 & p=0      & par_txt=''
	    		     w_tit=''  & x_tit=''  & y_tit=''   & z_tit='' & other_tit='' & time=''
	    		     tlist=tag_names(datp)
	    		     for k=0,n_elements(tlist)-1 do begin
	    		         CASE tlist(k) of
	    		         
	    		         'X':	 x =datp.x
	    		         'Y':	 y =datp.y
	    		         'Z':	 z =datp.z
	    		         'E':	 e =datp.e
	    		         'N':	 n =datp.n
	    		         'PV':	 pv=datp.pv
	    		         
	    		         'W_TIT':    w_tit    =datp.w_tit
	    		         'X_TIT':    x_tit    =datp.x_tit
	    		         'Y_TIT':    y_tit    =datp.y_tit
	   			 'Z_TIT':    z_tit    =datp.z_tit
	   			 'OTHER_TIT':other_tit=datp.other_tit
	   			 'TIME' :    time     =datp.time
	   			 
	   			 'P'	  :  p        =datp.p
	   			 'PAR_TXT':  par_txt  =datp.par_txt
	   			  ELSE:
	   			  ENDCASE
	    		     endfor
	    		     
	    		     iii=execute(tag+'=val')
      			     DATP={X:x,Y:y,Z:z,E:e,N:n,PV:pv,W_TIT:w_tit,X_TIT:x_tit    ,$
      			     	   Y_TIT:y_tit,Z_TIT:z_tit,OTHER_TIT:other_tit,TIME:time,$
      			     	   P:p,PAR_TXT:par_txt}
endif
return
end
Function mode,x,J,pj=pj,imax=imax,printout=printout,prob=p,e=e,s=s,plot=plot

J=Floor(j)
N=N_ELEMENTS(x)
if (J LT 1) THEN BEGIN
  J=1
endif
if (J GE N) THEN BEGIN
  J=N-1
endif
p=FLTARR(N-J)
e=FLTARR(N-J)
s=FLTARR(N-J)
x=x(Sort (x))
pmax=0
FOR i=0,N-J-1 DO BEGIN
  p(i)=J/(N*(x(i+J)-x(i)))
  e(i)=0.5*(x(i)+x(i+J))
  s(i)=sqrt(J)/(N*2*e(i))
  ;Print, i,i+J,x(i),x(i+J),e(i),p(i)
  if (p(i) GT pmax) THEN BEGIN
    imax=i
    pmax=p(i)
  endif
ENDFOR
if KEYWORD_SET(printout) THEN BEGIN
  Print, e(imax),p(imax),s(imax)	,s(imax)/p(imax),1/sqrt(J)
  i=imax
  x1=(e(i)+e(i-1))/2.
  x2=(e(i)+e(i+1))/2.
  y1=(alog(p(i))-alog(p(i-1)))/(e(i)-e(i-1))
  y2=(alog(p(i+1))-alog(p(i)))/(e(i+1)-e(i))
    print,1./SQRT(-(y2-y1)/(x2-x1)),j,1./SQRT(-(y2-y1)/(x2-x1))/SQRT(j)
endif
if KEYWORD_SET(plot) THEN BEGIN
     Plot, e,p,ps=0
endif
pj=p(imax)


Return, e(imax)
end 

;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO monitor, numor1, numor2

;					KHA, 19/5/98
;-------------------------------------------------------------------------------
;*******************************************************************************

@read_d7.cbk

	infile=''
	path='/usr/illdata/data-1/d7/'
	outfile='monitor.001'
	olddate=-10.

	IF (N_ELEMENTS(numor2) EQ 0) THEN numor2=numor1

	OPENW, 2, outfile
	FOR numor=numor1,numor2 DO BEGIN
		IF (numor GE 10000) THEN infile=path+'0'+STRTRIM(STRING(numor),2) $
				ELSE infile=path+'00'+STRTRIM(STRING(numor),2) 
		PRINT,' Reading run',numor
		read_d7sum, infile
		IF (numor EQ numor1) THEN PRINTF, 2, date, 0., 0.
		IF (date-olddate GT 1./24. OR numor EQ numor2) THEN $
			PRINTF, 2, date, mon1rate, dmon1rate
		IF (numor EQ numor2) THEN PRINTF, 2, date, 0., 0.
		olddate=date
	ENDFOR
	PRINTF, 2, 'Date (May 1998)'
	PRINTF, 2, 'Counts/second'
	PRINTF, 2, 'Monitor 1 rate'
	CLOSE, 2

	RETURN
	END
function monit,help=help,noprint=noprint,plot=plot,start=n1,cyc=cyc,wait=wait,stop=n2,dir=lambdm,vis=vis,hole=hole,loops=loops
;+
; Extracts the monitor counting rate from your raw data and updates catalogues
; in the directory d20sgi.ill.fr:~lambda'+divider+'MONITOR such as 981.cat, 981.132 and 
; 981.all for a cycle 981. These files can only be created 
; on d20sgi.ill.fr. The first time in a new cycle the file last.cyc in 
; ~lambda/CALIBRATION should be updated and the keyword start, giving the first
; numor of that cycle, be used. With the keyword vis you write the output
; not to the directory ~lambda/MONITOR but to your actual directory where 
; you work in - and have write access. With the keyword dir you can define
; another directory to read/write in. Especially on
; tektronix terminals you should use the keyword noplot.
; Modified    28 April 1998, Th. HANSEN
; Modified 27 November 2000, Th. HANSEN
; Modified    12 April 2001, Th. HANSEN
;-
if !version.release ge '5.0' then FORWARD_FUNCTION RDRUN
common calibration
common d20
divider = sys_dep('DIVIDER')
if keyword_set(help) then begin
  print,"Extracts the monitor counting rate from your raw data and updates catalogues"
  print,"in the directory d20sgi.ill.fr:~lambda'+divider+'MONITOR such as 981.cat, 981.132 and "
  print,"981.all for a cycle 981. These files can only be created "
  print,"on d20sgi.ill.fr. The first time in a new cycle the file last.cyc in "
  print,"~lambda/CALIBRATION should be updated and the keyword start, giving the first"
  print,"numor of that cycle, be used. With the keyword vis you write the output"
  print,"not to the directory ~lambda/MONITOR but to your actual directory where "
  print,"you work in - and have write access. With the keyword dir you can define"
  print,"another directory to read/write in. Especially on"
  print,"tektronix terminals you should use the keyword noplot."
  print,"Last Update 28 April 1998, Th. HANSEN"
endif
if NOT keyword_set(loops) then loops=999999 
loop=0
if keyword_set(plot) then noplot=0 ELSE noplot=1
submon=0
subtim=0
unit=1
unittxt='s '
NbOfZeroCounters=0
P_LAMBDA,lambda
Mhor=0
Mver=0
alpha1=0
wav=0
IF KEYWORD_SET(cyc) THEN cyc=ROUND(cyc)  ELSE BEGIN
  OPENR,in,LAMBDA+'CALIBRATION'+divider+'last.cyc',/get_lun
  READF,in,cyc
  CLOSE,in
  FREE_LUN,in
ENDELSE
xicutstr="RDSET  ,inst='D20'  ,base='C_Year "
IF cyc LT 700 THEN xicutstr=xicutstr+'20' ELSE xicutstr=xicutstr+'19'
xicutstr=xicutstr+STRMID(STRCOMPRESS(STRING(LONG(1000+cyc)),/remove_all),1,2)+" L',cycle='"
xicutstr=xicutstr+STRMID(STRCOMPRESS(STRING(LONG(1000+cyc)),/remove_all),1,3)
xicutstr=xicutstr+"'"
XICUTE,xicutstr
print,xicutstr
IF KEYWORD_SET(vis) THEN BEGIN
  IF NOT KEYWORD_SET(lambdm) THEN lambdm=''
  print,'Welcome, Visitor! Your catalogue/monitor files are written to ',lambdm
  lambdm=lambdm+divider+STRMID(STRCOMPRESS(STRING(LONG(1000+cyc)),/remove_all),1,3)
ENDIF ELSE BEGIN
  IF NOT KEYWORD_SET(lambdm) THEN lambdm=LAMBDA+'MONITOR'
  lambdm  =lambdm+divider+STRMID(STRCOMPRESS(STRING(LONG(1000+cyc)),/remove_all),1,3)
  print,'Welcome! Your catalogue/monitor files are written to ',lambdm
ENDELSE
filename=lambdm+'.mon'
lastnum=lambdm+'.'
print,"Files : ",filename," etc."
catname =lambdm+'.cat'
lctname =lambdm+'.132'
allname =lambdm+'.all'
corname =lambdm+'.cor'
attname =lambdm+'.att'
badname =lambdm+'.bad'
corrections=0
IF NOT KEYWORD_SET(n1) THEN BEGIN
  OPENR,cor,corname,/get_lun
  READF,cor,corrections
  IF corrections GT 0 THEN BEGIN
      cornum=fltarr(3,corrections)
        READF,cor,cornum
  ENDIF
  CLOSE,cor
  FREE_LUN,cor
  OPENW,cat,catname,/get_lun,/APPEND
  OPENW,lct,lctname,/get_lun,/APPEND
  OPENW,all,allname,/get_lun,/APPEND
  OPENW,att,attname,/get_lun,/APPEND
  OPENW,bad,badname,/get_lun,/APPEND
  OPENR,in,filename,/get_lun
  READF,in,n0,n1,refday,elements,unit
  n0=LONG(n0)
  n1=LONG(n1)
  refday=LONG(refday)
  elements=LONG(elements)
  unit=LONG(unit)
  IF unit EQ 7*86400 THEN unittxt='w '
  IF unit EQ   86400 THEN unittxt='d '
  IF unit EQ   3600  THEN unittxt='h '
  IF unit EQ 60      THEN      unittxt='mn'
  x=fltarr(elements)
  e=lonarr(elements)
  monitor=lonarr(elements)
  y=intarr(elements)
  n=lonarr(elements)
  READF,in,x
  READF,in,monitor
  READF,in,e
  READF,in,n
  READF,in,y
  CLOSE,in
  FREE_LUN,in
  CALDAT,refday,MON,DD,YY
  since=STRCOMPRESS(STRING(DD),/remove_all)+divider+STRCOMPRESS(STRING(MON),/remove_all)+divider+$
          STRCOMPRESS(STRING(YY),/remove_all)
  newfiles=0
ENDIF ELSE BEGIN
  OPENW,cor,corname,/get_lun
  PRINTF,cor,corrections
  CLOSE,cor
  FREE_LUN,cor
  OPENW,cat,catname,/get_lun
  OPENW,lct,lctname,/get_lun
  OPENW,all,allname,/get_lun
  OPENW,att,attname,/get_lun
  OPENW,bad,badname,/get_lun
  PRINT,'Numor Sub      Date     Time Usr Wav Scan Mod Time Monitor PSD-cnts Sample/Title'
  PRINTF,cat,'Numor Sub      Date     Time Usr Wav Scan Mod Time Monitor PSD-cnts Sample/Title'
  PRINTF,lct,'Numor Sub      Date     Time Usr Wav Scan Mod Time Monitor PSD-cnts 2Theta Omega   Chi   Phi   Tr1   Tr2 Sample/Title'
  PRINTF,all,'Numor Sub      Date     Time  User     Wav alp1 Scn Step Mod Cyc SliceTime total CntTim   Monit PSD-cnts 2Theta Omega   Chi   Phi Transl1 Transl2 Tset Treg Tsam Title                                    Sample'
  n0=n1
  refday=0
  newfiles=1
ENDELSE
IF NOT KEYWORD_SET(n2) THEN n2=999999
datp=1
counter=0
IF NOT KEYWORD_SET(hole) THEN hole=0
for numor = long(n1), LONG(n2) do begin
  flag,/soft,old=flag_restore,/noprint,/eff,/nobad,/noang,/noint,/nowav,/flp,/nonor,/nocor
  w=rdrun(numor,datp=datp)
  print,numor ; 20 September 2002
  flag,/soft,new=flag_restore,/noprint
  counter=counter + N_ELEMENTS(w(0,*))
    nodata=0
  WHILE (n_elements(w) le 1 or N_ELEMENTS(datp.p) LE 1) DO BEGIN 
     IF nodata EQ 0 THEN nomore=numor
     IF NOT KEYWORD_SET(wait) THEN BEGIN
        nodata=nodata+1
        print,'No data for ',numor
        numor=numor+1
     ENDIF ELSE BEGIN
       IF nodata EQ 0 THEN BEGIN
         print,'Waiting for ',numor,' since ',systime()
         printF,att,'Waiting for ',numor,' since ',systime()
         numor=nomore
        OPENW ,out,filename,/get_lun
        PRINTF,out,LONG(n0),LONG(numor),LONG(refday),LONG(N_elements(monitor)),LONG(unit)
        PRINTF,out,FLOAT(x),LONG(monitor),FLOAT(e),LONG(n),ROUND(y)
        CLOSE,out
        WAIT,wait*60
        FLUSH,cat
        FLUSH,lct
        FLUSH,all
        FLUSH,att
        FLUSH,mon ; 20 September 2002
        mod_datp,datp,'x',x
        mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
        mod_datp,datp,'p',[n1,numor-1]
        mod_datp,datp,'e',e
        mod_datp,datp,'n',n
        mod_datp,datp,'y',y
        mod_datp,datp,'w_tit','Monitor/time for Cycle'+STRING(cyc)
        mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n2)
        mod_datp,datp,'y_tit','cnt/sec'
        mod_datp,datp,'x_tit','time/s'
        give_datp,datp
      ENDIF
      nodata=1
    ENDELSE
    flag,/soft,old=flag_restore,/noprint,/eff,/nobad,/noang,/noint,/nowav,/flp,/nonor,/nocor
    w=rdrun(numor,datp=datp)
    flag,/soft,new=flag_restore,/noprint
    counter=counter + N_ELEMENTS(w(0,*))
    IF ((n_elements(w) le 1 AND nodata GE hole) and not newfiles) THEN BEGIN
      numor=nomore
      print,'No more numors from ',numor
      OPENW ,out,filename,/get_lun
      PRINTF,out,LONG(n0),LONG(numor),LONG(refday),LONG(N_elements(monitor)),LONG(unit)
      PRINTF,out,FLOAT(x),LONG(monitor),FLOAT(e),LONG(n),ROUND(y)
      CLOSE,out
      CLOSE,cat
      CLOSE,lct
      CLOSE,all
      CLOSE,att
      CLOSE,bad
      FREE_LUN,out,cat,lct,all,att,bad
      PRINT,filename ,' and ', catname ,' written'
      flag,new=flag_restore,/noprint
      mod_datp,datp,'x',x
      mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
      mod_datp,datp,'p',[n1,numor-1]
      mod_datp,datp,'e',e
      mod_datp,datp,'n',n
      mod_datp,datp,'y',y
      mod_datp,datp,'w_tit','Monitor/time for Cycle'+STRING(cyc)
      mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n2)
      mod_datp,datp,'y_tit','cnt/sec'
      mod_datp,datp,'x_tit','time/s'+unittxt+' since '+since
      give_datp,datp
      RETURN,monitor
    ENDIF
  ENDWHILE
  newfiles=0
  j=WHERE(cal_d20)
  FOR i=0,N_ELEMENTS(w(0,*))-1 DO BEGIN 
    w(j,i)=w(j,i)/cal_d20(j) 
  ENDFOR
    ;IF KEYWORD_SET(wait) AND nodata EQ 1 THEN BEGIN
    ;ENDIF
  index=WHERE(datp.n EQ 1.95646080e+07,counts)
  IF counts GE 1 THEN datp.n(0,0,index) =0
  corflag=0.
  IF datp.p(0) NE 0 OR N_ELEMENTS(w(0,*)) EQ 1 THEN BEGIN
    comtim=datp.p(25)*datp.p(35)*2./8000000.
    IF cyc LE 972 AND cyc GE 963 OR cyc EQ 973 AND numor LE 8918 THEN comtim=comtim/2.
        if ABS(comtim-datp.p(5)/N_ELEMENTS(w(0,*))) GE 0.01>(datp.p(5)/N_ELEMENTS(w(0,*)))/20000 THEN BEGIN
          corflag=1.
      PRINT,FORMAT="(I6,' PresetTime(/Step) NE CntTime because of reparable bug:',F7.2,'-',F7.2)",numor,comtim,datp.p(5)/N_ELEMENTS(w(0,*))
      PRINTF,att,FORMAT="(I6,' PresetTime(/Step) NE CntTime because of reparable bug:',F7.2,'-',F7.2)",numor,comtim,datp.p(5)/N_ELEMENTS(w(0,*))
      FLUSH,att
            IF corrections EQ 0 THEN BEGIN
              cornum=[numor,submon,subtim]
            ENDIF ELSE BEGIN
               cornum=[[cornum],[numor,submon,subtim]]
       ENDELSE
      OPENW,cor,corname,/get_lun
      PRINTF,cor,corrections
        PRINTF,cor,cornum
      CLOSE,cor
        FREE_LUN,cor
            corrections=corrections+1
            datp.p(5)=datp.p(5)-subtim*N_ELEMENTS(w(0,*))
            datp.pv(5,*)=datp.pv(5,*)-subtim
            datp.pv(30,*)=datp.pv(30,*)-submon
            datp.p(30)=datp.p(30)-submon
            datp.n(0,0,*)=datp.n(0,0,*)-submon
        ENDIF
      comtim=comtim*N_ELEMENTS(w(0,*))
  ENDIF ELSE BEGIN
      comtim=TOTAL(datp.pv(25,*)*datp.p(35)/8000000.)
    IF datp.p(0) EQ 0 THEN BEGIN
          submon=datp.n(0,0,1)
            subtim=datp.pv(5,1)
        ENDIF    
    ENDELSE
    IF ABS(comtim-datp.p(5)) GE 0.01>(datp.p(5))/500 THEN BEGIN
      PRINT,FORMAT="(I6,' (Total) PresetTime (still) NE CntTime:',F8.2,'-',F8.2)",numor,comtim,datp.p(5)
      PRINTF,att,FORMAT="(I6,' (Total) PresetTime (still) NE CntTime:',F8.2,'-',F8.2)",numor,comtim,datp.p(5)
      FLUSH,att
    ENDIF
    totmon=ROUND(TOTAL(datp.n/datp.p(5)))
    ;totPSD=TOTAL(FLOAT(w<100000*MAX(datp.pv(5,*)))/datp.p(5)/1600.)
    ;totmon=ROUND(TOTAL(datp.n(0,0,*))/datp.p(5))
    IF N_ELEMENTS(w(0,*)) GT 1 THEN BEGIN
      totPSD=TOTAL(w,2)/datp.p(5)/1600. 
      maxPSD=MAX(TOTAL(w,2))/datp.p(5)
    ENDIF ELSE BEGIN
      totPSD=TOTAL(w)/datp.p(5)/1600.
      maxPSD=MAX(TOTAL(w))/datp.p(5)
    ENDELSE
    RA=0
    IF STRLEN(datp.w_tit) GT 11 THEN RA=1
    print,'again: ',numor ; 20 September 2002
    PRINT,FORMAT="(I6,I4,A19,A5,F4.1,'A',I3,I2,I6,'s',I6,'/s',I5,'/c/s ',A11)",$
      numor,N_ELEMENTS(w(0,*)),strmid(datp.other_tit,3,19),strmid(datp.other_tit,28,4),$
        datp.p(33),ROUND(datp.p(0)),LONG(datp.p(34)-1),ROUND(datp.p(5)),totmon,$
        total(totPSD),$
        STRMID(STRCOMPRESS(datp.w_tit,REMOVE_ALL=RA),0,11)
		help,datp.w_tit,datp.other_tit,w(0,*),datp.p,totmon,totPSD,total(totpsd)
    print,'again and again: ',numor ; 20 September 2002
    IF numor gt 0 THEN PRINTF,cat,FORMAT="(I6,I4,A19,A5,F4.1,'A',I3,I2,I6,'s',I6,'/s',I5,'/c/s ',A11)",$
      numor,N_ELEMENTS(w(0,*)),strmid(datp.other_tit,3,19),strmid(datp.other_tit,28,4),$
        datp.p(33),ROUND(datp.p(0)),LONG(datp.p(34)-1),ROUND(datp.p(5)),totmon,$
        total(totPSD),$
        STRMID(STRCOMPRESS(datp.w_tit,REMOVE_ALL=RA),0,11)
    RA=0
    IF STRLEN(datp.w_tit) GT 27 THEN RA=1
    IF numor gt 0 THEN PRINTF,lct,FORMAT="(I6,I4,A19,A5,F4.1,'A',I3,I2,I6,'s',I6,'/s',I5,'/c/s ',6F6.1,A27)",$
      numor,N_ELEMENTS(w(0,*)),strmid(datp.other_tit,3,19),strmid(datp.other_tit,28,4),$
        datp.p(33),LONG(datp.p(0)),LONG(datp.p(34)),ROUND(datp.p(5)),totmon,$
        total(totPSD),datp.p(13:18)<999,$
        STRMID(STRCOMPRESS(datp.w_tit,REMOVE_ALL=RA),0,27)
    IF numor gt 0 THEN PRINTF,all,FORMAT="(I6,I4,A19,A9,F4.1,'A',I3,'`',I3,F6.2,I2,I6,F9.2,'ms',I6,'s',I5,'s',I6,'/s',I5,'/c/s ',4F6.1,F6.1,'mm',F6.1,'mm',I4,'K',I4,'K',I4,'K',A80,F5.2,I7,I8)",$
      numor,N_ELEMENTS(w(0,*)),strmid(datp.other_tit,3,19),strmid(datp.other_tit,28,8),$
        datp.p([33,31]),LONG(datp.p(0)),(datp.p(0) GT 1)*datp.p(28),LONG(datp.p(34:35)),datp.p(25)/8000.,ROUND(datp.p(5)),$
        ROUND(datp.pv(5,0)),totmon,$
        total(totPSD),datp.p(13:18)<999,$
        LONG(datp.p(10:12)<999),STRMID(datp.w_tit+'                                                                                                        ',0,80),[subtim,submon]*corflag,maxpsd

  zerocounters= WHERE(TOTAL(REFORM(w,N_ELEMENTS(w(*,0)),N_ELEMENTS(w(0,*))),2) LE 0)
  tmp=N_ELEMENTS(ZeroCounters)
    IF tmp GT NbOfZeroCounters THEN BEGIN
      PRINTF,att,FORMAT="(I6,' More zero-counting cells (',I4,') than before (',I4,')')",numor,tmp,NbOfZeroCounters
      IF tmp GT 3 AND tmp-1 GT NbOfZeroCounters THEN PRINT,FORMAT="(I6,' More zero-counting cells (',I4,') than before (',I4,')')",numor,tmp,NbOfZeroCounters
    ENDIF
    NbOfZeroCounters=tmp
  PRINTF,bad,' '
  IF NbOfZeroCounters GE 1 THEN PRINTF,bad,STRMID(numor,strlen(numor)-6,6),' Zero ', STRMID(ZeroCounters(0:13<N_ELEMENTS(ZeroCounters)-1),8,4)

  tmp=TOTAL(REFORM(w,N_ELEMENTS(w(*,0)),N_ELEMENTS(w(0,*))),2)*cal_d20

  ind=findgen(N_ELEMENTS(tmp)-4)+2

  smoothed=tmp
  smoothed(ind)=2./3.*(tmp(ind-1)+tmp(ind-1))-(tmp(ind-2)+tmp(ind-2))/6.>0

  MCounters=2+WHERE(tmp(ind) LT (tmp(ind-2)+tmp(ind+2))/2./1.06 AND tmp(ind-1)/1.02 GT (3.*tmp(ind-2)+tmp(ind+2))/4. AND tmp(ind+1)/1.02 GT (tmp(ind-2)+3.*tmp(ind+2))/4.,NbOfMCounters)
  IF NbOfMCounters GE 2 THEN MCounters=MCounters(SORT((tmp(MCounters+2)+tmp(MCounters+1)+tmp(MCounters)+tmp(MCounters-1)+tmp(MCounters-2))/((tmp(MCounters+1)+tmp(MCounters-1))/2.-tmp(MCounters))))
  IF NbOfMCounters GE 1 THEN PRINTF,bad,STRMID(numor,strlen(numor)-6,6),' "M"  ', STRMID(MCounters(0:13<N_ELEMENTS(MCounters)-1),8,4)

  WCounters=2+WHERE(tmp(ind)/1.06 GT (tmp(ind-2)+tmp(ind+2))/2. AND tmp(ind-1) LT (3.*tmp(ind-2)+tmp(ind+2))/4./1.02 AND tmp(ind+1) LT (tmp(ind-2)+3.*tmp(ind+2))/4./1.02,NbOfWCounters)
  IF NbOfWCounters GE 2 THEN WCounters=WCounters(SORT((tmp(WCounters+2)+tmp(WCounters+1)+tmp(WCounters)+tmp(WCounters-1)+tmp(WCounters-2))/(tmp(WCounters)-(tmp(WCounters+1)+tmp(WCounters-1))/2.)))
  IF NbOfWCounters GE 1 THEN PRINTF,bad,STRMID(numor,strlen(numor)-6,6),' "W"  ', STRMID(WCounters(0:13<N_ELEMENTS(WCounters)-1),8,4)

  ind=findgen(N_ELEMENTS(tmp)-4)+2

  LowCounters =2+WHERE(tmp(ind) LT (smoothed(ind)-4.*SQRT(smoothed(ind)>0))-ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.-ABS(tmp(ind-1)-tmp(ind+1))/2. AND tmp(ind) GT 0,NbOfLowCounters)
  IF NbOfLowCounters GE 2 THEN LowCounters=LowCounters(SORT(smoothed(LowCounters)/(smoothed(LowCounters)-tmp(LowCounters))))
  IF NbOfLowCounters GE 1 THEN PRINTF,bad,STRMID(numor,strlen(numor)-6,6),' Low  ', STRMID(LowCounters(0:13<N_ELEMENTS(LowCounters)-1),8,4)

  HighCounters =2+WHERE(tmp(ind) GT (smoothed(ind)+4.*SQRT(smoothed(ind)>0))+ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.+ABS(tmp(ind-1)-tmp(ind+1))/2.,NbOfHighCounters)
  IF NbOfHighCounters GE 2 THEN HighCounters=HighCounters(SORT(smoothed(HighCounters)/tmp((HighCounters)-smoothed(HighCounters))))
;  FOR hi=0,NbOfHighCounters-1 DO BEGIN
;    PRINTF,bad,HighCounters(hi)
;    PRINTF,bad,HighCounters(hi)-2+indgen(5)
;    PRINTF,bad,tmp(HighCounters(hi)-2+indgen(5))
;    PRINTF,bad,smoothed(HighCounters(hi)-2+indgen(5))
;  ENDFOR
  IF NbOfHighCounters GE 1 THEN PRINTF,bad,STRMID(numor,strlen(numor)-6,6),' High ', STRMID(HighCounters(0:13<N_ELEMENTS(HighCounters)-1),8,4)

  FLUSH,bad
  DD=0
  MON=0
  YY=0
  HH=0
  MM=0
  SS=0
  day      = strmid(datp.other_tit,4,2)
  READS,day,DD
  month    = strmid(datp.other_tit,7,3)
  year     = strmid(datp.other_tit,11,2)
  READS,year,YY
  IF YY LT 70 THEN YY=YY+2000 ELSE IF YY LE 99 THEN YY=YY+1900
  hour     = strmid(datp.other_tit,14,2)
  READS,hour,HH
  min      = strmid(datp.other_tit,17,2)
  READS,min,MM
  sec      = strmid(datp.other_tit,20,2)
  READS,sec,SS
  CASE month OF
     'Jan':  MON=1
     'Feb':  MON=2
     'Mar':  MON=3
     'Apr':  MON=4
     'May':  MON=5
     'Jun':  MON=6
     'Jul':  MON=7
     'Aug':  MON=8
     'Sep':  MON=9
     'Oct':  MON=10
     'Nov':  MON=11
     'Dec':  MON=12
  ENDCASE          
  IF refday EQ 0 THEN BEGIN
    refday=JULDAY(MON,DD,YY)
    day = 0
  since=STRCOMPRESS(STRING(DD),/remove_all)+divider+STRCOMPRESS(STRING(MON),/remove_all)+divider+$
          STRCOMPRESS(STRING(YY),/remove_all)
    PRINT,'First Day of Cycle',STRCOMPRESS(STRING(LONG(cyc))),': ',since
  ENDIF ELSE day=JULDAY(MON,DD,YY)-refday
  sec=(day*24.*3600.+HH*3600.+MM*60.+SS)
 lowpassed=0
  highpassed=0
  PRINT ,'Elements:',LONG(N_ELEMENTS(w(0,*)))
  FOR i=0L,LONG(N_ELEMENTS(w(0,*)))-1L DO BEGIN
  help,i
      if sec/unit GE 120. THEN BEGIN
        IF unit EQ 86400 THEN BEGIN
              unit=604800
              unittxt='w '
              IF N_ELEMENTS(x) GE 1 THEN x=x/7.
        ENDIF
        IF unit EQ 3600 THEN BEGIN
              unit=86400
              unittxt='d '
              IF N_ELEMENTS(x) GE 1 THEN x=x/24.
        ENDIF
        IF unit EQ 60 THEN BEGIN
              unit=3600
              unittxt='h '
              IF N_ELEMENTS(x) GE 1 THEN x=x/60.
        ENDIF
        IF unit EQ 1 THEN BEGIN
              unit=60
              unittxt='mn'
              IF sec/unit GE 120. THEN BEGIN
                  unit=3600
                  unittxt='h '
              ENDIF
              IF N_ELEMENTS(x) GE 1 THEN x=x/unit
        ENDIF
      ENDIF
      IF NOT KEYWORD_SET(noprint) THEN BEGIN
          PRINT,FORMAT="(I6,I5,A19,F7.2,A3,I7,'/s',A5,F4.1,'A',I6,'s',F6.2,I7)",$
               numor,i,strmid(datp.other_tit,4,18),$
                 sec/unit,unittxt, datp.n(0,0,i)/datp.pv(5,i),strmid(datp.other_tit,28,4),$
                    datp.p(33),$
                    ROUND(datp.pv(5,i)),[subtim,submon]*corflag
      ENDIF
      IF ROUND(10.*datp.p(33)) GE 23 THEN BEGIN     ; HOPG Monochromator
            lowmon=43000
            highmon=54000
        ENDIF ELSE BEGIN
          IF ROUND(10.*datp.p(33)) GE 12 THEN BEGIN   ; Copper Monochromator, high take-off
              lowmon=39000
             highmon=49000
          ENDIF ELSE BEGIN                             ; Copper Monochromator, low take-off
            IF ROUND(10.*datp.p(33)) GE 9 THEN BEGIN   ; Copper Monochromator, low take-off
                lowmon=24000
               highmon=28000
            ENDIF ELSE BEGIN                            ; Copper Monochromator, low take-off
                lowmon=10000
               highmon=13000
              ENDELSE
            ENDELSE
        ENDELSE 
    IF ROUND(datp.p(31)) LE 21 THEN BEGIN     ; alpha1 = 20 minutes
                lowmon=lowmon/2
                highmon=highmon/2
        ENDIF                    
    IF ROUND(datp.p(31)) LE 11 THEN BEGIN     ; alpha1 = 10 minutes
               lowmon=lowmon/5
                highmon=highmon/3
       ENDIF
    IF datp.p(20) LT 60 THEN BEGIN
      lowmon=round(lowmon/60.*datp.p(20))
      highmon=round(highmon/60.*datp.p(20))
    ENDIF
    IF datp.p(21) LT 280 THEN BEGIN
      lowmon=round(lowmon/280.*datp.p(21))
      highmon=round(highmon/280.*datp.p(21))
    ENDIF
	;print,'test'
    IF Mhor NE datp.p(20) OR Mver NE datp.p(21) OR alpha1 NE datp.p(31) OR wav NE datp.p(33) THEN BEGIN
            PRINT,FORMAT="('New Config. ',I5,'/s<Monitor<',I5,'/s for lam=',F3.1,'A, alph1=',I2,'`, M-apert=',I2,'/',I3,'mm')",lowmon,highmon,datp.p([33,31,20,21])
            ;help,lowmon,highmon,datp.p([33,31,20,21])
            PRINTF,att,FORMAT="('New Config. ',I5,'/s<Monitor<',I5,'/s for lam=',F3.1,'A, alph1=',I2,'`, M-apert=',I2,'/',I3,'mm')",lowmon,highmon,datp.p([33,31,20,21])
       IF KEYWORD_SET(noprint) THEN BEGIN
              PRINT,FORMAT="(I6,A19,I7,'/s',A5)",$
                  numor,strmid(datp.other_tit,4,18),$
                    datp.n(0,0,i)/datp.pv(5,i),strmid(datp.other_tit,28,4)
          ENDIF
    ENDIF
	print,'test2'
    Mhor=datp.p(20)
    Mver=datp.p(21)
    alpha1=datp.p(31)
    wav=datp.p(33)
    IF datp.pv(5,i) LE 0 THEN BEGIN
      datp.n(0,0,i) = 0
      datp.pv(5,i) = 1
      PRINTF,att,FORMAT="(I6,I5,' CountingTime is zero or negative')",numor,i
      PRINT,FORMAT="(I6,I4,' CountingTime is zero or negative')",numor,i
    ENDIF ELSE BEGIN
          IF datp.n(0,0,i)/datp.pv(5,i) GE highmon+SQRT((datp.n(0,0,i)))/datp.pv(5,i) AND NOT highpassed THEN BEGIN
            PRINTF,att,FORMAT="(I6,I5,' Monitor too HIGH for lambda/alpha1:',I7,'/s (',F3.1,'A,',I3,'`)')",numor,i,datp.n(0,0,i)/datp.pv(5,i),datp.p([33,31])
            ;help,numor,i,datp.n(0,0,i)/datp.pv(5,i),highmon,datp.p([33,31,20,21])
            PRINT,FORMAT="(I6,I5,' Monitor=',I7,'/s>',I5,'/s for lam=',F3.1,'A, alph1=',I2,'`, M-apert=',I2,'/',I3,'mm')",numor,i,datp.n(0,0,i)/datp.pv(5,i),highmon,datp.p([33,31,20,21])
;	print,'test3'
        IF KEYWORD_SET(noprint) THEN BEGIN
              PRINT,FORMAT="(I6,A19,I7,'/s',A5)",$
                  numor,strmid(datp.other_tit,4,18),$
                    datp.n(0,0,i)/datp.pv(5,i),strmid(datp.other_tit,28,4)
          ENDIF
        FLUSH,att
        FLUSH,mon ; 20 September 2002
        highpassed=1
; 	print,'test4'
         ENDIF ELSE BEGIN
            IF datp.n(0,0,i)/datp.pv(5,i) LE  lowmon-SQRT((datp.n(0,0,i)))/datp.pv(5,i) AND NOT lowpassed THEN BEGIN
          IF datp.n(0,0,i) LE 0 THEN BEGIN
            datp.n(0,0,i) = 0
            PRINTF,att,FORMAT="(I6,I5,' Monitor is zero or negative')",numor,i
            PRINT,FORMAT="(I6,I4,' Monitor is zero or negative')",numor,i
            IF KEYWORD_SET(noprint) THEN BEGIN
                  PRINT,FORMAT="(I6,A19,I7,'/s',A5)",$
                      numor,strmid(datp.other_tit,4,18),$
                        datp.n(0,0,i)/datp.pv(5,i),strmid(datp.other_tit,28,4)
             ENDIF
          ENDIF ELSE BEGIN
                PRINTF,att,FORMAT="(I6,I5,' Monitor too low for lambda/alpha1:',I7,'/s (',F3.1,'A,',I3,'`)')",numor,i,datp.n(0,0,i)/datp.pv(5,i),datp.p([33,31])
                ;PRINT,FORMAT="(I6,I5,' Monitor too low for lambda/alpha1:',I7,'/s (',F3.1,'A,',I3,'`)')",numor,i,datp.n(0,0,i)/datp.pv(5,i),datp.p([33,31])
                PRINT,FORMAT="(I6,I5,' Monitor=',I7,'/s<',I5,'/s for lam=',F3.1,'A, alph1=',I2,'`, M-apert=',I2,'/',I3,'mm')",numor,i,datp.n(0,0,i)/datp.pv(5,i),lowmon,datp.p([33,31,20,21])
            IF KEYWORD_SET(noprint) THEN BEGIN
                  PRINT,FORMAT="(I6,A19,I7,'/s',A5)",$
                      numor,strmid(datp.other_tit,4,18),$
                        datp.n(0,0,i)/datp.pv(5,i),strmid(datp.other_tit,28,4)
             ENDIF
          FLUSH,att
                  ENDELSE
                  lowpassed=1
        ENDIF
          ENDELSE
        ENDELSE
    datp.pv(5,i)=datp.pv(5,i)<10000.
    datp.pv(5,i)=datp.pv(5,i)>0.000000125
        datp.n(0,0,i)=datp.n(0,0,i)<(100000*datp.pv(5,i))
    datp.n(0,0,i)=datp.n(0,0,i)>0
    monerr=SQRT(datp.n(0,0,i)>0.)/datp.pv(5,i) > 0.
    monerr=monerr < 1000000.
 	;print,'test5'
    IF N_ELEMENTS(monitor) EQ 0 THEN BEGIN
 	;print,'test5aa'
      monitor=(datp.n(0,0,i)/datp.pv(5,i))
      e=monerr
      x=sec/unit
      n=numor
      y=i
    ENDIF ELSE BEGIN
 	;print,'test5ab'
      monitor=[monitor,(datp.n(0,0,i)/datp.pv(5,i))]
      e=[e,monerr]
      x=[x,sec/unit]
      n=[n,numor]
      y=[y,i]
    ENDELSE
 	;print,'test5b'
    sec=sec+datp.pv(5,i)
    monitor=[monitor,(datp.n(0,0,i)/datp.pv(5,i))]
    e=[e,monerr]
    x=[x,sec/unit]
    n=[n,numor]
    y=[y,i]
 	;print,'test5c'
    IF NOT KEYWORD_SET(noplot) THEN BEGIN
 	print,'test5d'
       PLOT,x,monitor,psym=3,$
         yrange=[min(monitor),max(monitor)],$
         ytitle='Monitor/Time [cnts/sec]',$
         xtitle='Time/'+unittxt+' since '+since ,xticks=4
 	;print,'test5e'
	;help,x,monitor,e
         if n_elements(x) lt 2000 then OPLOTERR,x,monitor,e,3
 	;print,'test5f'
    ENDIF
 	;print,'test6',i
  ENDFOR 
 	;print,'test7',i
  ;help,loop
  loop=loop+1
  IF loop GE loops  THEN BEGIN
      numor=numor+1
      print,loop, " numors read, as you've asked for - that's enough for the moment, see you later!"
      OPENW ,out,filename,/get_lun
      PRINTF,out,LONG(n0),LONG(numor),LONG(refday),LONG(N_elements(monitor)),LONG(unit)
      PRINTF,out,FLOAT(x),LONG(monitor),FLOAT(e),LONG(n),ROUND(y)
      CLOSE,out
      CLOSE,cat
      CLOSE,lct
      CLOSE,all
      CLOSE,att
      CLOSE,bad
      FREE_LUN,out,cat,lct,all,att,bad
      PRINT,filename ,' and ', catname ,' written'
      flag,new=flag_restore,/noprint
      mod_datp,datp,'x',x
      mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
      mod_datp,datp,'p',[n1,numor-1]
      mod_datp,datp,'e',e
      mod_datp,datp,'n',n
      mod_datp,datp,'y',y
      mod_datp,datp,'w_tit','Monitor/time for Cycle'+STRING(cyc)
      mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n2)
      mod_datp,datp,'y_tit','cnt/sec'
      mod_datp,datp,'x_tit','time/s'+unittxt+' since '+since
      give_datp,datp
      RETURN,monitor
  ENDIF
ENDFOR
OPENW,out,filename,/get_lun
PRINTF,out,LONG(n0),LONG(numor),LONG(refday),LONG(N_elements(monitor)),LONG(unit)
PRINTF,out,FLOAT(x),LONG(monitor),FLOAT(e),LONG(n),ROUND(y)
CLOSE,out
CLOSE,cat
CLOSE,lct
CLOSE,all
CLOSE,att
CLOSE,bad
FREE_LUN,out,cat,lct,all,att,bad
PRINT,filename ,' and ', catname ,' written'
mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
mod_datp,datp,'p',[n1,numor-1]
mod_datp,datp,'e',e
mod_datp,datp,'n',n
mod_datp,datp,'y',y
mod_datp,datp,'w_tit','Monitor/time for Cycle'+STRING(cyc)
mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n2)
mod_datp,datp,'y_tit','cnt/sec'
mod_datp,datp,'x_tit','time/'+unittxt+' since '+since
give_datp,datp

return,monitor
END
FUNCTION monochrom,w,l,om,om1=om1,om2=om2,d1=d1,d2=d2,l1=l1,l2=l2
;+
; NAME:
;	MONOCHROM
; PURPOSE:
;  Creates a workspace of illumination/divergence of e.g. a sample
;  see also <A HREF="#DIVERGENCE" TARGET="_top">divergence</A>
; INPUTS:
;  W:  Workspace
;  L:  Distance from illuminator to illuminated object (monochromator)
;  Om: Angle of monochromator to axis normal (takeoff/2, pos.=reflection)
; PROJECTS:
;  two sets of slits between monochromator and sample
;  wavelength distribution and monochromator mosaic
; MODIFICATION HISTORY:
;  Written by Thomas Hansen, May 1998
;-
IF KEYWORD_SET(om2) THEN om=om2
take_datp,datp
x=datp.x
y=datp.y
wout=w*0
FOR i=0,N_ELEMENTS(y)-1 DO BEGIN
  FOR j=0,N_ELEMENTS(x)-1 DO BEGIN
    xx=ABS(x-(x(j)-l*tan(y(i)*!PI/180.)))
    xx=MIN(xx)
    wout(j,i) = cos(y(i)*!PI/180.)*w(!C,i)
  ENDFOR
ENDFOR
give_datp,datp
RETURN,wout
end
PRO animfield, xr, yr, zr, u, v, w, arrows=arrows,$
               nvecs=nvecs,size=size,$
               sx=sx,sy=sy,sz=sz, scale=scale,$
               probe=probe,nframes=nframes,$
               xtimes=xtimes,ytimes=ytimes,len=len
;+
;field2d,charge,(-.5,1.5,.1],(-.5,1.5,.1],(-.5,1.5,.1],u,v,w,sx=sx,sy=sy,sz=sz
;field2d,electrodes,(50,120,10],(380,420,10],(-1.5,1.5,1.],u,v,w,sx=sx,sy=sy,sz=sz,/prog
;SCALE3, X=(-2,2],Y=(-2,2],Z=(-2,2],ax=40,az=0
;flow3,u,v,w,arrowsize=.02,sx=sx,sy=sy,sz=sz
;-
IF NOT KEYWORD_SET(len) THEN len=2.
xsize=ABS(xr(1)-xr(0))
ysize=ABS(yr(1)-yr(0))
zsize=ABS(zr(1)-zr(0))
IF NOT KEYWORD_SET(xtimes) THEN xtimes=2
IF NOT KEYWORD_SET(ztimes) THEN ztimes=1
IF NOT KEYWORD_SET(sx) THEN sx=0
IF NOT KEYWORD_SET(sy) THEN sy=0
IF NOT KEYWORD_SET(sz) THEN sz=0
IF KEYWORD_SET(nvecs) THEN BEGIN
  sx=0
  sy=0
  sz=0
ENDIF ELSE nvecs=0
IF NOT KEYWORD_SET(scale) THEN scale=[0,MAX([N_ELEMENTS(u(*,0,0)),N_ELEMENTS(u(0,*,0)),N_ELEMENTS(u(0,0,*))])]
IF NOT KEYWORD_SET(arrows) THEN arrows=200
ASPECT=FLOAT(xsize)/FLOAT(ysize)
IF NOT KEYWORD_SEt(size) THEN sizx=400 ELSE sizx=size
sizy=sizx
WINDOW, /FREE, XSIZE=sizx, YSIZE=sizy, COLORS=-16
IF NOT KEYWORD_SET ( nframes ) THEN nframes = 160
XINTERANIMATE, SET=[sizx, sizy, nframes] 
FOR i = 0, nframes - 1 DO BEGIN 
    SCALE3, X=scale,Y=scale,Z=scale,AX=i*ROUND(xtimes)*360./nframes,AZ=i*ROUND(ztimes)*360./nframes 
    ERASE 
    PRINT,'Frame',i,', AX=',i*ROUND(xtimes)*360./nframes,', AZ=',i*ROUND(ztimes)*360./nframes
    IF KEYWORD_SET(nvecs) THEN BEGIN
      flow3,u,v,w,arrowsize=.02,nvecs=nvecs,len=len
    ENDIF ELSE BEGIN
      flow3,u,v,w,arrowsize=.02,sx=sx,sy=sy,sz=sz,len=len
    ENDELSE
    SCALE3,AX=i*720./nframes,AZ=i*360./nframes 
    XINTERANIMATE, FRAME=i, WINDOW=!D.WINDOW
ENDFOR 
WDELETE
XINTERANIMATE
END
PRO mplo,wn,$
     xrange=xr,wrange=wr,TITLE=tit,SUBTITLE=sub,XTITLE=xtit,YTITLE=ytit,$
     ps=ps,landscape=landscape,portrait=portrait,noprint=noprint,printer=printer
@lamp.cbk
wn=ROUND(wn)
wn=wn>1
wn=wn<20
wn=wn(SORT(wn))
wn=wn(UNIQ(wn))
IF NOT KEYWORD_SET(portrait)  THEN portrait =0
IF NOT KEYWORD_SET(landscape) THEN landscape=0
IF NOT KEYWORD_SET(landscape) AND NOT  KEYWORD_SET(portrait) THEN BEGIN
  IF KEYWORD_SET(eps) THEN portrait=1 ELSE landscape=1
ENDIF
TVLCT,[0,255,0,0],[0,0,255,0],[0,0,0,255]
colors=['black', 'red  ', 'green', 'blue ']
nw=N_ELEMENTS(wn)
info=''
FOR i=0,nw-1 DO BEGIN 
  take_datp,datp,w=wn(i)
  take_w,w,w=wn(i)
  PRINT,i,' : Workspace ',wn(i),', Numor:',ROUND(datp.p(29<(N_ELEMENTS(datp.p)-1))),' ',his(wn(i))
  PRINT,i,' ',colors(i mod 4),min(datp.x),'<x<',max(datp.x),min(w),'<w<',max(w),' ',W_NUMOR(wn(i))
  info=info+', W'+STRCOMPRESS(wn(i),/REMOVE_ALL)+':'+STRCOMPRESS(colors(i mod 4),/REMOVE_ALL)+'='+STRCOMPRESS(his(wn(i)))
  IF i EQ 0 THEN BEGIN
    xmin=min(datp.x)
    xmax=max(datp.x)
    wmin=min(w)
    wmax=max(w)
  ENDIF ELSE BEGIN
    xmin=min(datp.x)<xmin
    xmax=max(datp.x)>xmax
    wmin=min(w)<wmin
    wmax=max(w)>wmax
  ENDELSE
ENDFOR
i=nw-1
IF STRLEN(info) GE 190 THEN info=STRMID(info,0,190)
IF NOT KEYWORD_SET(xr)  THEN xr=[xmin,xmax]
IF NOT KEYWORD_SET(wr)  THEN wr=[wmin,wmax]
IF NOT KEYWORD_SET(sub) THEN sub=info
IF NOT KEYWORD_SET(tit) THEN tit='W'+STRCOMPRESS(wn(i),/REMOVE_ALL)+' '+STRCOMPRESS(colors(i mod 4),/REMOVE_ALL)+datp.w_tit+datp.other_tit
IF NOT KEYWORD_SET(xtit) THEN xtit=datp.x_tit
IF NOT KEYWORD_SET(ytit) THEN ytit=datp.y_tit
print,STRLEN(info)
PLOT,xr,[0,0], XSTYLE=1, YSTYLE=1, XTIT=xtit, YTIT=ytit, CHARSIZE=0.6,$
               TITLE=tit, SUBTITLE=sub,xr=xr,yr=wr,background=255,color=0

FOR i=0,nw-1 DO BEGIN 
  take_datp,datp,w=wn(i)
  take_w,w,w=wn(i)
  ns=N_ELEMENTS(w(0,*))
  FOR j=0,ns-1 DO BEGIN
    oplot,datp.x(*,j<(N_ELEMENTS(datp.x(0,*))-1)),w(*,j),color=i mod 4,line=j
  ENDFOR
ENDFOR

IF keyword_set(ps) THEN BEGIN
    IF KEYWORD_SET(eps) THEN extension='.eps' ELSE  extension='.ps' 
    mydevice=!D.NAME
    set_plot,'ps'
    psnam='mplo.ps'
    device,portrait=portrait,landscape=landscape,/color,fil=psnam

    PLOT,xr,[0,0], XSTYLE=1, YSTYLE=1, XTIT=xtit, YTIT=ytit, CHARSIZE=0.6,$
                   TITLE=tit, SUBTITLE=sub,xr=xr,yr=wr,background=255,color=0

    FOR i=0,nw-1 DO BEGIN 
      take_datp,datp,w=wn(i)
      take_w,w,w=wn(i)
      ns=N_ELEMENTS(w(0,*))
      FOR j=0,ns-1 DO BEGIN
        oplot,datp.x(*,j<(N_ELEMENTS(datp.x(0,*))-1)),w(*,j),color=i mod 4,line=j
      ENDFOR
    ENDFOR

    device,/close
    set_plot,mydevice
    IF NOT keyword_set(noprint) THEN BEGIN
      IF NOT keyword_set(printer) THEN printer='dj1_d20'
      spawn,'lp -d'+printer+' '+psnam
    ENDIF
ENDIF

END
PRO mundle,fil,resf,a,b,c

y=fltarr(10000)
x=fltarr(10000)
e=fltarr(10000)
d=fltarr(10000)
dq=fltarr(10000)

ny=fltarr(10000)
nx=fltarr(10000)
nee=fltarr(10000)
ndq=fltarr(10000)
;resf=2.

xx='xxxxx'
print,fil
openr,unit,fil,/get_lun

while strmid(xx,1,3) ne 'lam' do begin
  readf,unit,xx
  print,xx
;  print,'looking for lam',strmid(xx,1,3)
endwhile

readf,unit,xx
print,xx

k=.00001 & l=.000001 & m=.000001 & n=.000001

i=0
while  not eof(unit) do begin
if i eq 0 then print,'start read data'

readf,unit,k,l,m,n
print,k,l,m,n
 
 x(i)=k & y(i)=m & e(i)=n & dq(i)=l
 i=i+1
endwhile

num=i
print,'total number inthe beginning: ',num


c=0
itt=4
tot=num

for k=0,itt do begin
 blim=0
 c=0
 num=tot
 new=0
 pairs=0
 print,'itteration: ',k+1


for i=0,num do begin

  if (x(c+1)-x(c) lt dq(c)/resf and x(c+1) ne 0) then begin
     ny(new)=(y(c+1)+y(c))/2.
     nee(new)=(sqrt(e(c)^2.+e(c+1)^2.))/2
     nx(new)=(x(c)+x(c+1))/2.
     ndq(new)=(dq(c)+dq(c+1))/2.
     pairs=pairs+1
     print,'found a pair:'
     c=c+1
     tot=tot-1
     blim=0
  endif else begin
     ny(new)=y(c)
     nx(new)=x(c)
     nee(new)=e(c)
     ndq(new)=dq(c)
  endelse
new=new+1 
c=c+1

endfor
 y=ny
 x=nx
 e=nee
 dq=ndq

 print,'tot num,new,pairs:',tot,num,new,pairs
 if (blim eq 0) then itt=1
endfor

a=alog10(ny(0:tot-1)) & b=nx(0:tot-1) & c=(nee(0:tot-1)/ny(0:tot-1))/alog(10)
;a=ny & b=nx & c=nee

free_lun,unit


while (((i=strpos(fil,'out'))) ne -1) do strput,fil,'aft',i


title='spanner'
nb=2.07
print,fil
openw,unit,fil,/get_lun
printf,unit,'"AFIT"'
printf,unit,'"'+title+'"'
printf,unit,format='(f4.2)',nb
printf,format='(i3)',unit,tot
for i=0,tot-1 do begin

 printf,unit,format='(g10.4,10x,g10.4,10x,g10.4)',nx(i),ny(i),nee(i)
endfor

close,unit
free_lun,unit


return
print,!stime
end
pro mv,mot,value


valstr=strtrim(string(value),2)
dummy=dial_mad_send('',0,mot+' '+valstr,'')
print,'sent command: '+mot+' '+valstr
   
wait,.8
stat=DIAL_MAD_READ('status')
;print,stat
 stat=strtrim(stat,2)
 while stat eq 'POSITIONNING' do begin
  stat=DIAL_MAD_READ('status')
  stat=strtrim(stat,2)
;  print,stat
 endwhile
wait,.5

end
;	***************************
	     pro myhelp_d20, TEXT
;	***************************

;This is effective when the string-array TEXT is more than one element.

text=[$
'**************************************************************************',$
'* THIS IS A HELP FOR D20 USERS OF LAMP (X11 version)                      ',$
'* For all information, please contact Thomas HANSEN (hansen@ill.fr, 7044) ',$
'*                                                                         ',$
"* Please use the users manual you'll find via a WWW-browser like Netscape ",$
'* on http://www.ill.fr/YellowBook/D20 (click on D20 information)          ',$
'* Use the toolchest to open a Web Browser (pop up menu Internet)          ',$
"* In Netscape's Options - Network Preferences - Proxies define no proxy   ",$
'* for ill.fr (www.ill.fr etc.) or use server http://proxy.ill.fr/proxy.pac',$
'*                                                                         ',$
'**************************************************************************',$
'',$
'READING DATA:',$
'	Chose the correct path with the data acces button',$
' The base "C_Year 1998 L" is stored locally on d20sgi.ill.fr for fast access',$
' If recent data are still not transfered, On_Line accesses directly d20.ill.fr',$
'',$
'	Select the workspace with the arrows',$
'	Type the correct numor or numor range in the window and press "read"',$
'	A numor range to be added up is specified with a ">" sign (Ex: 20010>20014)',$
'	A numor range to be read in a 3D-workspace with a ":" sign (Ex: 20010:20014)',$
'	"::" will read in only every second numor (Ex: 20010::20014 reads only even numors)',$
'',$
'	The data may be automatically calibrated with the right file in d20sgi.ill.fr:~lambda/CALIBRATION',$
'	If you set the right flag: type "flag,/eff"',$
'',$
'	Bad detector cells may be excluded by taking information from the right file in  d20sgi.ill.fr:~lambda/BAD_CELLS',$
'	If you set the right flag: type "flag,/bad"',$
' They will be linearly interpolated then by choosing "flag,/int"',$
' or excluded by "flag,/noint"',$
'',$
' You may opt for monitor normalisation during reading in by flag,/nor or flag,nor=10000',$
' This will be applied to each acquisition BEFORE eventually beeing added up',$
'',$
' Use the selector access button that opens a window called filter to read data',$
' into Workspace W20 (you can copy it afterwards, e.g. "W6=W20"). Using this you',$
' may choose the option M. for monitor normalisation AFTER adding up several numors',$
' (e.g. 44500>44600)',$
'',$
' Use GK_fit for simple peak fitting',$
' Use SuperPlot for superposing plots',$
' Use UserMacros for an overview of existing macros',$
' Use DataParameters for looking at fixed parameters for a workspace',$
' Use BeGood for changing titles, plot options and printer',$
' Use the command "?" to open an exhausing help-window on IDL - the original macro-language to LAMP',$
'',$
'	PROCEDURES:',$
' Please use the WWW D20 Manual or the "User Macros" button',$
' In the nowindows version of lamp (lamp -nw) you may type "procedures"',$
'',$
'	FUNCTIONS:',$
' Please use the WWW D20 Manual or the "User Macros" button',$
' In the nowindows version of lamp (lamp -nw) you may type "functions"',$
'',$
'		w_accu, accu=n1,add=n2',$
'		  Accumulates the data in workspace n2 into workspace n1.',$
'		  Statistics are properly accounted for.',$
'		  This is useful to add data from different ranges or with different "dud".',$		      	
'		  Also, it can be used to subtract data sets.',$
'		  Ex:	w_accu, accu=w10,add=w6',$
'			w7=-w7',$
'			w_accu, accu=w10,add=w7',$
'			This series of commands subtracts w7 from w6',$
'			and stores the result in w10'$

]

end
;	***************************
	     pro myhelp_d2b, TEXT
;	***************************

;This is effective when the string-array TEXT is more than one element.

text=[$
'*****************************************************************************',$
'* THIS IS A HELP FOR D2B USERS OF LAMP                                        ',$
'* For information on LAMP, please contact Thomas HANSEN (hansen@ill.fr, 7044) ',$
'*****************************************************************************',$
'',$
'READING DATA:',$
'	Chose the correct path with the data acces button',$
'   If recent data are still not transfered, On_Line accesses directly d2b.ill.fr',$
'',$
'	Select the workspace with the arrows',$
'	Type the correct numor or numor range in the window and press "read"',$
'	A numor range to be merged is specified with a ">" sign (Ex: 51568>51572)',$
'',$
'	The data will be automatically calibrated with the file d2b.cal ~lambda/CALIBRATION',$
'   Type "calibration" in a formula window and "DO" to show a list of possible calibration files',$
'   and choose the file you want for calibration with "load"',$
'',$
'	Bad detector cells may be excluded by typing, e.g. "dud,det=32,pts=0" in a formula window',$
'',$
'   If the "raw" button beside the "read" button is active, no monitor normalization will be done',$
'   which may give strange merged diagrams from several numors',$
'   Deactivating this radio button will normalize a range of numors always to the average monitor counting rate',$
'',$
' Use the selector access button that opens a window called filter to read data',$
' into Workspace W20 (you can copy it afterwards, e.g. "W6=W20"). Using this you',$
' may choose the option M. for monitor normalisation AFTER adding up several numors',$
' (e.g. 44500>44600)',$
'',$
' Use GK_fit for simple peak fitting',$
' Use SuperPlot for superposing plots',$
' Use UserMacros for an overview of existing macros',$
' Use DataParameters for looking at fixed parameters for a workspace',$
' Use Options... for changing titles, plot options and printer',$
' Use the command "?" to open an exhausing help-window on IDL - the original macro-language to LAMP',$
'',$
'	PROCEDURES:',$
' Please use the the "User Macros" button',$
' In the nowindows version of lamp (lamp -nw) you may type "procedures"',$
'',$
'	FUNCTIONS:',$
' Please use the "User Macros" button',$
' In the nowindows version of lamp (lamp -nw) you may type "functions"',$
'',$
' Some ancient stuff ...: ',$
'		w_accu, accu=n1,add=n2',$
'		  Accumulates the data in workspace n2 into workspace n1.',$
'		  Statistics are properly accounted for.',$
'		  This is useful to add data from different ranges or with different "dud".',$		      	
'		  Also, it can be used to subtract data sets.',$
'		  Ex:	w_accu, accu=w10,add=w6',$
'			w7=-w7',$
'			w_accu, accu=w10,add=w7',$
'			This series of commands subtracts w7 from w6',$
'			and stores the result in w10'$

]

end
;	***************************
	     PRO myhelp_d7, text
;	***************************

;This is effective when the string-array TEXT is more than one element.

	ON_IOERROR, finished

	OPENR, 1, '/home/cs/lambda/macros/D7/lampbook.txt'

	text=''	& line=''	& sline=''

	WHILE (NOT EOF(1)) DO BEGIN
		READF, 1, line
		l=STRLEN(line)
		IF (l LE 80) THEN BEGIN
			sline=line
		ENDIF
		s=0
		WHILE (l GT 80) DO BEGIN
			l=l-s
			IF (l GT 80) THEN s=RSTRPOS(STRMID(line,0,80),' ') $
					ELSE s=l
			sline=[sline,STRMID(line,0,s)]
			line=STRMID(line,s+1,l)
		ENDWHILE
		text=[text,sline]
	ENDWHILE

finished:

	CLOSE, 1

	RETURN
	END
;	***************************
	     PRO myhelp_in4, text
;	***************************

;This is effective when the string-array TEXT is more than one element.

	ON_IOERROR, finished

	OPENR, 1, '/home/cs/lambda/macros/IN4/helpin4.txt'

	text=''	& line=''	& sline=''

	WHILE (NOT EOF(1)) DO BEGIN
		READF, 1, line
		l=STRLEN(line)
		IF (l LE 80) THEN BEGIN
			sline=line
		ENDIF
		s=0
		WHILE (l GT 80) DO BEGIN
			l=l-s
			IF (l GT 80) THEN s=RSTRPOS(STRMID(line,0,80),' ') $
					ELSE s=l
			sline=[sline,STRMID(line,0,s)]
			line=STRMID(line,s+1,l)
		ENDWHILE
		text=[text,sline]
	ENDWHILE

finished:

	CLOSE, 1

	RETURN
	END
;	***************************
	     pro myhelp, TEXT
;	***************************

;This is effective when the string-array TEXT is more than one element.

text=['This text is printed when the user clicks on the first ? of lamp']

end
PRO myinit_d11

RDSET, inst='D11', base='d11', /raw
SETMANIP, /raw

RETURN
END
;+
;	*********************
	    pro myinit_d20
;	*********************

; You can insert here the codes you want to execute just after LAMP is loaded.
; This special procedure is thought for D20 (DIF) mainly.
; Last modification:	Thomas C Hansen,	November 2000	(Documentation, MK_HTML_HELP)
;-
if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION RDID, sys_dep')
common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
common c_lamp,	lamp_b1,lamp_act,lamp_focus,lamp_mic,lamp_don,lamp_did,lamp_ben,lamp_wrd,$
        		lamp_data,lamp_host,lamp_dir,lamp_sys,lamp_exec,lamp_entry,lamp_devps,$
        		lamp_hlp,lamp_siz,lamp_loc ,lamp_cyc,lamp_man ,lamp_dvd,lamp_asite,lamp_fsite,$
        		lamp_ins,lamp_proc,lamp_grp,lamp_ali,lamp_path,lamp_touch,lamp_macro,$
        		lamp_ziz,lamp_6,lamp_proxy,lamp_wrti,lamp_wrtp
IF N_ELEMENTS(LAMP_DEVPS) GT 0 THEN BEGIN
  IF STRLEN(LAMP_DEVPS) LE 1 THEN LAMP_DEVPS='lj1_d20'
ENDIF ELSE LAMP_DEVPS='lj1_d20'
IF (sys_dep('MACHINE') eq 'unix') THEN SPAWN,'rm -r .HS*'
p_lambda,plambda
IF (sys_dep('MACHINE') eq 'unix') THEN SPAWN,'rm -r '+plambda+'.HS*'
RDSET,inst='D20',base='ON_Line'
username=sys_dep('GETENV','USER')
PRINT,'User : ',username
cd,current=a
PRINT,'Current Working Directory : ',a
IF STRMID(username(0),0,6) EQ 'hansen' THEN BEGIN
  MK_HTML_HELP,'/home/cs/lambda/macros/DIF','/home/cs/lambda/macros/DIF/macp.html' ,TITLE='LAMP macros for DIF - serhom.ill.fr:/home/cs/lambda/macros'            
ENDIF
;if (sys_dep('MACHINE') eq 'mac') THEN MK_HTML_HELP,'HansenG3:lambda:macros','HansenG3:lambda:macros:macp.html' ,TITLE='MACP external LAMP macros - porthansen.ill.fr/HansenG3:lambda:macros:'
print,' '
a=rdid(0)
a=0
flag;,/eff
;pathcal
PRINT,pathcal
print,' '
print,'Type "functions" or "procedures" for a list of functions/procedures'
print,'Type "idl" for some hints on IDL - the basic language of LAMP'
print,'Type "workspaces" for some informations about this basic LAMP concept'
print,'Type w6=rdrun(34444), w7=rdsum(2344,2346) or w8= rdand(56798,56890) to read data'
print,' '
;d20_widget
end
PRO myinit_d22

RDSET, inst='D22', base='d22', /raw
SETMANIP, /raw

RETURN
END
PRO myinit_d2b

RDSET, inst="d2b",base="Current Cycle"
setmanip,/raw

end
PRO myinit_d7

RDSET, inst='D7', base='d7', /raw
SETMANIP, /raw

RETURN
END
PRO myinit_in4

RDSET, inst='IN4', base='in4', /raw
SETMANIP, /raw

RETURN
END
PRO myinit_in6

RDSET, inst='IN6', base='in6', /raw
SETMANIP, /raw

END
;	*********************
	    pro myinit
;	*********************

;You can insert here the codes you want to execute just after LAMP is loaded.
;See INTERNAL.pro for a list of lamp commands.

;RDSET,base='Current Cycle'
;mat=DIST(50)
;GIVE_W,mat,w=1
;SEE,w=1,/surface

end
;===============================================================================
; This procedure does all the calculations. It is called by nbcalc_event when 
; the calc. button is pressed. The string containing the chemical formula is
; passed as the argument 'compound'. The procedure first reads the file 
; containing the isotope data. This is inefficient because the file is read 
; each calculation, but it enables the user to modify the file while the 
; programme is still running (e.g. if the user wants to use an element/isotope
; which isn't in the file.) Then the string 'compound' is processed. To 
; determine the isotopes present and how many of each is in the formula.
; Numerous error checks are made. The result of all of this is a 2d array
; with an 'index' number of each isotope encountered and the 'multiplicty'
; i.e. the number of times it occurs in the formula.
;===============================================================================
PRO docalc,compound,density

; Common block to return isotope selected from selector window
COMMON iso,isel

;***************************************
; Open data file and read info. This is
; done each time a 'CALCULATE' is 
; pressed so the user can edit
; data fiel 'nbcalc.dat' while the 
; programme is running.

; open data file for reading
	CLOSE,10
	OPENR,10,'nbcalc.dat',ERROR=err
; if the file cannot be found locally then try remotely
	IF (err NE 0) THEN BEGIN 
		PRINT,'Unable to open nbcalc.dat in local directory. Trying remotely...'
		CLOSE,10
		OPENR,10,'/home/cs/lambda/macros/D17/GENERAL/nbcalc.dat',ERROR=err
; If file can't be found then signal error
		IF (err NE 0) THEN BEGIN
			PRINT,'Error: Cannot open nbcalc.dat'
			errormessage,'Cannot open nbcalc.dat!'
			RETURN
		END
		PRINT,' * Standard nbcalc.dat fetched from remote directory.'
	END
	
; set up catalogue of entries for the data of each isotope (up to 400)
	catalogue=REPLICATE({isotope, z:0, symb:'', m:0.0, b:0.0, a:0.0},400)
	
; read header and discard
	header=''
	READF,10,header
	READF,10,header
	READF,10,header
	
; counter for catalogue
	i=0
; define the types of the various fields in each entry
	z=0
	symb=''
	m=0.0
	b=0.0
	a=0.0
; read the entire file into the catalogue
	WHILE (NOT EOF(10)) AND (i LE N_ELEMENTS(catalogue)-1) DO BEGIN 
; note the strict formatting used in the data file...
		READF,10,z,symb,m,a,b,FORMAT='(I2,1X,A2,5X,F9.5,2X,F9.4,3X,F13.6)'
; set values
		catalogue[i].z=z
		catalogue[i].symb=STRCOMPRESS(symb,/REMOVE_ALL)
		catalogue[i].m=m
		catalogue[i].b=b
		catalogue[i].a=a
; increment counter
		i=i+1
	END
	CLOSE,10	
; number of isotopes read (i.e. maximum index of isotopes)
	nentries=i
	
;***************************************
; Process string to determine chemical 
; formula.

; array to contain up to 100 of (isotope index,number of isotope in formula)
	isotopes=INTARR(100,2)
; counter for isotopes appearing in the formula
	nisotopes=0
	
; remove whitespace and convert string to vector of bytes 
	compound = BYTE(STRCOMPRESS(compound, /REMOVE_ALL))

; IF 1st character of compound is the string terminator then no formula has been entered
	IF compound[0] EQ 0B THEN BEGIN
		errormessage,'Please enter a chemical formula!'
		RETURN
	END

; add a null terminator to the end of the string so can tell when to stop
	compound = [compound,0B]
	
;string index
	strind=0
; done flag
	done = 0
	WHILE NOT done DO BEGIN
	
; Check if current character is the first letter of a symbol (a capital). If not then
; signal error (see else statement below)
		IF compound[strind] GE 65B AND compound[strind] LE 90B THEN BEGIN
		
; Some elements have two characters, e.g. Fe. Check for a second lower case
			IF compound[strind+1] GE 97B AND compound[strind+1] LE 122B THEN BEGIN
; If so make a two character symbol string
				symbol=STRING(compound[strind:strind+1])
				strind=strind+2
			ENDIF ELSE BEGIN
; otherwise its just one char. ,e.g. C (carbon)
				symbol=STRING(compound[strind])
				strind=strind+1
			END

; Now look up in the catalogue of data to find the element 'symbol'
; A temporary array to contain all of the indices of isotopes of element 'symbol'
			iso_index=INTARR(20)
; counts the number of isotopes of the element
			counter=0
; loop over all entries of the catalogue
			FOR i=0,nentries-1 DO BEGIN
; If the element corresponds to symbol then add then save the index of that isotope
				IF symbol EQ catalogue[i].symb THEN BEGIN
					iso_index[counter]=i
					counter=counter+1
				END
			END
; If symbol wasn't in the catalogue then signal unknown element error
			IF counter EQ 0 THEN BEGIN
				errormessage,'Element ' + symbol + ' is unknown. (Add it to nbcalc.dat then press CALCULATE again)'
				RETURN
			END

; If there is only one isotope of element 'symbol' then simply copy the catalogue index
; into the array of isotopes in the formula
			IF counter EQ 1 THEN BEGIN
				isotopes[nisotopes]=iso_index[0]
			ENDIF ELSE BEGIN
; make an array of strings containing the masses of the isotopes for this element
				masses=STRARR(counter)
				masses[*]=STRING(catalogue[iso_index[0:counter-1]].m)
; bring up a window for the user to select the desired isotope which is then
; place in the common variable isel
				isel=-1
				isoselector,symbol,masses,strind-1
; place the selected isotope into the isotope array
				isotopes[nisotopes,0]=iso_index[isel]
			END
			
;Find number of times element occurs in compound (e.g. in H2O (water) number of H's is 2)

; num_len gives the length of the integer following the element (e.g. length=1 for the '2' in 'H2O')
			num_len=0

; look for a number, find its length in characters
			WHILE (compound[strind+num_len] GE 48B) AND (compound[strind+num_len] LE 57B) DO num_len=num_len+1
				
; if there are no 'suffix' numbers then element occurs once by default
			If num_len EQ 0 THEN isotopes[nisotopes,1]=1 ELSE BEGIN 
; otherwise convert to an integer
				num_el=FIX(STRING(compound[strind:strind+num_len]))
; check that it's not zero (that's just silly!)
				IF num_el EQ 0 THEN BEGIN
					errormessage,'Element '+symbol+' has suffix number zero! Check formula (zeroes look a lot like the letter O)'
					RETURN
				END
; store the number 
				isotopes[nisotopes,1]=num_el
			END
; increment string index by number of characters of number
			strind=strind+num_len
			
; set done flag to true if the end of the chemical formula is reached
			IF compound[strind] EQ 0B THEN done=1

; Print out to console which elements and isotopes have been found and how many there are of them
			PRINT,'Element ',symbol,', mass isotope',catalogue[isotopes[nisotopes,0]].m,' found ',isotopes[nisotopes,1],' time(s)'

; increment number of isotopes found in formula
			nisotopes=nisotopes+1

; Expected 1st letter next element to be capital, but it isn't so signal error
		ENDIF ELSE BEGIN
			errormessage,'Illegal character "'+STRING(compound[strind])+'". Element symbol starting with capital letter expected.
			RETURN
		END
	END

; sum up masses, scattering length and a:
; Mass:
	sum_mass=total(catalogue[isotopes[*,0]].m*isotopes[*,1])
; b:
	sum_b=total(catalogue[isotopes[*,0]].b*isotopes[*,1])
; a:
	sum_a=total(catalogue[isotopes[*,0]].a*isotopes[*,1])

; calculation of scattering length density
	nb=(sum_b*1.0e-23*density*6.02214e23)/sum_mass
; calculation of absorption
	ab=1/((sum_a*1.0e-28*density*1.0e6*6.02214e23)/sum_mass)

	results,STRING(compound),density,nb,ab
END

;===============================================================================
; shows isotope selection window and prompts user to select one
; element is a string containing the element symbol. isomasses is an array
; of strings of the isotope masses to label the buttons. strind is the index
; at which the element (whose isotope is desired) occurs. This is used to indicate
; which symbol we want the isotope for.
;===============================================================================
PRO isoselector,element,isomasses,strind

; common block containing base's id
COMMON widgetid,base,formula,dense
; common block containing isotope selector buttons
COMMON alig,bo_selector

	selbase = WIDGET_BASE(GROUP_LEADER=base,/FLOATING,/MODAL,TITLE='Select Isotope',/COLUMN)
	
; display blurb
	dummy = WIDGET_LABEL(selbase,VALUE='Please select isotope of '+element)
	dumbshit = WIDGET_LABEL(selbase,VALUE='Position in formula shown below:')
; get the string containging the formula and remove all whitespace. convert to byte array
	WIDGET_CONTROL,formula,GET_VALUE=compound
	compound = BYTE(STRCOMPRESS(compound[0],/REMOVE_ALL))
; tack some extra space at the end to stop errors due on line below.
	compound = [compound,32B,32B]
; form a string containing the chemical formula with a sodding great arrow pointing to the element in question
	pos_string=STRING(compound[0:strind])+' <===(!)   '+STRING(compound[strind+1:N_ELEMENTS(compound)-1])
; display formula with arrow pointing to element whose isotope is requested
	cleverchap = WIDGET_LABEL(selbase,/ALIGN_LEFT,VALUE=pos_string)
	
; now put up some buttons to prompt user to select an isotope
	bo_selector = CW_BGROUP(selbase,isomasses, /EXCLUSIVE, UVALUE='',/COLUMN,LABEL_TOP='Please choose',/FRAME)
	dummy = WIDGET_LABEL(selbase,VALUE='NB: Natural abundance')
	dummy = WIDGET_LABEL(selbase,VALUE='<should> be  1st in list')
	WIDGET_CONTROL,bo_selector,SET_VALUE=0
; put ok button at bottom. User value 'sel' enables message_event to know that
; the user has just selected an isotope
	ok_butt = WIDGET_BUTTON(selbase,VALUE='OK',UVALUE='sel')
	
; now realise it and leave the procedure message_event to pick up the pieces...
	WIDGET_CONTROL,selbase,/REALIZE
	XMANAGER,'message',selbase
END

;===============================================================================
; Shows results window. form=string containing chemical formula.
;===============================================================================
PRO results,form,density,nb,ab

; common block holding the base's id
COMMON widgetid,base,formula,dense

	result_base = WIDGET_BASE(GROUP_LEADER=base,/COLUMN,/FLOATING,TITLE='Results for '+form)
	dummy = WIDGET_LABEL(result_base,/ALIGN_CENTER,VALUE='Compound '+form+' has density '+STRCOMPRESS(STRING(density),/REMOVE_ALL)+ ' g/cm^3')
	dummy = WIDGET_LABEL(result_base,/ALIGN_CENTER,VALUE='Scattering length density = '+STRCOMPRESS(STRING(nb),/REMOVE_ALL))
	dummy = WIDGET_LABEL(result_base,/ALIGN_CENTER,VALUE='Absorption length = '+STRCOMPRESS(STRING(ab),/REMOVE_ALL))

	big_butt=WIDGET_BUTTON(result_base,VALUE='OK',UVALUE='ok')

	WIDGET_CONTROL,result_base,/REALIZE
	XMANAGER,'message',result_base
END
;===============================================================================
;shows error message window
;===============================================================================
PRO errormessage,messy

; common block holding the base's id
COMMON widgetid,base,formula,dense

; desensitise base
	WIDGET_CONTROL,base,SENSITIVE=0
;create floating message widget
	msg_base=WIDGET_BASE(GROUP_LEADER=base,/FLOATING,TITLE='Error Message',/COLUMN)

; label and give widget a button with 'ok' on
	mess=WIDGET_LABEL(msg_base,VALUE=messy)
	errbut=WIDGET_BUTTON(msg_base,VALUE='OK',UVALUE='ok')

; realise and pass control to event handler
	WIDGET_CONTROL,msg_base,/REALIZE
	XMANAGER,'message',msg_base,/JUST_REG
	RETURN
END

;===============================================================================
;handles events from errormessage, isoselector and results
;===============================================================================
PRO message_event,event

; common block for base widget ID
COMMON widgetid,base,formula,dense
; common block containing isotope selector buttons
COMMON alig,bo_selector
; Common block to return isotope selected
COMMON iso,isel

; get user value from button that caused event
	WIDGET_CONTROL,event.id,GET_UVALUE=ev,GET_VALUE=val
; If Okay button was pressed then resensitise the base widget and destroy
; the message widget
IF ev EQ 'ok' THEN BEGIN
	WIDGET_CONTROL,event.top,/DESTROY
	WIDGET_CONTROL,base,SENSITIVE=1
ENDIF

; If the window is the isotope selector and the ok button is pressed then
; return the isotope number

IF ev EQ 'sel' THEN BEGIN
		WIDGET_CONTROL,bo_selector,GET_VALUE=isel
		WIDGET_CONTROL,event.top,/DESTROY
ENDIF

END

;===============================================================================
; Displayshelp file nbcalc.txt
;===============================================================================
PRO helpwin

; common block for important widget id's	
COMMON widgetid,base,formula,dense

; open help file for reading
	CLOSE,10
	OPENR,10,'nbcalc.txt',ERROR=err
; if the file cannot be found locally then try remotely
	IF (err NE 0) THEN BEGIN 
		PRINT,'Unable to open nbcalc.txt in local directory. Trying remotely...'
		CLOSE,10
		OPENR,10,'/usr/ill/bin/nbcalc.txt',ERROR=err
; If file can't be found then signal error
		IF (err NE 0) THEN BEGIN
			errormessage,'Cannot open help file nbcalc.txt!'
			RETURN
		END
		
	END

; array of strings for each line of the help file
	line=STRARR(200)
; auxilliary string to read in each line. Should be able to just read
; each line into an element of the string array line, but IDL doesn't seem
; to do that!
	lined=''
; line counter
	i=0
	
	WHILE (NOT EOF(10)) AND i LT 200 DO BEGIN
		READF,10,lined
		line[i]=lined
		i=i+1
	END
	CLOSE,10

	help_base = WIDGET_BASE(GROUP_LEADER=base,/COLUMN,/FLOATING,TITLE='Help!')
	helpfile = WIDGET_TEXT(help_base,VALUE=line,/WRAP,YSIZE=30,XSIZE=55,/SCROLL)
	big_butt=WIDGET_BUTTON(help_base,VALUE='OK',UVALUE='ok')

	WIDGET_CONTROL,help_base,/REALIZE
	XMANAGER,'message',help_base
END

;===============================================================================
; Event handler for main base widget
;===============================================================================
PRO nbcalc_event,ev

; common block for important widget id's	
COMMON widgetid,base,formula,dense

	WIDGET_CONTROL,ev.id,GET_UVALUE=option
	IF option EQ 'quit' THEN WIDGET_CONTROL,ev.top,/DESTROY
; If 'CALCULATE' button is pressed then get chemical compound and call docalc
	IF option EQ 'help' THEN BEGIN
		helpwin
		RETURN
	END
	IF option EQ 'do' THEN BEGIN
; desensitize base and get formula and density
		WIDGET_CONTROL,base,SENSITIVE=0
		WIDGET_CONTROL,formula,GET_VALUE=compound
		WIDGET_CONTROL,dense,GET_VALUE=d
		density=FLOAT(STRCOMPRESS(d[0],/REMOVE_ALL))	
; error check for density
		IF density LE 0.0 THEN BEGIN
			errormessage,'Density must be a real number greater than 0.0.'
			RETURN	
		END
		docalc,compound[0],density
		WIDGET_CONTROL,base,SENSITIVE=1
	END
END

;===============================================================================
; Main procedure. Draws user interface.
;===============================================================================
PRO nbcalc

; common block for important widget id's	
COMMON widgetid,base,formula,dense

; Create user interface:
	base = WIDGET_BASE(TITLE='NbCalc',/COLUMN)
	
	dummy = WIDGET_LABEL(base,YSIZE=10,VALUE='')
	dummy = WIDGET_LABEL(base,/ALIGN_CENTER,VALUE='Enter chemical formula below')
; The example is FLaNGe5. In the original programme ArSe5 was the example.
; Other amusing ones are NiCeArSe, PUS5Y, PoON,BiTcH, and the very
; rude Fluorine-Uranium-Carbon-Potassium.
; (GaMoNFLaP5 is also quite funny!)
	dummy = WIDGET_LABEL(base,/ALIGN_CENTER,VALUE=' (e.g. FLaNGe5)')
	formula = WIDGET_TEXT(base,/EDITABLE,VALUE='')
	dummy = WIDGET_LABEL(base,YSIZE=10,VALUE='')
	dummy = WIDGET_LABEL(base,/ALIGN_CENTER,VALUE='Enter substance density below')
	dummy = WIDGET_LABEL(base,/ALIGN_CENTER,VALUE='(g/cm^3)')
	dense = WIDGET_TEXT(base,/EDITABLE,VALUE='')
	do_button = WIDGET_BUTTON(base,VALUE='CALCULATE',UVALUE='do')
	help_button = WIDGET_BUTTON(base,VALUE='HELP',UVALUE='help')
	quit_button = WIDGET_BUTTON(base,VALUE='QUIT',UVALUE='quit')
	
; Realise
	WIDGET_CONTROL,base,/REALIZE
	XMANAGER,'nbcalc',base,/JUST_REG
END
PRO NewAnimation,win,nframes,xsize,ysize
WINDOW, /FREE, COLORS=-16,xsize=xsize,ysize=ysize
win=!D.WINDOW
IF NOT KEYWORD_SET ( nframes ) THEN nframes = 160
XINTERANIMATE, SET=[xsize, ysize, nframes] 
END

PRO AddNewFrame,win,frame
XINTERANIMATE, FRAME=frame, WINDOW=win
END


PRO CloseAnimation,win
WDELETE,win
XINTERANIMATE
END
pro blap
openr,3,'data.'
x=indarr(50000)
y=indarr(50000)
picture=indarr(1000,1000)
readf,3,x,y

for i=1,50000 do begin
  picture(x(i),y(i))=picture(x(i),y(i))+1 
endfor

window,0,retain=2,xsize=2000,ysize=2000
contour,picture,levels=ll,c_colors=indgen(10)*25
close,3
end
FUNCTION newfit,ww,a,$
                 PRINT=printing,PLOT=plot,file=file,nowindow=nowindow,$
                 xx=xx,ee=ee,yy=yy,datpp=datpp,$
                 xmin=xmin,xmax=xmax,$
                 nbgterms=nbgterms,npeaks=npks,$
                 amplitude=amplitude,bg=bg,position=position,width=width,intensity=intensity,eta=eta,$
                 H=H,S=S,L=L,sig_H=sig_H,sig_S=sig_S,sig_L=sig_L,$
                 sig_amplitude=sig_amplitude,sig_bg=sig_bg,sig_position=sig_position,sig_width=sig_width,sig_intensity=sig_intensity,sig_eta=sig_eta,$
                 TOL=TOL,ITMAX=ITMAX,$
                 UVW=UVW,pVoigt=pVoigt,click=click,guess=guess,search=search,$
                 inputfile=inputfile,outputfile=outputfile,maxwidth=maxwidth,maxsearchwidth=maxsearchwidth,minwidth=minwidth,$
                 damping=damping,iterations=iterations,bragg=bragg_shape,rectangle=rectangle_shape,HR=HR,sig_HR=sig_HR,$
		 GUI=GUI,backwards=backwards,initialiterations=initialiterations,widget=widget,noderivative=noderivative,func=func
;+
; Started: 04-Nov-96 by Th.Hansen, ILL-Grenoble
; Gaussian fit for sequential diagrams and multiple peaks - now also Convolution with Bragg, Lorentz (pseudo-Voigt) and asymmetry (Finger-Cox-Jephcoat)
;
; w is a LAMP workspace, it might be three-dimensional 
; - in that case sequential fits will be performed
; a is a vector 
;
; new: the vector a contains npeaks * peakpars (amplitude, position and FWHM, evtl. eta) + nbg numbers, 
;      with nbg = 1 (constant bg), 2 (linear bg.) or 3 (square bg.), etc.
;
; 'a' can be given as a vector, read from a file ('inputfile'), made graphically interactively ('click') or created automatically if not given, or set to zero
; The number of peaks to be found automatically has to be given ('npeaks'), except for graphical search ('click')
; The number of background polynom terms ('nbgterms') has to be given, also with keyword 'click'
; The refined values and sigmas can be overtaken with keyword parameters such as 'intensity', 'amplitude','bg', 'sig_intensity', 'sig_amplitude', or 'sig_bg', etc.
; These parameters will be two-dimensional (number of diagrams * number of peaks/background polynom terms)
; IF FWHM have to be determined from automatic peak-search, then they can be taken optionally from a Cagliotti function, 'UVW' then has to be given as a vector
; With the keyword 'pVoigt' set, peaks will be fitted as pseudo-Voigt function instead of pure Gauss
; The initial guess can be written out to a file ('outputfile') or a variable ('guess')
; Some output can be written to screen ('print') and/or to a file ('file')
; Graphical output will be created when 'plot' is set, 'nowindow' will force this output to the last used window and open no new one
; If not working in a LAMP environment, the necessary additional workspace data X (x-axis) and E (errors) can (must?) be given via the keywords 'xx' and 'ee',
; or - if inside a structure datp containing datp.x and datp.e - as a structure via the keyword 'datpp'
; The default damping factor of 0.5 and number of iterative (10) least square curve fits can be changed ('damping', 'iterations')
; If taken from a inputfile, each parameter has an individual damping factor, found in every second line, as written to the file with 'outputfile'
; 'backwards' starts from the last diagram of a fiven workspace instead the first one
;
; Well, all that widget stuff (keyword 'click' or 'GUI') has not yet been documented, well, as it SHOULD be self-explaining ;-)
; You can until the clicking on background points (which you can undo as well now) change the order of the polynom
; As long as you have not stopped the background determination (by clicking on the corresponding button), you can change some settings 
; of the peakshape function (asymmetry after Finger-Cox-Jephcoat, pseudo-Voig or simple Gauss, Rectangle convolution, Bragg-formula convolution),
; later I shall try to allow for those changes at a later state as well (which is difficult however, as it might change the number of parameters on the road).
;
; If you work with an inputfile, you may define peaks as well which will emerge only later, giving an amplitude of zero
; These peaks won`t be taken into account during the refinement of the first pattern, from than on, before each run of the 
; least squares routine (iterations+1 times for each pattern, containing itmax proper least sqare iterations each - or less, damping applied inside),
; the peaks are checked: if they are non-zero and their presence improves the fit, then they are taken as they are as inital guess,
; if not, then the maximum difference count rate at the presumed peak position plus minus three sigma is taken, 
; if this (minus the background and the other peaks) is less than the counting error, 
; the peak is not taken, otherwise, it is checked, if the peak with this counting improves chi2 more than 10% only, only then, 
; the peak is taken into account.
;
; Modification 22-May-97 by Th. HANSEN:; fit.pro - sequential fit of multiple Gauss peaks (wrongly successively treated!)
; Modification 08-Sep-97 by Th. HANSEN:; several bugs fixed (array-indexing for a and x, etc.)
; Modification 04-Nov-97 by Th. HANSEN:; Voigt function and asymmetry correction ... ? Not really a success ...
; Modification 17-Nov-00 by Th. HANSEN:; new gaussfunc: gauss_square/poly.pro - new name: 'newfit' replaces 'fit'
; Modification 20-Nov-00 by Th. HANSEN:; everything changes ... (experiment M. Huber, E. Peters, B. Walk, T. Fehr, S. Zuern)
; Modification 05-Dec-00 by Th. HANSEN:; GUI replaces click, XREGISTERED, workspace numbers for output parameter keywords, y-axis ...
; Modification 06-Dec-00 by Th. HANSEN:; y values in file (W. Kuhs), OPLOTERR for error bars
; Modification 08-Dec-00 by Th. HANSEN:; call_procedure, noderivative - preparing Finger, Cox, Jephcoat: fcj.pro
; Modification 12-Dec-00 by Th. HANSEN:; use of an own lsfit.pro instead of IDL`s curvefit.pro for the least squares algorithm
; Modification 13-Dec-00 by Th. HANSEN:; Rectangle convolution and Bragg formula in gauss-poly.pro, tried to implement derivatives without success
; Modification 14-Dec-00 by Th. HANSEN:; Emerging peaks, keep them at zero as long as necessary ...
; Modification 15-Dec-00 by Th. HANSEN:; Emerging and disapearing peaks: performing limited peaksearches before each least-squares run, some documentation
; Modification 17-Dec-00 by Th. HANSEN:; Don`t consider emerging just beside existing peaks ... 
; Modification 19-Dec-00 by Th. HANSEN:; Tune recognition of emerging and of disappearing peaks: some tests are done AFTER least-squares to throw away badly refined peaks again
; Modification 23-Dec-00 by Th. HANSEN:; emerging and of disappearing peaks: debugging ...
; Modification 24-Dec-00 by Th. HANSEN:; Differential Peaksearch, first tries
; Modification 26-Dec-00 by Th. HANSEN:; Differential Peaksearch, as a new option ('search'), instead of taking last fit as initial guess
;
; to be done: 
;             constraints (UVW) on peak widths
;             crystallographical constraints on peak positions? (this would appproach a Rietveld style full profile fit)
;             zooming, and fixing xmin/max interactively
;             Gauss-Legendre integration over cellwidth
;             exponential 'wing'-effect of Pierre Convert
;             emergency exit if least squares block
;             handle new, emerging peaks - this is not so easy - same applies for disappearing peaks, of course:
;                 one 'solution' consists in looking at the peak`s contribution to the goodness of fit before each least-squares call
;                 the peak`s intensity is guessed at it`s position, if it is negative, or the peak does not improve chi2, 
;                 then set it to zero intensity and exclude it from fitting this round
;                 Up to now, emerging peaks must already exist somehow in the list of peaks, 
;                 an automatic peak-search for supplementary peaks could be a nice option
;                 Also could we try to avoid the polynominal background becoming negative
;                 An additional criterion on width could be applied to declare peaks 'broadened' out
;             GUI-widget: newfit should be called (but then as a procedure ?!) with a simple button click, so without any parameter or keyword
;                 This would mean the possibility of specifying an input-workspace, an output workspace, the x-range 
;                 and optional additional outputs in workspaces, using the widget.
;                 Consequently some parameters (xmin, xmax, peakpars, etc.) should kept changeable for longer than it is now
;
;-
;on_error,2              ;Return to caller if error - that`s for later (and in lsfit, fcj and gauss_poly as well!), as soon as theree is less need of debugging ...
;catch,error_status
error_status=0
COMMON fit,voigt,nterms,fitflag,key,undo,npeaks,rectangle,bragg,peakpars
COMMON clickwidget_cbk,clickwidget,title_field,numbers,nterms_label,up_button,down_button,bg_no,npeaks_label,peak_field,option_field,peak_no,up_peak,down_peak,$
    peak_ampli,peak_pos,peak_wid,peak_eta,voigt_field,voigt_button,buttons,next_button,undo_button,text_field,plot_zone
IF NOT KEYWORD_SET(maxwidth) THEN minwidth=0.2
IF NOT KEYWORD_SET(maxwidth) THEN maxwidth=5
IF NOT KEYWORD_SET(maxsearchwidth) THEN maxsearchwidth=0.15
IF KEYWORD_SET(bragg_shape) THEN bragg=1 ELSE bragg=0
IF KEYWORD_SET(rectangle_shape) THEN rectangle=1 ELSE rectangle=0
IF KEYWORD_SET(npks) THEN npeaks=npks ELSE npeaks=0
IF KEYWORD_SET(GUI) THEN click=1
; ################## are the output parameters numbers of workspaces ? ################################################
W_intensity=0
W_position=0
W_amplitude=0
W_width=0
W_eta=0
W_bg=0
W_H=0
W_S=0
W_L=0
W_HR=0
IF KEYWORD_SET(intensity) THEN IF N_ELEMENTS(intensity) EQ 1 THEN IF intensity GT 0 AND intensity LE 20 THEN W_intensity=intensity 
IF KEYWORD_SET(position) THEN IF N_ELEMENTS(position) EQ 1 THEN IF position GT 0 AND position LE 20 THEN W_position=position 
IF KEYWORD_SET(width) THEN IF N_ELEMENTS(width) EQ 1 THEN IF width GT 0 AND width LE 20 THEN W_width=width
IF KEYWORD_SET(eta) THEN IF N_ELEMENTS(eta) EQ 1 THEN IF eta GT 0 AND eta LE 20 THEN W_eta=eta 
IF KEYWORD_SET(amplitude) THEN IF N_ELEMENTS(amplitude) EQ 1 THEN IF amplitude GT 0 AND amplitude LE 20 THEN W_amplitude=amplitude
IF KEYWORD_SET(bg) THEN IF N_ELEMENTS(bg) EQ 1 THEN IF bg GT 0 AND bg LE 20 THEN W_bg=bg 
IF KEYWORD_SET(H) THEN IF N_ELEMENTS(H) EQ 1 THEN IF H GT 0 AND H LE 20 THEN W_H=H 
IF KEYWORD_SET(S) THEN IF N_ELEMENTS(S) EQ 1 THEN IF S GT 0 AND S LE 20 THEN W_S=S 
IF KEYWORD_SET(L) THEN IF N_ELEMENTS(L) EQ 1 THEN IF L GT 0 AND L LE 20 THEN W_L=L 
IF KEYWORD_SET(HR) THEN IF N_ELEMENTS(HR) EQ 1 THEN IF HR GT 0 AND HR LE 20 THEN W_HR=HR 
; ########################## Initialize a widget for output of what would have been printed into a terminal - maybe usefull for Windows-Runtime #########
IF KEYWORD_SET(widget) THEN BEGIN
  w0=WIDGET_BASE(title='NewFit.Pro Logging')
  w1=widget_text(w0)
  WIDGET_CONTROL,w0,/realize
  WIDGET_CONTROL,w1,SET_VALUE='Starting newfit'
ENDIF
; ################### Start sequential fitting from the first or the last diagram ##################################
IF NOT KEYWORD_SET(backwards) THEN BEGIN
  start=0 
  step=1
  last=N_ELEMENTS(ww(0,*))-1
ENDIF ELSE BEGIN
  last=0 
  step=-1
  start =N_ELEMENTS(ww(0,*))-1
ENDELSE
; ################### The variable a contains the parameters to be fitted, it must be defined #########################
IF N_PARAMS() LT 2 THEN a=0
; ################### The (general) damping factor to be applied to parameter shifts ##################################
IF NOT KEYWORD_SET(damping) THEN damping=0.5
; ################### Number of repeated calls to the least squares procedure CURVEFIT and damping of shifts ##########
IF NOT KEYWORD_SET(iterations) THEN iterations=5
; ################### just a flag - not really used, I think ##########################################################
fitflag=0
; ################### 
IF NOT KEYWORD_SET(ref) THEN ref=0
IF NOT KEYWORD_SET(noderivative) THEN noderivative=0
IF NOT KEYWORD_SET(func) THEN func="GAUSS_POLY" 
tmp_S=0.050
tmp_H=0.150
tmp_L=1.471
IF STRPOS(func,'fcj') GE 0 THEN BEGIN
    PRINT,'Finger Cox Jephcoat asymmetry'
    furtherterms=3
    IF KEYWORD_SET(H) THEN IF H(0) GT 0 THEN tmp_H=H
    IF KEYWORD_SET(S) THEN IF S(0) GT 0 THEN tmp_S=S
    IF KEYWORD_SET(L) THEN IF L(0) GT 0 THEN tmp_L=L
    a=[a,tmp_S,tmp_H,tmp_L]
ENDIF ELSE furtherterms=0
; ################## READING IN FROM AN INPUTFILE #######################
IF KEYWORD_SET(inputfile) THEN BEGIN
  OPENR,unit,inputfile,/GET_LUN
  npeaks=0
  voigt=0
  nbgterms=0
  furtherterms=0
  line=' '
  READF,unit,line
  line=line +' '+STRING(0)+' '+STRING(0)+' '+STRING(0)
  READS,line,npeaks,nbgterms,voigt,furtherterms
  IF voigt EQ 1 THEN BEGIN
    pvoigt=1
    peakpars=4
  ENDIF ELSE BEGIN
    peakpars=3 
    pVoigt=0
  ENDELSE
  IF rectangle EQ 1 THEN rectangle=rectangle+1
  a=FLTARR(npeaks*peakpars+nbgterms)
  ref=a 
  b=FLTARR(peakpars)
  FOR i=0,npeaks-1 DO BEGIN
    READF,unit,line
    line=line+' '+STRING(0.0)
    READS,line,b
    IF i EQ 0 THEN a=b ELSE a=[a,b]
    PRINT,b
    IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(b)
    READF,unit,line
    line=line+' '+STRING(0.0)
    READS,line,b
    IF i EQ 0 THEN ref=b ELSE ref=[ref,b]
  ENDFOR
  IF nbgterms GT 0 THEN BEGIN
    b=FLTARR(nbgterms)
    READF,unit,line
    line=line+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)
    READS,line,b
    PRINT,b
    IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(b)
    IF npeaks EQ 0 THEN a=b ELSE a=[a,b]
    READF,unit,line
    line=line+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)
    READS,line,b
    PRINT,b
    IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(b)
    IF npeaks EQ 0 THEN ref=b ELSE ref=[ref,b]
  ENDIF
  PRINT,furtherterms,' further terms from inputfile - If you want the Finger-Cox-Jephcoat function used for asymmetry, call newfit with func="fcj"'
  IF furtherterms GT 0 THEN BEGIN
    b=FLTARR(furtherterms)
    READF,unit,line
    line=line+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)
    READS,line,b  
    PRINT,b
    IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(b)  
    IF npeaks+nbgterms EQ 0 THEN a=b ELSE a=[a,b]
    READF,unit,line
    line=line+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)+' '+STRING(0.0)
    READS,line,b
    PRINT,b
    IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(b)
    IF npeaks+nbgterms EQ 0 THEN ref=b ELSE ref=[ref,b]
    FREE_LUN,unit
  ENDIF
ENDIF
;HELP,a
IF KEYWORD_SET(nbgterms) THEN nterms=nbgterms ELSE nterms=1
nbgterms=nterms
IF KEYWORD_SET(pvoigt) THEN BEGIN 
  peakpars=4
  voigt=1
ENDIF ELSE BEGIN
  peakpars=3
  voigt=0
ENDELSE
IF NOT KEYWORD_SET(eta) THEN eta=0.1 ELSE eta=eta(0)
sig2fwhm=2.*SQRT(2.*ALOG(2.))
IF (KEYWORD_SET(plot) OR KEYWORD_SET(click)) THEN BEGIN
  IF NOT (KEYWORD_SET(nowindow) OR KEYWORD_SET(click)) THEN BEGIN
    WINDOW,0,XSIZE=800,YSIZE=500
    IF NOT KEYWORD_SET(click) THEN WINDOW,1,XSIZE=800,YSIZE=200,YPOS=500
    WSET,0
  ENDIF 
  TVLCT,[0,255,0,0],[0,0,255,0],[0,0,0,255]
  PRINT,'Default Color',!P.COLOR
  !P.COLOR=0
ENDIF
IF NOT KEYWORD_SET(datpp) THEN take_datp,datp ELSE datp=datpp
IF N_PARAMS() LE 1 AND NOT KEYWORD_SET(inputfile) THEN a=0
a=REFORM(a(*,0),N_ELEMENTS(a(*,0)))
;HELP,a
IF NOT KEYWORD_SET(npeaks) AND NOT KEYWORD_SET(click) THEN BEGIN
  npeaks=(N_ELEMENTS(a)-1-nterms-furtherterms)/3
  PRINT,npeaks, ' peaks will be treated'
  IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(npeaks)+' peaks will be treated'
ENDIF
nterms=(nterms>1)<6                      ; minimum 1 term (constant bg), maximum 3 terms (square)
a=[a,FLTARR(npeaks*peakpars+nterms+furtherterms)]
;HELP,a
IF voigt EQ 0 THEN a=a(0:npeaks*peakpars+nterms+furtherterms-1) ELSE a=a(0:npeaks*peakpars+nterms+furtherterms-1)                  ; shape the parameter vector a
IF NOT KEYWORD_SET(xx) THEN xx=datp.x 
IF NOT KEYWORD_SET(ee) THEN ee=datp.e 
IF NOT KEYWORD_SET(yy) THEN IF N_ELEMENTS(datp.y) EQ N_ELEMENTS(ww(0,*)) THEN yy=datp.y ELSE yy=INDGEN(N_ELEMENTS(ww(0,*)))
IF N_ELEMENTS(yy) NE N_ELEMENTS(ww(0,*)) THEN yy=INDGEN(N_ELEMENTS(ww(0,*)))
IF N_ELEMENTS(xx(0,*)) GT 1 THEN BEGIN
  PRINT,'X is 2D - I will use the X for the first diagram for all diagrams - this is maybe not correct!!'
  IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='X is 2D - I will use the X for the first diagram for all diagrams - this is maybe not correct!!'
ENDIF
IF NOT KEYWORD_SET(maxexclusion) THEN maxexclusion=1.0
IF NOT KEYWORD_SET(overlap) THEN overlap=3.
IF NOT KEYWORD_SET(xmin) THEN xmin=MIN(xx)
IF NOT KEYWORD_SET(xmax) THEN xmax=MAX(xx)
index=WHERE(xx(*,0) GE xmin AND xx(*,0) LE xmax AND ww(*,start) GT 0,count)
IF count LE 0 THEN BEGIN
  PRINT,'There is a problem with the x-range for the peak searching loop'
  IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='There is a problem with the x-range for the peak searching loop'
  RETURN,0
ENDIF
w=ww(index,*)
e=ee(index,*)
y=yy
x=REFORM(xx(index,0),count)
; ##################### Graphical, interactive peak search ###################################
IF KEYWORD_SET(click) THEN BEGIN
  undo=0
  plot=1 ; That is just logic - if I am working interactively, I should show what is happening all the time
  peak_number=0
  IF NOT XREGISTERED('NewFit') THEN BEGIN
    clickwidget =WIDGET_BASE(title='NewFit',/COL,XSIZE=1000)
    title_field =WIDGET_TEXT(clickwidget,VALUE='Choose background points with mouse clicks! Bugs to hansen@ill.fr!')
    numbers     =WIDGET_BASE(clickwidget,/ROW)
    nterms_label=WIDGET_LABEL(numbers,VALUE=STRCOMPRESS(nterms,/RE)+' polynom terms')
    up_button   =WIDGET_BUTTON(numbers,VALUE='^')
    down_button =WIDGET_BUTTON(numbers,VALUE='v')
    bg_no       =WIDGET_LABEL(numbers,VALUE=STRCOMPRESS(0,/RE)+' bg. pnts.')
    npeaks_label=WIDGET_LABEL(numbers,VALUE=STRCOMPRESS(nterms,/RE)+' peaks')
    fcj_field =WIDGET_BASE(numbers,/NONEXCLUSIVE)
    fcj_button=WIDGET_BUTTON(fcj_field,VALUE='F.C.J.-Asym.')
    fcj_S  =WIDGET_TEXT(numbers,VALUE=STRCOMPRESS(tmp_S,/RE),/EDITABLE)
    fcj_H  =WIDGET_TEXT(numbers,VALUE=STRCOMPRESS(tmp_H,/RE),/EDITABLE)
    fcj_L  =WIDGET_TEXT(numbers,VALUE=STRCOMPRESS(tmp_L,/RE),/EDITABLE)
    bragg_field  =WIDGET_BASE(numbers,/NONEXCLUSIVE)
    bragg_button  =WIDGET_BUTTON(bragg_field,VALUE='Bragg')
    IF STRPOS(func,'fcj') GE 0 THEN WIDGET_CONTROL,FCJ_button,/SET_BUTTON
    IF bragg THEN WIDGET_CONTROL,Bragg_button,/SET_BUTTON
    peak_field = WIDGET_BASE(clickwidget,/ROW)
    peak_no     =WIDGET_LABEL(peak_field,VALUE='Pk. no.'+STRCOMPRESS(peak_number,/RE)+':')
    up_peak     =WIDGET_BUTTON(peak_field,VALUE='^')
    down_peak   =WIDGET_BUTTON(peak_field,VALUE='v')
    peak_ampli  =WIDGET_TEXT(peak_field,XSIZE=10,VALUE='0.0',/EDITABLE)
    peak_pos    =WIDGET_TEXT(peak_field,XSIZE=10,VALUE='0.0',/EDITABLE)
    peak_wid    =WIDGET_TEXT(peak_field,XSIZE=10,VALUE='0.0',/EDITABLE)
    peak_eta    =WIDGET_TEXT(peak_field,XSIZE=10,VALUE='0.0',/EDITABLE)
    peak_HR     =WIDGET_TEXT(peak_field,XSIZE=10,VALUE='0.0',/EDITABLE)
    ;option_field = WIDGET_BASE(clickwidget,/ROW)
    voigt_field =WIDGET_BASE(peak_field,/NONEXCLUSIVE)
    voigt_button=WIDGET_BUTTON(voigt_field,VALUE='ps.-Voigt')
    IF voigt THEN WIDGET_CONTROL,voigt_BUTTON,/SET_BUTTON
    rect_field =WIDGET_BASE(peak_field,/NONEXCLUSIVE)
    rect_button=WIDGET_BUTTON(rect_field,VALUE='rect.convol.')
    IF rectangle THEN WIDGET_CONTROL,rect_BUTTON,/SET_BUTTON
    buttons     =WIDGET_BASE(clickwidget,/ROW)
    next_button =WIDGET_BUTTON(buttons,VALUE='Stop background determination - go to peak search!')
    undo_button =WIDGET_BUTTON(buttons,VALUE='Undo last point of background!')
    text_field  =WIDGET_TEXT(buttons)
    plot_zone   =WIDGET_DRAW(clickwidget,/BUTTON_EVENTS,XSIZE=1000,YSIZE=600)
    WIDGET_CONTROL,clickwidget,/REALIZE
    XMANAGER,'NewFit',clickwidget,Event_Handler='LAMP_EVENT_PARSER',/just_reg
  ENDIF ELSE BEGIN
    WIDGET_CONTROL,title_field,SET_VALUE='Choose background points with mouse clicks! Bugs to hansen@ill.fr!'
    WIDGET_CONTROL,nterms_label,SET_VALUE=STRCOMPRESS(nterms,/RE)+' polynom terms'
    WIDGET_CONTROL,up_button,SET_VALUE='^'
    WIDGET_CONTROL,down_button,SET_VALUE='v'
    WIDGET_CONTROL,bg_no,SET_VALUE=STRCOMPRESS(0,/RE)+' bg. pnts.'
    WIDGET_CONTROL,npeaks_label,SET_VALUE=STRCOMPRESS(nterms,/RE)+' peaks'
    WIDGET_CONTROL,peak_no,SET_VALUE='Pk. no.'+STRCOMPRESS(peak_number,/RE)+':'
    WIDGET_CONTROL,up_peak,SET_VALUE='^'
    WIDGET_CONTROL,down_peak,SET_VALUE='v'
    WIDGET_CONTROL,peak_ampli,SET_VALUE='0.0'
    WIDGET_CONTROL,peak_pos,SET_VALUE='0.0'
    WIDGET_CONTROL,peak_wid,SET_VALUE='0.0'
    WIDGET_CONTROL,peak_eta,SET_VALUE='0.0'
    WIDGET_CONTROL,voigt_button,SET_VALUE='ps.-Voigt'
    IF voigt THEN WIDGET_CONTROL,voigt_BUTTON,/SET_BUTTON
    IF rectangle THEN WIDGET_CONTROL,rect_BUTTON,/SET_BUTTON
    IF STRPOS(func,'fcj') GE 0 THEN WIDGET_CONTROL,fcj_BUTTON,/SET_BUTTON
    WIDGET_CONTROL,next_button,SET_VALUE='Stop background determination - go to peak search!'
    WIDGET_CONTROL,undo_button,SET_VALUE='Undo last point of background!'
  ENDELSE
  WIDGET_CONTROL,plot_zone, GET_VALUE = win_num
  WSET,win_num
  npeaks=0
  bgterms=0
  j=0
  x1=xmin
  x2=xmax
  y1=0
  y2=MAX(w)
  x0=x1
  y0=y1
  PLOT,x,w(*,start),TITLE='Click on background positions!',YRANGE=[0,MAX(w)],background=255,xstyle=1,ystyle=1,color=0
  PRINT,nterms,' background terms'
  OPLOTERR,x,w(*,start),e(*,start),0
  REPEAT BEGIN 
    widget_result=WIDGET_EVENT([up_button,down_button,undo_button,next_button,plot_zone,voigt_button,rect_button,fcj_button,bragg_button])
    IF widget_result.ID EQ bragg_button THEN BEGIN
      IF bragg THEN bragg=0 ELSE bragg=1
      PRINT,'Bragg Convolution:',bragg
    ENDIF
    IF widget_result.ID EQ voigt_button THEN BEGIN
      IF voigt THEN voigt=0 ELSE voigt=1
      PRINT,'pseudo Voigt:',voigt
    ENDIF
    IF widget_result.ID EQ rect_button THEN BEGIN
      IF rectangle THEN rectangle=0 ELSE rectangle=1
      PRINT,'Rectangle Convolution:',rectangle
    ENDIF
    IF widget_result.ID EQ fcj_button THEN BEGIN
      IF STRPOS(func,'fcj') GE 0 THEN func='GAUSS_POLY' ELSE func='fcj'
      PRINT,'Function used: ',func
    ENDIF
    IF widget_result.ID EQ up_button THEN BEGIN
      nterms=nterms+1
      bgterms=N_ELEMENTS(bg_w)<nterms
      WIDGET_CONTROL,nterms_label,SET_VALUE=STRCOMPRESS(nterms,/RE)+' polynom terms'
    ENDIF
    IF widget_result.ID EQ down_button THEN BEGIN
      nterms=nterms-1
      bgterms=N_ELEMENTS(bg_w)<nterms
      WIDGET_CONTROL,nterms_label,SET_VALUE=STRCOMPRESS(nterms,/RE)+' polynom terms'
    ENDIF
    IF widget_result.ID EQ plot_zone THEN BEGIN
      PRINT,'Event in plot zone'
      IF widget_result.PRESS THEN BEGIN
        PRINT,'Press in plot zone'
        resultxy=convert_coord(widget_result.X,widget_result.Y,/device,/to_data)
        x0=resultxy(0)
        y0=resultxy(1)
        WIDGET_CONTROL,text_field,SET_VALUE=STRCOMPRESS(x0,/RE)+STRCOMPRESS(y0)
        PRINT,x0,y0
        IF x0 GE x1 AND x0 LE x2 AND y0 GE y1 AND y0 LE y2 THEN BEGIN 
          pos=MIN(ABS(x0-x),i)
          PRINT,STRING(pos)+STRING(x0)+STRING(i)+STRING(min(x))+STRING(max(x))
          IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(pos)+STRING(x0)+STRING(i)+STRING(min(x))+STRING(max(x))
          bgterms=(bgterms+1)<nterms
          PLOT,x,w(*,start),TITLE='Click on background positions!',YRANGE=[0,MAX(w)],background=255,color=0,xstyle=1,ystyle=1
          OPLOTERR,x,w(*,start),e(*,start),0
          PLOTS,[x0,x0],[MIN(w(*,start)),w(i,start)],COLOR=2
          xyouts,x0,w(i),STRCOMPRESS((x0))+STRCOMPRESS(ROUND(w(i))),COLOR=1,CHARSIZE=.8 
          PRINT,'Background',j,' at',x0,' degrees,',w(i,start),' counts'
          IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Background'+STRING(j)+' at'+STRING(x0)+' degrees,'+STRING(w(i,start))+' counts'
          IF j EQ 0 THEN BEGIN
            bg_x=x0
            bg_w=w(i,start)
            a=w(i,start)
            background=x*0.0+w(i,start)
          ENDIF ELSE BEGIN
            bg_x=[bg_x,x0]
            bg_w=[bg_w,w(i,start)]
            IF bgterms GT 1 THEN a=POLY_FIT(bg_x,bg_w,bgterms-1) ELSE a=[TOTAL(bg_w)/N_ELEMENTS(bg_w)]
            a=REFORM(a,N_ELEMENTS(a))
            PRINT,'Polynom: '+STRING(a)
            IF bgterms GT 1 THEN background=POLY(x,a) ELSE background=bg_x*0.0+a(0)
          ENDELSE
          OPLOT,x,background,COLOR=3,LINE=0
          j=j+1
        ENDIF ELSE PRINT,x1,y1,x2,y2
      ENDIF
      xyouts,MIN(x),MIN(w),'x',COLOR=1,CHARSIZE=1 
    ENDIF
    IF widget_result.ID EQ undo_button THEN BEGIN
      undo=0
      PLOT,x,w(*,start),TITLE='Click on background positions!',YRANGE=[0,MAX(w)],background=255,color=0,xstyle=1,ystyle=1
      OPLOTERR,x,w(*,start),e(*,start),0
      bgterms=(bgterms-1)>0
      IF j EQ 1 THEN BEGIN
        j=0
        a=MIN(w(*,start))
        background=x*0.0+MIN(w(*,start))
      ENDIF ELSE BEGIN
        j=j-1
        bg_x=bg_x(0:N_ELEMENTS(bg_x)-2)
        bg_w=bg_w(0:N_ELEMENTS(bg_w)-2)
        IF bgterms GT 1 THEN BEGIN
          a=POLY_FIT(bg_x,bg_w,bgterms-1) 
          a=REFORM(a,N_ELEMENTS(a))
          background=POLY(x,a)
        ENDIF ELSE BEGIN
          a=bg_w(0)
          background=x*0.0+a
        ENDELSE
      ENDELSE
      OPLOT,x,background,COLOR=3,LINE=0
    ENDIF
    WIDGET_CONTROL,bg_no,SET_VALUE=STRCOMPRESS(N_ELEMENTS(bg_x),/RE)+' bg. poinpnts.ts'
  ENDREP UNTIL widget_result.ID EQ next_button
  PRINT,'Finished background ...',nterms,' terms'
  WIDGET_CONTROL,up_button,SET_VALUE='';/DESTROY
  WIDGET_CONTROL,down_button,SET_VALUE='';/DESTROY
  IF bgterms EQ 0 THEN a=MIN(w(*,start))
  j=0
  IF N_ELEMENTS(a) EQ 1 THEN background=x*0.0+a(0) ELSE background=POLY(x,a)
  ; ******************* Now searching Peaks interactively ... ***************************************************
  PLOT,x,w(*,start),TITLE='Click on peaks maximums!',YRANGE=[0,MAX(w)],background=255,color=0,xstyle=1,ystyle=1
  OPLOTERR,x,w(*,start),e(*,start),0
  OPLOT,x,background,COLOR=3,LINE=1
  IF STRPOS(func,'fcj') GE 0 THEN BEGIN
    PRINT,'Finger Cox Jephcoat asymmetry'
    furtherterms=3
    IF KEYWORD_SET(H) THEN IF H(0) GT 0 THEN tmp_H=H
    IF KEYWORD_SET(S) THEN IF S(0) GT 0 THEN tmp_S=S
    IF KEYWORD_SET(L) THEN IF L(0) GT 0 THEN tmp_L=L
    a=[a,tmp_S,tmp_H,tmp_L]
  ENDIF ELSE BEGIN
    furtherterms=0
  ENDELSE
  a=[a,FLTARR(nterms+furtherterms)]
  a=a(0:nterms+furtherterms-1)
  WIDGET_CONTROL,title_field,SET_VALUE='Choose peaks by clicking on peak maximum and releasing in the slope!'
  WIDGET_CONTROL,next_button,SET_VALUE='Stop peak search and go on to fit of initial guess!'
  PRINT,'pseudo-Voigt Button Value: ',voigt
  IF voigt THEN peakpars=4 ELSE BEGIN
    peakpars=3
    WIDGET_CONTROL,peak_eta,SET_VALUE='';,/DESTROY
  ENDELSE
  IF rectangle EQ 1 THEN peakpars=peakpars+1
  print,peakpars,' parameters per peak'
  print,a
  REPEAT BEGIN 
    IF voigt THEN widget_result=WIDGET_EVENT([undo_button,next_button,plot_zone,up_peak,down_peak,peak_ampli,peak_pos,peak_wid,peak_eta,peak_HR,fcj_S,fcj_H,fcj_L,bragg_button]) ELSE BEGIN
      widget_result=WIDGET_EVENT([undo_button,next_button,plot_zone,up_peak,down_peak,peak_ampli,peak_pos,peak_wid,peak_HR,fcj_S,fcj_H,fcj_L,bragg_button]) 
    ENDELSE
    IF widget_result.ID EQ bragg_button THEN BEGIN
      IF bragg THEN bragg=0 ELSE bragg=1
      PRINT,'Bragg Convolution:',bragg
    ENDIF
    IF widget_result.ID EQ up_peak THEN BEGIN
      peak_number=(peak_number+1)<(npeaks-1)
    ENDIF
    IF widget_result.ID EQ down_peak THEN BEGIN
      peak_number=(peak_number-1)>0
    ENDIF
    IF widget_result.ID EQ plot_zone THEN IF widget_result.PRESS THEN BEGIN
      resultxy=convert_coord(widget_result.X,widget_result.Y,/device,/to_data)
      PRINT,resultxy
      x0=resultxy(0)
      y0=resultxy(1)
      PRINT,x0,y0
      WIDGET_CONTROL,text_field,SET_VALUE=STRCOMPRESS(x0,/RE)+STRCOMPRESS(y0)
      IF x0 GE x1 AND x0 LE x2 AND y0 GE y1 AND y0 LE y2 THEN BEGIN 
        pos=MIN(ABS(x0-x),i)
        CALL_PROCEDURE,func,x,a,g
        npeaks=npeaks+1
        IF rectangle THEN BEGIN
          IF voigt EQ 0 THEN a=[w(i,start)-g(i),x0,0.,0.,a] ELSE a=[w(i,start)-g(i),x0,0.,eta,0.,a] 
        ENDIF ELSE IF voigt EQ 0 THEN a=[w(i,start)-g(i),x0,0.,a] ELSE a=[w(i,start)-g(i),x0,0.,eta,a] 
        PLOTS,[x0,x0],[MIN(w(*,start)),w(i,start)],COLOR=2
        xyouts,x0,w(i,start),STRCOMPRESS((x0))+STRCOMPRESS(ROUND(w(i,start))),COLOR=1,CHARSIZE=.8 
        REPEAT widget_result=WIDGET_EVENT([plot_zone]) UNTIL widget_result.RELEASE
        IF widget_result.RELEASE THEN BEGIN
          resultxy=convert_coord(widget_result.X,widget_result.Y,/device,/to_data)
          PRINT,resultxy
          x0=resultxy(0)
          y0=resultxy(1)
        ENDIF
        pos=MIN(ABS(x0-x),i)
        a(2)=ABS((x0-a(1))/SQRT(-2*ALOG((w(i,start)-g(i))/a(0))))
        WHILE -2*ALOG((w(i,start)-g(i))/a(0)) LE 0 OR x0 EQ a(1)  DO BEGIN
          PRINT,'Try again to click on another point of peak!',-2*ALOG((w(i)-g(i))/a(0))
          xyouts,MIN(x),(MAX(w)-MIN(w))/2.,'Click again on another point of the peak!',COLOR=1,CHARSIZE=.8 
          IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Try again to click on another point of peak!'+STRING(-2*ALOG((w(i)-g(i))/a(0)))
          REPEAT widget_result=WIDGET_EVENT([plot_zone]) UNTIL widget_result.PRESS
          IF widget_result.PRESS THEN BEGIN
            resultxy=convert_coord(widget_result.X,widget_result.Y,/device,/to_data)
            PRINT,resultxy
            x0=resultxy(0)
            y0=resultxy(1)
          ENDIF
          pos=MIN(ABS(x0-x),i)
          a(2)=ABS((x0-a(1))/SQRT(-2*ALOG((w(i,start)-g(i))/a(0))))
        ENDWHILE
        PRINT,'Peak',j,' at',a(1),' degrees, amplitude',a(0),' counts, FWHM',a(2)*sig2fwhm,' degrees'
        IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Peak'+STRING(j)+' at'+STRING(a(1))+' degrees, amplitude'+STRING(a(0))+' counts, FWHM'+STRING(a(2)*sig2fwhm)+' degrees'
        j=j+1
      ENDIF ELSE CURSOR,x0,y0,/UP 
      xyouts,MIN(x),0,'X',COLOR=1,CHARSIZE=1
      IF rectangle THEN a(peakpars-1)=a(2)/10.
    ENDIF 
    IF widget_result.ID eq undo_button THEN BEGIN
      npeaks=npeaks-1
      a=a(peakpars:N_ELEMENTS(a)-1)
    ENDIF
    IF widget_result.ID EQ peak_ampli THEN BEGIN
      WIDGET_CONTROL,peak_ampli,GET_VALUE=valstr
      a(peak_number*peakpars)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ peak_pos THEN BEGIN
      WIDGET_CONTROL,peak_pos,GET_VALUE=valstr
      a(peak_number*peakpars+1)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ peak_wid THEN BEGIN
      WIDGET_CONTROL,peak_wid,GET_VALUE=valstr
      a(peak_number*peakpars+2)=FLOAT(valstr(0))
    ENDIF
    IF voigt THEN IF widget_result.ID EQ peak_eta THEN BEGIN
      WIDGET_CONTROL,peak_eta,GET_VALUE=valstr
      a(peak_number*peakpars+3)=FLOAT(valstr(0))
    ENDIF
    IF rectangle THEN IF widget_result.ID EQ peak_HR THEN BEGIN
      WIDGET_CONTROL,peak_HR,GET_VALUE=valstr
      a(peak_number*peakpars+3+voigt)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ fcj_S THEN BEGIN
      WIDGET_CONTROL,fcj_S,GET_VALUE=valstr
      a(nterms+npeaks*peakpars)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ fcj_H THEN BEGIN
      WIDGET_CONTROL,fcj_H,GET_VALUE=valstr
      a(nterms+npeaks*peakpars+1)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ fcj_L THEN BEGIN
      WIDGET_CONTROL,fcj_L,GET_VALUE=valstr
      a(nterms+npeaks*peakpars+2)=FLOAT(valstr(0))
    ENDIF
    PLOT,x,w(*,start),TITLE='Click on peaks maximums, release in its slope!',YRANGE=[0,MAX(w)],background=255,color=0,xstyle=1,ystyle=1
    OPLOTERR,x,w(*,start),e(*,start),0
    CALL_PROCEDURE,func,x,a,g 
    OPLOT,x,g,COLOR=2,LINE=0
    OPLOT,x,w(*,start)-g+MIN(w)/2.,color=3
    OPLOT,x,g*0.0+MIN(w)/2.,color=0
    IF N_ELEMENTS(e) EQ N_ELEMENTS(w) THEN BEGIN
          OPLOT,x,w(*,start)-g+e(*,start)+MIN(w)/2.,color=2,LINE=0
          OPLOT,x,w(*,start)-g-e(*,start)+MIN(w)/2.,color=2,LINE=0
    ENDIF
    tmp=npeaks
    npeaks=1
    FOR j=0,npeaks-1 DO BEGIN
        b=[a((j*peakpars)+INDGEN(peakpars)),a(npeaks*peakpars+INDGEN(nterms+furtherterms))]
        CALL_PROCEDURE,func,x,b,g
        OPLOT,x,g,COLOR=j+3,LINE=1
    ENDFOR
    npeaks=tmp
    IF npeaks THEN BEGIN
      WIDGET_CONTROL,peak_no,SET_VALUE='Pk. no.'+STRCOMPRESS(peak_number,/RE)+':'
      WIDGET_CONTROL,npeaks_label,SET_VALUE=STRCOMPRESS(npeaks,/RE)+' peaks'
      WIDGET_CONTROL,peak_ampli,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars),/RE)
      WIDGET_CONTROL,peak_pos,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+1),/RE)
      WIDGET_CONTROL,peak_wid,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+2),/RE)
      IF voigt THEN WIDGET_CONTROL,peak_eta,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+3),/RE)
      IF rectangle THEN WIDGET_CONTROL,peak_HR,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+voigt+3),/RE)
      IF furtherterms GE 3 THEN BEGIN
        WIDGET_CONTROL,fcj_S,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars),/RE)
        WIDGET_CONTROL,fcj_H,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars+1),/RE)
        WIDGET_CONTROL,fcj_L,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars+2),/RE)
      ENDIF
    ENDIF
  ENDREP UNTIL widget_result.ID EQ next_button
  WIDGET_CONTROL,title_field,SET_VALUE='Click on Stop button when the fit of the inital guess becomes satisfying!'
  WIDGET_CONTROL,next_button,SET_VALUE='Stop fit of initial guess and start sequential fitting!'
ENDIF
f = 0.0*w  ; resulting (fitted) values
IF NOT KEYWORD_SET(UVW) THEN UVW=0
; ############### Automatic Peak search - and supplementary search for incomplete input (except inputfile given) ########################################
IF a(npeaks*peakpars) EQ 0 THEN a(npeaks*peakpars)=MIN(w(*,start)) ; Set at least constant background to minimum counting rate
PRINT,'Constant background term: ',a(npeaks*peakpars),',',nterms,' background terms'
IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Constant background term: '+STRING(a(npeaks*peakpars))+','+STRING(nterms)+' background terms'
IF NOT KEYWORD_SET(inputfile) THEN FOR j=0,npeaks-1 DO BEGIN
  call_procedure,func,x,a,g 
  pos=a(j*peakpars+1)
  IF voigt EQ 1 THEN IF a(j*peakpars+3) LE 0 THEN a(j*peakpars+3)=eta  ; no eta given for this peak
  IF a(j*peakpars+0) LE 0 THEN BEGIN    ; no peak amplitude given for this peak
    IF a(j*peakpars+1) EQ 0 THEN BEGIN  ; no peak position given neither
      a(j*peakpars+0) = MAX(w(*,start)-g,i)
      a(j*peakpars+1) = x(i)
      pos=a(j*peakpars+1)
    ENDIF ELSE BEGIN             ; peak position already given ...
      pos=MIN(ABS(x-a(j*peakpars+1)),i)
      a(j*peakpars+0)=(w(i,start)-g(i))>0 ; only positive peaks taken into account
    ENDELSE
  ENDIF
  IF a(j*peakpars+2) LE 0 THEN BEGIN    ; no peak width given for this peak
    PRINT,'Peakwidth to be determinated for peak no.',j
    IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Peakwidth to be determinated for peak no.'+STRING(j)
    IF N_ELEMENTS(UVW) LT 3 THEN BEGIN
      i=WHERE(x GT pos AND w(*,start)-g LE a(j*peakpars+0)/2.0,count)
      IF count EQ 0 THEN pos2=MAX(x) ELSE pos2=x(i(0))
      i=WHERE(x LT pos AND w(*,start)-g LE a(j*peakpars+0)/2.0,count)
      IF count EQ 0 THEN pos1=MIN(x) ELSE pos1=x(i(count-1))
      a(j*peakpars+2)=(pos2-pos1)/sig2fwhm
    ENDIF ELSE a(j*peakpars+2)=FWHM(UVW,a(j*peakpars+1))
    IF rectangle THEN IF a((j+1)*peakpars-1) LE 0 THEN a((j+1)*peakpars-1)=a(j*peakpars+2)/10.
  ENDIF
  PRINT,'Peak', j,' (ampl., pos., sig.=FWHM/(2sqrt(2ln2)):',a(j*peakpars+INDGEN(peakpars))
  IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Peak'+STRING(j)+' (ampl., pos., sig.=FWHM/(2sqrt(2ln2)):'+STRING(a(j*peakpars+[0,1,2]))
ENDFOR  
PRINT,STRCOMPRESS(npeaks),' peaks, Voigt:',STRCOMPRESS(voigt),',',STRCOMPRESS(peakpars),' parameters/peak,',STRCOMPRESS(nterms),' background polynom terms,',STRCOMPRESS(furtherterms),' further terms (Finger-Cox-Jephcoat)'
PRINT,a(npeaks*peakpars+INDGEN(nterms+furtherterms))
IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(a(npeaks*peakpars+INDGEN(nterms+furtherterms)))
n=N_ELEMENTS(w(0,*))
m=N_ELEMENTS(w(*,start))
H=FLTARR(n)
S=H
L=H
sig_H=H
sig_S=H
sig_L=H
amplitude=FLTARR(n,npeaks)
intensity=amplitude
width=amplitude
HR=amplitude
eta=amplitude
position=amplitude
bg=FLTARR(n,nterms)
sig_amplitude=amplitude
sig_intensity=amplitude
sig_width=amplitude
sig_position=amplitude
sig_eta=amplitude
sig_HR=amplitude
sig_bg=bg
IF KEYWORD_SET(printing) THEN PRINT,'Step Pk Intensity   Peak-Heigth    Position 2sqrt(2ln2)*Sigma (Eta)  (HR)  Residu.' 
IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Step Pk Peak-Heigth    Position 2sqrt(2ln2)*Sigma Residu.' 
sigmaa=a*0.0
IF KEYWORD_SET(file) THEN OPENW,output,file,/get_lun
IF KEYWORD_SET(plot) THEN BEGIN
  PLOT,x,w(*,start),TITLE='Guess for first diagram',YRANGE=[0,MAX(w)],background=255,color=0
  OPLOTERR,x,w(*,start),e(*,start),0
ENDIF
IF N_ELEMENTS(ref) NE N_ELEMENTS(a) THEN ref=a*0.0+damping
nbgterms=nterms
; ################# Writing out the inital guess ###########################
IF KEYWORD_SET(outputfile) THEN BEGIN
  OPENW,unit,outputfile,/GET_LUN
  PRINTF,unit,npeaks,nbgterms,voigt,furtherterms
  FOR i=0,npeaks-1 DO BEGIN
    PRINTF,unit,a(i*peakpars+INDGEN(peakpars))
    PRINTF,unit,ref(i*peakpars+INDGEN(peakpars))
  ENDFOR
  IF nterms GT 0 THEN BEGIN
    PRINTF,unit,  a(i*peakpars+INDGEN(nterms))
    PRINTF,unit,ref(i*peakpars+INDGEN(nterms))
  ENDIF
  IF furtherterms GT 0 THEN BEGIN
    PRINTF,unit,  a(i*peakpars+nterms+INDGEN(furtherterms))
    PRINTF,unit,ref(i*peakpars+nterms+INDGEN(furtherterms))
  ENDIF
  FREE_LUN,unit
ENDIF
guess=a
IF KEYWORD_SET(plot) THEN BEGIN
	call_procedure,func,x,a,g
        OPLOT,x,g,COLOR=1
ENDIF
; ############### NOW THE GUESSING IS FINISHED, FITTING CAN START! ###############################
IF KEYWORD_SET(click) THEN initial_fit_finished=0 ELSE initial_fit_finished=1
IF NOT KEYWORD_SET(initialiterations) THEN initialiterations=40
loops=initialiterations 
fitflag=1
refbak=ref
IF KEYWORD_SET(nowait) THEN nowait=0 ELSE nowait=1
PRINT,peakpars,' parameters per peak'
FOR i=LONG(start),LONG(last),LONG(step) DO BEGIN
  weight=REPLICATE(1.,m)
  IF N_ELEMENTS(e) EQ N_ELEMENTS(w) THEN weight=e(*,i)
  ITER=0
  CHI2=0
  ref=refbak
  ; ****** some peaksearching ... try out some future new peak appearance/disappearing management ******
  ;smoothed=SMOOTH(w(*,i),3)
  smoothed=w(*,i) ; finally ... not smoothed at all ...
  index=INDGEN(N_ELEMENTS(smoothed))
  denominator=x((index+1)<(N_ELEMENTS(smoothed)-1))-x((index-1)>0)
  stepx=TOTAL(denominator(index(1:N_ELEMENTS(smoothed)-2)))/(N_ELEMENTS(smoothed)-2)
  denominator=denominator/stepx
  differentiated=(smoothed((index+1)<(N_ELEMENTS(smoothed)-1))-smoothed((index-1)>0))/denominator
  differentiated(0)=0
  differentiated(N_ELEMENTS(smoothed)-1)=0
  error=(e((index+1)<(N_ELEMENTS(smoothed)-1),i)+e((index-1)>0,i))/denominator
  twoprime=differentiated((index+1)<(N_ELEMENTS(smoothed)-1))-differentiated((index-1)>0)/denominator
  twoprime(0)=0
  twoprime(N_ELEMENTS(smoothed)-1)=0
  newx=FINDGEN(N_ELEMENTS(x)*10)*(MAX(x)-MIN(x))/N_ELEMENTS(x)/10.+MIN(x)
  ;foundpeaks=WHERE(differentiated LE error*3. AND differentiated((index-1)>0) GT error*3.,numberofoundpeaks)
  ;IF numberofoundpeaks GE 1 THEN PRINT,x(foundpeaks)
  twoprime      =INTERPOL(twoprime      ,x,newx)
  differentiated=INTERPOL(differentiated,x,newx)
  smoothed      =INTERPOL(smoothed      ,x,newx)
  error         =INTERPOL(error         ,x,newx)
  foundpeaks=WHERE(differentiated LE 0 AND differentiated((INDGEN(N_ELEMENTS(newx))-1)>0) GT 0 AND differentiated((INDGEN(N_ELEMENTS(newx))-1)>0)-differentiated GT error+error((INDGEN(N_ELEMENTS(newx))-1)>0),numberofoundpeaks)
  ;steep=(differentiated((foundpeaks-1)>0)-differentiated(foundpeaks))/error(foundpeaks)
  ;foundpeaks=foundpeaks(REVERSE(SORT(steep)))
  IF NOT KEYWORD_SET(click) AND KEYWORD_SET(plot) AND NOT KEYWORD_SET(now) THEN BEGIN
      WSET,1
      PLOT,newx,smoothed,YR=[MIN([smoothed,differentiated,twoprime]),MAX([smoothed,differentiated,twoprime])],BACK=255
      OPLOTERR,newx,smoothed,error,0
      OPLOT,newx,differentiated,COLOR=1
      ;OPLOTERR,x,differentiated,error,0
      OPLOT,newx,twoprime,COLOR=2
      WSET,0
  ENDIF
  peaks2fit=0
  FOR foundpeak=0,numberofoundpeaks-1 DO BEGIN
    ;part=differentiated(foundpeaks(foundpeak))/(differentiated(foundpeaks(foundpeak))-differentiated(foundpeaks(foundpeak)-1))
    ;maxx=
    idx=INDGEN(foundpeaks(foundpeak))
    left=MAX(WHERE(twoprime(idx) GE 0))
    leftpart=twoprime(left)/(twoprime(left)-twoprime(left+1))
    ;left=left-1
    leftx=leftpart*    newx(left)+(1-leftpart)*    newx(left+1)
    leftw=leftpart*smoothed(left)+(1-leftpart)*smoothed(left+1);-MIN(w(*,i))
    idx=INDGEN(N_ELEMENTS(smoothed)-foundpeaks(foundpeak))+foundpeaks(foundpeak)
    right=MIN(WHERE(twoprime(idx) GE 0))+foundpeaks(foundpeak)
    rightpart=twoprime(right)/(twoprime(right)-twoprime(right-1))
    ;right=right-1
    rightx=rightpart*    newx(right)+(1-rightpart)*    newx(right-1)
    rightw=rightpart*smoothed(right)+(1-rightpart)*smoothed(right+1);-MIN(w(*,i))
    IF KEYWORD_SET(search) THEN BEGIN
      peakwidth=(rightx-leftx)*sig2fwhm/2.
      ;PRINT,peakwidth
      IF peakwidth GE minwidth THEN BEGIN
        ;peakamplitude= MAX(smoothed(left:right),maxidx)-(POLY(newx(left+maxidx),a(npeaks*peakpars+INDGEN(nterms)))>MIN(w(*,i)))
        peakamplitude=(MAX(smoothed(left:right),maxidx)-(leftw+rightw)/2.0)/(1.0-EXP(-0.5))
        PRINT,'**',peaks2fit,peakamplitude,newx(left+maxidx),rightx-leftx
        ;PRINT,'* ',(MAX(smoothed(left:right))-(leftw+rightw)/2.0)/(1.0-EXP(-0.5))
        ;PRINT,'* ',leftw,rightw
        IF NOT KEYWORD_SET(click) AND KEYWORD_SET(plot) AND NOT KEYWORD_SET(nowindows) THEN BEGIN
          PLOTS,[            leftx,            leftx],[0,MAX([smoothed(left       )])],COLOR=3
          PLOTS,[newx(left+maxidx),newx(left+maxidx)],[0,MAX([smoothed(left+maxidx)])],COLOR=3
          PLOTS,[           rightx,           rightx],[0,MAX([smoothed(right      )])],COLOR=3
        ENDIF
        IF peaks2fit LT npeaks THEN BEGIN
            IF peaks2fit EQ 0 THEN BEGIN
              b=[peakamplitude,newx(left+maxidx),peakwidth/sig2fwhm]
            ENDIF ELSE BEGIN
              b=[b,peakamplitude,newx(left+maxidx),peakwidth/sig2fwhm]
            ENDELSE
            IF voigt     THEN b=[b,0.2]
            IF rectangle THEN b=[b,peakwidth/10.0/sig2fwhm]
            peaks2fit=peaks2fit+1
        ENDIF
      ENDIF
    ENDIF
  ENDFOR
  IF KEYWORD_SET(search) THEN BEGIN
    IF npeaks GT peaks2fit THEN BEGIN
      IF N_ELEMENTS(b) GT 1 THEN b=[b,FLTARR((npeaks-peaks2fit)*peakpars)]    
    ENDIF
    IF N_ELEMENTS(b) GT 1 THEN b=[b,a(npeaks*peakpars+INDGEN(nterms+furtherterms))] ELSE  b=a(npeaks*peakpars+INDGEN(nterms+furtherterms))
    refflag=INTARR(N_ELEMENTS(A))
    IF peaks2fit GT 0 THEN refflag(0:peakpars*peaks2fit-1)=1
    refflag(peakpars*npeaks:N_ELEMENTS(a)-1)=1
    a=b
  ENDIF
  ; ************************* Least Square Iterations ***************************************
  FOR j=0,loops-1 DO BEGIN
    aa=a
    IF bragg OR rectangle OR (STRPOS(func,'fcj') GE 0) THEN noderivative=1 ; no derivatives yet (correctly) implemented for these cases!
    ; +++++++++++++ First, we want to exclude non-existing peaks from any refinment (except the first ...) +++++++++++++++++++++++++
    IF NOT KEYWORD_SET(search) THEN BEGIN
      b=a
      peaks2fit=npeaks
      refflag=INTARR(N_ELEMENTS(A))+1
      FOR peak=0,npeaks-1 DO BEGIN
        IF NOT (i EQ start AND j EQ 0) THEN BEGIN
          ;PLOT,x,w(*,i),COLOR=0,back=255
          b(peak*peakpars)=0
          IF a(peak*peakpars) AND j NE 0 NE 0 THEN CALL_PROCEDURE,func,x,b,g0 ;ELSE g0=f(*,i-step); otherwise, g0 is already known!
          ;oPLOT,x,g0,COLOR=2,LINE=1
          IF a(peak*peakpars) GT 0 THEN BEGIN
            ; Don`t make the further stuff, if already everything looks fine for this peak as it is
            b(peak*peakpars)=a(peak*peakpars)
            CALL_PROCEDURE,func,x,b,g1
            chisqr0=TOTAL((g0-w(*,i))^2)/(N_ELEMENTS(w(*,i))-N_ELEMENTS(a)+peakpars)
            chisqr1=TOTAL((g1-w(*,i))^2)/(N_ELEMENTS(w(*,i))-N_ELEMENTS(a))
            IF chisqr0 LE 1.1*chisqr1 OR b(peak*peakpars) LE 0 THEN b(peak*peakpars)=0
            IF b(peak*peakpars) EQ 0 AND KEYWORD_SET(printing) AND j EQ 0 THEN PRINT,'Peak',peak,' to be checked, : amplitude=', b(peak*peakpars),', chi2:',chisqr1,'+10%>',chisqr0
          ENDIF 
          IF b(peak*peakpars) LE 0 THEN BEGIN ; no or only slight improvement to fit by using this peak - or peak equal zero from beginning
            bid=MIN(ABS(x-a(peak*peakpars+1)),xindex)
            b(peak*peakpars+2)=b(peak*peakpars+2)<maxwidth
            peakintegral=WHERE(x LE (a(peak*peakpars+1)+(b(peak*peakpars+2)<maxsearchwidth)) AND x GE (a(peak*peakpars+1)-(b(peak*peakpars+2)<maxsearchwidth)),peakcells)
            IF peakcells LE 4 THEN BEGIN
              peakintegral=INDGEN(5<N_ELEMENTS(x))+(xindex-2)>0 
              peakcells=5
            ENDIF
            IF peakcells GT 0 THEN BEGIN
              b(peak*peakpars) =  Min(w(peakintegral,i)-g0(peakintegral),peakposition)
              ;IF KEYWORD_SET(printing) AND j EQ 0 THEN PRINT,'Peak',peak,': Minimum of', b(peak*peakpars),'+/-',e(peakintegral(peakposition),i),' at',x(peakintegral(peakposition))
              b(peak*peakpars) = MAX(w(peakintegral,i)-g0(peakintegral),peakposition)
              ;IF KEYWORD_SET(printing) AND j EQ 0 THEN PRINT,'Peak',peak,': Maximum of', b(peak*peakpars),'+/-',e(peakintegral(peakposition),i),' at',x(peakintegral(peakposition))
              IF peakposition LT 0 OR peakposition GT (peakcells-1) THEN BEGIN
                IF a(peak*peakpars) EQ 0 AND KEYWORD_SET(printing) THEN PRINT,'0-Peak',peak,' still not refined, as maximum lies on the border of search range at',x(peakintegral(peakposition))
                IF a(peak*peakpars) GT 0 AND KEYWORD_SET(printing) THEN PRINT,'Old Pk',peak,' no longer refined, as maximum lies on the border of search range at',x(peakintegral(peakposition))
                b(peak*peakpars) =0 ; maximum lies on the border of search range -> don`t consider this peak ...
              ENDIF ELSE BEGIN
                FOR neighbour=0,npeaks-1 DO BEGIN
                  bid=MIN(ABS(x-b(neighbour*peakpars+1)),neighbour_xindex)
                  IF neighbour NE peak AND ABS(neighbour_xindex-peakintegral(peakposition)) LE 1 THEN BEGIN
                  ;IF a(neighbour*peakpars+1) LE x(peakintegral(peakposition))+0.1 AND a(neighbour*peakpars+1) GE x(peakintegral(peakposition))-0.1 THEN BEGIN
                    IF a(neighbour*peakpars+2)-a(peak*peakpars+2)*1.5 AND a(neighbour*peakpars+2) GE a(peak*peakpars+2)/1.5 THEN BEGIN
                      b(peak*peakpars)=0
                      IF a(peak*peakpars) EQ 0 AND KEYWORD_SET(printing) THEN PRINT,'0-Peak',peak,' still not refined, as overlapping with neighbour peak',neighbour 
                      IF a(peak*peakpars) GT 0 AND KEYWORD_SET(printing) THEN PRINT,'Old Pk',peak,' no longer refined, as overlapping with neighbour peak',neighbour 
                      neighbour=npeaks
                    ENDIF
                  ENDIF
                ENDFOR
                IF b(peak*peakpars) GT 0 THEN b(peak*peakpars+1) = x(peakintegral(peakposition))
              ENDELSE
              IF b(peak*peakpars) LE 3.*e(peakintegral(peakposition)) THEN BEGIN
                IF a(peak*peakpars) EQ 0 AND b(peak*peakpars) NE 0 AND KEYWORD_SET(printing) THEN PRINT,'0-Peak',peak,' still not refined: amplitude',b(peak*peakpars),'<3 error bars (', e(peakintegral(peakposition)),') at',x(peakintegral(peakposition)) 
                IF a(peak*peakpars) GT 0 AND b(peak*peakpars) NE 0 AND KEYWORD_SET(printing) THEN PRINT,'Old Pk',peak,' no longer refined: amplitude',b(peak*peakpars),'<3 error bars (', e(peakintegral(peakposition)),') at',x(peakintegral(peakposition)) 
                b(peak*peakpars) =0
              ENDIF
            ENDIF ELSE BEGIN
              IF KEYWORD_SET(printing) THEN PRINT,'Peak',peak,' covers no detector cells!'
              b(peak*peakpars)=0;a(peak*peakpars)
            ENDELSE
            IF b(peak*peakpars) LE 0 THEN BEGIN
                ;IF KEYWORD_SET(printing) THEN PRINT,'Peak ',peak,' will not be refined: amplitude=', b(peak*peakpars)
                b(peak*peakpars)=0
                aa(peak*peakpars)=0
            ENDIF ELSE BEGIN
                CALL_PROCEDURE,func,x,b,g1
                ;oPLOT,x,g1,COLOR=1,LINE=2
                chisqr1=TOTAL((g1-w(*,i))^2)/(N_ELEMENTS(w(*,i))-N_ELEMENTS(a))
                IF chisqr0 LE chisqr1 THEN BEGIN
                  IF KEYWORD_SET(printing) THEN PRINT,'Peak ',peak,' will not be refined: amplitude=', b(peak*peakpars),', chi2:',chisqr1,'>',chisqr0
                  b(peak*peakpars)=0
                  aa(peak*peakpars)=0
                ENDIF ELSE IF chisqr0 LE 1.1*chisqr1 THEN BEGIN
                  IF KEYWORD_SET(printing) THEN PRINT,'Peak ',peak,' will not be refined: amplitude=', b(peak*peakpars),', chi2:',chisqr1,'+10%>',chisqr0
                  b(peak*peakpars)=0
                  aa(peak*peakpars)=0
                 ENDIF 
            ENDELSE
            IF KEYWORD_SET(printing) AND b(peak*peakpars) GT 0 THEN IF (a(peak*peakpars+1) LT x((peakintegral(peakposition)-1)>0) OR a(peak*peakpars+1) GT x((peakintegral(peakposition)+1)<(N_ELEMENTS(x)-1)))  THEN BEGIN
                PRINT,'Peak ',peak,' shifts from', a(peak*peakpars+1),' to', b(peak*peakpars+1)
            ENDIF
          ENDIF
        ENDIF ELSE b(peak*peakpars)=a(peak*peakpars)
        IF b(peak*peakpars) EQ 0 THEN BEGIN
            refflag(peak*peakpars+INDGEN(peakpars))=0
            peaks2fit=peaks2fit-1
        ENDIF ELSE BEGIN
          IF a(peak*peakpars) EQ 0 THEN BEGIN
            refflag(peak*peakpars+INDGEN(peakpars))=MAX(refflag(peak*peakpars+INDGEN(peakpars)))+1
            IF KEYWORD_SET(printing) THEN PRINT,'Former 0-peak ',peak,' now in, with amplitude=', b(peak*peakpars),'+/-',e(peakintegral(peakposition)),', and position=',b(peak*peakpars+1)
          ENDIF
        ENDELSE
      ENDFOR
      IF KEYWORD_SET(printing) THEN PRINT,peaks2fit,' peaks remaining for fit'
    ENDIF ELSE BEGIN ; keyword 'search' set
      IF KEYWORD_SET(printing) THEN PRINT,peaks2fit,' peaks initially found for fit'
    ENDELSE
    refindex=WHERE(refflag GE 1)
    a=b(refindex)
    sigmaa=1;FLTARR(N_ELEMENTS(a))
    tmp=npeaks
    npeaks=peaks2fit
    fitflag=0
    ; +++++++++++++++++ Now, do the least squares refinment only on peaks to be refined! ++++++++++++++++++++++++++++++++++
    IF KEYWORD_SET(search) AND STRPOS(func,'fcj') GE 0 THEN BEGIN
      c=a(0:npeaks*peakpars+nterms-1)
      IF rectangle OR bragg THEN noder=1 ELSE noder=0
      f(*,i) = lsfit(x,w(*,i),weight,c,sigmaa,function_name='gauss_poly',TOL=TOL,ITMAX=ITMAX,ITER=ITER,CHI2=CHI2,noderivative=noder,PLOT=(i EQ start),print=(i EQ start),damp=ref(refindex))
      a(0:npeaks*peakpars+nterms-1)=c
    ENDIF
    f(*,i) = lsfit(x,w(*,i),weight,a,sigmaa,function_name=func,TOL=TOL,ITMAX=ITMAX,ITER=ITER,CHI2=CHI2,noderivative=noderivative,PLOT=(i EQ start),print=(i EQ start),damp=ref(refindex))
    ; ****** some peaksearching ... try out some future (?) new peak appearance/disappearing management ******
    smoothed=SMOOTH(w(*,i)-f(*,i),7)
    ;smoothed=w(*,i) ; finally ... not smoothed at all ...
    index=INDGEN(N_ELEMENTS(smoothed))
    denominator=x((index+1)<(N_ELEMENTS(smoothed)-1))-x((index-1)>0)
    stepx=TOTAL(denominator(index(1:N_ELEMENTS(smoothed)-2)))/(N_ELEMENTS(smoothed)-2)
    denominator=denominator/stepx
    differentiated=(smoothed((index+1)<(N_ELEMENTS(smoothed)-1))-smoothed((index-1)>0))/denominator
    differentiated(0)=0
    differentiated(N_ELEMENTS(smoothed)-1)=0
    error=(e((index+1)<(N_ELEMENTS(smoothed)-1),i)+e((index-1)>0,i))/denominator
    twoprime=differentiated((index+1)<(N_ELEMENTS(smoothed)-1))-differentiated((index-1)>0)/denominator
    twoprime(0)=0
    twoprime(N_ELEMENTS(smoothed)-1)=0
    newx=FINDGEN(N_ELEMENTS(x)*10)*(MAX(x)-MIN(x))/N_ELEMENTS(x)/10.+MIN(x)
    ;foundpeaks=WHERE(differentiated LE error*3. AND differentiated((index-1)>0) GT error*3.,numberofoundpeaks)
    ;IF numberofoundpeaks GE 1 THEN PRINT,x(foundpeaks)
    twoprime      =INTERPOL(twoprime      ,x,newx)
    differentiated=INTERPOL(differentiated,x,newx)
    smoothed      =INTERPOL(smoothed      ,x,newx)
    error         =INTERPOL(error         ,x,newx)
    ;foundpeaks=WHERE(differentiated LE error*3. AND differentiated((INDGEN(N_ELEMENTS(newx))-1)>0) GT error*3.,numberofoundpeaks)
    foundpeaks=WHERE(differentiated LE 0 AND differentiated((INDGEN(N_ELEMENTS(newx))-1)>0) GT 0 AND differentiated((INDGEN(N_ELEMENTS(newx))-1)>0)-differentiated GT 0.02*(error+error((INDGEN(N_ELEMENTS(newx))-1)>0)),numberofoundpeaks)
    IF numberofoundpeaks GE 1 THEN PRINT,newx(foundpeaks)
    IF NOT KEYWORD_SET(click) AND KEYWORD_SET(plot) AND NOT KEYWORD_SET(now) THEN BEGIN
        WSET,1
        PLOT,x,w(*,i)-f(*,i),YR=[MIN([w(*,i)-f(*,i),differentiated,twoprime]),MAX([w(*,i)-f(*,i),differentiated,twoprime])],BACK=255
        OPLOTERR,x,w(*,i)-f(*,i),e(*,i),0
        OPLOT,newx,smoothed
        OPLOT,newx,differentiated,COLOR=2
        ;OPLOTERR,x,differentiated,error,0
        OPLOT,newx,twoprime,COLOR=3
        WSET,0
    ENDIF
    IF KEYWORD_SET(search) THEN BEGIN
      IF npeaks GT 0 THEN b=a(0:npeaks*peakpars-1) ELSE b=0
      b_tmp=a(npeaks*peakpars:npeaks*peakpars+nterms+furtherterms-1)
    ENDIF
    FOR foundpeak=0,numberofoundpeaks-1 DO BEGIN
      ;part=differentiated(foundpeaks(foundpeak))/(differentiated(foundpeaks(foundpeak))-differentiated(foundpeaks(foundpeak)-1))
      ;maxx=
      idx=INDGEN(foundpeaks(foundpeak))
      left=MAX(WHERE(twoprime(idx) GE 0))
      leftpart=twoprime(left)/(twoprime(left)-twoprime(left+1))
      ;left=left-1
      leftx=leftpart*    newx(left)+(1-leftpart)*    newx(left+1)
      leftw=leftpart*smoothed(left)+(1-leftpart)*smoothed(left+1)
      idx=INDGEN(N_ELEMENTS(smoothed)-foundpeaks(foundpeak))+foundpeaks(foundpeak)
      right=MIN(WHERE(twoprime(idx) GE 0))+foundpeaks(foundpeak)
      rightpart=twoprime(right)/(twoprime(right)-twoprime(right-1))
      ;right=right-1
      rightx=rightpart*    newx(right)+(1-rightpart)*    newx(right-1)
      rightw=rightpart*smoothed(right)+(1-rightpart)*smoothed(right+1)
      IF KEYWORD_SET(search) THEN BEGIN
        peakwidth=(rightx-leftx)*sig2fwhm/2.
        ;peakamplitude=MAX(smoothed(left:right),maxidx)
        peakamplitude=(MAX(smoothed(left:right),maxidx)-(leftw+rightw)/2.0)/(1.0-EXP(-0.5))
        ;PRINT,peakwidth
        IF peakwidth GE minwidth*2. AND peakamplitude GT 4.*error(maxidx) THEN BEGIN
          ;peakamplitude= MAX(smoothed(left:right),maxidx)-(POLY(newx(left+maxidx),a(npeaks*peakpars+INDGEN(nterms)))>MIN(w(*,i)))
          PRINT,'##',peaks2fit,peakamplitude,newx(left+maxidx),rightx-leftx,error(maxidx)
          PRINT,'# ',(MAX(smoothed(left:right))-(leftw+rightw)/2.0)/(1.0-EXP(-0.5)),leftw,rightw
          IF NOT KEYWORD_SET(click) AND KEYWORD_SET(plot) AND NOT KEYWORD_SET(nowindows) THEN BEGIN
            WSET,1
            PLOTS,[ leftx, leftx],[MIN([twoprime(left),differentiated(left),smoothed(left)]), MAX([twoprime(left),differentiated(left),smoothed(left)])],COLOR=3
            PLOTS,[newx(left+maxidx),newx(left+maxidx)],[MIN([twoprime(left+maxidx),differentiated(left+maxidx),smoothed(left+maxidx)]), MAX([twoprime(left+maxidx),differentiated(left+maxidx),smoothed(left+maxidx)])],COLOR=1
            PLOTS,[rightx,rightx],[MIN([twoprime(right),differentiated(right),smoothed(right)]), MAX([twoprime(right),differentiated(right),smoothed(right)])],COLOR=3
            WSET,0
          ENDIF
          IF peaks2fit LT tmp THEN BEGIN
            IF peaks2fit EQ 0 THEN BEGIN
              b=[peakamplitude,newx(left+maxidx),peakwidth/sig2fwhm,b]
            ENDIF ELSE BEGIN
              b=[b,peakamplitude,newx(left+maxidx),peakwidth/sig2fwhm]
            ENDELSE
            IF voigt     THEN b=[b,0.2]
            IF rectangle THEN b=[b,peakwidth/10.0/sig2fwhm]
            peaks2fit=peaks2fit+1
          ENDIF
        ENDIF
      ENDIF
    ENDFOR
    IF KEYWORD_SET(search) AND peaks2fit GT npeaks THEN BEGIN
          HELP,b,b_tmp
          PRINT,b_tmp
          b=[b,b_tmp]
          refflag(0:peakpars*peaks2fit-1)=1
          refindex=WHERE(refflag GE 1)
          a=b;(refindex)
          sigmaa=1;FLTARR(N_ELEMENTS(a))
          npeaks=peaks2fit
          fitflag=0
          PRINT,npeaks
          HELP,a
          FOR peak=0,npeaks-1 DO PRINT,a(peak*peakpars+INDGEN(peakpars))
          IF nterms GT 0 THEN PRINT,a(npeaks*peakpars+INDGEN(nterms))
          IF furtherterms GT 0 THEN PRINT,a(npeaks*peakpars+nterms+INDGEN(furtherterms))
          CALL_PROCEDURE,func,x,a,g
          IF NOT KEYWORD_SET(click) AND KEYWORD_SET(plot) AND NOT KEYWORD_SET(nowindows) THEN BEGIN
            WSET,1
            OPLOT,x,w(*,i)-MIN(w(*,i)),COLOR=0
            OPLOTERR,x,w(*,i)-MIN(w(*,i)),e(*,i)
            OPLOT,x,g-MIN(w(*,i)),COLOR=1
            WSET,0
          ENDIF
          ;IF KEYWORD_SET(search) AND STRPOS(func,'fcj') GE 0 THEN BEGIN
            ;c=a(0:npeaks*peakpars+nterms-1)
            ;IF rectangle OR bragg THEN noder=1 ELSE noder=0
            ;f(*,i) = lsfit(x,w(*,i),weight,c,sigmaa,function_name='gauss_poly',TOL=TOL,ITMAX=ITMAX,ITER=ITER,CHI2=CHI2,noderivative=noder,PLOT=(i EQ start),print=(i EQ start),damp=ref(refindex))
            ;a(0:npeaks*peakpars+nterms-1)=c
          ;ENDIF
          f(*,i) = lsfit(x,w(*,i),weight,a,sigmaa,function_name=func,TOL=TOL,ITMAX=ITMAX,ITER=ITER,CHI2=CHI2,noderivative=noderivative,PLOT=(i EQ start),print=(i EQ start),damp=ref(refindex))
    ENDIF
    bid=MIN(w(*,i)-f(*,i),minpos)
    PRINT,'The residual shows a minimum of',bid,'+/-',e(minpos,i),' counts at',x(minpos),' degrees'
    bid=MAX(w(*,i)-f(*,i),maxpos)
    PRINT,'The residual shows a maximum of',bid,'+/-',e(maxpos,i),' counts at',x(maxpos),' degrees'
    ;closest_peak=0
    ;closest_zero_peak=0
    ;For peak=1,tmp-1 DO BEGIN
    ;  IF 
    ;ENDFOR
    IF fitflag THEN PRINT,'Least-squares becomes instable!'
    REPEAT BEGIN
      ;fitflag=0
      IF fitflag GE 3 THEN fitflag=fitflag-3
      FOR peak=0,npeaks-1 DO BEGIN
        ; check for NAN sigmas and put the corresponding peaks to their starting values - with zero amplitude - otherwise they shift around!
        bid=MIN(ABS(x-a(peak*peakpars+1)),peak_xindex)
        IF a(peak*peakpars) EQ 0 OR NOT FINITE(a(peak*peakpars)) THEN BEGIN ; lsfit sets the amplitude to zero, if there is a problem!
          ;PRINT,a(peak*peakpars+INDGEN(peakpars))
          ;PRINT,refindex(INDGEN(tmp)*peakpars),peak,peakpars
          IF KEYWORD_SET(printing) THEN PRINT,'Not to be refined peak as it became negative or infinite: ',refindex(peak*peakpars)/peakpars
          fitflag=2 ; will repeat least square after exclusion of this peak!
          a=b(refindex) ; go back to start!
          a(peak*peakpars+INDGEN(peakpars))=aa(refindex(peak*peakpars+INDGEN(peakpars))) ; set back to initial values
          a(peak*peakpars)=0
          peaks2fit=peaks2fit-1
          refflag(refindex(peak*peakpars)+INDGEN(peakpars))=0
          peak=npeaks
        ENDIF ELSE BEGIN
          ;intensity_tmp=a(peak*peakpars)
          ;sig_intensity_tmp=sigmaa(peak*peakpars)
          ;IF KEYWORD_SET(printing) THEN PRINT,'Peak',refindex(peak*peakpars)/peakpars,': amplitude=',intensity_tmp,'+/-',sig_intensity_tmp
          intensity_tmp=a(peak*peakpars)*a(peak*peakpars+2)*SQRT(!PI/ALOG(2.))/2.*sig2fwhm
          sig_intensity_tmp  =(ABS(sigmaa(peak*peakpars)*a(peak*peakpars+2))+ABS(a(peak*peakpars)*sigmaa(peak*peakpars+2)))*SQRT(!PI/ALOG(2.))/2.*sig2fwhm
          ;sig_intensity(i,j)=(ABS(sig_amplitude(i,j)   *width(i,j)       )+ABS(amplitude(i,j)  *sig_width(i,j)         ))*SQRT(!PI/ALOG(2.))/2.
          IF KEYWORD_SET(printing) THEN PRINT,'Peak',refindex(peak*peakpars)/peakpars,': intensity=',intensity_tmp,'+/-',sig_intensity_tmp
          IF intensity_tmp LE 3.*sig_intensity_tmp THEN BEGIN
            IF KEYWORD_SET(printing) THEN PRINT,'Peak',refindex(peak*peakpars)/peakpars,' finally not to be refined as intensity (',intensity_tmp,') < 3*sigma(intensity) (',sig_intensity_tmp,')'
            fitflag=2 ; will repeat least square after exclusion of this peak!
            a=b(refindex) ; go back to start!
            a(peak*peakpars+INDGEN(peakpars))=aa(refindex(peak*peakpars+INDGEN(peakpars))) ; set back to initial values
            a(peak*peakpars)=0
            peaks2fit=peaks2fit-1
            refflag(refindex(peak*peakpars)+INDGEN(peakpars))=0
            peak=npeaks
          ENDIF ELSE FOR neighbour=peak+1,npeaks-1 DO BEGIN ; check for peaks at same position -> they have to be merged!
            bid=MIN(ABS(x-a(neighbour*peakpars+1)),neighbour_xindex)
            IF ABS(neighbour_xindex-peak_xindex) LE 2 THEN BEGIN
            ;IF a(neighbour*peakpars+1) LE a(peak*peakpars+1)+0.01 AND a(neighbour*peakpars+1) GE a(peak*peakpars+1)-0.01 THEN BEGIN
              IF a(neighbour*peakpars+2) LE a(peak*peakpars+2)*1.5 AND a(neighbour*peakpars+2) GE a(peak*peakpars+2)/1.5 THEN BEGIN
                IF KEYWORD_SET(printing) THEN PRINT,'Overlapping peaks to be merged: ',refindex(peak*peakpars)/peakpars,refindex(neighbour*peakpars)/peakpars
                a=b(refindex)
                a(peak*peakpars)=a(peak*peakpars)+a(neighbour*peakpars) ; put all intensity to first peak!
                a(neighbour*peakpars+INDGEN(peakpars))=aa(refindex(neighbour*peakpars+INDGEN(peakpars)))
                a(neighbour*peakpars)=0
                neighbour=npeaks
                refflag(refindex(neighbour*peakpars)+INDGEN(peakpars))=0
                fitflag=2
                peaks2fit=peaks2fit-1
                peak=npeaks
              ENDIF
            ENDIF
          ENDFOR
        ENDELSE
      ENDFOR
      IF fitflag EQ 2 THEN BEGIN
        IF KEYWORD_SET(plot) THEN BEGIN
          PLOT,x,w(*,i),TITLE='Refused fit of diagram no.'+STRCOMPRESS(i)+STRCOMPRESS(y(i)),YRANGE=[0,MAX(w)],background=255,color=0
          OPLOTERR,x,w(*,i),e(*,i),0
          OPLOT,x,f(*,i),color=1
          OPLOT,x,w(*,i)-f(*,i)+MIN(w)/2.,color=3
          OPLOT,x,f(*,i)*0.0+MIN(w)/2.,color=0
          IF N_ELEMENTS(e) EQ N_ELEMENTS(w) THEN BEGIN
            OPLOT,x,w(*,i)-f(*,i)+e(*,i)+MIN(w)/2.,color=2,LINE=0
            OPLOT,x,w(*,i)-f(*,i)-e(*,i)+MIN(w)/2.,color=2,LINE=0
          ENDIF
        ENDIF
        b=aa
        b(refindex)=a
        refindex=WHERE(refflag GE 1)
        a=b(refindex)
        PRINT,'Repeat fitting for',peaks2fit,' remaining peaks'
        npeaks=peaks2fit
        fitflag=0
        sigmaa=1
        f(*,i) = lsfit(x,w(*,i),weight,a,sigmaa,function_name=func,TOL=TOL,ITMAX=ITMAX,ITER=ITER,CHI2=CHI2,noderivative=noderivative,PLOT=(i EQ start OR i EQ (start+step)),print=(i EQ start OR i EQ (start+step)),damp=ref(refindex))
        fitflag=fitflag+3
        smoothed=SMOOTH(w(*,i)-f(*,i),5)
        index=INDGEN(N_ELEMENTS(smoothed))
        differentiated=smoothed-smoothed((index-1)>0)
        foundpeaks=WHERE(differentiated LE 2*e(*,i) AND differentiated((index-1)>0) GT 2*e(index-1,i),numberofoundpeaks)
        IF numberofoundpeaks GE 1 THEN BEGIN
          PRINT,'res.peaksearch (5,2): ',x(foundpeaks)
        ENDIF
        bid=MIN(w(*,i)-f(*,i),minpos)
        PRINT,'The residual shows a minimum of',bid,'+/-',e(minpos,i),' counts at',x(minpos),' degrees'
        bid=MAX(w(*,i)-f(*,i),maxpos)
        PRINT,'The residual shows a maximum of',bid,'+/-',e(maxpos,i),' counts at',x(maxpos),' degrees'
      ENDIF
    ENDREP UNTIL fitflag LE 1
    IF fitflag THEN BEGIN ; check for instable least squares
      PRINT,'Least-squares becomes instable, so reducing concerned damping factors and continue iterative least square runs ...'
      fitflag=0
      j=0
      ref(refindex)=ref(refindex)/2.
      IF MAX(ref(refindex)) LT 0.1 THEN BEGIN
        j=loops
        fitflag=1
        PRINT,'Okay, we shall give up and quit further refinments, as even with damping factors all less 10%, least-squares are still unstable!'
      ENDIF
    ENDIF
    ;IF (NOT KEYWORD_SET(click) OR i NE start) AND NOT KEYWORD_SET(search) THEN BEGIN
    IF (NOT KEYWORD_SET(click)) AND NOT KEYWORD_SET(search) AND N_ELEMENTS(peakintegral) GT 0 THEN BEGIN
      ;IF N_ELEMENTS(peakintegral) LE 0 THEN peakintegral=INDGEN(N_ELEMENTS(x))
      IF b(peak*peakpars) GT 0 THEN b(peak*peakpars+1) = x(peakintegral(peakposition))
    ENDIF
    npeaks=tmp
    b=a
    a=aa
    a(refindex)=b
    b=sigmaa
    sigmaa=FLTARR(N_ELEMENTS(a))
    sigmaa(refindex)=b
    IF Error_status NE 0 THEN BEGIN
      j=loops
      PRINT, 'Error index: ', Error_status
      PRINT, 'Error message:', !ERR_STRING
    ENDIF
    IF KEYWORD_SET(click) THEN BEGIN
      WIDGET_CONTROL,npeaks_label,SET_VALUE=STRCOMPRESS(npeaks,/RE)+' peaks'
      WIDGET_CONTROL,peak_ampli,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars),/RE)
      WIDGET_CONTROL,peak_pos,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+1),/RE)
      WIDGET_CONTROL,peak_wid,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+2),/RE)
      IF voigt THEN WIDGET_CONTROL,peak_eta,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+3),/RE)
      IF rectangle THEN WIDGET_CONTROL,peak_HR,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+voigt+3),/RE)
      IF furtherterms GE 3 THEN BEGIN
        WIDGET_CONTROL,fcj_S,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars),/RE)
        WIDGET_CONTROL,fcj_H,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars+1),/RE)
        WIDGET_CONTROL,fcj_L,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars+2),/RE)
      ENDIF
    ENDIF
    IF j EQ loops THEN BEGIN
      shift=a-aa
      shift=MAX(shift/a,maxshift)
      IF maxshift LE npeaks*peakpars THEN BEGIN
        text=', peak'+STRCOMPRESS(maxshift/peakpars)
        IF (maxshift MOD peakpars) EQ 0 THEN text=text+' (amplitude)'
        IF (maxshift MOD peakpars) EQ 1 THEN text=text+' (position)'
        IF (maxshift MOD peakpars) EQ 2 THEN text=text+' (FWHM)'
        IF voigt THEN IF (maxshift MOD peakpars) EQ 3 THEN text=text+' (eta)'
        IF rectangle THEN IF (maxshift MOD peakpars) EQ (3+voigt) THEN text=text+' (HR)'
      ENDIF ELSE text=', background polynom or further parameter no.'+STRCOMPRESS(maxshift-npeaks*peakpars)
      IF KEYWORD_SET(printing) THEN PRINT,'Max. shift of',100.*shift,'% for parameter',maxshift,text
      IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE='Max. shift of'+STRING(100.*shift)+'% for parameter'+STRING(maxshift)+text
    ENDIF
  ENDFOR
  loops=iterations
  ; ***************************** Graphical output of fitting result for this diagram ********************
  IF KEYWORD_SET(plot) THEN BEGIN
        PLOT,x,w(*,i),TITLE='Fit of diagram no.'+STRCOMPRESS(i)+STRCOMPRESS(y(i)),YRANGE=[0,MAX(w)],background=255,color=0
        OPLOTERR,x,w(*,i),e(*,i),0
        OPLOT,x,f(*,i),color=1
        OPLOT,x,w(*,i)-f(*,i)+MIN(w)/2.,color=3
        OPLOT,x,f(*,i)*0.0+MIN(w)/2.,color=0
        IF N_ELEMENTS(e) EQ N_ELEMENTS(w) THEN BEGIN
          OPLOT,x,w(*,i)-f(*,i)+e(*,i)+MIN(w)/2.,color=2,LINE=0
          OPLOT,x,w(*,i)-f(*,i)-e(*,i)+MIN(w)/2.,color=2,LINE=0
        ENDIF
  ENDIF
  ; ************************ Put the resulting parameters to the corresponding variables ************************
  IF nterms GT 0 THEN BEGIN
    bg(i,*)=a(npeaks*peakpars+INDGEN(nterms))
    sig_bg(i,*)=sigmaa(npeaks*peakpars+INDGEN(nterms))
  ENDIF
  IF furtherterms GE 3 AND STRPOS(func,'fcj') GE 0 THEN BEGIN
    S(i,*)=a(npeaks*peakpars+nterms)
    H(i,*)=a(npeaks*peakpars+nterms+1)
    L(i,*)=a(npeaks*peakpars+nterms+2)
    sig_S(i,*)=sigmaa(npeaks*peakpars+nterms)
    sig_H(i,*)=sigmaa(npeaks*peakpars+nterms+1)
    sig_L(i,*)=sigmaa(npeaks*peakpars+nterms+2)
  ENDIF
  dy=w(*,i)-f(*,i)
  Rp=TOTAL(ABS(dy))/TOTAL(w)
  Rwp=SQRT(TOTAL(e*dy^2)/TOTAL(e*w^2))
  IF KEYWORD_SET(printing) THEN PRINT,FORMAT='(I8,2I18,4G18.6)',i,y(i),ITER,chi2,Rp,Rwp,SQRT(TOTAL(e*e^2)/TOTAL(e*w^2))
  IF KEYWORD_SET(widget) THEN WIDGET_CONTROL,w1,/APPEND,SET_VALUE=STRING(i)+STRING(ITER)+STRING(chi2)+STRING(Rp)+STRING(Rwp)+STRING(SQRT(TOTAL(e*e^2)/TOTAL(e*w^2)))
  IF KEYWORD_SET(file) THEN PRINTF,output,FORMAT='(I8,2I18,4G18.6)',i,y(i),ITER,chi2,Rp,Rwp,SQRT(TOTAL(e*e^2)/TOTAL(e*w^2))
  ; *********************** Plot each individual peak as dotted line and print its parameters *******************************************
  tmp=npeaks
  npeaks=1
  FOR j=0,tmp-1 DO BEGIN
    IF KEYWORD_SET(plot) THEN BEGIN
        b=[a((j*peakpars)+INDGEN(peakpars))]
        IF nterms+furtherterms GT 0 THEN b=[b,a(tmp*peakpars+INDGEN(nterms+furtherterms))]
        CALL_PROCEDURE,func,x,b,g
        OPLOT,x,g,COLOR=j+3,LINE=1
    ENDIF
    a(j*peakpars+2)=ABS(a(j*peakpars+2))
    amplitude(i,j)=a(j*peakpars+0)
    position(i,j) =a(j*peakpars+1)
    width(i,j)     =a(j*peakpars+2)*sig2fwhm
    sig_amplitude(i,j)=sigmaa(j*peakpars+0)
    sig_position(i,j) =sigmaa(j*peakpars+1)
    sig_width(i,j)     =sigmaa(j*peakpars+2)*sig2fwhm
    ; ############################# Calculate intensity for amplitude and sigma ########################################
    intensity(i,j)=amplitude(i,j)*width(i,j)*SQRT(!PI/ALOG(2.))/2.
    sig_intensity(i,j)=(ABS(sig_amplitude(i,j)*width(i,j))+ABS(amplitude(i,j)*sig_width(i,j)))*SQRT(!PI/ALOG(2.))/2.
    IF voigt EQ 1 THEN BEGIN
      sin_eta=SIN(!PI/2.*a(3+peakpars*j))
      true_eta=sin_eta^2
      eta(i,j)=true_eta
      sig_eta(i,j)=sigmaa(j*peakpars+3)*sin_eta*!PI*COS(!PI/2.*a(3+peakpars*j))
    ENDIF
    IF rectangle THEN BEGIN
      HR(i,j)=a(j*peakpars+voigt+3)
      sig_HR(i,j)=sigmaa(j*peakpars+voigt+3)
    ENDIF
  ENDFOR
  npeaks=tmp
  IF KEYWORD_SET(click) THEN BEGIN
    IF voigt THEN widget_result=WIDGET_EVENT([next_button,undo_button,up_peak,down_peak,peak_ampli,peak_pos,peak_wid,peak_eta,peak_HR,fcj_S,fcj_H,fcj_L,bragg_button],NOWAIT=nowait) ELSE BEGIN
      widget_result=WIDGET_EVENT([next_button,undo_button,up_peak,down_peak,peak_ampli,peak_pos,peak_wid,peak_HR,fcj_S,fcj_H,fcj_L,bragg_button],NOWAIT=nowait) 
    ENDELSE
    IF widget_result.ID EQ bragg_button THEN BEGIN
      IF bragg THEN bragg=0 ELSE bragg=1
      PRINT,'Bragg Convolution:',bragg
    ENDIF
    IF widget_result.ID EQ up_peak THEN BEGIN
      peak_number=(peak_number+1)<(npeaks-1)
    ENDIF
    IF widget_result.ID EQ down_peak THEN BEGIN
      peak_number=(peak_number-1)>0
    ENDIF
    IF widget_result.ID EQ peak_ampli THEN BEGIN
      WIDGET_CONTROL,peak_ampli,GET_VALUE=valstr
      a(peak_number*peakpars)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ peak_pos THEN BEGIN
      WIDGET_CONTROL,peak_pos,GET_VALUE=valstr
      a(peak_number*peakpars+1)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ peak_wid THEN BEGIN
      WIDGET_CONTROL,peak_wid,GET_VALUE=valstr
      a(peak_number*peakpars+2)=FLOAT(valstr(0))
    ENDIF
    IF voigt THEN IF widget_result.ID EQ peak_eta THEN BEGIN
      WIDGET_CONTROL,peak_eta,GET_VALUE=valstr
      a(peak_number*peakpars+3)=FLOAT(valstr(0))
    ENDIF
    IF widget_result.ID EQ undo_button THEN BEGIN
      IF nowait EQ 1 THEN BEGIN
        nowait=0
        WIDGET_CONTROL,undo_button,SET_VALUE='Continue'
      ENDIF ELSE BEGIN
        nowait=1
        WIDGET_CONTROL,undo_button,SET_VALUE='Pause'
      ENDELSE
    ENDIF
    WIDGET_CONTROL,peak_no,SET_VALUE='Pk. no.'+STRCOMPRESS(peak_number,/RE)+':'
    WIDGET_CONTROL,npeaks_label,SET_VALUE=STRCOMPRESS(npeaks,/RE)+' peaks'
    WIDGET_CONTROL,peak_ampli,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars),/RE)
    WIDGET_CONTROL,peak_pos,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+1),/RE)
    WIDGET_CONTROL,peak_wid,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+2),/RE)
    IF rectangle THEN WIDGET_CONTROL,peak_HR,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+voigt+3),/RE)
    IF furtherterms GE 3 THEN BEGIN
      WIDGET_CONTROL,fcj_S,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars),/RE)
      WIDGET_CONTROL,fcj_H,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars+1),/RE)
      WIDGET_CONTROL,fcj_L,SET_VALUE=STRCOMPRESS(a(nterms+npeaks*peakpars+2),/RE)
    ENDIF
    IF voigt THEN WIDGET_CONTROL,peak_eta,SET_VALUE=STRCOMPRESS(a(peak_number*peakpars+3),/RE)
    IF i EQ start AND NOT initial_fit_finished THEN BEGIN
      IF widget_result.ID NE next_button THEN BEGIN
        i=start
        initial_fit_finished=0
      ENDIF ELSE BEGIN
        initial_fit_finished=1
        WIDGET_CONTROL,title_field,SET_VALUE='Click on Stop button when the fit of the inital guess becomes satisfying!'
        WIDGET_CONTROL,next_button,SET_VALUE='Stop sequential fitting!'
        WIDGET_CONTROL,undo_button,SET_VALUE='Pause'
        nowait=1
      ENDELSE
    ENDIF ELSE BEGIN
      IF widget_result.ID EQ next_button THEN BEGIN
        i=last
      ENDIF
    ENDELSE
  ENDIF
  ; ******************* Print the peak parameters **********************
  FOR j=0,npeaks-1 DO BEGIN
      IF KEYWORD_SET(printing) THEN BEGIN
        IF voigt EQ 0 THEN BEGIN
          IF rectangle THEN BEGIN
            PRINT,FORMAT='(4X,I4,8G18.6)',j,intensity(i,j),amplitude(i,j),position(i,j),width(i,j),HR(i,j),sig_intensity(i,j),sig_amplitude(i,j),sig_position(i,j),sig_width(i,j),sig_HR(i,j)
          ENDIF ELSE BEGIN
            PRINT,FORMAT='(4X,I4,8G18.6)',j,intensity(i,j),amplitude(i,j),position(i,j),width(i,j),sig_intensity(i,j),sig_amplitude(i,j),sig_position(i,j),sig_width(i,j)
          ENDELSE
        ENDIF ELSE BEGIN
          IF rectangle THEN BEGIN
            PRINT,FORMAT='(4X,I4,10G18.6)',j,intensity(i,j),amplitude(i,j),position(i,j),width(i,j),eta(i,j),HR(i,j),sig_intensity(i,j),sig_amplitude(i,j),sig_position(i,j),sig_width(i,j),sig_eta(i,j),sig_HR(i,j)
          ENDIF ELSE BEGIN
            PRINT,FORMAT='(4X,I4,10G18.6)',j,intensity(i,j),amplitude(i,j),position(i,j),width(i,j),eta(i,j),sig_intensity(i,j),sig_amplitude(i,j),sig_position(i,j),sig_width(i,j),sig_eta(i,j)
          ENDELSE
        ENDELSE
      ENDIF
      IF initial_fit_finished EQ 1 AND KEYWORD_SET(file) THEN BEGIN
        IF voigt EQ 0 THEN BEGIN
          PRINTF,output,FORMAT='(4X,I4,6G18.6)',j,amplitude(i,j),position(i,j),width(i,j),sig_amplitude(i,j),sig_position(i,j),sig_width(i,j)
        ENDIF ELSE BEGIN
          PRINTF,output,FORMAT='(4X,I4,8G18.6)',j,amplitude(i,j),position(i,j),width(i,j),eta(i,j),sig_amplitude(i,j),sig_position(i,j),sig_width(i,j),sig_eta(i,j)
        ENDELSE
      ENDIF
  ENDFOR
  ; ******************* Print the background parameters **********************
  IF nterms GT 0 THEN BEGIN
      IF KEYWORD_SET(printing) THEN BEGIN
          fmt='(8X,'+STRCOMPRESS(2*nterms, /REMOVE_ALL)+'G18.6)'
          PRINT,FORMAT=fmt,bg(i,*),sig_bg(i,*)
      ENDIF   
      IF initial_fit_finished EQ 1 AND KEYWORD_SET(file) THEN BEGIN
          fmt='(8X,'+STRCOMPRESS(2*nterms,/REMOVE_ALL)+'G18.6)'
          PRINTF,output,FORMAT=fmt,bg(i,*),sig_bg(i,*)
      ENDIF
  ENDIF
  ; ******************* Print further parameters **********************
  IF furtherterms GT 0 THEN BEGIN
      IF KEYWORD_SET(printing) THEN BEGIN
            fmt='(8X,'+STRCOMPRESS((2*furtherterms), /REMOVE_ALL)+'G18.6)'
            PRINT,FORMAT=fmt,a(npeaks*peakpars+nterms+INDGEN(furtherterms)),sigmaa(npeaks*peakpars+nterms+INDGEN(furtherterms))
      ENDIF
      IF initial_fit_finished EQ 1 AND KEYWORD_SET(file) THEN BEGIN
            fmt='(8X,'+STRCOMPRESS((2*furtherterms), /REMOVE_ALL)+'G18.6)'
            PRINTF,output,FORMAT=fmt,a(npeaks*peakpars+nterms+INDGEN(furtherterms)),sigmaa(npeaks*peakpars+nterms+INDGEN(furtherterms))
      ENDIF  
  ENDIF
  IF KEYWORD_SET(file) THEN FLUSH,output
  IF fitflag THEN BEGIN ; check for instable least squares
      PRINT,'Least-squares becomes instable, so quit here ...'
      i=last
  ENDIF
ENDFOR
IF KEYWORD_SET(click) THEN WIDGET_CONTROL,next_button,SET_VALUE='';,/DESTROY
IF KEYWORD_SET(file) THEN FREE_LUN,output
; ######################## Calculate a positive FWHM from sigma ####################################################
;FOR j=0,npeaks-1 DO  a(j*peakpars+2)=ABS(a(j*peakpars+2))*sig2fwhm
;###################### Prepare return of workspace containing fitted diagrams and its data structure ##############
mod_datp,datp,'x',x
IF NOT KEYWORD_SET(datpp) THEN BEGIN
  give_datp,datp
ENDIF
mod_datp,datp,'x',y
mod_datp,datp,'y',0
w_tit=datp.w_tit
IF W_intensity GT 0 THEN BEGIN
  datp.w_tit='peak intensity from NewFit: '+w_tit
  mod_datp,datp,'e',sig_intensity
  give_w,intensity,w=W_intensity
  give_datp,datp,w=w_intensity
ENDIF
IF W_bg GT 0 THEN BEGIN
  datp.w_tit='background polynom from NewFit: '+w_tit
  mod_datp,datp,'e',sig_bg
  give_w,bg,w=W_bg
  give_datp,datp,w=w_bg
ENDIF
IF W_position GT 0 THEN BEGIN
  datp.w_tit='peak position from NewFit: '+w_tit
  mod_datp,datp,'e',sig_position
  give_w,position,w=W_position
  give_datp,datp,w=w_position
ENDIF
IF W_width GT 0 THEN BEGIN
  datp.w_tit='peak full width half maximum from NewFit: '+w_tit
  mod_datp,datp,'e',sig_width
  give_w,width,w=W_width
  give_datp,datp,w=w_width
ENDIF
IF W_eta GT 0 THEN BEGIN
  datp.w_tit='pseuto-Voigt eta from NewFit: '+w_tit
  mod_datp,datp,'e',sig_eta
  give_w,eta,w=W_eta
  give_datp,datp,w=w_eta
ENDIF
IF W_amplitude GT 0 THEN BEGIN
  datp.w_tit='peak amplitude from NewFit: '+w_tit
  mod_datp,datp,'e',sig_amplitude
  give_w,amplitude,w=W_amplitude
  give_datp,datp,w=w_amplitude
ENDIF
IF W_H GT 0 THEN BEGIN
  datp.w_tit='PSD height from NewFit: '+w_tit
  mod_datp,datp,'e',sig_H
  give_w,H,w=W_H
  give_datp,datp,w=w_H
ENDIF
IF W_S GT 0 THEN BEGIN
  datp.w_tit='Sample height from NewFit: '+w_tit
  mod_datp,datp,'e',sig_S
  give_w,S,w=W_S
  give_datp,datp,w=w_S
ENDIF
IF W_L GT 0 THEN BEGIN
  datp.w_tit='PSD-sample distance from NewFit: '+w_tit
  mod_datp,datp,'e',sig_L
  give_w,L,w=W_L
  give_datp,datp,w=w_L
ENDIF
IF W_HR GT 0 THEN BEGIN
  datp.w_tit='FWHM of rectangle part from NewFit: '+w_tit
  mod_datp,datp,'e',sig_HR
  give_w,HR,w=W_HR
  give_datp,datp,w=w_HR
ENDIF
return,f
END

; $Id: gaussfit.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

Function Gaussfit, x, y, a, nterms=nterms,w=w,sigmaa=sigmaa
;+
; NAME:
;	GAUSSFIT
;
; PURPOSE:
; 	Fit the equation y=f(x) where:
;
; 		F(x) = A0*EXP(-z^2/2) + A3 + A4*x + A5*x^2
; 			and
;		z=(x-A1)/A2
;
;	A0 = height of exp, A1 = center of exp, A2 = sigma (the width).
;	A3 = constant term, A4 = linear term, A5 = quadratic term.
; 	The parameters A0, A1, A2, A3 are estimated and then CURVEFIT is 
;	called.
;
; CATEGORY:
;	?? - fitting
;
; CALLING SEQUENCE:
;	Result = GAUSSFIT(X, Y [, A])
;
; INPUTS:
;	X:	The independent variable.  X must be a vector.
;	Y:	The dependent variable.  Y must have the same number of points
;		as X.
;
; OUTPUTS:
;	The fitted function is returned.
;
; OPTIONAL OUTPUT PARAMETERS:
;	A:	The coefficients of the fit.  A is a six-element vector as 
;		described under PURPOSE.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	The peak or minimum of the Gaussian must be the largest
;	or smallest point in the Y vector.
;
; PROCEDURE:
;	If the (MAX-AVG) of Y is larger than (AVG-MIN) then it is assumed
;	that the line is an emission line, otherwise it is assumed there
;	is an absorbtion line.  The estimated center is the MAX or MIN
;	element.  The height is (MAX-AVG) or (AVG-MIN) respectively.
;	The width is found by searching out from the extrema until
;	a point is found less than the 1/e value.
;
; MODIFICATION HISTORY:
;	DMS, RSI, Dec, 1983.
;-
;
on_error,2                      ;Return to caller if an error occurs
n = n_elements(y)		;# of points.
c = poly_fit(x,y,1,yf)		;fit a straight line.
yd = y-yf			;difference.

ymax=max(yd) & xmax=x(!c) & imax=!c	;x,y and subscript of extrema
ymin=min(yd) & xmin=x(!c) & imin=!c
a=fltarr(6)			;coefficient vector
if abs(ymax) gt abs(ymin) then i0=imax else i0=imin ;emiss or absorp?
i0 = i0 > 1 < (n-2)		;never take edges
dy=yd(i0)			;diff between extreme and mean
del = dy/exp(1.)		;1/e value
i=0
WHILE ((i0+i+1) lt n) and $	;guess at 1/2 width.
	((i0-i) gt 0) and $
	(abs(yd(i0+i)) gt abs(del)) and $
	(abs(yd(i0-i)) gt abs(del)) do i=i+1
a = [yd(i0), x(i0), abs(x(i0)-x(i0+i)), c(0), c(1), 0.] ;estimates
!c=0				;reset cursor for plotting
IF KEYWORD_SET(nterms) THEN BEGIN
  a=a(0:((nterms-1)>2)<5)
ENDIF
IF NOT KEYWORD_SET(w) THEN w=replicate(1.,n)
RETURN,curvefit(x,y,replicate(1.,n),a,sigmaa,function_name = "GAUSS_FUNCT")
END

pro nickwidf1

;common vars1,q
;common vars2,th
common vars0,def
common vars,lab,txt,but,gap
common varsb,base
common vars4,fac1
common vars5,fac2
common vars6,fac3
common vars7,th1
common vars8,th2
common vars9,th3
;common vars10,y,x,e

lab=lonarr(50)
txt=lonarr(50)
but=lonarr(50)
gap=lonarr(50)

;defaults

def='def'

dtb1='4685'
;'4336'
;'4308'
;'3867'
dtb2='4682'
;'4344'
;'4313'
;'3866'
dtb3=''
;'3866'

refl1='4679'
;'4337,4338'
;'4307'
;'3858'
refl2='4680
;'4339,4343'
;'4310,4311'
;'3861'
refl3=''
;'3863'

water='4683'
;def
;'3668'

lamda='1.8,19'

th1=def
th2=def
th3=def

fac1=def
fac2=def
fac3=def

r='19'
bg='25'

norm=0
bgrd=2

fil='nickwitt.out'
path='/users/data/'

base=widget_base(title='TOF Data',uvalue='base',column=5) 

;column 1
gap(10)=widget_label(base,ysize=10,value='')
lab(0)=widget_label(base,value='Run')
lab(1)=widget_label(base,value='set')
gap(0)=widget_label(base,ysize=0,value='')
lab(2)=widget_label(base,value='(1)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(3)=widget_label(base,value='(2)  ',/align_right)
gap(11)=widget_label(base,ysize=11,value='')
lab(4)=widget_label(base,value='(3)  ',/align_right)
gap(23)=widget_label(base,ysize=23,value='')
lab(5)=widget_label(base,value='Water',/align_right)
lab(6)=widget_label(base,value='runs',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
lab(7)=widget_label(base,value='Lamda',/align_right)
lab(8)=widget_label(base,value='range',/align_right)
gap(10)=widget_label(base,ysize=10,value='')
gap(0)=widget_label(base,ysize=0,value='')
lab(9)=widget_label(base,value='Normalise',/align_right)
lab(10)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 2
gap(10)=widget_label(base,ysize=10,value='')
lab(11)=widget_label(base,value='Direct')
lab(12)=widget_label(base,value='runs')
txt(0)=widget_text(base,value=dtb1,xsize=9,/editable,uvalue='int')
txt(1)=widget_text(base,value=dtb2,xsize=9,/editable,uvalue='int')
txt(2)=widget_text(base,value=dtb3,xsize=9,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(3)=widget_text(base,xsize=9,value=water,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(4)=widget_text(base,xsize=9,value=lamda,/editable,uvalue='real')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
but(0)=cw_bgroup(base,['Runtime','Monitor'],set_value=norm,/column,/exclusive,uvalue='norm')
gap(0)=widget_label(base,ysize=0,value='')
lab(11)=widget_label(base,value='Path:',/align_right)
lab(11)=widget_label(base,value='Output file:',/align_right)

;column 3
gap(10)=widget_label(base,ysize=10,value='')
lab(13)=widget_label(base,value='Reflect')
lab(14)=widget_label(base,value='runs')
txt(5)=widget_text(base,value=refl1,xsize=9,/editable,uvalue='int')
txt(6)=widget_text(base,value=refl2,xsize=9,/editable,uvalue='int')
txt(7)=widget_text(base,value=refl3,xsize=9,/editable,uvalue='int')
gap(16)=widget_label(base,ysize=16,value='')
lab(15)=widget_label(base,value='Foregrd',/align_right)
lab(16)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=10,value='')
lab(17)=widget_label(base,value='Backgrd',/align_right)
lab(18)=widget_label(base,value='range',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(20)=widget_label(base,ysize=20,value='')
lab(19)=widget_label(base,value='Use',/align_right)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(8)=widget_text(base,value=path,xsize=9,/editable,uvalue='str')
txt(9)=widget_text(base,value=fil,xsize=9,/editable,uvalue='str')

;column 4
gap(10)=widget_label(base,ysize=10,value='')
lab(20)=widget_label(base,value='Theta')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(10)=widget_text(base,xsize=4,value=th1,/editable,uvalue='real')
txt(11)=widget_text(base,xsize=4,value=th2,/editable,uvalue='real')
txt(12)=widget_text(base,xsize=4,value=th3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(13)=widget_text(base,xsize=4,value=r,/editable,uvalue='int')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(14)=widget_text(base,xsize=4,value=bg,/editable,uvalue='int')
but(1)=cw_bgroup(base,['left','both','fit'],set_value=bgrd,/column,/exclusive,uvalue='bgrd')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')

;column 5
gap(10)=widget_label(base,ysize=10,value='')
lab(21)=widget_label(base,value='Factor')
gap(6)=widget_label(base,value='',ysize=6)
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
txt(15)=widget_text(base,xsize=4,value=fac1,/editable,uvalue='real')
txt(16)=widget_text(base,xsize=4,value=fac2,/editable,uvalue='real')
txt(17)=widget_text(base,xsize=4,value=fac3,/editable,uvalue='real')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(6)=widget_label(base,ysize=6,value='')
gap(0)=widget_label(base,ysize=0,value='')
gap(10)=widget_label(base,ysize=10,value='')
gap(40)=widget_label(base,ysize=40,value='')
gap(40)=widget_label(base,ysize=40,value='')
gap(40)=widget_label(base,ysize=40,value='')
gap(20)=widget_label(base,ysize=20,value='')
gap(20)=widget_label(base,ysize=20,value='')
but(2)=widget_button(base,value='DONE',uvalue='done')

baseinfo=widget_info(base,/geometry)
widget_control,base,scr_xsize=baseinfo.scr_xsize+10
widget_control,base,scr_ysize=baseinfo.scr_ysize+10

widget_control,base,/realize

xmanager,'nickwidf',base

end



function convert,txtwid,defaults,intcheck,commacheck,strcheck,errcheck1,errcheck2

common flags1,flag2,flag3
common flags,flag4,flag5
common vars0,def

valnum=strarr(3)

widget_control,txtwid,get_value=val

valstr=val(0)

valstr=strcompress(valstr,/remove_all)

if (defaults eq 0) and (valstr eq def) then flag5=1
	
if valstr eq def then valnum(0)=1 else $

if (valstr ne def) and (strcheck eq 1) then valnum(1)=valstr else begin

	commapos=strpos(valstr,',')

	if commapos eq -1 then begin

		if commacheck eq 1 then flag4=1
	
		valflt=float(valstr)
		valint=fix(valstr)
	
		if strpos(string(valflt),valstr) eq -1 then flag2=1
		if (intcheck eq 1) and (valint ne valflt) then flag3=1
		if (intcheck eq 1) and (errcheck1 eq 1) then valnum=[0,valint,valint]
		if (intcheck eq 0) and (errcheck1 eq 1) then valnum=[0,valflt,valflt]
		if (intcheck eq 0) and (errcheck1 eq 0) then valnum(1)=valflt
		if (intcheck eq 1) and (errcheck1 eq 0) then valnum(1)=valint

	endif else begin
	
		if commacheck eq 0 then flag2=1

		valstr=['0',strmid(valstr,0,commapos),strmid(valstr,commapos+1)]

		valflt=float(valstr)
		valint=fix(valstr)
	
		if (strpos(string(valflt(1)),valstr(1)) eq -1) or (strpos(string(valflt(2)),valstr(2)) eq -1) then flag2=1
		if (intcheck eq 1) and ((valint(1) ne valflt(1)) or (valint(2) ne valflt(2))) then flag3=1
		if intcheck eq 1 then valnum=valint else valnum=valflt

	endelse

	if errcheck1 eq 1 then begin

		if valnum(1) gt valnum(2) then flag0=1

	endif

	if errcheck2 eq 1 then begin

		if valnum(1) eq 0 then flag1=1

	endif

endelse	

return,valnum

end



function factor,refa,refb,qa,qb,errora,errorb

;sa=size(ra)
;sb=size(rb)

xa=qa(sort(qa))
xb=qb(sort(qb))
ya=refa(sort(qa))
yb=refb(sort(qb))
errora=errora(sort(qa))
errorb=errorb(sort(qb))

;help,xa,ya,erra,xb,yb,errb

;fin=max(xa)
;sta=max(where(xa le min(xb)))

xaovsub=where(xa ge min(xb))

;if 

;help,xaovsub
;print,xaovsub
range=max(xaovsub)-min(xaovsub)

xaov=xa(min(xaovsub):max(xaovsub))

dataa=ya(min(xaovsub):max(xaovsub))
erra=errora(min(xaovsub):max(xaovsub))

datab=fltarr(range)
err2=fltarr(range)
errb=fltarr(range)

numersum=0
denomsum=0

for i=1,range-1 do begin
		
	pntabsub=min(where(xb ge xaov(i)))
	pntab=xb(pntabsub)
	databab=yb(pntabsub)
	errbab=errorb(pntabsub)
	pntbesub=max(where(xb lt xaov(i)))
	pntbe=xb(pntbesub)
	databbe=yb(pntbesub)
	errbbe=errorb(pntbesub)
	
	databdiff=databbe-databab

	datab(i)=(((pntab-xaov(i))/databdiff)*databbe)+(((xaov(i)-pntbe)/databdiff)*databab)
		errb(i)=sqrt((((pntab-xaov(i))/databdiff)*errbbe)^2+(((xaov(i)-pntbe)/databdiff)*errbab)^2)
	
	if pntab-xaov(i) le xaov(i)-pntbe then begin
		datab(i)=yb(pntabsub)
		errb(i)=errorb(pntabsub)
	endif else begin
		datab(i)=yb(pntbesub)
		errb(i)=errorb(pntbesub)
	endelse
	
	if (dataa(i) gt 1.e-11) and (datab(i) gt 1.e-11) and (erra(i) gt 0.) and (errb(i) gt 0.) then err2(i)=(erra(i)+errb(i))*(erra(i)+errb(i)) else err2(i)=1.e20

	numer=(1/err2(i))*dataa(i)*datab(i)

	denom=(1/err2(i))*datab(i)*datab(i)

	numersum=numersum+numer
	denomsum=denomsum+denom

endfor

fac=numersum/denomsum
help,fac
;print,fac
return,fac

end



pro nickwidf_event,event

common vars,lab,txt,but,gap
common varsb,base
;common vars1,q
;common vars2,th
common flags,flag4,flag5
common flags1,flag2,flag3
common vars0,def
;common vars5,th1
common vars4,fac1
common vars5,fac2
common vars6,fac3
common vars7,th1
common vars8,th2
common vars9,th3
common vars10,check0,check1
common varstuff,bgrd
common varbull,norm,bg,r,fil
common varpath,path
common varcrap1,bglim

widget_control,event.id,get_uvalue=ev

if ev eq 'done' then begin

	flag0=0	
	flag1=0	
	flag2=0
	flag3=0
	flag4=0
	flag5=0
	flag6=0

	check0=0
	check1=0
	check2=0

	dtb1=convert(txt(0),0,1,2,0,1,1) 
	
	dtb2=convert(txt(1),0,1,2,0,1,0) 

	dtb3=convert(txt(2),0,1,2,0,1,0) 

	water=convert(txt(3),1,1,2,0,1,0) 

	lamda=convert(txt(4),1,0,2,0,1,1)

	refl1=convert(txt(5),0,1,2,0,1,1) 

	refl2=convert(txt(6),0,1,2,0,1,0)

	refl3=convert(txt(7),0,1,2,0,1,0)

	path=convert(txt(8),0,0,0,1,0,0)

	fil=convert(txt(9),0,0,0,1,0,0)

	th1=convert(txt(10),1,0,0,0,0,0)

	th2=convert(txt(11),1,0,0,0,0,0)

	th3=convert(txt(12),1,0,0,0,0,0)

	r=convert(txt(13),0,1,0,0,0,0)

	bg=convert(txt(14),0,1,0,0,0,0)

	fac1=convert(txt(15),1,0,0,0,0,0)

	fac2=convert(txt(16),1,0,0,0,0,0)

	fac3=convert(txt(17),1,0,0,0,0,0)


	widget_control,but(0),get_value=norm
	widget_control,but(1),get_value=bgrd

	if (dtb2(1) ne 0) or (refl2(1) ne 0) then check0=1
	if (dtb3(1) ne 0) or (refl3(1) ne 0) then check1=1
;	if (check0 eq 1) and ((dtb2(1) eq 0) or (refl2(1) eq 0)) then flag6=1 
;	if (check1 eq 1) and ((dtb3(1) eq 0) or (refl3(1) eq 0) or (check0 eq 1)) then flag6=1 

	if flag0 eq 1 then errormessage,'Invalid ranges'
	if flag1 eq 1 then errormessage,'Incomplete fields'	
	if flag2 eq 1 then errormessage,'Field must be a number'	
	if flag3 eq 1 then errormessage,'Field must be integer'	
	if flag4 eq 1 then errormessage,'Comma expected'	
	if flag5 eq 1 then errormessage,'Default not available'	
	if flag6 eq 1 then errormessage,'Must complete all fields for given run set'	
	if (flag0 eq 0) and (flag1 eq 0) and (flag2 eq 0) and (flag3 eq 0) and (flag4 eq 0) and (flag5 eq 0) and (flag6 eq 0) then begin

		widget_control,base,sensitive=0

;		w3=make_array(3,286,type=4)
		if water(0) eq 1 then begin
			print,'Using default Water file ''water_LAMPascii''...'
			w3=make_array(3,286,type=4)

			close,4
			openr,4,"water_LAMPascii"
     			readf,4,w3
			w2=w3(1,*)
			close,4

		endif else begin
			watersum=0
			for i=water(1),water(2) do begin
				data_read,i,water
				watersum=water+watersum
			endfor
			awater,watersum,w2
;			w2=fltarr(3,286)
;			w2(1,*)=w3
		endelse
				
		db1sum=0
		db1monsum=0
		db1timesum=0

		for i=dtb1(1),dtb1(2) do begin
			data_read,i,db1,db1mon,db1time,dbdan1
                	db1sum=db1+db1sum
                	db1monsum=db1mon+db1monsum
                        db1timesum=db1time+db1timesum
                endfor
		erdb1=sqrt(db1sum)
		
		ref1sum=0
		ref1monsum=0
		ref1timesum=0
		for i=refl1(1),refl1(2) do begin
			data_read,i,ref1,ref1mon,ref1time,refdan1
			ref1sum=ref1+ref1sum
			ref1monsum=ref1mon+ref1monsum
			ref1timesum=ref1time+ref1timesum
		endfor
		erref1=sqrt(ref1sum)

		if norm eq 0 then begin
			normref1sum=ref1sum*(db1timesum/ref1timesum)
			normerref1sum=(db1timesum/ref1timesum)*erref1
		endif
;		if norm eq 1 then begin
;			normref1sum=ref1sum*(db1monsum/ref1monsum)
;			normerref1sum=(db1monsum/ref1monsum)*erref1
;		endif
		if norm eq 1 then begin 
			normref1sum=ref1sum/ref1monsum
			db1sum=db1sum/db1monsum
		endif

		if fac1(0) eq 1 then fac1(1)=1.
;print,'fac1',fac1(1)
help,w2	
	anal,db1sum,erdb1,dbdan1,normref1sum,normerref1sum,refdan1,w2,r(1),bg(1),w5,x5,e5,qe5,lamda,th1	
print,bg(1)	
;print,e5,w5

		w5=fac1(1)*w5
		e5=fac1(1)*e5

		z5=size(e5)

		xs=x5(sort(x5))
		ws=w5(sort(x5))
		es=e5(sort(x5))
		qes=qe5(sort(x5))

		if check0 eq 1 then begin
				
			db2sum=0
			db2monsum=0
			db2timesum=0
			for i=dtb2(1),dtb2(2) do begin
				data_read,i,db2,db2mon,db2time,dbdan2
     		           	db2sum=db2+db2sum
   		            	db2monsum=db2mon+db2monsum
      	                	db2timesum=db2time+db2timesum
                	endfor
			erdb2=sqrt(db2sum)

			ref2sum=0
			ref2monsum=0
			ref2timesum=0
			for i=refl2(1),refl2(2) do begin
				data_read,i,ref2,ref2mon,ref2time,refdan2
				ref2sum=ref2+ref2sum
				ref2monsum=ref2mon+ref2monsum
				ref2timesum=ref2time+ref2timesum
			endfor
			erref2=sqrt(ref2sum)

			if norm eq 0 then begin
				normref2sum=ref2sum*(db2timesum/ref2timesum)
				normerref2sum=(db2timesum/ref2timesum)*erref2
			endif
			if norm eq 1 then begin
				normref2sum=ref2sum*(db2monsum/ref2monsum)
				normerref2sum=(db2monsum/ref2monsum)*erref2
			endif	
;			if norm eq 1 then begin 
;				normref2sum=ref2sum/ref2monsum
;				db2sum=db2sum/db2monsum
;			endif

			anal,db2sum,erdb2,dbdan2,normref2sum,normerref2sum,refdan2,w2,r(1),bg(1),w6,x6,e6,qe6,lamda,th2
			if fac2(0) eq 1 then fac2(1)=factor(w5,w6,x5,x6,e5,e6)
			if fac2(1) eq 0. then print,'No Overlap'
				
;print,fac2(1)

			w6=fac2(1)*w6
			e6=fac2(1)*e6
			;print,e6*fac2(1),w6*fac2(1)			
			z6=size(e6)

			x=fltarr(z5(1)+z6(1))
			w=fltarr(z5(1)+z6(1))
			e=fltarr(z5(1)+z6(1))
			qe=fltarr(z5(1)+z6(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			
			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))
			
		endif
			
		if (check0 eq 1) and (check1 eq 1) then begin

			db3sum=0
			db3monsum=0
			db3timesum=0
			for i=dtb3(1),dtb3(2) do begin
				data_read,i,db3,db3mon,db3time,dbdan3
     		           	db3sum=db3+db3sum
    		            	db3monsum=db3mon+db3monsum
      	                	db3timesum=db3time+db3timesum
                	endfor
			erdb3=sqrt(db3sum)

			ref3sum=0
			ref3monsum=0
			ref3timesum=0
			for i=refl3(1),refl3(2) do begin
				data_read,i,ref3,ref3mon,ref3time,refdan3
				ref3sum=ref3+ref3sum
				ref3monsum=ref3mon+ref3monsum
				ref3timesum=ref3time+ref3timesum
			endfor
			erref3=sqrt(ref3sum)

			if norm eq 0 then begin
				normref3sum=ref3sum*(db3timesum/ref3timesum)
				normerref3sum=(db3timesum/ref3timesum)*erref3
			endif
			if norm eq 1 then begin
				normref3sum=ref3sum*(db3monsum/ref3monsum)
				normerref3sum=(db3monsum/ref3monsum)*erref3
			endif
;			if norm eq 1 then begin 
;				normref3sum=ref3sum/ref3monsum
;				db3sum=db3sum/db3monsum
;			endif
			anal,db3sum,erdb3,dbdan3,normref3sum,normerref3sum,refdan3,w2,r(1),bg(1),w7,x7,e7,qe7,lamda,th3
			if fac3(0) eq 1 then fac3(1)=factor(w6,w7,x6,x7,e6,e7)
			if fac3(1) eq 0. then print,'No Overlap'
;print,fac3(1)

			w7=fac3(1)*w7
			e7=fac3(1)*e7
;print,e7*fac2(1),w7*fac2(1)

			z7=size(e7)

;print,fac2

			x=fltarr(z5(1)+z6(1)+z7(1))
			w=fltarr(z5(1)+z6(1)+z7(1))
			e=fltarr(z5(1)+z6(1)+z7(1))
			qe=fltarr(z5(1)+z6(1)+z7(1))
			for i=0,z5(1)-1 do begin
				x(i)=x5(i)
				w(i)=w5(i)
				e(i)=e5(i)
				qe(i)=qe5(i)
			endfor
			for i=z5(1),z5(1)+z6(1)-1 do begin
				x(i)=x6(i-z5(1))
				w(i)=w6(i-z5(1))
				e(i)=e6(i-z5(1))
				qe(i)=qe6(i-z5(1))
			endfor
			for i=(z5(1)+z6(1)),(z5(1)+z6(1)+z7(1)-1) do begin
				x(i)=x7(i-z5(1)-z6(1))
				w(i)=w7(i-z5(1)-z6(1))
				e(i)=e7(i-z5(1)-z6(1))
				qe(i)=qe7(i-z5(1)-z6(1))
			endfor
;e((z5(1)+z6(1)):(z5(1)+z6(1)+z7(1)-1))=0
;w((z5(1)+z6(1)):(z5(1)+z6(1)+z7(1)-1))=1e-11
;reverse(e((z5(1)+z6(1)):(z5(1)+z6(1)+z7(1)-1)))		

			xs=x(sort(x))
			ws=w(sort(x))
			es=e(sort(x))
			qes=qe(sort(x))

		endif
;for i=0,z5(1)-1 do print,x5(i),w5(i),e5(i),i
;for i=0,z6(1)-1 do print,x6(i),w6(i),e6(i),i
;for i=0,z7(1)-1 do print,x7(i),w7(i)*fac2(1)*fac3(1),e7(i)*fac2(1)*fac3(1),i

;		print,xs,ws,es		
		
;		print,x5,w5		

;print,w6
;print,w(z5(1):z5(1)+z6(1))

;print,'this is size',points(1)

;y=alog10(ws)
;e1=es/(ws*alog(10.))
;for i=0,points(1)-1 do begin
;	if e(i) gt 10 then e(i)=10
;endfor
;plot,alog10(x),y,yrange=[-12,1],psym=4

;ploterr,alog10(xs),y,e1
;yrange=[-12,1],psym=4
;print,y,e1

		ec=es(where(es))
		qec=qes(where(es))
		xc=xs(where(es))
		wc=ws(where(es))
		
if water(0) eq 1 then water(1)='water_LAMPascii'
if bglim eq 1 then bg(1)='limited'

		close,10
		openw,10,fil(1)
		printf,10,' db1:',dtb1(1),dtb1(2),' ref1:',refl1(1),refl1(2),' th1:',th1(1),' fac1:',fac1(1)
		printf,10,' db2:',dtb2(1),dtb2(2),' ref2:',refl2(1),refl2(2),' th2:',th2(1),' fac2:',fac2(1)
		printf,10,' db3:',dtb3(1),dtb3(2),' ref3:',refl3(1),refl3(2),' th3:',th3(1),' fac3:',fac3(1)
		printf,10,' water:',water(1),' lamda:',lamda(1),lamda(2),' fgrd:',r(1),' bgrd:',bg(1)
		close,10

		output,xc,wc,ec,qec,fil(1)
;print,'HERE IS bg',bg(1)


;print,alog10(xc),alog10(wc),e1





;		ploterr,xs,ws,es
;,xtitle='q',ytitle='log(Ref)'
;		oploterr,x6,w6,e6
;		oploterr,x7,w7,e7
;		plot,w2


		endmessage

	endif		

endif

return
end





pro data_read,num,w1,w2,runtime,dan

common varshit,tofd,opena,period,lamarr
common varshit2,nx,dett
common vars0,def
common varcrap,par2
common varpath,path

close,3

par1 = fltarr(128)
par2 = fltarr(256)
txt=sindgen(34)
txt(*)='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
txt1=txt(1)
name=path(1)+'00'+string(strtrim(num,2))

filcheck=findfile(name,count=checkfil)
if checkfil eq 0 then errormessage,'File not found: '+name

print,' '
print,' '
print,'opening... ',name
openr,3,name
print,'opened: ',name
readf,3,txt
print,txt(4)
print,txt(25)
readf,3,par1
readf,3,txt1
readf,3,txt1
readf,3,par2
dpr=180./!pi
print,'no of chans= ',par1(94),' chan width= ',par1(95),' tof delay= ',par1(96)
print,'x1= ',par1(97),' x2= ',par1(98),' y1= ',par1(99),' y2= ',par1(100)
nx=par1(101)
print,'nx= ',par1(101),' ny= ',par1(102)
print,'chop 1 speed req= ',par2(40),' chop 1 phase req= ',par2(41)
print,'chop 2 speed req= ',par2(42),' chop 2 phase req= ',par2(43)
print,'chop 1 speed act= ',par2(44),' chop 1 phase act= ',par2(45)
print,'chop 2 speed act= ',par2(46),' chop 2 phase act= ',par2(47)

; useful chopper variables
openr=45.-(par2(43)-par2(41))
opena=45.-(par2(47)-par2(45))

;! chopper opening offset =1.1!!!!

opena=opena-1.1

period=60./par2(44)
dela=(285.-3.3776-opena)/2.
delt=(dela/360.)*period
cht=85.e-3
chopsam=4.1138-(cht)/2.
chopmon=.455
tofd=chopsam+(par2(15)/1000.)
chanpa=(tofd/3956.)/(par1(95)*1.e-6)
chanpam=(chopmon/3956.)/(par1(95)*1.e-6)
r=chopsam/tofd
delchan=delt/(par1(95)*1e-6)
delechan=par1(96)/par1(95)
print,'TOF distance    = ',tofd, ' period chans    =',period/(par1(95)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
;print,'     san= ',par2(2),' deg.'
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa
runtime=par1(2)/10.
print,'run time= ',runtime,' s',' det= ',par2(15),'dan = ',par2(16)
dan=par2(16)
dett=par2(15)
readf,3,txt1
readf,3,txt1
readf,3,txt1
readf,3,tot
tsize=long(par1(94))
xsize=long(par1(98)-par1(97)+1)
ysize=long(par1(100)-par1(99)+1)
dsize=xsize*ysize
if (tot ne (dsize*tsize+tsize)) then print,' Error in data array dimensions'
print,'tsize= ',tsize,' detector size= ',dsize
print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',dsize*tsize,' tot2= ',tot

det=lonarr(ysize,xsize,tsize)
if (ysize eq 1) then det=lonarr(xsize,tsize)

;det=lonarr(286,276)
mon=lonarr(tsize)
xy=lonarr(xsize,ysize)
xt=lonarr(xsize,tsize)
yt=lonarr(ysize,tsize)

c=1
readf,3,det,mon

;print,'mon= ',mon

nx=par1(101)

mmpp=1.04*nx

;useful area of det in mm
xminp=37
xmaxp=238

xminmm=xminp*mmpp
xmaxmm=xmaxp*mmpp


dpr=180./!pi

;help,th
;print,th
;if th(0) eq 1 then th(1)=par2(2)

;make lamda array
yy=findgen(tsize)
lamarr=(yy+delechan-delchan+0.5)/chanpa
	
;q=4*!pi*sin(th(1)/dpr)/lamarr

;m=(yy+delechan-delchan)/chanpam

w1=det
w2=mon

;print,w2
;print,y
;w4=total(w1,3)
;w3=total(w1,2)
;plot,mon

;make 2th array

;p0=135.79/nx

;mmpp=1.04*nx
;th=fltarr(xsize)


;for i=0,xsize-1 do th(i)=dan+dpr*atan(((p0-i)*mmpp)/dett)


;q=4*!pi*sin(th/dpr)/y


close,3
print,'total counts in detector = ',total(w1),' (',total(w1)/runtime,')'
;print,'total counts in monitor = ',total(w2),' (',total(w2)/runtime,')'
return

end


pro awater,w1,w2
w1=w1
xsize=286
;ysize=275
w2=fltarr(xsize)
;w3=fltarr(ysize) & w4=fltarr(xsize,ysize)

;useful area 37:238,30:248
x1=37 & x2= 238
;y1=30 & y2=248
help,w1
w2=total(w1,2)
;help,w2
;w3=total(w1,1)

w2=w2/(mean(w2(x1:x2)))
;w3=w3/(mean(w3(x1:x2)))
;w4=w1/mean(w1(x1:x2,y1:y2))
;w4(0:x1-1,*)=1 & w4(x2+1:xsize-1,*)=1 & w4(*,0:y1-1)=1 & w4(*,y2+1:ysize-1)=1 
w2(0:x1-1)=1 & w2(x2+1:xsize-1)=1
;w3(0:y1-1)=1 & w3(y2+1:ysize-1)=1

;print,!stime
return
end

function tth,d0,p0,dr,pr,nx,det
;TAKE_DATP,p
dpr=180./!pi

pcen=135.79/nx
mmpp=1.04*nx

print,'pcen= ',pcen,' mmpp= ',mmpp
th=(dr+dpr*atan((pcen-pr)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
print,'ref th= ',th
  
return,th
end



pro anal,db,dber,dbdan,ref,refer,refdan,water,r,bg,wdum,xdum,edum,qedum,lamda,th
help,water
help,db
wdum=0
xdum=0
edum=0
qedum=0

!except=0

common varshit,tofd,opena,period,lamarr
common varshit2,nx,dett
common vars0,def
common varcrap,par2
common varstuff,bgrd
common varcrap1,bglim

;pro anal,db,ref,fac,water,q,r,bg,w5,x5,e5,chop
;help,db,ref,water


; db is the direct beam run
; ref is the reflection run
; water is the x effiency of the detector
; q is the array of q(A^-1)
; r is the range over which to sum the intensity
; bg is the range to sum the background either side of r
; w5 is the output reflectivity with the q (x5) and error (e4)
; fac is the normalisation factor for w2 reflection data ie
; divide the ref data by this to make it normalised to the direct beam

chop=0
ref1=ref
ref2=ref
db1=db
db2=db
edb=db
ere=ref
detmax=238
detmin=37

z=size(db)
print,'db size: ',z(2)

;water correction
for i=0,z(2)-1 do begin
  db1(*,i)=db(*,i)/water
  dber(*,i)=dber(*,i)/water
  ref1(*,i)=ref(*,i)/water
  refer(*,i)=refer(*,i)/water
endfor

print,'done water correction'
;print,water
;print,db1(f1-bg:f1-1,i)

dbtot=total(db,2)
dbtotm=max(total(db,2),dbm)

f1=dbm-(r-1)/2
f2=dbm+(r-1)/2

;COM for db
numersum=0
denomsum=0
for i=f1,f2 do begin
  numer=dbtot(i)*i
  denom=dbtot(i)
  numersum=numer+numersum
  denomsum=denom+denomsum
endfor

dbcom=numersum/denomsum

;print,fix(dbcom),dbm
if fix(dbcom) ne dbm then dbm=fix(dbcom)

f1=dbm-(r-1)/2
f2=dbm+(r-1)/2

print,'db peak at: ',fix(dbcom)

if (f1-bg lt detmin) or (f2+bg gt detmax) then begin
  if f1-detmin le detmax-f2 then bg=f1-detmin else bg=detmax-f2
  print,'Outside useful area of detector, bg has been limited to ',bg
  bglim=1
endif else bglim=0

reftot=total(ref(*,40:z(2)-1),2)
reftotm=max(reftot,refm)

ff1=refm-(r-1)/2
ff2=refm+(r-1)/2

;COM for ref
numersum=0
denomsum=0
for i=ff1,ff2 do begin
  numer=reftot(i)*i
  denom=reftot(i)
  numersum=numer+numersum
  denomsum=denom+denomsum
endfor

refcom=numersum/denomsum

;if fix(refcom) ne refm then refm=fix(refcom)

ff1=refm-(r-1)/2
ff2=refm+(r-1)/2
  
;print,fix(refcom),refm
print,'ref peak at: ',fix(refcom)

if (ff1-bg lt detmin) or (ff2+bg gt detmax) then begin
  if ff1-detmin le detmax-ff2 then bg=ff1-detmin else bg=detmax-ff2
  print,'Outside useful area of detector, bg has been limited to ',bg
  bglim=1
endif else bglim=0



subarr=indgen(z(1))
dbb=fltarr(z(1),z(2))
rb=fltarr(z(1),z(2))
ed=fltarr(z(1),z(2))
eb=fltarr(z(1),z(2))
er=fltarr(z(1),z(2))

if bg gt 0 then begin


if bgrd eq 0 then begin

  for i=0,z(2)-1 do begin

    db2(*,i)=db1(*,i)-mean(db1(f1-bg:f1-1,i))
    ref2(*,i)=ref1(*,i)-mean(ref1(ff1-bg:ff1-1,i))

    dbb(*,i)=(sqrt(total(dber(f1-bg:f1-1,i)^2,1)))/bg
    rb(*,i)=(sqrt(total(refer(ff1-bg:ff1-1,i)^2,1)))/bg

    ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)
    er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

   endfor
      
endif


if bgrd eq 1 then begin

  for i=0,z(2)-1 do begin

    db2(*,i)=db1(*,i)-(mean(db1(f1-bg:f1-1,i))+mean(db1(f2+1:f2+bg,i)))/2
    ref2(*,i)=ref1(*,i)-(mean(ref1(ff1-bg:ff1-1,i))+mean(ref1(ff2+1:ff2+bg,i)))/2

    dbb(*,i)=(sqrt(total(dber(f1-bg:f1-1,i)^2,1)+total(dber(f2+1:f2+bg,i)^2,1)))/(2.*bg)
    rb(*,i)=(sqrt(total(refer(ff1-bg:ff1-1,i)^2,1)+total(refer(ff2+1:ff2+bg,i)^2,1)))/(2.*bg)

    ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)
    er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

  endfor

endif


if bgrd eq 2 then begin

;subtract backgrd from db
for i=0,z(2)-1 do begin

dbbgsubarr=intarr(2*bg)
dbbgarr=fltarr(2*bg,z(2))
dbbgfit=fltarr(z(1),z(2))

dbbgsubarr(0:bg-1)=subarr(f1-bg:f1-1) 
dbbgsubarr(bg:2*bg-1)=subarr(f2+1:f2+bg) 

dbbgarr(0:bg-1,i)=db1(f1-bg:f1-1,i)
dbbgarr(bg:2*bg-1,i)=db1(f2+1:f2+bg,i)

;print,dbbgsubarr
;print,dbbgarr
;print,db1(f1-bg:f1-1,i)

err=fltarr(2*bg)
for j=0,2*bg-1 do if sqrt(dbbgarr(j,i)) eq 0 then err(j)=1. else err(j)=sqrt(dbbgarr(j,i)+1)

dbbgcoeff=linfit(dbbgsubarr,dbbgarr(*,i),sdev=err,chisq=dbchisq,sigma=dbbgerr,/double)
;print,'dbchi',dbchisq
;print,dbbgsubarr,dbbgarr(*,i),err,dbchisq,dbchisq/(2*bg)

;print,'gothere'
;if dbchisq ne 1 then begin
;dbbgcoeff=linfit(dbbgsubarr(0:bg-1),dbbgarr(0:bg-1,i),sdev=err(0:bg-1),chisq=dbchisq,sigma=dbbgerr)
;endif
;print,'gothere'
;print,dbbgsubarr(0:bg-1),dbbgarr(0:bg-1,i),err(0:bg-1),dbchisq,dbchisq/(bg)

dbbgfit(*,i)=dbbgcoeff(0)+dbbgcoeff(1)*subarr

db2(*,i)=db1(*,i)-dbbgfit(*,i)

dbb(*,i)=sqrt((subarr*dbbgerr(1))^2+dbbgerr(0)^2)

ed(*,i)=sqrt(dber(*,i)^2+dbb(*,i)^2)

print,'dbfiterr',i,dbbgerr

endfor

;subtract backgrd from ref
for i=0,z(2)-1 do begin

refbgsubarr=intarr(2*bg)
refbgarr=fltarr(2*bg,z(2))
refbgfit=fltarr(z(1),z(2))

refbgsubarr(0:bg-1)=subarr(ff1-bg:ff1-1) 
refbgsubarr(bg:2*bg-1)=subarr(ff2+1:ff2+bg) 

refbgarr(0:bg-1,i)=ref1(ff1-bg:ff1-1,i)
refbgarr(bg:2*bg-1,i)=ref1(ff2+1:ff2+bg,i)

err=fltarr(2*bg)
for j=0,2*bg-1 do if sqrt(refbgarr(j,i)) eq 0 then err(j)=1. else err(j)=sqrt(refbgarr(j,i)+1)

refbgcoeff=linfit(refbgsubarr,refbgarr(*,i),sdev=err,chisq=refchisq,sigma=refbgerr,/double)
;print,'refchi',refchisq

;if refchisq ne 1 then begin
;refbgcoeff=linfit(refbgsubarr(0:bg-1),refbgarr(0:bg-1,i),sdev=err(0:bg-1),chisq=refchisq,sigma=refbgerr)
;endif

refbgfit(*,i)=refbgcoeff(0)+refbgcoeff(1)*subarr

ref2(*,i)=ref1(*,i)-refbgfit(*,i)

rb(*,i)=sqrt((subarr*refbgerr(1))^2+refbgerr(0)^2)

er(*,i)=sqrt(refer(*,i)^2+rb(*,i)^2)

print,'reffiterr',i,refbgerr

endfor

endif

endif else begin
 
  ref2=ref1
  db2=db1
  ed=dber
  er=refer

endelse

r=total(ref2(ff1:ff2,*),1)
d=total(db2(f1:f2,*),1)

print,'done background correction',f1-bg,f1-1,f1,f2,f2+1,f2+bg

;error calculation

ed=sqrt(total(ed(f1:f2,*)^2,1))

er=sqrt(total(er(ff1:ff2,*)^2,1))

;help,r & help,d & help,er & help,ed

reff=r
ereff=r

dpr=180./!pi

if th(0) eq 1 then th(1)=tth(dbdan,dbcom,refdan,refcom,nx,dett)
;if th(0) eq 1 then th(1)=par2(2)

q=4*!pi*sin(th(1)/dpr)/lamarr

for i=0,z(2)-1 do begin
  if ((r(i) gt 0.) and (d(i) gt 0.)) then begin
    reff(i)=r(i)/d(i)
    ereff(i)=reff(i)*sqrt((er(i)/r(i))^2+(ed(i)/d(i))^2) 
    print,' good point',i,ereff(i)/(reff(i)*alog(10.)),alog10(reff(i)),alog10(q(i))
  endif else begin
    ereff(i)=0
    reff(i)=1e-11
    print,'bum point',i,ereff(i),reff(i),q(i)  
  endelse
endfor

;resolution (error in q)
etf=((85e-3)/tofd)+(3956*opena*period)/(360*tofd*lamarr)

if par2(50) ge par2(54) then bigslit=par2(50) else bigslit=par2(54)
ethf=(bigslit*180)/(th(1)*3.4*!pi)

print,'slits',par2(54),par2(50)

qe=q*sqrt(etf^2+ethf^2)


; unlogged data for reflectivity is in reff, q is q and error is ereff
if lamda(0) eq 1 then begin

	qmin=(min(q))
	qmax=(max(q))

endif else begin

	dpr=180./!pi

	qmin=4*!pi*sin(th(1)/dpr)/lamda(2)
	qmax=4*!pi*sin(th(1)/dpr)/lamda(1)

endelse


b=where((q ge qmin) and (q le qmax))
;print,b,q(min(b)),q(max(b))

wdum=reverse(reff(min(b):max(b)))
xdum=reverse(q(min(b):max(b)))
edum=reverse(ereff(min(b):max(b)))
qedum=reverse(qe(min(b):max(b)))
;print,wdum,xdum,edum

print,bg
return
end











pro output,x,y,e,xe,fil

common varsb,base
;common vars10,y,x,e
points=size(x)

close,10
openw,10,fil,/append
for i=0,points(1)-1 do begin
	printf,10,x(i),y(i),e(i),xe(i)
endfor
close,10

plotbase=widget_base(group_leader=base,/floating,title='Reflectivity Plot',/column)
graph=widget_draw(plotbase,xsize=700,ysize=500,retain=2)
but=widget_button(plotbase,value='OK',uvalue='ok')

widget_control,plotbase,/realize

;wset,graph

ploterr,x,alog10(y),e/(y*alog(10.))

xmanager,'message',plotbase

return
end


pro endmessage

common varsb,base
common vars4,fac1
common vars5,fac2
common vars6,fac3
common vars7,th1
common vars8,th2
common vars9,th3
common vars10,check0,check1
common vars,lab,txt,but,gap
common varbull,norm,bg,r,fil
common varstuff,bgrd

res=intarr(20)

if norm eq 0 then nrm='runtime' else nrm='monitor'
if bgrd eq 0 then bgd='left'
if bgrd eq 1 then bgd='both'
if bgrd eq 2 then bgd='fit'

endbase=widget_base(group_leader=base,/floating,title='Finished',column=2)

;column1
res(0)=widget_label(endbase,value='fac1: '+strcompress(string(fac1(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac2: '+strcompress(string(fac2(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='fac3: '+strcompress(string(fac3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Normalised: '+nrm,/align_left)
res(2)=widget_label(endbase,value='Backgrd used: '+bgd,/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Saved to: '''+strcompress(string(fil(1)),/remove_all)+'''',/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Go again?')
gap(0)=widget_label(endbase,value='',ysize=0)

;column2
res(1)=widget_label(endbase,value='th1: '+strcompress(string(th1(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th2: '+strcompress(string(th2(1)),/remove_all),/align_left)
res(1)=widget_label(endbase,value='th3: '+strcompress(string(th3(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
res(2)=widget_label(endbase,value='Backgrd: '+strcompress(string(bg(1)),/remove_all),/align_left)
res(2)=widget_label(endbase,value='Foregrd: '+strcompress(string(r(1)),/remove_all),/align_left)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
gap(0)=widget_label(endbase,value='',ysize=0)
endbut1=widget_button(endbase,value='Yes',uvalue='yes')
endbut2=widget_button(endbase,value='No',uvalue='no')

widget_control,endbase,/realize

xmanager,'message',endbase

return
end


pro errormessage,mes1,mes2,mes3

common varsb,base

errbase=widget_base(group_leader=base,/floating,title='Error Message',/column)
mess1=widget_label(errbase,value=mes1)
;mess2=widget_label(errbase,value=mes2)
;mess3=widget_label(errbase,value=mes3)
errbut=widget_button(errbase,value='OK',uvalue='ok')

widget_control,errbase,/realize

xmanager,'message',errbase

return
end

pro message_event,event

common varsb,base
common vars4,fac1
common vars5,fac2
common vars6,fac3
common vars7,th1
common vars8,th2
common vars9,th3
common vars10,check0,check1
common vars,lab,txt,but,gap

widget_control,event.id,get_uvalue=ev,get_value=val

widget_control,event.top,/destroy

if ev eq 'yes' then begin

	widget_control,base,sensitive=1
	;widget_control,txt(14),set_value=strcompress(string(fac1(1)),/remove_all)
;	widget_control,txt(9),set_value=strcompress(string(th1(1)),/remove_all)
;	if check0 eq 1 then begin
;		;widget_control,txt(15),set_value=strcompress(string(fac2(1)),/remove_all)
;		;widget_control,txt(10),set_value=strcompress(string(th2(1)),/remove_all)
;	endif
;	if (check0 eq 1) and (check1 eq 1) then begin
;		;widget_control,txt(16),set_value=strcompress(string(fac3(1)),/remove_all)
;		;widget_control,txt(11),set_value=strcompress(string(th3(1)),/remove_all)
;	endif

endif	

if ev eq 'no' then widget_control,base,/destroy

if ev eq 'ok' then widget_control,base,sensitive=1
	
return
end


pro nickwid_event,event

widget_control,event.id,get_uvalue=ev,get_value=val

case ev of
	int: if int  	
	
	
endcase
;if ev= then begin
;	data=widget_base(title='Data entered')
;	ok=widget_button(data,value='OK')
;	widget_control,data,/realise
;	;widget_control,ev.top,/destroy
;endif	
end





pro nickwid

;common var,int,real

int=intarr(20)
real=fltarr(20)


;defaults
fac1='fac1'
fac2='fac2'
fac3='fac3'
r='r'
bg='bg'

base=widget_base(title='Data for Analysis',uval='base')

dbl1=widget_label(base,value='Direct beam run nos',xoffset=0,yoffset=5,uval='dbl')
int(1)=widget_text(base,xsize=4,xoffset=200,yoffset=0,/editable)
to=widget_label(base,value='to',xoffset=270,yoffset=5,uval='')
int(2)=widget_text(base,xsize=4,xoffset=300,yoffset=0,/editable)

ref1l1=widget_label(base,value='Reflection run nos (1)',xoffset=0,yoffset=95,uval='')
int(3)=widget_text(base,xsize=4,xoffset=200,yoffset=90,/editable)
to=widget_label(base,value='to',xoffset=270,yoffset=95,uval='')
int(4)=widget_text(base,xsize=4,xoffset=300,yoffset=90,/editable)

ref2l1=widget_label(base,value='Reflection run nos (2)',xoffset=0,yoffset=135,uval='')
int(5)=widget_text(base,xsize=4,xoffset=200,yoffset=130,/editable)
to=widget_label(base,value='to',xoffset=270,yoffset=135,uval='')
int(6)=widget_text(base,xsize=4,xoffset=300,yoffset=130,/editable)

ref3l1=widget_label(base,value='Reflection run nos (3)',xoffset=0,yoffset=175,uval='')
int(7)=widget_text(base,xsize=4,xoffset=200,yoffset=170,/editable)
to=widget_label(base,value='to',xoffset=270,yoffset=175,uval='')
int(8)=widget_text(base,xsize=4,xoffset=300,yoffset=170,/editable)

facl1=widget_label(base,value='Normalisation',xoffset=400,yoffset=45)
facl2=widget_label(base,value='factor',xoffset=430,yoffset=65)

real(1)=widget_text(base,xsize=2,value=fac1,xoffset=440,yoffset=90,/editable)

real(2)=widget_text(base,xsize=2,value=fac2,xoffset=440,yoffset=130,/editable)

real(3)=widget_text(base,xsize=2,value=fac3,xoffset=440,yoffset=170,/editable)

waterl1=widget_label(base,value='Water run nos',xoffset=0,yoffset=265,uval='')
int(9)=widget_text(base,xsize=4,xoffset=200,yoffset=260,/editable)
to=widget_label(base,value='to',xoffset=270,yoffset=265,uval='')
int(10)=widget_text(base,xsize=4,xoffset=300,yoffset=260,/editable)

lamdal1=widget_label(base,value='Useful wavelength',xoffset=0,yoffset=345,uval='')
lamdal2=widget_label(base,value='range (Angstroms)',xoffset=0,yoffset=365,uval='')
real(4)=widget_text(base,xsize=4,xoffset=200,yoffset=350,/editable)
to=widget_label(base,value='to',xoffset=270,yoffset=355,uval='')
real(5)=widget_text(base,xsize=4,xoffset=300,yoffset=350,/editable)

rl1=widget_label(base,value='Foreground range',xoffset=0,yoffset=435,uval='')
rl1=widget_label(base,value='(pixels)',xoffset=40,yoffset=455,uval='')
int(11)=widget_text(base,xsize=4,value=r,xoffset=160,yoffset=440,/editable)

bgl1=widget_label(base,value='Backgroung range',xoffset=270,yoffset=435,uval='')
bgl1=widget_label(base,value='(pixels)',xoffset=310,yoffset=455,uval='')
int(12)=widget_text(base,xsize=4,value=bg,xoffset=430,yoffset=440,/editable)

done=widget_button(base,value='DONE',xoffset=470,yoffset=0)

widget_control,base,/realize

xmanager,'nickwid',base

end
;-------------------------------------------------------------------------------
; The NeXus - API in IDL
;
; This is a reimplementation of the NeXus API routines in the IDL language.
; For details about the functions defined herein and about NeXus see the
; NeXus WWW-pages.
; 
; copyright: you may do everything withs this code, but one thing:
; 
; you may not sue me or my employer if it does not work or gives invalid
; results. You are at you own. This is why you have the source. 
; In other terms: Absolutely no Warranties are given.
;
; version 1.0
; 
; Initial coding:  Mark Koennecke, August 1998
;                  Laboratory for Neutron Scattering
;                  Paul Scherrer Institute
;                  CH-5232 Villigen-PSI
;                  Switzerland
;                  Mark.Koennecke@psi.ch
;-------------------------------------------------------------------------------- 
; WARNING: IDL-possible-bug: Do not change the calls to hdf_sd_attrinfo. I call
; it often with too many keywords, requesting information not needed. But I
; noticed, that hdf_sd_attrinfo would kill IDL when called with different sets
; of keywords. My recommendation: leave it alone! M.K., August 1998  
;
;-------------------------- NXprintError --------------------------------------
; hack Nxprinterror if you want errors printed somewhere else and not onto the
; IDL prompt. You may choose to pop message boxes instead.
PRO NXprinterror, txt
     Print, txt
END
;----------------------- NXopen ------------------------------------------------
FUNCTION NXopen, filename, access, handle
;
   if N_PARAMS() LT 3 THEN BEGIN
       NXprinterror, 'Insufficient number of arguments to NXopen'
   END      
;
;  the NeXus data structure
   handle = {NXstruct, NXID: 110898, Acess: ' ', iVID:LONG(0), $
            iSID:LONG(0) , iCurrentVG: LONG(0), $
              iCurrentSDS:LONG(0), iVREF:LONARR(10), iStackPtr:0}
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
; open file, depending on access code
   if access EQ 'read' then begin
      handle.iVID = hdf_open(filename,/read)
      handle.Acess = 'read'
      handle.iSID = hdf_sd_start(filename,/read)
    end
 ;
   IF access EQ 'write' THEN BEGIN
      handle.iVID = hdf_open(filename,/write)
      handle.iSID = hdf_sd_start(filename,/RDWR)
      handle.Acess = 'write'
   END
;  
   IF access EQ 'create' THEN BEGIN
       handle.iSID = hdf_sd_start(filename,/create)
       handle.iVID = hdf_open(filename,/write)
       handle.Acess = 'write'
       hdf_sd_attrset,handle.iSID, 'file_name',filename
;----- fix me, time is not in NeXus standard format
       tim = systime()
       hdf_sd_attrset, handle.iSID, 'file_time',tim
   END
   IF (handle.iVID EQ 0) OR (handle.iSID EQ 0) THEN BEGIN
       NXprinterror, 'ERROR: failed to open HDF file'
       return, 0
   END
    return, 1
END
;------------------------- NXcheck -------------------------------------------
FUNCTION NXcheck, handle
     IF N_PARAMS() LT 1 THEN BEGIN
        NXprinterror, 'ERROR: Internal, insufficient number of arguments to NXcheck'
        return, 0
      END
      IF handle.NXID  NE  110898 THEN BEGIN
         NXprinterror, 'ERROR: invalid NeXus file handle'
         return, 0
      END
      return, 1     
END
;------------------------ NXclose----------------------------------------------
FUNCTION NXclose, handle 
;
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;-------- close open vGroups
   IF handle.iCurrentVG NE 0 THEN BEGIN
         hdf_vg_detach, handle.iCurrentVG
   END
;-------- close open SDS
   IF handle.iCurrentSDS NE 0 THEN BEGIN
         hdf_sd_endaccess, handle.iCurrentSDS
   END
;-------- close SDS-API
   hdf_sd_end, handle.iSID
;--------- close file
   hdf_close, handle.iVID
   handle = 0
   return, 1
END
;------------------------------ NXIfindvgroup ---------------------------------
FUNCTION NXIfindvgroup, handle, name, class
;------root level
  IF handle.iCurrentVG EQ 0 THEN BEGIN
     list = hdf_vg_lone(handle.iVID)
     IF N_ELEMENTS(list) EQ 0 THEN BEGIN
        return, 0
     END
;------------ look them all up
     FOR I = 0, (N_ELEMENTS(list) - 1) DO BEGIN
       vgid = hdf_vg_attach(handle.iVID,list(I))
       hdf_vg_getinfo, vgid, name=nm, class =cn
       hdf_vg_detach, vgid
       IF (name EQ nm) AND (class EQ cn) THEN BEGIN
         return, list(I)
       END 
     END
  END ELSE BEGIN
    hdf_vg_gettrs, handle.iCurrentVG, tags, refs
    FOR I = 0, (N_ELEMENTS(tags) - 1) DO BEGIN
      IF tags(I) EQ 1965 THEN BEGIN
        vgid = hdf_vg_attach(handle.iVID,refs(I))
        hdf_vg_getinfo, vgid, name=nm, class =cn
        hdf_vg_detach, vgid
        IF (name EQ nm) AND (class EQ cn) THEN BEGIN
           return, refs(I)
        END 
      END
    END
  END
  return, 0
END
;------------------------------- NXmakegroup -----------------------------------
FUNCTION NXmakegroup, handle, nname, cclass
;----- check arguments
   IF N_PARAMS() LT 3 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXmakegroup'
       return, 0
    END 
 ;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;--------- make we do it?
    IF handle.Acess NE 'write' THEN BEGIN
       NXprinterror, 'ERROR: no permission to create vGroup'
       return,0
    END
;------------ make sure, that a group with this name does not yet exist
    iRet = NXIfindvgroup(handle,nname,cclass)
    IF iRet NE 0 THEN BEGIN
         NXprinterror, 'ERROR: vGroup already exists'
         return, 0
    END
;-------- do it
    iNew = hdf_vg_attach(handle.iVID,-1,/write)
    IF iNew LT 0 THEN BEGIN
       NXprinterror, 'ERROR: failed to create vGroup'
       return, 0
    END
    hdf_vg_setinfo, iNew, name = nname, class = cclass
;-------- insert when apropriate
    IF handle.iCurrentVG NE 0 THEN BEGIN
        hdf_vg_insert, handle.iCurrentVG, iNew
    END
    hdf_vg_detach, iNew
    return, 1
END
;---------------------- NXopengroup --------------------------------------
FUNCTION NXopengroup, handle, nname, cclass
;----- check arguments
   IF N_PARAMS() LT 3 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXopengroup'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;--------- search the vGroup
   iRef = NXIfindvgroup(handle,nname,cclass)
   IF iRef EQ 0 THEN BEGIN
       NXprinterror, 'ERROR: Requested vGroup NOT found'
       return,0
   END
;--------- at root:
   IF handle.iCurrentVG EQ 0 THEN BEGIN
      IF handle.Acess EQ 'read' THEN $ 
         handle.iCurrentVG = hdf_vg_attach(handle.iVID,iRef) $
      ELSE  $ 
         handle.iCurrentVG = hdf_vg_attach(handle.iVID,iRef,/write) 
      handle.iStackPtr = handle.iStackPtr + 1
      handle.iVREF(handle.iStackPtr) = iRef 
   END ELSE BEGIN
      hdf_vg_detach, handle.iCurrentVG
      handle.iStackPtr = handle.iStackPtr + 1
      handle.iVREF(handle.iStackPtr) = iRef 
      IF handle.Acess EQ 'read' THEN $ 
         handle.iCurrentVG = hdf_vg_attach(handle.iVID,iRef) $
      ELSE  $ 
         handle.iCurrentVG = hdf_vg_attach(handle.iVID,iRef,/write) 
   END
   IF handle.iCurrentVG LT 0 THEN BEGIN
     NXprinterror, 'ERROR: HDF failed to open vGroup'
     handle.iCurrentVG = 0
     return, 0
   END ELSE $ 
         return, 1
END
;---------------------- NXclosegroup -----------------------------------------
FUNCTION NXclosegroup, handle
;----- check arguments
   IF N_PARAMS() LT 1 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXclosegroup'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------ the trivial case: we are at root
  IF handle.iCurrentVG EQ 0 THEN BEGIN
               return, 1 
  END ELSE BEGIN 
    hdf_vg_detach,handle.iCurrentVG
    handle.iStackPtr = handle.iStackPtr - 1
    IF handle.iStackPtr LE 0 THEN BEGIN ; we are at root now
        handle.iStackPtr = 0
        handle.iCurrentVG = 0
    END ELSE BEGIN ; open lower vGroup
      iRef = handle.iVREF(handle.iStackPtr) 
      IF handle.Acess EQ 'read' THEN $ 
         handle.iCurrentVG = hdf_vg_attach(handle.iVID,iRef) $
      ELSE  $ 
         handle.iCurrentVG = hdf_vg_attach(handle.iVID,iRef,/write) 
    END
  END
  return, 1
END
;------------------------ NXIfindsds ------------------------------------------
FUNCTION NXIfindsds, handle, name
;----------- no arg checking, as this is supposed to be called only internally
;------------ root level
  IF handle.iCurrentVG EQ 0 THEN BEGIN
     hdf_sd_fileinfo, handle.iSID, iSDS, iATT
     for i = 0, (iSDS - 1) DO BEGIN
         iNew = hdf_sd_select(handle.iSID,i)
         hdf_sd_getinfo, iNew,name = me
         iRef = hdf_sd_idtoref(iNew)
         hdf_sd_endaccess,iNew
         IF me EQ name THEN return, iRef 
     END 
  END ELSE BEGIN ; vGroup level
          hdf_vg_getinfo,handle.iCurrentVG, NENTRIES = iN
          FOR i = 0, (iN - 1) DO BEGIN
             hdf_vg_gettr, handle.iCurrentVG,i,iTag,iRef
             IF (iTag EQ 700) OR (iTag EQ 720) OR (iTag EQ 703) THEN BEGIN
               ; DFTAG_SDG, DFTAF_NDG, DFTAG_SDS
               iNew = hdf_sd_reftoindex(handle.iSID,iRef)
               i2 = hdf_sd_select(handle.iSID,iNew)
               hdf_sd_getinfo, i2, name = me
               hdf_sd_endaccess, i2
               IF me EQ name THEN return, iRef          
             END
          END
  END
  return, 0
END
;--------------------------- NXmakedata --------------------------------------
FUNCTION NXmakedata, handle, name, datatype, rank, dimensions
;----- check arguments
   IF N_PARAMS() LT 5 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXmakedata'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;---------- do we have write privilege?
   IF handle.Acess NE 'write' THEN BEGIN
      NXprinterror, 'ERROR: no privilege to create SDS'
      return, 0
   END
;---------- is there already a SDS with the same name at the current level?
   iRet = NXIfindsds(handle,name)
   IF iRet NE 0 THEN BEGIN
      NXprinterror, 'ERROR: Cannot create duplicate SDS name'
      return, 0
   END
;------ check rank
   IF rank LE 0 THEN BEGIN
      NXprinterror, 'ERROR: invalid rank parameter specified'
      return, 0
   END
;------ check dims
   IF N_ELEMENTS(dimensions) LT rank THEN BEGIN
      NXprinterror, 'ERROR: not enough dimension values in dimensions array'
      return, 0
   END
;------- be nice, if there is already an SDS open
   IF handle.iCurrentSDS NE 0 THEN BEGIN
      hdf_sd_endaccess, handle.iCurrentSDS
      handle.iCurrentSDS = 0
   END
;--- disallow SDS creation at root level
   IF handle.iCurrentVG EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: SDS creation at root level not permitted in NeXus'
      return, 0
   END
;------ actually create the data set, depending on the value of the type info
   CASE datatype OF
        'NX_FLOAT32': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_FLOAT32)
        'NX_FLOAT64': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_FLOAT64)
        'NX_INT8': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/Byte)
        'NX_UINT8': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_UINT8)
        'NX_CHAR': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_CHAR)
        'NX_INT16': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_INT16)
        'NX_UINT16': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_UINT16)
        'NX_INT32': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_INT32)
        'NX_UINT32': $
           iRes = hdf_sd_create(handle.iSID,name,dimensions,/DFNT_UINT32)
         ELSE: BEGIN
            NXprinterror, 'ERROR: datatype not recognised'
            return, 0
         END        
    ENDCASE
    IF iRes LT 0 THEN BEGIN
        NXprinterror, 'ERROR: failed to create SDS'
        return, 0
    END
;------ link into vGroup
    IF handle.iCurrentVG NE 0 THEN BEGIN
       iRef = hdf_sd_idtoref(iRes)
       hdf_vg_addtr,handle.iCurrentVG, 700,iRef
    END
    hdf_sd_endaccess, iRes
    return, 1
END
;---------------------- NXopendata ---------------------------------------------
FUNCTION NXopendata, handle, name
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXopendata'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;-------- find the SDS
   iData = NXIfindSDS(handle,name)
   IF iData EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: SDS NOT found!'
      return, 0
   END   
;------ be nice: close SDS's which may still be open
   IF handle.iCurrentSDS NE 0 THEN BEGIN
       hdf_sd_endaccess, handle.iCurrentSDS
       handle.iCurrentSDS = 0
   END
;------- now do the job
   iNew = hdf_sd_reftoindex(handle.iSID,iData)
   handle.iCurrentSDS = hdf_sd_select(handle.iSID,iNew)
   IF handle.iCurrentSDS LE 0 THEN BEGIN
      NXprinterror, 'ERROR: failed to open SDS'
      handle.iCurrentSDS = 0
      return, 0
   END
   return, 1
END
;-------------------- NXclosedata ---------------------------------------------
FUNCTION NXclosedata, handle
;----- check arguments
   IF N_PARAMS() LT 1 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXclosedata'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;--------
   IF handle.iCurrentSDS NE 0 THEN BEGIN
      hdf_sd_endaccess, handle.iCurrentSDS
      handle.iCurrentSDS = 0
   END ELSE NXprinterror, 'WARNING: no SDS open, nothing to do'
   return, 1
END
;------------------------- NXgetdata ------------------------------------------
FUNCTION NXgetdata, handle, data
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXgetdata'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------- check if there is an open SDS
   IF handle.iCurrentSDS EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: no SDS open'
      return, 0
   END
;------- do read data
   hdf_sd_getdata, handle.iCurrentSDS, data
   return, 1
END
;--------------- NXgetslab -------------------------------------------------
FUNCTION NXgetslab, handle, data, start, ente
;----- check arguments
   IF N_PARAMS() LT 4 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXgetslab'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------- check if there is an open SDS
   IF handle.iCurrentSDS EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: no SDS open'
      return, 0
   END
;------- do read data
   hdf_sd_getdata, handle.iCurrentSDS, data, start=start, count=ente
   return, 1
END
;------------------------------ NXgetattr ------------------------------------
FUNCTION NXgetattr, handle, name, data, type
;----- check arguments
   IF N_PARAMS() LT 4 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXgetattr'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;--------- find the attribute
    IF handle.iCurrentSDS EQ 0 THEN BEGIN ; global attribute
       iID = hdf_sd_attrfind(handle.iSID,name)
    END ELSE BEGIN
       iID = hdf_sd_attrfind(handle.iCurrentSDS,name)
    END
    IF iID LT 0 THEN BEGIN
       NXprinterror, 'ERROR: attribute NOT found!'
       return, 0
    END
;--- read the attribute
    IF handle.iCurrentSDS EQ 0 THEN BEGIN
       hdf_sd_attrinfo,handle.iSID, iID,name=nm,data = data, HDF_TYPE = type
    END ELSE BEGIN
       hdf_sd_attrinfo,handle.iCurrentSDS, iID,name=nmm, data = data, HDF_TYPE = type
    END
    return, 1   
END
;------------------ NXputdata --------------------------------------------------
FUNCTION NXputdata, handle, data
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXputdata'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------- check if there is an open SDS
   IF handle.iCurrentSDS EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: no SDS open'
      return, 0
   END
;------- write  data
   hdf_sd_adddata, handle.iCurrentSDS, data
   return, 1
END
;--------------- NXputslab -------------------------------------------------
FUNCTION NXputslab, handle, data, start, ente
;----- check arguments
   IF N_PARAMS() LT 4 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXputslab'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------- check if there is an open SDS
   IF handle.iCurrentSDS EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: no SDS open'
      return, 0
   END
;------- write data
   hdf_sd_adddata, handle.iCurrentSDS, data, start=start, count=ente
   return, 1
END
;------------------------------ NXputattr ------------------------------------
FUNCTION NXputattr, handle, name, data
;----- check arguments
   IF N_PARAMS() LT 3 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXputattr'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;--- set the attribute
    IF handle.iCurrentSDS EQ 0 THEN BEGIN
       hdf_sd_attrset,handle.iSID,name,data
    END ELSE BEGIN
       hdf_sd_attrset,handle.iCurrentSDS, name,data
    END
    return, 1   
END
;----------------------- NXgetinfo ---------------------------------------------
FUNCTION NXgetinfo, handle, rank, dim, type
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXgetdata'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------- check if there is an open SDS
   IF handle.iCurrentSDS EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: no SDS open'
      return, 0
   END
;------- get data
   hdf_sd_getinfo, handle.iCurrentSDS, dims = dim, HDF_TYPE = type, NDIMS = rank
   return, 1
END
;-------------------------- NXgroupdir -------------------------------------
FUNCTION NXgroupdir, handle,names, class
;----- check arguments
   IF N_PARAMS() LT 3 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXgroupdir'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------ handling root level
   IF handle.iCurrentVG EQ 0 THEN BEGIN
      list = hdf_vg_lone(handle.iVID)
      iLen = N_ELEMENTS(list)
      names = STRARR(iLen)
      class = STRARR(iLen)
      FOR I = 0, (iLen - 1) DO BEGIN
         vgid = hdf_vg_attach(handle.iVID,list(I))
         hdf_vg_getinfo, vgid, name = nm, class = cn
         hdf_vg_detach, vgid
         names(I) = nm
         class(I) = cn
      END
      return, 1
   END ELSE BEGIN ; vGroup level
       hdf_vg_gettrs, handle.iCurrentVG, tags, refs
       iLen = N_ELEMENTS(tags)
       inames = STRARR(iLen+1)
       iclass = STRARR(iLen+1)
       iFound = 0
       FOR i = 0, (iLen - 1) DO BEGIN
            iTag = tags(I)
            IF iTag EQ 1965 THEN BEGIN ; vGroup
               vgid = hdf_vg_attach(handle.iVID,refs(I))
               hdf_vg_getinfo, vgid, name =nm, class = cn
               hdf_vg_detach, vgid
               inames(iFound) = nm
               iclass(iFound) = cn
               iFound = iFound + 1
            END 
            IF (iTag EQ 700) OR (iTag EQ 720) OR (iTag EQ 703) THEN BEGIN
              ; scientific data
                iNew = hdf_sd_reftoindex(handle.iSID,refs(I))
                i2 = hdf_sd_select(handle.iSID, iNew)
                hdf_sd_getinfo, i2, name = nm
                hdf_sd_endaccess, i2
                inames(iFound) = nm
                iclass(iFound) = 'SDS'
                iFound = iFound + 1 
            END
       END
       names = inames(0:iFound)
       class = iclass(0:iFound)
       return, 1 
   END
   return, 0
END
;-------------------------- NXgetattdir --------------------------------
FUNCTION NXattdir, handle, names
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXattdir'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;---------- root level
   IF handle.iCurrentSDS EQ 0 THEN BEGIN
      hdf_sd_fileinfo, handle.iSID, ds, atts
      names = STRARR(atts)
      FOR i = 0, (atts - 1) DO BEGIN
        hdf_sd_attrinfo, handle.iSID, i, name = nm, data =dat, HDF_TYPE = typ
        names(i) = nm
      END
      return, 1
   END ELSE BEGIN ; SDS attributes
      hdf_sd_getinfo, handle.iCurrentSDS, NATTS = atts
      names = STRARR(atts)
      FOR i = 0, (atts - 1) DO BEGIN
        hdf_sd_attrinfo, handle.iCurrentSDS, i, name = nm, data =dat, HDF_TYPE =typ
        names(i) = nm
      END
      return, 1
   END
END
;---------------------------- NXgetgroupid -----------------------------------
FUNCTION NXgetgroupid, handle, id
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXgetgroupid'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------ invalid when at root
   IF handle.iCurrentVG EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: No ID for root level'
      return, 0
   END
;------ alright do it
   id = lonarr(2)
   id(0) = 1965
   id(1) = handle.iCurrentVG
   return, 1   
END
;---------------------------- NXgetdataid -----------------------------------
FUNCTION NXgetdataid, handle, id
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXgetdataid'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;------ invalid when at root
   IF handle.iCurrentSDS EQ 0 THEN BEGIN
      NXprinterror, 'ERROR: No  SDS open, no ID s then'
      return, 0
   END
;------ alright do it
   id = lonarr(2)
   id(0) = 703
   id(1) = hdf_sd_idtoref(handle.iCurrentSDS)
   return, 1   
END
;-------------------------- NXmakelink ------------------------------------------
FUNCTION NXmakelink, handle, id
;----- check arguments
   IF N_PARAMS() LT 2 THEN BEGIN
       NXprinterror, 'ERROR: Insufficient number of arguments to NXmakelink'
       return, 0
    END 
;--------- check our handle
   iRET = NXcheck(handle)
     IF iRET NE 1 THEN return, 0
;----------- install error handler
   catch, errvar
   IF errvar NE 0 THEN BEGIN
      NXprinterror, !ERR_String
      return, 0
   END 
;--------- invalid if no vGroup open
    IF handle.iCurrentVG EQ 0 THEN BEGIN
            NXprinterror, 'ERROR: will not link into root level'
            return, 0 
    END
;----------- do it
    hdf_vg_addtr, handle.iCurrentVG, id(0), id(1)
    return, 1
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
;     FUNCTION normalise, w_in, raw=raw, monitor=monitor, time=time,  $
;			  detector=detector, alldetectors=alldetectors, ei=ei$
;			  madangles=madangles, zeroshift=zeroshift, inorm, ikeep
;
;For IN4, IN5, IN6, HET and D7 data.
;
;For IN4, IN5 and IN6:
;---------------------
; Normalises raw data to monitor or counting time, depending on value of inorm.
; Finds the position of the elastic peak.
;
;KEYWORDS
; /raw	        : no normlisation (error bars calculated)
; /monitor      : normalise data to 1000 monitor1 counts (DEFAULT)
; /time         : normalise data to counting time (will not work for summed data)
;
; (inorm and ikeep are obsolete, kept for backwards compatability)
;
;For HET:
;--------
; Normalises raw data to monitor 1 (must be monitor 1 for ISIS data).  Removes
; empty spectra.  User must input incident energy.
;
;ARGUMENTS
; ei	: incident energy of measurement
;
;For D7:
;--------
; Normalises raw data to monitor (default) or counting time or individual
; detector.  Extracts every other spectrum if desired (=> nspectra=32).
; Recalculates detector angles based on a YIG calibration by default.
;
;ARGUMENTS
; detector      : detector number to normalise to
; zeroshift     : angle in degrees of 2theta = 0
;
; (inorm and ikeep are obsolete, kept for backwards compatability)
;
;KEYWORDS
; /raw	        : no normlisation (error bars calculated)
; /monitor      : normalise data to 1000 monitor1 counts (DEFAULT)
; /time	        : normalise data to counting time
; /alldetectors : supresses the removal of the odd numbered detectors
; /madangles    : supresses the recalculation of the detector angles using the
;		  current YIG calibration
;
;DIMENSIONS
;   non-TOF data: w_out(nspectra,nphases,nruns)           -unless nphases is 1
;	TOF data: w_out(nchannels,nspectra*nphases,nruns)
;
;COMMAND SYNTAX
;  w2=normalise(w1[,/raw][,/monitor][,/time][,detector=#][,/alldetectors][,/rawangles][,ei=#])
;
;  (optional keywords/arguments shown in square brackets)
;
;						     KHA,JRS 16/7/02
;
;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION normalise_tof, w_in, inorm

	COMMON c_lamp_access, inst
	COMMON printing, iprint, outstring

	IF iprint THEN PRINT,'Start normalise_tof:'
	take_datp, datp

;-------------------------------------------------------------------------------
;Set up start parameters

	mon  = datp.n
	par  = datp.p
	x_in = datp.x
	y_in = datp.y

	sw = SIZE(w_in)
	IF iprint THEN PRINT,'SIZE(w_in) = ',sw
	nchannels = sw(1)
	IF sw(0) EQ 1 THEN nspectra = 1     ELSE $
	IF sw(0) EQ 2 THEN nspectra = sw(2) ELSE BEGIN $
		i = WIDGET_MESSAGE('Normalise: unknown data format',/ERROR)
		RETURN, w_in
	ENDELSE
	norm = 1
	IF N_ELEMENTS(inorm) GE 1 THEN norm = inorm
	IF iprint THEN PRINT, 'norm = ',norm
	gauss  = FLTARR(4)
	dgauss = FLTARR(4)

	IF iprint THEN PRINT,'End of setup data section'
;-------------------------------------------------------------------------------
;Find elastic peak

	IF inst EQ 'IN5' THEN i=WHERE(y_in GT 10.) ELSE i=INDGEN(nspectra)
	xtot = x_in
	ytot = TOTAL(w_in(*,i),2)
	etot = SQRT(ytot)
	y0   = MAX(ytot,i0)
	xmin = xtot((i0-20)>0)
	xmax = xtot((i0+20)<(nchannels-1))

	FITGAUSS, xtot, ytot, etot, xmin, xmax, gauss, dgauss

	chel   = gauss(2)
	IF (inst NE 'MiBeMol') AND (inst NE 'DCSasc') THEN par(9)=chel

        IF (iprint GT 0) THEN PRINT,'End of elastic peak section'

; ** Normalization for Mibemol data and DCS
; ** added by S. Rols 09/01 srols@anl.gov
; ** *************************************

	CASE inst OF
	'MiBeMol':BEGIN
		normf = TOTAL(mon)/N_ELEMENTS(mon)
		normf = normf/1000.
		chel = gauss(2) & par(9) = chel
		GOTO, mibdcs
		END
	'DCSasc':BEGIN
		normf = TOTAL(mon)
		normf = normf/1000.
		chel  = gauss(2) & par(10) = chel
		GOTO, mibdcs
		END
	ELSE:
	ENDCASE
;------------------------------------------------------------------------------
;Find monitor peak, integrate and normalise

	IF norm EQ 0 THEN $
		normf=1. $
	ELSE IF (norm EQ 1) THEN BEGIN
		xmon = x_in
		ymon = mon(*,0)
		emon = SQRT(ymon)
		y0=MAX(ymon,i0)
		xmin = xtot((i0-20)>0)
		xmax = xtot((i0+20)<(nchannels-1))

		FITGAUSS, xmon, ymon, emon, xmin, xmax, gauss, dgauss

		bkgd   = gauss(0)
		height = gauss(1)
		centre = gauss(2)
		sigma  = gauss(3)
		IF  iprint THEN BEGIN
			PRINT, 'bkgd =',bkgd
			PRINT, 'height =',height
			PRINT, 'centre =',centre
			PRINT, 'sigma =',sigma
		ENDIF

		irange  = WHERE(ABS(xmon - centre) LT 8.*sigma, nrange)
		peaksum = TOTAL(ymon(irange),1)
		bkgdsum = TOTAL(ymon,1)-peaksum
		bkgd    = bkgdsum/FLOAT(nchannels-nrange)
		normf   = (peaksum - bkgd*FLOAT(nrange))/1000.
	ENDIF ELSE IF norm EQ 2 THEN BEGIN
		IF inst EQ 'IN5' THEN normf=par(0) ELSE normf=par(0)/60.
	ENDIF

mibdcs:
	w_out = w_in/normf
	e_out = SQRT(w_in)/normf

        IF iprint THEN PRINT,'End of monitor peak section'
;-------------------------------------------------------------------------------
;Return parameters and exit

	s = STRTRIM(STRING(chel),2)  & i = STRPOS(s,'.') & chel  = STRMID(s,0,i(0)+3)
	s = STRTRIM(STRING(normf),2) & i = STRPOS(s,'.') & normf = STRMID(s,0,i(0)+3)

	CASE norm OF
		0: BEGIN
		   nors = '/raw'
		   nstring = 'not normalised. '
		   END
		1: BEGIN
		   nors = '/m'
		   nstring = 'normalised to '+normf+'/1000 M1 counts. '
		   END
		2: BEGIN
		   nors = '/t'
		   nstring='normalised to '+normf+' minutes. '
		   END
	ENDCASE
	normalisation = ' no('+nors+',ce='+chel+')'
	cstring='Elastic channel='+chel
	outstring=nstring+cstring

	datp.p=par

	s = datp.other_tit & i=RSTRPOS(s,' ') & n=STRLEN(s) & numor=STRMID(s,i+1,n-1)
	IF (STRPOS(numor,'>') EQ -1) THEN numor=STRTRIM(STRING(FIX(par(10))),2)
	datp.other_tit=inst+' #'+numor+normalisation

	datp.x_tit='Channel number'
	datp.y_tit='Scattering angle'
	datp.z_tit='Counts / 1000 M1'

	mod_datp, datp, "e", e_out

	give_datp, datp

finished:
	RETURN, w_out
	END


;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION normalise_d7, w_in0, inorm, ikeep, zeroshift

	COMMON c_lamp_access, inst
	COMMON printing, iprint, outstring

	IF iprint THEN PRINT,'Start normalise_d7:'
	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	m_in0     = datp.n
	x_in0     = datp.x
	y_in0     = datp.y
	z_in0     = datp.z
	e_in0     = datp.e
	par       = datp.p
	parv      = datp.pv
	e_in0     = SQRT(w_in0)
	rearrange = 0
	TOF       = FIX(par(8))
	nchannels = FIX(par(6))
	nspectra  = FIX(par(1))
	nphases   = FIX(par(2))
	se        = SIZE(e_in0)
	sw        = SIZE(w_in0)

	IF NOT TOF AND (nphases EQ 1) THEN BEGIN
		IF N_ELEMENTS(sw) EQ 4 THEN nruns = 1 ELSE nruns = sw(sw(0))
		PRINT,'Normalise_d7: Assuming workspace contains a series of no-PA runs'
		rearrange = 1
		w_in = FLTARR(64,nphases,nruns) & w_in(*,0,*)=w_in0(*,*)
		e_in = FLTARR(64,nphases,nruns) & e_in(*,0,*)=e_in0(*,*)
		y_in = y_in0
		sw   = size(w_in)
	ENDIF ELSE IF sw(0) EQ 2 THEN nruns = 1 ELSE nruns = sw(3)

	IF nruns EQ 1 THEN parv = par

	norm = 1
	keep = 0

	IF N_ELEMENTS(inorm) NE 0 THEN BEGIN
		norm = inorm
		IF N_ELEMENTS(ikeep) NE 0 THEN keep=ikeep
	ENDIF

	IF TOF AND (norm EQ 1) AND (nspectra EQ 66) THEN norm = -65
	IF keep LE 0 THEN nspectra = 32 ELSE nspectra = 64

	par(1) = nspectra
	par(3) = nruns

	IF iprint THEN BEGIN
		PRINT,'size(w_in) = ',sw
		PRINT,'TOF        = ',TOF
		PRINT,'nchannels  = ',nchannels
		PRINT,'nspectra   = ',nspectra
		PRINT,'nphases    = ',nphases
		PRINT,'nruns      = ',nruns
		PRINT,'norm       = ',norm
		PRINT,'keep       = ',keep
	ENDIF

	m_in = m_in0
	x_in = x_in0
	sz   = SIZE(z_in0)
	IF sz(0) EQ 3 THEN BEGIN
		ns   = sz(1)
		nr   = sz(3)
		z_in = REFORM(z_in0,ns,nr)
	ENDIF ELSE $
		z_in = z_in0
	IF rearrange EQ 0 THEN BEGIN
		w_in = w_in0
		e_in = e_in0
		y_in = y_in0
	ENDIF

	IF iprint THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;For TOF data, find elastic peak

	IF TOF THEN BEGIN
		nspecs = nspectra
		IF nphases GT 1 THEN adder = 1 ELSE adder = 0
		specs  = INDGEN(nspectra)*nphases + adder
		ytot = TOTAL(w_in(*,specs,*),2)
		IF nruns GT 1 THEN ytot = TOTAL(ytot,2)
		etot = SQRT(ytot)
		xtot = x_in
		y0 = MAX(ytot,i0)
		xmin = xtot((i0-20)>0)
		xmax = xtot((i0+20)<(nchannels-1))
		gauss  = FLTARR(4)
		dgauss = FLTARR(4)

		FITGAUSS, xtot, ytot, etot, xmin, xmax, gauss, dgauss

		chel   = gauss(2)
		par(9) = chel
	ENDIF

;-------------------------------------------------------------------------------
;Perform normalisation

	IF NOT TOF THEN BEGIN
		z_out = FLTARR(nspectra,nruns)
		x_out = FLTARR(nspectra)

		IF keep LE 0 THEN BEGIN
			x_out(INDGEN(32))   = x_in(2*INDGEN(32)+1)
			IF nruns GT 1  THEN $
			z_out(INDGEN(32),*) = z_in(2*INDGEN(32)+1,*) ELSE z_out = x_out
		ENDIF ELSE BEGIN
			x_out = x_in
			z_out = z_in
		ENDELSE

		specs  = INDGEN(nspectra)*2+1
		iphase = INDGEN(nphases)
		irun   = INDGEN(nruns)

		IF (keep LE 0) THEN BEGIN
			w_in = w_in(specs,*,*)
			e_in = e_in(specs,*,*)
		ENDIF

		IF norm EQ 0 THEN normf = 1.
		IF norm EQ 1 THEN normf = m_in(1,iphase+1,irun)/1000.
		IF norm EQ 2 THEN normf = m_in(0,iphase+1,irun)/100.
		IF norm LT 0 THEN normf = w_in(-norm-1,iphase,irun)/1000.

		nspecs = (SIZE(w_in))(1)
		normf = normf(INTARR(nspecs),*,*)
		IF iprint THEN HELP, normf

		w_out = w_in/normf
		e_out = e_in/normf

		IF (nruns EQ 1) OR (nphases NE 1) THEN y_out = y_in $
		ELSE BEGIN
			y_out=INTARR(nruns)
			y_out(*)=FIX(parv(0,*))
		ENDELSE
	ENDIF ELSE BEGIN
		x_out  = x_in
		y_out  = FLTARR(nspectra*nphases)
		iphase = INDGEN(nphases)
		irun = INDGEN(nruns)

		IF keep LE 0 THEN $
			y_out(iphase*32) = y_in(iphase*64 + 1) $
		ELSE IF (keep GT 0) AND (norm EQ -65) THEN $
			y_out = y_in((nspectra+2)*iphase(0):nspectra*(iphase(0) + 1)) $
		ELSE $
			y_out = y_in

		IF keep LE 0 THEN a = 2*INDGEN(32) + 1 ELSE a = INDGEN(64)
		z_out = (y_in(a))(*,INTARR(nruns))

		IF norm EQ -65 THEN nspecs = 66 ELSE nspecs = 64

		IF iprint THEN PRINT,'TOF factor for run #'+ $
			STRTRIM(STRING(LONG(parv(0, irun))),2)+' = '+ $
			STRTRIM(STRING(parv(40,irun)),2)

; Build normalisation array

		CASE 1 OF
		norm EQ 0: normf = 1.
		norm EQ 1: normf = m_in(1,iphase + 1,irun)*parv(40 + iphase,irun)/1000.
		norm EQ 2: normf = m_in(0,iphase + 1,irun)/100.  ; time
		norm LT 0: BEGIN     ; detector
			   ispec = -norm - 1 + iphase*nspecs
			   normf = TOTAL(w_in(*,ispec,irun),1)/1000.
			   w_in(*,ispec,irun) = 0.
			   e_in(*,ispec,irun) = -1.
			   END
		ENDCASE

		IF norm NE 0 THEN BEGIN
			a = (FLTARR(nspecs) + 1.) # TRANSPOSE(iphase)
			b = REFORM(a,nspecs*nphases)
			c = REFORM(normf(b,*),1,nspecs*nphases,nruns)
			normf = c(INTARR(nchannels),*,*)
		ENDIF

		w_out = w_in/normf
		e_out = e_in/normf

; Remove unwanted spectra

		IF norm EQ -65 THEN BEGIN
			zspecs = [(iphase+1)*66 - 2,(iphase+1)*66 - 1]
			e_out(*,zspecs,*) = -1.
		ENDIF
		IF keep LE 0 THEN BEGIN
		        zspecs = INTARR((nspecs/2),nphases)
			FOR i = 0, nphases - 1 DO zspecs(*,i) = INDGEN(nspecs/2)*2 + i*nspecs
			zspecs = REFORM(zspecs,(nspecs/2)*nphases)
			e_out(*,zspecs,*) = -1.
		ENDIF
		inz = WHERE((TOTAL(e_out,1))(*,0) GE 0.0, nnz)
		IF nnz GT 0 THEN BEGIN
			w_out = w_out(*,inz,*)
			e_out = e_out(*,inz,*)
		ENDIF
		par(6) = nchannels
	ENDELSE

	IF iprint THEN BEGIN
		PRINT,'size(w_out)=',size(w_out)
		PRINT,'size(e_out)=',size(e_out)
		PRINT,'size(x_out)=',size(x_out)
		PRINT,'size(y_out)=',size(y_out)
		PRINT,'size(z_out)=',size(z_out)
	ENDIF

	IF iprint THEN PRINT,'End of "Perform normalisation" section'

;-------------------------------------------------------------------------------
;Recalculate detector angles from YIG calibration
;MOST RECENT CORRECTION; YIG scan December 2001

	IF (keep EQ 0) OR (keep EQ 2) THEN BEGIN
		IF iprint THEN PRINT,'Recalculating detector angles'
		bank = FLTARR(4,nruns)
		IF nruns EQ 1  THEN bank =    par(16:19) $
			  ELSE bank =   parv(16:19,*)
		IF bank(0,0) EQ 0. THEN BEGIN
			i = WIDGET_MESSAGE('Normalise: Cannot recalibrate detector angles',/ERROR)
			GOTO, endangles
		ENDIF

		angle = FLTARR(16,4) - zeroshift
		angle(*,0) = angle(*,0) + [205.82,202.89,200.18,197.20,194.37,191.54,188.75,185.85, $
				           183.00,180.17,177.40,174.50,171.67,168.80,166.12,163.09]
		angle(*,1) = angle(*,1) + [197.35,194.45,191.73,188.77,185.91,183.09,180.30,177.42, $
				           174.57,171.73,168.91,166.03,163.15,160.33,157.52,154.61]
		angle(*,2) = angle(*,2) + [204.18,201.31,198.55,195.64,192.77,189.90,187.11,184.18, $
				           181.35,178.53,175.77,172.82,169.98,167.15,164.39,161.41]
		angle(*,3) = angle(*,3) + [200.13,197.29,194.58,191.63,188.78,185.94,183.16,180.26, $
				           177.39,174.54,171.80,168.85,166.02,163.14,160.33,157.42]
		IF keep EQ 0 THEN BEGIN
			i = INDGEN(8)*2 + 1
			angle2 = angle(i,*)
			phi=FLTARR(32)
			FOR ibank=0,3 DO $
				phi(ibank*8:ibank*8+7)=bank(ibank)-angle2(*,ibank)
		ENDIF ELSE BEGIN
			phi=FLTARR(64)
			FOR ibank=0,3 DO $
				phi(ibank*16:ibank*16+15)=bank(ibank)-angle(*,ibank)
		ENDELSE
		IF NOT TOF THEN BEGIN
			x_out=phi
		ENDIF ELSE BEGIN
			IF nphases EQ 1 THEN y_out=phi $
			ELSE IF nphases EQ 2 THEN y_out=[phi,phi] $
			ELSE y_out=[phi,phi,phi,phi,phi,phi]
			IF iprint THEN PRINT,'y_out=',y_out
		ENDELSE
		IF nruns GT 1 THEN FOR irun=0,nruns-1 DO BEGIN
			IF keep EQ 0 THEN FOR ibank=0,3 DO $
				phi(ibank*8:ibank*8+7)=bank(ibank,irun)-angle2(*,ibank) $
			ELSE FOR ibank=0,3 DO $
				phi(ibank*16:ibank*16+15)=bank(ibank,irun)-angle(*,ibank)
			z_out(*,irun)=phi
		ENDFOR
		IF nruns GT 1 THEN IF iprint THEN PRINT,'z_out=',z_out
	ENDIF
endangles:

	IF (iprint GT 0) THEN PRINT,'End of "Calibrate angles" section'


;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.p=par
	mod_datp, datp, "x", x_out
	mod_datp, datp, "z", z_out

	IF NOT TOF AND nphases EQ 1 THEN BEGIN
		w_out0=FLTARR(nspectra,nruns) & e_out0=w_out0
		w_out0(*,*)=w_out(*,0,*)
		e_out0(*,*)=e_out(*,0,*)
		IF nruns GT 1 THEN mod_datp, datp, "y", y_out
	ENDIF ELSE BEGIN
		w_out0=w_out
		e_out0=e_out
		mod_datp, datp, "y", y_out
	ENDELSE

	mod_datp, datp, "e", e_out0

	label=' '

	CASE norm OF
		0: BEGIN
			nors = '/r'
			nstring = 'no normalisation'
		   END
		1: BEGIN
			nors = '/m'
			nstring = 'normalised to M1'
		   END
		2: BEGIN
			nors = '/t'
			nstring = 'normalised to counting time'
		   END
	      -65: BEGIN
		   	nors = '/m'
			nstring = 'normalised to TOF-M1'
		   END
 	     ELSE: BEGIN
			nors = 'det='+STRTRIM(STRING(-norm),2)
			nstring='normalised to s'+STRTRIM(STRING(-norm),2)
		   END
	ENDCASE

	CASE keep OF
	        1: BEGIN
			kees = ',/all,/mad'
			kstring = 'all detectors kept, raw det angles used'
		   END
	       -1: BEGIN
			kees = ',/mad'
			kstring = 'odd detectors discarded, raw det angles used'
		   END
	        2: BEGIN
			kees = ',/all'
			kstring = 'all detectors kept, det angles recalculated'
		   END
	     ELSE: BEGIN
			kees = ''
			kstring = 'odd detectors discarded, det angles recalculated'
		   END
	ENDCASE

	normalisation = ' no('+nors+kees
	IF zeroshift GT 0.0 THEN BEGIN
		s=STRTRIM(STRING(zeroshift),2) & i=STRPOS(s,'.') & zers=STRMID(s,0,i+3)
		normalisation = normalisation+',zs='+zers
	ENDIF
	IF NOT TOF THEN normalisation = normalisation+')' ELSE BEGIN
		s=STRTRIM(STRING(chel),2) & i=STRPOS(s,'.') & chel=STRMID(s,0,i+3)
		normalisation = normalisation+',ce='+chel+')'
	cstring = '.  Elastic Channel = '+chel
	ENDELSE

	IF NOT TOF THEN BEGIN
		cstring = ''
		IF (nruns EQ 1) THEN BEGIN
			IF (nphases EQ 1) THEN $
				datp.y_tit = STRTRIM(label,2) $
			ELSE BEGIN
				datp.y_tit = 'Phase'
				datp.z_tit = STRTRIM(label,2)
			ENDELSE
		ENDIF ELSE BEGIN
			IF (nphases EQ 1) THEN BEGIN
				datp.y_tit = 'Run Number'
				datp.z_tit = STRTRIM(label,2)
			ENDIF ELSE BEGIN
				datp.y_tit = 'Phase'
				datp.z_tit = 'Run Number'
			ENDELSE
		ENDELSE
	ENDIF ELSE BEGIN
		datp.y_tit = 'Scattering Angle'
		IF (nruns EQ 1) THEN datp.z_tit = STRTRIM(label,2) $
				ELSE datp.z_tit = 'Numor'
	ENDELSE

	s=datp.other_tit & i=RSTRPOS(s,' ') & n=STRLEN(s) & numor=STRMID(s,i+1,n-1)
	IF (nruns EQ 1) AND (STRPOS(numor,'>') EQ -1) THEN numor = STRTRIM(STRING(LONG(par(0))),2)
	IF (nruns EQ 1) AND (STRPOS(numor,'>') NE -1) THEN numor = numor
	IF nruns NE 1 THEN $
	 numor=STRTRIM(STRING(LONG(parv(0,0))),2)+':'+STRTRIM(STRING(LONG(parv(0,nruns-1))),2)

	IF (STRPOS(s,' -ax') EQ -1 AND STRPOS(s,' -cc') EQ -1) THEN $  ; data not previously concatenated, or add_xyz'd
		datp.other_tit='D7 #'+numor+normalisation $
	ELSE datp.other_tit=datp.other_tit+normalisation

	outstring=nstring+', '+kstring+cstring

finished:

	IF (iprint GT 0) THEN PRINT,'End normalise:'

	give_datp, datp

	RETURN, w_out0
	END
;-----------------------------------------------------------------------------
;*****************************************************************************

	FUNCTION normalise_het, w_in, ei = ei

;-----------------------------------------------------------------------------
;*****************************************************************************

	COMMON printing, iprint, outstring
	take_datp, datp

	n = datp.n
	e_in = datp.e
	y_in = datp.y
	z_in = datp.z
	x_in = datp.x
	s = SIZE(w_in)
	nchannels = s(1)
	nspectra = s(2)
	IF iprint THEN BEGIN
		PRINT, 'Nspectra  = ', nspectra
		PRINT, 'Nchannels = ', nchannels
	ENDIF

	IF iprint THEN PRINT,'Normalise_HET: End of check dimensions, etc. section'
;-------------------------------------------------------------------------------------
; Find elastic lines

	offset = 100			; offset required to ignore prompt peak

;2.5m bank
	i = WHERE(z_in LT 2.6 AND z_in GT 2.4)
	xtot = x_in(offset : nchannels - 1)
	ytot = TOTAL(w_in(offset:nchannels-1,i),2)
	etot = SQRT(TOTAL(e_in(offset:nchannels-1,i)^2,2))
	y0   = MAX(ytot,i0)
	xmin = xtot((i0 - 20) > 0)
	xmax = xtot((i0 + 20) < (nchannels - 1))
	FITGAUSS, xtot, ytot, etot, xmin, xmax, gauss, dgauss
	chel1   = gauss(2)
	datp.p(9) = chel1

;4m bank
	i = WHERE(z_in LT 4.1 AND z_in GT 3.9)
	xtot = x_in(offset:nchannels - 1)
	ytot = TOTAL(w_in(offset:nchannels-1,i),2)
	etot = SQRT(TOTAL(e_in(100:nchannels-1,i)^2,2))
	y0   = MAX(ytot,i0)
	xmin = xtot((i0 - 20) > 0)
	xmax = xtot((i0 + 20) < (nchannels - 1))
	FITGAUSS, xtot, ytot, etot, xmin, xmax, gauss, dgauss
	chel2   = gauss(2)
	datp.p(8) = chel2

	IF (iprint GT 0) THEN PRINT,'End of elastic peak section'

;----------------------------------------------------------------------------
; Put Incident energy into parameter block

	IF N_ELEMENTS(ei) EQ 0 THEN BEGIN
		 s = STRARR(3)
		 s(0) = 'You need to include the incident energy'
		 s(1) = 'for HET data'
		 s(2) = 'e.g.   w2 = normalise(w1, Ei = 100)'
		 i = WIDGET_MESSAGE(s, /ERROR)
		 GOTO, finished
	ENDIF ELSE BEGIN
		ei = FLOAT(ei)
		lambda = SQRT(81.8066/ei)
		datp.p(21) = lambda
	ENDELSE
;----------------------------------------------------------------------------
; Sort data in ascending 2-theta order

	sorty = SORT(y_in)
	w_buf = w_in(*,sorty)
	e_buf = e_in(*,sorty)
	z_buf = z_in(sorty)
	y_buf = y_in(sorty)

; Perform normalisation to M1 (must use M1 for HET data)

	narr = INTARR(nspectra)
	w_out = w_buf/n(*,narr)
	e_out = SQRT( (e_buf/n(*,narr))^2 + (w_buf*n(*,narr+1)/(n(*,narr)^2))^2 )

; Remove zero spectra
	i = WHERE(y_buf NE 0, nnz)
	w_out = w_out(*,i)
	e_out = e_out(*,i)
	y_out = y_buf(i)
	z_out = z_buf(i)
	s = SIZE(w_out)
	nspectra = s(2)

	IF iprint THEN PRINT, 'Normalise_HET: End of normalisation section'

;---------------------------------------------------------------------------
; Return data and paramaters

	s=STRTRIM(STRING(ei),2)     & i=STRPOS(s,'.') & ei    =STRMID(s,0,i+3)
	s=STRTRIM(STRING(lambda),2) & i=STRPOS(s,'.') & lambda=STRMID(s,0,i+3)
	s=STRTRIM(STRING(chel1),2)  & i=STRPOS(s,'.') & chel1 =STRMID(s,0,i+3)
	s=STRTRIM(STRING(chel2),2)  & i=STRPOS(s,'.') & chel2 =STRMID(s,0,i+3)
	datp.other_tit = datp.other_tit + ' no(Ei='+ei+') '
	mod_datp, datp, "e", e_out
	mod_datp, datp, "y", y_out
	mod_datp, datp, "z", z_out
	give_datp, datp
	outstring = ' Normalised to HET monitor 1, Lambda = '+ lambda
        cstring = ', Elastic times: 2.5m bank - ' + chel1 + ', 4m bank - ' + chel2
	outstring = outstring + cstring
	RETURN, w_out

finished:
	END
;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION normalise, w_in, raw=raw, monitor=monitor, time=time, $
			    detector=detector, alldetectors=alldetectors, ei=ei, $
			    madangles=madangles, zeroshift=zeroshift, inorm, ikeep

	COMMON c_lamp_access, inst
	COMMON printing, iprint, outstring

	iprint = 0   ; if iprint>0, show debugging messages

	IF iprint THEN PRINT,'Start normalise:'

	IF(N_ELEMENTS(inorm) EQ 0) THEN inorm=1								     ;default
	IF KEYWORD_SET(raw) THEN inorm=0
	IF KEYWORD_SET(monitor) THEN inorm=1
	IF KEYWORD_SET(time) THEN inorm=2
	IF KEYWORD_SET(detector) THEN BEGIN
		IF(detector NE 0) THEN inorm=-detector
	ENDIF

	IF(N_ELEMENTS(ikeep) EQ 0) THEN ikeep=0								     ;default
	IF KEYWORD_SET(madangles) THEN BEGIN
		IF KEYWORD_SET(alldetectors) THEN ikeep=1 ELSE ikeep=-1
	ENDIF ELSE BEGIN
		IF KEYWORD_SET(alldetectors) THEN ikeep=2
	ENDELSE
	IF(N_ELEMENTS(zeroshift) LE 0) THEN zeroshift=0.0

;-------------------------------------------------------------------------------
;Check instrument name and call appropriate function

	IF (inst EQ 'IN4' OR inst EQ 'IN5' OR inst EQ 'IN6' OR inst EQ 'DCSasc' OR inst EQ 'MiBeMol') THEN $
		w_out=normalise_tof(w_in,inorm) $
	ELSE IF (inst EQ 'D7') THEN $
		w_out=normalise_d7(w_in,inorm,ikeep,zeroshift) $
	ELSE IF (inst EQ 'HET') THEN $
		w_out=normalise_HET(w_in, ei = ei) $
	ELSE BEGIN
		s = STRARR(9)
		s(0) = 'Normalise:  Instrument must be specfied as one of the following
		s(1) = ''
		s(2) = 'IN4'
		s(3) = 'IN5'
		s(4) = 'IN6'
		s(5) = 'D7'
		s(6) = 'HET'
		s(7) = 'MiBeMol'
		s(8) = 'DCSasc'
		i = WIDGET_MESSAGE(s,/ERROR)
		return,w_in
	ENDELSE

;-------------------------------------------------------------------------------
;Return parameters and exit

	PRINT,'normalise: '+outstring

finished:
	RETURN, w_out
	END
pro normalize,w,n,TIME=time,NOPRINT=noprint,HELP=help

IF KEYWORD_SET(help) THEN BEGIN
  print,''
  print,' Macro (started 25/10/96 by TH.HANSEN) to effectuate a '
  print,' normalization by counting time '
  print,' or by monitor counting rate, by default to monitor (-000)'
  print,''
  print,' Last modification 17-Jun-97 by Th.Hansen'
  print,' Last modification 19-Feb-98 by Th.Hansen'
  print,' Last modification 29-May-01 by Th.Hansen'
  print,' Last modification 01-Jun-01 by Th.Hansen'
  print,' Last modification 02-May-02 by Th.Hansen: Normalization of data read with raw-button released'
  print,''
ENDIF
take_datp,datp
w=float(w)
IF N_ELEMENTS(datp.e) NE N_ELEMENTS(W) THEN mod_datp,datp,'e',W/SQRT(W+1)
nt = 0 & nm = 0
ft = 0 & fm = 0
IF  datp.p(39) lt 0.0 THEN BEGIN
  IF NOT KEYWORD_SET(noprint) THEN print,'Time normalization already effectuated: ',datp.p(39)
  ft = -1.0 /  datp.p(39) 
ENDIF
IF  datp.p(39) gt 0.0 THEN BEGIN
  IF NOT KEYWORD_SET(noprint) THEN print,'Monitor normalization already effectuated: ',datp.p(39)
  fm = 1.0 /  datp.p(39) 
ENDIF
IF N_ELEMENTS(n) NE 1 THEN BEGIN
  IF KEYWORD_SET (time) THEN BEGIN
    n=1 
    IF N_ELEMENTS(w(0,*,*)) GT 1 THEN n=TOTAL(datp.pv(5,*,*))/N_ELEMENTS(datp.pv(0,*,*))
  ENDIF ELSE BEGIN
    n=100000
    IF N_ELEMENTS(w(0,*,*)) GT 1 THEN n=TOTAL(datp.n(*,*))/N_ELEMENTS(datp.n(*,*))
  ENDELSE
ENDIF
IF KEYWORD_SET (time) THEN BEGIN
  IF MIN(datp.pv(5,*)) LE 0.0 THEN n = 0
  IF NOT KEYWORD_SET(noprint) THEN print, 'Normalization to counting time = ',n 
  nt = n
  datp.p(39) = -n 
ENDIF ELSE BEGIN
  IF MIN(datp.n(0,0,*)) LE 0.0 THEN n = 0
  IF NOT KEYWORD_SET(noprint) THEN print, 'Normalization to monitor counting rate = ',n
  nm = n
  datp.p(39) = n 
ENDELSE
nss = N_ELEMENTS (w(0,0,*))		; Number of Scans/slices per numor
ns =  N_ELEMENTS (w(0,*,0))		; Number of Scans/slices per numor
nn = datp.n
IF N_ELEMENTS(datp.n(0,*)) EQ N_ELEMENTS(w(0,*)) AND N_ELEMENTS(datp.n(*,0)) EQ 1 THEN BEGIN
  IF N_ELEMENTS(nn) GT 1 THEN nn=REFORM(nn,N_ELEMENTS(w(0,*)))
ENDIF
pv = datp.pv
ee = datp.e
FOR ss=0,nss-1 DO FOR s=0,ns-1 DO BEGIN
  IF fm eq 0.0 THEN fmm = 1.0 ELSE fmm = (fm*nn(0,0,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1)))
  IF nm eq 0.0 THEN nmm = 1.0 ELSE nmm = (nm/nn(0,0,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1)))
  IF ft eq 0.0 THEN ftt = 1.0 ELSE BEGIN
      ftt = (ft*nn(0,1,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1)))
  ENDELSE
  IF nt eq 0.0 THEN ntt = 1.0 ELSE BEGIN
      ntt = (nt/nn(0,1,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1)))
  ENDELSE
  w (*,s,ss)=w (*,s,ss)*fmm*nmm*ftt*ntt
  ee(*,s,ss)=ee(*,s,ss)*fmm*nmm*ftt*ntt
  nn  (0,0,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1))=nn  (0,0,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1))*fmm*nmm*ftt*ntt
  IF N_ELEMENTS(nn(0,*,0,0)) GE 2 THEN BEGIN
    nn  (0,1,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1))=nn  (0,1,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1))*fmm*nmm*ftt*ntt
    IF N_ELEMENTS(nn(0,*,0,0)) GE 3 THEN BEGIN
	  nn  (0,2,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1))=nn  (0,2,s<(N_ELEMENTS(nn(0,0,*,0))-1),ss<(N_ELEMENTS(nn(0,0,0,*))-1))*fmm*nmm*ftt*ntt
    ENDIF
  ENDIF
ENDFOR
datp.e  = ee
datp.n  = nn
give_datp,datp

END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION norm_inc, w_in0, inc_xs=sigmaI, debye=DWfac, ini, dwf

;For D7 data only
;
; Normalise intensities to the incoherent scattering of the sample. 
; Must be called after components and theta_scan and phi2q. 
;
;ARGUMENTS:
; inc_xs	:incoherent cross-section of the sample (required)
; debye		:Debye-Waller factor (optional)
;
;DIMENSIONS
;x-axis must be in Q  -> w_in=w_out(nQ) 
;
;COMMAND SYNTAX:
;eq -	w2=norm_inc(w1,inc_xs=4.5[,debye=0.06])
;	- normalise to an incoherent scattering cross-section of 4.5barns
;	- Debye-Waller factor of exp(-0.06*Q^2)
; (optional arguments shown in square brackets)
;
;							KHA,JRS 14/9/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start norm_inc:'

	take_datp, datp
	IF(N_ELEMENTS(ini) GT 0) THEN sigmaI=ini
	IF(N_ELEMENTS(dwf) GT 0) THEN DWfac=dwf

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	sw=SIZE(w_in0)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in0)=',sw
	npts=sw(1)
	par=datp.p
	nspectra=FIX(par(1))
	ncomps=FIX(par(2))
	nruns=FIX(par(3))
	TOF=FIX(par(8))
	nchannels=FIX(par(6))
	chw=par(7)
	lambda=par(4)
	q=datp.x

	e_in0=datp.e

	se=SIZE(e_in0)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in0)=',sw
		PRINT,'        SIZE(e_in0)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	IF (ncomps EQ 1) THEN BEGIN
		PRINT,'norm_inc: Error - Workspace contains only one component'
		GOTO, finished
	ENDIF

	IF (TOF EQ 0) THEN BEGIN
		w_in=w_in0
		e_in=e_in0
	ENDIF ELSE BEGIN
		w_in=REFORM(w_in0,nchannels,nspectra,ncomps)
		e_in=REFORM(e_in0,nchannels,nspectra,ncomps)
	ENDELSE

	IF (iprint GT 0) THEN BEGIN
		PRINT,'TOF=',TOF
		PRINT,'nspectra=',nspectra
		PRINT,'nchannels=',nchannels
		PRINT,'nruns=',nruns
		PRINT,'ncomps=',ncomps
	ENDIF

	absnorm=sigmaI/(4.*!pi)

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Perform Normalisation

	normf=w_in*0.	& dnormf=normf

	IF(N_ELEMENTS(DWfac) GT 0) THEN BEGIN
		dw=exp(-DWfac*q^q)
	ENDIF ELSE BEGIN
		dw=0*q+1
	ENDELSE

	IF (TOF EQ 0) THEN BEGIN
		FOR ipt=0,npts-1 DO BEGIN
			FOR icomp=0,ncomps-1 DO BEGIN
				normf(ipt,icomp,*)=w_in(ipt,1,*)/dw(ipt)
				dnormf(ipt,icomp,*)=e_in(ipt,1,*)/dw(ipt)
			ENDFOR
		ENDFOR
		avinc=TOTAL(w_in(*,1,*)/e_in(*,1,*)^2,1)/TOTAL(1./e_in(*,1,*)^2,1)
		davinc=SQRT(1./TOTAL(1./e_in(*,1,*)^2,1))
		FOR irun=0,nruns-1 DO BEGIN
			normf(*,1,irun)=avinc(irun)
			dnormf(*,1,irun)=davinc(irun)
		ENDFOR
	ENDIF ELSE BEGIN
		FOR ispec=0,nspectra-1 DO BEGIN
			sum=TOTAL(w_in(*,ispec,1),1)
			dsum=SQRT(TOTAL(e_in(*,ispec,1)^2,1))
			normf(*,ispec,*)=sum*chw
			dnormf(*,ispec,*)=dsum*chw
		ENDFOR
		avinc=TOTAL(normf(0,*,1)/dnormf(0,*,1)^2)/TOTAL(1./dnormf(0,*,1)^2)
		davinc=SQRT(1./TOTAL(1./dnormf(0,*,1)))
		normf(*,*,1)=avinc	& dnormf(*,*,1)=davinc
	ENDELSE

	zeroed=WHERE(e_in LT -0.9, nz)
	IF (nz GT 0) THEN normf(zeroed)=-1.

	w_out=w_in/normf
	e_out=SQRT((e_in/normf)^2+(w_in*dnormf/normf^2)^2)
	e_out(*,1,*)=0.

	IF (nz GT 0) THEN BEGIN
		w_out(zeroed)=0.
		e_out(zeroed)=-1.
	ENDIF

	IF (TOF EQ 1) THEN BEGIN
		w_out=REFORM(w_out,nchannels,nspectra*ncomps)
		e_out=REFORM(e_out,nchannels,nspectra*ncomps)
	ENDIF

	w_out=w_out*absnorm
	e_out=e_out*absnorm

	IF (iprint GT 0) THEN PRINT,'End of "Perform Normalisation" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.e=e_out

	IF (TOF EQ 0) THEN $
		IF (nruns EQ 1 AND ncomps EQ 1) THEN datp.y_tit='X-section (b/ster/f.u.)' $
				ELSE datp.z_tit='X-section (b/ster/f.u.)'
	IF (TOF EQ 1) THEN datp.z_tit='X-section (b/ster/f.u./mcs)'


	s=STRTRIM(STRING(sigmaI),2)
trys:	n=STRLEN(s)	& i=RSTRPOS(s,'0')
	IF (i EQ n-1) THEN BEGIN
		s=STRMID(s,0,n-1)
		GOTO, trys
	ENDIF
	IF(N_ELEMENTS(DWfac) GT 0) THEN BEGIN
		p=STRTRIM(STRING(DWfac),2)
tryp:		n=STRLEN(p)	& i=RSTRPOS(p,'0')
		IF (i EQ n-1) THEN BEGIN
			p=STRMID(p,0,n-1)
			GOTO, tryp
		ENDIF
	ENDIF ELSE p=''

	PRINT,'Norm_inc: normalise to spin-incoherent X-section of '+s+' b/ster/f.u.'
	datp.other_tit=datp.other_tit+' -ni('+s+','+p+')'

finished:
	IF (iprint GT 0) THEN PRINT,'End norm_inc:'

	give_datp, datp

	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION norm_van, w_in0, filenum=Vrun, S_mass=mS, Fwt=AS, V_mass=mV, $
		 fn, op1, op2, op3

;For D7 data only
;
;Correct for "apparent" detector efficiencies using vanadium data.  If desired,
;normalise intensity to an absolute scale. Must be run after components.pro!!!
;
;ARGUMENTS:
; filenum	:number of vanadium integral file - "vanadium_<filenum>.dat"
;		 created by vanadium.pro.  Is possible also to input multiple
;		 vanadium file numbers for use with theta_scan data -
;		 e.g. filenum=[13487,13491] - use 5 vanadium files numbered
;					      13487,13488,13489,13490,13491
;					      i.e. sequential order
;		filenum=[13487,13490,13499] - use the three specified files
;					      i.e. non-sequential order
;
; S_mass	:sample mass (g) -optional
; V_mass	:V mass (g)	 -optional
; Fwt		:formula weight (amu) per f.u. -optional
;
; (fn, op1, op2 and op3 are obsolete, kept for backwards compatability)
;
;DIMENSIONS:
; w_in=w_out(nspectra,nphases,nruns) unless
;
;COMMAND SYNTAX
;Simple Example:
;	w2=norm_van(w1,filenum=[13478,13499])
;	- correct det efficiencies using 12 vanadium files vanadium_13478.dat
;	  to vanadium_13499.dat taken at different scan positions 
;
;Absolute Normalisation example:
;	w2=norm_van(w1,filenum=13487,S_mass=13.45,V_mass=92.3,Fwt=6.29)
;	- normalise to vanadium_13487.dat, using a sample mass of 13.45g 
;	  and a formula weight of 92.3 amu. V mass is 6.29g. 
;
;							KHA,JRS 14/4/01
;-------------------------------------------------------------------------------
;*******************************************************************************

	COMMON c_lamp_access, inst

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start norm_van:'

	take_datp, datp
	
	IF(N_ELEMENTS(fn) GT 0) THEN Vrun=fn
	IF(N_ELEMENTS(op1) GT 0) THEN mS=op1
	IF(N_ELEMENTS(op2) GT 0) THEN mV=op2
	IF(N_ELEMENTS(op3) GT 0) THEN AS=op3

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	IF (inst NE 'D7') THEN BEGIN
		PRINT,'norm_van: Error - instrument must be D7'
		GOTO, finished
	ENDIF

	sw=SIZE(w_in0)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in0)=',sw

	par=datp.p
	nspectra=FIX(par(1))
	ncomps=FIX(par(2))
	nruns=FIX(par(3))
	TOF=FIX(par(8))
	nchannels=FIX(par(6))
	chw=par(7)

	e_in0=datp.e

	se=SIZE(e_in0)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in0)=',sw
		PRINT,'        SIZE(e_in0)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	IF (TOF EQ 0) THEN BEGIN
		IF (ncomps EQ 1) THEN BEGIN
			w_in=FLTARR(nspectra,ncomps,nruns)	& e_in=w_in
			w_in(*,0,*)=w_in0(*,*)
			e_in(*,0,*)=e_in0(*,*)
		ENDIF ELSE BEGIN
			w_in=w_in0
			e_in=e_in0
		ENDELSE
	ENDIF ELSE BEGIN
		w_in=REFORM(w_in0,nchannels,nspectra,ncomps)
		e_in=REFORM(e_in0,nchannels,nspectra,ncomps)
	ENDELSE

	IF (iprint GT 0) THEN BEGIN
		PRINT,'TOF=',TOF
		PRINT,'nspectra=',nspectra
		PRINT,'ncomps=',ncomps
		PRINT,'nchannels=',nchannels
		PRINT,'nruns=',nruns
	ENDIF

	IF (N_ELEMENTS(Vrun) EQ 1) THEN BEGIN
		nVs=1
		V_file='vanadium_'+STRTRIM(STRING(Vrun),2)+'.dat'
		junk=FINDFILE(V_file,COUNT=co)
		IF(co EQ 0) THEN BEGIN
			V_file='/home/vis/d7/lambda/VANFILES/'+V_file
			junk=FINDFILE(V_file,COUNT=co)
			IF(co EQ 0) THEN PRINT, !ERR_STRING
		ENDIF
		PRINT,'Norm_van: Normalise to vanadium file ',V_file
	ENDIF ELSE BEGIN
		nVs=N_ELEMENTS(Vrun)
		IF(nVs EQ 2) THEN BEGIN		;consecutive sequence
			subv=Vrun(1)-Vrun(0)
			nVs=subv+1
			Vrun=INDGEN(nVs)+Vrun(0)
		ENDIF
		V_file=STRARR(nVs)
		PRINT,'Norm_van: Normalise to vanadium files
		FOR iV=0,nVs-1 DO BEGIN
			V_file(iV)='vanadium_'+STRTRIM(STRING(Vrun(iV)),2)+'.dat'
			junk=FINDFILE(V_file(iV),COUNT=co)
			IF(co EQ 0) THEN BEGIN
				V_file(iV)='/home/vis/d7/lambda/VANFILES/'+V_file(iV)
				junk=FINDFILE(V_file(iV),COUNT=co)
				IF(co EQ 0) THEN PRINT, !ERR_STRING
			ENDIF
			PRINT,'        ',V_file(iV)
		ENDFOR
	ENDELSE

	absol=0
	IF (N_ELEMENTS(mS) NE 0) THEN absol=1

	IF (iprint GT 0) THEN PRINT,'absol=',absol

	absnorm=1.
	IF (absol EQ 1) THEN BEGIN
		amu=1.66E-24	; amu in g
		NS=mS/(AS*amu)	; number of formula units
		AV=50.9414	; atomic mass of V
		NV=mV/(AV*amu)	; number of V atoms
		sigmaV=5.08/(4.*!pi) ; V incoherent cross-section in b/ster
		absnorm=sigmaV*NV/NS
		IF (iprint GT 0) THEN PRINT,'  Sample: m=',mS,'g  A=',AS,'amu  N.f.u.=',nS
		IF (iprint GT 0) THEN PRINT,'Vanadium: m=',mV,'g  A=',AV,'amu  N.f.u.=',nV,'  => absnorm=',absnorm
	ENDIF
		
	IF (iprint GT 0) THEN PRINT,'absnorm=',absnorm

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Open and read from input file

	itest=12

	line=''
	Varray=FLTARR(4,nspectra)
	V=FLTARR(nspectra,nruns)	& dV=V
	IF (nVs EQ 1) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'Opening Vanadium file: ',V_file(0)
		OPENR, 1, V_file(0), ERROR=err
		IF (err NE 0) THEN PRINT, !ERR_STRING
		READF, 1, line	& READF, 1, line
		READF, 1, Varray
		CLOSE, 1
		FOR irun=0,nruns-1 DO BEGIN
			V(*,irun)=Varray(2,*)
			dV(*,irun)=Varray(3,*)
		ENDFOR
	ENDIF ELSE BEGIN
		Vin=FLTARR(nspectra,nVs)	& dVin=Vin	& Vx=Vin
		FOR iV=0,nVs-1 DO BEGIN
			IF (iprint GT 0) THEN PRINT,'Opening Vanadium file: ',V_file(iV)
			OPENR, 1, V_file(iV), ERROR=err
			IF (err NE 0) THEN PRINT, !ERR_STRING
			READF, 1, line	& READF, 1, line
			READF, 1, Varray
			CLOSE, 1
			Vin(*,iV)=Varray(2,*)
			dVin(*,iV)=Varray(3,*)
			Vx(*,iV)=Varray(1,*)
			IF (iprint GT 0) THEN PRINT,'Vin(',itest,')=',Vin(itest,iV)
		ENDFOR
	ENDELSE

	IF (nruns GT 1 AND nVs GT 1) THEN BEGIN
		IF (nruns EQ nVs) THEN BEGIN
			IF (iprint GT 0) THEN PRINT,'identical V and sample positions'
			V=Vin & dV=dVin
		ENDIF ELSE BEGIN	; interpolate between V positions
			IF (iprint GT 0) THEN PRINT,'interpolating V positions'
			x_in=datp.z
			FOR ispec=0,nspectra-1 DO BEGIN
				V0=Vin(ispec,*)	   & dV0=dVin(ispec,*)
				xI0=x_in(ispec,*)  & xV0=Vx(ispec,*)
				V(ispec,*)=INTERPOL(V0,xV0,xI0)
				dV(ispec,*)=INTERPOL(dV0,xV0,xI0)
				IF (iprint GT 0 AND ispec EQ itest) THEN BEGIN
					PRINT,'In s',itest,' :'
					PRINT,'V0=',V0
					PRINT,'xV0=',xV0
					PRINT,'xI0=',xI0
					PRINT,'V=',V(ispec,*)
				ENDIF
			ENDFOR
		ENDELSE
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of "read from input file" section'

;-------------------------------------------------------------------------------
;Perform Normalisation

	normf=w_in*0.	& dnormf=normf

	IF (TOF EQ 0) THEN BEGIN
		FOR irun=0,nruns-1 DO BEGIN
			FOR ispec=0,nspectra-1 DO BEGIN
				normf(ispec,*,irun)=V(ispec,irun)
				dnormf(ispec,*,irun)=dV(ispec,irun)
			ENDFOR
		ENDFOR
	ENDIF ELSE BEGIN
		FOR ispec=0,nspectra-1 DO BEGIN
			normf(*,ispec,*)=V(ispec)*chw
			dnormf(*,ispec,*)=dV(ispec)*chw
		ENDFOR
	ENDELSE

	w_out=w_in/normf
	e_out=SQRT((e_in/normf)^2+(w_in*dnormf/(normf^2))^2)

	zeroed=WHERE(e_in LT -0.9, nz)

	IF (TOF EQ 1) THEN BEGIN
		w_out=REFORM(w_out,nchannels,nspectra*ncomps)
		e_out=REFORM(e_out,nchannels,nspectra*ncomps)
	ENDIF

	w_out=w_out*absnorm
	e_out=e_out*absnorm

	IF (nz GT 0) THEN BEGIN
		w_out(zeroed)=0.
		e_out(zeroed)=-1.
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of "Perform Normalisation" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.e=e_out

	IF (TOF EQ 0 AND absol EQ 1) THEN $
		IF (nruns EQ 1 AND ncomps EQ 1) THEN datp.y_tit='X-section (b/ster/f.u.)' $
				ELSE datp.z_tit='X-section (b/ster/f.u.)'
	IF (TOF EQ 1 AND absol EQ 1) THEN datp.z_tit='X-section (b/ster/f.u./mcs)'

	IF (nVs EQ 1) THEN Vruns=STRTRIM(STRING(Vrun),2) $
	ELSE BEGIN
		Vruns=STRTRIM(STRING(Vrun(0)),2)+':'+STRTRIM(STRING(Vrun(nVs-1)),2)
	ENDELSE

	IF (absol EQ 0) THEN datp.other_tit=datp.other_tit+' -nv('+Vruns+',0)' $
	ELSE BEGIN
		mSs=STRTRIM(STRING(mS),2)
mS0:		n=STRLEN(mSs)	& i=RSTRPOS(mSs,'0')
		IF (i EQ n-1) THEN BEGIN
			mSs=STRMID(mSs,0,n-1)
			GOTO, ms0
		ENDIF
		ASs=STRTRIM(STRING(AS),2)
AS0:		n=STRLEN(ASs)	& i=RSTRPOS(ASs,'0')
		IF (i EQ n-1) THEN BEGIN
			ASs=STRMID(ASs,0,n-1)
			GOTO, AS0
		ENDIF
		mVs=STRTRIM(STRING(mV),2)
mV0:		n=STRLEN(mVs)	& i=RSTRPOS(mVs,'0')
		IF (i EQ n-1) THEN BEGIN
			mVs=STRMID(mVs,0,n-1)
			GOTO, mV0
		ENDIF
		datp.other_tit=datp.other_tit+' -nv('+Vruns $
			+','+mSs+','+ASs+','+mVs+')'
	ENDELSE

finished:
	IF (iprint GT 0) THEN PRINT,'End norm_van:'

	give_datp, datp

	RETURN, w_out
	END
	FUNCTION norm_water, w_in0, Vrun, Mrun, AS, bd, wt, st, sd, TW
;
; Normalise intensities using water data. 
; Water integrals are in a file with number given by Vrun. 
; For absolute intensity normalisation, additional arguments 
; are required:
;		AS = atomic mass per f.u.	(amu)
;		bd = beam diameter		(mm)
;		wt = water thickness		(mm)
;		st = sample thickness		(mm)
;		sd = sample density		(g/cm^3)
;		TW = water transmission 	 
;
;							JRS 16/6/00
	iprint=0	; if iprint>0, show debugging messages

	ON_IOERROR, finished

	IF (iprint GT 0) THEN PRINT,'Start norm_water:'

	take_datp, datp
;-------------------------------------------------------------------------------
;Check dimensions of input workspaces
	sw=SIZE(w_in0)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in0)=',sw

	par=datp.p
	parv=datp.pv
	IF (sw(0) EQ 3) THEN nruns=sw(3) ELSE nruns=1
	IF (nruns EQ 1) THEN parv=par
	nspectra=sw(1)
	x_in0=datp.x
	y_in0=datp.y
	e_in0=datp.e

	se=SIZE(e_in0)

	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in0)=',sw
		PRINT,'        SIZE(e_in0)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	w_in=w_in0
	e_in=e_in0

	IF (iprint GT 0) THEN BEGIN
		PRINT,'nspectra=',nspectra
		PRINT,'nruns=',nruns
	ENDIF

	IF (N_ELEMENTS(Vrun) EQ 1) THEN BEGIN
		nVs=1
		V_file='water_'+STRTRIM(STRING(Vrun),2)+'.dat'
		PRINT,'Norm_water: Normalise to water file ',V_file
	ENDIF ELSE BEGIN
		PRINT,'norm_water: Error - must include water file number'
	ENDELSE
	IF (N_ELEMENTS(Mrun) EQ 1) THEN BEGIN
		M_file='mask_'+STRTRIM(STRING(Mrun),2)+'.dat'
		PRINT,'Norm_water: Using mask file ',M_file
	ENDIF

	absol=0
	IF (N_ELEMENTS(AS) NE 0) THEN absol=1

	IF (iprint GT 0) THEN PRINT,'absol=',absol

	absnorm=1.
	IF (absol EQ 1) THEN BEGIN
		sv=!pi*((bd/2)^2)*st	; sample volume (mm^3)
		sv=sv/1000.		; sample volume (cm^3)
		mS=sv*sd		; sample mass (g)
		wt=wt/10.		; water thickness (cm)
		amu=1.66E-24		; amu in g
		NS=mS/(AS*amu)		; number of sample formula units
		wv=!pi*((bd/2)^2)*wt	; water volume (mm^3)
		wv=wv/1000.		; water volume (cm^3)
		AV=3.34E22		; number density of water at RT
		NV=AV*wv		; number of water moleules
		sigmaV=-ALOG(TW)/(4.*!pi*wt*AV*1E-24) 	; water cross-section in b/ster
		absnorm=sigmaV*NV/NS
		PRINT, 'Sigma of Water is ',sigmaV*4*!pi
		PRINT,'Sample: m=',mS,'g,     A=',AS,'amu  N.f.u.=',NS
		PRINT,' Water: t=',wt,'cm, diam=',bd,'mm   N.f.u.=',NV,'  => absnorm=',absnorm
	ENDIF

	IF (iprint GT 0) THEN PRINT,'absnorm=',absnorm

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Open and read from input files

	line=''
	Varray=FLTARR(5,nspectra^2)
	V_buf=FLTARR(nspectra^2)		& dV_buf=V_buf
	IF (iprint GT 0) THEN PRINT,'Opening water file: ',V_file(0)
	OPENR, 1, V_file(0), ERROR=err
	IF (err NE 0) THEN PRINT, !ERR_STRING
	READF, 1, line	& READF, 1, line
	READF, 1, Varray
	CLOSE, 1
	V_buf(*)=Varray(3,*)
	dV_buf(*)=Varray(4,*)
	V=FLTARR(nspectra^2,nruns)	& dV=V
	FOR irun=0,nruns-1 DO BEGIN
		V(*,irun)=V_buf(*)
		dV(*,irun)=dV_buf(*)
	ENDFOR

	IF (N_ELEMENTS(Mrun) NE 0) THEN BEGIN
		line=''
		Marray=FLTARR(5,nspectra^2)
		M_buf=FLTARR(nspectra^2)	& dM_buf=M_buf
		IF (iprint GT 0) THEN PRINT,'Opening mask file: ',M_file(0)
		OPENR, 2, M_file(0), ERROR=err
		IF (err NE 0) THEN PRINT, !ERR_STRING
		READF, 2, line	& READF, 2, line
		READF, 2, Marray
		CLOSE, 2
		M_buf(*)=Marray(3,*)
		dM_buf(*)=Marray(4,*)
		M=FLTARR(nspectra^2,nruns)	& dM=M
		FOR irun=0,nruns-1 DO BEGIN
			M(*,irun)=M_buf(*)
			dM(*,irun)=dM_buf(*)
		ENDFOR
	ENDIF


	IF (iprint GT 0) THEN PRINT,'End of "read from input files" section'

;-------------------------------------------------------------------------------
;Perform Normalisation

	normf=w_in*0.	& dnormf=normf

	FOR irun=0,nruns-1 DO BEGIN
		FOR ispec=0,(nspectra)-1 DO BEGIN
			FOR jspec=0,(nspectra-1) DO BEGIN
				normf(ispec,jspec,irun)=V(((ispec*nspectra)+jspec),irun)
				dnormf(ispec,jspec,irun)=dV(((ispec*nspectra)+jspec),irun)
			ENDFOR
		ENDFOR
	ENDFOR
	IF (N_ELEMENTS(Mrun) NE 0) THEN BEGIN
		maskf=w_in*0.	& dmaskf=maskf
		FOR irun=0,nruns-1 DO BEGIN
			FOR ispec=0,(nspectra)-1 DO BEGIN
				FOR jspec=0,(nspectra-1) DO BEGIN
					maskf(ispec,jspec,irun)=M(((ispec*nspectra)+jspec),irun)
					dmaskf(ispec,jspec,irun)=dM(((ispec*nspectra)+jspec),irun)
				ENDFOR
			ENDFOR
		ENDFOR
	ENDIF ELSE BEGIN
		maskf=w_in*0.	& dmaskf=maskf
		FOR irun=0,nruns-1 DO BEGIN
			FOR ispec=0,(nspectra)-1 DO BEGIN
				FOR jspec=0,(nspectra-1) DO BEGIN
					maskf(ispec,jspec,irun)=1
					dmaskf(ispec,jspec,irun)=0
				ENDFOR
			ENDFOR
		ENDFOR
	ENDELSE
	w_out=w_in
	e_out=(w_out*0)-1
        i=WHERE(normf NE 0.0, nez)
	w_out(i)=w_in(i)*maskf(i)/normf(i)
	j=WHERE(normf EQ 0.0, nz)
	IF(N_ELEMENTS(j) GT 1) THEN BEGIN
		w_out(j)=0.0
	ENDIF
	i=WHERE(w_out NE 0.0, nez)
	term1=e_in(i)/normf(i)
	term2=(e_in(i)*dnormf(i))/(normf(i)^2)
	e_out(i)=SQRT(term1^2+term2^2)

	w_out=w_out*absnorm
	e_out=e_out*absnorm

	IF (iprint GT 0) THEN PRINT,'End of "Perform Normalisation" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.e=e_out

	IF (absol EQ 1) THEN $
		IF (nruns EQ 1) THEN datp.y_tit='X-section (b/ster/f.u.)' $
				ELSE datp.z_tit='X-section (b/ster/f.u.)'

	Vruns=STRTRIM(STRING(Vrun),2)
	IF (N_ELEMENTS(Mrun) NE 0) THEN BEGIN
		Mruns=STRTRIM(STRING(Mrun),2)
	ENDIF ELSE BEGIN
		Mruns='no mask'
	ENDELSE

	IF (absol EQ 0) THEN datp.other_tit=datp.other_tit+' -nw('+Vruns+','+Mruns+',0)' $
	ELSE BEGIN
		mSs=STRTRIM(STRING(mS),2)
mS0:		n=STRLEN(mSs)	& i=RSTRPOS(mSs,'0')
		IF (i EQ n-1) THEN BEGIN
			mSs=STRMID(mSs,0,n-1)
			GOTO, mS0
		ENDIF
		ASs=STRTRIM(STRING(AS),2)
AS0:		n=STRLEN(ASs)	& i=RSTRPOS(ASs,'0')
		IF (i EQ n-1) THEN BEGIN
			ASs=STRMID(ASs,0,n-1)
			GOTO, AS0
		ENDIF
		mVs=STRTRIM(STRING(NV),2)
mV0:		n=STRLEN(mVs)	& i=RSTRPOS(mVs,'0')
		IF (i EQ n-1) THEN BEGIN
			mVs=STRMID(mVs,0,n-1)
			GOTO, mV0
		ENDIF
		datp.other_tit=datp.other_tit+' -nw('+Vruns+','+Mruns $
			+','+mSs+','+ASs+','+mVs+')'
	ENDELSE

finished:
	IF (iprint GT 0) THEN PRINT,'End norm_water:'

	give_datp, datp

	RETURN, w_out
	END


pro num2d20ff,start,stop,T0=T0,mT=mT

@lamp.cbk

for i=start,stop do begin
  xicute,'w1=rdrun('+string(i)+')'
  if keyword_set(T0) then xicute,'p1(12)='+string(T0+mT*(i-start))
  xicute,"d20ff,w1,'"+strcompress(string(i),/re)+"'"
endfor

end
pro num2d20reg,start,stop,base=base,xoffset=xoffset,comment=extracomment,$
                          par=par,extension=extension,merg=merg,bin=bin,$
                          sdev=sdev,min_count=min_count

;w15=num2merg([112623,112625,112626],/sdev,min=3,bin=.2)

;@lamp.cbk
comment=''
IF not KEYWORD_SET(extracomment) THEN comment='' ELSE comment=string(extracomment)
IF not KEYWORD_SET(base) THEN base='' ELSE base=strcompress(base,/re)
partxt="["
FOR i=0,N_ELEMENTS(par)-1 DO BEGIN
  partxt=partxt+STRCOMPRESS(par(i))
  IF i NE (N_ELEMENTS(par)-1) THEN partxt=partxt+','
ENDFOR
partxt=partxt+"]"
    IF NOT KEYWORD_SET(sdev) THEN sdev=0
    IF NOT KEYWORD_SET(bin) THEN bin=0
    IF NOT KEYWORD_SET(min_count) THEN min_count=0

for i=start,stop do begin
  IF KEYWORD_SET (merg) THEN BEGIN
    print,'w1=num2merg('+string(i)+',sdev='+string(sdev)+',bin='+string(bin)+',min='+string(min_count)+',/nopr)'
    xicute,'w1=num2merg('+string(i)+',sdev='+string(sdev)+',bin='+string(bin)+',min='+string(min_count)+',/nopr)'
  ENDIF ELSE BEGIN
    print,'w1=rdrun('+string(i)+')'
    xicute,'w1=rdrun('+string(i)+')'
  ENDELSE
  IF KEYWORD_SET(xoffset) THEN print,'x1=x1+('+string(xoffset)+')'
  IF KEYWORD_SET(xoffset) THEN xicute,'x1=x1+('+string(xoffset)+')'
  IF KEYWORD_SET(xoffset) THEN comment=extracomment+' x1=x1+('+string(xoffset)+')'
  IF KEYWORD_SET(extension) THEN BEGIN
    IF KEYWORD_SET(par) THEN BEGIN
      print,"d20reg,w1,'"+base+strcompress(string(i),/re)+"','dat',comment='"+comment+"',par="+partxt
      xicute,"d20reg,w1,'"+base+strcompress(string(i),/re)+"','dat',comment='"+comment+"',par="+partxt
    ENDIF ELSE BEGIN
      print,"d20reg,w1,'"+base+strcompress(string(i),/re)+"','dat',comment='"+comment+"'"
      xicute,"d20reg,w1,'"+base+strcompress(string(i),/re)+"','dat',comment='"+comment+"'"
    ENDELSE
  ENDIF ELSE BEGIN
    IF KEYWORD_SET(par) THEN BEGIN
      print,"d20reg,w1,'"+base+strcompress(string(i),/re)+"',comment='"+comment+"',par="+partxt
      xicute,"d20reg,w1,'"+base+strcompress(string(i),/re)+"',comment='"+comment+"',par="+partxt
    ENDIF ELSE BEGIN
      print,"d20reg,w1,'"+base+strcompress(string(i),/re)+"',comment='"+comment+"'"
      xicute,"d20reg,w1,'"+base+strcompress(string(i),/re)+"',comment='"+comment+"'"
    ENDELSE
  ENDELSE
endfor
end
pro num2exriet,start,stop,xoffset=xoffset,nobeambg=nobeambg,illdat=illdat
; Modification 30 August 2001 by T.C.Hansen: Keyword illdat transmitted to exriet
@lamp.cbk

IF KEYWORD_SET(nobeambg) THEN BEGIN
  print,'w2=rdrun('+string(nobeambg)+')'
  xicute,'w2=rdrun('+string(nobeambg)+')'
ENDIF
IF NOT KEYWORD_SET(illdat) THEN illdat=0

for i=start,stop do begin
  print,'w1=rdrun('+string(i)+')'
  xicute,'w1=rdrun('+string(i)+')'
  IF KEYWORD_SET(nobeambg) THEN BEGIN
    print,'w2=w2*n1(0,1,0)/n2(0,1,0)'
    xicute,'w2=w2*n1(0,1,0)/n2(0,1,0)'
    print,'n2=n1'
    xicute,'n2=n1'
    print,'w1=w1-w2'
    xicute,'w1=w1-w2'
  ENDIF
  IF KEYWORD_SET(xoffset) THEN BEGIN
    print,'x1=x1+('+string(xoffset)+')'
    xicute,'x1=x1+('+string(xoffset)+')'
  ENDIF
  print,"exriet,w1,'"+strcompress(string(i),/r)+"',illdat="+strcompress(string(illdat),/r)
  xicute,"exriet,w1,'"+strcompress(string(i),/r)+"',illdat="+strcompress(string(illdat),/r)
endfor

end
pro num2fild20,start,stop,xoffset=xoffset

@lamp.cbk

for i=start,stop do begin
  print,'w1=rdrun('+string(i)+')'
  xicute,'w1=rdrun('+string(i)+')'
  print,'x1=x1+('+string(xoffset)+')'
  xicute,'x1=x1+('+string(xoffset)+')'
  print,'fild20,w1,/nod20,/nof20,/nonum'
  xicute,'fild20,w1,/nod20,/nof20,/nonum'
  print,'$ mv fil.dat '+strcompress(string(i),/r)+'.dat'
  xicute,'$ mv fil.dat '+strcompress(string(i),/r)+'.dat'
endfor

end
Function num2merg,num1,num2,$
                    nosum=nosum,nointerpolation=noint,threshold=thresh,$
                    sdev=sdev,noprint=noprint,bad=bad,mult=bad_mult,bin=bin,$
                    norm=norm,min_count=min_count,subnum=subnum
                    

;+
; Merge twotheta scan of n steps (PSD cell width must be 0.1 deg!)
; W1 = mergd20 (W2,/nosum)
; Function
; Parameters
;   Number of workspace to be merged 
; Keywords
;   NOSUM : no sum ...
; Output
;   Workspace containing merged diagram
;-

IF N_ELEMENTS(num1) GT 1 OR N_PARAMS() EQ 1 THEN BEGIN
  numors=num1 
ENDIF ELSE BEGIN
  numors=LINDGEN(ABS(num2-num1)+1)+min([num1,num2])
ENDELSE
d=1
IF NOT KEYWORD_SET(subnum) THEN subnum=INTARR(N_ELEMENTS(numors))+9999  
FOR i=0, N_ELEMENTS(numors)-1 DO BEGIN
  W1=RDRUN(numors(i),datp=d)
  IF i LT N_ELEMENTS(subnum) THEN BEGIN
    W1  =W1  (*,  0:((N_ELEMENTS(W1(0,*))<subnum(i))-1))
    d.e =d.e (*,  0:((N_ELEMENTS(W1(0,*))<subnum(i))-1))
    d.x =d.x (*,  0:((N_ELEMENTS(W1(0,*))<subnum(i))-1))
    d.pv=d.pv(*,  0:((N_ELEMENTS(W1(0,*))<subnum(i))-1))
    d.n =d.n (*,*,0:((N_ELEMENTS(W1(0,*))<subnum(i))-1))
    d.y =d.y (    0:((N_ELEMENTS(W1(0,*))<subnum(i))-1))
  ENDIF
  IF i EQ 0 THEN BEGIN
    ;help,w1,d,/stru
    W =W1
    E =d.e
    X =d.x
    N =d.n
    Y =d.y
    PV=d.pv
  ENDIF ELSE BEGIN
    W =[[W],   [W1]]
    X =[[X],   [d.x]]
    E =[[E],   [d.e]]
    PV=[[PV],  [d.pv]]
    Y =[Y,      d.y]
    N =[[[N]],[[d.n]]]
  ENDELSE
ENDFOR
mod_datp,d,'x',x
mod_datp,d,'e',e
mod_datp,d,'n',n
mod_datp,d,'y',y
mod_datp,d,'pv',pv
IF NOT KEYWORD_SET(noprint)   THEN noprint=0
IF NOT KEYWORD_SET(sdev)      THEN sdev=0
IF NOT KEYWORD_SET(min_count) THEN min_count=0
IF NOT KEYWORD_SET(bin)       THEN bin=0
IF NOT KEYWORD_SET(norm)      THEN norm=0
PRINT,N_ELEMENTS(Y),' steps'
W=mergd20(W,datp=d,sdev=sdev,noprint=noprint,bin=bin,norm=norm,min_count=min_count)
GIVE_DATP,d
RETURN,W
END
FUNCTION num2reg3d,num1,num2,FILENAME=filnam
;+
; Variante of d20reg for 3D-workspaces ... 
; Automatic reading of numors
; Created 27 July 1998 by Th. Hansen after demand of X. Turrillas
;-
@lamp.cbk
datp=0
TAKE_DATP,datp,W=one
IF N_ELEMENTS(datp) LT 1 THEN datp=0
w=RDAND(num1,num2,datp=datp)
IF NOT KEYWORD_SET(filnam) THEN BEGIN
  filnam=STRCOMPRESS(num1,/REMOVE_ALL)+'_'+STRCOMPRESS(num2,/REMOVE_ALL)
ENDIF
help,datp
help,datp.x
reg3d,w,filnam,DATP=datp
GIVE_DATP,datp
RETURN,w
END
PRO num, filename,start=start,help=help

IF KEYWORD_SET(help) THEN BEGIN
  PRINT,' '
  PRINT,'################# LAMP/IDL Macro PROcedure NUM.pro ##################'
  PRINT,'#                                                                   #'
  PRINT,'# *************** Thomas HANSEN, June 1997 D20/ILL **************** #'
  PRINT,'#                                                                   #'
  PRINT,'# Call:  NUM,'fil',START=10000  (example)                           #'
  PRINT,'# Creates a fil.num file out of a fil.f20 file                      #'
  PRINT,'# With increasing numor numbers from START if this keyword is given #'
  PRINT,'#                                                                   #'
  PRINT,'#####################################################################'
  PRINT,' '
ENDIF

Openr,in, strmid(filename,0,3)+'.f20',/get_lun
Openw,out,strmid(filename,0,3)+'.num',/get_lun
readf,in,bid
line=''
readf,in,line
WHILE strmid(line,0,10) NE '    -10000' DO BEGIN
  printf,out,strmid(strcompress(line)+'                         ',0,80)
  print,strmid(line,0,80)
  readf,in,line
  IF KEYWORD_SET (start) THEN BEGIN
    READS,line,bid,numor
    PRINTF,out,FORMAT='(I3,I7,"                                                                      ")',bid,start
    PRINT,     FORMAT='(I3,I7,"                                                                      ")',bid,start
    start=start+1
  ENDIF ELSE BEGIN
    printf,out,strmid(line,0,80)
    print,strmid(line,0,80)
  ENDELSE
  readf,in,line
  printf,out,strmid(line,0,80)
  print,strmid(line,0,80)
  readf,in,cells,line
  FOR i=0,long(cells)/10 DO readf,in,bid
  readf,in,line
ENDWHILE
printf,out,strmid(line,0,80)
print,strmid(line,0,80)
CLOSE,in
CLOSE,out
FREE_LUN,in
FREE_LUN,out
END
; Program/procedure for D20 PSD threshold calculation
; Programm "regseu3", 24.3.93 by Anton OED and Pierre CONVERT (BASIC)
; Modified 6.5.96 by Anton OED
; Procedure re-written for IDL/LAMP in February 1997 by Thomas HANSEN

PRO oldthresh, a,	thresh, boucle,$ ; a = counting rates, thresh = threshold values
              	fit=fit,tmin=tmin,tmax=tmax,marg=marg,start=start,sensibility=sens,$
              	x1=x1,w1=w1,x2=x2,w2=w2,flag=flag,printer=printer,$
              	noprint=noprint,$
              	var1=var1,var2=var2,damp=damp,prev=prev,p2=p2,p3=p3,$
		boxmean=boxmean, cellmean=cellmean,firstbox=firstbox,lastbox=lastbox
;IF NOT KEYWORD_SET(marg)  THEN marg=10.
IF KEYWORD_SET(boxmean) AND KEYWORD_SET(marg) THEN BEGIN
	boxmarg=marg
	marg=0
ENDIF
IF NOT KEYWORD_SET(marg)  THEN marg=10.
IF NOT KEYWORD_SET(damp) THEN damp=1
a      = a(*,0)
olda=a
oldt=thresh
IF NOT KEYWORD_SET(prev) THEN prev=oldt 
IF NOT KEYWORD_SET(p2) THEN p2=prev 
IF NOT KEYWORD_SET(p3) THEN p3=p2 
ncan   = n_elements(a)                                ; number of detector cells
IF NOT KEYWORD_SET(start) THEN start=0
IF NOT KEYWORD_SET(sens)  THEN sens=fltarr(ncan+2)+1. ; sensibility, not yet implemented
IF NOT KEYWORD_SET(tmin)  THEN tmin=300.
IF NOT KEYWORD_SET(tmax)  THEN tmax=900.
IF N_ELEMENTS(boucle) eq 0  THEN boucle = 10          ; number of iterations0
IF N_ELEMENTS(flag) NE ncan THEN flag=intarr(ncan)
;------ corrections (detector borders etc.) -----------------------------------
a(0)            = 0
a(ncan-1)       = 0
sum1            = total(a(where(a,counts)))
moyen           = sum1 / counts
IF (N_ELEMENTS(fit) NE ncan) THEN a(where(a eq 0)) = moyen
sum1   = total(a)
abw    = SQRT (sum1 / ncan)   ; or square ?
mplus  = moyen + abw
mminus = moyen - abw

;-------------- max and min ---------------------------
min = min(a)
max = max(a)

;-------------- calculation ---------------------------
IF NOT KEYWORD_SET(var1) THEN var1=.0009                         ; as explained below  (changed 29. 8.96)
IF NOT KEYWORD_SET(var2) THEN var2=var1*0.32 ELSE var2=var1*var2 ; empirical values!!
a     = [moyen, a, moyen]     ; counting rates plus border dummy countings
thresh= [0.,thresh,0.]
IF (N_ELEMENTS(fit) EQ ncan) THEN fit = [0.,fit,0.]
mV    = a*0.0                 ; threshold variation in each loop
B     = a*0.0                 ; new neutron counting rate
ngain     = a*0.0             ; gain of neutron counting rate 
redis     = a*0.0             ; gain of neutron counting rate 
MV2   = a*0.0                 ; total threshold variation
FOR k = 1, boucle DO BEGIN
   FOR i = 2, ncan, 2 DO IF flag(i-1) NE -1 THEN BEGIN                          ;caneaux impair
        IF (N_ELEMENTS(fit) EQ ncan+2) THEN moyen = fit(i) 
        mV(i) = -(moyen - a(i)) / (var1 * a(i))
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          mV(i)=(thresh(i)+MV2(i))/interpol(x1,w1,a(i)/moyen)-(thresh(i)+MV2(i))
          ideal=mV(i)
          var1=-(interpol(w1,x1,1)-interpol(w1,x1,(thresh(i)+MV2(i))/(thresh(i)+MV2(i)+ideal)))/(interpol(x1,w1,moyen)-interpol(x1,w1,a(i)/moyen))
        ENDIF
        IF ((thresh(i)+MV2(i)+mV(i)) GE tmax) THEN mV(i) =  tmax - (thresh(i)+MV2(i))
        IF ((thresh(i)+MV2(i)+mV(i)) LE tmin) THEN mV(i) = -(thresh(i)+MV2(i) - tmin)
        IF ((thresh(i)+MV2(i)+mV(i)) LE thresh(i)+marg) AND ((thresh(i)+MV2(i)+mV(i)) GE thresh(i)-marg) THEN mV(i) = -MV2(i)
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          B(i)=moyen*interpol(w1,x1,(thresh(i)+MV2(i)+mV(i))/(thresh(i)+MV2(i)+ideal))
        ENDIF ELSE BEGIN
          B(i) = a(i) * (1- mV(i)*var1)                      ;stockage du can. i
        ENDELSE
        var2bak=var2
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) AND KEYWORD_SET(x2) AND KEYWORD_SET(w2) THEN BEGIN
          var2=    -interpol(x1,w1,a(i)/moyen)
          var2=var2+interpol(x2,w2,a(i)/moyen)$
                   +interpol(x1,w1,B(i)/moyen)$
                   -interpol(x2,w2,B(i)/moyen)
          var2=var2/2.
          var2=var2(0)
          var2=var2*(B(i)-a(i))/(B(i)+a(i))*2
        ENDIF ELSE var2=mV(i)*var2 
        ;IF mV(i) NE 0 THEN print,start+i,mV(i),var2,var2/mV(i),mV(i),var2/mV(i)/var1
        B(i-1) = a(i-1)+var2 * a(i - 1)
        redis(i-1)=redis (i-1)+B(i-1) -a(i-1)
        redis(i+1)=redis (i+1)+a(i+1)
        a(i+1) = a(i+1)+var2 * a(i + 1)  
        redis(i+1)=redis (i+1)-a(i+1)
        var2=var2bak
   ENDIF
   a(1:i-2) = B(1:i-2)                                  ;nouvelles val.
   FOR i = 1, ncan, 2 DO  IF flag(i-1) NE -1 THEN BEGIN                          ;caneaux pair
        IF (N_ELEMENTS(fit) EQ ncan+2) THEN moyen = fit(i) 
        mV(i) = -(moyen - a(i)) / (var1 * a(i))
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          mV(i)=(thresh(i)+MV2(i))/interpol(x1,w1,a(i)/moyen)-(thresh(i)+MV2(i))
          ideal=mV(i)
          var1=-(interpol(w1,x1,1)-interpol(w1,x1,(thresh(i)+MV2(i))/(thresh(i)+MV2(i)+ideal)))/(interpol(x1,w1,moyen)-interpol(x1,w1,a(i)/moyen))
        ENDIF
        IF ((thresh(i)+MV2(i)+mV(i)) GE tmax) THEN mV(i) =  tmax - (thresh(i)+MV2(i))
        IF ((thresh(i)+MV2(i)+mV(i)) LE tmin) THEN mV(i) = -(thresh(i)+MV2(i) - tmin)
        IF ((thresh(i)+MV2(i)+mV(i)) LE thresh(i)+marg) AND ((thresh(i)+MV2(i)+mV(i)) GE thresh(i)-marg) THEN mV(i) = -MV2(i)
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          B(i)=moyen*interpol(w1,x1,(thresh(i)+MV2(i)+mV(i))/(thresh(i)+MV2(i)+ideal))
        ENDIF ELSE BEGIN
          B(i) = a(i) * (1- mV(i)*var1)                      ;stockage du can. i
        ENDELSE
        var2bak=var2
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) AND KEYWORD_SET(x2) AND KEYWORD_SET(w2) THEN BEGIN
          var2=    -interpol(x1,w1,a(i)/moyen)
          var2=var2+interpol(x2,w2,a(i)/moyen)$
                   +interpol(x1,w1,B(i)/moyen)$
                   -interpol(x2,w2,B(i)/moyen)
          var2=var2/2.
          var2=var2(0)
          var2=var2*(B(i)-a(i))/(B(i)+a(i))*2
        ENDIF ELSE var2=mV(i)*var2 
        ;IF mV(i) NE 0 THEN print,start+i,mV(i),var2,var2/mV(i),mV(i),var2/mV(i)/var1
        B(i-1) = a(i-1)+var2 * a(i - 1)
        redis(i-1)=redis (i-1)+B(i-1) -a(i-1)
        redis(i+1)=redis (i+1)+a(i+1)
        a(i+1) = a(i+1)+var2 * a(i + 1)  
        redis(i+1)=redis (i+1)-a(i+1)
        var2=var2bak
   ENDIF
   a(0:i-2) = B(0:i-2)                                  ;nouvelles val.
   MV2 = MV2 + mV                                       ;sum des variations
   ;plot,MV2(1:ncan)
ENDFOR
sum2 = total(a(1:ncan))
mmax = max (ABS(MV2(1:ncan)))
PRINT,"New total counting and maximal threshold shift: ", sum2,mmax

;---- presentation du spectre effectuer par la changement des seuils
a      = a(1:ncan)            ; new counting rates minus dummy cells
ngain  = ngain(1:ncan)
tgain  =a-olda
ngain  =tgain-redis
thresh = thresh(1:ncan)
IF (N_ELEMENTS(fit) EQ ncan+2) THEN fit=fit(1:ncan)

;------- presentation de la variation des seuils ------------------
MV2 = MV2(1:ncan)         ; total threshold variation in mV minus dummy values
;plot,MV2
thresh = thresh + MV2/damp     ; new threshold values (optional output)

;------- output for printer ------------------
OPENW,out,'threshold.out',/get_lun
IF NOT KEYWORD_SET(firstbox) THEN firstbox=1
IF NOT KEYWORD_SET(lastbox)  THEN lastbox =1
IF KEYWORD_SET(boxmean) THEN BEGIN
;	marg=boxmarg
	FOR i=firstbox,lastbox DO BEGIN
		thresh(i*32:i*32+31)=thresh(i*32:i*32+31)/mean(thresh(i*32:i*32+31))*boxmean
	ENDFOR
ENDIF
IF KEYWORD_SET(cellmean) THEN BEGIN
;	marg=boxmarg
	meancell=fltarr(32)
	FOR i=firstbox*32,lastbox*32+31 DO BEGIN
		meancell(i mod 32)=meancell(i mod 32)+thresh(i)
	ENDFOR
	FOR i=0,15 DO BEGIN
		meancell(i)=meancell(i)+meancell(31-i)
	ENDFOR
	FOR i=0,15 DO BEGIN
		meancell(31-i)=meancell(i)
	ENDFOR
	meancell=meancell/(lastbox-firstbox+1)/2
	FOR i=firstbox*32,lastbox*32+31 DO BEGIN
		thresh(i)=thresh(i)/meancell(i mod 32)*cellmean
	ENDFOR
ENDIF
;IF KEYWORD_SET(cellmean) OR KEYWORD_SET(boxmean) THEN BEGIN
;	FOR i=0,ncan-1 DO BEGIN
;		IF ABS(thresh(i)-oldt(i)) LE marg THEN BEGIN
;			thresh(i)=oldt(i)
;			;show,i
;		ENDIF
;	ENDFOR
;	FOR i=0,ncan-1 DO MV2(i)=thresh(i)-oldt(i)
;ENDIF
cellstotouch=0
FOR j=0,ncan-1 DO BEGIN
   IF round(thresh(j)) NE round(oldt(j)) THEN cellstotouch=cellstotouch+1
   i=start+j
   format='("??",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") Err",F8.3," (",F8.3,")")'
   IF MV2(j) GT 0 THEN format='("**",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") +++",F8.3," (",F8.3,")")'
   IF MV2(j) LT 0 THEN format='("**",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") ---",F8.3," (",F8.3,")")'
   IF round(thresh(j)) GE ROUND(tmax)    THEN format='("++",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") max",F8.3," (",F8.3,")")'
   IF round(thresh(j)) LE ROUND(tmin)    THEN format='("--",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") min",F8.3," (",F8.3,")")'
   IF round(thresh(j)) EQ ROUND(oldt(j)) THEN format='("  ",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,")    ",F8.3," (",F8.3,")")'
   IF (i MOD 32) EQ 0 THEN BEGIN
	printf,out
	printf,out
	print
	print,'Box:',j/32,': ','average:',mean(thresh(j:j+31)),' mV'
	printf,out,'Box',j/32,': average ',mean(thresh(j:j+31)),' mV'
   ENDIF
   IF (i MOD 64) EQ 0 THEN BEGIN
	;printf,out
   ENDIF
   IF (i MOD 32) EQ 0 THEN BEGIN
	printf,out,"  cell bx no  new   old prev   p1  p2     new count  old count"
   ENDIF
   IF ((i/32) MOD 2) EQ 0 THEN BEGIN
    printf,out,FORMAT=format,i,i/32,31-(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDIF ELSE BEGIN
    printf,out,FORMAT=format,i,i/32,(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDELSE
   IF ((i/32) MOD 2) EQ 0 THEN BEGIN
    print,     FORMAT=format,i,i/32,31-(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDIF ELSE BEGIN
    print,     FORMAT=format,i,i/32,(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDELSE
ENDFOR
CLOSE,out
FREE_LUN,out

thresh=round(thresh)

IF NOT KEYWORD_SET(printer) THEN line='$lp threshold.out' ELSE line='$lp -d'+printer+' threshold.out'
if NOT keyword_set(noprint) THEN  XICUTE,line 

IF KEYWORD_SET(cellmean) THEN BEGIN
	;FOR i=0,31 DO BEGIN
	;	PRINT,i,meancell(i)
	;ENDFOR
	;FOR i=firstbox*32,lastbox*32+31 DO BEGIN
	;	PRINT,i, thresh(i)
	;ENDFOR
ENDIF
print,cellstotouch,' cells to be adjusted'
END
 ;w8=w6&w9=w7&thresh,w8,w9,/noprint,var1=0.0009,var2=0.05,start=400
;Lamp> w12=w1
;w12: Float   dim = 1600 min=0.00000 max=305575.
;Lamp> w13=w2
;w13: Float   dim = 1600 min=300.000 max=900.000
;Lamp> w3=w1&w4=w2&thresh,w3,w4,50,fit=w5,flag=w14,marg=25,tmin=300,tmax=1000,/noprint

function omecon, win ,dlt_omega
;*******
;**
;** Transform rectangular coordinates to radial for Omega scan on D7.
;** Theta=xin
;** Omega=yin
@lamp.cbk

wout=0
wk  =strtrim(string(two),2)
xin =0
yin =0
lamd=0
ii  =execute('xin =x'+wk)
ii  =execute('yin =y'+wk)
ii  =execute('lamd=p'+wk+'(27)')

sw=size(win)
sx=size(xin) & sx=sx(1)
sy=size(yin) & sy=sy(1)

if (sw(1) eq sx) and (sw(2) eq sy) then begin

	iout  =fltarr(sx,sy)
	if n_elements(dlt_omega) eq 0 then dlt_omega=1

	for  j=0,sy-1 do $
	for  i=0,sx-1 do iout(i,j)=xin(i)/2+yin(j) + dlt_omega

	iout  = iout*!pi/180.

	k = 2*!pi/lamd
	fact  = 2   * k * sin(xin/2*!pi/180)

	jout  = cos(iout)
	iout  =-sin(iout)

	for  j=0,sy-1 do begin
		iout(*,j)=iout(*,j)*fact
		jout(*,j)=jout(*,j)*fact
	endfor

	triangulate ,iout,jout    ,triangles
	wout=trigrid(iout,jout,win,triangles)

	x_tit(one)='Qx'
	y_tit(one)='Qy'
	w_tit(one)=w_tit(two)

	DRAWIND
	nv=6  &  col=(indgen(nv)+1)*10+50
;	lv=[2700,3000,3500,4700]
;	contour,win,iout,jout,levels=[10000,20000]
	contour,win,iout,jout,nlevels=nv,/fill,c_colors=col,$
			 title=w_tit(one),xtitle=x_tit(one),ytitle=y_tit(one)
;	contour,win,iout,jout,c_colors=col,nlevels=nv

	sw  =size(wout)
	xin =findgen(sw(1))-sw(1)/2 & xin=-xin/xin(0)*2*k
	yin =findgen(sw(2))-sw(2)/2 & yin=-yin/yin(0)*2*k
	wk  =strtrim(string(one),2)
	ii  =execute('x'+wk+'=xin')
	ii  =execute('y'+wk+'=yin')
endif

return,wout
end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION omega_scan, w_in0, all_angles=all_angles, pos_angles=pos_angles, $
		 neg_angles=neg_angles, ib

;For D7 data only
;
;Input: 2-D or 3-D workspace containing a non-tof omega-scan read in with 
;rdand, normalised with normalise.pro and optionally separated into components 
;with components.pro
;Rearranges to a 1-D or 2-D workspace with detector angle theta as x-axis and 
;omega angle as y-axis
;
;KEYWORDS:
; /neg_angles	: only use data with negative angles
; /pos_angles	: only use data with positive angles
; /all_angles	: use all banks (defaults
;
; (ib is obsolete, kept for backwards compatability)
;
;DIMENSIONS:
; input format: w(32_or_64,nphases,nruns)	- unless nphases or nruns is 1
; output:       w(nspectra,nruns,nphases)	- unless nphases is 1
;
;COMMAND SYNTAX
; w5=omega_scan(w4[,/all_angles][,/pos_angles][,/neg_angles])
;
; (optional keywords shown in square brackets)
;
;						KHA,JRS 27/6/02
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=1	; if iprint>0, show debugging messages

	IF iprint GT 0 THEN PRINT,'Start omega_scan:'

	take_datp, datp

	ibank = 2				;all angles -  default
	IF(N_ELEMENTS(ib) GT 0) THEN ibank=ib
	IF KEYWORD_SET(all_angles) THEN ibank=2
	IF KEYWORD_SET(pos_angles) THEN ibank=1
	IF KEYWORD_SET(neg_angles) THEN ibank=0

;-------------------------------------------------------------------------------
;Check arguments and dimensions of w_in

	par   = datp.p
	e_in0 = datp.e

	sw = SIZE(w_in0)
	se = SIZE(e_in0)
	IF se[0] EQ 0 THEN BEGIN
		PRINT,'omega_scan: Error - no error bars; normalise must be called first'
		GOTO, finished
	ENDIF

	nspectra = sw[1]
	nphases  = FIX(par[2])
	nruns    = FIX(par[3])
	IF nphases EQ 1 THEN BEGIN
		w_in = FLTARR(nspectra,1,nruns)	& e_in = w_in
		w_in[*,0,*] = w_in0[*,*]
		e_in[*,0,*] = e_in0[*,*]
	ENDIF ELSE BEGIN
		w_in = w_in0	& e_in = e_in0
	ENDELSE

	x_in = datp.x
	y_in = datp.y

	IF iprint GT 0 THEN PRINT,'End of "check arguments and dimensions" section'

;-------------------------------------------------------------------------------
;Set up parameters relating to ibank and output arrays


	istart = 0
	i = WHERE(x_in GT 0)
	IF ibank EQ 0 THEN nspectra = i[0] ELSE $
	IF ibank EQ 1 THEN BEGIN
		istart=i[0]
		nspectra=nspectra-i[0]
	ENDIF

	IF iprint GT 0 THEN PRINT,'istart=',istart,' nspectra=',nspectra
	IF iprint GT 0 THEN PRINT,'End of "ibank and iPA setup" section'

;-------------------------------------------------------------------------------
;Rearrange w_in into w_out sorted in order of ascending omega

	y_out = FLTARR(nruns)
	y_out[*] = datp.pv[20,*]
	IF y_out[0] EQ y_out[1] THEN BEGIN
		y_out[*] = datp.pv[21,*]
		ws = 'using Lower Sample Rotation'
	ENDIF ELSE ws = 'using Lower Sample Rotation'	
	
	iorder = SORT(y_out)
	w_out  = FLTARR(nspectra,nruns,nphases)	& e_out = w_out

	is1 = istart	& is2 = is1 + nspectra - 1

	x_out = x_in[is1:is2]
	y_out = y_out[iorder]
	iphase = INDGEN(nphases)
	irun = INDGEN(nruns)
	FOR irun = 0, nruns - 1 DO BEGIN
		w_out[*,irun,iphase] = w_in[is1:is2,iphase,iorder[irun]]
		e_out[*,irun,iphase] = e_in[is1:is2,iphase,iorder[irun]]
	ENDFOR

	IF iprint GT 0 THEN PRINT,'End of "rearrange w_in into w_buf" section'

;-------------------------------------------------------------------------------
;Exclude bad spectra and runs

	ibs = INDGEN(nspectra)
	w_tot = TOTAL(w_out[ibs,*,0],2)
	e_tot = TOTAL(e_out[ibs,*,0],2)
	igs = WHERE(w_tot GT 0. AND e_tot GE 0)
	ib  = WHERE(w_tot LE 0. OR e_tot LT 0., nbs)
print, igs, ib
	IF nbs GT 0 THEN BEGIN
		IF iprint GT 0 THEN PRINT,'There is/are '+ $
			STRTRIM(STRING(nbs),2)+' bad spectrum/spectra'
		IF iprint GT 0 THEN PRINT,'Excluding det. at phi ='+ $
			STRTRIM(STRING(x_out[ib]),2)
		x_out = x_out[igs]
		w_out = w_out[igs,*,*]
		e_out = e_out[igs,*,*]
	ENDIF
help, w_out
	ibr=INDGEN(nruns)
	w_tot = TOTAL(w_out[*,ibr,0],1)
	e_tot = TOTAL(e_out[*,ibr,0],1)
	igr = WHERE(w_tot GT 0. AND e_tot GE 0.)
	ib  = WHERE(w_tot LE 0. OR e_tot LT 0.,nbr)
	IF nbr GT 0 THEN BEGIN
		IF iprint GT 0 THEN PRINT,'There is/are '+ $
			STRTRIM(STRING(nbr),2)+' bad run/runs'
		IF iprint GT 0 THEN PRINT,'Excluding run. at omega ='+ $
			STRTRIM(STRING(y_out[ib]),2)
		y_out = y_out[igr]
		w_out = w_out[*,*,igr]
		e_out = e_out[*,*,igr]
	ENDIF
help, w_out
	nspectra = nspectra - nbs
	nruns = nruns - nbr

	datp.p[1]=FLOAT(nspectra)
	datp.p[3]=FLOAT(nruns)

	IF (iprint GT 0) THEN PRINT,'End of "remove zeroed spectra and runs" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "x", x_out
	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	datp.x_tit = '2-theta'
	datp.y_tit = 'Omega'

	CASE ibank OF
	0: BEGIN
		s='negative angle detectors'
		os = '/neg'
	   END
	1: BEGIN
		s='positive angle detectors'
		os = '/pos'
	   END
	2: BEGIN
		s='all detectors'
		os = '/all'
           END
	ENDCASE

	PRINT,'Omega_scan: keep '+s+', '+ws

	datp.other_tit=datp.other_tit+' -os('+os+')'

finished:
	IF iprint GT 0 THEN PRINT,'End omega_scan:'

	give_datp, datp
help, w_out

	RETURN, w_out
	END
; $Id: oploterr.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO OPLOTERR, X, Y, ERR, PSYM
;
;+
; NAME:
;	OPLOTERR
;
; PURPOSE:
;	Overplot data points with accompanying error bars.
;
; CATEGORY:
;	Plotting, 2-dimensional.
;
; CALLING SEQUENCE:
;	OPLOTERR, [ X ,]  Y , Err  [, Psym ]
;
; INPUTS:
;	Y:	The array of Y values.
;
;	Err:	The array of error bar values.
;
; OPTIONAL INPUT PARAMETERS:
;	X:	An optional array of X values.  The procedure checks whether 
;		or not the third parameter passed is a vector to decide if X 
;		was passed.
;		
;		If X is not passed, then INDGEN(Y) is assumed for the X values.
;
;	PSYM:	The plotting symbol to use (default = +7).
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; RESTRICTIONS:
;	Arrays cannot be of type string.  There must be enough points to
;	plot.
;
; PROCEDURE:
;	A plot of X versus Y with error bars drawn from Y - ERR to Y + ERR
;	is written to the output device over any plot already there.
;
; MODIFICATION HISTORY:
;	William Thompson	Applied Research Corporation
;	July, 1986		8201 Corporate Drive
;				Landover, MD  20785
;-
;
P_SYM = !PSYM		; Save the affected system parameters
LINETYPE = !LINETYPE
;
;  Interpret the input parameters.
;
ON_ERROR,2              ; Return to caller if an error occurs
NP = N_PARAMS(0)
IF NP LT 2 THEN $
  message, 'Must be called with 2-4 parameters: [ X ,]  Y , ERR  [, PSYM ]' $
 ELSE IF NP EQ 2 THEN BEGIN			;Only Y and ERR passed.
	!PSYM = 7
	YERR = Y
	YY = X
	XX = INDGEN(n_elements(x))
END ELSE IF NP GE 3 THEN BEGIN
	N = N_ELEMENTS(ERR)
	IF N EQ 1 THEN BEGIN			;X array not passed.
		!PSYM = ERR
		YERR = Y
		YY = X
		XX = INDGEN(Y)
	END ELSE BEGIN				;X array passed.
		IF NP EQ 3 THEN !PSYM = 7 $
			ELSE !PSYM = PSYM
		YERR = ERR
		YY = Y
		XX = X
	END
END
;
;  Plot data and the error bars.
;
N = N_ELEMENTS(XX) < N_ELEMENTS(YY) < N_ELEMENTS(YERR)
IF N LT 1 THEN message, 'No points to plot.' $
ELSE IF N EQ 1 THEN BEGIN		;Double XX and YY arrays to allow
	XX = [XX(0),XX(0)]		;	plotting of single point.
	YY = [YY(0),YY(0)]
	YERR = [YERR(0),YERR(0)]
END ELSE BEGIN
	XX = XX(0:N-1)
	YY = YY(0:N-1)
ENDELSE
OPLOT,XX,YY				;Plot data points.
!PSYM = 0
!LINETYPE = 0
FOR I = 0,N-1 DO BEGIN			;Plot error bars.
	XXX = [XX(I),XX(I)]
	YYY = [YY(I)-YERR(I),YY(I)+YERR(I)]
	OPLOT,XXX,YYY
END
;
!PSYM = P_SYM		; Return the orginal system parameter values.
!LINETYPE = LINETYPE
;
RETURN
END

pro out_dat, w, file_name_base



take_datp, datp


;	**** filenames should be given with the base command ***
;	**** if not, the default name is "outfile" ***
if file_name_base eq '' then file_name_base = "outfile"

; 	**** set the two file names and get the corresponding units ****
o_file_dat  = file_name_base+'.dat'
o_file_gsas = file_name_base+'.gsas'
get_lun, unit1
get_lun, unit2

;	**** initialize the useful variables from the pv array ****
d2th = round(datp.p(11)*1000)/1000.
monitor = datp.p(12)
x = round(datp.x*1000)/1000. ;	x-axis (round up possible errors)
e = datp.e ;	errors
nruns = datp.n(0)/monitor ; (no of runs: not necessarily an integer)

;	        w contains the intensities

;	**** cut off negative points *****

range = where (x ge -1.e-4)
xx = x(range)
ww = w(range)
ee = e(range)


;	**** calculate final number of points (voids are absent in xx ****
;	**** but must be present in the data files), and initialize the new
;	**** variables *****
 
npoints = round(fix((xx(n_elements(xx)-1)-xx(0))/d2th+1)/10)*10
xnew=findgen(npoints)*d2th+xx(0)
wnew=fltarr(npoints)
enew=fltarr(npoints)
iout = intarr(2,npoints)	; the final output matrix

;	*** now loop over the points of xnew and look for matches with xx ***
for j=0, npoints-1 do $
	begin

	pt = where(abs(xx-xnew(j)) lt 1e-4 )
;		*** if a match is found, set the values of ww, ee and iout ***
;		*** (otherwise, points will be left at 0) ****

       	if pt(0) ne -1 then $
	  begin
		wnew(j)   = ww(pt(0))
		enew(j)   = ee(pt(0))
;		*** average values are printed
		iout(0,j) = round(wnew(j)/(enew(j)^2)*nruns)
		iout(1,j) = round(wnew(j)/nruns)
	  endif 
endfor

;	**** now let the final output begin .... ******
flag=''
on_ioerror, mis_write 
openw, unit1, o_file_dat
openw, unit2, o_file_gsas
printf, unit1, datp.w_tit, format='(A62,17X," ")'
printf, unit2, datp.w_tit, format='(A62,17X," ")'
printf, unit1 ,64, 0, d2th, 1, 0, 0, 0,format= '(2I8,F8.4,4I8)'
printf, unit2, 1,npoints,npoints/10,' CONST', xnew(0)*100,D2th*100,0.,0.,$
	format = '("BANK",3I12,A,4F15.7," STD")'
printf, unit1, xnew(0), format = '(F8.3)'
printf, unit1, monitor, format = '(F8.0)'
printf, unit1, iout, format = '(10(I2, I6))'
printf, unit2, iout, format = '(10(I2, I6))'      
printf, unit1, format ='("   -1000",71X," ")'
printf, unit1, format ='("   -10000",70X," ")'

;   	*** and do not forget to free the units ... ****
free_lun, unit1
free_lun, unit2
flag='ok'

mis_write: if flag ne 'ok' then print,string(7b)+!err_string

end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO output_allangles, w_in, file=out_file, ofi

;takes a 2-D workspace from t2e and writes it to a series of files, 
;one for each detector. x-axis must be energy transfer and y-axis 
;detector number.
;
;output files have names <file>.det2   detector #2
;			 <file>.det4   detector #4
;			 etc...
;
;ARGUMENTS
; file	: name of output file stem
; (ofi is obsolete, kept for backwards compatability)
;
;DIMSENSIONS
; w_in(nspectra,dE) output from t2e.pro [and reb.pro]
;
;COMMAND SYNTAX
; output_allangles, w17, file='<outfile>'
;							JRS, 8/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0

	take_datp, datp

	IF(N_ELEMENTS(ofi) GT 0) THEN out_file=ofi 

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	Earr=datp.x
	sE=size(Earr)
	nEs=sE(1)
	Aarr=datp.y	& sA=size(Aarr)	& nAs=sA(1)
	Sarr=w_in
	dSarr=datp.e
	Narr=INDGEN(nAs)+1


	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Open and write to output files

	ON_IOERROR, giveup

	FOR iA=0,nAs-1 DO BEGIN
		ang=Aarr(iA)
                det=Narr(iA)
                Astring=STRTRIM(STRING(FIX(det)),2)
		Astring='det'+Astring
		PRINT,'Saving to ',STRTRIM(out_file,2),'.',Astring
		S=FLTARR(nEs)	& S(*)=Sarr(*,iA)
		dS=FLTARR(nEs)	& dS(*)=dSarr(*,iA)
		i=WHERE(dS GT -0.9, n)
		IF (n GT 0) THEN BEGIN
			IF (iprint GT 0) THEN PRINT,'n=',n
			E=Earr(i)	& S=S(i)	& dS=dS(i)
			OPENW, 1, out_file+'.'+Astring
			FOR i=0,n-1 DO PRINTF, 1, E(i), S(i), dS(i)
			PRINTF, 1, datp.x_tit
			PRINTF, 1, datp.z_tit
			PRINTF, 1, datp.w_tit+' | angle='+STRTRIM(ang,2)+' degrees'
			PRINTF, 1, datp.other_tit
			CLOSE, 1
		ENDIF
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of "Write to output files" section'

;-------------------------------------------------------------------------------
;Return and exit

	GOTO, finished
giveup:
	CLOSE, 1
finished:
	give_datp, datp

	RETURN
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO output_allqs, w_in, file=out_file, ofi

;takes a 2-D workspace from sqw_rebin.pro and writes it to a series of files, 
;one for each Q. x-axis must be Q and y-axis energy transfer.
;
;output files have names <file>.q005   Q=0.05 A-1
;			 <file>.q010   Q=0.10 A-1
;			 etc...
;
;ARGUMENTS
; file	: name of output file stem
; (ofi is obsolete, kept for backwards compatability)
;
;DIMSENSIONS
; w_in(dQ,dE) output from sqw_rebin.pro
;
;COMMAND SYNTAX
; output_allqs, w17, file='<outfile>'
;							KHA,JRS 8/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0

	take_datp, datp

	IF(N_ELEMENTS(ofi) GT 0) THEN out_file=ofi 

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	Qarr=datp.x
	sQ=size(Qarr)
	nQs=sQ(1)
	Earr=datp.y	& sE=size(Earr)	& nEs=sE(1)
	Sarr=w_in
	dSarr=datp.e

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Open and write to output files

	ON_IOERROR, giveup

	FOR iQ=0,nQs-1 DO BEGIN
		Q=Qarr(iQ)	& Qstring=STRTRIM(STRING(FIX(100.*Q)),2)
		IF (Q LT 0.1) THEN Qstring='q00'+Qstring $
		ELSE IF (Q LT 1.0) THEN Qstring='q0'+Qstring $
		ELSE Qstring='q'+Qstring
		PRINT,'Saving to ',STRTRIM(out_file,2),'.',Qstring
		S=FLTARR(nEs)	& S(*)=Sarr(iQ,*)
		dS=FLTARR(nEs)	& dS(*)=dSarr(iQ,*)
		i=WHERE(dS GT -0.9, n)
		IF (n GT 0) THEN BEGIN
			IF (iprint GT 0) THEN PRINT,'n=',n
			E=Earr(i)	& S=S(i)	& dS=dS(i)
			OPENW, 1, out_file+'.'+Qstring
			ch=STRTRIM(STRING(Q),2)  & i=STRPOS(ch,'.') & Q=STRMID(ch,0,i(0)+4)
			FOR i=0,n-1 DO PRINTF, 1, E(i), S(i), dS(i)
			PRINTF, 1, datp.y_tit
			PRINTF, 1, datp.z_tit
			PRINTF, 1, datp.w_tit+' | Q='+Q+'A-1'
			PRINTF, 1, datp.other_tit
			CLOSE, 1
		ENDIF
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of "Write to output files" section'

;-------------------------------------------------------------------------------
;Return and exit

	GOTO, finished
giveup:
	CLOSE, 1
finished:
	give_datp, datp

	RETURN
	END
;-------------------------------------------------------------------------------
;*******************************************************************************

	PRO output_gsas, w_in, file = out_file
	
;takes a 1-d workspace and writes it to a gsas format data file. 
;Since gsas requires constant angle steps, binq.pro should be run on the data
;first.  
;
;COMMAND SYNTAX
; output_gsas, w10, file=<filename> 
;							JRS 24/11/01
;-------------------------------------------------------------------------------
;*******************************************************************************
	
	iprint=1	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start output_gsas:'

	take_datp, datp	

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	x_in=datp.x
	y_in=datp.y
	z_in=datp.z
	e_in=datp.e

	sw=SIZE(w_in)
		
	IF (N_ELEMENTS(out_file) EQ 0) THEN BEGIN
		PRINT,'output: Error - output file name must be specified'
		GOTO, finished
	ENDIF

	se=SIZE(e_in)
	FOR i=0,se(0) DO IF (se(i) NE sw(i)) THEN e_in=w_in*0.

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Open output file and arrange data and headers

	IF (iprint GT 0) THEN PRINT,'Opening output file'
	ON_IOERROR, close_file

	OPENW, 1, out_file+'.gss', ERROR=err	& IF (err NE 0) THEN PRINT, !ERR_STRING
	title = datp.w_tit

	IF (N_ELEMENTS(datp.p) GT 1) THEN BEGIN
		IF (datp.p(4) EQ 3.02) THEN ibank = 1 ELSE ibank = 2
	ENDIF ELSE BEGIN
		ibank = 2
	ENDELSE

	nchan = sw(1)
	bintyp = ' CONST      '
	tmin = x_in(0)
	step = x_in(1) - x_in(0)
	FOR i=0,nchan-2 DO BEGIN
		IF(ABS(x_in(i+1) - x_in(i) - step) GT 0.01) THEN BEGIN
			gap = x_in(i+1) - x_in(i)
			PRINT, 'Gap found between, ',x_in(i),' and ',x_in(i+1)
			npsg = ROUND((gap/step) - 1)
			gappar = (INDGEN(npsg)+1)*step + x_in(i)
			warr = FLTARR(npsg)
			IF(iprint GT 0) THEN BEGIN
				PRINT,'gap =',gap
				PRINT,'npsg =',npsg
				PRINT,'gappar =',gappar
				PRINT,'warr =',warr
			ENDIF
			x_buf = [x_in(0:i),gappar,x_in((i+1):nchan-1)]
			w_buf = [w_in(0:i),warr,w_in((i+1):nchan-1)]
			e_buf = [e_in(0:i),warr,e_in((i+1):nchan-1)]
			nchan = nchan + npsg
			x_in = x_buf
			w_in = w_buf
			e_in = e_buf
		ENDIF
	ENDFOR

	nrec = CEIL(2.*FLOAT(nchan)/10.)

	IF (iprint GT 0) THEN BEGIN
		PRINT, 'nchan = ',nchan
		PRINT, 'nrec  = ',nrec
		PRINT, 'tmin  = ',tmin
		PRINT, 'step  = ',step
	ENDIF

	a = [[w_in],[e_in]]
	b = ROTATE(a,4)
	w_buf = REFORM(b,2*nchan)
	rem = 10*nrec - 2*nchan

	IF (rem NE 0) THEN BEGIN
		addon = FLTARR(rem)
		w_buf2 = [w_buf,addon]
		w_buf1 = REFORM(w_buf2, 10, nrec)
	ENDIF ELSE BEGIN
		w_buf1 = REFORM(w_buf,10,nrec) 
	ENDELSE

;------------------------------------------------------------------------------
;Write gsas file
	
	PRINTF, 1, title
	PRINTF, 1, FORMAT = '("BANK", I2, I6, I5, A, 4F7.1, A)', $
	ibank, nchan, nrec, bintyp, tmin*100., step*100., 0.0, 0.0, ' ESD'
	PRINTF, 1, FORMAT = '(10F8.4)', w_buf1
	PRINT,'output_gsas: data written to - '+out_file+'.gss'

;------------------------------------------------------------------------------
;Return and exit

close_file:
	CLOSE, 1

finished:
	RETURN
	END
	
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO output, w_in, file=out_file, opf

;takes a workspace and writes it to a file. 1-D workspaces are saved 
;in a standard (x,y,e) 3-column format. Larger workspaces saved differently. 
;
;COMMAND SYNTAX
; output, w10, file=<filename> 
;							KHA,JRS 14/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start output:'

	take_datp, datp

	IF(N_ELEMENTS(opf) GT 0) THEN out_file=opf

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	x_in=datp.x
	y_in=datp.y
	z_in=datp.z
	e_in=datp.e

	sw=SIZE(w_in)
	npts=sw(1)
	IF (sw(0) EQ 1) THEN oned=1 ELSE oned=0
		
	IF (N_ELEMENTS(out_file) EQ 0) THEN BEGIN
		PRINT,'output: Error - output file name must be specified'
		GOTO, finished
	ENDIF

	se=SIZE(e_in)
	FOR i=0,se(0) DO IF (se(i) NE sw(i)) THEN e_in=w_in*0.

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Open and write to output file

	IF (iprint GT 0) THEN PRINT,'Opening output file'
	ON_IOERROR, close_file

	OPENW, 1, out_file, ERROR=err	& IF (err NE 0) THEN PRINT, !ERR_STRING

	IF (oned EQ 1) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'1-D data format'
		FOR i=0,npts-1 DO IF (w_in(i) NE 0.) OR (e_in(i) GT 0.) THEN $
			PRINTF, 1, FORMAT='(3F14.6)', x_in(i), w_in(i), e_in(i)
		IF (datp.y_tit EQ '') THEN datp.y_tit='Intensity (arb. units)'
		PRINTF, 1, datp.x_tit
		PRINTF, 1, datp.y_tit
		PRINTF, 1, datp.w_tit
		PRINTF, 1, datp.other_tit
	ENDIF ELSE BEGIN
		IF (iprint GT 0) THEN PRINT,'More than 1-D data format'
		PRINTF, 1, 'SIZE(workspace) =',SIZE(w_in)
		PRINTF, 1, w_in
		PRINTF, 1, e_in
		PRINTF, 1, 'SIZE(xarray) =',SIZE(x_in)
		PRINTF, 1, x_in
		PRINTF, 1, 'SIZE(yarray) =',SIZE(y_in)
		PRINTF, 1, y_in
		PRINTF, 1, 'SIZE(zarray) =',SIZE(z_in)
		PRINTF, 1, z_in
		PRINTF, 1, datp.x_tit
		PRINTF, 1, datp.y_tit
		PRINTF, 1, datp.z_tit
		PRINTF, 1, datp.w_tit
		PRINTF, 1, datp.other_tit
	ENDELSE

close_file:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'End of "Write to output file" section'

;-------------------------------------------------------------------------------
;Return and exit

	give_datp, datp

finished:
	PRINT,'output: workspace data saved in '+out_file

	RETURN
	END
	FUNCTION overlap, x_in, y_in, iprint, oldymin

	COMMON grid, xmin, xmax, ymin, ymax

;	IDL-ed version of area.for for TOF data analysis
;	Calculates amount of overlap area of rectangle with sides
;	x=xmin, x=xmax, y=ymin, y=ymax, and quadrangle with corners 
;	(x1,y1), (x2,y2), (x3,y3), (x4,y4).
;	(bottom and top lines of two quadrangles parallel).
;
;							KHA, 7/12/98
;
; (xmin,ymax)						 (xmax,ymax)
;	     +------------------------------------------+
;	     |						|
;    (x2,y2) |		     (x3,y3)			|
;	  +--|----B---------+				|
;	 /   |		   /				|
;	A    |		  C				|
;     /	     |		/  				|
;   +--------|--D-----+					|
; (x1,y1)    |		(x4,y4)				|
;	     |						|
;	     +------------------------------------------+
; (xmin,ymin)						 (xmax,ymin)
;

	x1=x_in(0)	& x01=x1
	x2=x_in(1)	& x02=x2
	x3=x_in(2)	& x03=x3
	x4=x_in(3)	& x04=x4
	y1=y_in(0)	& y01=y1
	y2=y_in(1)	& y02=y2
	y3=y_in(2)	& y03=y3
	y4=y_in(3)	& y04=y4

	IF (iprint GT 0) THEN PRINT,'Entering overlap:'

;	PRINT,'[Emin,Emax,Emax,Emin]=',y

;*******************************************************************************
;	Plot Q-E rectangle and quadrangle
;
	IF (iprint GT 0) THEN BEGIN
		a=''
		IF (oldymin NE ymin) THEN BEGIN
			PRINT,'Hit return to start new Q-E grid '
			READ, a
			dx=(xmax-xmin)
			dy=(ymax-ymin)
			x=[xmin-dx,xmin-dx,xmax+dx,xmax+dx]
			y=[ymin-dy,ymax+dy,ymin-dy,ymax+dy]
			plot, x, y, psym=1
		ENDIF
		x=[xmin,xmin,xmax,xmax]
		y=[ymin,ymax,ymin,ymax]
		oplot, x, y, psym=2
		x=[x1,x2,x3,x4]
		y=[y1,y2,y3,y4]
		oplot, x, y, psym=4
		PRINT,'Hit return to calculate overlap '
		READ, a
	ENDIF

;*******************************************************************************
;	Error check
;
	OK=1

	IF (y1 NE y4) OR (y2 NE y3) OR (y2 LE y1) THEN BEGIN
	   OK=0
	   IF (iprint GT 0) THEN PRINT,'y1 NE y4 or y2 NE y3 or y2 NE y1'
	   GOTO, finished
	ENDIF
	IF (x2 GE x3) OR (x1 GE x4) THEN BEGIN
	   OK=0
	   IF (iprint GT 0) THEN PRINT,'x2 GT x3 or x1 GE x4'
	   GOTO, finished
	ENDIF

	IF (MAX([x1,x2,x3,x4]) LE xmin) THEN BEGIN
	   OK=0
	   IF (iprint GT 0) THEN PRINT,'MAX([x1,x2,x3,x4]) LE xmin'
	   GOTO, finished
	ENDIF
	IF (MIN([x1,x2,x3,x4]) GE xmax) THEN BEGIN
	   OK=0
	   IF (iprint GT 0) THEN PRINT,'MIN([x1,x2,x3,x4]) GE xmax'
	   GOTO, finished
	ENDIF
	IF (MAX([y1,y2,y3,y4]) LE ymin) THEN BEGIN
	   OK=0
	   IF (iprint GT 0) THEN PRINT,'MAX([y1,y2,y3,y4]) LE ymin'
	   GOTO, finished
	ENDIF
	IF (MIN([y1,y2,y3,y4]) GE ymax) THEN BEGIN
	   OK=0
	   IF (iprint GT 0) THEN PRINT,'MIN([y1,y2,y3,y4]) GE ymax'
	   GOTO, finished
	ENDIF

;*******************************************************************************
;	If necessary, change y-limits of quad to be within rectangle
;
	IF (y1 LT ymin) THEN BEGIN
	   x1=x1+(ymin-y1)*(x2-x1)/(y2-y1)
	   x4=x4+(ymin-y4)*(x3-x4)/(y3-y4)
	   y1=ymin
	   y4=ymin
	ENDIF
	IF (y2 GT ymax) THEN BEGIN
	   x2=x1+(ymax-y1)*(x2-x1)/(y2-y1)
	   x3=x4+(ymax-y4)*(x3-x4)/(y3-y4)
	   y2=ymax
	   y3=ymax
	ENDIF

;*******************************************************************************
;	Find out whether and where quad crosses grid boundaries 
;
	ncross=0
	AcrossXmin=0	& BcrossXmin=0	& CcrossXmin=0	& DcrossXmin=0
	AcrossXmax=0	& BcrossXmax=0	& CcrossXmax=0	& DcrossXmax=0

	IF (x1 NE x2) THEN BEGIN
		yAxmin=y1+(xmin-x1)*(y2-y1)/(x2-x1)	; crossing of xmin
		IF (ymin LT yAxmin) AND (yAxmin LT ymax) AND $
		   (y1 LT yAxmin) AND (yAxmin LT y2) THEN BEGIN
			AcrossXmin=1
			ncross=ncross+1
		ENDIF ELSE AcrossXmin=0
		yAxmax=y1+(xmax-x1)*(y2-y1)/(x2-x1)	; crossing of xmax
		IF (ymin LT yAxmax) AND (yAxmax LT ymax) AND $
		   (y1 LT yAxmax) AND (yAxmax LT y2) THEN BEGIN
			AcrossXmax=1
			ncross=ncross+1
	   	ENDIF ELSE AcrossXmax=0
	ENDIF ELSE BEGIN
		AcrossXmin=0
		AcrossXmax=0
	ENDELSE

	IF (x2 LT xmin) AND (xmin LT x3) THEN BEGIN
		BcrossXmin=1
		ncross=ncross+1
	ENDIF ELSE BcrossXmin=0
	IF (x2 LT xmax) AND (xmax LT x3) THEN BEGIN
		BcrossXmax=1
		ncross=ncross+1
	ENDIF ELSE BcrossXmax=0

	IF (x3 NE x4) THEN BEGIN
		yCxmin=y4+(xmin-x4)*(y3-y4)/(x3-x4)	; crossing of xmin
		IF (ymin LT yCxmin) AND (yCxmin LT ymax) AND $
		   (y4 LT yCxmin) AND (yCxmin LT y3) THEN BEGIN
			CcrossXmin=1
			ncross=ncross+1
		ENDIF ELSE CcrossXmin=0
		yCxmax=y4+(xmax-x4)*(y3-y4)/(x3-x4)	; crossing of xmax
		IF (ymin LT yCxmax) AND (yCxmax LT ymax) AND $
		   (y4 LT yCxmax) AND (yCxmax LT y3) THEN BEGIN
			CcrossXmax=1
			ncross=ncross+1
		ENDIF ELSE CcrossXmax=0
	ENDIF ELSE BEGIN
		CcrossXmin=0
		CcrossXmax=0
	ENDELSE

	IF (x1 LT xmin) AND (xmin LT x4) THEN BEGIN
		DcrossXmin=1
		ncross=ncross+1
	ENDIF ELSE DcrossXmin=0
	IF (x1 LT xmax) AND (xmax LT x4) THEN BEGIN
		DcrossXmax=1
		ncross=ncross+1
	ENDIF ELSE DcrossXmax=0

	IF (x1 EQ xmin) AND (BcrossXmin EQ 1 OR CcrossXmin EQ 1) THEN DcrossXmin=1
	IF (x1 EQ xmax) AND (BcrossXmax EQ 1 OR CcrossXmax EQ 1) THEN DcrossXmax=1
	IF (x2 EQ xmin) AND (CcrossXmin EQ 1 OR DcrossXmin EQ 1) THEN BcrossXmin=1
	IF (x2 EQ xmax) AND (CcrossXmax EQ 1 OR DcrossXmax EQ 1) THEN BcrossXmax=1
	IF (x3 EQ xmin) AND (AcrossXmin EQ 1 OR DcrossXmin EQ 1) THEN BcrossXmin=1
	IF (x3 EQ xmax) AND (AcrossXmax EQ 1 OR DcrossXmax EQ 1) THEN BcrossXmax=1
	IF (x4 EQ xmin) AND (AcrossXmin EQ 1 OR BcrossXmin EQ 1) THEN DcrossXmin=1
	IF (x4 EQ xmax) AND (AcrossXmax EQ 1 OR BcrossXmax EQ 1) THEN DcrossXmax=1

	IF (ncross EQ 0) AND ((x1 LT xmin OR x1 GT xmax) OR $
  			       (y1 LT ymin OR y1 GT ymax)) THEN BEGIN
		OK=0
		IF (iprint GT 0) THEN PRINT,'quadrange does not cross grid',$
					' and (x1,y1) is not inside.
		GOTO, finished
	ENDIF	; i.e. if quad does not cross grid, and (x1,y1) is not inside.


	IF (AcrossXmin EQ 1) THEN BEGIN
	   IF (AcrossXmax EQ 1) THEN BEGIN
	      IF (BcrossXmin EQ 1) THEN BEGIN
		 IF (BcrossXmax EQ 1) THEN BEGIN		; Case 30
		    ic=30
		    x1=xmax	& y1=yAxmax
		    x2=xmin	& y2=yAxmin
		    x3=xmin
		    x4=xmax	& y4=y3
		    IF (CcrossXmin EQ 1) OR (CcrossXmax EQ 1) OR $ 
			(DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		 ENDIF ELSE BEGIN				; Case 31
		    ic=31
		    x4=x3	& y4=y3
		    x1=xmax	& y1=yAxmax
		    x2=xmin	& y2=yAxmin
		    x3=xmin
		    x5=xmax	& y5=yCxmax
		    IF (CcrossXmin EQ 1) OR (CcrossXmax EQ 0) OR $
			(DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		 ENDELSE
	      ENDIF ELSE BEGIN
		 IF (CcrossXmin EQ 1) THEN BEGIN
		    IF (x1 LT xmin) THEN BEGIN			; Case 1
		       ic=1
		       x1=xmin	& y1=yCxmin
		       x2=xmin	& y2=yAxmin
		       x3=xmax	& y3=yAxmax
		       x4=xmax	& y4=yCxmax
		       IF (BcrossXmax EQ 1) OR (CcrossXmax EQ 0) OR $
			  (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE BEGIN				; Case 32
		       ic=32
		       x1=xmax	& y1=yAxmax
		       x2=xmin	& y2=yAxmin
		       x3=xmin	& y3=yCxmin
		       x4=xmax	& y4=yCxmax
		       IF (BcrossXmax EQ 1) OR (CcrossXmax EQ 0) OR $
 			  (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDELSE
		 ENDIF ELSE IF (CcrossXmax EQ 1) THEN BEGIN	; Case 2
		    ic=2
		    x5=x4	& y5=y4
		    x1=xmin
		    x2=xmin	& y2=yAxmin
		    x3=xmax	& y3=yAxmax
		    x4=xmax	& y4=yCxmax
		    IF (BcrossXmax EQ 1) OR (DcrossXmin EQ 0) OR $
			(DcrossXmax EQ 1) THEN OK=0
		 ENDIF ELSE BEGIN				; Case 3
		    ic=3
		    x1=xmin
		    x2=xmin	& y2=yAxmin
		    x3=xmax	& y3=yAxmax
		    x4=xmax
		    IF (BcrossXmax EQ 1) OR (DcrossXmin EQ 0) OR $
			(DcrossXmax EQ 0) THEN OK=0
		 ENDELSE
	      ENDELSE
	   ENDIF ELSE BEGIN
	      IF (BcrossXmin EQ 1) THEN BEGIN
		 IF (BcrossXmax EQ 1) THEN BEGIN
		    IF (CcrossXmax EQ 1) THEN BEGIN		; Case 18
		       ic=18
		       x6=x4	& y6=y4
		       x2=xmin	& y2=yAxmin
		       x3=xmin
		       x4=xmax	& y4=y3
		       x5=xmax	& y5=yCxmax
		       IF (CcrossXmin EQ 1) OR (DcrossXmin EQ 1) OR $
			  (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE BEGIN				; Case 19
		       ic=19
		       x2=xmin	& y2=yAxmin
		       x3=xmin
		       x4=xmax	& y4=y3
		       x5=xmax	& y5=y1
		       IF (CcrossXmin EQ 1) OR (DcrossXmin EQ 1) OR $
			  (DcrossXmax EQ 0) THEN OK=0
		    ENDELSE
		 ENDIF ELSE BEGIN
		    IF (CcrossXmax EQ 1) THEN BEGIN		; Case 20
		       ic=20
		       x4=x3	& y4=y3
		       x2=xmin	& y2=yAxmin
		       x3=xmin
		       x5=xmax	& y5=yCxmax
		       x6=xmax	& y6=y1
		       IF (CcrossXmin EQ 1) OR (DcrossXmin EQ 1) OR $
			  (DcrossXmax EQ 0) THEN OK=0
		    ENDIF ELSE BEGIN				; Case 21
		       ic=21
		       x5=x4	& y5=y4
		       x4=x3	& y4=y3
		       x2=xmin	& y2=yAxmin
		       x3=xmin
		       IF (CcrossXmin EQ 1) OR (DcrossXmin EQ 1) OR $
			  (DcrossXmax EQ 1) THEN OK=0
		    ENDELSE
		 ENDELSE
	      ENDIF ELSE BEGIN
		 IF (BcrossXmax EQ 1) THEN BEGIN
		    IF (CcrossXmin EQ 1) THEN BEGIN		; Case 4
		       ic=4
		       x3=x2	& y3=y2
		       x1=xmin	& y1=yCxmin
		       x2=xmin	& y2=yAxmin
		       x4=xmax	& y4=y3
		       x5=xmax	& y5=yCxmax
		       IF (CcrossXmax EQ 0) OR (DcrossXmin EQ 1) OR $
			  (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE IF (CcrossXmax EQ 1) THEN BEGIN	; Case 5
		       ic=5
		       x6=x4	& y6=y4
		       x3=x2	& y3=y2
		       x1=xmin
		       x2=xmin	& y2=yAxmin
		       x4=xmax	& y4=y3
		       x5=xmax	& y5=yCxmax
		       IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE BEGIN				; Case 6
		       ic=6
		       x3=x2	& y3=y2
		       x1=xmin
		       x2=xmin	& y2=yAxmin
		       x4=xmax	& y4=y3
		       x5=xmax	& y5=y1
		       IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 0) THEN OK=0
		    ENDELSE
		 ENDIF ELSE BEGIN
		    IF (CcrossXmin EQ 1) THEN BEGIN
		       IF (CcrossXmax EQ 1) THEN BEGIN		; Case 22
			  ic=22
			  x2=xmin	& y2=yAxmin
			  x3=xmin	& y3=yCxmin
			  x4=xmax	& y4=yCxmax
			  x5=xmax	& y5=y1
			  IF (DcrossXmin EQ 1) OR (DcrossXmax EQ 0) THEN OK=0
		       ENDIF ELSE BEGIN
			  IF (x1 LT xmin) THEN BEGIN		; Case 7
			     ic=7
			     x4=x3	& y4=y3
			     x3=x2	& y3=y2
			     x1=xmin	& y1=yCxmin
			     x2=xmin	& y2=yAxmin
			     IF (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
			  ENDIF ELSE BEGIN			; Case 23
			     ic=23
			     x2=xmin	& y2=yAxmin
			     x3=xmin	& y3=yCxmin
			     IF (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
			  ENDELSE
		       ENDELSE
		    ENDIF ELSE BEGIN
		       IF (CcrossXmax EQ 1) THEN BEGIN		; Case 8
			  ic=8
			  x4=x3		& y4=y3
			  x3=x2		& y3=y2
			  x1=xmin
			  x2=xmin	& y2=yAxmin
			  x5=xmax	& y5=yCxmax
			  x6=xmax	& y6=y1
			  IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 0) THEN OK=0
		       ENDIF ELSE BEGIN				; Case 9
			  ic=9
			  x5=x4		& y5=y4
			  x4=x3		& y4=y3
			  x3=x2		& y3=y2
			  x1=xmin
			  x2=xmin	& y2=yAxmin
			  IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 1) THEN OK=0
		       ENDELSE
		    ENDELSE
		 ENDELSE
	      ENDELSE
	   ENDELSE
	ENDIF ELSE BEGIN
	   IF (AcrossXmax EQ 1) THEN BEGIN
	      IF (BcrossXmax EQ 1) THEN BEGIN			; Case 33
		 ic=33
		 x1=xmax	& y1=yAxmax
		 x3=xmax
		 IF (BcrossXmin EQ 1) OR (CcrossXmin EQ 1) OR (CcrossXmax EQ 1) $
			OR (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
	      ENDIF ELSE IF (CcrossXmax EQ 1) THEN BEGIN
		 IF (x1 LT xmax) THEN BEGIN			; Case 24
		    ic=24
		    x2=xmax	& y2=yAxmax
		    x3=xmax	& y3=yCxmax
		    IF (BcrossXmin EQ 1) OR (CcrossXmin EQ 1) OR $
			(DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		 ENDIF ELSE BEGIN				; Case 34
		    ic=34
		    x1=xmax	& y1=yAxmax
		    x4=xmax	& y4=yCxmax
		    IF (BcrossXmin EQ 1) OR (CcrossXmin EQ 1) OR $
			(DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		 ENDELSE
	      ENDIF ELSE BEGIN					; Case 25
		 ic=25
		 x2=xmax	& y2=yAxmax
		 x3=xmax	& y3=y4
		 IF (BcrossXmin EQ 1) OR (CcrossXmin EQ 1) OR $
		    (DcrossXmin EQ 1) OR (DcrossXmax EQ 0) THEN OK=0
	      ENDELSE
	   ENDIF ELSE BEGIN
	      IF (BcrossXmin EQ 1) THEN BEGIN
		 IF (BcrossXmax EQ 1) THEN BEGIN 
		    IF (CcrossXmin EQ 1) THEN BEGIN		; Case 10
		       ic=10
		       x1=xmin	& y1=yCxmin
		       x2=xmin
		       x3=xmax
		       x4=xmax	& y4=yCxmax
		       IF (CcrossXmax EQ 0) OR $
			  (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE IF (CcrossXmax EQ 1) THEN BEGIN	; Case 11
		       ic=11
		       x5=x4	& y5=y4
		       x1=xmin
		       x2=xmin
		       x3=xmax
		       x4=xmax	& y4=yCxmax
		       IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE BEGIN				; Case 12
		       ic=12
		       x1=xmin
		       x2=xmin
		       x3=xmax
		       x4=xmax
		       IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 0) THEN OK=0
		    ENDELSE
		 ENDIF ELSE BEGIN
		    IF (CcrossXmin EQ 1) THEN BEGIN		; Case 13
		       ic=13
		       x1=xmin	& y1=yCxmin
		       x2=xmin
		       IF (CcrossXmax EQ 1) OR $
			  (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE IF (CcrossXmax EQ 1) THEN BEGIN	; Case 14
		       ic=14
		       x1=xmin
		       x2=xmin
		       x4=xmax	& y4=yCxmax
		       x5=xmax	& y5=y1
		       IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 0) THEN OK=0
		    ENDIF ELSE BEGIN				; Case 15
		       ic=15
		       x1=xmin
		       x2=xmin
		       IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDELSE
		 ENDELSE
	      ENDIF ELSE BEGIN
		 IF (BcrossXmax EQ 1) THEN BEGIN
		    IF (CcrossXmax EQ 1) THEN BEGIN		; Case 26
		       ic=26
		       x5=x4	& y5=y4
		       x3=xmax
		       x4=xmax	& y4=yCxmax
		       IF (CcrossXmin EQ 1) OR $
			  (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		    ENDIF ELSE BEGIN				; Case 27
		       ic=27
		       x3=xmax
		       x4=xmax
		       IF (CcrossXmin EQ 1) OR $
			  (DcrossXmin EQ 1) OR (DcrossXmax EQ 0) THEN OK=0
		    ENDELSE
		 ENDIF ELSE BEGIN
		    IF (CcrossXmin EQ 1) THEN BEGIN
		       IF (CcrossXmax EQ 1) THEN BEGIN		; Case 16
			  ic=16
			  x1=xmin
			  x2=xmin	& y2=yCxmin
			  x3=xmax	& y3=yCxmax
			  x4=xmax
			  IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 0) THEN OK=0
		       ENDIF ELSE BEGIN				; Case 17
			  ic=17
			  x3=x4		& y3=y4
			  x1=xmin
			  x2=xmin	& y2=yCxmin
			  IF (DcrossXmin EQ 0) OR (DcrossXmax EQ 1) THEN OK=0
		       ENDELSE
		    ENDIF ELSE BEGIN
		       IF (CcrossXmax EQ 1) THEN BEGIN		; Case 28
			  ic=28
			  x4=xmax	& y4=yCxmax
			  x5=xmax	& y5=y1
			  IF (DcrossXmin EQ 1) OR (DcrossXmax EQ 0) THEN OK=0
		       ENDIF ELSE BEGIN				; Case 29
			  ic=29
			  IF (DcrossXmin EQ 1) OR (DcrossXmax EQ 1) THEN OK=0
		       ENDELSE
		    ENDELSE
		 ENDELSE
	      ENDELSE
	   ENDELSE
	ENDELSE

	IF (ic EQ 1) THEN GOTO, quadrangle
	IF (ic EQ 2) THEN GOTO, pentagon
	IF (ic EQ 3) THEN GOTO, quadrangle
	IF (ic EQ 4) THEN GOTO, pentagon
	IF (ic EQ 5) THEN GOTO, hexagon
	IF (ic EQ 6) THEN GOTO, pentagon
	IF (ic EQ 7) THEN GOTO, quadrangle
	IF (ic EQ 8) THEN GOTO, hexagon
	IF (ic EQ 9) THEN GOTO, pentagon
	IF (ic EQ 10) THEN GOTO, quadrangle
	IF (ic EQ 11) THEN GOTO, pentagon
	IF (ic EQ 12) THEN GOTO, quadrangle
	IF (ic EQ 13) THEN GOTO, triangle
	IF (ic EQ 14) THEN GOTO, pentagon
	IF (ic EQ 15) THEN GOTO, quadrangle
	IF (ic EQ 16) THEN GOTO, quadrangle
	IF (ic EQ 17) THEN GOTO, triangle
	IF (ic EQ 18) THEN GOTO, hexagon
	IF (ic EQ 19) THEN GOTO, pentagon
	IF (ic EQ 20) THEN GOTO, hexagon
	IF (ic EQ 21) THEN GOTO, pentagon
	IF (ic EQ 22) THEN GOTO, pentagon
	IF (ic EQ 23) THEN GOTO, quadrangle
	IF (ic EQ 24) THEN GOTO, quadrangle
	IF (ic EQ 25) THEN GOTO, triangle
	IF (ic EQ 26) THEN GOTO, pentagon
	IF (ic EQ 27) THEN GOTO, quadrangle
	IF (ic EQ 28) THEN GOTO, pentagon
	IF (ic EQ 29) THEN GOTO, quadrangle
	IF (ic EQ 30) THEN GOTO, quadrangle
	IF (ic EQ 31) THEN GOTO, pentagon
	IF (ic EQ 32) THEN GOTO, quadrangle
	IF (ic EQ 33) THEN GOTO, triangle
	IF (ic EQ 34) THEN GOTO, quadrangle

	OK=0
	PRINT,' Quadrangle has not fallen into any category! (Area=0)'


triangle:
	a1=x2-x1
	a2=y2-y1
	b1=x3-x1
	b2=y3-y1
	Area=ABS(a1*b2-a2*b1)/2.
	IF (OK EQ 0) THEN PRINT,' Logical problem with triangle, case ',ic
	IF (iprint GT 0) THEN BEGIN
		x=[x1,x2,x3,x1]
		y=[y1,y2,y3,y1]
		oplot, x, y, psym=-1
		PRINT,'Hit return to continue '
		READ, a
	ENDIF
	GOTO, finished

quadrangle:
	a1=x2-x1
	a2=y2-y1
	b1=x3-x1
	b2=y3-y1
	c1=x4-x1
	c2=y4-y1
	Area=ABS(a1*b2-a2*b1)/2.+ABS(b1*c2-b2*c1)/2.
	IF (OK EQ 0) THEN PRINT,' Logical problem with quadrangle, case ',ic
	IF (iprint GT 0) THEN BEGIN
		x=[x1,x2,x3,x4,x1]
		y=[y1,y2,y3,y4,y1]
		oplot, x, y, psym=-1
		PRINT,'Hit return to continue '
		READ, a
	ENDIF
	GOTO, finished

pentagon:
	a1=x2-x1
	a2=y2-y1
	b1=x3-x1
	b2=y3-y1
	c1=x4-x1
	c2=y4-y1
	d1=x5-x1
	d2=y5-y1
	Area=ABS(a1*b2-a2*b1)/2.+ABS(b1*c2-b2*c1)/2.+ABS(c1*d2-c2*d1)/2.
	IF (OK EQ 0) THEN PRINT,' Logical problem with pentagon, case ',ic
	IF (iprint GT 0) THEN BEGIN
		x=[x1,x2,x3,x4,x5,x1]
		y=[y1,y2,y3,y4,y5,y1]
		oplot, x, y, psym=-1
		PRINT,'Hit return to continue '
		READ, a
	ENDIF
	GOTO, finished

hexagon:
	a1=x2-x1
	a2=y2-y1
	b1=x3-x1
	b2=y3-y1
	c1=x4-x1
	c2=y4-y1
	d1=x5-x1
	d2=y5-y1
	e1=x6-x1
	e2=y6-y1
	Area=ABS(a1*b2-a2*b1)/2.+ABS(b1*c2-b2*c1)/2.+ABS(c1*d2-c2*d1)/2. $
		+ABS(d1*e2-d2*e1)/2.
	IF (OK EQ 0) THEN PRINT,' Logical problem with hexagon, case ',ic
	IF (iprint GT 0) THEN BEGIN
		x=[x1,x2,x3,x4,x5,x6,x1]
		y=[y1,y2,y3,y4,y5,y6,y1]
		oplot, x, y, psym=-1
		PRINT,'Hit return to continue '
		READ, a
	ENDIF
	GOTO, finished

finished:
	IF (OK EQ 0) THEN BEGIN
		area=0.
		IF (iprint GT 0) THEN PRINT,'Error in given quadrangle'
	ENDIF

	IF (iprint GT 0) THEN oldymin=ymin

	x1=x01
	x2=x02
	x3=x03
	x4=x04
	y1=y01
	y2=y02
	y3=y03
	y4=y04

;	PRINT,'[Emin,Emax,Emax,Emin]=',y

	RETURN, area
	END
PRO par,w,var,var2
;
; Started by Thomas HANSEN
; Macro to show non-variable parameters of D20's numors
; Call: PAR,W
; Last modified 13-Jun-97
;
Take_datp,datp
IF n_elements(var) EQ 0 THEN BEGIN
  FOR i=0,39 DO PRINT,strmid(string(i),6,2),' ',strmid(datp.par_txt(i)+string(datp.p(i)),0,75)
ENDIF ELSE BEGIN
  IF n_elements(var2) EQ 0 THEN BEGIN 
    FOR i=0,30 DO PRINT,strmid(string(i),6,2),' ',strmid(datp.par_txt(i)+string(datp.pv(i,var)),0,75)
  ENDIF ELSE BEGIN
    FOR i=0,30 DO PRINT,strmid(string(i),6,2),' ',strmid(datp.par_txt(i)+string(datp.pv(i,var,var2)),0,75)
  ENDELSE
ENDELSE
END
PRO pathcal
;******* ****
;**
common calibration
common c_rdid , dzap, pzap, pzip
;common d20

  if (sys_dep('MACHINE') eq 'mac') THEN BEGIN
    PATHCAL =P_LAMBDA()+'CALIBRATION:'
  ENDIF ELSE PATHCAL =P_LAMBDA()+'CALIBRATION/'
  if (sys_dep('MACHINE') eq 'vms') THEN PATHCAL =strmid(P_LAMBDA(),0,strlen(P_LAMBDA())-1)+ '.' +CALIBRATION +']'
  if (sys_dep('MACHINE') eq 'win') THEN PATHCAL =P_LAMBDA()+'CALIBRATION\' 
END
pro p_did_calib, inst, lamp_b1
;** ***********
;**
common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
common calib,base0,lirlist,listcal,comment,curfil,bacur,nwork,swork,filen,lodfil,minst,ytext
common c_lamp_font

if (!D.flags and 65536) eq 0 then RETURN
IF xregistered('CALIB') gt 0 then widget_control,bad_id=ii,base0,map=1 $
ELSE BEGIN

CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN & endif
      MINST   = strlowcase(inst)
      CD,PATHCAL,current=mee & lirlist = findfile() & CD,mee
      IF n_elements(CURFIL) eq 0 THEN CURFIL  =  MINST+'.cal'
      IF n_elements(SWORK)  eq 0 THEN swork   =' 0 '
      LODFIL=CURFIL

base0	=  widget_base  (title = 'CALIBRATION',resource_name='lamptouch',/column)
base0a	=  widget_base  (base0  ,/row   ,frame=4)
base0a1 =  widget_base  (base0a ,/column)
bid	=  widget_label (base0a1,value = PATHCAL,font=ft_b_bigger)
listcal	=  widget_list  (base0a1,value = lirlist,ysize = 7	,uvalue = [-88,394,1])

base0a1 =  widget_base  (base0a ,/column)
bid     =  widget_label (base0a1,value = 'for '+inst ,font=ft_b_bigger)
	   put_logo	,widget_base(base0a1,/row)
bid	=  widget_button(base0a1,value = 'Load selected file'	,uvalue = [-88,394,2])
bid	=  widget_button(base0a1,value = 'NO Calibration'	,uvalue = [-88,394,3])
bid	=  widget_button(base0a1,value = 'EXIT'			,uvalue = [-88,399  ])

base03	=  widget_base  (base0  ,/row)
bid	=  widget_label (base03 ,value = 'Current Calibration: '  ,font=ft_b_normal)
bacur	=  widget_label (base03 ,value = string(replicate(45b,30)),font=ft_b_normal)
comment	=  widget_label (base0  ,value = string(replicate(45b,60)),font=ft_b_normal)

base0b	=  widget_base  (base0  ,/column,frame=4)
bid	=  widget_label (base0b ,value = 'Make a Calibration file from raw data',font=ft_b_bigger)
base06	=  widget_base  (base0b ,/row)
bid	=  widget_label (base06 ,value='Wk_space #')
NWORK	=  widget_text  (base06 ,/editable,xsize =3 ,value= SWORK	,font=ft_propor)
bid	=  widget_label (base06 ,value='Comment:')
YTEXT	=  widget_text  (base06 ,/editable,xsize =15,value= 'no comment',font=ft_propor)
base07	=  widget_base  (base0b ,/row)
bid	=  widget_label (base07 ,value ='Filename:')
FILEN	=  widget_text  (base07 ,/editable,xsize =20,value='new'+MINST+'.cal',font=ft_propor)
bid	=  widget_button(base07 ,value = 'MAKE'			,uvalue = [-88,394,4])

widget_control  ,base0 , group_leader = lamp_b1,/realize  & put_logo
widget_control  ,bacur , set_value    = curfil
XMANAGER,'CALIB',base0 , event_handler='LAMP_EVENT_PARSER',/just_reg
ENDELSE
RETURN
END

pro p_did_calev, event,uv
;** ***********
;**
common calibration
common calib

widget_control,comment,bad_id=ii,set_value=' '
CASE uv(2) of
;**SELECT
   1:	   lodfil = lirlist(event.index)
;**LOAD
   2:begin P_DID_CALOD, minst,lodfil, flg
	   IF flg THEN begin curfil=lodfil & com= curfil+ ' is accepted ...' & endif $
		  ELSE begin curfil='None' & com= 'Bad Calibration file !!!' & endelse
	   widget_control,bacur  ,bad_id=ii, set_value=curfil
	   widget_control,comment,bad_id=ii, set_value=com
     end
;**NONE
   3:begin curfil='None' &  P_DID_CALOD, minst & widget_control,bacur,bad_id=ii,set_value=curfil & END
;**MAKE
   4:begin widget_control,nwork,bad_id=ii,get_value=swork & swork=strtrim(swork(0),2)
	   on_ioerror,mis_w & flg=0 & wn=fix(swork) & if (wn gt 0) and (wn le 20) then flg=1 & mis_w:
	   widget_control,filen,bad_id=ii,get_value=filnm & filnm=strtrim(filnm(0),2)
	   widget_control,ytext,bad_id=ii,get_value=text  & text =strtrim(text (0),2)
	   if flg eq 0 then com='Bad workspace number !!!' $
	   else begin	    P_DID_CALOD, minst,filnm,flg,wn , text
	   		    if flg eq  0 then com='Problem writting ' +filnm  +' !!!' else $
			    if flg eq -1 then com='Access denied:'    +pathcal+' !!!' $
					 else com= filnm+' write success ...'
      			    CD,PATHCAL,current=mee & lirlist = findfile() & CD,mee
			    widget_control,listcal , bad_id=ii,set_value=lirlist
	   endelse  &  widget_control,comment,bad_id=ii, set_value=com
     end
ELSE:
ENDCASE
RETURN
END

pro p_did_calod,minst,file, OK ,wn ,text ,LIST=list
;** ***********
;**
@lamp.cbk
common calibration

IF n_elements(wn)   eq 1 then mot='MAKE'  else $
IF n_elements(file) eq 1 then mot='READ'  else $
IF keyword_set(list)     then mot='LIST'  else mot='CLEAR'

OK=-1 & in=0 & out=0 & line=''
IF mot eq 'READ' then begin on_ioerror,mis_read & OPENR,in ,pathcal+file,/get_lun
			    mis_read:  if in le 0 then mot='CLEAR'			& endif
IF mot eq 'MAKE' then begin on_ioerror,mis_writ & OPENW,out,pathcal+file,/get_lun
			    tmp=1 & ii=execute('tmp=float(W'+strtrim(string(wn),2)+')')	& endif
ok=0

IF mot eq 'LIST' then begin tmp=FINDFILE(pathcal+'*'+minst+'*' ,count=cc)
			    j  =strlen  (pathcal) & k=strpos(tmp(0),pathcal)
			    if cc gt 0 then begin   print,'Note:  CALIBRATION [,file="myfile"] [,/nocal] [,/list]'
						    print,'Actual calibration files:'
						    for i=0,cc-1  do if k lt 0 then print,tmp(i) $
						    else    print,strmid(tmp(i),j,30)
			    endif
endif else $
CASE  minst of
'd16':  IF mot eq 'READ' then begin cal_d16 =fltarr(62,14)
	   on_ioerror,misd16
	   inf_d16 =[file]
	   READF,  in,line  & READF,in,cal_d16		 & ok=1
	   misd16: IF ok eq 0 THEN  cal_d16 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd16
	   PRINTF, out,'Calib(62*14) ' +systime()+' '+text
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd16:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d16 =0

'd1a':  IF mot eq 'READ' then begin cal_d1a =fltarr(25)  & ang_d1a=findgen(25)
	   on_ioerror,misd1a
	   inf_d1a =[file]
	   READF,  in,line  & READF,in,ang_d1a,cal_d1a	 & ok=1
	   misd1a: IF ok eq 0 THEN  cal_d1a =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd1a
	   PRINTF, out,'Calib(25)    ' +systime()+' '+text
	   TAKE_DATP,p,w=wn
	   PRINTF, out, P.x
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd1a:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d1a =0

'd2b':  IF mot eq 'READ' then begin cal_d2b =fltarr(64)  & ang_d2b=findgen(64)
	   on_ioerror,misd2b
	   inf_d2b =[file]
	   READF,  in,line  & READF,in,format='(64F8.3)',ang_d2b
			      READF,in,format='(64F8.3)',cal_d2b	 & ok=1
	   misd2b: IF ok eq 0 THEN  cal_d2b =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd2b
	   PRINTF, out,'Calib(64)    ' +systime()+' '+text
	   TAKE_DATP,p,w=wn
	   PRINTF, out, P.x
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd2b:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d2b =0

'd20': IF mot eq 'READ' then begin cal_d20 =fltarr(1600)& ang_d20=findgen(1600)
 	   on_ioerror,misd20
     ;flag_d20(6)=1
     IF file EQ ' default' THEN BEGIN
       inf_d20=[file,'not loaded','autod20.cal']
     ENDIF ELSE BEGIN
 	     READF,  in,line 
       cal_d20 =fltarr(1600,long(strmid(line,6,4))/1600)
       READF,in,ang_d20,cal_d20	 & ok=1
				  	IF N_ELEMENTS(inf_d20) EQ 0 THEN inf_d20=[file,line,'manualchoice'] ELSE inf_d20(0:1)=[file,line]
       print,'New Calibration file loaded: ', inf_d20(0)
       print,inf_d20(1)
       if N_ELEMENTS(inf_d20) GE 3 THEN IF inf_d20(2) EQ 'autochoice' THEN BEGIN
         PRINT,'D20 automatic default calibration by the right file - attention to wavelength!' 
       ENDIF ELSE BEGIN
         PRINT,'D20 manual choice of calibration file - pay attention to wavelength!' 
         inf_d20(2) = 'manualchoice'
       ENDELSE
 	     misd20: IF ok eq 0 THEN  cal_d20 =0
     ENDELSE
   ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd20
					  IF N_ELEMENTS(inf_d20) GE 1 THEN inf_d20=inf_d20(0:2)
 	     PRINTF, out,'Calib('+strtrim(string(N_ELEMENTS(tmp)),2)+')  ' +systime()+' '+text
 	     TAKE_DATP,p,w=wn
 	     PRINTF, out, P.x(0:1599,0,0)
 	     PRINTF, out, tmp & ok=1 & mikd20:
     ENDIF ELSE BEGIN
								cal_d20 =0
								inf_d20(0:2)=['','','']
								print,'NO Calibration',STRLEN(inf_d20(0))
        ;flag_d20(6)=0
					ENDELSE

'in13': IF mot eq 'READ' then begin cal_in13=fltarr(70)
	   on_ioerror,misin13
	   inf_in13=[file]
	   READF,  in,line  & READF,in,cal_in13		 & ok=1
	   misin13:IF ok eq 0 THEN  cal_in13=0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin13 & mikin13:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in13=0

'in6':  IF mot eq 'READ' then begin
	   on_ioerror,misin6
	   inf_in6 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in6 =fltarr(sz)  & idx_in6=intarr(sz) & shf_in6=intarr(sz)
	   READF,in,cal_in6	& READF,in,idx_in6 & READF,in,shf_in6 & ok=1
	   idx_in6=where(idx_in6 ge 0)
	   misin6: IF ok eq 0 THEN  cal_in6 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin  on_ioerror,mikin6
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf & ok=1 & mikin6:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in6 =0

'in5':  IF mot eq 'READ' then begin
	   on_ioerror,misin5
	   inf_in5 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in5 =fltarr(sz)  & idx_in5=intarr(sz) & shf_in5=intarr(sz)
	   READF,in,cal_in5	& READF,in,idx_in5 & READF,in,shf_in5 & ok=1
	   idx_in5=where(idx_in5 ge 0)
	   misin5: IF ok eq 0 THEN  cal_in5 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin5
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf & ok=1 & mikin5:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in5 =0
ELSE:
ENDCASE
mis_writ:
IF in  gt 0 THEN FREE_LUN,in
IF out gt 0 THEN FREE_LUN,out
RETURN
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION phi2q, w_in

; Transforms scattering angle on x-axis to Q, assuming elastic scattering. 
;
;DIMENSIONS:
; w_in=w_out(nspectra)
;
;COMMAND SYNTAX:
; w10=phi2q(w9)
;								KHA 10/2/99
;-------------------------------------------------------------------------------
;*******************************************************************************

	COMMON c_lamp_access, inst

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start phi2q:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set constants

	IF (inst EQ 'D7') THEN lambda=datp.p(4) $
			ELSE lambda=datp.p(21)
	k=2.*!pi/lambda

	IF (iprint GT 0) THEN PRINT,'End of "set constants" section'

;-------------------------------------------------------------------------------
;transform phi to Q

	phi=ABS(datp.x)*!pi/180.

	x_out=k*SQRT(2.*(1.-COS(phi)))

	IF (iprint GT 0) THEN PRINT,'End of "transform phi to Q" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	w_out=w_in

	datp.x=x_out
	datp.x_tit='Q (A^-1)'
	s=STRTRIM(STRING(lambda),2)	& n=STRPOS(s,'.')+4	& s=STRMID(s,0,n)
	datp.other_tit=datp.other_tit+' -pq('+s+')'

finished:

	IF (iprint GT 0) THEN PRINT,'End phi2q:'

	give_datp, datp

	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION phi2qtof, w_in
;
; input: 1-D data, phi as x-axis, energy transfer as y-axis, e.g. output
; from elastic.pro
; transforms x-axis to Q
;							KHA 10/2/98
;
;-------------------------------------------------------------------------------
;*******************************************************************************

	COMMON c_lamp_access, inst

	take_datp, datp

;-------------------------------------------------------------------------------
;calculate Q axis

	phi=datp.x*!pi/180.
	eps=w_in
	a=2.0719

	IF (inst EQ 'D7') THEN lambda=datp.p(4) $
			ELSE lambda=datp.p(21)
	Ei=81.8066/lambda^2
	Q=SQRT((2.*Ei-eps-2.*SQRT(Ei*(Ei-eps))*COS(phi))/a)
	datp.x=Q

	datp.x_tit='Q  (A^-1)'

	give_datp, datp

	RETURN, w_in
	END


;pro phif


PRO fpol,dbns,dbs,fns,nfns,fs,nfs,trans,etrans,phi,ephi,f,ef,r,er

COMMON local,nparams,whatwid

dbns=float(dbns)
dbs=float(dbs)
fns=float(fns)
nfns=float(nfns)
fs=float(fs)
nfs=float(nfs)

print,dbns,dbs,fns,nfns,fs,nfs

;now calculate shim transmission

itrans=dbns/dbs
edbs=sqrt(dbs)/dbs
edbns=sqrt(dbns)/dbns
eitrans=itrans*sqrt(edbs^2+edbns^2)
efitrans=sqrt(edbs^2+edbns^2)/itrans

trans=1./itrans
etrans=trans*efitrans

; calculate phi
phi=nfns/(itrans*((nfs+fs))) 

enfns=sqrt(nfns)/nfns
eb=sqrt(nfs+fs)/(nfs+fs)

ephi=phi*sqrt(enfns^2+eb^2+efitrans^2)

;now calculate flipper efficiency

top=fns+nfns-(nfs+fs)*itrans

fetop=sqrt(fns+nfns+nfs+fs)/top

bot=2.*nfns-(nfs+fs)*itrans
febot=sqrt(2.*nfns+nfs+fs)/bot

f=top/bot
ef=f*sqrt(fetop^2+febot^2)

f=1-f

; calculate flipping ratio

r=nfns/fns

er=r*sqrt((1/nfns)+1/(fns))

print,'transmission= ',trans,'+/- ',etrans
print,'phi= ',phi,' +/- ',ephi
print,'f= ',f,' +/- ',ef
print,'ratio= ',r,' +/- ',er


end

pro startmono_event,event
;** ************
;**
	COMMON local,nparams,whatwid
	con='x'
	par1=lonarr(6)
        
      	wWidget =  Event.top

        WIDGET_CONTROL,event.id,get_uvalue=gv

        if(gv eq 'quit')then widget_control,event.top,/destroy

        if(gv eq 'do')then begin
	FOR i=0,nparams-1 DO BEGIN
          Widget_Control, whatwid(i), GET_VALUE=gv
;	  print,i,gv
	  if(i lt 6) then  par1(i)=STRTRIM(gv,2)	  
        ENDFOR
;	print,par1

	fpol,par1(0),par1(1),par1(2),par1(3),par1(4),par1(5)$
        ,trans,etrans,phi,ephi,f,ef,r,er

	
	Widget_Control, whatwid(nparams-4), SET_VALUE=strtrim(string(trans),2)+' +/- ' $
	+strtrim(string(etrans),2)
	Widget_Control, whatwid(nparams-3), SET_VALUE=strtrim(string(phi  ),2)+' +/- ' $
	+strtrim(string(ephi),2)
	Widget_Control, whatwid(nparams-2), SET_VALUE=strtrim(string(f    ),2)+' +/- ' $
	+strtrim(string(ef),2)
	Widget_Control, whatwid(nparams-1), SET_VALUE=strtrim(string(r    ),2)+' +/- ' $
	+strtrim(string(er),2)
	
	
	
	
endif	
end


pro send_command,event,i
;** ************
;**
        COMMON local,nparams,whatwid
	Widget_Control, event.id, GET_VALUE=gv
	gv=STRTRIM(gv,2)
	command=fix(gv)
;	  
;	print, gv
;
end

PRO phif
COMMON local,nparams,whatwid
nparams=10
whatwid=intarr(nparams)
result='xxx'
param=strarr(nparams)
                param_text=STRARR(nparams)
		param_text(0) ='Direct beam no shim'
		param_text(1) ='Direct beam with shim'
		param_text(2) ='Reflection flipper on no shim'
		param_text(3) ='Reflection flipper off no shim'
		param_text(4) ='Reflection flipper on with shim'
		param_text(5) ='Reflection flipper off with shim'
		
		
		
		param_text(6) ='Shim transmission'
		
		param_text(7) ='Polariser+analyser efficiency'
		param_text(8) ='Flipper Efficiency'
                param_text(9) ='Flipping ratio'
		
		
;               defaults
                		
		param(0)='106780'
		param(1)='107507'
		param(2)='4425'
		param(3)='157423'
		param(4)='76173'
		param(5)='76290'
		param(6)='----'
		param(7)='----'
		param(8)='----'
		param(9)='----'
		
		
		
		
                D17S_BASE_4=Widget_Base(UNAME='D17S_BASE_4',TITLE="Enter Values" $
			,SPACE=3,XPAD=5,YPAD=3,/COLUMN)
		D17S_BASE_0=Widget_Base(D17S_BASE_4,UNAME='D17S_BASE_0' $
			,SPACE=3,XPAD=3,YPAD=3,/ROW)
		D17S_BASE_1=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_1' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)




		D17S_BASE_2=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_2' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
		D17S_BASE_3=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_3' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)

                gbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='gbutton' $
			, value='Do it',uvalue='do')
		fbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='fbutton' $
			, value='Quit',uvalue='quit')
			
		
				
			
		FOR i=0,nparams-1 DO BEGIN 
  			name= 'D17S_LABEL_'+STRTRIM(STRING(i+1),2) 
  			dummy = Widget_Label(D17S_BASE_2, UNAME=name,XOFFSET=3   $ 
     	 		,YOFFSET=3, SCR_YSIZE=33,/ALIGN_LEFT ,VALUE=param_text(i) $
			,FONT=ft_smaller)
  	  	ENDFOR
		

		
		FOR i=0,nparams-1 DO BEGIN 
  			name='D17S_VALUE_'+STRTRIM(STRING(i+1),2) 
  			 whatwid(i)= Widget_Text(D17S_BASE_3, UNAME=name ,FRAME=1  $ 
     			,XOFFSET=3 ,YOFFSET=3 ,SCR_XSIZE=150 ,SCR_YSIZE=29 $
			,/EDITABLE ,VALUE=STRTRIM(STRING(param(i)),2) $
			,FONT=ft_smaller) 
  	  	ENDFOR


		Widget_Control,/REALIZE,D17S_BASE_3
		loadct, 5
		XMANAGER, 'startmono',D17S_BASE_0,/JUST_REG

end
PRO plotdfil,xmin,xmax,$
             thresh=thresh,max=max,min=min,cmin=cmin,cmax=cmax,$
             ps=ps,noprint=noprint,printer=printer,eps=eps,$
             multi=multi,scale=scale,w=w11,x=x11,overlap=overlap,$
             portrait=portrait,landscape=landscape,ysize=ysize,$
             xoffset=xoffset,yoffset=yoffset,intensity=intensity,$
             fwhm=width,position=position,cellno=cellno,$
             intersection=intersection,interwidth=interwidth,points=points,$
             sum=w10

;+
; EXAMPLE :
;  plotdfil,59,61,max=25000,/ps,/nop
;-
Window,0
IF NOT KEYWORD_SET(portrait)  THEN portrait =0
IF NOT KEYWORD_SET(landscape) THEN landscape=0
IF NOT KEYWORD_SET(landscape) AND NOT  KEYWORD_SET(portrait) THEN BEGIN
  IF KEYWORD_SET(eps) THEN portrait=1 ELSE landscape=1
ENDIF
IF NOT KEYWORD_SET(multi)     THEN multi    =5
IF NOT KEYWORD_SET(xoffset)   THEN BEGIN
  IF KEYWORD_SET(portrait)THEN xoffset=1 ELSE xoffset=1
ENDIF
IF NOT KEYWORD_SET(yoffset)   THEN BEGIN
  IF KEYWORD_SET(portrait)THEN yoffset=0 ELSE yoffset=10
ENDIF
IF NOT KEYWORD_SET(ysize)     THEN BEGIN
  IF KEYWORD_SET(landscape)THEN ysize=19./multi ELSE ysize=29./multi
ENDIF
IF NOT KEYWORD_SET(overlap)   THEN overlap  =1
IF NOT KEYWORD_SET(scale)     THEN scale    =2.5
IF KEYWORD_SET(eps) THEN ps=1 ELSE eps      =0
white=0
IF N_ELEMENTS(xmax) EQ 0 THEN IF NOT KEYWORD_SET(cmax) THEN xmax=159.9 ELSE xmax=FLOAT(cmax)/10.
IF N_ELEMENTS(xmin) EQ 0 THEN IF NOT KEYWORD_SET(cmin) THEN xmin=0.    ELSE xmin=FLOAT(cmin)/10.
;print,xmin,xmax
IF NOT KEYWORD_SET(max)  THEN max=25000.
IF NOT KEYWORD_SET(cmin) THEN cmin=FLOOR(xmin*10)-10
IF NOT KEYWORD_SET(cmax) THEN cmax=CEIL (xmax*10)+10
cmin=cmin>0
cmax=cmax<1599
IF N_ELEMENTS(cellno)       NE 1600 THEN cellno      =INDGEN(1600)
IF N_ELEMENTS(position)     NE 1600 THEN position    =fltarr(1600)
IF N_ELEMENTS(width)        NE 1600 THEN width       =fltarr(1600)
IF N_ELEMENTS(intersection) NE 1600 THEN intersection=fltarr(1600)
IF N_ELEMENTS(interwidth)   NE 1600 THEN interwidth  =fltarr(1600)
cell=0
overlap=FLOAT(overlap)
range=((xmax-xmin)+FLOAT(2.*overlap*((multi-1))))/FLOAT(multi)
PRINT,((xmax-xmin))/FLOAT(multi),FLOAT(overlap*((multi-1))),range
ang1=xmin+2.*overlap
cells=((cmax-cmin+4*(overlap*10)*((multi+1))))/multi
cel1=cmin+2*(overlap*10)
!P.Multi=[0,1,multi]
IF keyword_set(ps) THEN BEGIN
    IF KEYWORD_SET(eps) THEN extension='.eps' ELSE  extension='.ps' 
    mydevice=!D.NAME
    set_plot,'ps'
    psnam='def_'+strcompress(cmin,/RE)+'_'+strcompress(cmax,/re)+extension
    PRINT,'Create ',psnam, ' - XSIZE (range*scale) =',range*scale,' cm, YOFFSET=',yoffset, 'cm'
    device,portrait=portrait,landscape=landscape,/color,fil=psnam,encapsulated=eps,$
           YSIZE=ysize,XSIZE=range*scale,xoffset=xoffset,yoffset=yoffset,/SYMBOL
ENDIF
colors,color
TVLCT,[0,255,0,0],[0,0,255,0],[0,0,0,255]
color=[0,1,2,3,255]
xmin=ROUND(xmin*100)/100.
;print,xmin,xmax
xmax=ROUND(xmax*100)/100.
;print,xmin,xmax
w10=FLTARR(CEIL(xmax-xmin)*100)
w11=FLTARR(CEIL(xmax-xmin)*100,5)
x11=INTARR(CEIL(xmax-xmin)*100,5)
FOR page=1,multi DO BEGIN
 ang0=ang1-2.*overlap
 ang1=ang0+range
 plot,w10*0.,yr=[0,max],xr=[ang0,ang1],color=color(0),background=color(4),FONT=0,XSTYLE=1,yticklen=1,ygridstyle=2,yminor=0,xminor=9
 cel0=cel1-6*(10*overlap)
 cel1=cel0+cells
 ;print,cel0,cel1
 ;cel0=ang0*10.-10.
 ;cel1=ang1*10.+10.
 ;print,ang0,ang1
 ;print,cel0,cel1
 print,page,ang0,ang1,range,cel0,cel1,cells
 PRINT,'   cell, left, center, right, fwhm,  center-i/10.,  totalw,   maxw'
 ;PRINT,cel0,cmin,cmax,cel1
 for i=ROUND(cel0>cmin),ROUND(cel1<cmax) do BEGIN
  filnam='C'+STRMID(STRCOMPRESS(i+10000,/RE),1,4)+'.def'
  ;PRINT,filnam
  bid=FindFile(filnam,COUNT=counts)
  IF counts GE 1 THEN BEGIN
    OPENR,in,filnam,/GET_LUN
    number=0
    READF,in,number
    ;print,'Read ',filnam,number, ' points'
    x=FLTARR(number)
    w=FLTARR(number)
    READF,in,x,w
    FREE_LUN,in
    xnew=ROUND(x*100)/100.
    ;help,wnew,w,x,xnew
    wnew=INTERPOL(w,x,xnew)
    w=wnew
    x=xnew
    oplot,x,w,line=ABS(((i mod 32)<1)-1),color=color(i mod 4)
    maxw=max(w,pos)
    pos=x(pos)
    IF maxw ge max/2. AND pos LT ang1 AND pos GT ang0 THEN BEGIN
      XYOUTS, pos,maxw,charsize=.6, ' '+strcompress(i,/re),align=.0,orient=90,color=color(i mod 4),FONT=0
      IF N_ELEMENTS(thresh) EQ 1600 THEN BEGIN
        IF KEYWORD_SET(intensity) THEN BEGIN
          XYOUTS,pos,maxw,charsize=.5, strcompress(round(thresh(i)),/re)+' '+strcompress(round(TOTAL(w)/intensity),/re)+'    ',align=1,orient=90,color=color(i mod 4),FONT=0
        ENDIF ELSE BEGIN
          XYOUTS,pos,maxw,charsize=.5, strcompress(round(thresh(i)),/re)+'    ',align=1,orient=90,color=color(i mod 4),FONT=0
        ENDELSE
      ENDIF ELSE BEGIN
        IF KEYWORD_SET(intensity) THEN BEGIN
          XYOUTS,pos,maxw,charsize=.5, strcompress(round(TOTAL(w)/intensity),/re)+'    ',align=1,orient=90,color=color(i mod 4),FONT=0
        ENDIF 
      ENDELSE
    ENDIF
    IF i GT cell THEN BEGIN
     integral=FLTARR(number)
     FOR j=0,number-1 DO integral(j)=integral((j-1)>0)+w(j)
     totalw=integral(number-1)
     center=INTERPOL(x,integral,[totalw/2.,totalw/4.,totalw*3./4.])
     center=center(0)
     maxw=max(w,pos)
     x1=max(x(where(x le x(pos) AND w lt maxw/2)>0),ind)
     y1=w(where(x le x(pos) AND w lt maxw/2)>0)
     y1=y1(ind>0)
     x2=min(x(where(x lt x(pos) AND w gt maxw/2)>0),ind)
     y2=w(where(x le x(pos) AND w gt maxw/2)>0)
     y2=y2(ind>0)
     left=(x2-x1)/(y2-y1)*(maxw/2-y1)+x1
     x1=min(x(where(x gt x(pos) AND w lt maxw/2)>0),ind)
     y1=w(where(x ge x(pos) AND w lt maxw/2)>0)
     y1=y1(ind>0)
     x2=max(x(where(x gt x(pos) AND w gt maxw/2)>0),ind)
     y2=w(where(x ge x(pos) AND w gt maxw/2)>0)
     y2=y2(ind>0)
     right=(x2-x1)/(y2-y1)*(maxw/2-y1)+x1
     fwhm=  right-left
     width(i)=fwhm
     position(i)=center-i/10.
     PRINT,i,left,center,right,fwhm,center+i/10.,totalw,maxw
     for j=0,number-1 do begin
      k=ROUND(100*(x(j)-xmin))
      IF k GE 0 AND k LT N_ELEMENTS(W10) THEN BEGIN
        w10(k)=w10(k)+w(j)
        IF w(j) GT w11(k,0) THEN BEGIN
          w11(k,4)=w11(k,3)
          w11(k,3)=w11(k,2)
          w11(k,2)=w11(k,1)
          w11(k,1)=w11(k,0)
          w11(k,0)=w(j)
          x11(k,4)=x11(k,3)
          x11(k,3)=x11(k,2)
          x11(k,2)=x11(k,1)
          x11(k,1)=x11(k,0)
          x11(k,0)=i
        ENDIF ELSE IF w(j) GT w11(k,1) THEN BEGIN
            w11(k,4)=w11(k,3)
            w11(k,3)=w11(k,2)
            w11(k,2)=w11(k,1)
            w11(k,1)=w(j)
            x11(k,4)=x11(k,3)
            x11(k,3)=x11(k,2)
            x11(k,2)=x11(k,1)
            x11(k,1)=i
          ENDIF ELSE IF w(j) GT w11(k,2) THEN BEGIN
              w11(k,4)=w11(k,3)
              w11(k,3)=w11(k,2)
              w11(k,2)=w(j)
              x11(k,4)=x11(k,3)
              x11(k,3)=x11(k,2)
              x11(k,2)=i
            ENDIF ELSE IF w(j) GT w11(k,3) THEN BEGIN
                w11(k,4)=w11(k,3)
                w11(k,3)=w(j)
                x11(k,4)=x11(k,3)
                x11(k,3)=i
              ENDIF ELSE IF w(j) GT w11(k,4) THEN BEGIN
                  w11(k,4)=w(j)
                  x11(k,4)=i
                ENDIF 
      ENDIF
    ENDFOR
    cell=i
   ENDIF
  ENDIF
 ENDFOR
 IF NOT KEYWORD_SET(points) THEN points=0
 IF NOT KEYWORD_SET(min) THEN min=0
 oplot,Findgen(N_ELEMENTS(W10))/100.+xmin,w10,color=color(1),psym=points,min_value=min,max_value=max
 oplot,Findgen(N_ELEMENTS(W10))/100.+xmin,TOTAL(w11(*,0:2),2),color=color(2),psym=points,min_value=min,max_value=max
 oplot,Findgen(N_ELEMENTS(W10))/100.+xmin,TOTAL(w11(*,0:4),2),color=color(3),psym=points,min_value=min,max_value=max
 axis,yr=[0,max],xr=[ang0,ang1],color=color(0),FONT=0,XSTYLE=1,yticklen=.1/(range*scale)<0.002,/noerase,xminor=9
ENDFOR
IF keyword_set(ps) THEN BEGIN
    device,/close
    set_plot,mydevice
    IF NOT keyword_set(noprint) THEN BEGIN
      IF NOT keyword_set(printer) THEN bid=sys_dep('PRT_DEF',psnam)
      IF NOT keyword_set(printer) THEN printer='dj1_d20'
      bid=sys_dep('PRINT',printer,psnam)
    ENDIF
ENDIF
PRINT,'Intersection Analysis'
points=N_ELEMENTS(w11(*,0))
FOR i=1,points-1 DO BEGIN
  ;PRINT,i
  IF x11(i,0) GT x11(i-1,0) THEN BEGIN
    z2=w11(i,0)
    z1=w11(i-1,1)
    y2=w11(i,1)
    y1=w11(i-1,0)
    delta=(z1-y1)/(y2-y1-z2+z1)
    intersection(x11(i,0))=x11(i-1,0)/10.-(i-1.+delta)/100.+xmin
    interwidth(x11(i-1,0))=-(intersection(x11(i-1,0))-intersection(x11(i,0)))
    PRINT,'At',  intersection(x11(i,0)),' between',x11(i,0),' and',x11(i-1,0),interwidth(x11(i-1,0))
  ENDIF 
ENDFOR

END
PRO plotd,Win,c,pos,d,thresh,datp=datp,bg=bg,max=max,sum=sum,x=x,$
    noprint=noprint
;+
; procedure plotd is called by def2.pro and defil.pro
; for plotting detector scans,
; for writing detector cell reply functions in *.def files,
; and for calculating the different total counts on particular positions
;
; Written by  Thomas C Hansen,          1998
; Modified by Thomas C Hansen, November 2000
;-
  IF NOT KEYWORD_SET(datp) THEN take_datp,datp 
  IF NOT KEYWORD_SET(bg)   THEN bg='?'
  IF     KEYWORD_SET(max)  THEN yr=[0,max]
  cells=N_ELEMENTS(c)
  points=N_ELEMENTS(Win(0,*))
  TVLCT,[0,255,0,0],[0,0,255,0],[0,0,0,255]
  tmp=0.
  sumtotal=total((Win)>0,1)
  sum3=sumtotal*0.
  sum5=sumtotal*0.
  sum7=sumtotal*0.
  FOR i=0,points-1 DO BEGIN
    maxc=MAX(Win    (*,i),cell)
    sum3(i)=TOTAL(Win((cell-1)>0:(cell+1)<(cells-1),i)>0)
    sum5(i)=TOTAL(Win((cell-2)>0:(cell+2)<(cells-1),i)>0)
    sum7(i)=TOTAL(Win((cell-3)>0:(cell+3)<(cells-1),i)>0)
  ENDFOR
  ; x=datp.p(14)-pos-d+datp.pv(13,*)
  IF NOT KEYWORD_SET(x) THEN x=datp.x
  IF NOT KEYWORD_SET(max) THEN maxi=MAX(sumtotal) ELSE maxi=max
  PLOT,x,sumtotal,yr=[0,maxi],COLOR=0,BACKGROUND=255,$
    TITLE='2th-om:'+STRCOMPRESS(pos)+' bg:'+STRCOMPRESS(bg),$
    SUB=datp.other_tit,XTIT=datp.w_tit
  OPLOT,x,sum3,color=1
  OPLOT,x,sum5,color=2
  OPLOT,x,sum7,color=3
  FOR i=0,cells-1 DO BEGIN
    filnam='C'+STRMID(STRCOMPRESS(c(i)+10000,/RE),1,4)+'.def'
    bid=FINDFILE(filnam,COUNT=counts)
    wfromfile=1
    IF counts GE 1 THEN BEGIN
      OPENR,in,filnam,/GET_LUN
      number=0
      READF,in,number
      xfromfile=FLTARR(number)
      wfromfile=FLTARR(number)
      READF,in,xfromfile,wfromfile
      FREE_LUN,in
    ENDIF
    nozerin=WHERE(wfromfile GT 0,nbnozerin)
    nozer  =WHERE(Win(i,*) GT 0,nbnozer)
    IF nbnozerin GE 1 THEN IF nbnozer GE 1 THEN BEGIN 
      IF NOT KEYWORD_SET(noprint) THEN PRINT,i,c(i),nbnozerin,nbnozer,[TOTAL(wfromfile(nozerin)-$
          TOTAL(wfromfile(nozerin([0,nbnozerin-1])))/2.),$
          wfromfile(nozerin([0,nbnozerin-1])),TOTAL(Win(i,nozer)-$
          TOTAL(Win(i,nozer([0,nbnozer-1])))/2.),$
          REFORM(Win(i,nozer([0,nbnozer-1])),2)]
      ; IF N_ELEMENTS(wfromfile) LE 1 OR TOTAL(wfromfile(nozerin)-$
      ;     TOTAL(wfromfile(nozerin([0,nbnozerin-1])))/2.) LE TOTAL(Win(i,nozer)-$
      ;     TOTAL(Win(i,nozer([0,nbnozer-1])))/2.) THEN BEGIN
      IF NOT KEYWORD_SET(noprint) THEN BEGIN
        IF N_ELEMENTS(wfromfile) LE 1 $
        ;OR TOTAL(wfromfile(nozerin)-TOTAL(wfromfile(nozerin([0,nbnozerin-1])))/2.) LE TOTAL(Win(i,nozer)-TOTAL(Win(i,nozer([0,nbnozer-1])))/2.) $
        OR nbnozer GE nbnozerin THEN BEGIN
          PRINT,filnam
          OPENW,out,filnam,/GET_LUN
          PRINTF,out,nbnozer
          PRINTF,out,x(nozer),REFORM(Win(i,nozer),nbnozer)
          FREE_LUN,out
        ENDIF
      ENDIF
    ENDIF ELSE IF nbnozer GE 1 THEN BEGIN 
      IF NOT KEYWORD_SET(noprint) THEN BEGIN
        PRINT,filnam
        OPENW,out,filnam,/GET_LUN
        PRINTF,out,nbnozer
        PRINTF,out,x(nozer),REFORM(Win(i,nozer),nbnozer)
        FREE_LUN,out
     ENDIF
    ENDIF
    OPLOT,x,Win(i,*),COLOR=c(i) MOD 4  ; ,LINE=c(i) mod 4
    maxw=MAX(Win(i,*),pos)
    pos=x(pos)
    IF maxw ge MAX(Win)/2. THEN BEGIN
      XYOUTS, pos,maxw,charsize=.6, ' '+strcompress(c(i),/re),align=.0,orient=90,color=c(i) mod 4
      IF N_ELEMENTS(thresh) EQ 1600 THEN BEGIN
        XYOUTS, pos,maxw,charsize=.5, strcompress(round(thresh(c(i))),/re)+'    ',align=1,orient=90,color=c(i) mod 4
      ENDIF
    ENDIF
  ENDFOR
  sum=sumtotal
END
PRO plotnclick,win,x=x,xsize=xsize,ysize=ysize,xrange=xrange,yrange=yrange

IF NOT KEYWORD_SET(x) THEN BEGIN
  take_datp,datp
  x=datp.x
ENDIF
w=win(*,0)
help,x,w
IF N_ELEMENTS(x) NE N_ELEMENTS(w) THEN x=INDGEN(N_ELEMENTS(w))
colors,color
IF NOT KEYWORD_SET(xsize) THEN xsize=1400
IF NOT KEYWORD_SET(ysize) THEN ysize=900
IF NOT KEYWORD_SET(xrange) THEN xrange=[min(x),max(x)]
IF NOT KEYWORD_SET(yrange) THEN yrange=[min(w),max(w)]
Window,1,xsize=xsize,ysize=ysize
range=WHERE(x GE xrange(0) AND X LE xrange(1))
xx=x(range)
w=w(range)
PLOT,xx,w,xstyle=1,ystyle=1,back=color(4),col=color(0),yrange=yrange
x1=!x.crange(0)
x2=!x.crange(1)
y1=!y.crange(0)
y2=!y.crange(1)
x=x1
y=y1
PRINT,'Click outside the plotrange to stop!'
first=1
REPEAT BEGIN 
  CURSOR,x,y,/DOWN 
  IF x GE x1 AND x LE x2 AND y GE y1 AND y LE y2 THEN BEGIN 
    bid=MIN(ABS(xx-x),i)
    PLOTS,[x,x],[y,w(i)],COLOR=COLOR(2)
    ;xyouts,x,y,STRCOMPRESS(x)+STRCOMPRESS(w(i)),$
    ;           COLOR=COLOR(1),CHARSIZE=.6 
    IF first EQ 0 THEN PLOTS,[oldx,x],[oldw,w(i)],COLOR=COLOR(5) ELSE first=0
    PRINT,x,w(i)
    oldx=x
    oldw=w(i)
  ENDIF
ENDREP UNTIL x LT x1 OR x GT x2 OR y LT y1 OR y GT y2 

END
PRO plotnzoom,w,new=new

TVLCT,[0,255,0,0],[0,0,255,0],[0,0,0,255]
IF KEYWORD_SET(new) THEN plot,w,xstyle=1,ystyle=1
cursor,x1,y1,/down 
plots,[0,N_ELEMENTS(w)-1],[y1,y1]
plots,[x1,x1],[min(w),max(w)]
cursor,x2,y2,/up 
plot,w,xstyle=1,xr=[x1,x2],yr=[y1,y2]

END
FUNCTION pn1,in_wk
;
; Read in pn1 xyz files gjk March95
;
@lamp.cbk

ON_IOERROR,misopen
	wwout =11
	
OPENR,in,in_wk,/get_lun
	ix=0
	iy=0
	iz=0
	minx  =1024
	miny  =1024
	wwout =7
	maxx  =-minx
	maxy  =-miny
	wwout =0
	wwout =INTARR(minx,miny)
	lnths =SIZE  (wwout)
	
	if lnths(0) eq 2 then begin
	
	ON_IOERROR,miseof
	
	WHILE (1) DO BEGIN
	
		READF,in,ix,iy,iz
		
		IF (ix lt lnths(1)) and (iy lt lnths(2)) and $
		   (ix ge 0)	    and (iy ge 0)   THEN BEGIN
			wwout(ix,iy)=iz
			if ix lt minx then minx=ix
			if ix gt maxx then maxx=ix
			if iy lt miny then miny=iy
			if iy gt maxy then maxy=iy
		ENDIF
	ENDWHILE
	
	miseof: FREE_LUN,in

;	Trim data to size
	wwout=wwout(minx:maxx , miny:maxy)
	lnths=SIZE(wwout)
	wks  =STRTRIM(STRING(one),2)
	iii=EXECUTE( 'x'+wks+'=INDGEN(lnths(1))+minx' )
	iii=EXECUTE( 'y'+wks+'=INDGEN(lnths(2))+miny' )
	
	x_tit(one)='E - TOTAL (Mev)'
	y_tit(one)='DELTA - E (Mev)'
	w_tit(one)= in_wk
	
	endif else wwout=8

misopen:RETURN, wwout
END
; $Id: poly_fit.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

FUNCTION POLY_FIT,X,Y,NDEGREE,YFIT,YBAND,SIGMA,A
;+
; NAME:
;	POLY_FIT
;
; PURPOSE:
;	Perform a least-square polynomial fit with optional error estimates.
;
;	This routine uses matrix inversion.  A newer version of this routine,
;	SVDFIT, uses Singular Value Decomposition.  The SVD technique is more
;	flexible, but slower.
;
;	Another version of this routine, POLYFITW, performs a weighted
;	least square fit.
;
; CATEGORY:
;	Curve fitting.
;
; CALLING SEQUENCE:
;	Result = POLY_FIT(X, Y, NDegree [,Yfit, Yband, Sigma, A] )
;
; INPUTS:
;	X:	The independent variable vector.
;
;	Y:	The dependent variable vector, should be same length as x.
;
;     NDegree:	The degree of the polynomial to fit.
;
; OUTPUTS:
;	POLY_FIT returns a vector of coefficients with a length of NDegree+1.
;
; OPTIONAL OUTPUT PARAMETERS:
;	Yfit:	The vector of calculated Y`s.  These values have an error 
;		of + or - Yband.
;
;	Yband:	Error estimate for each point = 1 sigma
;
;	Sigma:	The standard deviation in Y units.
;
;	A:	Correlation matrix of the coefficients.
;
; COMMON BLOCKS:
;	None.
;
; SIDE EFFECTS:
;	None.
;
; MODIFICATION HISTORY:
;	Written by: George Lawrence, LASP, University of Colorado,
;		December, 1981.
;
;	Adapted to VAX IDL by: David Stern, Jan, 1982.
;
;-
;	ON_ERROR,2		;RETURN TO CALLER IF ERROR
	XX = X*1.		;BE SURE X IS FLOATING OR DOUBLE
	N = N_ELEMENTS(X) 	;SIZE
	IF N NE N_ELEMENTS(Y) THEN $
	  message,'X and Y must have same # of elements'
;
	M = NDEGREE + 1			;# OF ELEMENTS IN COEFF VEC.
;
	A = DBLARR(M,M)		;COEFF MATRIX
	B = DBLARR(M)		;WILL CONTAIN SUM Y * X^J
	Z = DBLARR(N)+1.
;
	A(0,0) = N
	B(0) = TOTAL(Y)
;
	FOR P = 1,2*NDEGREE DO BEGIN ;POWER LOOP.
		Z=Z*XX			;Z IS NOW X^P
		IF P LT M THEN B(P) = TOTAL(Y*Z) ;B IS SUM Y*XX^J
		SUM = TOTAL(Z)
		FOR J= 0 > (P-NDEGREE), NDEGREE < P DO A(J,P-J) = SUM
	  END			;END OF P LOOP.
;
	A = INVERT(A)		;INVERT MATRIX.
;
;			IF A IS MULTIPLIED BY SIGMA SQUARED, IT IS THE
;			CORRELATION MATRIX.
;
	C = float(b) # a	;Get coefficients

;
	IF (N_PARAMS(0) LE 3) THEN RETURN,C	;EXIT IF NO ERROR ESTIMATES.
;
	YFIT = FLTARR(N)+C(0)	;INIT YFIT
	FOR K = 1,NDEGREE DO YFIT = YFIT + C(K)*(XX^K) ;FORM YFIT.
;
	IF (N_PARAMS(0) LE 4) THEN RETURN,C	;EXIT IF NO ERROR ESTIMATES.
;
	IF N GT M THEN $
		SIGMA = TOTAL((YFIT-Y) ^ 2) / (N-M) $	;COMPUTE SIGMA
	   ELSE	SIGMA = 0.
;
	A=A* SIGMA		;GET CORREL MATRIX
;
	SIGMA = SQRT(SIGMA)
	YBAND = FLTARR(N)+ A(0,0)	;SQUARED ERROR ESTIMATES
;
	FOR P = 1,2*NDEGREE DO BEGIN
	  Z = XX ^ P
	  SUM = 0.
	  FOR J=0 > (P - NDEGREE), NDEGREE < P DO SUM = SUM + A(J,P-J)
	  YBAND = YBAND + SUM * Z ;ADD IN ERRORS.
	END		;END OF P LOOP
	YBAND = SQRT(ABS(YBAND))	;ERROR ESTIMATES
	RETURN,C
END
function positive, w_in
;******* ********
;**
;** Transform an integer*2 unsigned array in a long positive one.
;** Call: W1 = POSITIVE ( W1 )

    s=size(w_in)
    if s(s(0)+1) eq 2 then begin

	index=where ( w_in lt 0 )
	
	w_in       =long  (w_in)
	
	if index(0) ge 0 then w_in(index)=65536+ w_in(index)
	
    endif
    	
    return, w_in
    
end
; $Id: gaussfit.pro,v 1.1 1993/04/02 19:43:31 idl Exp $

PRO	pow_funct,X,A,F,PDER,C=C
; 2qtrue = 2qexp.-ZER => 2tsim = 2tcalc + ZER
; Up to now only
; Refinement of intensity and width of each peak, wavelength, zeroshift & background 
 ON_ERROR,2                       ;Return to caller if an error occurs
 aaa=0
 jj=0
 jjj=0
 FOR j=0,N_ELEMENTS(c.f)-1 DO IF c.f(j) GT 0 THEN BEGIN
    aaa=[aaa,c.p(jj)] 
    jj=jj+1
 ENDIF ELSE BEGIN
    aaa=[aaa,a(jjj)] 
    jjj=jjj+1
 ENDELSE  ; free and fixed parameters split up in two arrays
 aaa=aaa(1:N_ELEMENTS(aaa)-1)
 peaks=C.n(3)                                                ; number of peaks
 lambda=aaa(TOTAL(c.n(0:7)) :TOTAL(c.n(0:8))-1)              ; wavelength
 scale =aaa(TOTAL(c.n(0:11)):TOTAL(c.n(0:12))-1)             ; wavelength
 ZER   =aaa(TOTAL(c.n(0:8)) :TOTAL(c.n(0:9))-1)              ; FullProf : 2ttrue = 2texp.-ZER => 2tsim = 2tcalc + ZER
 ZER   =ZER(0)                                               ; only one zeroshift and wavelenght yet
 b     =[aaa(TOTAL(c.n(0:6)):TOTAL(c.n(0:7))-1),0,0,0,0,0,0] ; background polynom
 FOR j=0,N_ELEMENTS(lambda)-1 DO BEGIN
   l=lambda(j)
   s=scale(j<(N_ELEMENTS(scale)-1))
   t=aaa(TOTAL(c.n(0:2)):TOTAL(c.n(0:3))-1)
   t=2*asin(l/2/t)*180/!pi + ZER                          ; peak position  (2theta)
                                                          ; ATTENTION : d > l/2 !! (esp. in fits if l is refinable)
   AA=FLTARR(peaks,3)                                     ; Gaussian parameters
   AA(*,0)=aaa(TOTAL(c.n(0:4)):TOTAL(c.n(0:5))-1)         ; peak intensity (integrated)
   AA(*,1)=t                                              ; peak position  (2theta)
   AA(*,2)=aaa(TOTAL(c.n(0:5)):TOTAL(c.n(0:6))-1)         ; peak width     (FWHM(2theta))
   Z = FLTARR(N_ELEMENTS(X),N_ELEMENTS(a(*,0))) + 10.
  	FOR i=0,N_ELEMENTS(AA(*,0))-1 DO IF AA(i,2) GT 0 THEN Z(*,i)=(X-AA(i,1))/AA(i,2)*2*SQRT(2*ALOG(2)) 	;GET Z
   IF j EQ 0 THEN EZ = FLTARR(N_ELEMENTS(X))
  	FOR i=0,N_ELEMENTS(AA(*,0))-1 DO BEGIN
     EZ=EZ+s*2*SQRT(ALOG(2)/!pi)/AA(i,2)*AA(i,0)*EXP(-(Z(*,i)*(ABS(Z(*,i)) LE 7.))^2/2.)*(ABS(Z(*,i)) LE 7.) ; GAUSSIAN PART IGNORE SMALL TERMS
   ENDFOR
 ENDFOR
	F = EZ + b(0) + b(1)*X + b(2)*X^2 + b(3)*X^3 + b(4)*X^4 + b(5)*X^5;FUNCTIONS.
	IF N_PARAMS(0) LE 3 THEN BEGIN
	  RETURN 
	ENDIF;NEED PARTIAL?
;
; These values  are not yet correct! (still from former GAUSS_FUNC)
;
	PDER = FLTARR(N_ELEMENTS(X),N_ELEMENTS(A)) ;YES, MAKE ARRAY.
 FOR j=0,peaks-1 DO BEGIN ; integrated intensity
	  ;PDER(0,0) = EZ		;COMPUTE PARTIALS
 ENDFOR
 FOR j=peaks,2*peaks-1 DO BEGIN ; FWHM
	  if a(2) ne 0. then PDER(0,1) = A(0) * EZ * Z/A(2)
	  PDER(0,2) = PDER(*,1) * Z
 ENDFOR
 FOR j=2*peaks,2*peaks+c.bg-1 DO BEGIN ; background
	  IF c.bg GE 1 THEN PDER(*,j)   = 1.
	  IF c.bg GE 2 THEN PDER(*,j+1) = X
	  IF c.bg GE 3 THEN PDER(*,j+2) = X^2
	  IF c.bg GE 4 THEN PDER(*,j+3) = X^3
	  IF c.bg GE 5 THEN PDER(*,j+4) = X^4
	  IF c.bg GE 6 THEN PDER(*,j+5) = X^5
 ENDFOR
 j=2*peaks+c.bg   ; wavelength
 j=2*peaks+c.bg+1 ; zeroshift
	RETURN
END

FUNCTION powder,   w,sigmaa=sigmaa,uvw=u,hkl=h,abc=abc,lambda=l,$
                   int=i,bg=b,x=x,fwhm=f,scale=scale,$
                   zeroshift=z,dspacing=d,multiplicity=K,$
                   twotheta=t,iterations=iterations,key=key,$
                   fixedblock=fixedblock,correct=correct,datp=datp_,pseudo=pseudo,true=true 
;+
;uvw=[],1.92,-1.40,0.40579]&i=0&f=0&d=0&h=hkl(/si)&s=1000&a=5.43094&l=1.304947&b=1000&z=-.3494
; w3=powder(y2,in=i,fw=f,/cor,ab=a,la=l,sc=s,bg=b,tw=t,ds=d,m=m,it=3,u=u,hk=h,datp=datp2,/pseudo)
;-
on_error,2                      ;Return to caller if an error occurs
IF NOT KEYWORD_SET(true) THEN true=0
IF NOT KEYWORD_SET(pseudo) THEN pseudo=0
colors,color,pseudo=pseudo,true=true
IF NOT KEYWORD_SET(datp_) THEN TAKE_DATP,datp ELSE datp=datp_
x=datp.x
IF NOT KEYWORD_SET(b_damp) THEN b_damp=.5
lambda=l
l=max(l)
IF KEYWORD_SET(h) THEN BEGIN 
  IF N_ELEMENTS(h) GE 3 THEN d=abc(0)/SQRT(h(0,*)^2+h(1,*)^2+h(2,*)^2)
 ; h=h(*,where(d gt l/2))
  tmp=(where(d gt l/2))
  h=h(*,reverse(tmp(sort(d(tmp)))))
ENDIF
d=d(where(d gt l/2))
d=d(reverse(sort(d)))
d=REFORM(d,N_ELEMENTS(d))
t=2*asin(l/2/d)*180/!pi
l=lambda
t=t(WHERE(t LE datp.x(N_ELEMENTS(datp.x)-1)))
d=d(WHERE(t LE datp.x(N_ELEMENTS(datp.x)-1)))
IF KEYWORD_SET(h) THEN h=h(*,(WHERE(t LE datp.x(N_ELEMENTS(datp.x)-1))))
ind=(UNIQ(t,sort(t)))
K=intarr(N_ELEMENTS(d))
FOR j=0,N_ELEMENTS(d)-1 DO BEGIN
    bid=WHERE(t EQ t(j),count)
    K(j)=K(j)+count
ENDFOR
IF NOT KEYWORD_SET(z)         THEN z=0         ; Zeroshift like FullProf : 2tcalc=2tsim-Z
IF NOT KEYWORD_SET(scale)     THEN scale=1     
IF N_ELEMENTS(scale) EQ 1     THEN BEGIN
  scale=scale(0)
  IF scale LE 0  THEN scale=1  
ENDIF
IF NOT KEYWORD_SET(u)         THEN u=[0,0,.3]  ; 
IF NOT KEYWORD_SET(b)         THEN b=0
IF NOT KEYWORD_SET(f)         THEN f=fwhm(u,t(ind)) ELSE IF N_ELEMENTS(f) EQ N_ELEMENTS(d) THEN f=f(ind) ELSE f=fwhm(u,t(ind))
IF NOT KEYWORD_SET(i)         THEN i=K(ind)         ELSE IF N_ELEMENTS(i) EQ N_ELEMENTS(d) THEN i=i(ind) ELSE i=K(ind)& 
Params     =[REFORM(h(0,*),N_ELEMENTS(h(0,*))),REFORM(h(1,*),N_ELEMENTS(h(1,*))),REFORM(h(2,*),N_ELEMENTS(h(2,*))),d(ind),t(ind),i,f,b,l,z,abc,u,scale]
NbOfParams =[N_ELEMENTS(h(0,*)),N_ELEMENTS(h(0,*)),N_ELEMENTS(h(0,*)),N_ELEMENTS(d(ind)),N_ELEMENTS(t(ind)),N_ELEMENTS(i),N_ELEMENTS(f),N_ELEMENTS(b),N_ELEMENTS(l),N_ELEMENTS(z),N_ELEMENTS(abc),N_ELEMENTS(u),N_ELEMENTS(scale)]
TotalNbOfParams=NbOfParams
NbOfParams([0,1,2,4,10,11])=0
IF NOT KEYWORD_SET (fixedblock) THEN fixedBlock =[1,1,1,1,1,0,0,1,0,0,1,1,1]
IF N_ELEMENTS(fixedblock) NE 13 THEN fixedBlock =[1,1,1,1,1,0,0,1,0,0,1,1,1]
block = (WHERE  (NbOfParams GT 0,count)) 
index=TotalNbOfParams
altindex=NbOfParams
fixed=INTarr(TOTAL(NbOfParams))
FOR j=0,N_ELEMENTS(TOTALNbOfParams)-1 DO index(j)=TOTAL(TotalNbOfParams(0:j))
FOR j=0,N_ELEMENTS(NbOfParams)-1 DO altindex(j)=TOTAL(NbOfParams(0:j))
FOR j=0,N_ELEMENTS(block)-1 DO IF N_ELEMENTS(a) LT 1 THEN a=Params(index(block(j))-NbOfParams(block(j)):index(block(j))-1) ELSE BEGIN
    a=[a,Params(index(block(j))-NbOfParams(block(j)):index(block(j))-1)]  
ENDELSE
FOR j=0,N_ELEMENTS(block)-1 DO BEGIN
    fixed(altindex(block(j))-NbOfParams(block(j)):altindex(block(j))-1) = fixedBlock(block(j))
ENDFOR
comment =   ['h','k','l','dspacings','twotheta','intensities','widths','background','wavelength','zeroshift','unit cell','Cagliotti','scale']
par=0
var=0
old=a
FOR j=0,N_ELEMENTS(fixed)-1 DO IF fixed(j) EQ 0 THEN var=[var,a(j)] ELSE par=[par,a(j)] ; free and fixed parameters split up in two arrays
var =var(1:N_ELEMENTS(var)-1) ; ... and if nothing is to be refined ???
par=par(1:N_ELEMENTS(par)-1)
help,var,par
key={p:par,f:fixed,n:nbOfParams}

pow_funct,x,var,result,c=key

e=sqrt(result)
mod_datp,datp,'e',e
IF NOT KEYWORD_SET(datp_) THEN give_datp,datp
plot,x,w,tit='1st guess',/xstyle,back=color(4),col=color(3)
oplot,x,result,color=color(1)

; free and fixed parameters split up in two arrays => put it together again ...
a=0
jj=0
jjj=0
FOR j=0,N_ELEMENTS(fixed)-1 DO IF fixed(j) GT 0 THEN BEGIN
    a=[a,par(jj)] 
    jj=jj+1
ENDIF ELSE BEGIN
    a=[a,var(jjj)] 
    jjj=jjj+1
ENDELSE  ; free and fixed parameters split up in two arrays
a=a(1:N_ELEMENTS(a)-1)
peaks=nbofparams(3)                                       ; number of peaks
l    =a(TOTAL(nbofparams(0:7)):TOTAL(nbofparams(0:8))-1)  ; wavelength
scale=a(TOTAL(nbofparams(0:11)):TOTAL(nbofparams(0:12))-1); wavelength
Z    =a(TOTAL(nbofparams(0:8)):TOTAL(nbofparams(0:9))-1)  ; FullProf : 2ttrue = 2texp.-ZER => 2tsim = 2tcalc + ZER
Z    =Z(0)                                                ; only one zeroshift and wavelenght yet
t    =2*asin(l(0)/2/d)*180/!pi + Z                        ; peak position  (2theta)
                                                          ; ATTENTION : C.d > l/2 !! (esp. in fits if l is refinable)
b    =[a(TOTAL(nbofparams(0:6)):TOTAL(nbofparams(0:7))-1)]; background polynom
i=FLTARR(N_ELEMENTS(d))
f=i
FOR j=0,N_ELEMENTS(d)-1 DO BEGIN
    i(j)=a(TOTAL(nbofparams(0:4))+WHERE(d(ind) EQ d(j),count))
    f(j)=a(TOTAL(nbofparams(0:5))+WHERE(d(ind) EQ d(j),count))
ENDFOR
i=i/k
print,'  h, k, l,          d,     2theta,       fwhm,  intensity, mult.
for j=0,n_elements(d)-1 do print,FORMAT="(3I3,4F12.3,I3)",h(0,j),h(1,j),h(2,j),d(j),t(j),f(j),i(j),k(j)
print,'1st guess, zeroshift=',+strcompress(z)
FOR j=0,N_ELEMENTS(l)-1 DO print,'lambda='+strcompress(l(j))+', scale=',+strcompress(scale(j<(N_ELEMENTS(scale)-1)))
 
IF NOT KEYWORD_SET (iterations) THEN iterations=0 

FOR iteration=1,iterations DO BEGIN
  ;help,datp,/stru,w,var
  result=powfit(datp.x,w,w/datp.e,var,sigmaa,function_name = "POW_FUNCT",key=key,/noder,itmax=1,chi2=chi2) ;call powfit

  help,var,par

  e=sqrt(result)
  mod_datp,datp,'e',e
  IF NOT KEYWORD_SET(datp_) THEN give_datp,datp
  plot,x,w,tit='iteration no.'+strcompress(iteration)+', chi2='+strcompress(chi2),/xstyle,back=color(4),col=color(3)
  oplot,x,result,color=color(1)

  ; free and fixed parameters split up in two arrays => put it together again ...
  a=0
  jj=0
  jjj=0
  FOR j=0,N_ELEMENTS(fixed)-1 DO IF fixed(j) GT 0 THEN BEGIN
    a=[a,par(jj)] 
    jj=jj+1
  ENDIF ELSE BEGIN
    a=[a,var(jjj)] 
    jjj=jjj+1
  ENDELSE  ; free and fixed parameters split up in two arrays
  a=a(1:N_ELEMENTS(a)-1)
  peaks=nbofparams(3)                                       ; number of peaks
  l    =a(TOTAL(nbofparams(0:7)):TOTAL(nbofparams(0:8))-1)  ; wavelength
  scale=a(TOTAL(nbofparams(0:11)):TOTAL(nbofparams(0:12))-1); scale
  Z    =a(TOTAL(nbofparams(0:8)):TOTAL(nbofparams(0:9))-1)  ; FullProf : 2ttrue = 2texp.-ZER => 2tsim = 2tcalc + ZER
  Z    =Z(0)                                                ; only one zeroshift and wavelenght yet
  t    =2*asin(l(0)/2/d)*180/!pi + Z                        ; peak position  (2theta)
                                                            ; ATTENTION : C.d > l/2 !! (esp. in fits if l is refinable)
  b  =[a(TOTAL(nbofparams(0:6)):TOTAL(nbofparams(0:7))-1)] ; background polynom
  i=FLTARR(N_ELEMENTS(d))
  f=i
  FOR j=0,N_ELEMENTS(d)-1 DO BEGIN
    i(j)=a(TOTAL(nbofparams(0:4))+WHERE(d(ind) EQ d(j),count))
    f(j)=a(TOTAL(nbofparams(0:5))+WHERE(d(ind) EQ d(j),count))
  ENDFOR
  i=i/k
  print,'  h, k, l,          d,     2theta,       fwhm,  intensity, mult.
  for j=0,n_elements(d)-1 do print,FORMAT="(3I3,4F12.3,I3)",h(0,j),h(1,j),h(2,j),d(j),t(j),f(j),i(j),k(j)
  print,'iteration no.'+strcompress(iteration)+', zeroshift=',+strcompress(z)+', chi2='+strcompress(chi2)+', bg=',+strcompress(b)
  FOR j=0,N_ELEMENTS(l)-1 DO print,'lambda='+strcompress(l(j))+', scale=',+strcompress(scale(j<(N_ELEMENTS(scale)-1)))
  IF KEYWORD_SET(correct) THEN BEGIN
    ; Now correct non-realistic values (negative peaks etc.)
    for j=0,nbofparams(5) DO BEGIN
      if a(TOTAL(nbofparams(0:4))+j) LE 0 THEN BEGIN
        a(TOTAL(nbofparams(0:4))+j)=0
        fixed(TOTAL(nbofparams(0:4))+j)=1
        IF nbofparams(3) GT 0 THEN fixed(TOTAL(nbofparams(0:2))+j)=1
        IF nbofparams(4) GT 0 THEN fixed(TOTAL(nbofparams(0:3))+j)=1
        IF nbofparams(6) GT 0 THEN fixed(TOTAL(nbofparams(0:5))+j)=1
      ENDIF
    ENDFOR
    par=0
    var=0
    old=a
    FOR j=0,N_ELEMENTS(fixed)-1 DO IF fixed(j) EQ 0 THEN var=[var,a(j)] ELSE par=[par,a(j)] ; free and fixed parameters split up in two arrays
    var =var(1:N_ELEMENTS(var)-1) ; ... and if nothing is to be refined ???
    par=par(1:N_ELEMENTS(par)-1)
    key={p:par,f:fixed,n:nbOfParams}
    help,var,par

    pow_funct,x,var,result,c=key

    e=sqrt(result)
    mod_datp,datp,'e',e
    IF NOT KEYWORD_SET(datp_) THEN give_datp,datp
    plot,x,w,tit='1st guess',/xstyle,back=color(4),col=color(3)
    oplot,x,result,color=color(1)

    ; free and fixed parameters split up in two arrays => put it together again ...
    a=0
    jj=0
    jjj=0
    FOR j=0,N_ELEMENTS(fixed)-1 DO IF fixed(j) GT 0 THEN BEGIN
        a=[a,par(jj)] 
        jj=jj+1
    ENDIF ELSE BEGIN
        a=[a,var(jjj)] 
        jjj=jjj+1
    ENDELSE  ; free and fixed parameters split up in two arrays
    a=a(1:N_ELEMENTS(a)-1)
    peaks=nbofparams(3)                                       ; number of peaks
    l    =a(TOTAL(nbofparams(0:7)):TOTAL(nbofparams(0:8))-1)  ; wavelength
    scale=a(TOTAL(nbofparams(0:11)):TOTAL(nbofparams(0:12))-1); wavelength
    Z    =a(TOTAL(nbofparams(0:8)):TOTAL(nbofparams(0:9))-1)  ; FullProf : 2ttrue = 2texp.-ZER => 2tsim = 2tcalc + ZER
    Z    =Z(0)                                                ; only one zeroshift and wavelenght yet
    t    =2*asin(l(0)/2/d)*180/!pi + Z                        ; peak position  (2theta)
                                                              ; ATTENTION : C.d > l/2 !! (esp. in fits if l is refinable)
    b  =[a(TOTAL(nbofparams(0:6)):TOTAL(nbofparams(0:7))-1)]  ; background polynom
    i=FLTARR(N_ELEMENTS(d))
    f=i
    FOR j=0,N_ELEMENTS(d)-1 DO BEGIN
        i(j)=a(TOTAL(nbofparams(0:4))+WHERE(d(ind) EQ d(j),count))
        f(j)=a(TOTAL(nbofparams(0:5))+WHERE(d(ind) EQ d(j),count))
    ENDFOR
    i=i/k
    print,'  h, k, l,          d,     2theta,       fwhm,  intensity, mult.
    for j=0,n_elements(d)-1 do print,FORMAT="(3I3,4F12.3,I3)",h(0,j),h(1,j),h(2,j),d(j),t(j),f(j),i(j),k(j)
    print,'corrected guess, zeroshift=',+strcompress(z)+', bg=',+strcompress(b)
    FOR j=0,N_ELEMENTS(l)-1 DO print,'lambda='+strcompress(l(j))+', scale=',+strcompress(scale(j<(N_ELEMENTS(scale)-1)))
    oplot,x,result,col=color(6)
  ENDIF
ENDFOR
MOD_DATP,datp,'x',x
MOD_DATP,datp,'e',e
MOD_DATP,datp,'p',[l,z,scale]
MOD_DATP,datp,'par_txt',['lambda     ', 'zeroshift','scale   ']
IF NOT KEYWORD_SET(datp_) THEN GIVE_DATP,datp
RETURN,result
END

; $Id: curvefit.pro,v 1.7 1995/06/15 16:24:13 dave Exp $
function powfit, x, y, w, a, sigmaa, Function_Name = Function_Name, $
                        itmax=itmax, iter=iter, tol=tol, chi2=chi2, $
                        noderivative=noderivative,key=key
; Copyright (c) 1988-1995, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; former NAME:
;       CURVEFIT
;
; PURPOSE:
;       Non-linear least squares fit to a function of an arbitrary 
;       number of parameters.  The function may be any non-linear 
;       function.  If available, partial derivatives can be calculated by 
;       the user function, else this routine will estimate partial derivatives
;       with a forward difference approximation.
;
; CATEGORY:
;       E2 - Curve and Surface Fitting.
;
; CALLING SEQUENCE:
;       Result = CURVEFIT(X, Y, W, A, SIGMAA, FUNCTION_NAME = name, $
;                         ITMAX=ITMAX, ITER=ITER, TOL=TOL, /NODERIVATIVE)
;
; INPUTS:
;       X:  A row vector of independent variables.  This routine does
;		not manipulate or use values in X, it simply passes X
;		to the user-written function.
;
;       Y:  A row vector containing the dependent variable.
;
;       W:  A row vector of weights, the same length as Y.
;               For no weighting,
;               w(i) = 1.0.
;               For instrumental weighting,
;               w(i) = 1.0/y(i), etc.
;
;       A:  A vector, with as many elements as the number of terms, that 
;           contains the initial estimate for each parameter.  If A is double-
;           precision, calculations are performed in double precision, 
;           otherwise they are performed in single precision.
;
; KEYWORDS:
;       FUNCTION_NAME:  The name of the function (actually, a procedure) to 
;       fit.  If omitted, "FUNCT" is used. The procedure must be written as
;       described under RESTRICTIONS, below.
;
;       ITMAX:  Maximum number of iterations. Default = 20.
;       ITER:   The actual number of iterations which were performed
;       TOL:    The convergence tolerance. The routine returns when the
;               relative decrease in chi-squared is less than TOL in an 
;               interation. Default = 1.e-3.
;       CHI2:   The value of chi-squared on exit
;       NODERIVATIVE:   If this keyword is set then the user procedure will not
;               be requested to provide partial derivatives. The partial
;               derivatives will be estimated in CURVEFIT using forward
;               differences. If analytical derivatives are available they
;               should always be used.
;
; OUTPUTS:
;       Returns a vector of calculated values.
;       A:  A vector of parameters containing fit.
;
; OPTIONAL OUTPUT PARAMETERS:
;       Sigmaa:  A vector of standard deviations for the parameters in A.
;
; COMMON BLOCKS:
;       NONE.
;
; SIDE EFFECTS:
;       None.
;
; RESTRICTIONS:
;       The function to be fit must be defined and called FUNCT,
;       unless the FUNCTION_NAME keyword is supplied.  This function,
;       (actually written as a procedure) must accept values of
;       X (the independent variable), and A (the fitted function's
;       parameter values), and return F (the function's value at
;       X), and PDER (a 2D array of partial derivatives).
;       For an example, see FUNCT in the IDL User's Libaray.
;       A call to FUNCT is entered as:
;       FUNCT, X, A, F, PDER
; where:
;       X = Variable passed into CURVEFIT.  It is the job of the user-written
;		function to interpret this variable.
;       A = Vector of NTERMS function parameters, input.
;       F = Vector of NPOINT values of function, y(i) = funct(x), output.
;       PDER = Array, (NPOINT, NTERMS), of partial derivatives of funct.
;               PDER(I,J) = DErivative of function at ith point with
;               respect to jth parameter.  Optional output parameter.
;               PDER should not be calculated if the parameter is not
;               supplied in call. If the /NODERIVATIVE keyword is set in the
;               call to CURVEFIT then the user routine will never need to
;               calculate PDER.
;
; PROCEDURE:
;       Copied from "CURFIT", least squares fit to a non-linear
;       function, pages 237-239, Bevington, Data Reduction and Error
;       Analysis for the Physical Sciences.
;
;       "This method is the Gradient-expansion algorithm which
;       combines the best features of the gradient search with
;       the method of linearizing the fitting function."
;
;       Iterations are performed until the chi square changes by
;       only TOL or until ITMAX iterations have been performed.
;
;       The initial guess of the parameter values should be
;       as close to the actual values as possible or the solution
;       may not converge.
;
; EXAMPLE:  Fit a function of the form f(x) = a * exp(b*x) + c to
;	sample pairs contained in x and y.
;	In this example, a=a(0), b=a(1) and c=a(2).
;	The partials are easily computed symbolicaly:
;		df/da = exp(b*x), df/db = a * x * exp(b*x), and df/dc = 1.0
;
;		Here is the user-written procedure to return F(x) and
;		the partials, given x:
;       pro gfunct, x, a, f, pder	; Function + partials
;	  bx = exp(a(1) * x)
;         f= a(0) * bx + a(2)		;Evaluate the function
;         if N_PARAMS() ge 4 then $	;Return partials?
;		pder= [[bx], [a(0) * x * bx], [replicate(1.0, N_ELEMENTS(y))]]
;       end
;
;         x=findgen(10)			;Define indep & dep variables.
;         y=[12.0, 11.0,10.2,9.4,8.7,8.1,7.5,6.9,6.5,6.1]
;         w=1.0/y			;Weights
;         a=[10.0,-0.1,2.0]		;Initial guess
;         yfit=curvefit(x,y,w,a,sigmaa,function_name='gfunct')
;	  print, 'Function parameters: ', a
;         print, yfit
;       end
;
; MODIFICATION HISTORY:
;       Written, DMS, RSI, September, 1982.
;       Does not iterate if the first guess is good.  DMS, Oct, 1990.
;       Added CALL_PROCEDURE to make the function's name a parameter.
;              (Nov 1990)
;       12/14/92 - modified to reflect the changes in the 1991
;            edition of Bevington (eq. II-27) (jiy-suggested by CreaSo)
;       Mark Rivers, U of Chicago, Feb. 12, 1995
;           - Added following keywords: ITMAX, ITER, TOL, CHI2, NODERIVATIVE
;             These make the routine much more generally useful.
;           - Removed Oct. 1990 modification so the routine does one iteration
;             even if first guess is good. Required to get meaningful output
;             for errors. 
;           - Added forward difference derivative calculations required for 
;             NODERIVATIVE keyword.
;           - Fixed a bug: PDER was passed to user's procedure on first call, 
;             but was not defined. Thus, user's procedure might not calculate
;             it, but the result was then used.
;           
;-
       on_error,2              ;Return to caller if error

       ;Name of function to fit
       if n_elements(function_name) le 0 then function_name = "pow_FUNCT"
       if n_elements(tol) eq 0 then tol = 1.e-3		;Convergence tolerance
       if n_elements(itmax) eq 0 then itmax = 20	;Maximum # iterations
	type = size(a)
	type = type(type(0)+1)
	double = type eq 5
	if (type ne 4) and (type ne 5) then a = float(a)  ;Make params floating

       ; If we will be estimating partial derivatives then compute machine
       ; precision
       if keyword_set(NODERIVATIVE) then begin
          res = nr_machar(DOUBLE=double)
          eps = sqrt(res.eps)
       endif

       nterms = n_elements(a)   ; # of parameters
       nfree = n_elements(y) - nterms ; Degrees of freedom
       if nfree le 0 then message, 'Curvefit - not enough data points.'
       flambda = 0.001          ;Initial lambda
       diag = lindgen(nterms)*(nterms+1) ; Subscripts of diagonal elements

;      Define the partial derivative array
       if double then pder = dblarr(n_elements(y), nterms) $
	else pder = fltarr(n_elements(y), nterms)
;
       for iter = 1, itmax do begin   ; Iteration loop

;         Evaluate alpha and beta matricies.
          if keyword_set(NODERIVATIVE) then begin
;            Evaluate function and estimate partial derivatives
             call_procedure, Function_name, x, a, yfit, c=key
             for term=0, nterms-1 do begin
                p = a       ; Copy current parameters
                ; Increment size for forward difference derivative
                inc = eps * abs(p(term))    
                if (inc eq 0.) then inc = eps
                p(term) = p(term) + inc
                call_procedure, function_name, x, p, yfit1, c=key
                pder(0,term) = (yfit1-yfit)/inc
             endfor
          endif else begin
             ; The user's procedure will return partial derivatives
             call_procedure, function_name, x, a, yfit, pder ,c=key
          endelse

          beta = (y-yfit)*w # pder
          alpha = transpose(pder) # (w # (fltarr(nterms)+1)*pder)
          chisq1 = total(w*(y-yfit)^2)/nfree ; Present chi squared.

				; If a good fit, no need to iterate
	  all_done = chisq1 lt total(abs(y))/1e7/NFREE
;
;         Invert modified curvature matrix to find new parameters.

          repeat begin
             c = sqrt(alpha(diag) # alpha(diag))
             array = alpha/c
             array(diag) = array(diag)*(1.+flambda)              
             array = invert(array)
             b = a+ array/c # transpose(beta) ; New params
             call_procedure, function_name, x, b, yfit ,c=key ; Evaluate function
             chisqr = total(w*(y-yfit)^2)/nfree         ; New chisqr
	     if all_done then goto, done
             flambda = flambda*10.                      ; Assume fit got worse
          endrep until chisqr le chisq1
;
          flambda = flambda/100.  ; Decrease flambda by factor of 10
          a=b                     ; Save new parameter estimate.
          if ((chisq1-chisqr)/chisq1) le tol then goto,done  ; Finished?
       endfor                        ;iteration loop
;
       message, 'Failed to converge', /INFORMATIONAL
;
done:  sigmaa = sqrt(array(diag)/alpha(diag)) ; Return sigma's
       chi2 = chisqr                          ; Return chi-squared
       return,yfit              ;return result
END
FUNCTION powsim,uvw=u,hkl=h,abc=a,lambda=l,$
                int=i,bg=b,x=x,fwhm=f,scale=scale,$
                zeroshift=z,dspacing=d,multiplicity=K,$
                twotheta=t

; INPUT :  hkl          h
;          uvw          u
;
; OUTPUT : Multiplicity K
;          dspacing     d
;          Int. calc.   i
;          FWHM         f
;          2theta       t
;

  TAKE_DATP,datp
if not keyword_set(x) THEN x=indgen(1600)/10.

result=fltarr(n_elements(x))
help,h
d=a/SQRT(h(0,*)^2+h(1,*)^2+h(2,*)^2)
h=h(*,where(d gt l/2))
help,h
h=h(*,reverse(sort(d)))
d=d(where(d gt l/2))
d=d(reverse(sort(d)))
;h=h(*,where(d gt l/2))
d=REFORM(d,N_ELEMENTS(d))
t=2*asin(l/2/d)*180/!pi
;t=REFORM(t,N_ELEMENTS(t))

  ind=(UNIQ(t,sort(t)))
  K=intarr(N_ELEMENTS(d))
  FOR j=0,N_ELEMENTS(d)-1 DO BEGIN
    bid=WHERE(t EQ t(j),count)
    K(j)=K(j)+count
  ENDFOR

  IF NOT KEYWORD_SET(z) THEN z=0  ; Zeroshift like FullProf : 2tcalc=2tsim-Z

  f=fwhm(u,t(ind))
  i=K(ind)*scale
  
  c={d:d(ind),bg:N_ELEMENTS(b)}
  a=[i,f,b,l,z]
  pow_funct,x,a,result,c=c
  
  f=fwhm(u,t(ind))
  i=K*scale
  FOR j=0,N_ELEMENTS(d)-1 DO BEGIN
    ;bid=WHERE(t(ind) EQ t(j),count)
    i(j)=a(WHERE(t(ind) EQ t(j),count))
  ENDFOR
  i=i/k

  e=sqrt(result)
  for j=0,n_elements(d)-1 do print,h(0,j),h(1,j),h(2,j),d(j),t(j),i(j),k(j)
  plot,x, result,tit='simulation'
MOD_DATP,datp,'x',x
MOD_DATP,datp,'e',e
GIVE_DATP,datp
RETURN,w
END


pro pretreat,w,parasite,W=workspace
;
; Macro (started 18/10/96 by Th.Hansen) in order to interpolate or eliminate zero-counting or
; parasite-affected detector cells and/or non-executed or wrong steps/slices of scans/stroboscopic
; acquisitions.
; DATP is given by take_datp, so a call in another macro isn't possible yet!
; To change this, a keyword parameter with DATP has to be introduced.
; By default, all detector cells and all steps/slices with counting sums of zero are eliminated.
; Later on for calibration of angle/efficiency the corresponding cell-number for each counting rate
; has to be calculated by the formula CELL(i) = ROUND ((XX(i) - XX(0)) * 10). That works only if
; any angle calibration doesn't shift the 2*Theta value for any cell of 0.05 deg or more.
; Otherwise PRETREAT has either to be executed before any angle calibration or to be execute 
; after this calibration (angle calibration flag set) but in that case the cell number is simply
; the first index of the workspace w and it must not be calculated as above!
;
; Last modification 20-Jun-97 by Th.Hansen
;
take_datp,datp			; be cautious with this LAMP procedure !!!
pv = datp.pv 
x  = datp.x
e  = datp.e
y  = datp.y 
n  = datp.n  
nd = N_ELEMENTS (w(*,0))	; Number of Detector cells
np = N_ELEMENTS (pv(*,0))	; Number of variable Parameters
ns = N_ELEMENTS (w(0,*))	; Number of Scans/slices per numor
nx = N_ELEMENTS (x(0,*))	; Number of Scans/Slices per numor in X
ny = N_ELEMENTS (y(0,*))	; Number of Scans/Slices per numor in y if 2-dim, else 1/0
IF ns le 1 THEN w=reform(w,n_elements(w),1)
IF nx ne ns THEN nx=0
IF n_params() gt 1 THEN parasite = parasite(*,0,0,0)
cell = indgen (nd) 

 
;
; Elimination of zero-counting steps/slices:
;
IF nx gt 1 THEN x =x (*,where(total(w,1)))
IF ny gt 1 THEN y =y (*,where(total(w,1))) ELSE y =y (where(total(w,1)))
e =e (*,where(total(w,1)))
n =n (  where(total(w,1)))
pv=pv(*,where(total(w,1)))
w =w (*,where(total(w,1)))

IF n_params() gt 1 THEN BEGIN
  a=indgen(nd)
  b=parasite
  a(parasite)=-1
  a=a(where(a ge 0))
  wold=w  
  IF N_ELEMENTS(w(0,*)) GE N_ELEMENTS(x(0,*)) THEN BEGIN
    FOR i=0,N_ELEMENTS(w(0,*))-1 DO w(b,i)=interpol(w(a,i),x(a),x(b))
  ENDIF ELSE w(b)=interpol(w(a),x(a),x(b))
  e(b,*)=w(b,*)*e(b,*)/wold(b,*)
  wold=0
ENDIF

mod_datp, datp, 'y' , y
mod_datp, datp, 'x',  x
mod_datp, datp, 'n' , n 
mod_datp, datp, 'pv', pv
mod_datp, datp, 'e' , e
datp.p(38)=datp.p(38)+4.	; PREATREAT-flag
give_datp, datp
END
	FUNCTION prime_cell, w_in1, w_in2

; calculates prime_cell from transmission runs given in w_in2 and applies
; to runs contained in w_in1
;						JRS 2/3/00

	iprint=0

	take_datp, dat1
	take_datp, dat2, /third
	
	beamcentre, w_in2, px, py

	IF(iprint GE 0) THEN BEGIN
		PRINT,'prime_cell: Beam Centre found at:'
		PRINT,'		X0 =',px
		PRINT,'		Y0 =',py
	ENDIF

	sw=SIZE(w_in1)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in1)=',sw

	IF (sw(0) EQ 3) THEN nruns=sw(3) ELSE nruns=1
	IF (nruns EQ 1) THEN BEGIN
		dat1.p(13)=px
		dat1.p(14)=py
	ENDIF ELSE BEGIN
		dat1.p(13)=px
		dat1.p(14)=py
		dat1.pv(13,*)=px
		dat1.pv(14,*)=py
	ENDELSE

;---------------------------------------------------------------------------

	prix=STRTRIM(STRING(px),2)
	priy=STRTRIM(STRING(py),2)
	dat1.other_tit=dat1.other_tit+' -pc('+prix+','+priy+')'
	GIVE_DATP, dat1

	RETURN, w_in1
	END
PRO procedures

print,' '
print,'*** Overview of procedures for LAMP on D20SGI ***'
print,' '
print,'Type "procedure,parameter1,parameter2,keyword1=value1,/keyword2" etc. '
print,' '
print,'IDL Internal procedures:'
print,' '
print,'If you have XWindows or an emulator you may call "?" for the exhaustive IDL help '
print,' '
print,'?        : Opens a help window (XWindows) on IDL - a really good help for IDL programmers!'
print,'help     : Gives informations (dimensions etc.) about any variable'
print,'           help,x6,w6,n6,p6,pv6 or help,/file'
print,'set_plot : Let you set your graphics device (Tektronix terminal, XWindows or PostScript'
print,'           set_plot,"tek", set_plot,"X" or set_plot,"ps"  '
print,'free_lun : Frees a logical unit (a file that has been opened for read or write'
print,'           but not yet closed, e.g. due to a program error) : If you receive '
print,'           e.g. an error message saying that "all logical units" are in use" you '
print,'           may type "help,/file" to get the logical unit numbers (e.g. 100 and 102)of the files concerned'
print,'           and you may close the files by typing "free_lun,100,102"'
print,'print    : Print any variable, string or value to the terminal window, also formatted'
print,'plot     : Plot a 1D-array, eventually dependent to an x-axis array'
print,'set_plot : Change the graphics output device, e.g. "X", "ps" or "tek" '
print,'journal  : Creates a journal file of your session. Every command you give will be written '
print,'           to a procedure file idlsave.pro or another filename you give'
print,'           till you leave lamp/idl or you type journal   '
print,'           without giving a filename '
print,' '
print,' '
print,'LAMP Internal procedures '
print,' '
print,'You may get more help by clicking on "The Manual" if you are working with the XWindows version '
print,'Otherwise (lamp -nw) you connect to the LAMP Manual of the Computing for Science group on WWW.ILL.FR '
print,'or you work with "WebLamp" on BARNS.ILL.FR where you will find a button called "Manual"'
print,' '
print,'rdset : Sets instrument, data base and cycle'
print,' '
print,' '
print,'D20 LAMP procedures '
print,' '
print,'You may get more help by typing "procedure_name,help" '
print,'You find the files procedure_name.pro in the directory d20sgi.ill.fr:~lambda/macros '
print,' '
print,'flag   : Choose several options to be applied during reading numors'
print,'exriet : Exports workspaces or numors to original Rietveld-Hewat format'
print,'         (INSTR 1 in fullprof, like D1A and D2B), general two axis '
print,'         diffractometer data format (INSTR 5) and GSAS formats'
print,'d20reg : Exports a 1D-workspace to x y dy format (gnuplot, xmgr)'
print,'         Corresponds to D4reg, extension "dat" will generate only one'
print,'         title comment line to correspond to fullprof format 10'
print,'fild20 : Exports 1D- or 2D-data (workspace or numors) in "D1B" format'
print,'par    : Prints the fixed parameters of a workspace or the variable'
print,'         parameters of a given step: "par,w6" or "par,w7,3"'
print,'rdeff  : Reads a calibration file (extension .d20)'
print,' '
END
pro pscell_32,w,x=x,mincell=mincell,maxcell=maxcell,cell=cell,wcell=wcell,$
             wnorm=wnorm,wrevers=wrevers,wrevnorm=wrevnorm,enorm=enorm,$
             erevers=erevers,erevnorm=erevnorm,wmean=wmean,emean=emean,$
             mean=mean,sdev=sdev,nops=nops,noplot=noplot
IF NOT KEYWORD_SET(x) THEN x=indgen(N_ELEMENTS(w(0,*)))
e    =w/SQRT(w+1.)
;e    =SQRT(w)
wmean=TOTAL(w,2)/N_ELEMENTS(w(0,*))
emean=TOTAL(e,2)/N_ELEMENTS(e(0,*))
wnorm=float(w)
FOR i=0,N_ELEMENTS(w(0,*))-1 DO wnorm(*,i)=wnorm(*,i)/float(wmean)
enorm=float(e)
FOR i=0,N_ELEMENTS(e(0,*))-1 DO enorm(*,i)=enorm(*,i)/float(wmean)
set_plot,'ps'
mean=fltarr(1600)
sdev=fltarr(1600)
IF NOT KEYWORD_SET(mincell) THEN mincell=0
IF NOT KEYWORD_SET(maxcell) THEN maxcell=1599
IF KEYWORD_SET(cell) THEN BEGIN
  mincell=cell
  maxcell=cell
ENDIF
FOR i=0,1599 DO IF total(w(i,*)) NE 0 THEN BEGIN
  res=MOMENT(w(i,*),SDEV=dev)
  mean(i)=res(0)
  sdev(i)=dev
ENDIF ELSE wnorm(i,*)=1.
FOR i=mincell,maxcell do IF total(w(i,*)) NE 0 THEN BEGIN
  IF NOT KEYWORD_SET(nops) THEN set_plot,'ps'
  filename='000'+strcompress(string(i),/REMOVE_ALL)
  filename=strmid(filename,strlen(filename)-4,4)
  IF NOT KEYWORD_SET(nops) THEN DEVICE,filename='cell'+filename+'.ps'
  wcell=wnorm(i,*)
  IF NOT KEYWORD_SET(nops) THEN plot,wnorm(i,*),$
       yrange=[0,2],$
       title='Cell no.'+strcompress(string(i))+' '+SYSTIME()+', counts:'+strcompress(string(wmean(i))),$       
       subtitle='Error:'+strcompress(string(emean(i)))+' ='+strcompress(string(emean(i)/wmean(i)*100.))+'%, sdev:'+strcompress(string(sdev(i)))
  IF NOT KEYWORD_SET(nops) THEN DEVICE,/CLOSE
  IF NOT KEYWORD_SET(nops) THEN set_plot,'X'
  IF NOT KEYWORD_SET(noplot) THEN plot,wnorm(i,*),yrange=[0,2],title='Cell no.'+strcompress(string(i))+', counts:'+strcompress(string(wmean(i))),$
       subtitle='Error:'+strcompress(string(emean(i)))+' ='+strcompress(string(emean(i)/wmean(i)*100.))+'%, sdev:'+strcompress(string(sdev(i)))
ENDIF
wrevers=REFORM(w,N_ELEMENTS(w(0,*)),1600)
FOR i=0,1599 DO FOR j=0,N_ELEMENTS(w(0,*))-1 DO wrevers(j,i) = w (i,j)
erevers=wrevers/SQRT(wrevers+1.)
;erevers=SQRT(wrevers)
wrevnorm=REFORM(wnorm,N_ELEMENTS(wnorm(0,*)),1600)
FOR i=0,1599 DO FOR j=0,N_ELEMENTS(wnorm(0,*))-1 DO wrevnorm(j,i) = wnorm (i,j)
erevnorm=REFORM(enorm,N_ELEMENTS(enorm(0,*)),1600)
FOR i=0,1599 DO FOR j=0,N_ELEMENTS(enorm(0,*))-1 DO erevnorm(j,i) = enorm (i,j)

END
pro pscell,w,x=x,mincell=mincell,maxcell=maxcell,cell=cell,wcell=wcell,$
             wnorm=wnorm,wrevers=wrevers,wrevnorm=wrevnorm,enorm=enorm,$
             erevers=erevers,erevnorm=erevnorm,wmean=wmean,emean=emean,$
             mean=mean,sdev=sdev,nops=nops,noplot=noplot
IF NOT KEYWORD_SET(x) THEN x=indgen(N_ELEMENTS(w(0,*)))
e    =w/SQRT(w+1.)
;e    =SQRT(w)
wmean=TOTAL(w,2)/N_ELEMENTS(w(0,*))
emean=TOTAL(e,2)/N_ELEMENTS(e(0,*))
wnorm=float(w)
FOR i=0,N_ELEMENTS(w(0,*))-1 DO wnorm(*,i)=wnorm(*,i)/float(wmean)
enorm=float(e)
FOR i=0,N_ELEMENTS(e(0,*))-1 DO enorm(*,i)=enorm(*,i)/float(wmean)
set_plot,'ps'
mean=fltarr(1600)
sdev=fltarr(1600)
IF NOT KEYWORD_SET(mincell) THEN mincell=0
IF NOT KEYWORD_SET(maxcell) THEN maxcell=1599
IF KEYWORD_SET(cell) THEN BEGIN
  mincell=cell
  maxcell=cell
ENDIF
FOR i=0,1599 DO IF total(w(i,*)) NE 0 THEN BEGIN
  res=MOMENT(w(i,*),SDEV=dev)
  mean(i)=res(0)
  sdev(i)=dev
ENDIF ELSE wnorm(i,*)=1.
FOR i=mincell,maxcell do IF total(w(i,*)) NE 0 THEN BEGIN
  IF NOT KEYWORD_SET(nops) THEN set_plot,'ps'
  filename='000'+strcompress(string(i),/REMOVE_ALL)
  filename=strmid(filename,strlen(filename)-4,4)
  IF NOT KEYWORD_SET(nops) THEN DEVICE,filename='cell'+filename+'.ps'
  wcell=wnorm(i,*)
  IF NOT KEYWORD_SET(nops) THEN plot,wnorm(i,*),$
       yrange=[0,2],$
       title='Cell no.'+strcompress(string(i))+' '+SYSTIME()+', counts:'+strcompress(string(wmean(i))),$       
       subtitle='Error:'+strcompress(string(emean(i)))+' ='+strcompress(string(emean(i)/wmean(i)*100.))+'%, sdev:'+strcompress(string(sdev(i)))
  IF NOT KEYWORD_SET(nops) THEN DEVICE,/CLOSE
  IF NOT KEYWORD_SET(nops) THEN set_plot,'X'
  IF NOT KEYWORD_SET(noplot) THEN plot,wnorm(i,*),yrange=[0,2],title='Cell no.'+strcompress(string(i))+', counts:'+strcompress(string(wmean(i))),$
       subtitle='Error:'+strcompress(string(emean(i)))+' ='+strcompress(string(emean(i)/wmean(i)*100.))+'%, sdev:'+strcompress(string(sdev(i)))
ENDIF
wrevers=REFORM(w,N_ELEMENTS(w(0,*)),1600)
FOR i=0,1599 DO FOR j=0,N_ELEMENTS(w(0,*))-1 DO wrevers(j,i) = w (i,j)
erevers=wrevers/SQRT(wrevers+1.)
;erevers=SQRT(wrevers)
wrevnorm=REFORM(wnorm,N_ELEMENTS(wnorm(0,*)),1600)
FOR i=0,1599 DO FOR j=0,N_ELEMENTS(wnorm(0,*))-1 DO wrevnorm(j,i) = wnorm (i,j)
erevnorm=REFORM(enorm,N_ELEMENTS(enorm(0,*)),1600)
FOR i=0,1599 DO FOR j=0,N_ELEMENTS(enorm(0,*))-1 DO erevnorm(j,i) = enorm (i,j)

END
PRO psplot32,w,xrange,yrange,comment,noprint=noprint,printer=printer,box=box,points=points
take_datp,datp
SET_PLOT,'ps'
x=findgen(N_ELEMENTS(w))
IF NOT KEYWORD_SET(points) THEN points=0 
IF N_ELEMENTS(xrange) NE 2 THEN xrange=[min(x),max(x)]
IF N_ELEMENTS(yrange) NE 2 THEN yrange=[min(w),max(w)]
IF N_ELEMENTS(comment) LT 1 THEN comment='cell '
filename=strcompress(string(round(xrange(0))),/remove_all)+'.ps'
IF KEYWORD_SET(eps) THEN eps=1 ELSE eps=0
DEVICE,FILENAME=filename,$
  /LANDSCAPE,XSIZE=25,YSIZE=15,YOFFSET=25,XOFFSET=5,$
  BITS_PER_PIXEL=256,/COLOR,encapsulated=eps
IF NOT KEYWORD_SET(wmax) THEN wmax=max(w)
IF NOT KEYWORD_SET(wmin) THEN wmin=min(w)
xx=x(where((x GE xrange(0)) AND (x LE xrange(1))))
tickv=xx(where((xx mod 32) LT 0.05))
tickv=float(tickv)-0.5
tickformat='(F6.1)'
IF KEYWORD_SET(box) THEN BEGIN
  x=float(x)/32.
  tickv=tickv/32. 
  tickformat='(I1)'
  xrange=float(xrange)/32.
ENDIF ELSE IF N_ELEMENTS(tickv) GE 30 THEN tickv=xx(where((xx mod 64) LT 0.05))
ticks=N_ELEMENTS(tickv)-1
PLOT,x,w,$
       PSYM  = points, $
       yRANGE  = yrange, $
       ygridstyle=1,$
       xRANGE  = xrange, $
       xtickv=tickv,$
       xtickFORMAT=tickformat,$
       xgridstyle=1,$
       xticklen=1.,$
       yticklen=1.,$
       xticks=ticks,$
       TITLE=datp.w_tit,$
       SUBTITLE=datp.other_tit,$
       xTITLE=comment,$
       yTITLE=datp.y_tit
IF KEYWORD_SET(box) THEN BEGIN
  PLOT,x,w,/noerase,$
       PSYM  = points, $
       yRANGE  = yrange, $
       ygridstyle=1,$
       xRANGE  = xrange, $
       xtickv=tickv+0.5,$
       xtickFORMAT='(I2)',$
       yticklen=1.,$
       xticks=ticks,$
       TITLE=datp.w_tit,$
       SUBTITLE=datp.other_tit,$
       xTITLE=comment,$
       yTITLE=datp.y_tit
ENDIF
DEVICE,/CLOSE
IF NOT KEYWORD_SET(noprint) THEN BEGIN
  IF KEYWORD_SET(printer) THEN line='$lp -d'+printer+' '+filename ELSE line='$lp '+filename
  print,line
  XICUTE,line
ENDIF
SET_PLOT,'X'
PLOT,x,w,$
       PSYM  = points, $
       yRANGE  =yrange, $
       ygridstyle=1,$
       xRANGE  = xrange, $
       xtickv=tickv,$
       xtickFORMAT=tickformat,$
       xgridstyle=1,$
       xticklen=1.,$
       yticklen=1.,$
       xticks=ticks,$
       TITLE=datp.w_tit,$
       SUBTITLE=datp.other_tit,$
       xTITLE=comment,$
       yTITLE=datp.y_tit
IF KEYWORD_SET(box) THEN BEGIN
  PLOT,x,w,/noerase,$
       PSYM  = points, $
       yRANGE  = yrange, $
       ygridstyle=1,$
       xRANGE  = xrange, $
       xtickv=tickv+0.5,$
       xtickFORMAT='(I2)',$
       yticklen=1.,$
       xticks=ticks,$
       TITLE=datp.w_tit,$
       SUBTITLE=datp.other_tit,$
       xTITLE=comment,$
       yTITLE=datp.y_tit
ENDIF
give_datp,datp
END
PRO psploterr,w
;,shade=shade,wmax=wmax,wmin=wmin,$
;             eps=eps,noprint=noprint,printer=printer
take_datp,datp
SET_PLOT,'ps'
filename=strcompress(string(round(datp.p(0))),/remove_all)+'.ps'
IF KEYWORD_SET(eps) THEN eps=1 ELSE eps=0
DEVICE,FILENAME=filename,$
  /LANDSCAPE,XSIZE=25,YSIZE=15,YOFFSET=25,XOFFSET=5,$
  BITS_PER_PIXEL=256,/COLOR,encapsulated=eps
IF NOT KEYWORD_SET(wmax) THEN wmax=max(w)
IF NOT KEYWORD_SET(wmin) THEN wmin=min(w)
IF N_ELEMENTS(w(0,*)) GT 1 THEN $
  IF KEYWORD_SET(shade) THEN $
  SHADE_SURF,w,datp.x,datp.y        ,$
          zRANGE  = [wmin,wmax], $
          TITLE   =datp.w_tit    ,$
          SUBTITLE=datp.other_tit,$
          xTITLE  =datp.x_tit,$
          yTITLE  =datp.y_tit,$
          zTITLE  =datp.z_tit $
  ELSE $
  SURFACE,w,datp.x,datp.y        ,$
          zRANGE  = [wmin,wmax], $
          TITLE   =datp.w_tit    ,$
          SUBTITLE=datp.other_tit,$
          xTITLE  =datp.x_tit,$
          yTITLE  =datp.y_tit,$
          zTITLE  =datp.z_tit $
ELSE $
  PLOT,datp.x,w,$
       yRANGE  = [wmin,wmax], $
       TITLE=datp.w_tit,$
       SUBTITLE=datp.other_tit,$
       xTITLE=datp.x_tit,$
       yTITLE=datp.y_tit
OPLOTERR,datp.x,w,datp.e,3 
;IF KEYWORD_SET(err) THEN ERRPLOT,datp.x,w-datp.e,w+datp.e 
;IF KEYWORD_SET(err) THEN ERRPLOT,datp.x,w,datp.e,PSYM=3
DEVICE,/CLOSE
  IF NOT KEYWORD_SET(printer) THEN line='$lp '+filename ELSE line='$lp -d'+printer+' '+filename
;if NOT keyword_set(noprint) THEN  PRINT,line 
if NOT keyword_set(noprint) THEN  XICUTE,line 
SET_PLOT,'X'
give_datp,datp
END
PRO psplot,w,shade=shade,wmax=wmax,wmin=wmin,xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax,$
             xrange=xrange,yrange=yrange,wrange=wrange,eps=eps,noprint=noprint,printer=printer,$
             error=error,contour=contour,noscreen=noscreen,ax=ax,az=az,help=help,$
             notitle=notitle,noaxis=noaxis,nozaxis=nozaxis,noxaxis=noxaxis,noyaxis=noyaxis,$
             vector=vector,noxtitle=noxtitle,noytitle=noytitle,$
             xformat=xformat,yformat=yformat,wformat=wformat,wset=wset,window=win,$
             xticks=xticks,yticks=yticks,wticks=wticks,random=random,psym=psym

COMMON C_LAMP_W
COMMON C_LAMP_INFO

!p.position=[0.1,0.15,.95,.95]
IF KEYWORD_SET(help) THEN BEGIN
  PRINT,'     modification 01 December  1997 by Thomas Hansen: More options for 3D-surface plots (thermodiffractometries)'
  PRINT,'Last modification 07 September 1998 by Thomas Hansen: window and wset'
ENDIF
print,'T'
print,'PSPLOT'
take_datp,datp
IF KEYWORD_SET(win)  THEN window,win
IF NOT KEYWORD_SET(wset)  THEN wset=0
IF NOT KEYWORD_SET(landscape)  THEN landscape=0
IF NOT KEYWORD_SET(vector)  THEN vector=0
IF NOT KEYWORD_SET(noxaxis) THEN xaxis=1 ELSE xaxis=0
IF NOT KEYWORD_SET(noyaxis) THEN yaxis=1 ELSE yaxis=0
IF NOT KEYWORD_SET(noxaxis) THEN noxaxis=0
IF NOT KEYWORD_SET(noyaxis) THEN noyaxis=0
IF NOT KEYWORD_SET(nozaxis) THEN nozaxis=0
IF NOT KEYWORD_SET(ax)      THEN ax=20
IF NOT KEYWORD_SET(az)      THEN az=20
IF NOT KEYWORD_SET(xmax)    THEN xmax=max(datp.x)
IF NOT KEYWORD_SET(xmin)    THEN xmin=min(datp.x)
IF NOT KEYWORD_SET(xrange)  THEN xrange=[xmin,xmax]
xmax=max(xrange)
xmin=min(xrange)
IF NOT KEYWORD_SET(wmax)    THEN wmax=max(w(WHERE(datp.x GE xrange(0) AND datp.x LE xrange(1),count),*))
IF NOT KEYWORD_SET(wmin)    THEN wmin=min(w(WHERE(datp.x GE xrange(0) AND datp.x LE xrange(1),count),*))
IF NOT KEYWORD_SET(wrange)  THEN wrange=[wmin,wmax]
IF NOT KEYWORD_SET(wmax)    THEN wmax=max(wrange)
IF NOT KEYWORD_SET(wmin)    THEN wmin=min(wrange)
IF NOT KEYWORD_SET(ymax)    THEN ymax=max(datp.y)
IF NOT KEYWORD_SET(ymin)    THEN ymin=min(datp.y)
IF NOT KEYWORD_SET(yrange)  THEN yrange=[ymin,ymax]
IF NOT KEYWORD_SET(psym)    THEN psym=0
ymax=max(yrange)
ymin=min(yrange)
IF NOT KEYWORD_SET(xformat) THEN IF (xmax LT 1000000) AND (xmax-xmin GT 6) THEN xformat='(I6)' ELSE xformat=0
IF NOT KEYWORD_SET(yformat) THEN IF (ymax LT 1000000) AND (ymax-ymin GT 6) THEN yformat='(I6)' ELSE yformat=0
IF NOT KEYWORD_SET(wformat) THEN IF (wmax LT 1000000) AND (wmax-wmin GT 6) THEN wformat='(I6)' ELSE wformat=0
IF NOT KEYWORD_SET(xticks)  THEN xticks=0
IF NOT KEYWORD_SET(yticks)  THEN yticks=0
IF NOT KEYWORD_SET(wticks)  THEN wticks=0

pp=datp.p
help,pp
ww=w
IF N_ELEMENTS(ww(0,0,*)) GT 1 THEN z_tit='counts' ELSE z_tit=datp.z_tit

FOR ii=0,N_ELEMENTS(w(0,0,*))-1 DO BEGIN
pv=datp.pv(*,0,ii)
IF N_ELEMENTS(ww(0,0,*)) GT 1 THEN subtitle=datp.other_tit+'-'+strcompress(string(ii)+' '+datp.par_txt(10+ROUND(pp(0))/10)+string(pv(10+ROUND(pp(0))/10))) ELSE subtitle=datp.other_tit
print,subtitle
IF NOT KEYWORD_SET(notitle)  THEN title=datp.w_tit ELSE title=''
IF NOT KEYWORD_SET(noxtitle) THEN x_tit=datp.x_tit ELSE x_tit=''
IF NOT KEYWORD_SET(noytitle) THEN y_tit=datp.y_tit ELSE y_tit=''
IF     KEYWORD_SET(noztitle) THEN                       z_tit=''
IF     KEYWORD_SET(notitle)  THEN                    subtitle=''
IF     KEYWORD_SET(nozaxis)  THEN zaxis=-1 ELSE zaxis=3
w=ww(*,*,ii)
IF N_ELEMENTS(datp.x(0,*)) GT 1 THEN x =datp.x (*,ii*N_ELEMENTS(ww(0,*,0)):(ii+1)*N_ELEMENTS(ww(0,*,0))-1) ELSE x =datp.x
y=datp.y
SET_PLOT,'ps'
IF N_ELEMENTS(datp.p) GT 29 THEN BEGIN
  filename=strcompress(string(ROUND(datp.p(29))),/remove_all)+'W'+strcompress(string(alone),/remove_all)
ENDIF ELSE BEGIN
  filename=strcompress(string(W_NUMOR(alone)),/remove_all)+'W'+strcompress(string(alone),/remove_all)
ENDELSE
;PRINT,filename,alone,W_NUMOr
IF KEYWORD_SET(random) THEN filename=strcompress(string(round(systime(1) mod 1000)),/remove_all)
IF N_ELEMENTS(ww(0,0,*)) GT 1 THEN filename=filename+'_'+strcompress(string(ii),/remove_all)
filename=filename+'.ps'
IF KEYWORD_SET(eps) THEN eps=1 ELSE eps=0

DEVICE,FILENAME=filename,$
  /LANDSCAPE,XSIZE=25,YSIZE=15,YOFFSET=25,XOFFSET=5,$
  encapsulated=eps,BITS_PER_PIXEL=256,/color
index=WHERE((x LE xmax) AND (x GE xmin))
x=x(index)
w=w(index,*,ii)
IF N_ELEMENTS(w(0,*,0)) GT 1 THEN BEGIN
  index=WHERE((y LE ymax) AND (y GE ymin))
  y=y(index)
  w=w(*,index,ii)
  IF KEYWORD_SET(shade) THEN $
    SHADE_SURF,w,x,y        ,$
          zRANGE  = wrange,ax=ax,az=az, $
          xRANGE  = xrange, $
          CHARSIZE=0.5,CHARTHICK=0.7,xCHARSIZE=1.5*xaxis,yCHARSIZE=1.5*yaxis,zCHARSIZE=1.5,$
          xSTYLE     = 1+noxaxis*4,$
          ySTYLE     = 1+noyaxis*4,$
          zSTYLE     = 1+nozaxis*4,$
          xTICKFORMAT= xformat,$
          yTICKFORMAT= yformat,$
          zTICKFORMAT= wformat,$
          xTICKS     = xticks,$
          yTICKS     = yticks,$
          zTICKS     = wticks,$
          yRANGE  = [ymin,ymax], $
          TITLE   =title+'  '+subtitle    ,$
          xTITLE  =x_tit,$
          yTITLE  =y_tit,$
          zTITLE  =z_tit 
  IF KEYWORD_SET(contour) THEN $
    CONTOUR,w,x,y        ,$
          zRANGE  = wrange, $
          xRANGE  = xrange, $
          yRANGE  = [ymin,ymax], $
          xSTYLE     = 1+noxaxis*4,$
          ySTYLE     = 1+noyaxis*4,$
          xTICKFORMAT= xformat,$
          yTICKFORMAT= yformat,$
          xTICKS     = xticks,$
          yTICKS     = yticks,$
          TITLE   =title    ,$
          SUBTITLE=subtitle,$
          xTITLE  =x_tit,$
          yTITLE  =y_tit,$
          zTITLE  =z_tit 
  IF NOT (KEYWORD_SET(contour) OR KEYWORD_SET(shade)) THEN $
    SURFACE,w,x,y        ,$
          zRANGE     = wrange,ax=ax,az=az, $
          xRANGE     = xrange, $
          yRANGE     = [ymin,ymax], $
          CHARSIZE   = 0.5,CHARTHICK=0.7,xCHARSIZE=1.5*xaxis,yCHARSIZE=1.5*yaxis,zCHARSIZE=1.5,$
          xSTYLE     = 1+noxaxis*4,$
          ySTYLE     = 1+noyaxis*4,$
          zSTYLE     = 1+nozaxis*4,$
          xTICKFORMAT= xformat,$
          yTICKFORMAT= yformat,$
          zTICKFORMAT= wformat,$
          xTICKS     = xticks,$
          yTICKS     = yticks,$
          zTICKS     = wticks,$
          HORIZONTAL = vector,$
          zAXIS      = zaxis,$
          TITLE      = title+'  '+subtitle    ,$
          xTITLE     = x_tit,$
          yTITLE     = y_tit,$
          zTITLE     = z_tit 
ENDIF ELSE BEGIN
  PLOT,x,w,$
       yRANGE  = wrange, psym=psym,$
       xRANGE  = xrange, $
       TITLE=datp.w_tit,$
       SUBTITLE=subtitle,$
       xTITLE=datp.x_tit,$
       yTITLE=datp.y_tit
  IF KEYWORD_SET(error) THEN OPLOTERR,x,w,datp.e,3 
ENDELSE
DEVICE,/CLOSE
IF NOT KEYWORD_SET(printer) THEN line='$lp -dlj1_d20 '+filename ELSE line='$lp -d'+printer+' '+filename
if NOT keyword_set(noprint) THEN  BEGIN
  PRINT,line
  XICUTE,line 
ENDIF
SET_PLOT,'X'
IF NOT KEYWORD_SET(noscreen) THEN BEGIN
  IF N_ELEMENTS(w(0,*)) GT 1 THEN BEGIN
  IF KEYWORD_SET(shade) THEN $
  IF KEYWORD_SET(shade) THEN $
    SHADE_SURF,w,x,y        ,$
          zRANGE  = wrange,ax=ax,az=az, $
          xRANGE  = xrange, $
          CHARSIZE=0.5,CHARTHICK=0.7,xCHARSIZE=1.5*xaxis,yCHARSIZE=1.5*yaxis,zCHARSIZE=1.5,$
          xSTYLE     = 1+noxaxis*4,$
          ySTYLE     = 1+noyaxis*4,$
          zSTYLE     = 1+nozaxis*4,$
          xTICKFORMAT= xformat,$
          yTICKFORMAT= yformat,$
          zTICKFORMAT= wformat,$
          xTICKS     = xticks,$
          yTICKS     = yticks,$
          zTICKS     = wticks,$
          yRANGE  = [ymin,ymax], $
          TITLE   =title+'  '+subtitle    ,$
          xTITLE  =x_tit,$
          yTITLE  =y_tit,$
          zTITLE  =z_tit 
  IF KEYWORD_SET(contour) THEN $
    CONTOUR,w,x,y        ,$
          zRANGE  = wrange, $
          xRANGE  = xrange, $
          yRANGE  = [ymin,ymax], $
          xSTYLE     = 1+noxaxis*4,$
          ySTYLE     = 1+noyaxis*4,$
          xTICKFORMAT= xformat,$
          yTICKFORMAT= yformat,$
          xTICKS     = xticks,$
          yTICKS     = yticks,$
          TITLE   =title    ,$
          SUBTITLE=subtitle,$
          xTITLE  =x_tit,$
          yTITLE  =y_tit,$
          zTITLE  =z_tit 
  IF NOT (KEYWORD_SET(contour) OR KEYWORD_SET(shade)) THEN $
    SURFACE,w,x,y        ,$
          zRANGE     = wrange,ax=ax,az=az, $
          xRANGE     = xrange, $
          yRANGE     = [ymin,ymax], $
          CHARSIZE   = 0.5,CHARTHICK=0.7,xCHARSIZE=1.5*xaxis,yCHARSIZE=1.5*yaxis,zCHARSIZE=1.5,$
          xSTYLE     = 1+noxaxis*4,$
          ySTYLE     = 1+noyaxis*4,$
          zSTYLE     = 1+nozaxis*4,$
          xTICKFORMAT= xformat,$
          yTICKFORMAT= yformat,$
          zTICKFORMAT= wformat,$
          xTICKS     = xticks,$
          yTICKS     = yticks,$
          zTICKS     = wticks,$
          HORIZONTAL = vector,$
          zAXIS      = zaxis,$
          TITLE      = title+'  '+subtitle    ,$
          xTITLE     = x_tit,$
          yTITLE     = y_tit,$
          zTITLE     = z_tit 
ENDIF ELSE BEGIN
  PLOT,x,w,$
       yRANGE  = wrange, psym=psym,$
       xRANGE  = xrange, $
       TITLE=datp.w_tit,$
       SUBTITLE=datp.other_tit,$
       xTITLE=datp.x_tit,$
       yTITLE=datp.y_tit
  IF KEYWORD_SET(error) THEN OPLOTERR,x,w,datp.e,3 
ENDELSE
ENDIF
ENDFOR
w=ww
;give_datp,datp
END
PRO	pure_GAUSS,X,A,F,PDER
	ON_ERROR,2                        ;Return to caller if an error occurs
	if a(2) ne 0.0 then Z = (X-A(1))/A(2) $	;GET Z
	else z= 10.
	EZ = EXP(-Z^2/2.)*(ABS(Z) LE 7.) ;GAUSSIAN PART IGNORE SMALL TERMS
	F = A(0)*EZ ;FUNCTIONS.
	IF N_PARAMS(0) LE 3 THEN RETURN ;NEED PARTIAL?
	PDER = FLTARR(N_ELEMENTS(X),3) ;YES, MAKE ARRAY.
	PDER(0,0) = EZ		;COMPUTE PARTIALS
	if a(2) ne 0. then PDER(0,1) = A(0) * EZ * Z/A(2)
	PDER(0,2) = PDER(*,1) * Z
	RETURN
END



FUNCTION q2d,w,wl,lambda=wl
 ; 2qtrue = 2qexp.-ZER

take_datp,datp
q=datp.x
e=datp.e
range=where(q gt 0.1)
q=q(range)
ww=ww(range)
e=e(range)
if n_elements(wl) eq 0 then if n_elements(datp.p) gt 9 then if datp.p(9) NE 0.0 THEN wl =datp.p(9) 
if n_elements(wl) eq 1 THEN BEGIN
  d=2.*!pi/q
  idx=sort(d)
  mod_datp,datp,'x',d(idx)
  mod_datp, datp, 'E', e(idx)
  mod_datp,datp,'x_tit','d/Ang'
  ww=ww(idx)
  give_datp,datp
  return,ww
ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
ENDELSE
END
FUNCTION q2tt,ww,wl,zeroshift=z
 ; 2qtrue = 2qexp.-ZER

IF NOT KEYWORD_SET(z) THEN z=0.
take_datp,datp
q=datp.x
e=datp.e
range=where(q gt 0)
q=q(range)
ww=ww(range)
e=e(range)
if n_elements(wl) eq 0 then if n_elements(datp.p) gt 9 then if datp.p(9) NE 0.0 THEN wl =datp.p(9) 
if n_elements(wl) eq 1 THEN BEGIN
  x=asin(wl/2.*q/2./!pi)*360./!pi
  idx=sort(x)
  mod_datp,datp,'x',x(idx)+z
  mod_datp, datp, 'E', e(idx)
  mod_datp,datp,'x_tit','2theta/deg'
  ww=ww(idx)
  give_datp,datp
  return,ww
ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
ENDELSE
END
	FUNCTION Q_cal,w_in

; Function to calibrate axes in terms of Q of 1-D or 2-D input data

; 						JRS 	3/2/00

	COMMON c_lamp_access, inst

	iprint=1	;GT 0 turns on debugging

	IF (iprint GT 0) THEN PRINT,'Starting q_cal:'

	take_datp,datp

;------------------------------------------------------------------------------
;Check dimensions section

        s=SIZE(w_in)
	IF (s(0) EQ 3) THEN nruns=s(3) ELSE nruns=1

        IF (s(0) GT 1) THEN BEGIN
		X0=datp.p(13)
		Y0=datp.p(14)
	ENDIF ELSE BEGIN
		X0=0.0
		Y0=0.0
	ENDELSE

	IF (inst EQ 'D22') THEN BEGIN
		pix=0.75
	ENDIF ELSE BEGIN
		pix=1.0
	ENDELSE

	lambda=datp.p(15)
        detd=datp.p(9)
	IF (iprint GT 0) THEN BEGIN
		PRINT,'            nruns: ',nruns
		PRINT,'       wavelength: ',lambda
		PRINT,'Detector Distance: ',detd
		PRINT,'       Pixel size: ',pix
	ENDIF
	IF (iprint GT 0) THEN PRINT,'q_cal: End of "check dimensions" section'

;-------------------------------------------------------------------------------
; Transform to Q

	thetax=0.5*(ATAN(((datp.x-X0)*pix)/(detd*100.)))
	x=FLOAT(4*!pi*SIN(thetax)/lambda)
        IF (s(0) GE 2 AND s(1) EQ s(2)) THEN BEGIN
		thetay=0.5*(ATAN(((datp.y-Y0)*pix)/(detd*100.)))
		y=FLOAT(4*!pi*SIN(thetay)/lambda)
		datp.y_tit='Qy (Angtroms^-1)'
		mod_datp, datp, "y", y
	ENDIF

        IF (s(0) GE 2 AND s(1) EQ s(2)) THEN BEGIN
		datp.x_tit='Qx (Angtroms^-1)'
        ENDIF ELSE BEGIN
		datp.x_tit='Q (Angtroms^-1)'
	ENDELSE
	IF (iprint GT 0) THEN PRINT,'q_cal: End of "transform to Q" section'

;-------------------------------------------------------------------------------
; Return data

	swav=STRTRIM(STRING(lambda),2)
	sdet=STRTRIM(STRING(detd),2)
	datp.other_tit=datp.other_tit+' -qc('+inst+','+swav+','+sdet+')'
	mod_datp, datp, "x", x 
	give_datp, datp
	
	RETURN, w_in
	END
pro qcellcompare,s,n1,n2,int_ratio=int_ratio,sig_ratio=sig_ratio,plot=plot,$
                     print=print,color=color,truecolors=truecolors,wset=wset,$
                     exclusions=exclusions
;+
; NAME:
;	qcellcompare
;
; PURPOSE:
;	This procedure is the basic routine called from alignloop to calculate relative efficiencies
;
; CATEGORY:
;	Instrument.
;
; CALLING SEQUENCE:
;	qcellcompare,s,n1,n2,int_ratio=int_ratio,sig_ratio=sig_ratio,plot=plot,print=print,color=color,truecolors=truecolors,wset=wset,exclusions=exclusions
;
; INPUTS:
;   s		:	Workspace (2D array, nd * steps elements, as defined in LAMP, normally a 2theta scan over a vanadium)
;	n1		:	detector cell number to be compared with ...
;	n2		:	second detector cell number to be compared to n1
;
; OPTIONAL INPUTS:
;	none
;	
; KEYWORD PARAMETERS:
;	int_ratio	:	intensity ratio of n1 and n2
;	sig_ratio	:	?
;	plot		:	if set, some output will be plotted
;	print		:	if set, some printed output will be created
;	color		:	?
;	truecolors	:	?
;	wset		:	window to be used for plotting output
;	exclusions	:	?
;
; OUTPUTS:
;	none
;
; OPTIONAL OUTPUTS:
;	none
;
; COMMON BLOCKS:
;	none
;
; SIDE EFFECTS:
;	none
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
; 	methods of error calculation are set according to  "Statistics for nuclear and particle physicists" by L.Lyon that can be found 
; 	in the ILL library (number 5 68)
; 	each calculation is commented 
;
; EXAMPLE:
;	(in LAMP)
;	RDSET,inst='D20',base="Loc Cycle 005" 
;	flag,/nor,/noint,/nobad,/flp,/noeff,/noang
;	w1=RDRUN(19512)
;   ALIGNLOOP(w1,800,x1=x,y1=y,e1=e,s0=s,r0=r)
;
; MODIFICATION HISTORY:
; 	Written by:		Steffen Metzger,	August 1998.
;	Modified by:	Thomas C Hansen,	November 2000 (weighted error calculations)
;
;-
	steps=N_ELEMENTS(s(0,*))
	cells=N_ELEMENTS(s(*,0))
	n1=n1>0
	n1=n1<(cells-1)
	n2=n2>0
	n2=n2<(cells-1)
	nmin=min([n1,n2])
	nmax=max([n1,n2])+steps
	ymin=min(s([n1,n2],*))
	ymax=max(s([n1,n2],*))
	IF KEYWORD_SET(plot) THEN BEGIN
		IF N_ELEMENTS(color) LT 8 THEN colors,color,truecolors=truecolors,/noprint
		IF KEYWORD_SET(wset) THEN wset,0 ELSE window,0,xsi=800,title='Compare cells '+STRCOMPRESS(n1)+' and'+STRCOMPRESS(n2),ysi=400
		cell,s,n1,index=x1,counts=y1,xticklen=1,xgridst=1,xrange=[nmin,nmax<cells],yrange=[ymin,ymax],back=color(4),color=color(0),xstyle=1
		cell,s,n2,index=x2,counts=y2,/oplot,color=color(1),/error
	ENDIF ELSE BEGIN
		x1=indgen(steps)+n1  ; former qcell-call ...
		y1=s(n1,*) 
		x2=indgen(steps)+n2
		y2=s(n2,*)
	ENDELSE
	cmin=max([min(x1),min(x2)])
	cmax=min([max(x1),max(x2)])
	i1=where(x1 ge cmin and x1 le cmax,comcount)
	i2=where(x2 ge cmin and x2 le cmax)
	com=x1(i1)
	celln=BYTARR(cells+steps)
	celln(com)=1
	IF KEYWORD_SET(exclusions) THEN celln(exclusions)=0
	celln=celln(cmin:cmax)
	i1=i1(where(celln EQ 1))
	com=x1(i1)
	i2=i2(where(celln EQ 1))
	ratio=(y1(i1))/(y2(i2))     ;	ratio of cell counting rates  
	e1=SQRT(y1)                 ;	square root of counting rates, (Poisson-distribution)  
	e2=SQRT(y2)
	sigm=ratio*SQRT(((e1(i1))/(y1(i1)))^2+((e2(i2))/(y2(i2)))^2)   ;	error calculatiom in non-linear situation  
	IF KEYWORD_SET(plot) THEN BEGIN
		IF KEYWORD_SET(wset) THEN wset,1 ELSE window,1,title='Ratio cells '+STRCOMPRESS(n1)+' and'+STRCOMPRESS(n2),ysi=380,xsi=800
		plot,com,ratio,back=color(0),yrange=[min(ratio),max(ratio)],xrange=[nmin,nmax<cells],xstyle=1
	 	IF N_ELEMENTS(com) GT 1 THEN oploterr,com,ratio,sigm
	ENDIF
	okay =where(ratio NE 0 AND sigm ne 0,okcount)
	IF okcount GE 1 THEN BEGIN
		int_ratio=(TOTAL(ratio(okay)))/okcount 	;	mean of ratios, after the angles below the beamstop have been excluded, the formula for the 
	                                       		;	weighted mean int_ratio=TOTAL((ratio(okay))/((sigm(okay))^2))/(TOTAL(1/(sigm(okay))^2)) can
	                                       		;	be used  
		sig_ratio=SQRT(TOTAL(((sigm(okay))/okcount)^2))	;	derived from error calculation in a linear situation; for the weighted mean the 
	    	                                           	;	error is sig_ratio=SQRT(1/TOTAL(1/(sigm(okay))^2))
	ENDIF 
	IF KEYWORD_SET(print) THEN BEGIN
		IF okcount GE 1 THEN BEGIN
			PRINT,FORMAT="('Compare',2I5,' - weighted :',2G12.6)",n1,n2,int_ratio,sig_ratio
		ENDIF ELSE PRINT,FORMAT="('Compare',2I5,' - no valid overlap!')",n1,n2
	ENDIF 
END
pro qcell,s,cell,index=index,counts=counts

index=indgen(N_ELEMENTS(s(0,*)))+cell
counts=s(cell,*)
end
PRO qcompare2allcells,s,n,xx=xx,exclusions=exclusions,$
                       int_ratio=int_ratio,sig_ratio=sig_ratio,$
                       noprint=noprint,plot=plot,single=single,truecolors=truecolors
;+
; NAME:
;	qcompare2allcells
;
; PURPOSE:
;	This procedure is the first routine called from alignloop to calculate relative efficiencies
;
; CATEGORY:
;	Instrument.
;
; CALLING SEQUENCE:
;	qcompare2allcells,s,n
;
; INPUTS:
;   s		:	Workspace (2D array, nd * steps elements, as defined in LAMP, normally a 2theta scan over a vanadium)
;	n		:	detector cell number to be compared to all others
;
; OPTIONAL INPUTS:
;	none
;	
; KEYWORD PARAMETERS:
;	xx			:	?
;	exclusions	:	?
;	int_ratio	:	intensity ratio of n1 and n2
;	sig_ratio	:	?
;	noprint		:	if set, no printed output will be created
;	plot		:	if set, some output will be plotted
;	single		:	?
;	truecolors	:	?
;
; OUTPUTS:
;	none
;
; OPTIONAL OUTPUTS:
;	none
;
; COMMON BLOCKS:
;	none
;
; SIDE EFFECTS:
;	none
;
; RESTRICTIONS:
;	none
;
; PROCEDURE:
; 	methods of error calculation are set according to  "Statistics for nuclear and particle physicists" by L.Lyon that can be found 
; 	in the ILL library (number 5 68)
; 	each calculation is commented 
;
; EXAMPLE:
;	(in LAMP)
;	RDSET,inst='D20',base="Loc Cycle 005" 
;	flag,/nor,/noint,/nobad,/flp,/noeff,/noang
;	w1=RDRUN(19512)
;   ALIGNLOOP(w1,800,x1=x,y1=y,e1=e,s0=s,r0=r)
;
; MODIFICATION HISTORY:
; 	Written by:		Steffen Metzger,	August 1998.
;	Modified by:	Thomas C Hansen,	November 2000 (documentation)
;
;-
	wset=0
	IF NOT keyword_SET(plot) THEN plot=0 ELSE wset=1
	IF NOT keyword_SET(truecolors) THEN truecolors=0
	IF KEYWORD_SET(single) THEN noprint=0 ELSE single=0
	n=LONG(n)
	steps=N_ELEMENTS(s(0,*))
	cells=N_ELEMENTS(s(*,0))
	nmin=n-(steps-2)>0
	nmax=n+(steps-2)<(cells-1)
	xx=indgen(nmax-nmin+1)+nmin
	int_ratio=DBLARR(nmax-nmin+1)+1
	sig_ratio=int_ratio*DOUBLE(0)
	FOR i=nmin,nmax DO BEGIN 
		IF i NE n THEN BEGIN
			qcellcompare,s,n,i,int_ratio=int,sig_ratio=sig,plot=plot,wset=wset,print=single,true=truecolors,exclusions=exclusions
			IF NOT KEYWORD_SET(noprint) THEN IF NOT KEYWORD_SET(single) THEN PRINT,i,int,sig
 			int_ratio(where(xx eq i))=int
			sig_ratio(where(xx eq i))=sig
		ENDIF
	ENDFOR
END
; ** ***************************************************************************************
; ** Program qens_fit
; ** This module permits to fit Quasi-elastic data to a set of
; ** different models (translations, rotations, jumps ...)
; ** S. Rols 09/01 srols@anl.gov
; ** Last modification: 02/04/02
; ** Last modification: 15/05/02 - correction of several buggs when fitting all spectra 
; **                             - modification of the output files format
; ** Last modification: 21/05/02 - modification of the convolution routine ... use of convol
; ** Last modification: 28/05/02 - modification of the convolution routine ... use of convol
; ** Last modification: 07/07/02 - symetrization of the slopping backg or constant backg
; ** ****************************************************************************************

; ** **************************************************************
pro create_commons
; ** **************************************************************
; ** Just to create correct commons while compiling.
; ** Explains also variables



common sc_wid, $
			sw_ba_leader,								$;Widget Id of leader base
			sw_bu_filem, sw_bu_exitm,					$
			sw_bu_fitm,sw_bu_lgm,sw_bu_isorotm,			$
			sw_bu_axrotm,sw_bu_rwm,						$
			sw_ba_up,sw_ba_up1,sw_ba_up2,sw_ba_up3,		$
			sw_ba_up11,sw_ba_up12,						$
			sw_ba_up21,sw_ba_up22,						$
			sw_ba_up31,sw_ba_up32,						$
			sw_bu_gwin,sw_bu_gres,sw_bu_wwou,			$
			sw_bu_winf,sw_bu_resf,sw_bu_wouf,			$
			sw_bu_winb,sw_bu_resb,sw_bu_woub,			$
			sw_la_win,sw_la_res,sw_la_wou,				$
			sw_ba_mid,sw_ba_mid2,sw_ba_mid3,			$
			sw_ba_mid11,sw_ba_mid12,sw_ba_mid13,		$
			sw_ba_mid14,sw_ba_mid15,					$
			sw_la_xmin,sw_la_xmax,sw_la_ymin,			$
			sw_la_ymax,sw_la_wsub,sw_tx_xmin,			$
			sw_tx_xmax,sw_tx_ymin,sw_tx_ymax,			$
			sw_tx_wsub,sw_bu_plot,sw_bu_plre,			$
			sw_pl_area,sw_ba_plre,sw_bu_norm,			$
			sw_ba_bot,sw_bu_start,sw_bu_cancel,			$
			sw_la_nlor,sw_la_ngau,sw_tx_resmin,			$
			sw_tx_nlor,sw_tx_ngau,sw_tx_resmax,			$
			sw_tx_balg2,sw_bu_balg2,sw_tx_fwsub,		$
			sw_tx_fxmin,sw_tx_fxmax,sw_tx_cycl,			$
			sw_pl_areabot,sw_bu_gdos,sw_bu_fit,     $
      sw_bu_done,sw_bu_try,sw_bu_fitall,      $
      sw_bu_acquire,sw_tx_acquire,sw_bu_reverse,$
      sw_bu_fromlast,sw_bu_symsqw,sw_tx_temp

common sc_loc, $
			sw_in,sw_res,sw_ou,sw_result,				$ ; input Workspaces (input,res fun,output)
			str_win,str_wres,str_wou,					$ ; input Worksp strings (input,res fun,output)
			sx_in,sx_res,sx_ou,sx_result,				$ ; input X
			sy_in,sy_res,sy_ou,sy_result,				$ ; input Y
			se_in,se_res,se_ou,se_result,				$ ; input errors
			s_pl_wid,num_spectrum,nb_spe_tot,			$
			nb_channels,x_to_plot,w_wk,w_wkres,e_wk,	$ ; variables de plot (x,S(q,w),Resf(Q,w) normee, error)
			w_resc,e_resc,ce,							$ ; res. func treated and its error for the convolution
			xmin,xmax,ymin,ymax,s_pl_widbot


common sc_flag, $
			flag_pl_res,flag_norm,						$ ;
			flag_lfit,flag_gfit,flag_lcfit,flag_gcfit,	$ ;
			flag_lwfit,flag_gwfit,flag_lifit,flag_gifit,$ ;
			flag_dfit,flag_dcfit,flag_difit,			$ ;
			flag_bfit,flag_bcfit,flag_bifit,			$ ;
			flag_lgifit,flag_pl_fit,flag_lect_in, $
      flag_pl_fit2,flag_all,flag_reverse,flag_fromlast, $
      flag_sym

common sc_fit,	$
			num_lor,num_gau,rfmin,rfmax,				$ ;
			sf_index,sf_values,ibmin,ibmintx,idmin,		$ ;
			idmintx,igmin,igmintx,igminind,idminind,	$ ;
			ibminind,sf_param_to_fit,sf_new_values,		$ ;
			sf_last_values,sf_xmin,sf_xmax,				$ ;
			sf_sp_num_min,sf_sp_num_max,sf_iter_num,	$ ;
			sf_w_fitted,sf_e_values,sf_w_exp_fit,		$ ;
			sf_sub_function,name_func,sf_new,sf_e,  $
      sf_functions_labels,sf_errors_labels,chisqr,betatemp

common sc_convs,$
			aalpha,abeta,lmin,lmax,cel,fwhm_rf,center_rf

common sc_lorgau,$
			n_l,n_g,ispecc,falpha,fbeta,w_resc2,w_resc2_interp

end

; ** ********************************************************************* ** ;
; ** ********************************************************************* ** ;
; ** This is the complete contain of the MPFIT.pro program developed       ** ;
; ** by C. B. Markwardt, NASA/GSFC, craigm@lheamail.gsfc.nasa.edu          ** ;
; ** The complete notice on how to use this routine is developed in the    ** ;
; ** MPFIT.pro file as well as on the web page :                           ** ;
; ** http://cow.physics.wisc.edu/~craigm/idl/fitting.html                  ** ;
; ** ********************************************************************* ** ;
; ** ********************************************************************* ** ;

pro mpfit_dummy
  ;; Enclose in a procedure so these are not defined in the main level
  forWARD_function mpfit_fdjac2, mpfit_enorm, mpfit_lmpar, mpfit_covar, $
    mpfit, mpfit_call

  common mpfit_error, error_code  ;; For error passing to user function
  common mpfit_config, mpconfig   ;; For internal error configrations
end

;; Reset profiling registers for another run.  By default, and when
;; uncommented, the profiling registers simply accumulate.

pro mpfit_resetprof
  common mpfit_profile, mpfit_profile_vals

  mpfit_profile_vals = { status: 1L, fdjac2: 0D, lmpar: 0D, mpfit: 0D, $
                         qrfac: 0D,  qrsolv: 0D, enorm: 0D}
  return
end

;; Following are machine constants that can be loaded once.  I have
;; found that bizarre underflow messages can be produced in each call
;; to MACHAR(), so this structure minimizes the number of calls to
;; one.

pro mpfit_setmachar, double=isdouble
  common mpfit_profile, profvals
  if n_elements(profvals) eq 0 then mpfit_resetprof

  common mpfit_machar, mpfit_machar_vals

  ;; In earlier versions of IDL, MACHAR itself could produce a load of
  ;; error messages.  We try to mask some of that out here.
  if (!version.release) lt 5 then dummy = check_math(1, 1)

  mch = 0.
  mch = machar(double=keyword_set(isdouble))
  dmachep = mch.eps
  dmaxnum = mch.xmax
  dminnum = mch.xmin
  dmaxlog = alog(mch.xmax)
  dminlog = alog(mch.xmin)
  if keyword_set(isdouble) then $
    dmaxgam = 171.624376956302725D $
  else $
    dmaxgam = 171.624376956302725
  drdwarf = sqrt(dminnum*1.5) * 10
  drgiant = sqrt(dmaxnum) * 0.1

  mpfit_machar_vals = {machep: dmachep, maxnum: dmaxnum, minnum: dminnum, $
                       maxlog: dmaxlog, minlog: dminlog, maxgam: dmaxgam, $
                       rdwarf: drdwarf, rgiant: drgiant}

  if (!version.release) lt 5 then dummy = check_math(0, 0)

  return
end



;; Call user function or procedure, with _EXTRA or not, with
;; derivatives or not.
function mpfit_call, fcn, x, fjac, _EXTRA=extra

  on_error, 2
  common mpfit_config, mpconfig

  if keyword_set(mpconfig.qanytied) then mpfit_tie, x, mpconfig.ptied

  ;; Decide whether we are calling a procedure or function
  if mpconfig.proc then proc = 1 else proc = 0
  mpconfig.nfev = mpconfig.nfev + 1

  if proc then begin
      if n_params() eq 3 then begin
          if n_elements(extra) gt 0 then $
            call_procedure, fcn, x, f, fjac, _EXTRA=extra $
          else $
            call_procedure, fcn, x, f, fjac
      endif else begin
          if n_elements(extra) gt 0 then $
            call_procedure, fcn, x, f, _EXTRA=extra $
          else $
            call_procedure, fcn, x, f
      endelse
  endif else begin
      if n_params() eq 3 then begin
          if n_elements(extra) gt 0 then $
            f = call_function(fcn, x, fjac, _EXTRA=extra) $
          else $
            f = call_function(fcn, x, fjac)
      endif else begin
          if n_elements(extra) gt 0 then $
            f = call_function(fcn, x, _EXTRA=extra) $
          else $
            f = call_function(fcn, x)
      endelse
  endelse

  if n_params() eq 2 and mpconfig.damp gt 0 then begin
      damp = mpconfig.damp(0)

      ;; Apply the damping if requested.  This replaces the residuals
      ;; with their hyperbolic tangent.  Thus residuals larger than
      ;; DAMP are essentially clipped.
      f = tanh(f/damp)
  endif

  return, f
end

function mpfit_fdjac2, fcn, x, fvec, step, ulimited, ulimit, dside, $
                 iflag=iflag, epsfcn=epsfcn, autoderiv=autoderiv, $
                 FUNCTARGS=fcnargs, xall=xall, ifree=ifree, dstep=dstep

  common mpfit_machar, machvals
  common mpfit_profile, profvals
  common mpfit_error, mperr

;  prof_start = systime(1)
  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum

  if n_elements(epsfcn) eq 0 then epsfcn = MACHEP0
  if n_elements(xall)   eq 0 then xall = x
  if n_elements(ifree)  eq 0 then ifree = lindgen(n_elements(xall))
  if n_elements(step)   eq 0 then step = x * 0.
  nall = n_elements(xall)

  eps = sqrt(max([epsfcn, MACHEP0]));
  m = n_elements(fvec)
  n = n_elements(x)

  ;; Compute analytical derivative if requested
  if not keyword_set(autoderiv) then begin
      mperr = 0
      fjac = intarr(nall)
      fjac(ifree) = 1      ;; Specify which parameters need derivatives
      fp = mpfit_call(fcn, xall, fjac, _EXTRA=fcnargs)
      iflag = mperr

      if n_elements(fjac) ne m*nall then begin
          message, 'ERRor: Derivative matrix was not computed properly.', /info
          iflag = 1
;          profvals.fdjac2 = profvals.fdjac2 + (systime(1) - prof_start)
          return, 0
      endif

      ;; This definition is consistent with CURVEFIT
      ;; Sign error found (thanks Jesus Fernandez <fernande@irm.chu-caen.fr>)
      fjac = reform(-temporary(fjac), m, nall, /overwrite)

      ;; Select only the free parameters
      if n_elements(ifree) lt nall then $
        fjac = reform(fjac(*,ifree), m, n, /overwrite)
;      profvals.fdjac2 = profvals.fdjac2 + (systime(1) - prof_start)
      return, fjac
  endif

  fjac = make_array(m, n, value=fvec(0)*0.)
  fjac = reform(fjac, m, n, /overwrite)

  h = eps * abs(x)

  ;; if STEP is given, use that
  if n_elements(step) gt 0 then begin
      wh = where(step gt 0, ct)
      if ct gt 0 then h(wh) = step(wh)
  endif

  ;; if relative step is given, use that
  if n_elements(dstep) gt 0 then begin
      wh = where(dstep gt 0, ct)
      if ct gt 0 then h(wh) = abs(dstep(wh)*x(wh))
  endif

  ;; In case any of the step values are zero
  wh = where(h eq 0, ct)
  if ct gt 0 then h(wh) = eps

  ;; Reverse the sign of the step if we are up against the parameter
  ;; limit, or if the user requested it.
  mask = dside eq -1
  if n_elements(ulimited) gt 0 and n_elements(ulimit) gt 0 then $
    mask = mask or (ulimited and (x gt ulimit-h))
  wh = where(mask, ct)
  if ct gt 0 then h(wh) = -h(wh)

  ;; Loop through parameters, computing the derivative for each
  for j=0L, n-1 do begin
      xp = xall
      xp(ifree(j)) = xp(ifree(j)) + h(j)

      mperr = 0
      fp = mpfit_call(fcn, xp, _EXTRA=fcnargs)

      iflag = mperr
      if iflag lt 0 then return, !values.d_nan

      if abs(dside(j)) le 1 then begin
          ;; COMPUTE THE One-SIDED DERIVATIVE
          ;; Note optimization fjac(0:*,j)
          fjac(0,j) = (fp-fvec)/h(j)

      endif else begin
          ;; COMPUTE THE TWO-SIDED DERIVATIVE
          xp(ifree(j)) = xall(ifree(j)) - h(j)

          mperr = 0
          fm = mpfit_call(fcn, xp, _EXTRA=fcnargs)

          iflag = mperr
          if iflag lt 0 then return, !values.d_nan

          ;; Note optimization fjac(0:*,j)
          fjac(0,j) = (fp-fm)/(2*h(j))
      endelse

  endfor

;  profvals.fdjac2 = profvals.fdjac2 + (systime(1) - prof_start)
  return, fjac
end

function mpfit_enorm, vec

  ;; notE: it turns out that, for systems that have a lot of data
  ;; points, this routine is a big computing bottleneck.  The extended
  ;; computations that need to be done cannot be effectively
  ;; vectorized.  The introduction of the FASTNorM configuration
  ;; parameter allows the user to select a faster routine, which is
  ;; based on total() alone.
  common mpfit_profile, profvals
;  prof_start = systime(1)

  common mpfit_config, mpconfig
; Very simple-minded sum-of-squares
  if n_elements(mpconfig) gt 0 then if mpconfig.fastnorm then begin
      ans = sqrt(total(vec^2))
      goto, TERminATE
  endif

  common mpfit_machar, machvals

  agiant = machvals.rgiant / n_elements(vec)
  adwarf = machvals.rdwarf * n_elements(vec)

  ;; This is hopefully a compromise between speed and robustness.
  ;; Need to do this because of the possibility of over- or underflow.
  mx = max(vec, min=mn)
  mx = max(abs([mx,mn]))
  if mx eq 0 then return, vec(0)*0.

  if mx gt agiant or mx lt adwarf then ans = mx * sqrt(total((vec/mx)^2))$
  else                                 ans = sqrt( total(vec^2) )

  TERminATE:
;  profvals.enorm = profvals.enorm + (systime(1) - prof_start)
  return, ans
end

pro mpfit_qrfac, a, ipvt, rdiag, acnorm, pivot=pivot

  sz = size(a)
  m = sz(1)
  n = sz(2)

  common mpfit_machar, machvals
  common mpfit_profile, profvals
;  prof_start = systime(1)

  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum

  ;; Compute the initial column norms and initialize arrays
  acnorm = make_array(n, value=a(0)*0.)
  for j = 0L, n-1 do $
    acnorm(j) = mpfit_enorm(a(*,j))
  rdiag = acnorm
  wa = rdiag
  ipvt = lindgen(n)

  ;; Reduce a to r with householder transformations
  minmn = min([m,n])
  for j = 0L, minmn-1 do begin
      if not keyword_set(pivot) then goto, HOUSE1

      ;; Bring the column of largest norm into the pivot position
      rmax = max(rdiag(j:*))
      kmax = where(rdiag(j:*) eq rmax, ct) + j
      if ct le 0 then goto, HOUSE1
      kmax = kmax(0)

      ;; Exchange rows via the pivot only.  Avoid actually exchanging
      ;; the rows, in case there is lots of memory transfer.  The
      ;; exchange occurs later, within the body of MPFIT, after the
      ;; extraneous columns of the matrix have been shed.
      if kmax ne j then begin
          temp     = ipvt(j)   & ipvt(j)    = ipvt(kmax) & ipvt(kmax)  = temp
          rdiag(kmax) = rdiag(j)
          wa(kmax)    = wa(j)
      endif

      HOUSE1:

      ;; Compute the householder transformation to reduce the jth
      ;; column of A to a multiple of the jth unit vector
      lj     = ipvt(j)
      ajj    = a(j:*,lj)
      ajnorm = mpfit_enorm(ajj)
      if ajnorm eq 0 then goto, neXT_ROW
      if a(j,j) lt 0 then ajnorm = -ajnorm

      ajj     = ajj / ajnorm
      ajj(0)  = ajj(0) + 1
      ;; *** Note optimization a(j:*,j)
      a(j,lj) = ajj

      ;; Apply the transformation to the remaining columns
      ;; and update the norms

      ;; notE to SELF: tried to optimize this by removing the loop,
      ;; but it actually got slower.  Reverted to "for" loop to keep
      ;; it simple.
      if j+1 lt n then begin
          for k=j+1, n-1 do begin
              lk = ipvt(k)
              ajk = a(j:*,lk)
              ;; *** Note optimization a(j:*,lk)
              ;; (corrected 20 Jul 2000)
              if a(j,lj) ne 0 then $
                a(j,lk) = ajk - ajj * total(ajk*ajj)/a(j,lj)

              if keyword_set(pivot) and rdiag(k) ne 0 then begin
                  temp = a(j,lk)/rdiag(k)
                  rdiag(k) = rdiag(k) * sqrt((1.-temp^2) > 0)
                  temp = rdiag(k)/wa(k)
                  if 0.05D*temp*temp le MACHEP0 then begin
                      rdiag(k) = mpfit_enorm(a(j+1:*,lk))
                      wa(k) = rdiag(k)
                  endif
              endif
          endfor
      endif

      neXT_ROW:
      rdiag(j) = -ajnorm
  endfor

;  profvals.qrfac = profvals.qrfac + (systime(1) - prof_start)
  return
end

pro mpfit_qrsolv, r, ipvt, diag, qtb, x, sdiag

  sz = size(r)
  m = sz(1)
  n = sz(2)
  delm = lindgen(n) * (m+1) ;; Diagonal elements of r

  common mpfit_profile, profvals
;  prof_start = systime(1)

  ;; copy r and (q transpose)*b to preserve input and initialize s.
  ;; in particular, save the diagonal elements of r in x.

  for j = 0L, n-1 do $
    r(j:n-1,j) = r(j,j:n-1)
  x = r(delm)
  wa = qtb
  ;; Below may look strange, but it's so we can keep the right precision
  zero = qtb(0)*0.
  half = zero + 0.5
  quart = zero + 0.25

  ;; Eliminate the diagonal matrix d using a givens rotation
  for j = 0L, n-1 do begin
      l = ipvt(j)
      if diag(l) eq 0 then goto, STorE_RESTorE
      sdiag(j:*) = 0
      sdiag(j) = diag(l)

      ;; The transformations to eliminate the row of d modify only a
      ;; single element of (q transpose)*b beyond the first n, which
      ;; is initially zero.

      qtbpj = zero
      for k = j, n-1 do begin
          if sdiag(k) eq 0 then goto, ELIM_neXT_LOOP
          if abs(r(k,k)) lt abs(sdiag(k)) then begin
              cotan  = r(k,k)/sdiag(k)
              sine   = half/sqrt(quart + quart*cotan*cotan)
              cosine = sine*cotan
          endif else begin
              tang   = sdiag(k)/r(k,k)
              cosine = half/sqrt(quart + quart*tang*tang)
              sine   = cosine*tang
          endelse

          ;; Compute the modified diagonal element of r and the
          ;; modified element of ((q transpose)*b,0).
          r(k,k) = cosine*r(k,k) + sine*sdiag(k)
          temp = cosine*wa(k) + sine*qtbpj
          qtbpj = -sine*wa(k) + cosine*qtbpj
          wa(k) = temp

          ;; Accumulate the transformation in the row of s
          if n gt k+1 then begin
              temp = cosine*r(k+1:n-1,k) + sine*sdiag(k+1:n-1)
              sdiag(k+1:n-1) = -sine*r(k+1:n-1,k) + cosine*sdiag(k+1:n-1)
              r(k+1:n-1,k) = temp
          endif
ELIM_neXT_LOOP:
      endfor

STorE_RESTorE:
      sdiag(j) = r(j,j)
      r(j,j) = x(j)
  endfor

  ;; Solve the triangular system for z.  If the system is singular
  ;; then obtain a least squares solution
  nsing = n
  wh = where(sdiag eq 0, ct)
  if ct gt 0 then begin
      nsing = wh(0)
      wa(nsing:*) = 0
  endif

  if nsing ge 1 then begin
      wa(nsing-1) = wa(nsing-1)/sdiag(nsing-1) ;; Degenerate case
      ;; *** Reverse loop ***
      for j=nsing-2,0,-1 do begin
          sum = total(r(j+1:nsing-1,j)*wa(j+1:nsing-1))
          wa(j) = (wa(j)-sum)/sdiag(j)
      endfor
  endif

  ;; Permute the components of z back to components of x
  x(ipvt) = wa

;  profvals.qrsolv = profvals.qrsolv + (systime(1) - prof_start)
  return
end
;
function mpfit_lmpar, r, ipvt, diag, qtb, delta, x, sdiag, par=par

  common mpfit_machar, machvals
  common mpfit_profile, profvals
;  prof_start = systime(1)

  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum

  sz = size(r)
  m = sz(1)
  n = sz(2)
  delm = lindgen(n) * (m+1) ;; Diagonal elements of r

  ;; Compute and store in x the gauss-newton direction.  If the
  ;; jacobian is rank-deficient, obtain a least-squares solution
  nsing = n
  wa1 = qtb
  wh = where(r(delm) eq 0, ct)
  if ct gt 0 then begin
      nsing = wh(0)
      wa1(wh(0):*) = 0
  endif

  if nsing gt 1 then begin
      ;; *** Reverse loop ***
      for j=nsing-1,0,-1 do begin
          wa1(j) = wa1(j)/r(j,j)
          if (j-1 ge 0) then $
            wa1(0:(j-1)) = wa1(0:(j-1)) - r(0:(j-1),j)*wa1(j)
      endfor
  endif

  ;; Note: ipvt here is a permutation array
  x(ipvt) = wa1

  ;; Initialize the iteration counter.  Evaluate the function at the
  ;; origin, and test for acceptance of the gauss-newton direction
  iter = 0L
  wa2 = diag * x
  dxnorm = mpfit_enorm(wa2)
  fp = dxnorm - delta
  if fp le 0.1*delta then goto, TERminATE

  ;; If the jacobian is not rank deficient, the newton step provides a
  ;; lower bound, parl, for the zero of the function.  Otherwise set
  ;; this bound to zero.

  zero = wa2(0)*0.
  parl = zero
  if nsing ge n then begin
      wa1 = diag(ipvt)*wa2(ipvt)/dxnorm

      wa1(0) = wa1(0) / r(0,0) ;; Degenerate case
      for j=1L, n-1 do begin   ;; Note "1" here, not zero
          sum = total(r(0:(j-1),j)*wa1(0:(j-1)))
          wa1(j) = (wa1(j) - sum)/r(j,j)
      endfor

      temp = mpfit_enorm(wa1)
      parl = ((fp/delta)/temp)/temp
  endif

  ;; Calculate an upper bound, paru, for the zero of the function
  for j=0, n-1 do begin
      sum = total(r(0:j,j)*qtb(0:j))
      wa1(j) = sum/diag(ipvt(j))
  endfor
  gnorm = mpfit_enorm(wa1)
  paru  = gnorm/delta
  if paru eq 0 then paru = DWARF/min([delta,0.1])

  ;; If the input par lies outside of the interval (parl,paru), set
  ;; par to the closer endpoint

  par = max([par,parl])
  par = min([par,paru])
  if par eq 0 then par = gnorm/dxnorm

  ;; Beginning of an interation
  ITERATION:
  iter = iter + 1

  ;; Evaluate the function at the current value of par
  if par eq 0 then par = max([DWARF, paru*0.001])
  temp = sqrt(par)
  wa1 = temp * diag
  mpfit_qrsolv, r, ipvt, wa1, qtb, x, sdiag
  wa2 = diag*x
  dxnorm = mpfit_enorm(wa2)
  temp = fp
  fp = dxnorm - delta

  if (abs(fp) le 0.1D*delta) $
    or ((parl eq 0) and (fp le temp) and (temp lt 0)) $
    or (iter eq 10) then goto, TERminATE

  ;; Compute the newton correction
  wa1 = diag(ipvt)*wa2(ipvt)/dxnorm

  for j=0,n-2 do begin
      wa1(j) = wa1(j)/sdiag(j)
      wa1(j+1:n-1) = wa1(j+1:n-1) - r(j+1:n-1,j)*wa1(j)
  endfor
  wa1(n-1) = wa1(n-1)/sdiag(n-1) ;; Degenerate case

  temp = mpfit_enorm(wa1)
  parc = ((fp/delta)/temp)/temp

  ;; Depending on the sign of the function, update parl or paru
  if fp gt 0 then parl = max([parl,par])
  if fp lt 0 then paru = min([paru,par])

  ;; Compute an improved estimate for par
  par = max([parl, par+parc])

  ;; End of an iteration
  goto, ITERATION

TERminATE:
  ;; Termination
;  profvals.lmpar = profvals.lmpar + (systime(1) - prof_start)
  if iter eq 0 then return, par(0)*0.
  return, par
end

;; Procedure to tie one parameter to another.
pro mpfit_tie, p, _ptied
  if n_elements(_ptied) eq 0 then return
  if n_elements(_ptied) eq 1 then if _ptied(0) eq '' then return
  for _i = 0L, n_elements(_ptied)-1 do begin
      if _ptied(_i) eq '' then goto, neXT_TIE
      _cmd = 'p('+strtrim(_i,2)+') = '+_ptied(_i)
      _err = execute(_cmd)
      if _err eq 0 then begin
          message, 'ERRor: Tied expression "'+_cmd+'" failed.'
          return
      endif
      neXT_TIE:
  endfor
end

;; Default procedure to be called every iteration.  It simply prints
;; the parameter values.
pro mpfit_defiter, fcn, x, iter, fnorm, FUNCTARGS=fcnargs, $
                   quiet=quiet, iterstop=iterstop, parinfo=parinfo, $
                   format=fmt, pformat=pformat, _EXTRA=iterargs

  common mpfit_error, mperr
  mperr = 0
  if keyword_set(quiet) then return
  if n_params() eq 3 then begin
      fvec = mpfit_call(fcn, x, _EXTRA=fcnargs)
      fnorm = mpfit_enorm(fvec)^2
  endif
; *** Stef ajout
;if abs(fnorm) le 1e-20 then begin
;print, 'Probleme fnorm trop petit'
;stop
;endif
;if abs(fnorm) ge 1e+20 then begin
;print, 'Probleme fnorm trop grand'
;stop
;endif
; *** fin Stef ajout
  print, iter, fnorm, $
    format='("Iter ",I6,"   CHI-SQUARE = ",G20.8)'
  if n_elements(fmt) gt 0 then begin
      print, x, format=fmt
  endif else begin
      if n_elements(parinfo) gt 0 then begin
          parinfo_tags = tag_names(parinfo)
          wh = where(parinfo_tags eq 'PARNAME', ct)
          if ct eq 1 then begin
              plen = max(strlen(parinfo.parname)) < 25
              plen = strtrim(plen,2)
              p = string(parinfo.parname, format='("    ",A'+plen+'," = ")')
          endif
      endif
      if n_elements(p) eq 0 then $
        p = '    P('+strtrim(lindgen(n_elements(x)),2)+') = '
      if n_elements(pformat) eq 0 then pformat = '(G20.6)'
      p = p + string(x,format=string(pformat(0))) + '  '
      print, p, format='(A)'
  endelse

  if keyword_set(iterstop) then begin
      k = get_kbrd(0)
      if k eq string(byte(7)) then begin
          message, 'WARNING: minimization not complete', /info
          print, 'Do you want to terminate this procedure? (y/n)', $
            format='(A,$)'
          k = ''
          read, k
          if strupcase(strmid(k,0,1)) eq 'Y' then begin
              message, 'WARNING: Procedure is terminating.', /info
              mperr = -1
          endif
      endif
  endif

  return
end

;; Procedure to parse the parameter values in PARINFO
pro mpfit_parinfo, parinfo, tnames, tag, values, default=def, status=status, $
                   n_param=n

  status = 0
  if n_elements(n) eq 0 then n = n_elements(parinfo)

  if n eq 0 then begin
      if n_elements(def) eq 0 then return
      values = def
      status = 1
      return
  endif

  if n_elements(parinfo) eq 0 then goto, do_DEFAUlt
  if n_elements(tnames) eq 0 then tnames = tag_names(parinfo)
  wh = where(tnames eq tag, ct)

  if ct eq 0 then begin
      do_DEFAUlt:
      if n_elements(def) eq 0 then return
      values = make_array(n, value=def(0))
      values(0) = def
  endif else begin
      values = parinfo.(wh(0))
  endelse

  status = 1
  return
end

function mpfit_covar, rr, ipvt, tol=tol

  sz = size(rr)
  if sz(0) ne 2 then begin
      message, 'ERRor: r must be a two-dimensional matrix'
      return, -1L
  endif
  n = sz(1)
  if n ne sz(2) then begin
      message, 'ERRor: r must be a square matrix'
      return, -1L
  endif

  zero = rr(0) * 0.
  one  = zero  + 1.
  if n_elements(ipvt) eq 0 then ipvt = lindgen(n)
  r = rr
  r = reform(rr, n, n, /overwrite)

  ;; For the inverse of r in the full upper triangle of r
  l = -1L
  if n_elements(tol) eq 0 then tol = one*1.E-14
  tolr = tol * abs(r(0,0))
  for k = 0L, n-1 do begin
      if abs(r(k,k)) le tolr then goto, INV_end_LOOP
      r(k,k) = one/r(k,k)
      for j = 0L, k-1 do begin
          temp = r(k,k) * r(j,k)
          r(j,k) = zero
          r(0,k) = r(0:j,k) - temp*r(0:j,j)
      endfor
      l = k
  endfor
  INV_end_LOOP:

  ;; Form the full upper triangle of the inverse of (r transpose)*r
  ;; in the full upper triangle of r
  if l ge 0 then $
    for k = 0L, l do begin
      for j = 0L, k-1 do begin
          temp = r(j,k)
          r(0,j) = r(0:j,j) + temp*r(0:j,k)
      endfor
      temp = r(k,k)
      r(0,k) = temp * r(0:k,k)
  endfor

  ;; For the full lower triangle of the covariance matrix
  ;; in the strict lower triangle or and in wa
  wa = replicate(r(0,0), n)
  for j = 0L, n-1 do begin
      jj = ipvt(j)
      sing = j gt l
      for i = 0L, j do begin
          if sing then r(i,j) = zero
          ii = ipvt(i)
          if ii gt jj then r(ii,jj) = r(i,j)
          if ii lt jj then r(jj,ii) = r(i,j)
      endfor
      wa(jj) = r(j,j)
  endfor

  ;; Symmetrize the covariance matrix in r
  for j = 0L, n-1 do begin
      r(0:j,j) = r(j,0:j)
      r(j,j) = wa(j)
  endfor

  return, r
end

function mpfit, fcn, xall, FUNCTARGS=fcnargs, SCAle_FCN=scalfcn, $
                ftol=ftol, xtol=xtol, gtol=gtol, epsfcn=epsfcn, resdamp=damp, $
                nfev=nfev, maxiter=maxiter, errmsg=errmsg, $
                factor=factor, nprint=nprint, STATUS=info, $
                iterproc=iterproc, iterargs=iterargs, niter=iter, iterstop=ss,$
                diag=diag, rescale=rescale, autoderivative=autoderiv, $
                perror=perror, covar=covar, nocovar=nocovar, bestnorm=fnorm, $
                parinfo=parinfo, quiet=quiet, nocatch=nocatch, $
                fastnorm=fastnorm, proc=proc, query=query

;stop
  if keyword_set(query) then return, 1

  if n_params() eq 0 then begin
      message, "USAge: PARMS = MPFIT('MYFUNCT', START_PARAMS, ... )", /info
      return, !values.d_nan
  endif

  ;; Use of double here not a problem since f/x/gtol are all only used
  ;; in comparisons
  if n_elements(ftol) eq 0 then ftol = 1.D-10
  if n_elements(xtol) eq 0 then xtol = 1.D-10
  if n_elements(gtol) eq 0 then gtol = 1.D-10
  if n_elements(factor) eq 0 then factor = 100.
  if n_elements(nprint) eq 0 then nprint = 1
  if n_elements(iterproc) eq 0 then iterproc = 'MPFIT_DEFITER'
  if n_elements(autoderiv) eq 0 then autoderiv = 1
  if strupcase(iterproc) eq 'MPFIT_DEFITER' and n_elements(iterargs) eq 0 $
    and keyword_set(ss) then iterargs = {iterstop:1}
  if n_elements(fastnorm) eq 0 then fastnorm = 0
  if n_elements(damp) eq 0 then damp = 0 else damp = damp(0)

  common mpfit_config, mpconfig
  mpconfig = {fastnorm: keyword_set(fastnorm), proc: 0, nfev: 0L, damp: damp}

  info = 0L
  iflag = 0L
  errmsg = ''
  catch_msg = 'in MPFIT'

  ;; Parameter damping doesn't work when user is providing their own
  ;; gradients.
  if damp ne 0 and not keyword_set(autoderiv) then begin
      errmsg = 'ERRor: keywords DAMP and AUTODERIV are mutually exclusive'
      goto, TERminATE
  endif


  ;; Handle error conditions gracefully
  if not keyword_set(nocatch) then begin
      catch, catcherror
      if catcherror ne 0 then begin
          catch, /cancel
          message, 'Error detected while '+catch_msg+':', /info
          message, !err_string, /info
          message, 'Error condition detected. Returning to MAIN level.', /info
          return, !values.d_nan
      endif
  endif

  ;; Parinfo:
  ;; --------------- STARTING/CONFIG INFO (passed in to routine, not changed)
  ;; .value   - starting value for parameter
  ;; .fixed   - parameter is fixed
  ;; .limited - a two-element array, if parameter is bounded on
  ;;            lower/upper side
  ;; .limits - a two-element array, lower/upper parameter bounds, if
  ;;           limited vale is set
  ;; .step   - step size in Jacobian calc, if greater than zero

  catch_msg = 'parsing input parameters'
  ;; Parameters can either be stored in parinfo, or x.  Parinfo takes
  ;; precedence if it exists.
  if n_elements(xall) eq 0 and n_elements(parinfo) eq 0 then begin
      errmsg = 'ERRor: must pass parameters in P or PARINFO'
      goto, TERminATE
  endif

  ;; Be sure that PARINFO is of the right type
  if n_elements(parinfo) gt 0 then begin
      parinfo_size = size(parinfo)
      if parinfo_size(parinfo_size(0)+1) ne 8 then begin
          errmsg = 'ERRor: PARINFO must be a structure.'
          goto, TERminATE
      endif
      if n_elements(xall) gt 0 and n_elements(xall) ne n_elements(parinfo) $
        then begin
          errmsg = 'ERRor: number of elements in PARINFO and P must agree'
          goto, TERminATE
      endif
  endif

  ;; If the parameters were not specified at the command line, then
  ;; extract them from PARINFO
  if n_elements(xall) eq 0 then begin
      mpfit_parinfo, parinfo, tagnames, 'value', xall, status=status
      if status eq 0 then begin
          errmsg = 'ERRor: either P or PARINFO(*).value must be supplied.'
          goto, TERminATE
      endif

      sz = size(xall)
      ;; Convert to double if parameters are not float or double
      if sz(sz(0)+1) ne 4 and sz(sz(0)+1) ne 5 then $
        xall = double(xall)
  endif
  npar = n_elements(xall)
  zero = xall(0) * 0.
  one  = zero    + 1.
  fnorm  = -one
  fnorm1 = -one

  ;; TIED parameters?
  mpfit_parinfo, parinfo, tagnames, 'TIED', ptied, default='', n=npar
  ptied = strtrim(ptied, 2)
  wh = where(ptied ne '', qanytied)
  qanytied = qanytied gt 0
  mpconfig = create_struct(mpconfig, 'QANYTIED', qanytied, 'PTIED', ptied)

  ;; FIXED parameters ?
  mpfit_parinfo, parinfo, tagnames, 'FIXED', pfixed, default=0, n=npar
  pfixed = pfixed eq 1
  pfixed = pfixed or (ptied ne '')   ;; Tied parameters are also effectively fixed

  ;; Finite differencing step, absolute and relative, and sidedness of derivative
  mpfit_parinfo, parinfo, tagnames, 'STEP',     step, default=zero, n=npar
  mpfit_parinfo, parinfo, tagnames, 'RELSTEP', dstep, default=zero, n=npar
  mpfit_parinfo, parinfo, tagnames, 'MPSIDE',  dside, default=0,    n=npar

  ;; Maximum and minimum steps allowed to be taken in one iteration
  mpfit_parinfo, parinfo, tagnames, 'MPmaxSTEP', maxstep, default=zero, n=npar
  mpfit_parinfo, parinfo, tagnames, 'MPminSTEP', minstep, default=zero, n=npar
  qmin = minstep *  0  ;; Remove minstep for now!!
  qmax = maxstep ne 0
  wh = where(qmin and qmax and maxstep lt minstep, ct)
  if ct gt 0 then begin
      errmsg = 'ERRor: MPminSTEP is greater than MPmaxSTEP'
      goto, TERminATE
  endif
  wh = where(qmin and qmax, ct)
  qminmax = ct gt 0

  ;; Finish up the free parameters
  ifree = where(pfixed ne 1, ct)
  if ct eq 0 then begin
      errmsg = 'ERRor: no free parameters'
      goto, TERminATE
  endif

  ;; Compose only VARYING parameters
  xnew = xall      ;; xnew is the set of parameters to be returned
  x = xnew(ifree)  ;; x is the set of free parameters

  ;; LIMITED parameters ?
  mpfit_parinfo, parinfo, tagnames, 'LIMITED', limited, status=st1
  mpfit_parinfo, parinfo, tagnames, 'LIMITS',  limits,  status=st2
  if st1 eq 1 and st2 eq 1 then begin

      ;; Error checking on limits in parinfo
      wh = where((limited(0,*) and xall lt limits(0,*)) or $
                 (limited(1,*) and xall gt limits(1,*)), ct)
      if ct gt 0 then begin
          errmsg = 'ERRor: parameters are not within PARINFO limits'
          goto, TERminATE
      endif
      wh = where(limited(0,*) and limited(1,*) and limits(0,*) ge limits(1,*) and $
                 pfixed eq 0, ct)
      if ct gt 0 then begin
          errmsg = 'ERRor: PARINFO parameter limits are not consistent'
          goto, TERminATE
      endif


      ;; Transfer structure values to local variables
      qulim = limited(1, ifree)
      ulim  = limits (1, ifree)
      qllim = limited(0, ifree)
      llim  = limits (0, ifree)

      wh = where(qulim or qllim, ct)
      if ct gt 0 then qanylim = 1 else qanylim = 0

  endif else begin

      ;; Fill in local variables with dummy values
      qulim = lonarr(n_elements(ifree))
      ulim  = x * 0.
      qllim = qulim
      llim  = x * 0.
      qanylim = 0

  endelse

  n = n_elements(x)
  if n_elements(maxiter) eq 0 then maxiter = 200L

  ;; Check input parameters for errors
  if (n le 0) or (ftol le 0) or (xtol le 0) or (gtol le 0) $
    or (maxiter le 0) or (factor le 0) then begin
      errmsg = 'ERRor: input keywords are inconsistent'
      goto, TERminATE
  endif

  if keyword_set(rescale) then begin
      errmsg = 'ERRor: DIAG parameter scales are inconsistent'
      if n_elements(diag) lt n then goto, TERminATE
      wh = where(diag le 0, ct)
      if ct gt 0 then goto, TERminATE
      errmsg = ''
  endif

  common mpfit_error, mperr

  mperr = 0
  catch_msg = 'calling '+fcn
  fvec = mpfit_call(fcn, xnew, _EXTRA=fcnargs)
  iflag = mperr
  if iflag lt 0 then begin
      errmsg = 'ERRor: first call to "'+fcn+'" failed'
      goto, TERminATE
  endif

  catch_msg = 'calling MPFIT_setMACHAR'
  sz = size(fvec(0))
  isdouble = (sz(sz(0)+1) eq 5)

  common mpfit_machar, machvals
  mpfit_setmachar, double=isdouble

  common mpfit_profile, profvals
;  prof_start = systime(1)

  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum

  szx = size(x)
  ;; The parameters and the squared deviations should have the same
  ;; type.  Otherwise the MACHAR-based evaluation will fail.
  catch_msg = 'checking parameter data'
  tp = szx(szx(0)+1)
  if tp ne 4 and tp ne 5 then begin
      if not keyword_set(quiet) then begin
          message, 'WARNING: input parameters must be at least float', /info
          message, '         (converting parameters to float)', /info
      endif
      x = float(x)
      xnew = float(x)
      szx = size(x)
  endif
  if isdouble and tp ne 5 then begin
      if not keyword_set(quiet) then begin
          message, 'WARNING: data is doUBle but parameters are float', /info
          message, '         (converting parameters to doUBle)', /info
      endif
      x = double(x)
      xnew = double(xnew)
  endif

  m = n_elements(fvec)
  if (m lt n) then begin
      errmsg = 'ERRor: number of parameters must not exceed data'
      goto, TERminATE
  endif

  fnorm = mpfit_enorm(fvec)

  ;; Initialize Levelberg-Marquardt parameter and iteration counter

  par = zero
  iter = 1L
  qtf = x * 0.

  ;; Beginning of the outer loop

  OUTER_LOOP:

  ;; If requested, call fcn to enable printing of iterates
  xnew(ifree) = x
  if qanytied then mpfit_tie, xnew, ptied

  if nprint gt 0 and iterproc ne '' then begin
      catch_msg = 'calling '+iterproc
      iflag = 0L
      if (iter-1) MOD nprint eq 0 then begin
          mperr = 0
          xnew0 = xnew

          call_procedure, iterproc, fcn, xnew, iter, fnorm^2, $
            FUNCTARGS=fcnargs, parinfo=parinfo, quiet=quiet, _EXTRA=iterargs
          iflag = mperr

          ;; Check for user termination
          if iflag lt 0 then begin
              errmsg = 'WARNING: premature termination by "'+iterproc+'"'
              goto, TERminATE
          endif

          ;; If parameters were changed (grrr..) then re-tie
          if max(abs(xnew0-xnew)) gt 0 then begin
              if qanytied then mpfit_tie, xnew, ptied
              x = xnew(ifree)
          endif

      endif
  endif

  ;; Calculate the jacobian matrix
  iflag = 2
  catch_msg = 'calling MPFIT_FDJAC2'
  fjac = mpfit_fdjac2(fcn, x, fvec, step, qulim, ulim, dside, $
                      iflag=iflag, epsfcn=epsfcn, $
                      autoderiv=autoderiv, dstep=dstep, $
                      FUNCTARGS=fcnargs, ifree=ifree, xall=xnew)
  if iflag lt 0 then begin
      errmsg = 'WARNING: premature termination by FDJAC2'
      goto, TERminATE
  endif

  ;; Rescale the residuals and gradient, for use with "alternative"
  ;; statistics such as the Cash statistic.
  catch_msg = 'prescaling residuals and gradient'
  if n_elements(scalfcn) gt 0 then begin
      call_procedure, strtrim(scalfcn(0),2), fvec, fjac
  endif

  ;; Determine if any of the parameters are pegged at the limits
  if qanylim then begin
      catch_msg = 'zeroing derivatives of pegged parameters'
      whlpeg = where(qllim and (x eq llim), nlpeg)
      whupeg = where(qulim and (x eq ulim), nupeg)

      ;; See if any "pegged" values should keep their derivatives
      if (nlpeg gt 0) then begin
          ;; Total derivative of sum wrt lower pegged parameters
          for i = 0L, nlpeg-1 do begin
              sum = total(fvec * fjac(*,whlpeg(i)))
              if sum gt 0 then fjac(*,whlpeg(i)) = 0
          endfor
      endif
      if (nupeg gt 0) then begin
          ;; Total derivative of sum wrt upper pegged parameters
          for i = 0L, nupeg-1 do begin
              sum = total(fvec * fjac(*,whupeg(i)))
              if sum lt 0 then fjac(*,whupeg(i)) = 0
          endfor
      endif
  endif

  ;; Compute the QR factorization of the jacobian
  catch_msg = 'calling MPFIT_QRFAC'
  mpfit_qrfac, fjac, ipvt, wa1, wa2, /pivot

  ;; On the first iteration if "diag" is unspecified, scale
  ;; according to the norms of the columns of the initial jacobian
  catch_msg = 'rescaling diagonal elements'
  if (iter eq 1) then begin

      if not keyword_set(rescale) or (n_elements(diag) lt n) then begin
          diag = wa2
          wh = where (diag eq 0, ct)
          if ct gt 0 then diag(wh) = one
      endif

      ;; On the first iteration, calculate the norm of the scaled x
      ;; and initialize the step bound delta
      wa3 = diag * x
      xnorm = mpfit_enorm(wa3)
      delta = factor*xnorm
      if delta eq zero then delta = zero + factor
  endif

  ;; Form (q transpose)*fvec and store the first n components in qtf
  catch_msg = 'forming (q transpose)*fvec'
  wa4 = fvec
  for j=0L, n-1 do begin
      lj = ipvt(j)
      temp3 = fjac(j,lj)
      if temp3 ne 0 then begin
          fj = fjac(j:*,lj)
          wj = wa4(j:*)
          ;; *** optimization wa4(j:*)
          wa4(j) = wj - fj * total(fj*wj) / temp3
      endif
      fjac(j,lj) = wa1(j)
      qtf(j) = wa4(j)
  endfor
  ;; From this point on, only the square matrix, consisting of the
  ;; triangle of R, is needed.
  fjac = fjac(0:n-1, 0:n-1)
  fjac = reform(fjac, n, n, /overwrite)
  fjac = fjac(*, ipvt)
  fjac = reform(fjac, n, n, /overwrite)

  ;; Check for overflow.  This should be a cheap test here since FJAC
  ;; has been reduced to a (small) square matrix, and the test is
  ;; O(N^2).
  wh = where(finite(fjac) eq 0, ct)
  if ct gt 0 then goto, FAIL_OVERFLOW

  ;; Compute the norm of the scaled gradient
  catch_msg = 'computing the scaled gradient'
  gnorm = zero
  if fnorm ne 0 then begin
      for j=0L, n-1 do begin
          l = ipvt(j)
          if wa2(l) ne 0 then begin
              sum = total(fjac(0:j,j)*qtf(0:j))/fnorm
              gnorm = max([gnorm,abs(sum/wa2(l))])
          endif
      endfor
  endif

  ;; Test for convergence of the gradient norm
  if gnorm le gtol then info = 4
  if info ne 0 then goto, TERminATE

  ;; Rescale if necessary
  if not keyword_set(rescale) then $
    diag = diag > wa2

  ;; Beginning of the inner loop
  INneR_LOOP:

  ;; Determine the levenberg-marquardt parameter
  catch_msg = 'calculating LM parameter (MPFIT_LMPAR)'
  par = mpfit_lmpar(fjac, ipvt, diag, qtf, delta, wa1, wa2, par=par)

  ;; Store the direction p and x+p. Calculate the norm of p
  wa1 = -wa1

  if qanylim eq 0 and qminmax eq 0 then begin
      ;; No parameter limits, so just move to new position WA2
      alpha = one
      wa2 = x + wa1

  endif else begin

      ;; Respect the limits.  If a step were to go out of bounds, then
      ;; we should take a step in the same direction but shorter distance.
      ;; The step should take us right to the limit in that case.
      alpha = one

      if qanylim eq 1 then begin
          ;; Do not allow any steps out of bounds
          catch_msg = 'checking for a step out of bounds'
          if nlpeg gt 0 then wa1(whlpeg) = wa1(whlpeg) > 0
          if nupeg gt 0 then wa1(whupeg) = wa1(whupeg) < 0

          dwa1 = abs(wa1) gt MACHEP0
          whl = where(dwa1 and qllim and (x + wa1 lt llim), lct)
          if lct gt 0 then $
            alpha = min([alpha, (llim(whl)-x(whl))/wa1(whl)])
          whu = where(dwa1 and qulim and (x + wa1 gt ulim), uct)
          if uct gt 0 then $
            alpha = min([alpha, (ulim(whu)-x(whu))/wa1(whu)])
      endif

      ;; Obey any max step values.

      if qminmax eq 1 then begin
          nwa1 = wa1 * alpha
          whmax = where(qmax and maxstep gt 0, ct)
          if ct gt 0 then begin
              mrat = max(nwa1(whmax)/maxstep(whmax))
              if mrat gt 1 then alpha = alpha / mrat
          endif
      endif

      ;; Scale the resulting vector
      wa1 = wa1 * alpha
      wa2 = x + wa1

      ;; Adjust the final output values.  If the step put us exactly
      ;; on a boundary, make sure it is exact.
      wh = where(qulim and wa2 ge ulim*(1-MACHEP0), ct)
      if ct gt 0 then wa2(wh) = ulim(wh)

      wh = where(qllim and wa2 le llim*(1+MACHEP0), ct)
      if ct gt 0 then wa2(wh) = llim(wh)
  endelse

  wa3 = diag * wa1
  pnorm = mpfit_enorm(wa3)

  ;; On the first iteration, adjust the initial step bound
  if iter eq 1 then delta = min([delta,pnorm])

  ;; Evaluate the function at x+p and calculate its norm
  mperr = 0
  xnew(ifree) = wa2
  catch_msg = 'calling '+fcn
  wa4 = mpfit_call(fcn, xnew, _EXTRA=fcnargs)
  iflag = mperr
  if iflag lt 0 then begin
      errmsg = 'WARNING: premature termination by "'+fcn+'"'
      goto, TERminATE
  endif
  fnorm1 = mpfit_enorm(wa4)

  ;; Compute the scaled actual reduction
  catch_msg = 'computing convergence criteria'
  actred = -one
  if 0.1D * fnorm1 lt fnorm then actred = - (fnorm1/fnorm)^2 + 1.

  ;; Compute the scaled predicted reduction and the scaled directional
  ;; derivative
  for j = 0L, n-1 do begin
      wa3(j) = 0
      wa3(0:j) = wa3(0:j) + fjac(0:j,j)*wa1(ipvt(j))
  endfor

  ;; Remember, alpha is the fraction of the full LM step actually
  ;; taken
  temp1 = mpfit_enorm(alpha*wa3)/fnorm
  temp2 = (sqrt(alpha*par)*pnorm)/fnorm
  half  = zero + 0.5
  prered = temp1*temp1 + (temp2*temp2)/half
  dirder = -(temp1*temp1 + temp2*temp2)

  ;; Compute the ratio of the actual to the predicted reduction.
  ratio = zero
  tenth = zero + 0.1
  if prered ne 0 then ratio = actred/prered

  ;; Update the step bound
  if ratio le 0.25D then begin
      if actred ge 0 then temp = half $
      else temp = half*dirder/(dirder + half*actred)
      if ((0.1D*fnorm1) ge fnorm) or (temp lt 0.1D) then temp = tenth
      delta = temp*min([delta,pnorm/tenth])
      par = par/temp
  endif else begin
      if (par eq 0) or (ratio ge 0.75) then begin
          delta = pnorm/half
          par = half*par
      endif
  endelse

  ;; Test for successful iteration
  if ratio ge 0.0001 then begin
      ;; Successful iteration.  Update x, fvec, and their norms
      x = wa2
      wa2 = diag * x

      fvec = wa4
      xnorm = mpfit_enorm(wa2)
      fnorm = fnorm1
      iter = iter + 1
  endif

  ;; Tests for convergence
  if (abs(actred) le ftol) and (prered le ftol) $
    and  (0.5D * ratio le 1) then info = 1
  if delta le xtol*xnorm then info = 2
  if (abs(actred) le ftol) and (prered le ftol) $
    and (0.5D * ratio le 1) and (info eq 2) then info = 3
  if info ne 0 then goto, TERminATE

  ;; Tests for termination and stringent tolerances
  if iter ge maxiter then info = 5
  if (abs(actred) le MACHEP0) and (prered le MACHEP0) $
    and (0.5*ratio le 1) then info = 6
  if delta le MACHEP0*xnorm then info = 7
  if gnorm le MACHEP0 then info = 8
  if info ne 0 then goto, TERminATE

  ;; End of inner loop. Repeat if iteration unsuccessful
  if ratio lt 0.0001 then begin
      goto, INneR_LOOP
  endif

  ;; Check for over/underflow
  wh = where(finite(wa1) eq 0 or finite(wa2) eq 0 or finite(x) eq 0, ct)
  if ct gt 0 or finite(ratio) eq 0 then begin
      FAIL_OVERFLOW:
      errmsg = ('ERRor: parameter or function value(s) have become '+$
                'infinite; check model function for over- '+$
                'and underflow')
      info = -16
      goto, TERminATE
  endif

  ;; End of outer loop.
  goto, OUTER_LOOP

TERminATE:
  catch_msg = 'in the termination phase'
  ;; Termination, either normal or user imposed.
  if iflag lt 0 then info = iflag
  iflag = 0
  if n_elements(ifree) eq 0 then xnew = xall else xnew(ifree) = x
  if nprint gt 0 and info gt 0 then begin
      catch_msg = 'calling '+fcn
      fvec = mpfit_call(fcn, xnew, _EXTRA=fcnargs)
      catch_msg = 'in the termination phase'
      fnorm = mpfit_enorm(fvec)
  endif

  if n_elements(fnorm) gt 0 and n_elements(fnorm1) gt 0 then begin
      fnorm = max([fnorm, fnorm1])
      fnorm = fnorm^2.
  endif

  covar = !values.d_nan
  ;; (very carefully) set the covariance matrix COVAR
  if info gt 0 and not keyword_set(nocovar) $
    and n_elements(n) gt 0 and n_elements(fvec) gt 0 $
    and n_elements(fjac) gt 0 and n_elements(ipvt) gt 0 then begin
      sz = size(fjac)
      if n gt 0 and sz(0) gt 1 and sz(1) ge n and sz(2) ge n $
        and n_elements(ipvt) ge n then begin
          catch_msg = 'computing the covariance matrix'
          if n eq 1 then $
            cv = mpfit_covar(reform([fjac(0,0)],1,1), ipvt(0)) $
          else $
            cv = mpfit_covar(fjac(0:n-1,0:n-1), ipvt(0:n-1))
          cv = reform(cv, n, n, /overwrite)
          nn = n_elements(xall)

          ;; Fill in actual covariance matrix, accounting for fixed
          ;; parameters.
          covar = replicate(zero, nn, nn)
          for i = 0L, n-1 do begin
              covar(ifree, ifree(i)) = cv(*,i)
          end

          ;; Compute errors in parameters
          catch_msg = 'computing parameter errors'
          i = lindgen(nn)
          perror = replicate(covar(0)*0., nn)
          wh = where(covar(i,i) ge 0, ct)
          if ct gt 0 then $
            perror(wh) = sqrt(covar(wh, wh))
      endif
  endif
;  catch_msg = 'returning the result'
;  profvals.mpfit = profvals.mpfit + (systime(1) - prof_start)

  nfev = mpconfig.nfev
  return, xnew
end

; ** ********************************************************************* ** ;
; ** ********************************************************************* ** ;
; ** 						end of MPFIT								   ** ;
; ** ********************************************************************* ** ;
; ** ********************************************************************* ** ;

; ** **************************************************************
function bose,xinput
; ** **************************************************************
; ** Calculate the bose factor
bosex=xinput/(1-exp(-1.*xinput*11.6045/300))
bosex(where(abs(xinput) le 1e-5))=1.
return, bosex
end
; ** **************************************************************
function fungdos_to_fit,xinput,sf_new_values
; ** **************************************************************
; On construit la fonction mais on ne convolue pas ...
common sc_lorgau
;sf_sp_num_min=workspace number min to fit
;sf_sp_num_max=workspace number max to fit ... not for the moment

; ** Expression of the S(Q,w) with a gdos=soundv*w^dimsys
w_2_fit=xinput*0.
soundv=sf_new_values(0)
dimsys=sf_new_values(1)
;w_2_fit=(bose(xinput)/xinput^2)*soundv*(abs(xinput))^dimsys
w_2_fit=(bose(xinput)/xinput^2)*soundv*(abs(xinput))^dimsys
w_2_fit(where(abs(w_2_fit) ge 1e10))=0.
; ** Now deal with the elastic line
dcenter=sf_new_values(2)
x_interp=xinput+dcenter
w_resc2_interp=spline(x_interp,w_resc2,xinput)
dint=sf_new_values(3)
w_2_fit=w_2_fit+dint*w_resc2_interp
; ** Now deal with the background
slope=sf_new_values(4)
const=sf_new_values(5)
w_2_fit=w_2_fit+slope*xinput+const

return,w_2_fit

end
; ** **************************************************************
; ** **************************************************************
function qlorentz,xinput,p1,p2,p3
; ** **************************************************************
; ** p1=position p2=FWHM p3=intensity
; ** lorentz(x)=(2*P2*P3*/PI)*(4*(x-P1)^2+P2^2)
;
; ** Compute the function first
qlor=(2*p2*p3/!PI)/(4*(xinput-p1)^2+p2^2)
if abs(p2) le 1e-20 then print,'Probleme p2'
; ** Compute the derivatives after
;dlor_dp1=(-16*p3*p2/!PI)/(4*(xinput-p1)^2+p2^2)^2
;dlor_dp2=(2*p3/!PI)*(1/(4*(xinput-p1)^2+p2^2)-p2/(4*(xinput-p1)^2+2*p2))
;dlor_dp3=(2*p2/!PI)/(4*(xinput-p1)^2+p2^2)
;return,[lor,dlor_dp1,dlor_dp2,dlor_dp3]

return,[qlor]
end

; ** **************************************************************
function qgauss,xinput,p1,p2,p3
; ** **************************************************************
; ** p1=position p2=FWHM p3=intensity
; ** gauss(x)=(P3/(p2'*sqrt(PI))*EXP(-(x-P1)^2/(P2')^2)
; ** in that case, P2'=P2/(2sqrt(Ln(2))) is not the FWHM
;
; ** Compute the function first
p2p=p2/(2.*alog(2.))
if abs(p2p) le 1e-20 then print,'Probleme p2p'
qgau=(p3/p2p/sqrt(!PI))*EXP(-((xinput-p1)^2)/(p2p^2))
; ** Compute the derivatives
;dgau_dp1=2.*p3*(xinput-p1)*EXP(-(xinput-p1)^2/(p2p^2))/(p2p*sqrt(!PI))
;dgau_dp2=p3*EXP(-((xinput-p1)^2)/(p2p^2))/(2.*p2p*sqrt(!PI*alog(2.)))
;dgau_dp2=dgau_dp2*(-1.+2*(xinput-p1)^2/p2p^2)
;dgau_dp3=EXP(-((xinput-p1)^2)/(p2p^2))/(p2p*sqrt(!PI))
;return,[gau,dgau_dp1,dgau_dp2,dgau_dp3]

return,[qgau]
end

; ** **************************************************************************
function convs,w_to_conv,ispe,falpha,fbeta,w_resc2
; ** **************************************************************************
; ** This program performs the numerical convolution of an input theoretical
; ** vector w_to conv with the resolution function as treated by the preceding
; ** program
; ** [sx_in(nx1),sx_in(nx2)]=fitting range
; ** treatment for spectrum ispmin to ispmax but for the moment, full treatment e.g
; ** ispmin and ispmax=(size(w_res))(2) (nspectra)

common sc_loc
common sc_fit
common sc_convs

on_error,0
sz=size(w_resc) & ns_x=sz(1)-1
nx2=n_elements(w_to_conv)
w_to_fit=w_to_conv*0.0
deltaw=sx_in(1)-sx_in(0) & test=sx_res(1)-sx_res(0)
if deltaw ne test then treat_resf
test=sx_res(1)-sx_res(0)
if deltaw ne test then message,'PROBLEM ! Resf and input not the same binning in energy'
for i=0,nx2-1 do begin
	val_conv=0.
	for j=i-lmax(ispe-1),i+lmin(ispe-1) do begin
	if j lt 0 or j gt nx2-1 then continue
	k=i-j+cel(ispe-1)-falpha & if k lt 0 or k gt nx2-1 then message,'PROBLEM in convolution ! '
	val_conv=val_conv+w_resc2(i-j+cel(ispe-1)-falpha,ispe-1)*w_to_conv(j)
	endfor
	w_to_fit(i)=val_conv*deltaw
endfor
return, w_to_fit
end

; ** **************************************************************
function funlg_to_fit,xinput,sf_new,betatemp
; ** **************************************************************
; On construit la fonction mais on ne convolue pas ...
common sc_loc
common sc_lorgau
common sc_convs
;sf_sp_num_min=workspace number min to fit
;sf_sp_num_max=workspace number max to fit ... not for the moment

;stop

num_lor=n_l & num_gau=n_g
w_resc2_ispe=w_resc2(*,num_spectrum-1)
aamin=aalpha(num_spectrum-1) & aamax=abeta(num_spectrum-1) & ess_conv=w_resc(aamin:aamax,num_spectrum-1)
;ess_conv=w_resc2_ispe(aalpha(num_spectrum-1):abeta(num_spectrum-1))

w_to_conv=xinput*0. & w_to_convl=w_to_conv & w_to_convg=w_to_conv
arr_index=fltarr(1)
if num_lor gt 0 then begin
for il=0,num_lor-1 do begin
;lor_to_add=lorentz(xinput,sf_new_values(ispecc-1,il*3),sf_new_values(ispecc-1,il*3+1),sf_new_values(ispecc-1,il*3+2))
lor_to_add=qlorentz(xinput,sf_new(il*3),sf_new(il*3+1),sf_new(il*3+2))
ind_lor_0=where(lor_to_add ge 1e-10,nn)
if nn le 7 then begin
lor_to_add=0.
arr_index=[arr_index,il*3]
endif
w_to_convl=w_to_convl+lor_to_add;lorentz(xinput,sf_new_values(il*3),sf_new_values(il*3+1),sf_new_values(il*3+2))
endfor
endif
igminind=num_lor*3
if num_gau gt 0 then begin
for ig=0,num_gau-1 do begin
;gau_to_add=gauss(xinput,sf_new_values(ispecc-1,igminind+ig*3),sf_new_values(ispecc-1,igminind+ig*3+1),sf_new_values(ispecc-1,igminind+ig*3+2))
gau_to_add=qgauss(xinput,sf_new(igminind+ig*3),sf_new(igminind+ig*3+1),sf_new(igminind+ig*3+2))
ind_gau_0=where(gau_to_add ge 1e-10,nn)
if nn le 7 then begin
gau_to_add=0.
arr_index=[arr_index,igminind+ig*3]
endif
w_to_convg=w_to_convg+gau_to_add;gauss(xinput,sf_new_values(igminind+ig*3),sf_new_values(igminind+ig*3+1),sf_new_values(igminind+ig*3+2))
endfor
endif
; ** Now sum the Lorentzian and Gaussian parts
w_to_conv=w_to_convl+w_to_convg

; ** Now do the convolution with the Resolution function (to be done)
;w_2_fit=convs(w_to_conv,num_spectrum,falpha,fbeta,w_resc2)
;stop
w_2_fit=convol(w_to_conv,ess_conv,total(ess_conv),/edge_truncate);,center=0)
; ** Now deal with the background
;slope=sf_new_values(ispecc-1,3*num_lor+3*num_gau+2)
slope=sf_new(3*num_lor+3*num_gau+2)
;const=sf_new_values(ispecc-1,3*num_lor+3*num_gau+3)
const=sf_new(3*num_lor+3*num_gau+3)
w_2_fit=w_2_fit+slope*xinput+const
; ** ... and multiply by the temperature factor in case of symetric data (detailed balance factor)
w_2_fit=w_2_fit*exp(betatemp*xinput)

if n_elements(arr_index) gt 1 then begin
; ** Now deal with the line too sharp that we change in res. function
for ic=1,n_elements(arr_index)-1 do begin
;dcenter=sf_new_values(ispecc-1,arr_index(ic)) & dint=sf_new_values(ispecc-1,arr_index(ic)+2) & x_interp=xinput+dcenter
dcenter=sf_new(arr_index(ic)) & dint=sf_new(arr_index(ic)+2) & x_interp=xinput+dcenter
w_2_fit=w_2_fit+dint*spline(x_interp,w_resc2_ispe,xinput)
endfor
endif

; ** Now deal with the elastic line
;dcenter=sf_new_values(ispecc-1,3*num_lor+3*num_gau)
dcenter=sf_new(3*num_lor+3*num_gau)
x_interp=xinput+dcenter
w_resc2_interp=spline(x_interp,w_resc2_ispe,xinput)

;dint=sf_new_values(ispecc-1,3*num_lor+3*num_gau+1)
dint=sf_new(3*num_lor+3*num_gau+1)
w_2_fit=w_2_fit+dint*w_resc2_interp
;
return,w_2_fit

end

; ** **************************************************************
function myfunc,P,XVAL=X,YVAL=Y,ERRVAL=E
; ** **************************************************************
;P=sf_new_values : values of the fit parameters
;X=x values constrainted by the fit range ... Y=corresponding Y values
;and E=corresponding errors
;model=returned array containing the model values
common sc_fit
case name_func of
	'LOR_GAU':model=funlg_to_fit(X,P,betatemp)
	'GDOS':model=fungdos_to_fit(X,P,betatemp)
else:stop
endcase
return,(Y-model)/E

end
; ** **************************************************************
pro prepare_2_fit,X,Y,E,parinfo
; ** **************************************************************
; ** Called when the FIT button is pressed
; ** Call back the new values of the fit parameters as well as
; ** other necessary features

common sc_wid
common sc_loc
common sc_flag
common sc_fit
common sc_lorgau

; ** parinfo is the structure containing the indication on how the fit has to be performed
case name_func of
	'LOR_GAU':begin
	 parinfo=replicate({value:0.,fixed:0},3*num_lor+3*num_gau+4)
	 fact=3
	 end
	'GDOS':begin
	 parinfo=replicate({value:0.,fixed:0},2*num_lor+4)
	 fact=2
	 end
else:stop
endcase
;
iprint=0
sf_last_values(num_spectrum-1,*)=sf_new_values(num_spectrum-1,*)	; new values become last values

if not flag_all then begin
for i=0,fact*num_lor+fact*num_gau+4-1 do begin 	; sf_new_values must read the new value of the parameters
widget_control,sw_tx_balg2(3*i),get_value=str_balg2 & flt_balg2=float(strcompress(str_balg2,/remove_all)) & flt_balg2=flt_balg2(0)
sf_new_values(num_spectrum-1,i)=flt_balg2
endfor
endif else begin
if flag_reverse then iadprev=1 else iadprev=-1
num_prev=num_spectrum+1*iadprev
if not((num_prev lt 1 or num_prev gt nb_spe_tot) or (not flag_fromlast)) then begin
sf_new_values(num_spectrum-1,*)=sf_new_values(num_prev-1,*)
sf_index(num_spectrum-1,*)=sf_index(num_prev-1,*)
endif
endelse

;
sf_param_to_fit=intarr(3*num_lor+3*num_gau+4)
sf_param_to_fit(*)=abs(not sf_index(num_spectrum-1,*)) 	; contains the indices of the parameters to be fitted
;
; ** Now deal with the string to float or integer transformation (see "plot it")
widget_control,sw_tx_fxmin,get_value=s & sf_xmin=float(strcompress(s,/remove_all)) & sf_xmin=sf_xmin(0) ;x min fit range
widget_control,sw_tx_fxmax,get_value=s & sf_xmax=float(strcompress(s,/remove_all)) & sf_xmax=sf_xmax(0) ;x max fit range

;if ((sf_sp_num_min le 0) or (sf_sp_num_min gt nb_spe_tot)) then sf_sp_num_min=1
widget_control,sw_tx_cycl,get_value=s & sf_iter_num=fix(strcompress(s,/remove_all)) & sf_iter_num=sf_iter_num(0) ;number of iteration maximum to perform

rin=where((sx_in le sf_xmax) and (sx_in ge sf_xmin),npt,complement=out)
falpha=rin(0) & fbeta=rin(npt-1)
if sf_xmax le sf_xmin then begin $
print, "PROBLEM: Fitting range, sf_xmin not lt sf_xmax !!"
stop
endif
if iprint ne 0 then begin
print,"falpha=",falpha,"fbeta=",fbeta
print,"rin=",rin
print,"out=",out
endif
w_resc2=w_resc(falpha:fbeta,*)
X=sx_in(rin) & Y=sw_in(rin,num_spectrum-1)
E=se_in(rin,num_spectrum-1) & rrr=where(E le 0.) & if rrr(0) ne -1 then E(rrr)=100000
sf_w_fitted(*,num_spectrum-1)=0
;ispecc=sf_sp_num_min;-1
sf_new=fltarr(3*num_lor+3*num_gau+4) & sf_new(*)=sf_new_values(num_spectrum-1,*)
sf_e=fltarr(3*num_lor+3*num_gau+4) & sf_e(*)=sf_e_values(num_spectrum-1,*)
parinfo.value=sf_new
;parinfo.value=sf_new_values(num_spectrum,*)
parinfo.fixed=sf_param_to_fit
end


; ** **************************************************************
pro qens_fit_event, Event
; ** **************************************************************
; ** Called when a qens_fit event is generated

@lamp.cbk
common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common sc_wid
common sc_loc
common sc_flag
common sc_fit
common sc_lorgau
common sc_convs
stat=0
;catch,stat

;if stat  ne 0  then begin
;		catch,/cancel
; 		set_plot,my_path(3);
;		widget_control, bad_id=i, gw_err_lab, Set_Value=!err_string
;		return & endif
;error_msg, 0				; Clear error msg fields
;print,'On est dans qens_fit'
if  TAG_NAMES(Event,/structure_name) ne 'widget_draw' then $
	widget_control, bad_id=i, Event.Id, /Hourglass
	widget_control, bad_id=i, Event.Id, geT_uvalue=Ev, Get_Value=value
no_plot=0

case Ev(0) of
    0:case Ev(1) of									;Menu Event
          0:case Ev(2) of
                0:widget_control,event.top,/DESTROY ;Exit Event
                1:begin                                                     ;Save Curves Event
                save_file=dialog_pickfile(file='fit_curves.sav',filter='*.sav',title='Save in File:')
                openw,unit,save_file,/get_lun
                ts=transpose(sf_sub_function)
                f2print=reform(sf_w_fitted,1,nb_channels,nb_spe_tot)
                dat2print=reform(sw_in,1,nb_channels,nb_spe_tot)
                err2print=reform(se_in,1,nb_channels,nb_spe_tot)
                x2print=sx_in & for i=0,nb_spe_tot-2 do x2print=[x2print,sx_in] & x2print=reform(x2print,1,nb_channels,nb_spe_tot)
                w2print=[x2print,dat2print,err2print,f2print,ts]
                nsub=size(w2print) & nsub2=nsub(1) & iformat=nsub2
                sformat=strcompress(string(iformat),/remove_all)
                sformat='('+sformat+'(G15.8,1X))'
                strdate=systime(0)
                  case name_func of
                    'LOR_GAU':str2add='Data were fitted using a set of independent Lorentzian and Gaussian functions'
                    else: str2add='Model non existent'
                  endcase  
                printf,unit,'File printed on '+strdate   
                printf,unit,str2add
                printf,unit,'--------------------------------------------------',format='(a50)'                
                for isp=0,nb_spe_tot-1 do begin
                printf,unit,'# Spectrum# ',isp+1,'Angle=',sy_in(isp)
                printf,unit,w2print(*,*,isp),format=sformat
                printf,unit,'##################################################',format='(a50)'
                endfor
                free_lun,unit        
                end
                2:begin
                save_file=dialog_pickfile(file='fit_param.sav',filter='*.sav',title='Save in File:')
                openw,unit,save_file,/get_lun
                openw,unit2,'logfile.sav',/get_lun
                strdate=systime(0)
                  case name_func of
                    'LOR_GAU':str2add='Data were fitted using a set of independent Lorentzian and Gaussian functions'
                    else: str2add='Model non existent'
                  endcase  
                printf,unit,'File printed on '+strdate &  printf,unit2,'# '+'File printed on '+strdate 
                printf,unit,str2add       & printf,unit2,'# '+name_func
                printf,unit,'--------------------------------------------------',format='(a50)'
                printf,unit2,'# '+'--------------------------------------------------'
                for isp=0,nb_spe_tot-1 do begin
                printf,unit,'# Spectrum#',isp+1,'Angle=',sy_in(isp),'value of CHISQR=',chisqr(isp),format='(a,1x,i4,1x,a,1x,f7.3,3x,a,1x,f9.3)'
                for isub=0,n_elements(sf_functions_labels)-1 do begin
                printf,unit,sf_functions_labels(isub),sf_new_values(isp,isub),sf_errors_labels(isub),sf_e_values(isp,isub)$
                ,format='(a26,3x,E15.8,3x,a,3x,E15.8)'
                endfor
                printf,unit,'##################################################',format='(a50)'                
                endfor
                sformat=strcompress(string(2*n_elements(sf_functions_labels)+1),/remove_all) & sformat='('+sformat+'(G15.8,1X))'
                printf,unit2,[transpose(sy_in),transpose(sf_new_values),transpose(sf_e_values)],format=sformat               
                free_lun,unit
                free_lun,unit2                                      
                end
            endcase    
          1:case Ev(2) of
                0:fit_basegl							; Lor-Gauss fit
                1:							; Isotropic rotation
                2:							; Uniaxial rotation
                3:							; RW translation
                4:print,'Do nothing at the moment'
                ;fit_basegdos
            endcase
      endcase
    1:begin								; First Line Event
      case Ev(1) of
    	  1:begin ; Get data event
    		widget_control,sw_la_win,get_value=str_win
    		str_test=STRMID(str_win,1,STRleN(str_win)-1)
			sw_in=0 & sx_in=0 & sy_in=0 & se_in=0
			iii=EXECUTE("w_in=w"+str_test)
			iii=EXECUTE("x_in=x"+str_test)	;& sx_in=sx_in(*,0)
			iii=EXECUTE("y_in=y"+str_test)
			iii=EXECUTE("e_in=e"+str_test)
			sw_in=w_in & sx_in=x_in & sy_in=y_in & se_in=e_in
			sw_result=sw_in & sx_result=sx_in & sy_result=sy_in & se_result=se_in
			sz_win=size(w_in)
			case n_elements(sz_win) of
			4:begin
			nb_spe_tot=1 & nb_channels=sz_win(1)
			end
			5:begin
			nb_spe_tot=sz_win(2) & nb_channels=sz_win(1)
			end
			else:begin
			Print,"Problem in array dimension ... quiting"
			Return
			end
			endcase
			flag_lect_in=1
      widget_control,sw_tx_fxmin,set_value=strcompress(string(min(sx_in)),/remove_all)
      widget_control,sw_tx_fxmax,set_value=strcompress(string(max(sx_in)),/remove_all)
			sf_w_fitted=fltarr(nb_channels,nb_spe_tot) 	; the final fitted array has the same dimensions as the input array
			sf_w_exp_fit=sf_w_fitted					; the difference in between the experimental and the fitted curves
      widget_control,sw_bu_gres,sensitive=1
    		end
    	  2:begin
    		widget_control,sw_la_res,get_value=str_wres
    		str_test=strmid(str_wres,1,strlen(str_wres)-1)
			sw_res=0 & sx_res=0 & sy_res=0 & se_res=0
			iii=execute("w_in=w"+str_test)
			iii=execute("x_in=x"+str_test) ;& sx_res=sx_res(*,0)
			iii=execute("y_in=y"+str_test)
			iii=execute("e_in=e"+str_test)
			sw_res=w_in & sx_res=x_in & sy_res=y_in & se_res=e_in
			sz_wres=size(w_in)
			case n_elements(sz_wres) of
			4:begin
			test_spec=1 & test_ch=sz_wres(1)
			end
			5:begin
			test_spec=sz_wres(2) & test_ch=sz_wres(1)
			end
			else: begin
			Print,"Problem in array dimension ... quiting"
			Return
			end
			endcase
			if flag_lect_in and ((test_spec ne nb_spe_tot) or (test_ch ne nb_channels)) then begin
			print,'W_in and W_Res_function do not have the same dimensions' & stop
			endif
      widget_control,sw_bu_plot,sensitive=1
    		end
    	  3:begin							; Write Result event
    		widget_control,sw_la_wou,get_value=str_wou
    		str_test=strmid(str_wou,1,strlen(str_wou)-1)
			w_out=sw_result & x_out=sx_in & y_out=sy_in & e_out=0.;se_result
			iii=execute("w"+str_test+"=w_out")
			iii=execute("x"+str_test+"=x_out") ;& sx_res=sx_res(*,0)
			iii=execute("y"+str_test+"=y_out")
			iii=execute("e"+str_test+"=e_out")
    		end
       endcase
       end
    2:begin									; Second Line Event
      case Ev(1) of
    	  1:ids=sw_la_win				    ; concerns w_in
    	  2:ids=sw_la_res					; concerns w_res
    	  3:ids=sw_la_wou					; concerns w_ou
      endcase
      widget_control,ids,get_value=str_w_test
      ilen=strlen(str_w_test)
      str_w_test=strmid(str_w_test,1,ilen-1) & w_test=fix(str_w_test)
      case Ev(2) of
          1:begin							; w_test=w_test-1
          w_test=w_test-1
          if w_test lt 1 then w_test=20
          end
          2: ;Label ... no event should occur
          3:	begin							; w_test=w_test+1
          w_test=w_test+1
          if w_test gt 20 then w_test=1
          end
      endcase
      str_w_test='W'+string(w_test)
      str_w_test=strcompress(str_w_test,/remove_all)
      widget_control,ids,set_value=str_w_test
      end
    3:begin									; Mid Line Event
      case Ev(1) of
          1:								; Mid column1 Event
          2:begin
            case Ev(2) of
                1:begin           ; "Accept !" Event
                widget_control,sw_tx_wsub,get_value=str_wsub & str_wsub=strlowcase(strcompress(str_wsub,/remove_all))
                num_spectrum=1 & str_wsub=str_wsub(0)
                num_spectrum=fix(str_wsub) & num_spectrum=num_spectrum(0)
                if ((num_spectrum le 0) or (num_spectrum gt nb_spe_tot)) then begin
                print,'ERROR num_spectrum out of range ... put it to 1'
                num_spectrum=1
                widget_control,sw_tx_wsub,set_value=' 1'
                endif
          		  plot_it
               if flag_pl_fit2 then begin
                fact=1
                ; Change the parameters text box values
                for i=0,fact*num_lor*3+fact*num_gau*3+4-1 do begin ; sf_new_values must print the new value of the parameters
                str_balg2=string(sf_new_values(num_spectrum-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
                widget_control,sw_tx_balg2(3*i),set_value=str_balg2,sensitive=sf_index(num_spectrum-1,i)
                str_balg2=string(sf_last_values(num_spectrum-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
                widget_control,sw_tx_balg2(3*i+1),set_value=str_balg2
                str_balg2=string(sf_e_values(num_spectrum-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
                widget_control,sw_tx_balg2(3*i+2),set_value=str_balg2
                widget_control,sw_bu_balg2(i),set_button=abs(not sf_index(num_spectrum-1,i))
                endfor                             
              endif
          		end
          		2:begin
          		flag_pl_res= not flag_pl_res
          		wset,s_pl_wid
          		plot_it
          		end
          		3:begin
          		flag_norm= not flag_norm
          		wset,s_pl_wid
          		plot_it
          		end
          	endcase
          	end
          3:	no_plot=1							; Mid column3 Event ... plot should not occur
      endcase
      end
    4:case Ev(2) of						; Bottom Event
          1:begin
          num_lor=0 & num_gau=0
          widget_control,sw_tx_nlor,get_value=str_numlor
          widget_control,sw_tx_ngau,get_value=str_numgau
          str_numlor=strcompress(str_numlor,/remove_all) & num_lor=fix(str_numlor) & num_lor=num_lor(0)
          str_numgau=strcompress(str_numgau,/remove_all) & num_gau=fix(str_numgau) & num_gau=num_gau(0)
          print,'num_lor=',num_lor
          print,'num_gau=',num_gau
          n_l=num_lor & n_g=num_gau
          if ((num_lor lt 0) or (num_lor gt 5)) then begin
          str_numlor='1'
          widget_control,sw_tx_nlor,set_value=str_numlor
          endif $
          else if ((num_gau lt 0) or (num_gau gt 5)) then begin
          str_numgau='1'
          widget_control,sw_tx_ngau,set_value=str_numgau
          endif else begin
          widget_control,bad_id=i,sw_ba_bot,/DESTROY
          Print,'Traitement Res function'
          widget_control,sw_tx_resmin,get_value=str_resmin
          str_test=strcompress(str_resmin,/remove_all) & rfmin=float(str_resmin) & rfmin=rfmin(0)
          widget_control,sw_tx_resmax,get_value=str_resmax
          str_test=strcompress(str_resmax,/remove_all) & rfmax=float(str_resmax) & rfmax=rfmax(0)
          treat_resf
          fit_basegl2
          endelse
          end							; Start Event
          2:widget_control,bad_id=i,sw_ba_bot,/DESTROY			; Done Event
      endcase
    6:case Ev(1) of
          0:begin
                widget_control,sw_tx_wsub,get_value=str_wsub & str_wsub=strlowcase(strcompress(str_wsub,/remove_all))
                num_spectrum=1 & str_wsub=str_wsub(0)
                num_spectrum=fix(str_wsub) & num_spectrum=num_spectrum(0)
                if ((num_spectrum le 0) or (num_spectrum gt nb_spe_tot)) then begin
                num_spectrum=1
                widget_control,sw_tx_wsub,set_value=' 1'
                endif
;                ispecc=num_spectrum
                betatemp=0
                if flag_sym then begin                
                widget_control,sw_tx_temp,get_value=str_temp & str_temp=strlowcase(strcompress(str_temp,/remove_all))
                str_temp=str_temp(0) & temp=float(str_temp) & temp=temp(0)
                if temp le 1.5 then begin
                widget_control,sw_tx_temp,set_value='0.',sensitive=0
                flag_sym=not flag_sym
                widget_control,sw_bu_symsqw,set_button=abs(flag_sym)
                endif else $
                betatemp=11.6045/temp
                endif
;                print,'betatemp=',betatemp,'temp-meV=',1./betatemp
          case Ev(2) of
                0:begin
                on_error,0
                ; ** THE TRY BUTTON HAS BEEN PRESSED !!!
                prepare_2_fit, X,Y,E,parinfo
                end               
                1:begin
                on_error,0
                ispecc_min=num_spectrum & ispecc_max=num_spectrum
                if flag_all then begin ispecc_min=1 & ispecc_max=nb_spe_tot & endif
                for ispecc=ispecc_min,ispecc_max do begin
                if not flag_reverse then num_spectrum=ispecc else num_spectrum=nb_spe_tot-ispecc+1
                print,"Treating spectrum# ", num_spectrum
                ; ** THE FIT BUTTON HAS BEEN PRESSED !!!
;                stop
                prepare_2_fit, X,Y,E,parinfo
                ; ** Now I can launch the fitting procedure
                sf_new=MPFIT('myfunc',sf_new,FUNCTARGS={XVAL:X,YVAL:Y,ERRVAL:E},$
                PERROR=sf_e,BESTNorM=chisq,PARINFO=parinfo)
                sf_new_values(num_spectrum-1,*)=sf_new(*)
                sf_e_values(num_spectrum-1,*)=sf_e(*)
                chisqr(num_spectrum-1)=chisq
                print,'For spectrum# ',num_spectrum,' CHISQ=',chisq
                endfor
                ispecc=ispecc-1
                end
           endcase
           
           ispecc_min=num_spectrum & ispecc_max=num_spectrum
           if flag_all then begin ispecc_min=1 & ispecc_max=nb_spe_tot & endif
           for ispect=ispecc_min-1,ispecc_max-1 do begin
;                if not flag_reverse then num_spectrum=ispect+1 else num_spectrum=nb_spe_tot-ispecc+1
                num_spectrum=ispect+1
                print,"calculating spectrum# ", num_spectrum
;                prepare_2_fit, X,Y,E,parinfo			  
           case name_func of
					  'LOR_GAU':begin
					  fact=1
        str_wsub=string(num_spectrum) & str_wsub=strcompress(str_wsub(0),/remove_all) & widget_control,sw_tx_wsub,set_value=str_wsub
        for i=0,fact*num_lor*3+fact*num_gau*3+4-1 do begin ; sf_new_values must print the new value of the parameters
        str_balg2=string(sf_new_values(ispect,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
        widget_control,sw_tx_balg2(3*i),set_value=str_balg2
        str_balg2=string(sf_last_values(ispect,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
        widget_control,sw_tx_balg2(3*i+1),set_value=str_balg2
        str_balg2=string(sf_e_values(ispect,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
        widget_control,sw_tx_balg2(3*i+2),set_value=str_balg2
        endfor
;        if flag_all then flag_all=not flag_all
;        prepare_2_fit,X,Y,E,parinfo
					  falpha=0 & fbeta=nb_channels-1
					  w_resc2=w_resc
					  w_resc2_ispe=w_resc2(*,ispect)
					  ;f_fitted=funlg_to_fit(sx_in,sf_new_values)
            f_fitted=funlg_to_fit(sx_in,sf_new_values(ispect,*),betatemp)
					  ; ** Calculate the fitted curve
            ;stop
					  sf_w_fitted(*,ispect)=f_fitted(*)
            sw_result=sf_w_fitted & widget_control,sw_bu_wwou,sensitive=1
					  ; ** Do the difference exp-th
					  sf_w_exp_fit(*,ispect)=sw_in(*,ispect)-sf_w_fitted(*,ispect)
            ;stop
					  ; ** Express the sub-functions
            
            w_resc2_ispe=w_resc2(*,num_spectrum-1)
            ess_conv=w_resc2_ispe(aalpha(num_spectrum-1):abeta(num_spectrum-1)+1)
					  
            dcenter=sf_new_values(ispect,3*num_lor+3*num_gau)
					  dint=sf_new_values(ispect,3*num_lor+3*num_gau+1)
					  sf_sub_function(ispect,*,num_lor+num_gau)=dint*w_resc2_interp(*)
					  slope=sf_new_values(ispect,3*num_lor+3*num_gau+2)
					  const=sf_new_values(ispect,3*num_lor+3*num_gau+3)
					  sf_sub_function(ispect,*,num_lor+num_gau+1)=slope*sx_in(*)+const
					  if num_lor gt 0 then begin
					  for i=0,num_lor-1 do begin
					  ll=qlorentz(sx_in,sf_new_values(ispect,i*3),sf_new_values(ispect,i*3+1),sf_new_values(ispect,i*3+2))
					  ind_lor_0=where(ll ge 1e-10,nn)
					  if nn le 7 then begin
					  dcenter=sf_new_values(ispect,i*3)
					  dint=sf_new_values(ispect,i*3+2) & x_interp=sx_in+dcenter
					  lll=dint*spline(x_interp,w_resc2_ispe,sx_in)
					  endif else lll=convol(ll,ess_conv,total(ess_conv),/edge_truncate);,center=0);lll=convs(ll,ispect+1,falpha,fbeta,w_resc2)
					  sf_sub_function(ispect,*,i)=lll(*)
					  endfor
					  endif
					  if num_gau gt 0 then begin
					  for i=0,num_gau-1 do begin
				    gg=qgauss(sx_in,sf_new_values(ispect,igminind+i*3),$
            sf_new_values(ispect,igminind+i*3+1),sf_new_values(ispect,igminind+i*3+2))
            ind_gau_0=where(gg ge 1e-10,nn)
					  if nn le 7 then begin
					  dcenter=sf_new_values(ispect,igminind+i*3)
					  dint=sf_new_values(ispect,igminind+i*3+2) & x_interp=sx_in+dcenter
					  ggg=dint*spline(x_interp,w_resc2_ispe,sx_in)
					  endif else ggg=convol(gg,ess_conv,total(ess_conv),/edge_truncate);,center=0);ggg=convs(gg,ispect+1,falpha,fbeta,w_resc2)
					  sf_sub_function(ispect,*,num_lor+i)=ggg(*)
					  endfor
					  endif
	;				convs(w_to_conv,ispecc,falpha,fbeta,w_resc2)
                 ; ** And I can write the results
;                 if ispecc_min ne ispecc_max then flag_all=not flag_all
        if not flag_pl_fit then flag_pl_fit=not flag_pl_fit
  				plot_it
					  end
					  else:print,'There is only one function at the moment'
				endcase
        endfor
;        stop
;				str_wsub=string(num_spectrum) & str_wsub=strcompress(str_wsub(0),/remove_all) & widget_control,sw_tx_wsub,set_value=str_wsub
;				if not flag_pl_fit then flag_pl_fit=not flag_pl_fit
;				plot_it
        
                ; ** And I can write the results
;        for i=0,fact*num_lor*3+fact*num_gau*3+4-1 do begin ; sf_new_values must print the new value of the parameters
;        str_balg2=string(sf_new_values(ispecc-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
;        widget_control,sw_tx_balg2(3*i),set_value=str_balg2
;        str_balg2=string(sf_last_values(ispecc-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
;        widget_control,sw_tx_balg2(3*i+1),set_value=str_balg2
;        str_balg2=string(sf_e_values(ispecc-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
;        widget_control,sw_tx_balg2(3*i+2),set_value=str_balg2
;        endfor
                end
          1:begin
                widget_control,sw_tx_wsub,get_value=str_wsub & str_wsub=strlowcase(strcompress(str_wsub,/remove_all))
                num_spectrum=1 & str_wsub=str_wsub(0)
                num_spectrum=fix(str_wsub) & num_spectrum=num_spectrum(0)
                if ((num_spectrum le 0) or (num_spectrum gt nb_spe_tot)) then begin
                num_spectrum=1
                widget_control,sw_tx_wsub,set_value=' 1'
                endif
            i2fix=Ev(2)
            sf_index(num_spectrum-1,i2fix)=not sf_index(num_spectrum-1,i2fix)
				    widget_control,sw_tx_balg2(i2fix*3),sensitive=sf_index(num_spectrum-1,i2fix)
            widget_control,sw_bu_balg2(i2fix),set_button=abs(not sf_index(num_spectrum-1,i2fix))
            end
          2:case Ev(2) of
                0:begin
                widget_control,bad_id=i,sw_ba_bot,/DESTROY			; Done Event
                widget_control,bad_id=i,sw_bu_fit,sensitive=0   ;Set the FIT button non-sensitive
                widget_control,bad_id=i,sw_bu_done,sensitive=0          ;Set the DONE button non-sensitive
                widget_control,sw_tx_resmin,sensitive=1         ;set the x res ranges actives
                widget_control,sw_tx_resmax,sensitive=1
                if flag_pl_fit then flag_pl_fit=not flag_pl_fit
                if flag_pl_fit2 then flag_pl_fit2=not flag_pl_fit2
                if flag_all then flag_all=not flag_all
                end
                1:begin                                         ;"Fit all Sp" check box 
                flag_all=not flag_all
                widget_control,sw_bu_try,sensitive=abs(not flag_all)
                widget_control,sw_bu_fitall,set_button=abs(flag_all)
                widget_control,sw_bu_acquire,sensitive=abs(not flag_all)
                widget_control,sw_tx_acquire,sensitive=abs(not flag_all)
                if not flag_all then begin
                flag_fromlast=0 & flag_reverse=0
                widget_control,sw_bu_reverse,set_button=0
                widget_control,sw_bu_fromlast,set_button=0
                endif
                widget_control,sw_bu_reverse,sensitive=abs(flag_all)
                widget_control,sw_bu_fromlast,sensitive=abs(flag_all)
                end
                2:begin                                              ;"Acquire from Sp#" button
                widget_control,sw_tx_acquire,get_value=str_acq & str_acq=strlowcase(strcompress(str_acq,/remove_all))
                i_acq=1 & str_acq=str_acq(0)
                i_acq=fix(str_acq) & i_acq=i_acq(0)
                if ((i_acq le 0) or (i_acq gt nb_spe_tot)) then begin
                print,'ERROR num_spectrum out of range ... put it to 1'
                i_acq=1
                widget_control,sw_tx_acquire,set_value=' 1'
                endif
                fact=1
                ; Change the parameters text box values
                for i=0,fact*num_lor*3+fact*num_gau*3+4-1 do begin ; sf_new_values must print the new value of the parameters
                str_balg2=string(sf_new_values(i_acq-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
                widget_control,sw_tx_balg2(3*i),set_value=str_balg2,sensitive=sf_index(i_acq-1,i)
                str_balg2=string(sf_last_values(i_acq-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
                widget_control,sw_tx_balg2(3*i+1),set_value=str_balg2
                str_balg2=string(sf_e_values(i_acq-1,i)) & str_balg2=strcompress(str_balg2(0),/remove_all)
                widget_control,sw_tx_balg2(3*i+2),set_value=str_balg2
                widget_control,sw_bu_balg2(i),set_button=abs(not sf_index(i_acq-1,i))
                sf_index(num_spectrum-1,i)=sf_index(i_acq-1,i)
                endfor           
                end
                3:begin
                flag_reverse=not flag_reverse
                widget_control,sw_bu_reverse,set_button=abs(flag_reverse)
                end
                4:begin
                flag_fromlast=not flag_fromlast
                widget_control,sw_bu_fromlast,set_button=abs(flag_fromlast)
                end
                5:begin
                flag_sym=not flag_sym
                widget_control,sw_bu_symsqw,set_button=abs(flag_sym)
                widget_control,sw_tx_temp,sensitive=abs(flag_sym)
                ;sw_bu_symsqw,sw_tx_temp
                end
                6:
         endcase        
      endcase
    else: error_msg, 5
endcase
end

; ** **************************************************************
pro plot_it
; ** **************************************************************
; ** This routine defines the plot-limits required
;
@lamp.cbk
common sc_wid
common sc_loc
common sc_flag
common sc_fit

; ** Getting the information about the desired plot (xrange,yrange and subplot)
widget_control,sw_tx_xmin,get_value=str_xmin & str_xmin=strlowcase(strcompress(str_xmin,/remove_all))
widget_control,sw_tx_xmax,get_value=str_xmax & str_xmax=strlowcase(strcompress(str_xmax,/remove_all))
widget_control,sw_tx_ymin,get_value=str_ymin & str_ymin=strlowcase(strcompress(str_ymin,/remove_all))
widget_control,sw_tx_ymax,get_value=str_ymax & str_ymax=strlowcase(strcompress(str_ymax,/remove_all))

; ** Some necessary transformation from string to float or integer
str_xmin=str_xmin(0) & str_ymin=str_ymin(0)
str_xmax=str_xmax(0) & str_ymax=str_ymax(0)

; ** Putting the arrays into one and two dimensional array
w_wk=sw_in(*,num_spectrum-1)
w_wkres=sw_res(*,num_spectrum-1)
w_wkfit=sf_w_fitted(*,num_spectrum-1)
d_wk=sf_w_exp_fit(*,num_spectrum-1)
; ** Normalize to elastic peak intensity when normalize button is pushed
if flag_norm then w_wkres=w_wkres/(max(w_wkres)/max(w_wk))
e_wk=se_in(*,num_spectrum-1)
x_to_plot=sx_in & sss=size(x_to_plot)
if sss(0) gt 1 then x_to_plot=x_to_plot(0)
; ** Checking the input value for errors
if str_xmin eq 'min' then xmin=min(sx_in) $
else begin
xmin=float(str_xmin) & xmin=xmin(0)
endelse
if str_xmax eq 'max' then xmax=max(sx_in) $
else begin
xmax=float(str_xmax) & xmax=xmax(0)
endelse
if str_ymin eq 'min' then ymin=min(w_wk)  $
else begin
ymin=float(str_ymin) & ymin=ymin(0)
endelse
if str_ymax eq 'max' then ymax=max(w_wk)  $
else begin
ymax=float(str_ymax) & ymax=ymax(0)
endelse
if ((xmin ge xmax) or (ymin ge ymax)) then begin
xmin=min(sx_in) & xmax=max(sx_in) & ymin=min(sy_in) & ymax=max(sy_in)
endif
;
; Adapt vector to current plot zone
;ind=where((sx_in ge xmin) and (sx_in le xmax) and (w_wk le ymax) and (w_wk ge ymin), nb_pt1) & ind=ind(0) ;last one to have a 1d vector
; do the plot
!x.title='Energy transfert (meV)'
!y.title='Intensity (a.u)'
widget_control, bad_id=i, sw_pl_area, get_value=s_pl_wid 	; Store the number assigned to this window in s_pl_wid
wset,s_pl_wid											                        ; Set the s_pl_wid active
plot,x_to_plot,w_wk,psym=7,xrange=[xmin,xmax],yrange=[ymin,ymax]
errlow=w_wk-e_wk & errhigh=w_wk+e_wk
indzero=where(errlow lt 0.) & if (indzero(0) ne -1) then errlow(indzero)=abs(10.*w_wk(indzero))
;errplot,x_to_plot,w_wk-e_wk,w_wk+e_wk
errplot,x_to_plot,errlow,errhigh;,color=1
if flag_pl_res then oplot,x_to_plot,w_wkres,color=1
if flag_pl_fit then begin
oplot,x_to_plot,w_wkfit,color=65,linestyle=0,thick=2
for i=0,num_lor+num_gau+1 do begin
oplot,x_to_plot,sf_sub_function(num_spectrum-1,*,i),color=11+i*10,linestyle=2,thick=2
endfor
widget_control, bad_id=i, sw_pl_areabot, get_value=s_pl_widbot 	; Store the number assigned to this window in s_pl_wid
wset,s_pl_widbot
!x.title=''
!y.title='e-t';!y.title='exp-th '
plot,x_to_plot,d_wk,xrange=[xmin,xmax],pos=[0.12,0.,0.97,1.]
wset,s_pl_wid
endif
;plot_flag=1
;trap_current=!D.window
return
end

; ** **************************************************************
pro fit_basegl
; ** **************************************************************
; ** create the base of the fitting routine
;
@lamp.cbk
common sc_wid
common sc_loc
common sc_flag
common sc_fit

;print,"ON Y EST ! C'est parti"

if (xregistered('fit_base') le 0) then begin

; ** Start definition of the widget object
; ** *************************************

; ** Base for the fit
sw_ba_bot=widget_base(group_leader=sw_ba_leader, /row, $
				Title='Choose the number of functions to use',$
				resource_name='lamp')
;sw_ba_bot=widget_base(sw_ba_leader,Title='Base row bottom',/row)

; ** First up : button, labels and text boxes
sw_bu_start=widget_button(sw_ba_bot,Font=ft_b_smaller,Frame=2,value='Start',uvalue=[4,0,1])
sw_bu_cancel=widget_button(sw_ba_bot,Font=ft_b_smaller,Frame=2,value='Cancel',uvalue=[4,0,2])
sw_la_nlor=widget_label(sw_ba_bot,Font=ft_b_smaller,value='Number of Lorentzian ?')
sw_tx_nlor=widget_text(sw_ba_bot,Font=ft_b_smaller,/editable,value='1',uvalue=[4,0,3],xsize=2)
sw_la_ngau=widget_label(sw_ba_bot,Font=ft_b_smaller,value='Number of Gaussian ?')
sw_tx_ngau=widget_text(sw_ba_bot,Font=ft_b_smaller,/editable,value='1',uvalue=[4,0,4],xsize=2)

; ** Realization of the Base
widget_control, sw_ba_bot, /Realize; & put_logo
xmanager,'qens_fit',sw_ba_bot,/just_reg

endif

end

; ** **************************************************************
pro fit_basegl2
; ** **************************************************************
; ** create the base of the fitting routine for a Lor-Gau fit
;
@lamp.cbk
common sc_wid
common sc_loc
common sc_flag
common sc_fit
common sc_convs

name_func='LOR_GAU'

; ** Defining the flag for the L and G click box
; ** *******************************************
flag_lfit=0 & flag_gfit=0 & flag_lcfit=0 & flag_gcfit=0 & flag_lwfit=0
flag_gwfit=0 & flag_lifit=0 & flag_gifit=0
flag_dfit=0 & flag_bfit=0 & flag_dcfit=0 & flag_bcfit=0
flag_difit=0 & flag_bifit=0
flag_lgifit=intarr(num_lor+num_gau+2)
flag_pl_fit2=not flag_pl_fit2
flag_reverse=0
flag_fromlast=0
flag_sym=0

; ** Defining the widgetID vectors
; ** *****************************
dimlongtx=9*(num_lor+num_gau)+12
ilor=0 & igau=0
if num_lor gt 0 then ilor=1
if num_gau gt 0 then igau=1
;dimlongbu=4*(num_lor+num_gau+ilor+igau)+6
dimlongbu=3*(num_lor+num_gau)+4
sw_tx_balg2=lonarr(dimlongtx)
sw_bu_balg2=lonarr(dimlongbu)

; ** Defining the fit variable vectors
; ** *********************************
sf_index=intarr(nb_spe_tot,3*num_lor+3*num_gau+4) & sf_index=not sf_index
sf_new_values=fltarr(nb_spe_tot,3*num_lor+3*num_gau+4) & for ii=0,nb_spe_tot-1 do sf_new_values(ii,3*indgen(num_lor+num_gau))=center_rf(ii)
sf_new_values(0:nb_spe_tot-1,3*indgen(num_lor+num_gau)+1)=0.1 & sf_new_values(0:nb_spe_tot-1,3*indgen(num_lor+num_gau)+2)=1.
sf_new_values(0:nb_spe_tot-1,3*num_lor+3*num_gau:3*num_lor+3*num_gau+3)=0. & sf_new_values(0:nb_spe_tot-1,3*num_lor+3*num_gau+1)=10.
sf_last_values=fltarr(nb_spe_tot,3*num_lor+3*num_gau+4)
sf_e_values=fltarr(nb_spe_tot,3*num_lor+3*num_gau+4)
sf_sub_function=fltarr(nb_spe_tot,nb_channels,num_lor+num_gau+2)
sf_functions_labels=strarr(num_lor*3+num_gau*3+2*2)
sf_errors_labels=strarr(num_lor*3+num_gau*3+2*2)
chisqr=fltarr(nb_spe_tot)+1.e30

if (xregistered('fit_base') le 0) then begin

; ** Start definition of the widget object
; ** *************************************

; ** Base for the fit
; ** First Base
sw_ba_bot=widget_base(group_leader=sw_ba_leader, /column, $
				Title='Fitted parameters and errors ',$
				resource_name='lamp')

; ** Now do the Lorentzian functions if any

sw_ba_botup1=widget_base(sw_ba_bot,Frame=2,Title='Base botlow left',/column)


if num_lor gt 0 then begin
for il=1,num_lor do begin
sw_ba_botup=widget_base(sw_ba_botup1,/row)
str_il='L'+string(il) & str_il=strcompress(str_il,/remove_all)
sw_la_lor=widget_label(sw_ba_botup,value=str_il,font=font_smaller,xsize=50,/align_center)
;
str_il='C'+string(il) & str_il=strcompress(str_il,/remove_all)
sw_la_clor=widget_label(sw_ba_botup,value=str_il,font=font_smaller,xsize=30,/align_center);'
sw_tx_balg2((il-1)*9)=widget_text(sw_ba_botup,font=font_smaller,value=strcompress(string(center_rf(num_spectrum-1)),/remove_all),/editable,xsize=5,/align_center)
sw_tx_balg2((il-1)*9+1)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2((il-1)*9+2)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_botup,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2((il-1)*3)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,(il-1)*3],/align_center)
;
str_il='W'+string(il) & str_il=strcompress(str_il,/remove_all)
sw_la_wlor=widget_label(sw_ba_botup,value=str_il,font=font_smaller,xsize=30,/align_center);'
sw_tx_balg2((il-1)*9+3)=widget_text(sw_ba_botup,font=font_smaller,value='0.10',/editable,xsize=5,/align_center)
sw_tx_balg2((il-1)*9+4)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2((il-1)*9+5)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_botup,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2((il-1)*3+1)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,(il-1)*3+1],/align_center)
;
str_il='I'+string(il) & str_il=strcompress(str_il,/remove_all)
sw_la_ilor=widget_label(sw_ba_botup,value=str_il,font=font_smaller,xsize=30,/align_center);'
sw_tx_balg2((il-1)*9+6)=widget_text(sw_ba_botup,font=font_smaller,value='1.00',/editable,xsize=5,/align_center)
sw_tx_balg2((il-1)*9+7)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2((il-1)*9+8)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_botup,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2((il-1)*3+2)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,(il-1)*3+2],/align_center)
sf_functions_labels((il-1)*3)='Center value for Lor#'+strcompress(string(il),/remove_all)
sf_functions_labels((il-1)*3+1)='Width value for Lor#'+strcompress(string(il),/remove_all)
sf_functions_labels((il-1)*3+2)='Intensity value for Lor#'+strcompress(string(il),/remove_all)
sf_errors_labels((il-1)*3)='with error'
sf_errors_labels((il-1)*3+1)='with error'
sf_errors_labels((il-1)*3+2)='with error'

endfor
endif
igmin=num_lor*3
igmintx=num_lor*9
igminind=num_lor*3
; ** Now do the Gaussian function if any
if num_gau gt 0 then begin

for ig=1,num_gau do begin
;
sw_ba_botup=widget_base(sw_ba_botup1,/row)
;
str_ig='G'+string(ig) & str_ig=strcompress(str_ig,/remove_all)
sw_la_gau=widget_label(sw_ba_botup,value=str_ig,font=font_smaller,xsize=50,/align_center)
;
str_ig='C'+string(ig) & str_ig=strcompress(str_ig,/remove_all)
sw_la_cgau=widget_label(sw_ba_botup,value=str_ig,font=font_smaller,xsize=30,/align_center);'
sw_tx_balg2(igmintx+(ig-1)*9)=widget_text(sw_ba_botup,font=font_smaller,value=strcompress(string(center_rf(num_spectrum-1)),/remove_all),/editable,xsize=5,/align_center)
sw_tx_balg2(igmintx+(ig-1)*9+1)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2(igmintx+(ig-1)*9+2)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_botup,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2(igmin+(ig-1)*3)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,igmin+(ig-1)*3],/align_center)
;
str_ig='W'+string(ig) & str_ig=strcompress(str_ig,/remove_all)
sw_la_wlor=widget_label(sw_ba_botup,value=str_ig,font=font_smaller,xsize=30,/align_center);'
sw_tx_balg2(igmintx+(ig-1)*9+3)=widget_text(sw_ba_botup,font=font_smaller,value='0.10',/editable,xsize=5,/align_center)
sw_tx_balg2(igmintx+(ig-1)*9+4)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2(igmintx+(ig-1)*9+5)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_botup,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2(igmin+(ig-1)*3+1)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,igmin+(ig-1)*3+1],/align_center)
;
str_ig='I'+string(ig) & str_ig=strcompress(str_ig,/remove_all)
sw_la_ilor=widget_label(sw_ba_botup,value=str_ig,font=font_smaller,xsize=30,/align_center);'
sw_tx_balg2(igmintx+(ig-1)*9+6)=widget_text(sw_ba_botup,font=font_smaller,value='1.00',/editable,xsize=5,/align_center)
sw_tx_balg2(igmintx+(ig-1)*9+7)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2(igmintx+(ig-1)*9+8)=widget_text(sw_ba_botup,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_botup,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2(igmin+(ig-1)*3+2)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,igmin+(ig-1)*3+2],/align_center)

sf_functions_labels(igmin+(ig-1)*3)='Center value for Gau#'+strcompress(string(ig),/remove_all)
sf_functions_labels(igmin+(ig-1)*3+1)='Width value for Gau#'+strcompress(string(ig),/remove_all)
sf_functions_labels(igmin+(ig-1)*3+2)='Intensity value for Gau#'+strcompress(string(ig),/remove_all)
sf_errors_labels(igmin+(ig-1)*3)='with error'
sf_errors_labels(igmin+(ig-1)*3+1)='with error'
sf_errors_labels(igmin+(ig-1)*3+2)='with error'
endfor
endif

; ** The Delta function
; ** ********************************
sw_ba_botlow=widget_base(sw_ba_bot,Frame=2,Title='Base bot right',/column)
idmin=igmin+num_gau*3
idmintx=igmintx+num_gau*9
idminind=igminind+num_gau*3

sw_ba_c1=widget_base(sw_ba_botlow,/row)
;
sw_la_del=widget_label(sw_ba_c1,value='D ',font=font_smaller,/align_center,xsize=50)
;
sw_la_cdel=widget_label(sw_ba_c1,value='Cd',font=font_smaller,xsize=30,/align_center)
sw_tx_balg2(idmintx)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',/editable,xsize=5,/align_center)
sw_tx_balg2(idmintx+1)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2(idmintx+2)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2(idmin)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,idmin],/align_center)

sw_la_idel=widget_label(sw_ba_c1,value='Id',font=font_smaller,xsize=30,/align_center)
sw_tx_balg2(idmintx+3)=widget_text(sw_ba_c1,font=font_smaller,value='10.0',/editable,xsize=5,/align_center)
sw_tx_balg2(idmintx+4)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2(idmintx+5)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2(idmin+1)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,idmin+1],/align_center)

sf_functions_labels(idmin)='Center value for Delta'
sf_functions_labels(idmin+1)='Intensity value for Delta'
sf_errors_labels(idmin)='with error'
sf_errors_labels(idmin+1)='with error'


;; ** Insert the "Try without fitting" button and "fitALL" chekbox
;; ** *************************************************************
;sw_bu_try=widget_button(sw_ba_c1,Font=ft_b_smaller,Frame=1,value='Try and enter',uvalue=[6,0,0])
;sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box2',/nonexclusive,/align_center,/row)
;sw_bu_fitall=widget_button(sw_ba_cb1,value=' fit all Sp?',uvalue=[6,2,1],/align_center)
;sw_bu_reverse=widget_button(sw_ba_cb1,value=' reverse?',uvalue=[6,2,3],/align_center,sensitive=0)
;sw_bu_fromlast=widget_button(sw_ba_cb1,value=' from last?',uvalue=[6,2,4],/align_center,sensitive=0)
;
;;sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box4',/nonexclusive,/align_center)
;;sw_bu_balg2(idmin+2)=widget_button(sw_ba_cb1,value='',uvalue=[6,1,80],/align_center)

; ** Now the slopping background
; ** *************************************************
ibmin=idmin+2
ibmintx=idmintx+6
ibminind=idminind+2

sw_ba_c1=widget_base(sw_ba_botlow,/row)
;
sw_la_bac=widget_label(sw_ba_c1,value='B ',font=font_smaller,/align_center,xsize=50)
;
sw_la_sbac=widget_label(sw_ba_c1,value='Sb',font=font_smaller,xsize=30,/align_center)
sw_tx_balg2(ibmintx)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',/editable,xsize=5,/align_center)
sw_tx_balg2(ibmintx+1)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2(ibmintx+2)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2(ibmin)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,ibmin],/align_center)

sw_la_idel=widget_label(sw_ba_c1,value='Cb',font=font_smaller,xsize=30,/align_center)
sw_tx_balg2(ibmintx+3)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',/editable,xsize=5,/align_center)
sw_tx_balg2(ibmintx+4)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_tx_balg2(ibmintx+5)=widget_text(sw_ba_c1,font=font_smaller,value='0.00',xsize=5,/align_center)
sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box2',/nonexclusive,/align_center)
sw_bu_balg2(ibmin+1)=widget_button(sw_ba_cb1,value='fix?',uvalue=[6,1,ibmin+1],/align_center)

sf_functions_labels(ibmin)='Slope value for Backg'
sf_functions_labels(ibmin+1)='Constant value for Backg'
sf_errors_labels(ibmin)='with error'
sf_errors_labels(ibmin+1)='with error'

; ** Insert the "Try without fitting" button and "fitALL" chekbox
; ** *************************************************************
sw_ba_botlow=widget_base(sw_ba_bot,Frame=2,Title='Base bot right',/column)
sw_ba_c1=widget_base(sw_ba_botlow,/row)
sw_bu_try=widget_button(sw_ba_c1,Font=ft_b_smaller,Frame=1,value='Try and enter',uvalue=[6,0,0])
sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box2',/nonexclusive,/align_center,/row)
sw_bu_fitall=widget_button(sw_ba_cb1,value=' fit all Sp?',uvalue=[6,2,1],/align_center)
sw_bu_reverse=widget_button(sw_ba_cb1,value=' reverse?',uvalue=[6,2,3],/align_center,sensitive=0)
sw_bu_fromlast=widget_button(sw_ba_cb1,value=' from last?',uvalue=[6,2,4],/align_center,sensitive=0)

;sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box4',/nonexclusive,/align_center)
;sw_bu_balg2(idmin+2)=widget_button(sw_ba_cb1,value='',uvalue=[6,1,80],/align_center)

; ** Insert the "Acquire from Sp#" button and "Sp#" textbox and symetrization possibility
; ** *************************************************************************************
sw_ba_c1=widget_base(sw_ba_botlow,/row)
sw_bu_acquire=widget_button(sw_ba_c1,Font=ft_b_smaller,Frame=1,value='Acquire from Sp#',uvalue=[6,2,2])
sw_tx_acquire=widget_text(sw_ba_c1,font=font_smaller,value=' 1',/editable,xsize=3,/align_center)
sw_ba_cb1=widget_base(sw_ba_c1,Title='Fit box1',/nonexclusive,/align_center)
sw_bu_symsqw=widget_button(sw_ba_cb1,value='Sym.S(Q,w)?',/align_center,uvalue=[6,2,5])
sw_tx_temp=widget_text(sw_ba_c1,font=font_smaller,value=' 0',/editable,xsize=3,/align_center,sensitive=0)
sw_la_temp=widget_label(sw_ba_c1,value='K',font=font_smaller,xsize=10,/align_center)
;

; ** We initialise the sf_new_values, sf_last_values, sf_e_values arrays !
; ** *********************************************************************
;for i=0,num_lor*3+num_gau*3+4-1 do begin ; sf_new_values must print the new value of the parameters
;widget_control,sw_tx_balg2(3*i),get_value=str_balg2
;flt_balg2=float(str_balg2) & flt_balg2=flt_balg2(0) & sf_new_values(*,i)=flt_balg2
;widget_control,sw_tx_balg2(3*i+1),get_value=str_balg2
;flt_balg2=float(str_balg2) & flt_balg2=flt_balg2(0) & sf_last_values(*,i)=flt_balg2
;widget_control,sw_tx_balg2(3*i+2),get_value=str_balg2
;flt_balg2=float(str_balg2) & flt_balg2=flt_balg2(0) & sf_e_values(*,i)=flt_balg2
;endfor


; ** Realization of the Base
widget_control, sw_ba_bot, /Realize; & put_logo
xmanager,'qens_fit',sw_ba_bot,/just_reg

; ** Set the FIT and DONE button sensitive:
widget_control,sw_bu_fit, sensitive=1
widget_control,sw_bu_done, sensitive=1

endif

end

; ** **************************************************************************
pro treat_resf
; ** **************************************************************************
; ** This program gives several treatment to the resolution function spectrum
; ** Basically, il substracts a flat background, performs the normalization to 1
; ** and deal with the range under consideration (e.g w where res(w) ne 0)
; ** sw_res=vector containing the exp. res. function
; ** w_resc=vector containing the treated res function
; ** rfmin and rfmax define the range of res. fun. to consider [rfmin,rfmax]
; ** treatment for spectrum ispmin to ispmax but for the moment, full treatment e.g
; ** ispmin and ispmax=(size(w_res))(2) (nspectra)

common sc_loc
common sc_fit
common sc_convs
common sc_wid
; ** recovering the data parameter
; ** *****************************
x_rf=sx_res ; energy array
y_rf=sy_res ; Q or theta array
e_rf=se_res ; error array
w_rf=sw_res   ; raw RF array
iprint=0 & ispmax=1
aalpha=y_rf*0. & abeta=aalpha & cel=aalpha
s_w_rf=size(sw_res) & nrfx=s_w_rf(1)
s_x_rf=size(sx_in) & nrx=s_x_rf(1)
ispmin=1 & ispmax=nb_spe_tot
fwhm_rf=fltarr(nb_spe_tot) & center_rf=fwhm_rf
;ispmin=1 & if s_w_rf(0) eq 2 then ispmax=s_w_rf(2)
if nrfx ne nrx then print,"PROBLEM: Dimension of X and W don't match !!"

; ** Start the loop on the spectra
; ** ******************************
for ispec=ispmin-1,ispmax-1 do begin
if iprint ne 0 then print,"Spectrum #",ispec
;
; ** obtaining alpha, beta and ce
; ** cad x_rf(alpha)=rfmin & x_rf(beta)=rfmax (limits)
; ** and x_rf(ce)=0. meV (elastic channel)
; ** *************************************************
rfin=where((x_rf lt rfmax) and (x_rf gt rfmin),nrfpts, complement=rfout)
aalpha(ispec)=rfin(0) & abeta(ispec)=rfin(nrfpts-1)
if (floor(nrfpts/2.)*2) eq nrfpts then begin
print,'PROBLEM: number of points in the Res. Function range should be odd and symetric % 0meV'
stop
endif
ce=where(w_rf(*,ispec) eq max(w_rf(*,ispec))) & e_el=x_rf(ce)
cel(ispec)=ce(0) & ce=ce(0) & test=where(ce eq rfin) & test=test(0)
if rfmax le rfmin then begin $
print, "PROBLEM: range of Res. function, rfmin not lt rfmax !!"
stop
endif
if test eq -1 then begin $
print, "PROBLEM: range of Res. function doesn't have the elastic peak !!"
stop
endif
if nrfpts le 5 then begin $
print, "PROBLEM: not enough points in the resolution function range !!"
stop
endif
if iprint ne 0 then begin
print,"aalpha=",aalpha(ispec),"abeta=",abeta(ispec),"ce=",ce,"e_el=",e_el
print,"rfin=",rfin
print,"rfout=",rfout
print,"test=",test
endif

; ** Fitting the resolution function with a Gaussian shape to have
; ** the width at half maximum
; ** **************************************************************

x_in_fit=x_rf(rfin)
y_in_fit=w_rf(rfin,ispec)
reso_fitted= gaussfit(x_in_fit,y_in_fit,A_param,NTERMS=4)
;print,A_param
plot,x_in_fit,y_in_fit
oplot,x_in_fit,reso_fitted,color=80000
fwhm_rf(ispec)=2*A_param(2)*sqrt(2*alog(2.)) & print,'FWHM for the RF at group#',ispec,fwhm_rf(ispec)
center_rf(ispec)=A_param(1) & print,'Center for the RF at group#',ispec,A_param(1)
;wait,0.2
; ** Substraction of a flat background
; ** *************************************
if iprint ne 0 then print, w_rf(*,ispec)
rfalpha=total(w_rf(aalpha(ispec):aalpha(ispec)+9,ispec),1)/10. & rfbeta=total(w_rf(abeta(ispec)-9:abeta(ispec),ispec),1)/10.
backg=rfalpha < rfbeta
if iprint ne 0 then print,backg,rfalpha,rfbeta
if backg le 0 then backg=0.
w_rf(*,ispec)=w_rf(*,ispec)-backg
w_rf(0:aalpha(ispec)-1,ispec)=0. & w_rf(abeta(ispec)+1:nrfx-1,ispec)=0.
e_rf(0:aalpha(ispec)-1,ispec)=0. & e_rf(abeta(ispec)+1:nrfx-1,ispec)=0.
infzero=where(w_rf(*,ispec) lt 0.)
if infzero(0) ne -1 then begin
w_rf(infzero,ispec)=0. & e_rf(infzero,ispec)=0.
endif
if iprint ne 0 then print, w_rf(*,ispec)

; ** Normalization to unity
; ** *************************************
deltaw1=x_rf(1)-x_rf(0) & deltaw2=x_rf(nrx-1)-x_rf(nrx-2)
deltaw=x_rf(ce+1)-x_rf(ce)
diff1=abs(deltaw1-deltaw) & diff2=abs(deltaw2-deltaw)
if (diff1 gt 0.00001) or (diff2 gt 0.00001) then begin
print,"PROBLEM: non constant energy step"
print,"Deltaw1=",deltaw1," Deltaw2=",deltaw2," Deltaw=",deltaw
print,"Diff1=",diff1," Diff2=",diff2
endif
factor=total(w_rf(*,ispec))*deltaw & sfac=size(factor)
if iprint ne 0 then print,"factor=",factor," deltaw=",deltaw
w_rf(*,ispec)=w_rf(*,ispec)/factor
e_rf(*,ispec)=e_rf(*,ispec)/factor
if iprint ne 0 then print,"NEWSUM=",total(w_rf(*,ispec))*deltaw


; ** End loop on ispec
; *********************
endfor

; ** Return modified values in w_out
; ** *******************************
w_resc=w_rf
sw_result=w_rf
lmin=cel-aalpha & lmax=abeta-cel

; ** Set the text boxes relative to the x range to consider inactives
; ** ****************************************************************
widget_control,sw_tx_resmin,sensitive=0
widget_control,sw_tx_resmax,sensitive=0

; ** End of Subroutine convs
; ** ***********************
end

; ** **************************************************************
pro qens_fit, Just=just, Group=group, Tripx=tripx, tx_param
; ** **************************************************************
; ** Main body of this complete routine ... the first to be called
;
@lamp.cbk
common sc_wid
common sc_loc
common sc_flag
common sc_fit

;Factors for using measured widths for peaks
;
;resolve_routine,'treat_resf'
;resolve_routine,'convs',/IS_function
gw_fac=2.0*sqrt(2.)
lw_fac=0.5
nb_channels=0
;print,"ON Y EST ! C'est parti"
flag_pl_res=0
flag_norm=0
flag_pl_fit=0 & flag_pl_fit2=0 & flag_all=0

if keyword_set(just) then g_ctrl_panel=1 else g_ctrl_panel=0
if (!D.flags and 65536) eq 0  then print,'set_plot,"X" before using rdfilter' else  $
if (xregistered('qens_fit') le 0) then begin
    cp_nb	=0
    cp_bck	=0
    cp_pos	=0
    cp_hgt	=0
    cp_wid	=0
    cp_pf	=0
    cp_hf	=0
    cp_wf	=0
    cp_fb	=0
    cp_sb	=0
    cp_fbf	=0
    cp_sbf	=0

  g_old_plot_wid=!D.window
  P_MUS,'mus_harp'				; PLAY a tune
  g_fct_name	='Gauss' ; Default is Gauss
  g_old_pk_nb	=1	 ; old peak number
  g_afitisdone	=0	 ; No fit was done
  g_pk_nb	=1	 ; number of peak processed
  g_char	=0.8	 ;
  g_print_nb	=0	 ;
  g_show_subfct	=1	 ; if this flag is set, subfunctions are plotted
  bb1		=0	 ;l'une des bornes d'un intervalle a exclure (sert a la saisie)
  bb2		=0	 ;idem bb1
  g_nb_pk_max	=6	 ;<----change peaks maximum number
  max_nb_int	=3	 ;<----change excluded zone maximum number
  sauv		=4	 ;deplacement (dans viewarr) donnant la zone a afficher initiale
  nbzone	=3	 ;stored zones number
  no_zone	=1	 ;initializing zone number
  g_bg_but	=0	 ;fixed as background button is unset by default
  viewarr	=fltarr(8+nbzone*4)	 ;dim zone to view array
  excl_param	=fltarr(2*max_nb_int)	 ;bornes des intervalles exclus
  excl_widge	=lonarr(2*max_nb_int)	 ;widget IDs des fenetres d'affichage des bornes
  g_parameters	=fltarr(3*g_nb_pk_max+3) ;parametres position,height,width + flat,slope
  g_step	=strarr(3*g_nb_pk_max+2) ;extensions des champs pos,height,width,flat,slope
  g_error	=fltarr(3*g_nb_pk_max+2) ;erreurs sur les parametres correspondants de g_parameters
  g_fct_type	=strarr(g_nb_pk_max)
  gw_pos_pop	=lonarr(10)		 ;widget ID of pos parameter menu
  gw_int_pop	=lonarr(10)		 ;widget ID of int parameter menu
  gw_wdt_pop	=lonarr(10)		 ;widget ID of wdt parameter menu
  gw_fbg_pop	=lonarr(10)		 ;widget ID of fbg parameter menu
  gw_sbg_pop	=lonarr(10)		 ;widget ID of sbg parameter menu
  sw_ni		=[0]
  g_npeaks	=1
  g_ncycles	=2
  peaky		=0.0
  g_resid	=1.0e12

  g_fct_type(*)	=g_fct_name
  nw_ni=0 & nw_out=1
  g_tripx=1 &wdtr='0'
  str_win='W1 ' & str_wres='W2 ' & str_wou='W3 '

  ;if g_tripx then nw_ni=23 else begin
      if lamp_b1 ne 0 then p_did_getw_cur, nw_ni, wstr	; get current w number
      if nw_ni eq 0 then nw_ni=1	; if not defined then w=1
      if nw_ni gt 20 then nw_ni=1
      nw_out	=nw_ni+1
  ;endelse
  if nw_out gt 20 then nw_out=20

if n_elements(Group) eq 0 then GROUP=lamp_b1
junk		= { CW_PDMENU_S, flags:0, name:'' }

; the whole lamp size depending modifications is here
sl_size =16
if lamp_siz gt 900 then begin
    xsiz=800 & ysiz=440
endif else begin
    xsiz=700 & ysiz=280
endelse
if lamp_siz lt 800 then begin	; adapt to lamp size
    xsiz=550 & ysiz=250		; adapt plotting window size
    sl_size=15
endif
txt_hlp=  '(LEFT press=position  release=width)....(RIGHT= Define Fitting Area)'

; ** Start definition of the widget object
; ** *************************************

; ** First Base
sw_ba_leader=widget_base(group_leader=Group, /column, $
				Title='Lamp SRfit Version 1st Oct 01 (sr)',$
				resource_name='lamp' $;)
				,MBAR=m_bar)
; ** Menu Bar
sw_bu_filem=widget_button(m_bar,/menu,value='File')
sw_bu_fitm=widget_button(m_bar,/menu,value='Fitting Model')
sw_bu_savec=widget_button(sw_bu_filem,value='Save curves',uvalue=[0,0,1])
sw_bu_savep=widget_button(sw_bu_filem,value='Save parameters',uvalue=[0,0,2])
sw_bu_exitm=widget_button(sw_bu_filem,value='Exit',uvalue=[0,0,0])
sw_bu_lgm=widget_button(sw_bu_fitm,value='Lorentzian and Gaussian',uvalue=[0,1,0])
sw_bu_isorotm=widget_button(sw_bu_fitm,value='Isotropic rotation',uvalue=[0,1,1],sensitive=0)
sw_bu_axrotm=widget_button(sw_bu_fitm,value='Axial rotation',uvalue=[0,1,2],sensitive=0)
sw_bu_rwm=widget_button(sw_bu_fitm,value='Random Walk translations',uvalue=[0,1,3],sensitive=0)
sw_bu_gdos=widget_button(sw_bu_fitm,value='GDOS treatment',uvalue=[0,1,4],sensitive=0)
sw_bu_plm=widget_button(m_bar,/menu,value='Analysis')
sw_bu_plwq=widget_button(sw_bu_plm,value='Plot width',uvalue=[0,2,0])
sw_bu_plwi=widget_button(sw_bu_plm,value='Plot intewnsity',uvalue=[0,2,1])
sw_pl_eisf=widget_button(sw_bu_plm,value='Plot EISF',uvalue=[0,2,2])

; ** First up : bases
sw_ba_up=widget_base(sw_ba_leader,Title='Base row up',frame=1,/row)
sw_ba_up1=widget_base(sw_ba_up,Title='Base row up 1',/column,/align_center)
sw_ba_up2=widget_base(sw_ba_up,Title='Base row up 2',/column,/align_center)
sw_ba_up3=widget_base(sw_ba_up,Title='Base row up 3',/column,/align_center)
sw_ba_up40=widget_base(sw_ba_up,Title='Base row up 40',/row,/align_center)
sw_ba_up4=widget_base(sw_ba_up,Title='Base row up 4',/column,/align_center)
sw_ba_up11=widget_base(sw_ba_up1,Title='Base row up 11',/row,/align_center)
sw_ba_up12=widget_base(sw_ba_up1,Title='Base row up 12',/row,/align_center)
sw_ba_up21=widget_base(sw_ba_up2,Title='Base row up 21',/row,/align_center)
sw_ba_up22=widget_base(sw_ba_up2,Title='Base row up 22',/row,/align_center)
sw_ba_up31=widget_base(sw_ba_up3,Title='Base row up 31',/row,/align_center)
sw_ba_up32=widget_base(sw_ba_up3,Title='Base row up 32',/row,/align_center)
sw_ba_up41=widget_base(sw_ba_up4,Title='Base row up 41',/row,/align_center)
sw_ba_up42=widget_base(sw_ba_up4,Title='Base row up 42',/row,/align_center)
; ** First up : button, labels and texts
sw_bu_gwin=widget_button(sw_ba_up11,Font=ft_b_smaller,Frame=2,value='Get W_in',uvalue=[1,1,0],/align_center)
sw_bu_gres=widget_button(sw_ba_up21,Font=ft_b_smaller,Frame=2,value='Get Res_fun',uvalue=[1,2,0],/align_center,sensitive=0)
sw_bu_wwou=widget_button(sw_ba_up31,Font=ft_b_smaller,Frame=2,value='Write W_out',uvalue=[1,3,0],/align_center,sensitive=0)
sw_bu_winb=widget_button(sw_ba_up12,Font=ft_smaller,Frame=2,value='<<',uvalue=[2,1,1],/align_center)
sw_la_win=widget_label(sw_ba_up12,Font=ft_b_smaller,Frame=2,value=str_win,uvalue=[2,1,2],/align_center)
sw_bu_winf=widget_button(sw_ba_up12,Font=ft_smaller,Frame=2,value='>>',uvalue=[2,1,3],/align_center)
sw_bu_resb=widget_button(sw_ba_up22,Font=ft_smaller,Frame=2,value='<<',uvalue=[2,2,1],/align_center)
sw_la_res=widget_label(sw_ba_up22,Font=ft_b_smaller,Frame=2,value=str_wres,uvalue=[2,2,2],/align_center)
sw_bu_resf=widget_button(sw_ba_up22,Font=ft_smaller,Frame=2,value='>>',uvalue=[2,2,3],/align_center)
sw_bu_woub=widget_button(sw_ba_up32,Font=ft_smaller,Frame=2,value='<<',uvalue=[2,3,1],/align_center)
sw_la_wou=widget_label(sw_ba_up32,Font=ft_b_smaller,Frame=2,value=str_wou,uvalue=[2,3,2],/align_center)
sw_bu_rouf=widget_button(sw_ba_up32,Font=ft_smaller,Frame=2,value='>>',uvalue=[2,3,3],/align_center)
sw_la_reslim=widget_label(sw_ba_up40,Font=ft_smaller,value='Give limits for Res. fun.:',/align_center)
sw_la_resmin=widget_label(sw_ba_up41,Font=ft_smaller,value='xmin=  ',/align_center)
sw_la_resmax=widget_label(sw_ba_up42,Font=ft_smaller,value='xmax=  ',/align_center)
sw_tx_resmin=widget_text(sw_ba_up41,Font=ft_smaller,/editable,xsize=3,value='-1',/align_center)
sw_tx_resmax=widget_text(sw_ba_up42,Font=ft_smaller,/editable,xsize=3,value=' 1',/align_center)
sw_la_mev=widget_label(sw_ba_up41,Font=ft_smaller,value='  meV/mmeV',/align_center)
sw_la_mev=widget_label(sw_ba_up42,Font=ft_smaller,value='  meV/mmeV',/align_center)

; ** Second mid : bases
sw_ba_mid=widget_base(sw_ba_leader,Title='Base row mid',frame=1,/row)
sw_ba_mid1=widget_base(sw_ba_mid,Title='Base row mid 1',/column)
sw_ba_mid2=widget_base(sw_ba_mid,Title='Base row mid 2',/column)

;sw_ba_mid3=widget_base(sw_ba_mid,Title='Base row mid 3',/column)

sw_ba_mid11=widget_base(sw_ba_mid1,Title='Base row mid 11',/column,frame=1)
sw_ba_mid12=widget_base(sw_ba_mid1,Title='Base row mid 12',/column,frame=1)
sw_ba_mid13=widget_base(sw_ba_mid1,Title='Base row mid 13',/column,frame=1)

sw_ba_mid11up=widget_base(sw_ba_mid11,Title='Base row mid 11up',/row)
sw_ba_mid11bot=widget_base(sw_ba_mid11,Title='Base row mid 11bot',/row)
sw_ba_mid12up=widget_base(sw_ba_mid12,Title='Base row mid 12up',/row)
sw_ba_mid12bot=widget_base(sw_ba_mid12,Title='Base row mid 12bot',/row,/nonexclusive)


;sw_ba_mid14=widget_base(sw_ba_mid1,Title='Base row mid 14',/row)
;sw_ba_mid15=widget_base(sw_ba_mid1,Title='Base row mid 15',/row)

; ** Second mid : button, labels and txtboxes
sw_la_xrange=widget_label(sw_ba_mid11up,Font=ft_b_smaller,value='X range:')
sw_tx_xmin=widget_text(sw_ba_mid11up,Font=ft_b_smaller,/editable,value='min',xsize=5,uvalue=[3,1,1])
sw_tx_xmax=widget_text(sw_ba_mid11up,Font=ft_b_smaller,/editable,value='max',xsize=5,uvalue=[3,1,2])
sw_la_yrange=widget_label(sw_ba_mid11bot,Font=ft_b_smaller,value='Y range:')
sw_tx_ymin=widget_text(sw_ba_mid11bot,Font=ft_b_smaller,/editable,value='min',xsize=5,uvalue=[3,1,3])
sw_tx_ymax=widget_text(sw_ba_mid11bot,Font=ft_b_smaller,/editable,value='max',xsize=5,uvalue=[3,1,4])

sw_la_wsub=widget_label(sw_ba_mid12up,Font=ft_b_smaller,value='Sp_#') & blabla=widget_label(sw_ba_mid12up,Font=ft_b_smaller,value='',xsize=15)
sw_tx_wsub=widget_text(sw_ba_mid12up,Font=ft_b_smaller,/editable,value=' 1',xsize=3,uvalue=[3,1,5]) & sw_tx_fwsub=sw_tx_wsub
blabla=widget_label(sw_ba_mid12up,Font=ft_b_smaller,value='',xsize=15)
sw_bu_plot=widget_button(sw_ba_mid12up,Font=ft_b_smaller,frame=4,value="Accept!",uvalue=[3,2,1],sensitive=0)

sw_bu_plre=widget_button(sw_ba_mid12bot,value="Res. Func.",uvalue=[3,2,2])
sw_bu_norm=widget_button(sw_ba_mid12bot,value="Norm.?",uvalue=[3,2,3])

; ** **********************************************************************************************
; ** Second up : button, labels and text boxes
;
sw_la_sdl=widget_label(sw_ba_mid13,Font=ft_b_smaller,value='** Fitting Range: **')
sw_ba_mid13up=widget_base(sw_ba_mid13,Title='Base row mid 13up',/row)
sw_ba_mid13bot=widget_base(sw_ba_mid13,Title='Base row mid 13bot',/row)
sw_bu_done=widget_button(sw_ba_mid13,Font=ft_b_smaller,Frame=1,value='Done',uvalue=[6,2,0],sensitive=0)

sw_la_xrange=widget_label(sw_ba_mid13up,Font=ft_b_smaller,value='X range:')
sw_tx_fxmin=widget_text(sw_ba_mid13up,/editable,value='min',xsize=5,uvalue=[6,0,2])
sw_tx_fxmax=widget_text(sw_ba_mid13up,/editable,value='max',xsize=5,uvalue=[6,0,3])
sw_bu_fit=widget_button(sw_ba_mid13bot,Font=ft_b_smaller,Frame=2,value='   FIT !   ',uvalue=[6,0,1],sensitive=0)
sw_tx_cycl=widget_text(sw_ba_mid13bot,Font=ft_b_smaller,/editable,value=' 5',xsize=3,uvalue=[6,0,5])
sw_la_cycl=widget_label(sw_ba_mid13bot,Font=ft_b_smaller,value='Cycles')

; ** *********************************************************************************************
; ** Second mid : graph
sw_pl_area=widget_draw(sw_ba_mid2,/Button_Events,Frame=5,Retain=2,uvalue=[3,3,1],Colors=-8, $
					   XSize=3*xsiz/4,YSize=9*ysiz/16)
sw_pl_areabot=widget_draw(sw_ba_mid2,/Button_Events,Frame=5,Retain=2,uvalue=[3,3,2],Colors=-8, $
					   XSize=3*xsiz/4,YSize=3*ysiz/16)
szsl=0 & str=''
if sys_dep('VERSION') ge 4.0 then ii=execute('str=widget_info(peak_menu2,/geometry) & szsl=str.xsize')
bid=sys_dep('DYNLAB', sw_ba_leader, 1)

;widget_control, bad_id=i, sw_ba_leader, /Realize & put_logo

; ** Realization of the Base
widget_control, sw_ba_leader, /Realize; & put_logo
xmanager,'qens_fit',sw_ba_leader,/just_reg

; ** Get the window Id for the plotting area and store it in s_pl_wid
widget_control, bad_id=i, sw_pl_area, get_value=s_pl_wid 	; Store the number assigned to this window in s_pl_wid
wset,s_pl_wid											; Set the s_pl_wid active

; ** Get the window Id for the plotting area #2 and store it in s_pl_widbot
widget_control, bad_id=i, sw_pl_areabot, get_value=s_pl_widbot 	; Store the number assigned to this window in s_pl_wid
wset,s_pl_widbot											; Set the s_pl_wid active


endif
; Get drawable window index
;widget_control, bad_id=i, gw_plot_area, get_value=g_plot_wid
;wset,g_plot_wid

;if lamp_b1 gt 0 then xmanager, 'qens_fit', sw_ba_leader, /just_reg $
;else g_char=0.4

;if lamp_b1 le 0 then xmanager, 'qens_fit', sw_ba_leader

end
function qens_treat,w_in,emin=emin,emax=emax,de=de,arm=arm
;** **********************************************
;** S. Rols 11/01 srols@anl.gov
;** The call is w_out=qens_treat(w_in)
;** Treatment of the QENS (IPNS) data involving
;** -tof 2 nrj transformation and ki/kf correction
;** -arms grouping
;** -monitor normalization
;** **********************************************

common c_lamp_access, inst
common printing, iprint, outstring

take_datp, datp
par=datp.p
D_sd=datp.pv
D_mon_s=par(17) ;moderator to monitor distance

;** First of all check the energy range and increment
;** *************************************************

if (emin lt -2.5) then begin
print, 'QENS: Give an emin value -2.5 meV < emin < 0 meV'
w_out=w_in
goto, endret
endif else if (emax gt 200) then begin
print, 'QENS: Give an emax value 0 meV < emax < 200 meV'
w_out=w_in
goto, endret
endif else if (emin ge emax) then begin
print, 'QENS: emin should be < to emax !!!'
w_out=w_in
goto, endret
endif else if (n_elements(de) ne 0) then begin
if (de(0) le 0.005) then begin
print, 'QENS: problem ... de too small.// Typical values for de are 0.015 for quasielastic ([-1.5,5 meV]) or 0.1 for DOS ([-3,50meV]).)'
w_out=w_in
goto, endret
endif
endif

;** Donnees experimentales
;** ************************************************

x_in=datp.x
y_in=datp.y
e_in=datp.e
mon=datp.n
teta=y_in
iprint=0
n_channels=n_elements(x_in)
n_spectra=n_elements(D_sd)

;** Calcul of the scattered energy for each detector
;** ************************************************

D_md=8.04+D_sd ;moderator to detector distance in meter
D_ms=8.04 ;moderator to sample distance in meter
D_mm=D_ms-D_mon_s
ch_width=par(14)   ; channel width in microsecond for detectors
ch_width_mon=par(16)   ; channel width in microsecond for monitor
c_el=D_md*0.
T_md=(x_in-1)*ch_width+2000 ; tof for channels in microseconds
alpha=5.2267*1e6 ;E to v conversion factor

if iprint eq 0 then print,n_spectra,ch_width,D_mm,'n_spectra,ch_width,D_mod_mon'

for ispec=0,n_spectra-1 do begin
if iprint ne 0 then print,"Spectrum #",ispec
ce=where(w_in(*,ispec) eq max(w_in(*,ispec)))
if (n_elements(ce) le 3 and fix(total(ce)/n_elements(ce)) le 1300 and fix(total(ce)/n_elements(ce)) ge 600) then c_el(ispec)=x_in(fix(total(ce)/n_elements(ce))) else begin
print,'Elastic channel of Spectrum #',ispec+1,' has pb ... removed'
c_el(ispec)=0
endelse
endfor

;** we now remove the bad detectors
index_remo=where(c_el ne 0) ;indices of the spectra to be removed
n_spectra=n_elements(index_remo) ;new dimension of the arrays
w_buf_1=fltarr(n_channels,n_spectra) & w_buf_1=w_in(*,index_remo) ;intensities modifications
e_in_buf_1=fltarr(n_channels,n_spectra) & e_in_buf_1=e_in(*,index_remo) ;intensities errors modifications
c_el=c_el(index_remo) ;elastic channel array modification
D_md=D_md(index_remo) & D_sd=D_sd(index_remo) & y_out=y_in(index_remo) ;distances and angles arrays modifications
;** we now calculate the scattered energy and the elastic time of flight
T_md_el=c_el*ch_width+2000
e_d=alpha*(D_md/T_md_el)^2 & v_d=D_md/T_md_el ;scattered energy in meV and scattered celerity in m/us
e_i=fltarr(n_channels,n_spectra) & homega=e_i

;** Calculation of the incident energy ... the first channels are non-physical, and correspond
;** to a negative flight path distance ... we should not take them into account ... but for the moment, it
;** is simpler to take them and then reduce our energy range to reasonnable values.
for ispec=0,n_spectra-1 do begin
if ispec ne 2 then begin
e_i(*,ispec)=alpha*((D_ms*v_d(ispec))/(v_d(ispec)*T_md(*)-D_sd(ispec)))^2	;incident energy in meV
homega(*,ispec)=e_i(*,ispec)-e_d(ispec)
endif
endfor

;** The only spectrum# for which the value of v_d(ispec)*T_md(*)-D_sd(ispec)=0 is the spectrum ispec=2
;** for the 73rd channel. We gonna give it a slighly larger (non-0) value ... not perfect but it works
for ichan=0,n_channels-1 do begin
if ichan ne 73 then e_i(ichan,2)=alpha*((D_ms*v_d(2))/(v_d(2)*T_md(ichan)-D_sd(2)))^2	$
else e_i(ichan,2)=alpha*((D_ms*v_d(2))/(1.e-6))^2
homega(ichan,2)=e_i(ichan,2)-e_d(2)
endfor
if iprint ne 0 then print,e_d

;
;** Transformation from tof to energy
;** ************************************************
;1/ create the desired energy grid first
if (n_elements(de) eq 0) then begin
print,"QENS: Will interpol spectra to nrj grid defined by detector #1"
x_out=reverse(homega(*,0)) & x_out=x_out(where(x_out le emax and x_out ge emin))
nx_points=n_elements(x_out)-1
endif else begin
print,"QENS: Will interpol spectra to nrj grid defined user"
if (de(0) le 0.005) then begin
de=0.02
print,"QENS: Value of de too small ... put it to 0.02"
endif
nx_points=fix(abs(emax-emin)/abs(de))
x_out=emin+findgen(nx_points+1)*abs(de)
endelse
w_buf=fltarr(nx_points+1,n_spectra) & e_out=w_buf

;2/ Do the t2e transformation next for each detector

for ispec=0,n_spectra-1 do begin
homega_buf=homega(*,ispec) & e_i_buf=e_i(*,ispec)
homega_buf_2=homega_buf(where(homega_buf le emax and homega_buf ge emin)) & homega_buf_2=reverse(homega_buf_2)
e_i_buf_2=e_i_buf(where(homega_buf le emax and homega_buf ge emin)) & e_i_buf_2=reverse(e_i_buf_2)

; No remove a constant flat background determined by the min of the 10 first and 10 last channels.

i_buf=w_buf_1(*,ispec)
ra=total(i_buf(0:9))/10. & rb=total(i_buf(n_elements(i_buf)-10:n_elements(i_buf)-1))/10.
backg=ra < rb
if backg le 0 then backg=0.
w_buf_1(*,ispec)=w_buf_1(*,ispec)-backg
infzero=where(w_buf_1(*,ispec) LT 0.)
if infzero(0) ne -1 then w_buf_1(infzero,ispec)=0.

i_buf=w_buf_1(where(homega_buf le emax and homega_buf ge emin),ispec) & i_buf=reverse(i_buf)
i_buf_b=interpol(i_buf,homega_buf_2,x_out) & fact=interpol(e_i_buf_2,homega_buf_2,x_out)
infzero=where(fact le 0.)
if infzero(0) ne -1 then print,"Probem in fact calculation"
;i_buf_b=spline(homega_buf_2,i_buf,x_out) & fact=spline(homega_buf_2,e_i_buf_2,x_out)
;i_buf_b(where(i_buf_b) lt 0.)=0.

;3/ Now do the dt/dw correction (jacobian factor)

i_buf_b=i_buf_b*D_ms*sqrt(alpha)*0.5/(abs(fact)^(3/2))
e_in_buf=abs(i_buf_b)*D_ms*sqrt(alpha)*0.5/(abs(fact)^(3/2)) & indd=where(e_in_buf lt 0)
if indd(0) ge 0 then begin
print,'Probleme error inf eq 0'
stop
e_in_buf(indd)=0.
endif

;4/ Now do the kd/ki correction factor

if e_d(ispec) le 0. then print,"Probem in e_d ... in or eq 0"
fact=sqrt(abs((x_out+e_d(ispec))/(e_d(ispec))))
i_buf_b=i_buf_b*fact & e_in_buf=e_in_buf*fact

;5/ Loading into convenient workspaces

w_buf(*,ispec)=i_buf_b(*)
e_out(*,ispec)=sqrt(e_in_buf(*))

endfor

e_i_grid=fltarr(n_elements(x_out),n_spectra)
for ispec=0,n_spectra-1 do e_i_grid(*,ispec)=x_out(*)+e_d(ispec)

;** Now do the monitor normalization
;** *****************************************************

n_channels_mon=n_elements(mon)
tof_mon=600+findgen(n_channels_mon)*ch_width_mon
e_in_mon=alpha*((D_mm)/tof_mon)^2
infzero=where(e_in_mon le 0.)
if infzero(0) ne -1 then print,"problem in monitor normalization 1"
mon_buf=mon*D_mm*sqrt(alpha)*0.5/(e_in_mon^(3/2))

for ispec=0,n_spectra-1 do begin
e_in_mon_2=e_in_mon(where(e_in_mon le e_i_grid(n_elements(x_out)-1,ispec) and e_in_mon ge e_i_grid(0,ispec)))
mon_buf_2=mon_buf(where(e_in_mon le e_i_grid(n_elements(x_out)-1,ispec) and e_in_mon ge e_i_grid(0,ispec)))
YY=reverse(mon_buf_2) & XX=reverse(e_in_mon_2)
TT=fltarr(n_elements(x_out)) & TT=e_i_grid(*,ispec)
;mon_splined=spline(XX,YY,TT)
mon_splined=interpol(YY,XX,TT)
nfzero=where(mon_splined le 0.)
if infzero(0) ne -1 then print,"problem in monitor normalization 2"
w_buf(*,ispec)=1000.*w_buf(*,ispec)/mon_splined(*)
e_out(*,ispec)=1000.*e_out(*,ispec)/mon_splined(*)
endfor

;** Now do the Arm Grouping if required
;** *****************************************************

if ((n_elements(arm) eq 0) or (arm(0) eq 1)) then begin
print,"QENS: Grouping spectra by arms"
count=n_spectra & ngroup=0
ntot=0.
group=0.
while ntot ne n_spectra do begin
ang=y_out(ntot)
ind=where(y_out eq ang,count)
ntot=ntot+count
ngroup=ngroup+1
group=[group,ind(0),ind(n_elements(ind)-1),ang]
endwhile
group=group(1:n_elements(group)-1) & group=reform(group,3,ngroup)
w_buf_g=fltarr(n_elements(x_out),ngroup) & y_out_g=fltarr(ngroup) & e_out_g=w_buf_g
for ig=0,ngroup-1 do begin
imin=group(0,ig) & imax=group(1,ig) & y_out_g(ig)=group(2,ig)
w_buf_g(*,ig)=total(w_buf(*,imin:imax),2)/(imax-imin+1)
e_out_g(*,ig)=sqrt(total((e_out(*,imin:imax))^2,2))/(imax-imin+1)
endfor
w_buf=w_buf_g
e_out=e_out_g
y_out=y_out_g
endif

;** We return the workspace and modify the datp structure
;** *****************************************************

w_out=w_buf

mod_datp, datp, "e", e_out
mod_datp, datp, "x", x_out
mod_datp, datp, "y", y_out
mod_datp, datp, "pv", D_sd
mod_datp, datp, "x_tit", "Energy transfer (meV)"
give_datp, datp

endret: return, w_out

;** End of program
;** *****************************************************
end
pro qs,w,minl,th,pmin,pmax,sizex,sizez,file
common data,w8,x8,y8
print,'readback',nn,th,pmin,pmax,sizex,sizez,file
close,3
y=size(w)
print,y
TAKE_DATP,P
help,p
if (y(0) eq 3) then begin
   print,y
   
   xsize=y(1)
   ysize=y(2)
   tsize=y(3)

   print,'Three dimensions x,y,t =',xsize,ysize,tsize
   print,'Will sum over the y dimension'
   ww=lonarr(xsize,tsize)
   ww=total(w,2)
   
   
endif else begin
   
   tsize=y(2)
   xsize=y(1)
   print,'Two dimensions x,t =',xsize,tsize
   ww=lonarr(xsize,tsize)
   ww=w
      
endelse

print,'hello world'
print,'no of chans= ',p.p(1),' chan width= ',p.p(6),' tof delay= ',p.p(7)
print,'x1= ',p.p(2),' x2= ',p.p(3),' y1= ',p.p(4),' y2= ',p.p(5)
nx=p.p(8)
ny=p.p(9)
print,'nx= ',nx,' ny= ',ny
print,'chop 1 speed req= ',p.p(10),' chop 1 phase req= ',p.p(11)
print,'chop 2 speed req= ',p.p(12),' chop 2 phase req= ',p.p(13)
print,'chop 1 speed act= ',p.p(14),' chop 1 phase act= ',p.p(15)
print,'chop 2 speed act= ',p.p(16),' chop 2 phase act= ',p.p(17)

; useful chopper variables
openr=45.-(p.p(13)-p.p(11))
opena=45.-(p.p(17)-p.p(15))
opena=opena-1.1
period=60./p.p(14)
dela=(285.-opena-3.3776)/2.
delt=(dela/360.)*period
chopsam=4.1135-(85.e-3)/2.
tofd=chopsam+(p.p(23)/1000.)
chanpa=(tofd/3956.)/(p.p(6)*1e-6)
chanpam=(chopsam/3956.)/(p.p(6)*1e-6)
delchan=delt/(p.p(6)*1e-6)
delechan=p.p(7)/p.p(6)
print,'TOF distance    = ',tofd, ' period chans    =',period/(p.p(6)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
print,'san= ',p.p(24),' deg.','dan= ',p.p(25),' deg.'
san=p.p(24)
dan=p.p(25)
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa
time=p.p(26)/10.
print,'run time= ',time,' s',' det= ',p.p(23)
det=p.p(23)


print,'well done chaps...'
;make lambda array
yy=indgen(tsize)
;larr=(yy+delechan-delchan)/chanpa
larr=(yy)/chanpa
m=(yy+delechan-delchan)/chanpam



lfirst=(delchan-delechan+0.5)
print,'channel shift = ',lfirst

; loose nn channels at the beginning to avoid infinities in reciprocal space

;nn=1
aa=shift(ww,1,-round(lfirst))

neww1=aa(*,nn:tsize-1)
newlarr=larr(nn:tsize-1)

q=fltarr(xsize,tsize-nn)
th=fltarr(xsize,tsize-nn)
qx=fltarr(xsize,tsize-nn)
qz=fltarr(xsize,tsize-nn)

 

;  conversion to reciprocal space

dpr=180./!pi

pcen=135.79/nx
mmpp=1.04*nx
;pmin=150./nx
;pmax=233./nx


print,'pcen= ',pcen,' mmpp= ',mmpp
print,'ref th= ',(dr+dpr*atan((pcen-pr)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
lmax=max(newlarr)
lmin=min(newlarr)

;expt information d0=dan for diect beam p0=pixel for direct beam
;dr=dan for reflection pr=pixel for reflection



;find limits in reciprocal space

for i=pmin,pmax do begin
  for j=0,tsize-nn-1 do begin
  
;   l=newlarr(j)
   th(i,j)=(dr+dpr*atan((pcen-i)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2.0
   h1=th(i,j)
   h2=(h1-san)/dpr
   q(i,j)=4*!pi*sin(h1/dpr)/newlarr(j)
   h3=q(i,j)
   qx(i,j)=h3*sin(h2)
   qz(i,j)=h3*cos(h2)

;   l=newlarr(j)
;   th(i,j)=(dr+dpr*atan((pcen-i)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
;   q(i,j)=4*!pi*sin(th(i,j)/dpr)/newlarr(j)
;   qx(i,j)=q(i,j)*sin((th(i,j)-san)/dpr)
;   qz(i,j)=q(i,j)*cos((th(i,j)-san)/dpr)

  
   endfor
 endfor

   
  
   print,'limits....'
   print,'thmax= ',max(th),'thmin= ',min(th),'qmin= ',min(q),'qmax= ',max(q)
   print,'qxmax= ',max(qx),'qxmin= ',min(qx),'qzmax= ',max(qz),'qzmin= ',min(qz)



;nfac=1
;sizex=120.*nfac
;sizez=300.*nfac
print,min(qx),max(qx),min(qz),max(qz),sizex,sizez

gs=[(max(qx)*1.001-min(qx))/sizex,(max(qz)*1.001-min(qz))/sizez]

print,gs(0),gs(1),max(qz)/gs(1)

;**********************
;  nicks bit

;  bin neww1 into a square array qx qz of size sizex X sizez


x8=indgen(sizex)*(max(qx)-min(qx))/(sizex)+min(qx)
y8=indgen(sizez)*(max(qz)-min(qz))/(sizez)+min(qz)

xpixelsize=gs(0)
zpixelsize=gs(1)


print,tsize-nn
w8=fltarr(sizex,sizez)


; loop about output array w9
;for i=0,sizex-1 do begin
;	for j=0,sizez-1 do begin
;		w8(i,j)=0
;	endfor
;endfor	


minz=min(qz)
minx=min(qx)
;      loop about input array neww1
          for k=0,xsize-1 do begin
;             print,k,xsize-1

               
;		i=floor((qx(k,*)-min(qx))/xpixelsize)
;               j=floor((qz(k,*)-min(qz))/zpixelsize)

		i=floor((qx(k,*)-minx)/xpixelsize)
                j=floor((qz(k,*)-minz)/zpixelsize)
              
		w8(i,j)=w8(i,j)+neww1(k,*)

          endfor



print,'done'



;*********************




return

end
pro qit_event,event
;** ************
;**
        common data,w8,x8,y8
	COMMON local,nparams,whatwid
	con='x'
	par1=fltarr(2)
        par2=intarr(4)
	par3=strarr(1)
      	wWidget =  Event.top

        WIDGET_CONTROL,event.id,get_uvalue=gv

        if(gv eq 'quit')then widget_control,event.top,/destroy

        if(gv eq 'do')then begin
	FOR i=0,nparams-1 DO BEGIN
          Widget_Control, whatwid(i), GET_VALUE=gv
;	  print,i,gv
	  if(i le 1) then  par1(i)=STRTRIM(gv,2)
	  if(i gt 1 and lt 6) then  par2(i)=STRTRIM(gv,2)
	  if(i eq 6) then par3(i)=STRTRIM(gv,2)
        ENDFOR
	print,par1,par2,par3

	qs,par1(0),par1(1),par2(0),par2(1),par2(2),par2(3),par3(0)


	
	Widget_Control, whatwid(nparams-2), SET_VALUE=strtrim(string(totalp),2)
	
	if (par2(3) eq 0)then begin
	  Widget_Control, whatwid(nparams-1), SET_VALUE=strtrim(string(floor(totalt*3600.)),2)
	endif
	
	if (par2(3) eq 1)then begin
	  Widget_Control, whatwid(nparams-1), SET_VALUE=strtrim(string(totalh),2)+' h'$
	  +strtrim(string(totalm),2)+' m'
	endif
	
endif	
end





pro send_command,event,i
;** ************
;**
	Widget_Control, event.id, GET_VALUE=gv
	gv=STRTRIM(gv,2)
	command=fix(gv)
;	  
;	print, gv
;
end

PRO qit,w8,x8,y8
COMMON local,nparams,whatwid
common data,w8,x8,y8
nparams=7
whatwid=intarr(nparams)

param=strarr(nparams)
                param_text=STRARR(nparams)
		param_text(0) ='Theta (deg.)'
		param_text(1) ='Minimum wavelength (A)'
		param_text(2) ='Minimum x-pixel'
		param_text(3) ='Maximum x-pixel'
		param_text(4) ='Number of qx pixels'
		param_text(5) ='Number of qz pixels'
		
		param_text(6) ='Output filename'
		
		
;               defaults
                		
		param(0)='2.2'
		param(1)='0.7'
		param(2)='150'
		param(3)='250'
		param(4)='150'
		param(5)='300'
		param(6)='qspace.dat'
		
		
		
		
		
                D17S_BASE_4=Widget_Base(UNAME='D17S_BASE_4',TITLE="Enter Values" $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
		D17S_BASE_0=Widget_Base(D17S_BASE_4,UNAME='D17S_BASE_0' $
			,SPACE=3,XPAD=3,YPAD=3,/ROW)
		D17S_BASE_1=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_1' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)




		D17S_BASE_2=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_2' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
		D17S_BASE_3=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_3' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)

                gbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='gbutton' $
			, value='Do it',uvalue='do')
		fbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='fbutton' $
			, value='Quit',uvalue='quit')
			
		
				
			
		FOR i=0,nparams-1 DO BEGIN 
  			name= 'D17S_LABEL_'+STRTRIM(STRING(i+1),2) 
  			dummy = Widget_Label(D17S_BASE_2, UNAME=name,XOFFSET=3   $ 
     	 		,YOFFSET=3, SCR_YSIZE=33,/ALIGN_LEFT ,VALUE=param_text(i) $
			,FONT=ft_smaller)
  	  	ENDFOR
		

		
		FOR i=0,nparams-1 DO BEGIN 
  			name='D17S_VALUE_'+STRTRIM(STRING(i+1),2) 
  			 whatwid(i)= Widget_Text(D17S_BASE_3, UNAME=name ,FRAME=1  $ 
     			,XOFFSET=3 ,YOFFSET=3 ,SCR_XSIZE=100 ,SCR_YSIZE=29 $
			,/EDITABLE ,VALUE=STRTRIM(STRING(param(i)),2) $
			,FONT=ft_smaller) 
  	  	ENDFOR


		Widget_Control,/REALIZE,D17S_BASE_3
		loadct, 5
		XMANAGER, 'startmono',D17S_BASE_0,/JUST_REG

end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION qrebin, w_in, omegashift=omegashift, fold=fold, $
	                 nQ=nQ, oms

;For D7 data only
;
;takes output workspace of omega_scan.pro containing omega-scan, converts to
;Q-space and rebins to a constant Qx-Qy grid in a single quadrant, giving 
;sensible error bars! Deals with only one spin phase.
;
;ARGUMENTS:
; omegashift	: offset in degrees of omega=0 position
; (oms is obsolete, kept for backwards compatability)
;
;KEYWORDS:
; fold		: folds quadrants into +,+
;
;DIMENSIONS:
; w_in(nspectra,nruns)	-> w_out(nQ,nQ) (folded), w_out(2*nQ,2*nQ) (unfolded)
;
;COMMAND SYNTAX:
; w10=qrebin(w9,[nQ=<nQ>][,omegashift=<omegashift>][,/fold])
;						KHA,JRS 31/3/01
;-------------------------------------------------------------------------------
;*******************************************************************************

	take_datp, datp

	iprint=0	; if iprint>0, show debugging messages

	fld=1		; don't fold data (default)
	IF(N_ELEMENTS(oms) GT 0) THEN omegashift=oms
	IF KEYWORD_SET(fold) THEN fld=0

;-------------------------------------------------------------------------------
;Set constants

	par=datp.p
	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nruns=FIX(par(3))
	lambda=par(4)
	k=2.*!pi/lambda

	IF (iprint GT 0) THEN PRINT,'End of "set constants" section'

;-------------------------------------------------------------------------------
;Set up arrays

	ntheta=nspectra
	nomega=nruns

	e_in=datp.e

	phi=-datp.x		; detector angle: anticlockwise is +ve
	IF (N_ELEMENTS(omegashift) EQ 0) THEN omegashift=0.
	omega=-datp.y+omegashift	; sample rotation angle

	theta=FLTARR(ntheta)
	FOR itheta=0,ntheta-1 DO $
		IF (phi(itheta) LE 0.) THEN $
			theta(itheta)=phi(itheta)/2.+90. $
		ELSE theta(itheta)=phi(itheta)/2.-90.

	Qmag=k*SQRT(2.*(1.-COS(phi*!pi/180.)))

	Qx=FLTARR(ntheta,nomega)
	Qy=FLTARR(ntheta,nomega)
	FOR iomega=0,nomega-1 DO BEGIN
		Qx(*,iomega)=Qmag*COS((theta-omega(iomega))*!pi/180.)
		Qy(*,iomega)=Qmag*SIN((theta-omega(iomega))*!pi/180.)
	ENDFOR

	IF (lambda GT 4.5) THEN BEGIN
		IF(N_ELEMENTS(nQ) EQ 0) THEN BEGIN
			nQ=26
			dQ=0.1
		ENDIF ELSE BEGIN
			dQ=2.6/FLOAT(nQ)
		ENDELSE
	ENDIF ELSE BEGIN
		IF(N_ELEMENTS(nQ) EQ 0) THEN BEGIN
			nQ=21
			dQ=0.2
		ENDIF ELSE BEGIN
			dQ=4.2/FLOAT(nQ)
		ENDELSE
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'omega=',omega
	IF (iprint GT 0) THEN FOR itheta=0,ntheta-1 DO $
		PRINT,'itheta=',itheta,' phi=',phi(itheta), $
		' theta=',theta(itheta),' Qmag=',Qmag(itheta)
	IF (iprint GT 0) THEN PRINT,'End of "Set up arrays" section'

;-------------------------------------------------------------------------------
;Rebin data

	w_out=FLTARR((fld+1)*nQ,(fld+1)*nQ)	& w_out(*,*)=0.
	e_out=FLTARR((fld+1)*nQ,(fld+1)*nQ)	& e_out(*,*)=0.
	n_out=FLTARR((fld+1)*nQ,(fld+1)*nQ)	& n_out(*,*)=0.

	FOR itheta=0,ntheta-1 DO BEGIN
		FOR iomega=0,nomega-1 DO BEGIN
			IF (fld EQ 1) THEN BEGIN
				ix=FIX(((Qx(itheta,iomega)+dQ/2.)/dQ)+nQ)
				iy=FIX(((Qy(itheta,iomega)+dQ/2.)/dQ)+nQ)
			ENDIF ELSE BEGIN
				ix=FIX(ABS((Qx(itheta,iomega))+dQ/2.)/dQ)
				iy=FIX(ABS((Qy(itheta,iomega))+dQ/2.)/dQ)
			ENDELSE
			w_out(ix,iy)=w_out(ix,iy)+w_in(itheta,iomega)
			e_out(ix,iy)=e_out(ix,iy)+e_in(itheta,iomega)^2
			n_out(ix,iy)=n_out(ix,iy)+1.
		ENDFOR
	ENDFOR

	FOR ix=0,(fld+1)*nQ-1 DO BEGIN
		FOR iy=0,(fld+1)*nQ-1 DO BEGIN
			IF (n_out(ix,iy) GT 0.) THEN BEGIN
				w_out(ix,iy)=w_out(ix,iy)/n_out(ix,iy)
				e_out(ix,iy)=SQRT(e_out(ix,iy))/n_out(ix,iy)
			ENDIF ELSE BEGIN
				w_out(ix,iy)=0.
				e_out(ix,iy)=-1.
			ENDELSE
		ENDFOR
	ENDFOR

	x_out=FLOAT((INDGEN((fld+1)*nQ)-(fld*nQ))*dQ)	& y_out=x_out

	IF (iprint GT 0) THEN PRINT,'End of "rebin data" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "x", x_out
	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	datp.x_tit='Qx'
	datp.y_tit='Qy'

	d=STRTRIM(STRING(dQ),2)
tryd:	n=STRLEN(d)	& i=RSTRPOS(d,'0')
	IF (i EQ n-1) THEN BEGIN
		d=STRMID(d,0,n-1)
		GOTO, tryd
	ENDIF
	s=STRTRIM(STRING(omegashift),2)
trys:	n=STRLEN(s)	& i=RSTRPOS(s,'0')
	IF (i EQ n-1) THEN BEGIN
		s=STRMID(s,0,n-1)
		GOTO, trys
	ENDIF
	PRINT,'Qrebin: rebinned to Qx-Qy grid with dQ='+d+'A-1 and omega-shift='+s+'degrees'
	datp.other_tit=datp.other_tit+' -qr('+d+','+s
	IF(fld=0) THEN datp.other_tit=datp.other_tit+',/fold)' ELSE $
		       datp.other_tit=datp.other_tit+')'

finished:
	give_datp, datp

	RETURN, w_out
	END
pro qspace,w,nn,d0,p0,dr,pr,neww1,qx,qz,res,x8,y8
print,'readback',nn,d0,p0,dr,pr
close,3
y=size(w)
print,y
TAKE_DATP,P

if (y(0) eq 3) then begin
   print,y
   
   xsize=y(1)
   ysize=y(2)
   tsize=y(3)

   print,'Three dimensions x,y,t =',xsize,ysize,tsize
   print,'Will sum over the y dimension'
   ww=lonarr(xsize,tsize)
   ww=total(w,2)
   
   
endif else begin
   
   tsize=y(2)
   xsize=y(1)
   print,'Two dimensions x,t =',xsize,tsize
   ww=lonarr(xsize,tsize)
   ww=w
      
endelse


print,'no of chans= ',p.p(1),' chan width= ',p.p(6),' tof delay= ',p.p(7)
print,'x1= ',p.p(2),' x2= ',p.p(3),' y1= ',p.p(4),' y2= ',p.p(5)
nx=p.p(8)
ny=p.p(9)
print,'nx= ',nx,' ny= ',ny
print,'chop 1 speed req= ',p.p(10),' chop 1 phase req= ',p.p(11)
print,'chop 2 speed req= ',p.p(12),' chop 2 phase req= ',p.p(13)
print,'chop 1 speed act= ',p.p(14),' chop 1 phase act= ',p.p(15)
print,'chop 2 speed act= ',p.p(16),' chop 2 phase act= ',p.p(17)

; useful chopper variables
openr=45.-(p.p(13)-p.p(11))
opena=45.-(p.p(17)-p.p(15))
period=60./p.p(14)
dela=(285.-opena)/2.
delt=(dela/360.)*period
chopsam=4
tofd=chopsam+(p.p(23)/1000.)
chanpa=(tofd/3956.)/(p.p(6)*1e-6)
chanpam=(chopsam/3956.)/(p.p(6)*1e-6)
delchan=delt/(p.p(6)*1e-6)
delechan=p.p(7)/p.p(6)
print,'TOF distance    = ',tofd, ' period chans    =',period/(p.p(6)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
print,'san= ',p.p(24),' deg.','dan= ',p.p(25),' deg.'
san=p.p(24)
dan=p.p(25)
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa
time=p.p(26)/10.
print,'run time= ',time,' s',' det= ',p.p(23)
det=p.p(23)



;make lambda array
yy=indgen(tsize)
;larr=(yy+delechan-delchan)/chanpa
larr=(yy)/chanpa
m=(yy+delechan-delchan)/chanpam



lfirst=(delchan-delechan)
print,'channel shift = ',lfirst

; loose nn channels at the beginning to avoid infinities in reciprocal space

;nn=1
aa=shift(ww,1,-round(lfirst))

neww1=aa(*,nn:tsize-1)
newlarr=larr(nn:tsize-1)

q=fltarr(xsize,tsize-nn)
th=fltarr(xsize,tsize-nn)
qx=fltarr(xsize,tsize-nn)
qz=fltarr(xsize,tsize-nn)

 

;  conversion to reciprocal space

dpr=180./!pi

pcen=135.79/nx
mmpp=1.04*nx
pmin=36./nx
pmax=233./nx


print,'pcen= ',pcen,' mmpp= ',mmpp
print,'ref th= ',(dr+dpr*atan((pcen-pr)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
lmax=max(newlarr)
lmin=min(newlarr)

;expt information d0=dan for diect beam p0=pixel for direct beam
;dr=dan for reflection pr=pixel for reflection



;find limits in reciprocal space

for i=pmin,pmax do begin
  for j=0,tsize-nn-1 do begin
  
   l=newlarr(j)
   th(i,j)=(dr+dpr*atan((pcen-i)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
   q(i,j)=4*!pi*sin(th(i,j)/dpr)/newlarr(j)
   qx(i,j)=q(i,j)*sin((th(i,j)-san)/dpr)
   qz(i,j)=q(i,j)*cos((th(i,j)-san)/dpr)
  
   endfor
 endfor

   
  
   print,'limits....'
   print,'thmax= ',max(th),'thmin= ',min(th),'qmin= ',min(q),'qmax= ',max(q)
   print,'qxmax= ',max(qx),'qxmin= ',min(qx),'qzmax= ',max(qz),'qzmin= ',min(qz)




sizex=600.
sizez=100.
;x1=-.004
;x2=.004
;y1=0
;y2=.05

;x1=-.0005
;x2=.0005
;y1=0
;y2=.15




;lims=[x1,y1,x2,y2]
gs=[(max(qx)-min(qx))/sizex,(max(qz)-min(qz))/sizez]
;gs=[(x2-x1)/sizex,(y2-y1)/sizez]

triangulate,qx,qz,triangles
x8=indgen(sizex+1)*(max(qx)-min(qx))/sizex+min(qx)
y8=indgen(sizez+1)*(max(qz)-min(qz))/sizex+min(qz)
res=trigrid(qx,qz,neww1,triangles,gs)
    

return

end
pro qspace_jg,w,nn,d0,p0,dr,pr,sizex,sizez,neww1,qx,qz,w8,x8,y8,p
print,'readback',nn,d0,p0,dr,pr
close,3
y=size(w)
print,y
TAKE_DATP,P
help,p
if (y(0) eq 3) then begin
   print,y
   
   xsize=y(1)
   ysize=y(2)
   tsize=y(3)

   print,'Three dimensions x,y,t =',xsize,ysize,tsize
   print,'Will sum over the y dimension'
   ww=lonarr(xsize,tsize)
   ww=total(w,2)
   
   
endif else begin
   
   tsize=y(2)
   xsize=y(1)
   print,'Two dimensions x,t =',xsize,tsize
   ww=lonarr(xsize,tsize)
   ww=w
      
endelse

print,'hello world'
print,'no of chans= ',p.p(1),' chan width= ',p.p(6),' tof delay= ',p.p(7)
print,'x1= ',p.p(2),' x2= ',p.p(3),' y1= ',p.p(4),' y2= ',p.p(5)
nx=p.p(8)
ny=p.p(9)
print,'nx= ',nx,' ny= ',ny
print,'chop 1 speed req= ',p.p(10),' chop 1 phase req= ',p.p(11)
print,'chop 2 speed req= ',p.p(12),' chop 2 phase req= ',p.p(13)
print,'chop 1 speed act= ',p.p(14),' chop 1 phase act= ',p.p(15)
print,'chop 2 speed act= ',p.p(16),' chop 2 phase act= ',p.p(17)

; useful chopper variables
openr=45.-(p.p(13)-p.p(11))
opena=45.-(p.p(17)-p.p(15))
opena=opena-1.1
period=60./p.p(14)
dela=(285.-opena-3.3776)/2.
delt=(dela/360.)*period
chopsam=4.1135-(85.e-3)/2.
tofd=chopsam+(p.p(23)/1000.)
chanpa=(tofd/3956.)/(p.p(6)*1e-6)
chanpam=(chopsam/3956.)/(p.p(6)*1e-6)
delchan=delt/(p.p(6)*1e-6)
delechan=p.p(7)/p.p(6)
print,'TOF distance    = ',tofd, ' period chans    =',period/(p.p(6)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
print,'san= ',p.p(24),' deg.','dan= ',p.p(25),' deg.'
san=p.p(24)
dan=p.p(25)
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa
time=p.p(26)/10.
print,'run time= ',time,' s',' det= ',p.p(23)
det=p.p(23)


print,'well done chaps...'
;make lambda array
yy=indgen(tsize)
;larr=(yy+delechan-delchan)/chanpa
larr=(yy)/chanpa
m=(yy+delechan-delchan)/chanpam



lfirst=(delchan-delechan+0.5)
print,'channel shift = ',lfirst

; loose nn channels at the beginning to avoid infinities in reciprocal space

;nn=1
aa=shift(ww,1,-round(lfirst))

neww1=aa(*,nn:tsize-1)
newlarr=larr(nn:tsize-1)

q=fltarr(xsize,tsize-nn)
th=fltarr(xsize,tsize-nn)
qx=fltarr(xsize,tsize-nn)
qz=fltarr(xsize,tsize-nn)

 

;  conversion to reciprocal space

dpr=180./!pi

pcen=135.79/nx
mmpp=1.04*nx
pmin=150./nx
pmax=233./nx


print,'pcen= ',pcen,' mmpp= ',mmpp
print,'ref th= ',(dr+dpr*atan((pcen-pr)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
lmax=max(newlarr)
lmin=min(newlarr)

;expt information d0=dan for diect beam p0=pixel for direct beam
;dr=dan for reflection pr=pixel for reflection



;find limits in reciprocal space

for i=pmin,pmax do begin
  for j=0,tsize-nn-1 do begin
  
;   l=newlarr(j)
   th(i,j)=(dr+dpr*atan((pcen-i)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2.0
   h1=th(i,j)
   h2=(h1-san)/dpr
   q(i,j)=4*!pi*sin(h1/dpr)/newlarr(j)
   h3=q(i,j)
   qx(i,j)=h3*sin(h2)
   qz(i,j)=h3*cos(h2)

;   l=newlarr(j)
;   th(i,j)=(dr+dpr*atan((pcen-i)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
;   q(i,j)=4*!pi*sin(th(i,j)/dpr)/newlarr(j)
;   qx(i,j)=q(i,j)*sin((th(i,j)-san)/dpr)
;   qz(i,j)=q(i,j)*cos((th(i,j)-san)/dpr)

  
   endfor
 endfor

   
  
   print,'limits....'
   print,'thmax= ',max(th),'thmin= ',min(th),'qmin= ',min(q),'qmax= ',max(q)
   print,'qxmax= ',max(qx),'qxmin= ',min(qx),'qzmax= ',max(qz),'qzmin= ',min(qz)



;nfac=1
;sizex=120.*nfac
;sizez=300.*nfac
print,min(qx),max(qx),min(qz),max(qz),sizex,sizez

gs=[(max(qx)*1.001-min(qx))/sizex,(max(qz)*1.001-min(qz))/sizez]

print,gs(0),gs(1),max(qz)/gs(1)

;**********************
;  nicks bit

;  bin neww1 into a square array qx qz of size sizex X sizez

xpixelsize=gs(0)
zpixelsize=gs(1)
minz=min(qz)
minx=min(qx)

x8=indgen(sizex)*xpixelsize + minx
y8=indgen(sizez)*ypixelsize + minz

w8=congrid(neww1, sizex, sizez, /INTERP, /MINUS_ONE)

;print,tsize-nn
;w8=fltarr(sizex,sizez)

;      loop about input array neww1
;          for k=0,xsize-1 do begin
;		i=floor((qx(k,*)-minx)/xpixelsize)
;                j=floor((qz(k,*)-minz)/zpixelsize)
;              
;		w8(i,j)=w8(i,j)+neww1(k,*)
;
;          endfor




print,'done'



;*********************




return

end
pro qspace,w,nn,d0,p0,dr,pr,sizex,sizez,neww1,qx,qz,w8,x8,y8,p
print,'readback',nn,d0,p0,dr,pr
close,3
y=size(w)
print,y
TAKE_DATP,P
help,p
if (y(0) eq 3) then begin
   print,y
   
   xsize=y(1)
   ysize=y(2)
   tsize=y(3)

   print,'Three dimensions x,y,t =',xsize,ysize,tsize
   print,'Will sum over the y dimension'
   ww=lonarr(xsize,tsize)
   ww=total(w,2)
   
   
endif else begin
   
   tsize=y(2)
   xsize=y(1)
   print,'Two dimensions x,t =',xsize,tsize
   ww=lonarr(xsize,tsize)
   ww=w
      
endelse

print,'hello world'
print,'no of chans= ',p.p(1),' chan width= ',p.p(6),' tof delay= ',p.p(7)
print,'x1= ',p.p(2),' x2= ',p.p(3),' y1= ',p.p(4),' y2= ',p.p(5)
nx=p.p(8)
ny=p.p(9)
print,'nx= ',nx,' ny= ',ny
print,'chop 1 speed req= ',p.p(10),' chop 1 phase req= ',p.p(11)
print,'chop 2 speed req= ',p.p(12),' chop 2 phase req= ',p.p(13)
print,'chop 1 speed act= ',p.p(14),' chop 1 phase act= ',p.p(15)
print,'chop 2 speed act= ',p.p(16),' chop 2 phase act= ',p.p(17)

; useful chopper variables
openr=45.-(p.p(13)-p.p(11))
opena=45.-(p.p(17)-p.p(15))
opena=opena-1.02
period=60./p.p(14)
dela=(285.-opena+0.9)/2.
delt=(dela/360.)*period
chopsam=4.0115-(85.e-3)/2.
tofd=chopsam+(p.p(23)/1000.)
chanpa=(tofd/3956.)/(p.p(6)*1e-6)
chanpam=(chopsam/3956.)/(p.p(6)*1e-6)
delchan=delt/(p.p(6)*1e-6)
delechan=p.p(7)/p.p(6)
print,'TOF distance    = ',tofd, ' period chans    =',period/(p.p(6)*1e-6)
print,'channels/Ang    = ',chanpa,' chop del chans  = ',delchan
print,'chopper period  = ',period*1000.,' elec del chans  = ',delechan
print,'opening      req= ',openr,' opening      act= ',opena
print,'chop delay angle= ',dela,' chop delay  time= ',delt*1000.,' ms'
print,'san= ',p.p(24),' deg.','dan= ',p.p(25),' deg.'
san=p.p(24)
dan=p.p(25)
print,' 27A TOF        = ',27.*chanpa,' 4.5A TOF        = ',4.5*chanpa
time=p.p(26)/10.
print,'run time= ',time,' s',' det= ',p.p(23)
det=p.p(23)


print,'well done chaps...'
;make lambda array
yy=indgen(tsize)
;larr=(yy+delechan-delchan)/chanpa
larr=(yy)/chanpa
m=(yy+delechan-delchan)/chanpam



lfirst=(delchan-delechan+0.5)
print,'channel shift = ',lfirst

; loose nn channels at the beginning to avoid infinities in reciprocal space

;nn=1
aa=shift(ww,1,-round(lfirst))

neww1=aa(*,nn:tsize-1)
newlarr=larr(nn:tsize-1)

q=fltarr(xsize,tsize-nn)
th=fltarr(xsize,tsize-nn)
qx=fltarr(xsize,tsize-nn)
qz=fltarr(xsize,tsize-nn)

 

;  conversion to reciprocal space

dpr=180./!pi

pcen=135.79/nx
mmpp=1.04*nx
pmin=150./nx
pmax=233./nx


print,'pcen= ',pcen,' mmpp= ',mmpp
print,'ref th= ',(dr+dpr*atan((pcen-pr)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
lmax=max(newlarr)
lmin=min(newlarr)

;expt information d0=dan for diect beam p0=pixel for direct beam
;dr=dan for reflection pr=pixel for reflection



;find limits in reciprocal space

for i=pmin,pmax do begin
  for j=0,tsize-nn-1 do begin
  
   l=newlarr(j)
   th(i,j)=(dr+dpr*atan((pcen-i)*mmpp/det))/2-(d0+dpr*atan((pcen-p0)*mmpp/det))/2
   q(i,j)=4*!pi*sin(th(i,j)/dpr)/newlarr(j)
   qx(i,j)=q(i,j)*sin((th(i,j)-san)/dpr)
   qz(i,j)=q(i,j)*cos((th(i,j)-san)/dpr)
  
   endfor
 endfor

   
  
   print,'limits....'
   print,'thmax= ',max(th),'thmin= ',min(th),'qmin= ',min(q),'qmax= ',max(q)
   print,'qxmax= ',max(qx),'qxmin= ',min(qx),'qzmax= ',max(qz),'qzmin= ',min(qz)



;nfac=1
;sizex=120.*nfac
;sizez=300.*nfac
print,min(qx),max(qx),min(qz),max(qz),sizex,sizez

gs=[(max(qx)*1.001-min(qx))/sizex,(max(qz)*1.001-min(qz))/sizez]

print,gs(0),gs(1),max(qz)/gs(1)

;**********************
;  nicks bit

;  bin neww1 into a square array qx qz of size sizex X sizez


x8=indgen(sizex)*(max(qx)-min(qx))/(sizex)+min(qx)
y8=indgen(sizez)*(max(qz)-min(qz))/(sizez)+min(qz)

xpixelsize=gs(0)
zpixelsize=gs(1)


print,tsize-nn
w8=fltarr(sizex,sizez)


; loop about output array w9
;for i=0,sizex-1 do begin
;	for j=0,sizez-1 do begin
;		w8(i,j)=0
;	endfor
;endfor	



;      loop about input array neww1
          for k=0,xsize-1 do begin
;             print,k,xsize-1

               
		i=floor((qx(k,*)-min(qx))/xpixelsize)
                j=floor((qz(k,*)-min(qz))/zpixelsize)
              
		w8(i,j)=w8(i,j)+neww1(k,*)

          endfor



print,'done'



;*********************




return

end
;--------------------------------------------------------------------------------
;********************************************************************************
;
	FUNCTION qstrip, w_in, Q=Qvalue, dQ=dQ, pos_angles=pos_angles, $
		 neg_angles=neg_angles, all_angles=all_angles, qv, qb, ib
;
; For IN4, IN5, IN6 and D7
;
;rebins output data from t2e and reb to regular-grid S(Q,w) data using the old
;KHA IN6 rebin algorithm. Selects a single Q-value. Input workspace must be in
;energy transfer versus scattering angle, i.e. only one component or spin phase.
;
;ARGUMENS:
;	Qvalue:	Q-value at centre of extracted strip
;	dQ :	Width of Q-strip
;
;KEYWORDS (- only for D7 data)
; /neg_angles	: use only negative angles
; /pos_angles	: use only positive angles
; /all_angles	: use all angles (default)
;		input workspace must be in energy transfer versus scattering angle,
;		i.e. only one component or spin phase.
; (ev, eb, qb and ib are obsolete, kept for backwards compatability)
;
;DIMENSIONS:
; w_in(nE,nphi) -> w_out(nE)
;
;COMMAND SYNTAX:
; w10=qstrip(w9,Q=<Qvalue>,dQ=<dQ>[,/neg_angles][,/pos_angles][,/all_angles])
;
; (optional keywords shown in square brackets)
;							KHA,JRS 10/8/00
;
;----------------------------------------------------------------------------------
;**********************************************************************************

	common c_lamp_access, inst

	common grid, Qmin, Qmax, Emin, Emax

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start qstrip:'

	take_datp, datp

	ibank=2
	IF(N_ELEMENTS(qv) GT 0) THEN Qvalue=qv
	IF(N_ELEMENTS(qb) GT 0) THEN dQ=qb
	IF(N_ELEMENTS(ib) GT 0) THEN ibank=ib

	IF KEYWORD_SET(pos_angles) THEN ibank=1
	IF KEYWORD_SET(neg_angles) THEN ibank=0
	IF KEYWORD_SET(all_angles) THEN ibank=2
;-------------------------------------------------------------------------------
;Set up starting parameters

	IF (N_ELEMENTS(Qvalue) NE 1 OR N_ELEMENTS(dQ) NE 1) THEN BEGIN
		PRINT,'qstrip: Error - Qvalue, dQ must be specified'
		return, w_in
	ENDIF

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	IF (sw(0) NE 2) THEN BEGIN
		PRINT,'qstrip: Error - input workspace must be 2-D: E vs. phi'
		return,w_in
	ENDIF
	nx=sw(1)
	ny=sw(2)
	IF (iprint GT 0) THEN PRINT,'nx=',nx,' ny=',ny
	x_in=datp.x	& sx=SIZE(x_in)
	y_in=datp.y	& sy=SIZE(y_in)
	IF (nx NE sx(1)) OR (ny NE sy(1)) THEN BEGIN
		PRINT,'qstrip: Error - sx=',sx,' sy=',sy
		return,w_in
	ENDIF

	e_in=datp.e
	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN e_in=w_in*0.

	par=datp.p

	IF (iprint GT 0) THEN PRINT,'Instrument = ',inst
	IF (inst EQ 'D7') THEN BEGIN
		lambda=par(4)
		IF (N_ELEMENTS(ibank) EQ 0) THEN ibank=2
		TOF=FIX(par(8))
		IF (TOF NE 1) THEN BEGIN
			PRINT,'qstrip: Error - workspace data is not in TOF'
			return,w_in
		ENDIF
	ENDIF ELSE lambda=par(21)

	IF (iprint GT 0) THEN PRINT,'lambda=',lambda,'A'

;-------------------------------------------------------------------------------------
;	Set constants and prepare arrays for rebinning to regular Q-E grid

	const1=5.22697		; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571	; E(meV)=const2*k(A^-1)^2 for neutron
	const3=3.956076		; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066		; E(meV)=const4/lambda(A)^2 for neutron

	Ei=const4/lambda^2
	ki=SQRT(Ei/const2)
	y_in=y_in*!pi/180.	; convert to radians

	nEps=nx+1	& Eps=FLTARR(nEps)
	Eps(0)=x_in(0)-(x_in(1)-x_in(0))/2.
	Eps(1:nx-1)=(x_in(0:nx-2)+x_in(1:nx-1))/2.
	Eps(nx)=x_in(nx-1)+(x_in(nx-1)-x_in(nx-2))/2.

	IF (iprint GT 0) THEN PRINT,'x=',x_in

	nEps=nx+1	& Emin=Eps(0)	& Emax=Eps(nEps-1)
	IF (iprint GT 0) THEN PRINT,'Emin=',Emin,' Emax=',Emax,' meV'
	IF (iprint GT 0) THEN PRINT,'Eps=',Eps

	w_out=FLTARR(nEps)	& w_out(*)=0.	& e_out=w_out-1.

	IF (iprint GT 0) THEN PRINT,'y_in=',y_in*180./!pi

	IF (inst EQ 'D7') THEN BEGIN
		i=WHERE(y_in GT 0.,n)
		IF (n LE 0 OR n EQ ny) THEN BEGIN
			PRINT,'qstrip: Error - For D7 both -ve and +ve angles must be present'
			return,w_in
		ENDIF
		IF (ibank EQ 2) THEN BEGIN
			twice=1
			iphi1=0		& iphi1next=i(0)
			iphi2=i(0)-1	& iphi2next=ny-1
		ENDIF ELSE BEGIN
			twice=0
			IF (ibank EQ 0) THEN BEGIN
				iphi1=0
				iphi2=i(0)-1
			ENDIF ELSE IF (ibank EQ 1) THEN BEGIN
				iphi1=i(0)
				iphi2=ny-1
			ENDIF ELSE BEGIN
				PRINT,'qstrip: Error - ibank =',ibank
				return,w_in
			ENDELSE
		ENDELSE
	ENDIF ELSE BEGIN
		twice=0
		iphi1=0	& iphi2=ny-1
	ENDELSE
	IF (iprint GT 0) THEN PRINT,'twice=',twice,' iphi1=',iphi1,' iphi2=',iphi2

start:
	nphi=iphi2-iphi1+2
	phi=FLTARR(nphi)
	phi(0)=y_in(iphi1)-(y_in(iphi1+1)-y_in(iphi1))/2.
	phi(1:nphi-2)=(y_in(iphi1:iphi2-1)+y_in(iphi1+1:iphi2))/2.
	phi(nphi-1)=y_in(iphi2)+(y_in(iphi2)-y_in(iphi2-1))/2.
	COSphi=COS(phi)

	w_buf=w_in(*,iphi1:iphi2)
	e_buf=e_in(*,iphi1:iphi2)
	y_buf=y_in(iphi1:iphi2)
	IF (phi(0) LT 0.) THEN BEGIN ; reverse array direction for negative angles
		w_buf=REVERSE(w_buf,2)
		e_buf=REVERSE(e_buf,2)
		y_buf=ABS(REVERSE(y_buf))
		phi=ABS(REVERSE(phi))
		COSphi=REVERSE(COSphi)
	ENDIF

	IF (iprint GT 0) THEN PRINT,'phi=',phi*180./!pi

	IF (iprint GT 0) THEN PRINT,'End of "prepare arrays" section'

;-------------------------------------------------------------------------------------
;	Rebin to constant Q grid

	a=const2		;	E(meV)=a*Q(A**-1)**2   for neutron

	oldymin=0.

	IF (iprint GT 0) THEN BEGIN
		b=''
		PRINT,'About to start rebinning. Hit return to continue'
		READ, b
	ENDIF

	Qmin=Qvalue-dQ/2.	& Qmax=Qvalue+dQ/2.
	Q00=[Qmin,Qmin,Qmax,Qmax]
	IF (iprint GT 0) THEN PRINT,Qmin,' < Q <',Qmax
	FOR iEps=0,nEps-2 DO BEGIN
		IF (iprint GT 0) THEN PRINT,'iEps=',iEps
		Emin=Eps(iEps)	& Emax=Eps(iEps+1)
		corrarea=dQ*(Emax-Emin)
		Eps0=[Emin,Emax,Emax,Emin]
		IF (iprint GT 0) THEN PRINT,Emin,' < Eps <',Emax
		COSphi0=(2.*Ei-Eps0-a*Q00^2)/(2.*SQRT(Ei*(Ei-Eps0)))
		IF (iprint GT 0) THEN PRINT,' COS(phi1-4):',COSphi0
		IF (MAX(ABS(COSphi0)) GE 1.) THEN GOTO, outside
		phi0=ACOS(COSphi0)
		IF (iprint GT 0) THEN PRINT,' phi0=',phi0*180./!pi
		phimin=MIN(phi0)	& phimax=MAX(phi0)
		IF (iprint GT 0) THEN PRINT,'Outside if: phimax=',phimax*180./!pi,'< phi(0)=',phi(0)*180./!pi
		IF (iprint GT 0) THEN PRINT,'        or: phimin=',phimin*180./!pi,'> phi(nphi-1)=',phi(nphi-1)*180./!pi,'  nphi=',nphi
		IF (phimax LT phi(0) OR phimin GT phi(nphi-1)) THEN GOTO, outside
		IF (iprint GT 0) THEN PRINT,'phi within range'
		iphi=WHERE(phi GT phimin AND phi LT phimax, nlines)
		iphi0=(iphi(0)-1)>0
		IF (nlines EQ 0) THEN BEGIN
			phimean=(phimin+phimax)/2.
			ip=WHERE(phi LT phimean, np)
			iphi0=ip(np-1)
		ENDIF
startrebin:	Areasum=0.
		wsum=0.
		e2sum=0.
		phiminmeas=7.	& phimaxmeas=0.
		FOR iphi=iphi0,(iphi0+nlines)<(nphi-2) DO BEGIN
			IF (iprint GT 0) THEN BEGIN
				ip1=iphi0
				ip2=(iphi0+nlines)<(nphi-2)
				PRINT,'FOR iphi=',ip1,',',ip2
				PRINT,'phi(',ip1,')=',phi(ip1)*180./!pi
				PRINT,'phi(',ip2+1,')=',phi(ip2+1)*180./!pi
			ENDIF
			COSphi1=COSphi(iphi)	& COSphi2=COSphi(iphi+1)
			COSphi0=[COSphi1,COSphi1,COSphi2,COSphi2]
			IF (iprint GT 0) THEN PRINT,'phi1=',phi(iphi)*180./!pi,$
								' phi2=',phi(iphi+1)*180./!pi
			Q0=SQRT((2.*Ei-Eps0-2.*SQRT(Ei*(Ei-Eps0))*COSphi0)/a)
			area=overlap(Q0,Eps0,iprint,oldymin)
			IF (area GT 0.) THEN BEGIN
				IF (iprint GT 0) THEN PRINT,'Area>0'
				w=w_buf(iEps,iphi)	& e=e_buf(iEps,iphi)
				IF (w NE 0. OR e GE 0.) THEN BEGIN
					areasum=areasum+area
					wsum=wsum+area*w
					e2sum=e2sum+(area*e)^2
					phiminmeas=phiminmeas<phi(iphi)
					phimaxmeas=phimaxmeas>phi(iphi+1)
					IF (iprint GT 0) THEN PRINT, $
						'w_buf(',iEps,',',iphi,')=',w
					IF (iprint GT 0) THEN PRINT, $
						'e_buf(',iEps,',',iphi,')=',e
					IF (iprint GT 0) THEN PRINT, $
					phiminmeas,' < phimeas <',phimaxmeas
				ENDIF
			ENDIF ELSE IF (iprint GT 0) THEN PRINT,'Area<=0'
		ENDFOR
		IF (areasum NE 0.) THEN BEGIN
			IF (iprint GT 0) THEN PRINT,'areasum NE 0. - OK'
			w_out(iEps)=wsum/areasum
			e_out(iEps)=SQRT(e2sum)/areasum
			GOTO, binned
		ENDIF ELSE IF (iprint GT 0) THEN PRINT,'areasum is zero'
outside:	IF (iprint GT 0) THEN PRINT,'Outside covered Q-w region'
		w_out(iEps)=0.
		e_out(iEps)=-1.
		GOTO, nextpoint
binned:
		IF (iprint GT 0) THEN PRINT,'phimin=',phimin,' phimax=',phimax
		IF (iprint GT 0) THEN PRINT,'measur=',phiminmeas,'        ',phimaxmeas
		p1=phimin>phiminmeas
		p2=phimax<phimaxmeas
		IF (p2-p1 LT (phimax-phimin)/2.) THEN BEGIN
			IF (iprint GT 0) THEN PRINT,'Point removed'
			w_out(iEps)=0.
			e_out(iEps)=-1.
		ENDIF ELSE IF (iprint GT 0) THEN PRINT,'Point kept'
nextpoint:
		IF (iprint GT 0) THEN PRINT,'*********************************************************'
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of rebinning'

	IF (twice EQ 1) THEN BEGIN
		IF (iphi1 EQ 0) THEN BEGIN
			w_out1=w_out	& e_out1=e_out
			iphi1=iphi1next
			iphi2=iphi2next
			GOTO, start
		ENDIF ELSE BEGIN
			w_out2=w_out	& e_out2=e_out
			w_out(*)=0.	& e_out(*)=0.
			not1=WHERE(e_out1 LE 0.,n1)
			IF (n1 NE 0) THEN e_out1(not1)=1.
			not2=WHERE(e_out2 LE 0.,n2)
			IF (n2 NE 0) THEN e_out2(not2)=1.
			w_out=(w_out1/e_out1^2+w_out2/e_out2^2)/(1./e_out1^2+1./e_out2^2)
			e_out=1./SQRT(1./e_out1^2+1./e_out2^2)
			IF (n1 NE 0) THEN e_out1(not1)=-1.
			IF (n2 NE 0) THEN e_out2(not2)=-1.
			IF (n1 NE 0) THEN BEGIN
				w_out(not1)=w_out2(not1)
				e_out(not1)=e_out2(not1)
			ENDIF
			IF (n2 NE 0) THEN BEGIN
				w_out(not2)=w_out1(not2)
				e_out(not2)=e_out1(not2)
			ENDIF
		ENDELSE
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of rebinning section'

;-------------------------------------------------------------------------------------
;	Chop off superfluous bits


	iOK=WHERE(e_out GE 0.,nOK)
	IF (nOK LE 0) THEN BEGIN
		PRINT,'qstrip: Error - no data within this Q-strip'
		GOTO, finished
	ENDIF ELSE BEGIN
		w_out=w_out(iOK)
		e_out=e_out(iOK)
		Eps=Eps(iOK)
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'End of chopping section'

;-------------------------------------------------------------------------------------
;	Return parameters and exit

	datp.x_tit='Energy Transfer (meV)'
	datp.y_tit=datp.z_tit

	mod_datp, datp, "x", Eps
	mod_datp, datp, "e", e_out

	PRINT, FORMAT='("qstrip: Rebinned to constant Q-w: Q=",F4.2,"+/-",F4.2,"A-1")', Qvalue, dQ/2.

	s=STRTRIM(STRING(FLOAT(Qvalue)),2)  & i=STRPOS(s,'.') & Qvalue=STRMID(s,0,i(0)+3)
	s=STRTRIM(STRING(FLOAT(dQ)),2)  & i=STRPOS(s,'.') & dQ=STRMID(s,0,i(0)+3)
	s=' -qs('+Qvalue+','+dQ
	IF (inst EQ 'D7') THEN s=s+','+STRTRIM(STRING(ibank),2)+')' ELSE s=s+')'
	datp.other_tit=datp.other_tit+s

	give_datp, datp

finished:
	RETURN, w_out
	END

;------------------------------------------------------------------------------
;******************************************************************************
;
	FUNCTION quartz, w_in, nosave=nosave, FR_depol=FRR, $
		 temp=temp, sk, fr1, tmp

;For D7 data only
;
;takes 2-D or 3-D workspace containing a normalised non-tof z-PA 
;or xyz-PA background-subtracted quartz run (or runs). Puts the flipping ratios 
;into w_out and also into the file 'quartz_"numor".dat'.  Will also correct
;for depolarisation due to the sample (assuming cylindrical geometry) if desired
;
;
;ARGUMENTS:
; FR_depol	:if depolarisation is present in the sample - 
;		 FR_depol is flipping ratio (IN M2)in the presence of 
;		 depolarisation
; temp		:if depolarisation is present in the sample - 
;		 temp is the temperature (used to name the output file
;		 "quartz_<numor>_<temp>.dat") to identify the depolarisation
;		 correction at that temperature
; (sk, fr1 and tmp are obsolete, kept for backwards compatability)
;
;KEYWORDS:
; /nosave	:don't save flipping ratios to file
;
;DIMENSIONS:
; w_in(nspectra, nphases) -> w_out(nspectra)
;
;COMMAND SYNTAX:
; w5=quartz(w4[,/nosave][,FR_depol=<FR_depol>,temp=<temp>]
;
; (optional keywords/arguments shown in square brackets)
;
;							KHA/JRS, 6/10/00
;-------------------------------------------------------------------------------
;*******************************************************************************
	COMMON c_lamp

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start quartz:'

	take_datp, datp

	skip=0

	IF(N_ELEMENTS(sk) GT 0) THEN skip=sk
	IF(N_ELEMENTS(fr1) GT 0) THEN FRR=fr1
	IF(N_ELEMENTS(tmp) GT 0) THEN temp=tmp

	IF KEYWORD_SET(nosave) THEN skip=1
;-------------------------------------------------------------------------------
;Check dimensions of input workspaces


	mon=datp.n
	e_in=datp.e

	sw=SIZE(w_in)

	se=SIZE(e_in)
	FOR i=0,se(0) DO IF (se(i) NE sw(i)) THEN GOTO, seterr
	GOTO, noseterr
seterr:
	PRINT,'Normalise: No error bars defined for w_in. Use sqrt'
	e_in=SQRT(w_in)
noseterr:

	nspectra=sw(1)
	nphases=sw(2)/2		; i.e. 1 for z-PA and 3 for xyz-PA
	IF(sw(0) EQ 2) THEN nruns=1 ELSE nruns=sw(3)
	IF(nruns EQ 1) THEN x_in=datp.x ELSE x_in=datp.z

	IF (N_ELEMENTS(skip) EQ 0) THEN skip=0

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Calculate flipping ratios

	fr=FLTARR(nspectra)		& dfr=fr
	x_out=x_in
	IF(nruns GT 1) THEN z_out=INDGEN(nruns)
	y_out=INDGEN(nphases)
	w_out=FLTARR(nspectra,nphases,nruns)
	e_out=w_out
	
	FOR irun=0,nruns-1 DO BEGIN
		FOR iphase=0,nphases-1 DO BEGIN
			ip0=2*iphase	& ip1=2*iphase+1
			IF (iprint GT 0) THEN PRINT,'iphase=',iphase,' ip0=',ip0,' ip1=',ip1
			fr=(w_in(*,ip0,irun)/w_in(*,ip1,irun))
			dfr=SQRT((e_in(*,ip0,irun)/w_in(*,ip1,irun))^2 $
				+(e_in(*,ip1,irun)*w_in(*,ip0,irun)/w_in(*,ip1,irun)^2)^2)
			w_out(*,iphase,irun)=fr
			e_out(*,iphase,irun)=dfr
			IF (iprint GT 0) THEN PRINT,'fr=',fr
			IF (iprint GT 0) THEN PRINT,'dfr=',dfr
		ENDFOR
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of "calculate flip. etc." section'
;-------------------------------------------------------------------------------
;Blech-Averbach correction for angular dependence (drops out if FRR=1)

	IF (N_ELEMENTS(FRR) EQ 0) THEN FRR=0
	IF (FRR EQ 0) THEN GOTO, write

	IF(nphases EQ 3) THEN BEGIN
		x=[datp.p(28),datp.p(29),datp.p(30)]
		FRRT1=MOMENT(x)
		FRRT=FRRT1(0)
	ENDIF ELSE BEGIN
		FRRT=datp.p(28)
	ENDELSE

	print, FRRT
	p1=(FRR-1.)/(FRR+1.)	& p0=(FRRT-1.)/(FRRT+1.)

	a1=1.7133
	a2=-0.0927
	b1=-0.0368
	b2=-0.3750

	muR=(-a1+SQRT(a1^2-4.*a2*ALOG(p1/p0)))/(2*a2)
	muR=ABS(muR)

	IF (IPRINT GT 0) THEN PRINT, 'p1=',p1,'p0=',p0,'muR=',muR

	ptheta=x_in
	x_buf=(ABS(x_in)*!pi/180.)/2.	;theta in radians

	ptheta=EXP(-(a1+b1*SIN(x_buf)^2)*muR-(a2+b2*SIN(x_buf)^2)*muR^2)

	w_buf=(w_out-1.)/(w_out+1.)
	e_buf=e_out*(2./((w_out+1.)^2))

	FOR iphase=0,nphases-1 DO BEGIN
		w_buf(*,iphase,*)=w_buf(*,iphase,*)*ptheta
		e_buf(*,iphase,*)=e_buf(*,iphase,*)*ptheta
	ENDFOR

	w1=1.+w_buf	& e1=e_buf
	w2=1.-w_buf	& e2=e_buf
	w_out=w1/w2
	e_out=e_buf*(2./((1.-w_buf)^2))

	IF (IPRINT GT 0) THEN PRINT,'Flipping ratios, and errors are:',w_out, e_out
	IF (IPRINT GT 0) THEN PRINT,'End of Blech-Averbach correction section.'

;-------------------------------------------------------------------------------
;Write flipping ratios to quartz file

write:	help, w_out
	numor=LONARR(nruns)
	FOR irun=0,nruns-1 DO BEGIN
		IF(iprint GT 0) THEN PRINT,'irun=',irun
		IF(nruns EQ 1) THEN numor(irun)=LONG(datp.p(0)) ELSE $
			numor(irun)=LONG(datp.pv(0,irun))
		mon=LONG(mon)

		title='Flipping Ratios from '+STRTRIM(datp.w_tit,2)

		IF (skip NE 0) THEN GOTO, dontsave
	
		IF(FRR EQ 0) THEN BEGIN
			out_file='quartz_'+STRTRIM(STRING(numor(irun)),2)+'.dat'
		ENDIF ELSE BEGIN
			out_file='quartz_'+STRTRIM(STRING(numor(irun)),2)+'_'+STRTRIM(STRING(temp),2)+'.dat'
		ENDELSE

		OPENW, 1, out_file
		PRINTF, 1, STRTRIM(title,2)
		IF (nphases EQ 1) THEN BEGIN
			PRINTF, 1, 'Spectrum    Angle      Flip     dFlip'
			FOR i=0,nspectra-1 DO PRINTF, 1, FORMAT='(I7,2F11.3,F7.3)', $
						2*(i+1), x_out(i,irun), w_out(i,0,irun), e_out(i,0,irun)
			PRINTF, 1, FORMAT='("   Time 0  ",I18)', mon(0,1,irun)
			PRINTF, 1, FORMAT='("   Time 1  ",I18)', mon(0,2,irun)
			PRINTF, 1, FORMAT='("Monitor 0  ",I18)', mon(1,1,irun)
			PRINTF, 1, FORMAT='("Monitor 1  ",I18)', mon(1,2,irun)
		ENDIF ELSE BEGIN
			PRINTF, 1, 'Spectrum    Angle      FlipZ  dFlipZ     FlipX  dFlipX     FlipY  dFlipY'
			FOR i=0,nspectra-1 DO PRINTF, 1, FORMAT='(I7,2F11.3,F7.3,F11.3,F7.3,F11.3,F7.3)', $
						2*(i+1), x_out(i,irun), w_out(i,0,irun), e_out(i,0,irun), $
						w_out(i,1,irun), e_out(i,1,irun), w_out(i,2,irun), e_out(i,2,irun)
			PRINTF, 1, FORMAT='("   Time 0  ",3I18)', mon(0,1,irun), mon(0,3,irun), mon(0,5,irun)
			PRINTF, 1, FORMAT='("   Time 1  ",3I18)', mon(0,2,irun), mon(0,4,irun), mon(0,6,irun)
			PRINTF, 1, FORMAT='("Monitor 0  ",3I18)', mon(1,1,irun), mon(1,3,irun), mon(1,5,irun)
			PRINTF, 1, FORMAT='("Monitor 1  ",3I18)', mon(1,2,irun), mon(1,4,irun), mon(1,6,irun)
		ENDELSE
		CLOSE, 1	
		IF(lamp_host EQ 'd7' OR lamp_host EQ 'd7sgi' OR lamp_host EQ 'd7lin') THEN $
	   		spawn, 'cp '+out_file+' /home/vis/d7/lambda/QUARTZFILES/'
	ENDFOR
dontsave:

	IF (iprint GT 0) THEN PRINT,'End of "Write to quartz_file" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	datp.w_tit=title
	datp.other_tit=datp.other_tit+' -qu'

	IF (nphases EQ 1) THEN datp.y_tit='Flipping Ratio' ELSE BEGIN
		datp.y_tit='Phase'
		datp.z_tit='Flipping Ratio'
	ENDELSE

finished:

	IF (iprint GT 0) THEN PRINT,'End quartz:'

	give_datp, datp

	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION QxQy, w_in, omegashift=omegashift, dQ=dQ, os

;Takes output workspace of omega_scan.pro containing omega-scan, converts to
;Q-space and interpolates to a constant Qx-Qy grid (rough and ready version of
;qrebin.pro)  Deals with only one spin phase at a time
;
;ARGUMENTS:
; omegashift	: angle (in degrees) of omega=0 position
; dQ		: Q interpolation bin
; (os is obsolete, kept for backwards compatability)
;
;DIMENSIONS
; w_in(nspectra,nruns) -> w_out(nQx,nQy)
;
;COMMAND SYNTAX:
; w6=QxQy(w5[,/omegashift=<omega>])
;
; (optional arguments shown in square brackets)
;
;						KHA,JRS 21/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	take_datp, datp

	iprint=0	; if iprint>0, show debugging messages

	IF(N_ELEMENTS(os) GT 0) THEN omegashift=os

;-------------------------------------------------------------------------------
;Set constants

	par=datp.p
	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nruns=FIX(par(3))
	lambda=par(4)
	k=2.*!pi/lambda

	IF (iprint GT 0) THEN PRINT,'End of "set constants" section'

;-------------------------------------------------------------------------------
;Set up arrays

	ntheta=nspectra
	nomega=nruns

	e_in=datp.e

	phi=-datp.x		; detector angle: anticlockwise is +ve
	IF (N_ELEMENTS(omegashift) EQ 0) THEN omegashift=0.
	omega=-datp.y+omegashift	; sample rotation angle

	theta=FLTARR(ntheta)
	FOR itheta=0,ntheta-1 DO $
		IF (phi(itheta) LE 0.) THEN $
			theta(itheta)=phi(itheta)/2.+90. $
		ELSE theta(itheta)=phi(itheta)/2.-90.

	Qmag=k*SQRT(2.*(1.-COS(phi*!pi/180.)))

	IF (iprint GT 0) THEN PRINT,'omega=',omega
	IF (iprint GT 0) THEN FOR itheta=0,ntheta-1 DO $
		PRINT,'itheta=',itheta,' phi=',phi(itheta), $
		' theta=',theta(itheta),' Qmag=',Qmag(itheta)
	IF (iprint GT 0) THEN PRINT,'End of "Set up arrays" section'

;-------------------------------------------------------------------------------
;Check number of banks

	negative=0
	positive=0
	IF (phi(0) LT 0.) THEN BEGIN
		negative=1
		nneg1=0
		FOR iphi=1,ntheta-1 DO $
			IF (phi(iphi) GT 0.) THEN GOTO, pos
		nneg2=ntheta-1
		npos1=0
		npos2=0
		GOTO, endbanks
	pos:	positive=1
		nneg2=iphi-1
		npos1=iphi
		npos2=ntheta-1
	ENDIF ELSE BEGIN
		positive=1
		npos1=0
		FOR iphi=1,ntheta-1 DO $
			IF (phi(iphi) LT 0.) THEN GOTO, neg
		npos2=ntheta-1
		nneg1=0
		nneg2=0
		GOTO, endbanks
	neg:	negative=1
		npos2=iphi-1
		nneg1=iphi
		nneg2=ntheta-1
	ENDELSE
endbanks:

	IF (iprint GT 0) THEN BEGIN
		PRINT,'negative=',negative,' positive=',positive
		PRINT,'nneg1=',nneg1,' nneg2=',nneg2,' npos1=',npos1,' npos2=',npos2
	ENDIF
	IF (iprint GT 0) THEN PRINT,'End of "Check number of banks" section'

;-------------------------------------------------------------------------------
;Interpolate to regular Qx-Qy grid

	Qx=FLTARR(ntheta,nomega)
	Qy=FLTARR(ntheta,nomega)
	FOR iomega=0,nomega-1 DO BEGIN
		Qx(*,iomega)=Qmag*COS((theta-omega(iomega))*!pi/180.)
		Qy(*,iomega)=Qmag*SIN((theta-omega(iomega))*!pi/180.)
	ENDFOR

	TRIANGULATE, Qx, Qy, triangles, b

	IF N_ELEMENTS(dQ) EQ 0 THEN dQ=0.05
	GS=[dQ,dQ]
	Limits=[-2.*k,-2.*k,2.*k,2.*k]

	w_out=TRIGRID(Qx,Qy,w_in,triangles,GS,limits)
	e_out=TRIGRID(Qx,Qy,e_in,triangles,GS,limits)

	sw=size(w_out)

	x_out=FINDGEN(sw(1))-(sw(1)-1)/2. & x_out=x_out*dQ
	y_out=FINDGEN(sw(2))-(sw(2)-1)/2. & y_out=y_out*dQ

	nx=size(x_out)	& nx=nx(1)
	ny=size(y_out)	& ny=ny(1)

	IF (iprint GT 0) THEN PRINT,'End of "Interpolate to regular grid" section'

;-------------------------------------------------------------------------------
;Set points outside measured region to zero

	Qmin=100.
	Qmax=-100.
	FOR iQ=0,ntheta-1 DO BEGIN
		Q=Qmag(iQ)
		IF (Q LT Qmin) THEN Qmin=Q
		IF (Q GT Qmax) THEN Qmax=Q
	ENDFOR

	thetaneg1=theta(nneg2)
	thetaneg2=theta(nneg1)
	thetapos1=theta(npos2)
	thetapos2=theta(npos1)

	omegamin=omega(0)
	omegamax=omega(nomega-1)
	IF (omegamin GT omegamax) THEN BEGIN
		omegabuf=omegamin
		omegamin=omegamax
		omegamax=omegabuf
	ENDIF
	domega=(omegamax-omegamin)/FLOAT(nomega-1)
	fullcircle=0
	IF (360.-(omegamax-omegamin) LT 1.5*domega) THEN fullcircle=1

	IF (iprint GT 0) THEN BEGIN
		PRINT,'Qmin=',Qmin,' Qmax=',Qmax
		PRINT,'thetaneg1=',thetaneg1,' thetaneg2=',thetaneg2
		PRINT,'thetapos1=',thetapos1,' thetapos2=',thetapos2
		PRINT,'omegamin=',omegamin,' omegamax=',omegamax,' fullcircle=',fullcircle
	ENDIF

;	GOTO, skip

	ip=0
	FOR ix=0,nx-1 DO BEGIN
		Qx0=x_out(ix)
		FOR iy=0,ny-1 DO BEGIN
			Qy0=y_out(iy)
			Q=SQRT(Qx0^2+Qy0^2)
			IF (Q LT Qmin) OR (Q GT Qmax) THEN GOTO, zero
			IF (fullcircle EQ 1) THEN GOTO, notzero
			outneg=0
			outpos=0
			psi0=ACOS(Qx0/Q)*180./!pi
			IF (Qy0 LT 0.) THEN psi0=-psi0
			phi0=ACOS(1.-0.5*(Q/k)^2)*180./!pi
			IF (iprint GT 0) THEN ip=ip+1
			IF (ip EQ 10) THEN PRINT,'Qx=',Qx0,' Qy=',Qy0,' psi=',psi0,' phi=',phi0
			IF (negative EQ 1) THEN BEGIN
				IF (ip EQ 10) THEN PRINT,'phi is negative'
				theta0=-phi0/2.+90.
				IF (ip EQ 10) THEN PRINT,'theta0=',theta0
				IF (theta0 LT thetaneg1) OR (theta0 GT thetaneg2) THEN GOTO, outsideneg
				omega0=theta0-psi0
				IF (ip EQ 10) THEN PRINT,'omega0=',omega0
				nom=0
				FOR iom=-2,1 DO $
				IF (omega0 GE omegamin+iom*360.) AND (omega0 LE omegamax+iom*360.) THEN nom=nom+1
				IF (nom EQ 0) THEN GOTO, outsideneg
				IF (nom GE 2) THEN PRINT,'Error in -ve: nom>1'
				IF (ip EQ 10) THEN PRINT,'inside omega region'
			ENDIF ELSE BEGIN
	outsideneg:		outneg=1
				IF (ip EQ 10) THEN PRINT,'outside -ve region'
			ENDELSE
			IF (positive EQ 1) THEN BEGIN
				IF (ip EQ 10) THEN PRINT,'phi is positive'
				theta0=phi0/2.-90.
				IF (ip EQ 10) THEN PRINT,'theta0=',theta0
				IF (theta0 LT thetapos1) OR (theta0 GT thetapos2) THEN GOTO, outsidepos
				omega0=theta0-psi0
				IF (ip EQ 10) THEN PRINT,'omega0=',omega0
				nom=0
				FOR iom=-2,1 DO $
				IF (omega0 GE omegamin+iom*360.) AND (omega0 LE omegamax+iom*360.) THEN nom=nom+1
				IF (nom EQ 0) THEN GOTO, outsidepos
				IF (nom GE 2) THEN PRINT,'Error in +ve: nom>1'
				IF (ip EQ 10) THEN PRINT,'inside omega region'
			ENDIF ELSE BEGIN
	outsidepos:		outpos=1
				IF (ip EQ 10) THEN PRINT,'outside +ve region'
			ENDELSE
			IF (ip EQ 10) THEN ip=0
			IF (outneg EQ 1) AND (outpos EQ 1) THEN GOTO, zero ELSE GOTO, notzero
	zero:		w_out(ix,iy)=0.
			e_out(ix,iy)=-1.
	notzero:	dummy=0.
		ENDFOR
	ENDFOR

skip:

	IF (iprint GT 0) THEN PRINT,'End of "set outside points to zero" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "x", x_out
	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	datp.x_tit='Qx'
	datp.y_tit='Qy'

	s=STRTRIM(STRING(omegashift),2)
try:	n=STRLEN(s)	& i=RSTRPOS(s,'0')
	IF (i EQ n-1) THEN BEGIN
		s=STRMID(s,0,n-1)
		GOTO, try
	ENDIF
	PRINT,'QxQy: converted to Qx-Qy grid with omega-shift='+s+'degrees'
	datp.other_tit=datp.other_tit+' -qx('+s+')'

finished:
	give_datp, datp

	RETURN, w_out
	END
;*******************************************************************************
;*******************************************************************************
pro eve_event,ev
;*******************************************************************************
;*******************************************************************************

widget_control,ev.id,get_uvalue=u


common nb,n
common nb2,m
common tablo,tabb
common wavelth,wav

for i=1,m[0] do begin
	if u(0) eq i then begin
	widget_control,u(1),get_value=ech
	samp=strtrim(ech,2)
	tabb[i+100]=samp
	tabb[i+600]=samp
	endif
endfor




;---------------- CLOSE BUTTON ---------------
if u(0) eq 23 then begin
widget_control,ev.top,/destroy
endif

;---------------- NEW BUTTON ----------------
if u(0) eq 24 then begin
widget_control,/reset
rack
endif




;-------------------------------------------------------------------------------
;---------------------------------------- OPEN GRILLE.PROC ---------------------

if u(0) eq 25 then begin

common tablo,tabb


cpt=0
for i=1,m[0] do begin
	widget_control,u(i+1),get_value=ech
	if strlen(strtrim(string(ech[0]),2)) gt 0 then begin
	cpt=cpt+1
	tabb[cpt+100]=strtrim(ech,2)
;	tabb[cpt]=strtrim(string(i),2)
	tabb[cpt]=i
	tabb[i+600]=tabb[cpt+100]
	endif

endfor
tabb[1080]=cpt


;--------- INITIALISATION -----------
common tablo2,tabb2
tabb2=strarr(701)
;------------------------------------

grille

endif


end








;*******************************************************************************
;*******************************************************************************
pro ev_event,ev
;*******************************************************************************
;*******************************************************************************

widget_control,ev.id,get_uvalue=uv
common nb,n
common nb2,m
common tablo,tabb
common top,changer_based0

common base,base0,error

if uv(0) eq 4 then begin
  widget_control,uv(1),get_value=m
;  print, "m: ",m
  tabb[1081]=m
endif

if uv(0) eq 3 then begin
  ;widget_control,nb_rack,set_uvalue=[3,rack_nb,nb_rack,pos0,incr]
  para =DialNewValue(TYPE='t_para',NAME='changer_file')
  ;help,para,/struc
  ;print,para
  widget_control,uv(2),get_value=nr
  nr1=nr-1
  tabb[1082]=nr
  pos_0=para.changer_one(nr1)
  incr=para.changer_inc(nr1)
  m=long(para.changer_nb(nr1))
;for test only: m=17
;m=17
  tabb[1081]=m
  widget_control,uv(1),set_value=m
  ;widget_control,uv(3),set_value=pos_0
  ;widget_control,uv(4),set_value=inc
endif


if uv(0) eq 2 then begin
  widget_control,ev.top,/destroy
endif


if uv(0) eq 1 then begin    
	widget_control,uv(2),get_value=nr
	tabb[1082]=nr
	widget_control,uv(1),get_value=m
	tabb[1080]=m

	if (m[0] gt 0) and (m[0] le 100) then begin
;-------------------------------------------------------------------------------
;------------------------------------ BASE CREATION ----------------------------

	;---------------- ERROR ------------------
	err=' '
	widget_control,error,set_value=string(err)
	;-----------------------------------------

par=strarr(23)

base0=widget_base(group_leader=changer_based0,title='Command File (3)',/column,/align_center)

base1=widget_base(base0,/column)
base11=widget_base(base1,/align_center)	
base12=widget_base(base1,/align_center)
base13=widget_base(base1)
	
base2=widget_base(base0,/row)
base21=widget_base(base2,/column)	
base22=widget_base(base2,/column)
base23=widget_base(base2,/column)

base3=widget_base(base1,/align_center)

lab1=widget_label(base11,frame=5,value='enter names of samples')	
;lab2=widget_label(base12,value='*****************')
		
		for i=1,m[0] do begin
	
	txt=string(format='(I2)',i)
	pos=widget_text(base21,xsize=2,value=txt)
	par(i)=widget_text(base22,xsize=18)	
	widget_control,par(i),/editable
	
		endfor

but3=widget_button(base23,frame=10,value='measurement table',uvalue=[25])
but2=widget_button(base23,value='new')
but1=widget_button(base23,value='close')

;lambda=cw_field(base3,xsize=2,title='wavelength:',value='8')

		
	widget_control,base0,/realize
	
	
;-------------------------------------------------------------------------------
;-------------------------------- EVENTS ---------------------------------------

for i=1,m[0] do begin
	
	txt=string(format='(I2)',i)
	widget_control,par(i),set_uvalue=[i,par(i)]

endfor
;widget_control,lambda,set_uvalue=[26,lambda]

widget_control,but1,set_uvalue=[23,but1]
widget_control,but2,set_uvalue=[24,but2]
widget_control,but3,set_uvalue=[25,par]

;++++++++++++++++++++++++++++++++++++++++++++++++++++++
common wavelth,wav
wav=0

common check,chec
if chec eq 1 then begin
	nam[0]=tabb[1098]+'.cmd'
	openr,roro,nam[0],/get_lun

	while not (eof(roro)) do begin
		point_lun,-roro,deb
		readf,roro,read1
	
		wave=strpos(read1,'wavelength')
			if wave ge 0 then begin
			lamb=strmid(read1,wave+2,100)
			tabb[1099]=strtrim(lamb,2)
			wav=1
			widget_control,lambda,set_value=tabb[1099]

		
			endif
	endwhile
	close,roro
endif

;++++++++++++++++++++++++++++++++++++++++++++++++++++++

xmanager,'eve',base0,/just_reg

	
	
	
	
	
	
	
;---------- CONDITION TO QUIT IF n>22 ou n<1 -----------------------------------
	
	endif else begin
;------------------------ ERROR ------------------------------	
	err='*** out of range ***'
	widget_control,error,set_value=string(err)
;------------------------------------------------------------

	endelse




endif

end





;*******************************************************************************
;*******************************************************************************
pro rack
;*******************************************************************************
;*******************************************************************************

common tablo, tabb


;---------------------------- INITIALISATION -----------------------------------
tabb=strarr(1100)

;-------------------------------------------------------------------------------

common base,base0,error
common sa,sam
common top,changer_based0

base0=widget_base(group_leader=changer_based0,title='Command File (2)',/column)

base01=widget_label(base0,frame='5',value='choice of the rack')
;base02=widget_label(base0,value='*********************')

base1=widget_base(base0, /column)


err=string(format='(A25)','')
error=widget_label(base1,value=err)

;**** modified by roland *************************************************
nb_rack=cw_field(base1,xsize=2,title='rack #: ',/return_events)
rack_nb=cw_field(base1,xsize=2,title='# of positions on the rack: ', $
	/return_events)
;************************************************************************

base2=widget_base(base0,/align_center,/column)
;lab=widget_label(base2,value='***')

create=widget_button(base2,frame=10,xsize=240,value='sample table')

but=widget_button(base2,xsize=200,value='close')

;--------------- REALIZE THE WIDGETS ------------------------
widget_control,base0,/realize
;------------------------------------------------------------

pos0=0
incr=-10.
widget_control,rack_nb,set_uvalue=[4,rack_nb]
widget_control,nb_rack,set_uvalue=[3,rack_nb,nb_rack] ;,pos0,incr]
widget_control,error,set_uvalue=[6,error]

widget_control,but,set_uvalue=[2,but]
widget_control,create,set_uvalue=[1,rack_nb,nb_rack]  ;,pos0,incr]






;------------------ (DISPLAY NOTHING WHEN NO ERROR) ----------------------------
err=' '								
widget_control,error,set_value=string(err)
;-------------------------------------------------------------------------------





xmanager,'ev',base0,/just_reg,group_leader=changer_based0

end
	FUNCTION radial, w_in0, lim1, lim2, bins
;
; Produces radial integration of isotropic SANS data (with proper errors)

; lim1 and lim2 	define radial limits of integration
; bins 			defines number of points in outfile

;							JRS 30/3/00

	iprint=0	;shows debugging messages

	IF (iprint GT 0) THEN PRINT, 'Start radial:'
	
	take_datp, datp

;--------------------------------------------------------------------------
;Check dimensions of input workspaces

	sw=SIZE(w_in0)
	se=size(w_in0)
	IF (sw(0) EQ 3) THEN nruns=sw(3) ELSE nruns=1

	z_in0=datp.z
	e_in0=datp.e
	par=datp.p
	parv=datp.pv

	x0=par(13)
	y0=par(14)
	x_in0=datp.x-x0
	y_in0=datp.y-y0

	p_out=par
	p_out(13)=0.0
	p_out(14)=0.0	;write (0,0) beamcentre to output parameter block
	
	IF (nruns GT 1) THEN BEGIN
		pv_out=parv
		pv_out(13,*)=0.0
		pv_out(14,*)=0.0
	ENDIF
		
	IF (iprint GT 0) THEN PRINT,sw(1),sw(2)
	IF (iprint GT 0) THEN PRINT,'radial: End of "check dimensions" section'

;----------------------------------------------------------------------------
; Sort data

	w_buf=FLTARR(sw(1)*sw(2),nruns)
	e_buf=FLTARR(sw(1)*sw(2),nruns)
	r_buf=FLTARR(sw(1)*sw(2))
	ir=0
	FOR ix=0,sw(1)-1 DO BEGIN
		FOR iy=0,sw(2)-1 DO BEGIN
			r_buf(ir)=SQRT((x_in0(ix)^2)+(y_in0(iy)^2))
			w_buf(ir,*)=w_in0(ix,iy,*)
			e_buf(ir,*)=e_in0(ix,iy,*)
			ir=ir+1
		ENDFOR
	ENDFOR

	nx_in=sw(1)*sw(2)

	i=SORT(r_buf)
	w_buf1=w_buf
	e_buf1=e_buf
	r_buf1=w_buf
	FOR j=1,nruns DO BEGIN
		r_buf1(*,j-1)=r_buf(i)
		w_buf1(*,j-1)=w_buf(i,j-1)
		e_buf1(*,j-1)=e_buf(i,j-1)
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'radial: End of "sort data" section'

;-------------------------------------------------------------------------
;Perform radial average

	IF (N_ELEMENTS(bins) EQ 0) THEN bins=30.
	IF (N_ELEMENTS(lim2) EQ 0) THEN lim2=FIX(sw(1)-x0)
	IF (N_ELEMENTS(lim1) EQ 0) THEN lim1=5.

	bw=FLOAT((lim2-lim1)/FLOAT(bins))
	IF (iprint GT 0) THEN PRINT,'radial: bin width= ',bw

	rmax=r_buf1(nx_in-1,0)
	nx_out=bins
	r_out=(INDGEN(nx_out)*bw)+lim1

	w_out=FLTARR(nx_out,nruns)	& w_out(*,*)=0.
	e_out=FLTARR(nx_out,nruns)	& e_out(*,*)=-1.

	FOR g=1,nruns DO BEGIN
		i0=0
		FOR iQ=0,nx_out-1 DO BEGIN
			Q0=r_out(iQ)
			wsum=0.
			e2sum=0.
			n=0
			FOR i=i0,nx_in-1 DO BEGIN
				Q=r_buf1(i,g-1)
				IF (ABS(Q-Q0) LT bw/2.) THEN BEGIN
					IF(e_buf1(i,g-1) NE -1) THEN BEGIN
						wsum=wsum+w_buf1(i,g-1)
						e2sum=e2sum+e_buf1(i,g-1)^2
						n=n+1
					ENDIF 
				ENDIF ELSE IF (Q GE Q0+bw/2.) THEN GOTO, endloop
			ENDFOR
endloop:		i0=i
			IF (n GT 0) THEN BEGIN
				w_out(iQ,g-1)=wsum/n
				e_out(iQ,g-1)=sqrt(e2sum)/n
			ENDIF
		ENDFOR
	ENDFOR

; for multiple runs, define temperature as y-axis and arrange in ascending order
	
	IF (nruns GT 1) THEN BEGIN
		y_out=FLTARR(nruns)
		y_out(*)=parv(10,*)
		datp.y_tit='Temperature (K)'
		i=SORT(y_out)
		y_out=y_out(i)
		pv_out(*,*)=pv_out(*,i)
		w_out(*,*)=w_out(*,i)
		e_out(*,*)=e_out(*,i)
	ENDIF
	
	IF (iprint GT 0) THEN PRINT,'radial: End of "rebin to constant R" section'

;-------------------------------------------------------------------------------
; return data

	IF (nruns EQ 1) THEN BEGIN
		w_out=REFORM(w_out)
		e_out=REFORM(e_out)
		datp.y_tit='Intensity'
	ENDIF ELSE BEGIN
		mod_datp, datp, "pv", pv_out
		mod_datp, datp, "y", y_out
	ENDELSE
	
	datp.x_tit='Radius (pixels)'
	
	slim1=STRTRIM(STRING(lim1),2)
lim10:	n=STRLEN(slim1)	& i=RSTRPOS(slim1,'0')
	IF (i EQ n-1) THEN BEGIN
		slim1=STRMID(slim1,0,n-1)
		GOTO, lim10
	ENDIF
	slim2=STRTRIM(STRING(lim2),2)
lim20:	n=STRLEN(slim2)	& i=RSTRPOS(slim2,'0')
	IF (i EQ n-1) THEN BEGIN
		slim2=STRMID(slim2,0,n-1)
		GOTO, lim20
	ENDIF
	sbins=STRTRIM(STRING(bins),2)
bins0:	n=STRLEN(sbins)	& i=RSTRPOS(sbins,'0')
	IF (i EQ n-1) THEN BEGIN
		sbins=STRMID(sbins,0,n-1)
		GOTO, bins0
	ENDIF

	datp.other_tit=datp.other_tit+' -ra('+slim1+','+slim2+','+sbins+')'
		
	mod_datp, datp, "x", r_out
	mod_datp, datp, "e", e_out
	mod_datp, datp, "p", p_out	

finished:
	give_datp, datp

	RETURN, w_out
	END

	
;***************************************;

pro interpol,x_in,w_in,w_out,E,t,i            ,E_IN,E_OUT
;
; Do interpolation
;
  m=(w_in(t,*)-w_in(t-1,*))/(x_in(t)-x_in(t-1))
  b= w_in(t,*)-m*x_in(t)
  w_out  (i,*)=m*E+b

  if n_elements(e_out) gt 1 then begin
    r=(e_in(t,*)^2+e_in(t-1,*)^2)/(x_in(t)-x_in(t-1))
    s= e_in(t,*)^2  + r*x_in(t)
    e_out  (i,*)=SQRT(r*E+s)
  endif
  i=i+1
end

;***************************************;

pro calculate,Estep,x_in,w_in,w_out,E,t,i,nch ,E_IN,E_OUT
;
; Average over values within E..E+Estep
;
  counter=0
  e_out(i,*)=e_out(i,*)^2
  while (t lt nch-1) and (x_in(t) lt E+Estep)  do begin     
    w_out(i,*)=w_out(i,*)+w_in(t,*)
    if n_elements(e_out) gt 1 then e_out(i,*)=e_out(i,*)+e_in(t,*)^2
    t=t+1
    counter=counter+1
  endwhile
  w_out(i,*)=w_out(i,*)/counter
  if n_elements(e_out) gt 1 then e_out(i,*)=SQRT(e_out(i,*))/counter
  i=i+1
end
;***************************************;

pro starter,Estep,x_in,w_in,w_out,E,t,i       ,E_IN,E_OUT
;
; Find starting point
;
  while (x_in(t) lt E) do t=t+1
  while (x_in(t)-E) gt Estep do begin
    if t eq 0 then w_out(t,*)=0 $
    else interpol,x_in,w_in,w_out,E,t,i       ,E_IN,E_OUT
    E=E+Estep
  endwhile
end



function ebin,in_wk,Emin,Emax,Estep
;
; Bin with given Emin,Emx,Estep
;
@mac.in 
my_check=size(in_wk)

  if my_check(0) lt 1 then  begin
     P_MUS,'mus_cannon'
     mess='Workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
   endif

  if strpos(his(two),'t2e') lt 0 then begin
     P_MUS,'mus_cannon'
     mess='Input workspace not in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
  endif

  P_MUS,'mus_shot'
  nch=my_check(1)
  nang=my_check(2)
;
; Arguments reasonable ?
;
  if Emin gt Emax then begin
    E=Emax
    Emax=Emin
    Emin=E
  endif $
  else E=Emin
    if (Estep lt 0) then Estep=-Estep 
      if Estep gt (Emax-Emin) $
      or Estep eq 0 then Estep=max(x_in)-min(x_in)/nch
  length=round((Emax-Emin)/Estep)+1
  if length gt (3.*nch) then Estep=(Emax-Emin)/(3.*nch)
  w_out=fltarr(round((Emax-Emin)/Estep)+1,nang)
  x_out=fltarr(round((Emax-Emin)/Estep)+1)
  IF n_elements(e_in) eq n_elements(w_in) then E_OUT=w_out else E_OUT=0
  i=0 
  t=0
;
; Main program
;
  starter,Estep,x_in,w_in,w_out,E,t,i                ,E_IN,E_OUT
  repeat begin
    if (x_in(t)-E) gt Estep $
      then interpol,x_in,w_in,w_out,E,t,i            ,E_IN,E_OUT $
      else calculate,Estep,x_in,w_in,w_out,E,t,i,nch ,E_IN,E_OUT
    E=E+Estep
  endrep until E gt Emax
  c=findgen(round((Emax-Emin)/Estep)+1)
  x_out=Emin+Estep*c
  y_out=y_in
  p_out(30)=p_in(30)
  p_out(19)=round((Emax-Emin)/Estep)+1
@mac.out
  return,w_out
end

;***************************************;

pro eventhandler_bin_event, event
;
; Operations following widget events
;
common binwid, min_label,min_slider,max_label,max_slider,step_label, $
         step_slider,w_in_slider,w_out_slider,maxx,maxws,winsli, $
         Emin,Emax,Estep,sd   
common arns,av_epp,ep
@lamp.cbk
@dons.cbk
  widget_control, event.id, get_uvalue=p
;
  case p of 'done' :  begin 
;
;            Conversion to output format
;
      widget_control,min_label,get_value=min_b
      widget_control,max_label,get_value=max_b
      widget_control,step_label,get_value=step_b
      widget_control,w_in_slider,get_value=win_b
      widget_control,w_out_slider,get_value=wout_b
      min_bs =strtrim(strmid(min_b,6,7),2)
      max_bs =strtrim(strmid(max_b,6,7),2)
      step_bs=strtrim(strmid(step_b,7,7),2)
      win_bs =strtrim(string(win_b),2)
      wout_bs=strtrim(string(wout_b),2)
;
;            Execute BIN_W call
;
      rhs='=ebin(w'+win_bs +','+min_bs +','+max_bs + ',' +step_bs +')'
      lhs='w'+wout_bs
      comy=strarr(1)
      comy(0)=lhs+rhs
      xicuter,comy(0)
      widget_control,event.top,/destroy
      end
;
     'abort': widget_control,event.top,/destroy
;
     'w_in' : begin
; 
;            Check whether input workspace is full,
;            set output slider
;
      widget_control,w_in_slider, get_value=s
;      s=ws_full(s)
      widget_control, w_in_slider, set_value=s  
      if s eq maxws then $
        widget_control,w_out_slider,set_value=ws_full(s-1)+1 $
      else widget_control,w_out_slider,set_value=s+1
      winsli=s
      update1
      end

     'w_out': widget_control,event.id,get_value=t 

     'min'  : begin 
;
;           Read out Emin, Emax; is Emin < Emax ?
;           set label values
;
      widget_control,event.id,get_value=s 
      widget_control,max_slider,get_value=t
      if t le s then begin
        widget_control,max_slider,set_value=maxx
        widget_control,max_label,set_value='max = '+ $
          strtrim(string(Emax,format='(f10.2)'),2)
      endif
      widget_control,min_label,set_value='min = '+ $
        strtrim(string(Estep(s-1),format='(f10.2)'),2)
      end

     'max'  : begin
;
      widget_control,event.id,get_value=t
      widget_control,min_slider,get_value=s
      if t le s then begin $
        widget_control,max_slider,set_value=maxx
        widget_control,max_label,set_value='max = '+ $
          strtrim(string(Emax,format='(f10.2)'),2)
      endif $
      else widget_control,max_label,set_value='max = '+ $
        strtrim(string(Estep(t-1),format='(f10.2)'),2)                   
      end
;
   'step' : begin
;
;           Read out Estep
;
      widget_control,step_slider,get_value=s 
      dummy=(1./5.)*sd+s*((5.*sd-(1./5.)*sd)/maxx)
      widget_control,step_label,set_value='step = '+ $
        strtrim(string(dummy,format='(f10.4)'),2)
      end
  endcase
end

;-----------------------------------------------------------

;***************************************;


;***************************************;

pro update1
;
; Updates slider and label values
;
common binwid
common arns,av_epp,ep
@lamp.cbk
@dons.cbk
two=winsli
@mac.in

my_check=size(w_in)

  if my_check(0) lt 0 then   begin
     widget_control,min_label,set_value='No valid data'  
     widget_control,max_label,set_value='No valid data'  
     widget_control,step_label,set_value='No valid data'  
     mess='Input workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return
  endif
  if strpos(his(two),'t2e') lt 0 then begin
     widget_control,min_label,set_value='No valid data'  
     widget_control,max_label,set_value='No valid data'  
     widget_control,step_label,set_value='No valid data'  
     mess='Input workspace not in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return
  endif
     widget_control,bad_id=iii,l_message,set_value='ok'

  nch=my_check(1)
  nang=my_check(2)
; Calculate ranges of the sliders
;
  Estep  =fltarr(100)
  Emax   =x_in(nch-1)
  if (81.799/p_in(21)^2) gt 3*p_in(11)/11.6 then Emin=-81.799/p_in(21)^2 $
  else Emin=-3*p_in(11)/11.6
  if x_in(0) gt Emin then Emin=x_in(0)
  a=findgen(maxx)
  Estep=Emin+a*(Emax-Emin)/(maxx-1)
  if nch-1 ge p_in(9) then $
    sd=round((x_in(fix(p_in(9))+1)-x_in(fix(p_in(9))))*1000.)/1000. $
  else sd=0.01
;
; Set values of sliders and labels
;
  widget_control,min_slider,set_value=1
  widget_control,min_label,set_value='Emin = '+ $
    strtrim(string(Emin,format='(f10.2)'),2)
  widget_control,max_slider,set_value=maxx
  widget_control,max_label,set_value='Emax = '+ $
    strtrim(string(Emax,format='(f10.2)'),2)
  widget_control,step_slider, $
    set_value=round(maxx/6.)
  widget_control,step_slider,get_value=s
  dummy=(1./5.)*sd+s*((5.*sd-(1./5.)*sd)/maxx)
  widget_control,step_label,set_value='Estep = ' $ 
    +strtrim(string(dummy,format='(f10.4)'),2)
end

;--------------------------------------------------------------------------


pro rbin,ws=in_wk
;
; Widget window for the call of BIN_W
;
common binwid, min_label,min_slider,max_label,max_slider,step_label, $
         step_slider,w_in_slider,w_out_slider,maxx,maxws,winsli, $
         Emin,Emax,Estep,sd           
common arns,av_epp,ep
@lamp.cbk
@dons.cbk
  maxws=20
  maxx=100.
;
; Keyword check
;
;  if keyword_set(in_wk) then begin
;    two=in_wk
;    winsli=ws_full(in_wk)
;  endif $
;  else begin
;    two=maxws
;    winsli=ws_full(maxws)
;  endelse
;  two=winsli
@mac.in
emax=1.0
emin=-1.0
if n_elements(x_in) gt 1 then begin
emax=max(x_in)
emin=min(x_in)
endif

;
; Create and realize window
;
  winsli=1
  base     =widget_base (xsize=350, title='Rebin in Energy', $
     /column,space=20)
  head     =widget_label(base,value='REBINING OF SPECTRA',/frame)
  buttons  =widget_base(base,/row,/frame,space=245)
  wkspace  =widget_base(base,/row,/frame,space=105)
  Erange   =widget_base (base,/column,/frame)
  steprange=widget_base (base,/column,/frame)
;
  done_button =widget_button(buttons,value='done',uvalue='done')
  abort_button=widget_button(buttons,value='abort',uvalue='abort')
;
  w_in_slider =widget_slider(wkspace, title='workspace #(in)',$
    minimum=1,maximum=maxws,uvalue='w_in')
  w_out_slider=widget_slider(wkspace,title='workspace #(out)',$
    minimum=1,maximum=maxws,uvalue='w_out')
  widget_control,w_in_slider,set_value=winsli 
  if winsli eq maxws then $
    widget_control,w_out_slider,set_value=ws_full(winsli-1)+1 $
  else widget_control,w_out_slider,set_value=winsli+1
;
  range=widget_label(Erange, value='E-RANGE')
  min_label   =widget_label(Erange)
  min_slider  =widget_slider(Erange,uvalue='min',minimum=1,$
    maximum=maxx,/suppress_value)
  max_label   =widget_label(Erange) 
  max_slider  =widget_slider(Erange,uvalue='max',minimum=1,$
    maximum=maxx,/suppress_value)
;
  st_label   =widget_label(steprange,value='STEPWIDTH') 
  step_label =widget_label(steprange,value='step')
  step_slider=widget_slider(steprange,uvalue='step',/suppress_value)
;  update1
;
  bid=sys_dep      ('DYNLAB',base,1)
  widget_control,base,group_leader=lamp_b1,/realize
  xmanager,'eventhandler_bin',base
end

; $Id: rb_routines.pro,v 1.12 2001/01/15 22:28:10 scottm Exp $
;
; Copyright (c) 1999-2001, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.

;The rotuines in this file were created for use by READ_BINARY and
;BINARY_TEMPLATE.  The "rb_" prefix used on the routine names
;stands for Read_Binary, but the routines are used by binary_template
;also.

function rb_dim_str, dims, num_dims
;COMPILE_OPT hidden, strictarr
;
;Assemble a dimension string from the strings in DIMS.
;A dimension string is like '[640, 512]', and can have
;variables or expressions in it, e.g. '[xsize, ysize].'
;
if num_dims eq 0 then begin
    result = 'scalar'
    end $
else begin
    result = '['
    for i=0,num_dims-1 do begin
        result = result + strtrim(dims[i], 2)
        if i lt num_dims-1 then $
            result = result + ', '
        end
    result = result + ']'
    end
return, result
end
;--------------------------------------------------------------------
function rb_is_integral, val
;COMPILE_OPT hidden, strictarr
;
;Purpose: test value to see if it is an integer.
;
tname = size(val, /tname)

if tname eq 'BYTE' $
or tname eq 'INT' $
or tname eq 'LONG' $
or tname eq 'UINT' $
or tname eq 'ULONG' $
or tname eq 'LONG64' $
or tname eq 'ULONG64' then $
    return, 1

return, 0
end
;--------------------------------------------------------------------
function rb_template_is_valid, rb_template, edit=edit, msg=msg
;COMPILE_OPT hidden, strictarr
;
;Purpose: return 1 if template is valid, else return 0.
;Also return a message string via the MSG keyword.
;
;If keword EDIT is set, test template for use with the template
;editor, BINARY_TEMPLATE, else test the template for use with
;READ_BINARY.
;
;Note: some variables in this routine are named with an
;"rb_" prefix.  This is to help avoid clashes with field
;names specified in the template.  "rb_" stands for
;"Read_Binary".
;
msg = 'Template is invalid.'

if n_elements(rb_template) gt 1 then begin
    msg = 'Template cannot be an array.'
    return, 0
    end

if size(rb_template, /tname) ne 'STRUCT' then begin
    msg = 'Template must be a structure.'
    case size(rb_template, /tname) of
        'OBJREF':
        'POINTER':
        'STRING':
        'UNDEFINED': msg = 'Supplied template is undefined.'
        else: begin
            if rb_template eq 0 then $
                msg = 'Template is zero.'
            end
        endcase
    return, 0
    end
;
;Make sure 'version' field is present.
;
tag_names_found = tag_names(rb_template)
void = where(tag_names_found eq 'VERSION', count)
if count ne 1 then begin
    msg = 'Version field is missing from template.'
    return, 0
    end
;
;Check the rest of the fields in the template.
;
case rb_template.version of
    1.0: begin
        tag_names_required = strupcase([ $
            'endian', $
            'fieldCount', $
            'Typecodes', $
            'Names', $
            'Offsets', $
            'NumDims', $
            'Dimensions', $
            'reverseflags', $
            'AbsoluteFlags', $
            'ReturnFlags', $
            'VerifyFlags', $
            'VerifyVals' $
            ])
        if keyword_set(edit) then begin
            tag_names_required = [ $
                tag_names_required, $
                strupcase([ $
                    'TemplateName', $
                    'DimAllowFormulas', $
                    'OffsetAllowFormulas' $
                    ]) $
                ]
            end
        end
    else: begin
        msg = 'The only recognized template version is: 1.0.'
        return, 0
        end
    endcase

for i=0,n_elements(tag_names_required)-1 do begin
    void = where(tag_names_found eq tag_names_required[i], count)
    if count ne 1 then begin
        msg = tag_names_required[i] + ' field missing from template.'
        return, 0
        end
    end

if size(rb_template.names, /tname) ne 'STRING' then begin
    msg = 'Invalid template: Names must be of type STRING.'
    return, 0
    end

if keyword_set(edit) then begin
    if size(rb_template.templatename, /tname) ne 'STRING' then begin
        msg = 'Invalid template: TemplateName must be of type STRING.'
        return, 0
        end
    if n_elements(rb_template.templatename) gt 1 then begin
        msg = 'Invalid template: TemplateName cannot have more than ' $
            + 'one element.'
        return, 0
        end
    end

if size(rb_template.offsets, /tname) ne 'STRING' then begin
    msg = 'Invalid template: Offsets must STRING expressions.'
    return, 0
    end

if size(rb_template.dimensions, /tname) ne 'STRING' then begin
    msg = 'Invalid template: Dimensions must be STRING expressions.'
    return, 0
    end

if size(rb_template.verifyvals, /tname) ne 'STRING' then begin
    msg = 'Invalid template: VerifyVals must be STRING expressions.'
    return, 0
    end

if n_elements(rb_template.endian) gt 1 then begin
    msg = 'Invalid template: Endian specification cannot have more ' + $
        'than one element.'
    return, 0
    end

if not rb_is_integral(rb_template.fieldCount) then begin
    msg = 'Invalid template: FieldCount is not an integer.'
    return, 0
    end

if rb_template.fieldCount lt 1 then begin
    msg = 'Invalid template: FieldCount is less than 1.'
    return, 0
    end

if not rb_is_integral(rb_template.Typecodes) then begin
    msg = 'Invalid template: Typecodes must be integers.'
    return, 0
    end
if not rb_is_integral(rb_template.NumDims) then begin
    msg = 'Invalid template: NumDims must be integers.'
    return, 0
    end
if not rb_is_integral(rb_template.reverseflags) then begin
    msg = 'Invalid template: ReverseFlags must be integers.'
    return, 0
    end
if not rb_is_integral(rb_template.absoluteflags) then begin
    msg = 'Invalid template: AbsoluteFlags must be integers.'
    return, 0
    end
if not rb_is_integral(rb_template.ReturnFlags) then begin
    msg = 'Invalid template: ReturnFlags must be integers.'
    return, 0
    end
if not rb_is_integral(rb_template.VerifyFlags) then begin
    msg = 'Invalid template: VerifyFlags must be integers.'
    return, 0
    end

if keyword_set(edit) then begin
    if not rb_is_integral(rb_template.DimAllowFormulas) then begin
        msg = 'Invalid template: DimAllowFormulas must be integers.'
        return, 0
        end
    if not rb_is_integral(rb_template.OffsetAllowFormulas) then begin
        msg = 'Invalid template: OffsetAllowFormulas must be integers.'
        return, 0
        end
    end

if n_elements(rb_template.Typecodes) $
ne rb_template.fieldCount then begin
    msg = 'Invalid template: number of Typecodes does ' + $
        'not match FieldCount.'
    return, 0
    end
if n_elements(rb_template.Names) $
ne rb_template.fieldCount then begin
    msg = 'Invalid template: number of Names does ' + $
        'not match FieldCount.'
    return, 0
    end
if n_elements(rb_template.Offsets) $
ne rb_template.fieldCount then begin
    msg = 'Invalid template: number of Offsets does ' + $
        'not match FieldCount.'
    return, 0
    end
if n_elements(rb_template.NumDims) $
ne rb_template.fieldCount then begin
    msg = 'Invalid template: number of NumDims does ' + $
        'not match FieldCount.'
    return, 0
    end

siz = size(rb_template.Dimensions)
if siz[0] lt 2 then begin
    msg = 'Invalid template: Dimensions field must be a 2D array.'
    return, 0
    end
if siz[1] ne rb_template.fieldCount then begin
    msg = $
        'Invalid template: 1st dimension of Dimensions array ' + $
            'should be same as FieldCount.'
    return, 0
    end
if siz[2] ne 8 then begin
    msg = $
        'Invalid template: Dimensions'' 2nd dimension must be 8.'
    return, 0
    end
siz = size(rb_template.reverseflags)
if siz[0] lt 2 then begin
    msg = $
        'Invalid template: ReverseFlags field must have two dimensions.'
    return, 0
    end
if siz[1] ne rb_template.fieldCount then begin
    msg = $
        'Invalid template: 1st dimension of reverseflags array ' + $
            'should be same as FieldCount.'
    return, 0
    end
if siz[2] ne 8 then begin
    msg = $
        'Invalid template: ReverseFlags''s 2nd dimension must be 8.'
    return, 0
    end
if n_elements(rb_template.absoluteflags) $
ne rb_template.fieldCount then begin
    msg = $
        'Invalid template: number of AbsoluteFlags does ' + $
            'not match FieldCount.'
    return, 0
    end
if n_elements(rb_template.ReturnFlags) $
ne rb_template.fieldCount then begin
    msg = $
        'Invalid template: number of ReturnFlags does ' + $
            'not match FieldCount.'
    return, 0
    end
if n_elements(rb_template.VerifyFlags) $
ne rb_template.fieldCount then begin
    msg = $
        'Invalid template: number of VerifyFlags does ' + $
            'not match FieldCount.'
    return, 0
    end

if keyword_set(edit) then begin
    if n_elements(rb_template.dimallowformulas) $
    ne rb_template.fieldCount then begin
        msg = $
            'Invalid template: number of dimallowformulas does ' + $
                'not match FieldCount.'
        return, 0
        end
    if n_elements(rb_template.offsetallowformulas) $
    ne rb_template.fieldCount then begin
        msg = $
            'Invalid template: number of offsetallowformulas does ' + $
                'not match FieldCount.'
        return, 0
        end
    end

if n_elements(rb_template.verifyvals) $
ne rb_template.fieldCount then begin
    msg = $
        'Invalid template: number of verifyvals does ' + $
            'not match FieldCount.'
    return, 0
    end

if not keyword_set(edit) then begin
    returns_indx = where(rb_template.ReturnFlags ne 0)
    if returns_indx[0] eq -1 then begin
        msg = 'Invalid template: no fields are set to be returned.'
        return, 0
        end
    end

for rb_i=0,rb_template.fieldcount-1 do begin
;
;   Check field name syntax.
;
    if rb_template.names[rb_i] eq '' then begin
        msg = 'Invalid template: names[' $
            + strcompress(rb_i, /remove_all) $
            + '] is blank.'
        return, 0
        end
    if strpos(strupcase(rb_template.names[rb_i]), 'RB_') ne -1 $
    or strpos(strupcase(rb_template.names[rb_i]), 'BT_') ne -1 then begin
        msg = 'Invalid template: Invalid field name ' $
            + strupcase(rb_template.names[rb_i]) $
            + '. ("RB_" and "BT_" not allowed.)'
        return, 0
        end
    message, /reset ; clear !error_state
    if not execute(rb_template.names[rb_i] + ' = 0b', 1) then begin
        msg = [ $
            'Invalid template: field name ' $
                + strupcase(rb_template.names[rb_i]) $
                + ' is invalid.', $
            '(' + !error_state.msg + ')' $
            ]
        return, 0
        end
;
;   Check offset syntax.
;
    if strpos(strupcase(rb_template.offsets[rb_i]), 'RB_') ne -1 $
    or strpos(strupcase(rb_template.offsets[rb_i]), 'BT_') ne -1 then begin
        msg = 'Invalid template: offset for field ' $
            + strupcase(rb_template.names[rb_i]) $
            + ' is invalid. ("RB_" and "BT_" not allowed.)'
        return, 0
        end

    if rb_template.absoluteflags[rb_i] eq 0 then begin
        if strmid(rb_template.offsets[rb_i], 0, 1) ne '<' $
        and strmid(rb_template.offsets[rb_i], 0, 1) ne '>' then begin
            msg = 'Invalid template: relative offset should start with ' $
                + '">" or "<".'
            return, 0
            end
        end

    message, /reset ; clear !error_state
    void = execute( $
        'void = ' $
            + strmid( $
                rb_template.offsets[rb_i], $
                ([1, 0])[rb_template.absoluteflags[rb_i]] $
                ), $
        1 $
        )
    if !error_state.name eq 'IDL_M_BADSYNTAX' $
    or !error_state.name eq 'IDL_M_ILLOP' $
    or !error_state.name eq 'IDL_M_ILLCHAR' then begin
        msg = [ $
            'Invalid template: offset for field ' $
                + strupcase(rb_template.names[rb_i]) $
                + ' is invalid.', $
            '(' + !error_state.msg + ')' $
            ]
        return, 0
        end
;
;   Check dimensions syntax.
;
    if rb_template.numdims[rb_i] gt 0 then begin
        if max(strpos( $
            strupcase(rb_template.dimensions[rb_i, *]), $
            'RB_' $
            )) ne -1 $
        or max(strpos( $
            strupcase(rb_template.dimensions[rb_i, *]), $
            'BT_' $
            )) ne -1 $
        then begin
            msg = 'Invalid template: a dimension for field ' $
                + strupcase(rb_template.names[rb_i]) $
                + ' is invalid. ("RB_" and "BT_" not allowed.)'
            return, 0
            end
        message, /reset ; clear !error_state
        void = execute( $
            'void = ' $
                + rb_dim_str( $
                    rb_template.dimensions[rb_i, *], $
                    rb_template.numdims[rb_i] $
                    ), $
            1 $
            )
        if !error_state.name eq 'IDL_M_BADSYNTAX' $
        or !error_state.name eq 'IDL_M_ILLOP' $
        or !error_state.name eq 'IDL_M_ILLCHAR' then begin
            msg = [ $
                'Invalid template: dimensions for field ' $
                    + strupcase(rb_template.names[rb_i]) $
                    + ' are invalid.', $
                '(' + !error_state.msg + ')' $
                ]
            return, 0
            end
        end
;
;   Check verify value syntax.
;
    if rb_template.VerifyFlags[rb_i] eq 1 then begin
        if strpos(strupcase(rb_template.verifyvals[rb_i]), 'RB_') ne -1 $
        or strpos(strupcase(rb_template.verifyvals[rb_i]), 'BT_') ne -1 $
        then begin
            msg = 'Invalid template: verifyval expression for field ' $
                + strupcase(rb_template.names[rb_i]) $
                + ' is invalid. ("RB_" and "BT_" not allowed.)'
            return, 0
            end
        message, /reset ; clear !error_state
        void = execute('void = ' + rb_template.verifyvals[rb_i], 1)
        if !error_state.name eq 'IDL_M_BADSYNTAX' $
        or !error_state.name eq 'IDL_M_ILLOP' $
        or !error_state.name eq 'IDL_M_ILLCHAR' then begin
            msg = [ $
                'Invalid template: the verification value for field ' $
                    + strupcase(rb_template.names[rb_i]) $
                    + ' is invalid.', $
                '(' + !error_state.msg + ')' $
                ]
            return, 0
            end
        end
    end
;
;Check that specified field names are unique.
;
if n_elements( $
    uniq(strupcase(rb_template.names), sort(strupcase(rb_template.names))) $
    ) $
ne rb_template.fieldcount then begin
    msg = 'Invalid template: specified field names are not unique.'
    return, 0
    end
;
msg = 'Template is valid.'
return, 1
end

; dummy stub so that rb_routines can be compiled using RESOLVE_ROUTINE
pro rb_routines
	;COMPILE_OPT hidden
end
function rd1600,fil

OPENR,in,fil,/get_lun
w=fltarr(1600)
readf,in,w
free_lun,in
RETURN,w

END
FUNCTION rd20 , INST_GRP,PATH,FILENAME,STATUS,DATP ,COMP=comp
;******* ****
;**
common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
common c_rdid , dzap, pzap, pzip
common d20, bad_d20 ,flag_d20, wav_d20, psd_d20  

IF n_elements(PATHCAL )   eq 0 then BEGIN
  if (sys_dep('MACHINE') eq 'mac') THEN BEGIN
    PATHCAL =P_LAMBDA()+':CALIBRATION:'
    HELP,PATHCAL
  ENDIF ELSE PATHCAL =P_LAMBDA()+'/CALIBRATION/'
ENDIF
IF n_elements(INST_GRP)   le 1 then return,1
CATCH,stat & if stat ne 0 then begin CATCH,/cancel & print,!err_string
				     FREE_LUN,in   & RETURN, WOUT & endif

;help,inst_grp
;print,inst_grp
;HELP,PATH,FILENAME,STATUS,DATP,comp
;PRINT,PATH,FILENAME,STATUS,DATP
WOUT=0 & WT='' & DATE='' & OT='' & XT='' & YT='' & ZT='' & PP=0 & PTXT=''
         XX=0  & YY  =0  & ZZ=0  & NN=0  & PV=0  & EE=0

scan=0 & Vri=-1 & text='' & exper='' & partx='' & param=0  & parai=0 & vparm=0
pthv=PATH
INST=strlowcase(INST_GRP)
IF n_elements(FILENAME) gt 1 THEN BEGIN NIMG=fix(FILENAME(1)) &
FILENAME=FILENAME(0)
			     ENDIF ELSE NIMG=0

remember=0


IF (INST(0) EQ 'd16') OR   (INST(0) EQ 'db21') THEN INST(1) ='dif'
IF  INST(3) EQ '1'  THEN IF INST(1) EQ 'dif'   THEN IF INST(0) NE 'd1a' THEN  $
						    IF INST(0) NE 'd2b' THEN  $
		    pthv=pthv+INST(0)+'_'+strmid(FILENAME,1,1)+sys_dep('DIVIDER')
;Compressed or not!
;---------- -- ---
form=findfile(pthv+FILENAME+'.Z',count=cprs)
IF cprs GT 0  THEN BEGIN
	IF pthv NE '' THEN bid=sys_dep      ('COPY',FILENAME+'.Z',pthv) ELSE cprs=0
			   bid=sys_dep      ('UN_Z',FILENAME+'.Z')       &   pthv=''
ENDIF

ON_IOERROR,misopen
STATUS=11
GET_LUN,in & if in gt 125 then begin free_lun,125 & free_lun,126 & endif
OPENR,in,pthv+FILENAME

	STATUS=13
	line  ='' & deco='' & form='' & cnt=0L & bid=0L & numor=0L & vpb=0L
	linet =['']
	ON_IOERROR,misread
	
	READF,in,line     & READF,in,deco   & READF,in,line
	SKIPLINE,in,deco,numor,nvers=nvers

;	Contact and date
;	------- --- ----	
	READF,in,deco  & cnt=80
	SKIPLINE,in,deco,cnt
	nbl  =cnt/80      & IF nbl*80 lt cnt  THEN  nbl=nbl+1
	text =strarr(nbl) & READF,in,text   & READF,in,form
	form =strmid(form,0,2)
     	insv =strlowcase(strtrim(strmid(text(0),0,4),2))

	IF  form ne 'VV'  THEN BEGIN
	 WHILE form ne 'AA' DO BEGIN READF,in,form & form=strmid(form,0,2)
	 ENDWHILE

;	 Experiment
;	 ----------	
	 READF,in,deco     & SKIPLINE,in,deco,cnt
	 nbl  =cnt/80      & IF nbl*80 lt cnt  THEN  nbl=nbl+1
	 exper=strarr(nbl) & READF,in,exper  & READF,in,form
	 form =strmid(form,0,2)
	ENDIF
;	Parameters
;	----------
	WHILE (form ne 'SS') AND (form ne 'VV') DO BEGIN
		
		READF,in,deco    & SKIPLINE,in,deco,cnt
		nbl  =cnt/80      & IF nbl*80 lt cnt  THEN  nbl=nbl+1
		IF form eq 'FF'  THEN BEGIN
 				      IF n_elements(par4)  gt 1 THEN par5=par4
 				      IF n_elements(par3)  gt 1 THEN par4=par3
 				      IF n_elements(par2)  gt 1 THEN par3=par2
 				      IF n_elements(par1)  gt 1 THEN par2=par1
				       IF n_elements(param) gt 1 THEN par1=param
;**** numor-bug fix Th.Hansen D20 ***********************
  IF n_elements(par1)  EQ 0 AND cnt EQ 30 AND numor GE 6815 AND numor LE 6840 THEN cnt=25 
;**** numor-bug fix Th.Hansen D20 ***********************
				      param=fltarr(cnt) 
		ENDIF ELSE $
		IF form eq 'II'  THEN parai=lonarr(cnt)   ELSE  $
		IF form eq 'AA'  THEN bidon=strarr(nbl)
	
		IF form eq 'AA'  THEN READF,in,bidon ELSE $
		IF form eq 'II'  THEN READF,in,parai ELSE $
;		IF form eq 'FF'  THEN READF,in,param
;**** numor-bug fix Th.Hansen D20 ***********************
		IF form eq 'FF'  THEN BEGIN
    IF numor GE 22274 AND nvers EQ 3 AND n_elements(par4) GT 1 AND n_elements(par5) LE 1 THEN BEGIN
      tmppar=fltarr(10)
      READF,in,tmppar
      param(0:9)=tmppar
      param(10:14) = 0
      READF,in,deco
      tmppar=fltarr(cnt-15)
      READF,in,tmppar
      param(15:cnt-1)=tmppar
    ENDIF ELSE READF,in,param
  ENDIF
;**** numor-bug fix Th.Hansen D20 ***********************
		READF,in,form
		form=strmid(form,0,2)
	
	ENDWHILE
	
	IF form eq 'SS' THEN BEGIN
;***	** **** ** **** **** ***** ---> DIF TOF
;***	** **** ** **** **** ***** ---> DIF TOF
;***	** **** ** **** **** ***** ---> DIF TOF

;	# scans
;	-------
	
	READF,in,deco     & READS,deco+' 0 0 0 0 0 0',bid,scan,bid,bid,bid,vpb
	SKIPVPAR,vpb,vpara, in
;**** numor-bug fix Th.Hansen May 97 D20 ***********************
IF N_ELEMENTS(par5) GT 25 THEN IF par5(25) EQ 972. THEN IF numor EQ 8131 THEN BEGIN
  READF,in,form  
  vpara=[vpara(0:10),vpara(12:25),0.]
ENDIF
;**** numor-bug fix Th.Hansen May 97 D20 ***********************
	READF,in,form     & form=strmid(form,0,2)
	IF scan lt 1 THEN scan=1 ELSE scan=scan+1

	READF,in,deco     & SKIPLINE,in,deco,cnt
	
	forcl=1 & forcd=0
	
	CASE insv OF
	'd19' : begin   vp=10 & forcl=0
		IF scan gt 1 THEN BEGIN bad_d=intarr(512) & forcd=1 & cnt=cnt-1024 &
ENDIF
	        end
	'd9'  : begin   vp=10 & forcl=0 & end
	'db21': begin   vp=10 & forcl=0 & end
	'd16' : begin   vp=10 & end
	'd1b' : begin   vp=3  & end
	else  : begin   vp=0  & end
	ENDCASE

	IF vpb gt 0 THEN vp=0

	cnt  =  cnt-vp
	IF cnt  gt 1 THEN BEGIN
	IF vp   gt 0 THEN BEGIN vparm=lonarr(vp ,scan) & vpara=lonarr(vp) & ENDIF
	IF vpb  gt 0 THEN	vparm=fltarr(vpb,scan)                  ; ##### modified for D20 #######
 IF form eq 'JJ' THEN  form='II'
	IF scan gt   1    THEN $
	IF form eq 'II'   THEN buf=lonarr(cnt) $
			  ELSE buf=fltarr(cnt)

	IF form ne 'II'  THEN WOUT=fltarr(cnt,scan) $
		          ELSE IF   forcl  eq 0 THEN $
			       WOUT=intarr(cnt,scan) $
			  ELSE WOUT=lonarr(cnt,scan)
;	Read data
;	---- ----
	FOR i=0,(scan-1)<1299 DO   BEGIN   ;####### limitation necessary but not usefull: modif D20 ######
;   PRINT,'scan',i
	  IF  i gt 0 THEN BEGIN
     READF,in,line
     ;**** numor-bug fix Th.Hansen July 98 D20 ***********************
	    WHILE strpos(strlowcase(line), 'ssssssss') LT 0 DO BEGIN
;       print,'lin ',line
;       PRINT,strpos(strlowcase(line), 'ssssssss')
       READF,in,line
     ENDWHILE
;     PRINT,strpos(strlowcase(line), 'ssssssss')
     ;**** numor-bug fix Th.Hansen July 98 D20 ***********************
     READF,in,deco
;     print,'line',line
;     print,'deco',deco
		   READS,deco+' 0 0 0 0 0 0',bid,bid,bid,bid,bid,vpb
		   SKIPVPAR,vpb,vpara,in
     ;**** numor-bug fix Th.Hansen May 97 D20 ***********************
     IF N_ELEMENTS(par5) GT 25 THEN IF par5(25) EQ 972. THEN IF numor EQ 8131 THEN BEGIN
       READF,in,form  
;      print,'form',form
       vpara=[vpara(0:10),vpara(12:25),0.]
     ENDIF
     ;**** numor-bug fix Th.Hansen May 97 D20 ***********************
	   	READF,in,line   & READF,in,deco   & SKIPLINE,in,deco,bid
;     print,'line',line
	  ENDIF

	  IF vpb  gt 0 THEN   vparm(0,i)=vpara
;   help,vpb
	  IF scan le 1 THEN   BEGIN
	    IF vp eq 0 THEN BEGIN
       READF, in,         WOUT  
	    ENDIF ELSE BEGIN 
       READF, in, vpara , WOUT
	    		vparm(0,i)=vpara 
     ENDELSE
	  ENDIF	 ELSE  BEGIN
	    IF vp eq 0 THEN BEGIN
				   IF forcd eq 1   THEN BEGIN
         READF,in,bad_d,buf,bad_d 
						 ENDIF ELSE READF,in,buf
				 ENDIF ELSE BEGIN
				   IF forcd eq 1   THEN BEGIN
         READF,in,vpara,bad_d,buf,bad_d 
						 ENDIF ELSE READF,in,vpara,buf
	    		vparm(0,i)=vpara 
     ENDELSE
				
	    WOUT(0,i)=buf
;     plot,buf
 ;    HELP,buf
	  ENDELSE
	  Vri=i+1
	ENDFOR
 IF i LT scan THEN PRINT,'Not the entire Scan could be read in! (',i,' of',scan,' steps)'
	STATUS=0
	ENDIF
	ENDIF ELSE $
	IF form eq 'VV' THEN BEGIN
;***	** **** ** **** **** ***** --->  TAS
;***	** **** ** **** **** ***** --->  TAS
;***	** **** ** **** **** ***** --->  TAS

	NP=0
	READF,in,line & partx=[line]   &  READF,in,line
	linec='' & step='!!'
	WHILE strpos(line,'DATA_:') lt 0 DO BEGIN
	      IF strpos(line,'COMND:') eq 0 THEN BEGIN
	      			i=strpos(strlowcase(line),' np ')
	      			IF i  gt 0 THEN READS,strmid(line,i+4,5)+' 0' ,NP
	      			IF NP eq 0 THEN NP=100
	      			linec=strmid(strtrim(strcompress(line),2),7,50)
	      			ENDIF
	      IF strpos(line,'STEPS:') eq 0 THEN $
				step=strmid(strtrim(strmid(line,6,6),2),1,6)
	      partx=[partx,line]
	      READF,in,line
	ENDWHILE
	READF,in,line & line=strtrim(strcompress(line),2)+' ' & partx=[partx,line]
			l=strlen(line) & j=0
			FOR i=0,l-1 DO IF strmid(line,i,1) eq ' ' THEN BEGIN
					  linet=[linet,strmid(line,j,i-j)] & j=i+1 & ENDIF
			linet=linet(1:*)
	partx=strtrim(partx,2)

	IF NP  GT 0 THEN BEGIN
	   pos=0L & POINT_LUN,-in,pos
	   	    READF,in,line & line=strtrim(strcompress(line),2)
	   	    POINT_LUN, in,pos
	   cnt=0 & i=0 & WHILE i ge 0 DO BEGIN cnt=cnt+1 & i=strpos(line,' ',i+1)  &
ENDWHILE
	
	   ON_IOERROR,eofread
	   vparm=fltarr(cnt,NP)
	   READF,in,vparm
	   
	   IF vparm(0,NP-1) eq 100 THEN BEGIN   buf=fltarr(cnt)
	   					WHILE (1) DO BEGIN READF,in,buf
	   						     vparm=[[[vparm]],[buf]]
	   						     NP=NP+1 & ENDWHILE & ENDIF
	eofread:STATUS=0
	IF n_elements(vparm) gt 1 THEN BEGIN i=NP-1 & WHILE (i gt 0) and (vparm(0,i) eq 0) do i=i-1
						vparm=vparm(*,0:i>0)               & ENDIF
	ENDIF
	ENDIF
	
misread:FREE_LUN,in
	IF Vri gt 0 then IF Vri lt scan THEN begin scan=Vri & WOUT=WOUT(*,0:scan-1) & STATUS=0
					IF vp+vpb gt 0 THEN vparm=vparm(*,0:scan-1) & endif
IF cprs gt 0 THEN bid=sys_dep ('DELET', FILENAME)

misopen:

IF STATUS eq 0 THEN BEGIN
   CASE INST(1) OF
   'dif':  BEGIN
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' Run ' + FILENAME    ;+' User '    +strmid(text,4,10)  
           XT  ='Detector X .'
           YT  ='Detector Y .'
           IF    scan gt 1 THEN ZT ='Points' ELSE  ZT ='Counts'
	   IF   n_elements(param) ge 50      THEN  BEGIN
	   	   PP  = [param(3:6),param(17),param(45:47),param(34:36)]
	   	   PTXT= ['Phi    ','Chi    ','Omega  ','2*Theta',$
	   	   	  'Wave lenght',$
	   	   	  'Requested  Temperature  ',$
	   	   	  'Regulation Temperature  ',$
	   	   	  'Sample (K) Temperature  ',$
	   	   	  'Sample-Detector Distance',$
		   	  'Starting Angle ',$
		   	  'Angle Variation']
	   	   ENDIF     
    	   IF   n_elements(vparm) ge scan*2  THEN  NN=[vparm(0,0:scan-1),vparm(1,0:scan-1)] 
    	   IF   n_elements(vparm) ge scan*4  THEN  BEGIN
    	           ZZ  =[ vparm(2,0:scan-1)]
    	           PV  =[ vparm(3,0:scan-1)]
              	   	   ENDIF

     	   CASE INST(0) of
     	   'd19':  BEGIN IF n_elements(cal_d19) eq 0 THEN BEGIN
     	   		 ENDIF
     	   		 WOUT=reform(WOUT,512,n_elements(WOUT)/512,/overwrite)
		   END
	   'd9':   BEGIN IF scan gt 1 THEN WOUT=reform (WOUT,32,32,n_elements(WOUT)/32/32,/overwrite)$
	    	   	      	      ELSE WOUT=reform  (WOUT,32,32, /overwrite)
		   END
	   'd16':  BEGIN IF scan gt 1 THEN WOUT=reform (WOUT,64,16,n_elements(WOUT)/64/16,/overwrite)$
	    	   	      	      ELSE WOUT=reform  (WOUT,64,16, /overwrite)
					   WOUT=reverse (WOUT(1:62,1:14),1)
			 sw=size(WOUT) & if sw(0) eq 3 then sz=sz(sw(3)) else sz=1
			 IF n_elements(cal_d16) eq 0 THEN $
			    P_DID_CALOD, INST(0),INST(0)+'.cal', flg

			 IF n_elements(cal_d16) gt 1 THEN BEGIN WOUT=float(WOUT)
				FOR i=0,sz-1 DO WOUT(0,0,i)=WOUT(*,*,i)/cal_d16
				OT=OT+' /'+inf_d16(0) & ENDIF
		   ZZ  =numor
		   
		   if n_elements(pzip) eq 0 then pzip=0.
		   D2TH=pzip

		   PTXT= ['2*Theta   ','Omega     ','Chi       ','Phi       ',$
	   	   	  'Trans_X   ','Trans_Y   ','Rot       ','Beamstop  ',$
                          'Wave lenght             ','Requested  Temperature ',$
	   	   	  'Regulation Temperature  ','Sample (K) Temperature  ',$
	   	   	  'Sample-Detector Distance','Starting Angle          ',$
                          'Angle Variation         ','Angle Range            ',$                           
			  'PRESET                  ','Coupling factor         ',$
                          'Motor scanned           ','Nb points requested    ','Nb points saved         ',$ 
			  'Count:Monitor or Time   ','Type of T-regulation    ','Type ofMulti-meter     ',$
                          'Delta2th                ']
		   PP =[param(6),param(5),param(4),param(3),0,0,0,0,param(17),param(45:47),$
                        param(29),param(35:38),param(42),parai(3),parai(5:7),parai(12:13),pzip]
                        
                   scan_t=parai(3)
                   nbang=parai(4)
                   FOR i=1,nbang DO IF parai(23+i) eq 0 THEN parai(23+i)=24
;                  ***Lecture pour les differents motors scans*****
	 	   PP(parai(24)-1)=vparm(3)/1000.
                   IF nbang eq 1 THEN BEGIN ZZ=PP(2) & ENDIF
		   IF nbang eq 2 THEN BEGIN PP(parai(25)-1)=vparm(4)/1000. & ENDIF
                   IF nbang eq 3 THEN BEGIN PP(parai(25)-1)=vparm(4)/1000. &PP(parai(26)-1)=vparm(5)/1000. & ENDIF
                   IF parai(3) gt 0 THEN BEGIN ZZ=round(vparm(3)*100/1000.) 
                       IF parai(3) eq 1  THEN  ZT='gamma*100'   & IF parai(3) eq 2 THEN ZT='omega*100'
                       IF parai(3) eq 3  THEN  ZT='chi*100'     & IF parai(3) eq 4 THEN ZT='phi*100'
                       IF parai(3) eq 5  THEN  ZT='Trans_X*100' & IF parai(3) eq 6 THEN ZT='Trans_Y*100'
                       IF parai(3) eq 7  THEN  ZT='Rot*100'
		   ENDIF
                   IF PP(12) le 0 THEN PP(12)=100.
		   step = 180./!pi * .254/PP(12)
		   set_tolerance,tt,/get & if tt eq 0 then set_tolerance,step
         	   XX   = findgen(62)*step + PP(0) - 30.5*step
                   NN   = vparm(1)

;                  ****Write the file in a regular grid determined by the delta2th parameter***
                   IF D2TH gt 0.001 THEN BEGIN
                     S=ROUND((XX(n_elements(XX)-1)-XX(0))/D2TH)+2
                     WINT=fltarr(S,14) & FRAC=0 & XR=fltarr(S) & NN=lonarr(S)
;                    ***XR contains the 2th's rounded to the nearest step size**
		     tent=round(XX(0)/D2TH)*D2TH
                     if XX(0) gt tent then XR(0)=tent else XR(0)=tent-D2TH

                     for i=1,S-1   do XR(i)=XR(i-1)+D2TH  
;                    ****How to write the numor o the regular grid XR****
                     FOR i=0,61 do begin 
                      FOR J=0,S-2 do begin
                       IF (XX(i) gt XR(j)) and (XX(i) lt XR(j+1)) then begin
			   FRAC=(XX(i)-XR(j))/D2TH & FRAC1=1-FRAC
                           WINT(j,*)=FRAC1*WOUT(i,*)+WINT(j,*)	& WINT(j+1,*)=FRAC*WOUT(i,*)+WINT(j+1,*) 
                             NN(j)  =FRAC1*vparm(1) +  NN(j)	&   NN(j+1) =FRAC*vparm(1) +  NN(j+1) 
                       ENDIF
                      ENDFOR 
                     ENDFOR
		     XX=XR & WOUT=WINT 
                     EE = SQRT(WOUT)		; *** EE the error
                   ENDIF
                   XX=round(XX*10000) & XX=XX/10000.
           	   XT   ='2*theta'
		   END
	   'db21': BEGIN WOUT=reform(WOUT,128 ,128,/overwrite)
	   	   END
	   'd1b':  BEGIN
           	   XT  ='2*Theta'
           	   YT  ='Temperature'
           	   XX  =findgen(n_elements(WOUT)) * 79.8/(n_elements(WOUT)-1)+PP(3)
           	   YY  =param(46)
	   	   END
	   'd1a':  BEGIN nd=25. & IF n_elements(cal_d1a) eq 0 THEN $
				     P_DID_CALOD, INST(0),INST(0)+'.cal', flg
		   nj  = n_elements(WOUT)/(nd+4)
		   if long(nj) ne nj then RETURN,0
	   	   WOUT= reform(WOUT,(nd+4),nj ,/overwrite)
		   NN  = WOUT(0,0)
		   YY  = reform(WOUT(2,*))/1000.
   	   	   YT  ='Counts'
		   WOUT= WOUT(4:*,*)
		   IF n_elements(cal_d1a) eq nd THEN BEGIN wout=float(wout) &  FOR i=0,nj-1 $
						        DO wout(0,i)=wout(*,i)/cal_d1a & fct=1.
							OT=OT+' /'+inf_d1a(0)
		   ENDIF ELSE fct = -6.

		   XX  =fct*ang_d1a+YY(0)
		   WOUT= reform(WOUT,nd*nj,/overwrite)
		   IF nj gt 1 then BEGIN FOR i=1,nj-1 do  XX=[XX , fct*ang_d1a+YY(i)]
		   			 idx=sort (XX) &  XX =XX(idx) & WOUT=WOUT(idx)
		   			 XX =round(XX/0.05) & XX=XX*0.05
		   			 YY =param(46)
		   		   ENDIF
           	   XT  ='2*Theta'
	   	   END
	   'd2b':  BEGIN
;			*** initialize parameters ***
			nd=64. & D2TH = param(36) 
		        if n_elements(dzap) eq 0 then dzap=0
		        if n_elements(pzap) eq 0 then pzap=0
;			*** read calibration file (if present)
			pp=[pp,d2th, param(38)]
			ptxt=[ptxt, 'Delta 2*theta', 'Monitor']

			IF n_elements(cal_d2b) eq 0 THEN $
			   P_DID_CALOD, INST(0),INST(0)+'.cal', flg

;		       *** nj = number of points ***
		   vp  = parai(4)+2
		   nj  = n_elements(WOUT)/(nd+vp)
;		       *** rewrite WOUT in matrix form (69 cols, nj rows) ***
	   	   WOUT= reform(WOUT,(nd+vp),nj ,/overwrite)
		   NN  = WOUT(0,0)
;			*** YY = 2th values for detector 1 ***
		   YY  = reform(WOUT(2,*))/1000.
;			*** set titles ***
   	   	   YT  ='Counts'
		   XT  =' 2*Theta' 
;			*** reform WOUT to eliminate first vp values (not data) ***
		   WOUT= WOUT(vp:*,*)

;		   *** detector zapping algorithm ***
;		   *** definition of new calibration arrays (default: equal to old)
		   newcal_d2b=cal_d2b
		   newang_d2b=ang_d2b
		   newd=nd
;		   *** test if dzap contains real detectors **
		   idz=where(dzap ge 1 and dzap le 64)
;		   *** in case, eliminate spurious values ***
		   if idz(0) ne -1 then dzap=dzap(idz) else dzap=0
;		   *** is there something left? ***
		   SD=SIZE(dzap)

;		   *** test if pzap contains real points **
		   idz=where(pzap ge 1 and pzap le nj)
;		   *** in case, eliminate spurious values ***
		   if idz(0) ne -1 then pzap=pzap(idz) else pzap=0
;		   *** is there something left? ***
		   SP=SIZE(pzap)

;		   *** if dzap has something, do the following ***
		   if SD(0) gt 0 then BEGIN
;		     *** set all dud values and calibration to -999 ***
		     WOUT(dzap-1,*)=-999
		     newcal_d2b(dzap-1)=-999
;		     *** good values are those which do not contain -999 ***
		     GOOD=where(WOUT ne -999)
		     if GOOD(0) eq -1 then return, GOOD(0)

;		     *** cut out dud values from WOUT and calibrations ***
		     WOUT=WOUT(GOOD)
		     newang_d2b=ang_d2b(where(newcal_d2b ne -999))
		     newcal_d2b=cal_d2b(where(newcal_d2b ne -999))
;		     *** redefine the detector number
		     newd=(nd-n_elements(dzap))
;		     *** reform WOUT to proper format
		     WOUT=reform(WOUT,newd,nj ,/overwrite)
		   ENDIF

;		   *** if pzap has something, do the following ***
		   if SP(0) gt 0 then BEGIN
;		     *** set all dud values -999 ***
		     WOUT(*,pzap-1)=-999
;		     *** good values are those which do not contain -999 ***
		     GOOD=where(WOUT ne -999)
;		     *** cut out dud values from WOUT ***
		     WOUT=WOUT(GOOD)
;		     *** redefine the number of points
		     nj=(nj-n_elements(pzap))
;		     *** reform WOUT to proper format
		     WOUT=reform(WOUT,newd,nj ,/overwrite)
		   ENDIF
;			*** if calibration available, calibrate by dividing ***
		   
		   IF n_elements(cal_d2b) eq nd THEN BEGIN wout=float(wout) &  FOR i=0,nj-1 $
							DO wout(0,i)=wout(*,i)/newcal_d2b & fct=1.
							OT=OT+' /'+inf_d2b(0)
;		        *** fct*newang_d2b always newd values spaced by ~ -2.5 ***
		   ENDIF ELSE fct = -2.5
;			*** XX array of initial 2th for all detectors ***
		   XX  =fct*newang_d2b+YY(0)
;			*** reform WOUT to be a 1-line vector ***
		   WOUT= reform(WOUT,newd*nj,/overwrite)
;			*** create a XX array by adding up all 2th for all dets **
;			*** in the same order as in WOUT


;			*** do the following if there are at least 2 points ***
		   IF nj gt 1 then BEGIN FOR i=1,nj-1 do  XX=[XX , fct*newang_d2b+YY(i)]
;			*** sort the XX and WOUT arrays (idx is the index array) ***
		   			 idx=sort (XX) &  XX =XX(idx) & WOUT=WOUT(idx)
;			*** XR contains the 2th's rounded to the nearest step size ***
		   			 XR =round(XX/D2TH) & XR=XR*D2TH
;			*** GRID contains the fractional indices of XR into XX ***					 
					 GRID=(XR-XX)/D2TH+findgen(n_elements(XX))				
;			*** WINT is WOUT interpolated onto the fractional indices *** 
					 WINT=interpolate(WOUT,GRID)
;			*** reassign XX and WOUT
					 XX=XR
				         WOUT=WINT
;			*** YY is the temperature, EE the error
		   			 YY =param(46)
					 EE = SQRT(WOUT)
		   		   ENDIF
	   	   END
'd20':BEGIN ;############### D20 Specifications ###########################
	WOUT=WOUT>0
    nd=cnt
	DATI     = strmid(exper(5),20,18)
    day      = strmid(DATI,0,2)
    month    = strmid(DATI,3,3)
    year     = strmid(DATI,7,2)
    charpos=0
    IF  STRMID(year,0,1) GT '9' OR  STRMID(year,0,1) LT '0'  OR STRMID(year,1,1) GT '9' OR  STRMID(year,1,1) LT '0' THEN BEGIN 
			  	charpos=strpos(text(0),':',0)-2
			  	hour=strmid(text(0),charpos,2)
		  		hour=strmid('00'+hour,strlen(hour),2)
				  charpos=charpos+3
			  	secpos=strpos(text(0),':',charpos)
				  minute=strmid(text(0),charpos,secpos-charpos)
			  	minute=strmid('00'+minute,strlen(minute),2)
			  	second=strmid(text(0),secpos+1,2)
			  	second=strmid('00'+second,strlen(second),2)
			  	charpos=strpos(text(0),' ',secpos)+1
		  		secpos=strpos(text(0),'-',charpos)
				  day=strmid(text(0),charpos,secpos-charpos)
			  	day=strmid('00'+day,strlen(day),2)
			  	charpos=secpos+1
		 	  secpos=strpos(text(0),"-",charpos)
			  	month=strmid(text(0),charpos,secpos-charpos)
			  	month=strmid('   '+month,strlen(month),3)
			  	charpos=secpos+1
			  	year=strmid(text(0),charpos,2)
			  	year=strmid('00'+year,strlen(year),2)
						DATI=day+"-"+month+"-"+year+" "+hour+":"+minute+":"+second
    ENDIF
    IF nd EQ 1600 THEN BEGIN
				  IF total(WOUT(128:1599,*)) EQ 0 AND year EQ "96" THEN BEGIN     ; old PSD 128 cells
             WOUT  =  WOUT(0:127,*)
													nd=128
             if n_elements(vparm) lt 26.*scan then vparm=fltarr(26,scan)
      ENDIF
    ENDIF
    WOUT=float(WOUT)
    IF N_ELEMENTS(vparm) GE  1 THEN vparm=vparm(*,0:N_elements(WOUT(0,*))-1)
    nj = N_ELEMENTS(wout(0,*))
    EE  = WOUT/sqrt(1+WOUT)
	   IF n_elements(par5) eq 0 THEN BEGIN                          ; Numor bug fix
	       par5=par4
	       par4=par3
	       par3=0
	   ENDIF
    par1(51)=par1(51)/1000000.                                   ; CntTime in sec (raw data: microsec)
	   IF n_elements(par5) eq 25 THEN BEGIN                         ; Numor bug fix
	     par5=[par5(0:19),0.,0.,0.,0.,0.,par5(20:24)]
      param=[0.,param]
      FOR i=0,nj-1 Do wout(*,i)=[wout(nd-1,i),wout(0:nd-2,i)] 
	   ENDIF
 	  CntTime  = par1(51)
    proposal = strmid(exper(2),20 ,9)
  	 WT  =  ' '+strcompress(strmid(exper(0),20,40)) $
   	      +' '+strcompress(strmid(exper(3),20,40))
    OT = insv +' '+ DATI $
     	        +' User '+strmid(exper(1),20,8)$
     	  	     +' L.C.' +strmid(exper(4),20,7)$
		            +' Run'  +strcompress(string(numor)) 
    CASE month OF
       'Jan':  MON=1
       'Feb':  MON=2
       'Mar':  MON=3
       'Apr':  MON=4
       'May':  MON=5
       'Jun':  MON=6
       'Jul':  MON=7
       'Aug':  MON=8
       'Sep':  MON=9
       'Oct':  MON=10
       'Nov':  MON=11
       'Dec':  MON=12
    ENDCASE					
    IF par5(25) LT 963 THEN BEGIN                                  ; evt. missing reactor cycle
	  			par5(25)=year*10+ROUND(((mon-1.)*30.5+(day-1.))/366.*5.)
    ENDIF
    CYCLE = long(par5(25))
    IF N_ELEMENTS(inf_d20) EQ 0 THEN BEGIN
      IF CYCLE NE long(year*10+1+ROUND(((mon-1.)*30.5+(day-1.))/366.*4.)) THEN PRINT,"Cycle is",cycle," but probably should be",long(year*10+1+ROUND(((mon-1.)*30.5+(day-1.))/366.*4.))
    ENDIF
    if year le 60 then century=20 else century=19
    ;****** CHECK WAVELENGTH ************
    IF ROUND(10*par5(3)) LE 26 AND ROUND(10*par5(3)) GE 25 THEN BEGIN
      wav=2.52
      IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
        IF ROUND(par5(1)) NE   1 THEN PRINT,'2.52A, HOPG-Monochromator, Filters should be in but they are not'
        IF ROUND(par5(4)) NE  44 THEN PRINT,'2.52A, HOPG-Monochromator, TakeOff should be 44deg but it is at',ROUND(par5(4))
        IF ROUND(par5(5)) NE 120 THEN PRINT,'2.52A, HOPG-Monochromator, MonoChanger should be 120deg but it is at',ROUND(par5(5))
      ENDIF
    ENDIF ELSE BEGIN
      IF ROUND(10*par5(3)) LE 24 AND ROUND(10*par5(3)) GE  20 THEN BEGIN
        wav=2.41
        IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
          IF ROUND(par5(1)) NE   1 THEN PRINT,'2.41A, HOPG-Monochromator, Filters should be in but they are not'
          IF ROUND(par5(4)) NE  42 THEN PRINT,'2.41A, HOPG-Monochromator, TakeOff should be 42 deg but it is at',ROUND(par5(4))
          IF ROUND(par5(5)) NE 120 THEN PRINT,'2.41A, HOPG-Monochromator, MonoChanger should be 120 deg but it is at',ROUND(par5(5))
        ENDIF
      ENDIF ELSE BEGIN
        IF ROUND(10*par5(3)) LE 19 AND ROUND(10*par5(3)) GE 15 THEN BEGIN
          wav=1.36
          IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
            IF ROUND(par5(1)) NE   0 THEN PRINT,'1.36A, Cu-Monochromator, Filters should be out but they are not'
            IF ROUND(par5(4)) NE  44 THEN PRINT,'1.36A, Cu-Monochromator, TakeOff should be 44 deg but it is at',ROUND(par5(4))
            IF ROUND(par5(5)) NE 210 THEN PRINT,'1.36A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
          ENDIF
        ENDIF ELSE BEGIN
          IF ROUND(10*par5(3)) LE 13 AND ROUND(10*par5(3)) GE 10 THEN BEGIN
            wav=1.30
            IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
              IF ROUND(par5(1)) NE   0 THEN PRINT,'1.30A, Cu-Monochromator, Filters should be out but they are not'
              ;IF ROUND(par5(4)) NE  42 THEN PRINT,'1.30A, Cu-Monochromator, TakeOff should be 42 deg but it is at',ROUND(par5(4))
              ;IF ROUND(par5(5)) NE 210 THEN PRINT,'1.30A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
            ENDIF
          ENDIF ELSE BEGIN
            IF ROUND(100*par5(3)) LE 99 AND ROUND(100*par5(3)) GE 91 THEN BEGIN
              wav=0.94
              IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                IF ROUND(par5(1)) NE   0 THEN PRINT,'0.94A, Cu-Monochromator, Filters should be out but they are not'
                IF ROUND(par5(4)) NE  30 THEN PRINT,'0.94A, Cu-Monochromator, TakeOff should be 30 deg but it is at',ROUND(par5(4))
                IF ROUND(par5(5)) NE 210 THEN PRINT,'0.94A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
              ENDIF
            ENDIF ELSE BEGIN
              IF ROUND(100*par5(3)) LE 90 AND ROUND(100*par5(3)) GE 85 THEN BEGIN
                wav=0.88
                IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                  IF ROUND(par5(1)) NE   0 THEN PRINT,'0.88A, Cu-Monochromator, Filters should be out but they are not'
                  IF ROUND(par5(4)) NE  28 THEN PRINT,'0.88A, Cu-Monochromator, TakeOff should be 28 deg but it is at',ROUND(par5(4))
                  IF ROUND(par5(5)) NE 210 THEN PRINT,'0.88A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
                ENDIF
              ENDIF ELSE BEGIN
                IF ROUND(100*par5(3)) LE 84 AND ROUND(100*par5(3)) GE 70 THEN BEGIN
                  wav=0.82
                  IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                    IF ROUND(par5(1)) NE   0 THEN PRINT,'0.82A, Cu-Monochromator, Filters should be out but they are not'
                    IF ROUND(par5(4)) NE  26 THEN PRINT,'0.82A, Cu-Monochromator, TakeOff should be 28 deg but it is at',ROUND(par5(4))
                    IF ROUND(par5(5)) NE 210 THEN PRINT,'0.82A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
                  ENDIF
                ENDIF ELSE BEGIN
                  IF N_ELEMENTS(inf_d20) LE 1 THEN PRINT,'Do you really have a wavelength of',par5(3),' Angstroem?'
                ENDELSE
              ENDELSE
            ENDELSE
          ENDELSE
        ENDELSE
      ENDELSE
    ENDELSE
   ;########VVVVVVV Reading several flags form rdid.flag VVVVVVV######################
    IF N_ELEMENTS(flag_d20) LT 8 THEN flag,/noprint,old=flag_d20
				bad_flag=     flag_d20(0)
				interpol_flag=flag_d20(1)
				ang_flag=     flag_d20(2)
			 wav_flag=     flag_d20(3)
				normalize=    flag_d20(4)
				float_flag=   flag_d20(5)
				eff_flag  =   flag_d20(6)
				cor_flag=     flag_d20(7)
   ;########VVVVVV EFFICIENCY/Angle CALIBRATION VVVVVVVV######################

    IF N_ELEMENTS(inf_d20) EQ 0 THEN BEGIN
      inf_d20='autod20.cal'
    ENDIF ELSE IF N_ELEMENTS(inf_d20) EQ 1 THEN IF inf_d20 EQ 0 THEN inf_d20 ='autod20.cal'

    IF N_ELEMENTS(cal_d20) EQ 0 THEN BEGIN
      cal_d20=0
    ENDIF  

    default_cal = 0
    IF n_elements(inf_d20) EQ 0 THEN BEGIN
				  default_cal=1 
				ENDIF ELSE BEGIN
				  IF inf_d20(0) EQ 'autod20.cal' THEN BEGIN
						  default_cal=1
						ENDIF ELSE BEGIN
						    IF N_ELEMENTS(inf_d20) GE 3 THEN BEGIN
										  IF inf_d20(2) EQ 'autod20.cal' THEN BEGIN
												  default_cal=1
												ENDIF
										ENDIF
						ENDELSE
    ENDELSE
    IF default_cal EQ 1 AND (ang_flag EQ 1 OR eff_flag EQ 1) THEN BEGIN
				  IF N_ELEMENTS(inf_d20) EQ 0 THEN inf_d20=['autod20.cal','not loaded','autod20.cal']
				  count=N_ELEMENTS(inf_d20)
				  IF count LT 4 THEN BEGIN
PRINT,'Looking up for calibration files in ',PATHCAL
				    tmf     =PATHCAL
				    tmp     =findfile(tmf+inst(0)+'_????_??_??????.???',count=tmc) ; NEW calibration file names
				    if tmc gt 0 then filelist=strmid(tmp,strpos(tmp(0),inst(0)),22) else print,"Are you really on the right workstation (d20sgi.ill.fr)?"
					   IF N_ELEMENTS(filelist) LE 0 THEN BEGIN
					    	PRINT,'NO auto-calibration file found!'
					    	inf_d20=['','','']
					    	default_cal=0
					    	filelist=''
					   ENDIF else print,'Files in ~lambda/CALIBRATION ',filelist
        IF N_ELEMENTS(inf_d20) LT 2 THEN inf_d20=['autod20.cal','']
					   inf_d20=[inf_d20(0:1),'autod20.cal',STRING(filelist)]
				  ENDIF ELSE filelist= inf_d20(3:count-1)  ; NEW calibration file naming
      tmplist=filelist	
      tmp=where(STRMID(filelist,strlen(inst(0))+16,3) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3),count)
      if count le 0 then tmp=where(STRMID(filelist,strlen(inst(0))+16,2) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,2),count)
      if count le 0 then BEGIN
        tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,1),count)
        if count le 0 then tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*((wav+1)<9))),1,1),count)
        if count le 0 then tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*((wav-1)>0))),1,1),count)
      ENDIF
      if count gt 0 then begin
        tmplist=filelist(tmp)
        tmp=where(tmplist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3),count)
      endif
						IF count GT 0 THEN tmp=MAX(tmplist(tmp)) ELSE BEGIN
        print,'Apparently there is no calibration for ',wav,' Angstroem ',STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3)
					   tmp=WHERE(filelist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+STRMID(STRING(f='(I4)',1000+ROUND(100*par5(3))),1,3),count)
				  		IF count GT 0 THEN tmp=MAX(filelist(tmp)) ELSE tmp=MIN(filelist)
         print,tmp,' will be taken for calibration'
      ENDELSE
						calfile=STRCOMPRESS(tmp,/re)
			 ENDIF
ON_IOERROR,badmisread
;help,psd_d20
				IF bad_flag EQ 1  OR  bad_flag NE 1 THEN BEGIN
				   count=N_ELEMENTS(psd_d20)
							IF count LT 1 THEN psd_d20=['empty']
			  	 IF count LT 2 THEN BEGIN
				    	tmf     =PATHCAL ; P_LAMBDA()+'/BAD_CELLS/'
				    	tmp     =findfile(tmf+inst(0)+'_????_??_??????.bad',count=tmc) ; NEW  file names
				     if tmc gt 0 then badlist=strmid(tmp,strpos(tmp(0),inst(0)),22) else print,"Are you really on the right workstation (d20sgi.ill.fr)?"
					    IF N_ELEMENTS(badlist) LE 0 THEN BEGIN
						    	  PRINT,'NO bad cells file found!'
					  	  			psd_d20=['empty']
					  	  			bad_flag=0
									    badlist=''
					  	  ENDIF else print,'Creating new bad cells filelist',badlist
					  	  psd_d20=[string(psd_d20(0)),badlist]
					  ENDIF ELSE badlist=psd_d20(1:count-1)
       tmp=where(badlist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+'bad',count)
				  IF count GT 0 THEN tmp=MAX(badlist(tmp)) ELSE  tmp=MIN(badlist)
 						 IF psd_d20(0) NE tmp THEN BEGIN
            psd_d20(0)=tmp
            print,'data : ',PATHCAL,psd_d20(0)
								    bad_d20=rddat('data',PATHCAL,psd_d20(0),rddat_status,rddat_datp)
            print,bad_d20
								    PRINT,'New bad_cells file loaded : ',psd_d20(0)
       ENDIF
				ENDIF
badmisread:
				IF wav_flag EQ 1 THEN BEGIN
				      count=N_ELEMENTS(wav_d20)
			  	    IF count LT 1 THEN wav_d20=[0.,0.,0.]
			  	    IF count LT 4 THEN BEGIN
				    	tmf     =P_LAMBDA()+'/RIETVELD/'
				    	tmp     =findfile(tmf+'?????????.d20',count=tmc)
				    	if tmc gt 0 then filelist=LONG(strmid(tmp,strpos(tmp(0),'.d20')-9,9))

					    			IF N_ELEMENTS(filelist) LE 0 THEN BEGIN
						    		  PRINT,'NO wavelength/zeroshift file found!'
					  	  				wav_d20=[0.,0.,0.]
					  	  				bad_flag=0
										filelist=''
					  	  		ENDIF else print,'Creating newwavelength/zeroshift file list',filelist
					  	    wav_d20=[wav_d20(0:2),filelist]
					    	ENDIF ELSE filelist=wav_d20(1:count-1)
						    tmp=WHERE(filelist LE LONG(cycle)*1000000+numor,count)
						    IF count GT 0 THEN tmp=MAX(filelist(tmp)) ELSE tmp=MIN(filelist)
						    wav_d20(0)=LONG(tmp)
				      OPENR,tmp,tmf+STRING(STRCOMPRESS(wav_d20(0),/REMOVE_ALL))+'.d20',/get_lun
				      READF,tmp,line
				      READF,tmp,wav_d20(1:2)
				      FREE_LUN,tmp
						ENDIF
      ;help,inf_d20
      ;print,inf_d20
						IF N_ELEMENTS(inf_d20) ge 3 THEN IF N_ELEMENTS(calfile) GE 1 THEN IF calfile NE inf_d20(0) THEN IF inf_d20(2) EQ 'autod20.cal' THEN BEGIN
        inf_d20(2) = 'autochoice'
        P_DID_CALOD, INST(0),calfile, flg 
        inf_d20(2) = 'autod20.cal'
      ENDIF
      IF STRMID(inf_d20(1),37,8) LT '3' THEN wavelength=FLOAT(STRMID(inf_d20(1),37,8)) else wavelength=0
    ;####### Efficiency Correction by MULTIPLICATION with efficiency-CORRECTION data! ###########
    IF float_flag EQ 1 THEN WOUT=FLOAT(WOUT)
	   IF n_elements(cal_d20(*,0)) eq nd AND eff_flag EQ 1 THEN BEGIN 
      OT=OT+'*'+inf_d20(0)
      FOR i=0,nj-1 DO FOR j=0,nd-1 DO BEGIN 
        wout(j,i)=wout(j,i)*cal_d20(j,0) 
        EE(j,i)= EE(j,i)*cal_d20(j,0) 
      ENDFOR 
    ENDIF
    IF n_elements(cal_d20(*,0)) eq 0 THEN cal_d20=0
    IF float_flag NE 1 THEN BEGIN
      IF eff_flag EQ 1 OR normalize GT 0 THEN PRINT,'Attention : Workspace is NOT floating point, but it should be!'
    ENDIF

    SequenceType    = par1(0) 
    StroboType      = par1(40) 
    NbOfSegments    = par1(1)  
	   PV = fltarr(31,scan)
	   NN = fltarr(scan)
	   FOR i=0,scan-1 DO BEGIN
	       PV(0:4,i)   = par1(0:4)	
	       PV(5,i)     = par1(51)		    ; CntTime in sec.
	       PV(6:7,i)   = par5(26:27)	  ; RtrPower,D19
	       PV(8,i)     = par5(14)		    ; OS
	       PV(9:19,i)  = param(0:10) 	 ; SampEnv,TempValues,MotorValues,Voltmeter1
	       PV(20,i)    = (par5(12)<30)+(par5(13)<30) 	 ; hor.  MonoSlits
	       PV(21,i)    = (par5(10)<140)+(par5(11)<140) 	 ; vert. MonoSlits
	       PV(22,i)    = par5(18)+par5(19) 	 ; hor.  SampleSlits
	       PV(23,i)    = par5(16)+par5(17) 	 ; vert. SampleSlits
	       PV(24,i)    = 0.0		         ; TimeStep
	       PV(25:27,i) = par1(45:47)	  ; TimeSlice,TimeDelay,TimeWindow
	       PV(28,i)    = i             ; Slice_No or sub-numor, for scans it will contain the inner stepwidth (later on ...)
	       PV(29,i)    = numor
	       PV(30,i)    = par1(50)      ; monitor
	       NN(i)       = par1(50)
	   ENDFOR
	   IF nj LE 1 THEN NN = par1(50)
	   IF N_ELEMENTS(vparm) GE 1 THEN BEGIN
      IF N_ELEMENTS(vparm(*,0)) GE 26 THEN BEGIN                                 ; NOT Stroboscopie
	       PV(0:4,*)  = vparm(0:4,*) 
        PV(5:20,*) = vparm(6:21,*) 
        PV(5,*)    = PV(5,*)/1000000.                          ; CntTime in sec (not microsec)
		      NN(*)= (vparm(5,*) EQ 0.)*NN(*)+vparm(5,*)
		      PV(30,*)=nn(*)
      ENDIF ELSE BEGIN 
        IF N_ELEMENTS(vparm(*,0)) GE 5 THEN BEGIN
	         PV(25:27,*)= vparm(0:2,*)  
	         PV(5,*)    = vparm(4,*) /1000000.                          ; time in sec (not microsec)
		        NN(*)= (vparm(3,*) EQ 0.)*NN(*)/PV(5,0)*PV(5,*)+vparm(3,*) ; tot.monitor if slice-mon. zero 
          IF vparm(4,0) LT vparm(3,0) THEN BEGIN                     ; Monitor-time confusion in the reading of the 51st scaler
		          PV(5,*)    = vparm(3,*) /1000000.                        ; time in sec (not microsec)
					       NN(*)      = vparm(4,*)
            IF nvers EQ 2 THEN BEGIN
              brico=indgen(nj)*3
		  						  		brico=brico(WHERE(brico LT nj))
		            PV(26:27,brico)= vparm(0:1,brico)                                ; even more confusions
		            PV(25,brico)   = vparm(2,brico)                                  ; even more confusions
              brico=indgen(nj)*3+1
								    		brico=brico(WHERE(brico LT nj))
		            PV(25:26,brico)= vparm(1:2,brico)                                ; even more confusions
		            PV(27,brico)   = vparm(0,brico)                                  ; even more confusions
					  	    ENDIF
					  	  ENDIF
		        PV(30,*)=nn(*)
				    ENDIF
				  ENDELSE
				ENDIF
    IF cor_flag EQ 1 THEN IF Cycle LE 974 THEN IF cycle GE 973 THEN IF numor LE 20200 THEN IF numor GE 8451 THEN BEGIN
      IF StroboType EQ 0 THEN IF scan EQ 1 OR SequenceType NE 0 THEN BEGIN
        corname =P_LAMBDA()+'/MONITOR/'+STRCOMPRESS(STRING(LONG(cycle)), /REMOVE_ALL)+'.cor'
        OPENR,cor,corname,/get_lun
        READF,cor,corrections
        IF corrections GT 0 THEN BEGIN
	      	  cornum=fltarr(3,corrections)
	      			READF,cor,cornum
	      	ENDIF
        CLOSE,cor
		      FREE_LUN,cor
								corind=WHERE(cornum(0,*) EQ numor,corrections)
								IF corrections EQ 1 THEN BEGIN
								  PRINT,'Corrections will be applied: ',corname
								  cornum=cornum(1:2,corind)
          PV(30,*)=PV(30,*)-cornum(0)
          NN      =NN      -cornum(0)
          PV(5,*) =PV(5,*) -cornum(1)
								ENDIF ELSE PRINT,'Looked for corrections but found nothing',corrections
      ENDIF
				ENDIF
	   MotPar=fltarr(6)
	   MotTxt=['2*Theta/deg.     ','Omega  /deg.     ',$
	           'Chi    /deg.     ','Phi    /deg.     ',$
		          'Tr.1   /mm (horz)','Tr.2   /mm (vert)']
	   FOR i=0,5 DO BEGIN 
				  IF par1(12+i*5) EQ 0.0 THEN BEGIN
	       MotPar(i)=param(4+i) 
	       MotTxt(i)=MotTxt(i)+'     '
	     ENDIF ELSE BEGIN
	       MotPar(i)=par1(12+i*5)
	       MotTxt(i)=MotTxt(i)+'     '
      ENDELSE
				ENDFOR
    step_or_sub='Sub-Numor or Slice-No.  '
    ScanText=   'Unknown Scan Type       '                        
    IF  SequenceType eq  0 THEN ScanText='Single Data Acquisition '
    IF  SequenceType eq  1 THEN ScanText='Sequential Acquisition  '
    IF  SequenceType eq  2 THEN ScanText='Temperature Scan        '
    IF  SequenceType eq  3 THEN ScanText='2Theta Scan             '
    IF  SequenceType eq  4 THEN ScanText='Omega Scan              '
    IF  SequenceType eq  5 THEN ScanText='Chi Scan                '
    IF  SequenceType eq  6 THEN ScanText='Phi Scan                '
    IF  SequenceType eq  7 THEN ScanText='Translation 1 Scan      '
    IF  SequenceType eq  8 THEN ScanText='Translation 2 Scan      '
    IF  SequenceType eq  9 THEN ScanText='Other Scan              '
				inner=long(SequenceType)-2
    IF  SequenceType gt 10 THEN BEGIN
             ScanTextArray=['Sing.','Sequ.','Temp.','2Th. ','Omega','Chi  ','Phi  ','Tr.1 ','Tr.2 ','Seven','Else ']
             ScanText=ScanTextArray((long(SequenceType) /   10)<10)
             outertext=ScanText
             outer=(long(SequenceType)  /  10) - 2
             ScanText=ScanTextArray((long(SequenceType) mod   10)<10)
             innertext=ScanText
             inner=(long(SequenceType) mod 10) - 2
             ScanText=outerText+'/'+innertext+'coupled Scan '
    ENDIF
    IF inner GE 0 THEN BEGIN
				  PV(28,*)=par1(7+inner*5) 
						step_or_sub='Sub-Numor or Slice-No.  '
						step_or_sub='(inner) Scan Step-Width '
    ENDIF
	   PP  =[PV(0:30),par5(0:1),par5(3),$                   
		        StroboType,$      
		        par1(41),0,0,0,0]
    IF CntTime EQ 0.0 THEN BEGIN            ; IF Real Counting Time not measured
				  CntTime=PV(25,0)*PP(35)/8000000.      ; missing 51st scaler, 1 ACQ = 1 Slice (before modification)
						PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.)
				ENDIF
    IF CntTime LT 0.0 THEN BEGIN            ; Real Counting Time GE 1 hour: Value becomes negative
				  CntTime=PV(25,0)*PP(35)/8000000.*2.   ; 51st scaler present, 1 ACQ = 2 Slices (after modification)
						IF StroboType eq 0 THEN PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.*2.) ELSE PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.)
				ENDIF
				PP(5)=TOTAL(PV(5,*))                    ; Total counting time in fixed parameter 
				CntTime=PP(5)
    IF charpos NE 0 THEN BEGIN
				  day  = STRCOMPRESS(STRING(LONG(day)   -   LONG(CntTime)  /  86400),/remove_all)
				  hour  =STRCOMPRESS(STRING(LONG(hour)  -  (LONG(CntTime) MOD 86400)  /  3600),/remove_all)
				  minute=STRCOMPRESS(STRING(LONG(minute)- ((LONG(CntTime) MOD 86400) MOD 3600)  /  60),/remove_all)
				  second=STRCOMPRESS(STRING(LONG(second)-(((LONG(CntTime) MOD 86400) MOD 3600) MOD 60)),/remove_all)
      IF LONG(second) LT 0 THEN BEGIN
						  second = STRCOMPRESS(STRING(LONG(second)+60),/remove_all)
							 minute = STRCOMPRESS(STRING(LONG(minute)- 1),/remove_all)
						ENDIF
      IF LONG(minute) LT 0 THEN BEGIN
						  minute = STRCOMPRESS(STRING(LONG(minute)+60),/remove_all)
							 hour   = STRCOMPRESS(STRING(LONG(hour  )- 1),/remove_all)
						ENDIF
      IF LONG(hour  ) LT 0 THEN BEGIN
						  hour   = STRCOMPRESS(STRING(LONG(hour  )+60),/remove_all)
							 day    = STRCOMPRESS(STRING(LONG(day   )- 1),/remove_all)
						ENDIF
      IF LONG(day   ) LT 0 THEN BEGIN
						  second = STRCOMPRESS(STRING(0),/remove_all)
						  minute = STRCOMPRESS(STRING(0),/remove_all)
						  hour   = STRCOMPRESS(STRING(0),/remove_all)
							 day    = STRCOMPRESS(STRING(1),/remove_all)
						ENDIF
      day='00'+day
      day=strmid(day,strlen(day)-2,2)
      hour='00'+hour
      hour=strmid(hour,strlen(hour)-2,2)
      minute='00'+minute
      minute=strmid(minute,strlen(minute)-2,2)
      second='00'+second
      second=strmid(second,strlen(second)-2,2)
						DATI=day+"-"+month+"-"+year+""+hour+":"+minute+":"+second
      OT = insv   +' '+ DATI $
     	   +' User '+strmid(exper(1),20,8)$
     	  	+' L.C.' +strmid(exper(4),20,7);$
		       ;+' Run'  +strcompress(string(numor)) 
				ENDIF
    PTXT=[$
                  ScanText,   $
                 'Number of Segments      ','Segment Number          ',$
                 'Number of Data Sets     ','Data Set Number         ',$
                 'TOTAL Counting Time/s   ','Reactor Power / MW      ',$
                 'D19 State               ','OS closed/open (0/1)    ',$
                 'Sample Environment      ','Set Temperature         ',$
                 'Regulation Temperature  ','Sample Temperature      ',$
                  MotTxt(0:5),$
                 'Voltmeter1              ','hor. MonoSlits / mm     ',$
                 'vert. MonoSlits / mm    ','hor. SampleSlits / mm   ',$
                 'vert. SampleSlits / mm  ','Time Step               ',$
                 'Time Slice              ','Time Delay              ',$
                 'Time Window             ', step_or_sub              ,$
                 'Numor                   ','Original Monitor Counts ',$
                 'Incid. divergence alpha1','HOPG Filters IN/OUT     ',$
                 'Wavelength / Angstroem  ',$
                 'Stroboscopic Mode       ','Number of strob. Cycles ',$
                 'Calibration Wavelength/A','Raw Data TwoTheta Offset',$
                 'Correction Eff./Ang./Bad','Normalisation Mon./Time ']
    twotheta_offset=-32.2 ; Changed 7/11, before : -32.1876  
    tmparr=FINDGEN(nd)/10.
	   PP(38)= (n_elements(cal_d20) eq nd AND eff_flag EQ 1) 
	   IF ang_flag NE 0 AND n_elements(ang_d20) EQ nd AND n_elements(cal_d20) EQ nd THEN BEGIN 
	       PP(38)= PP(38)+2 
			     twotheta_offset = ang_d20(0)
        tmparr=ang_d20-twotheta_offset
        PP(38)= PP(38)+2*(n_elements(ang_d20) eq nd) 
        IF wav_flag NE 0 THEN IF Wavelength NE 0 THEN PP(36)=Wavelength
    ENDIF
    IF (TwoTheta_OffSet+PP(13) GE 10 AND nd EQ 1600) THEN TwoTheta_Offset=TwoTheta_Offset-66.666667
    PV(13,*)=TwoTheta_OffSet+PV(13,*)
    PP(13)  =TwoTheta_OffSet+PP(13)
    PP(37)  =TwoTheta_Offset
    XX      =PV(13,0)+tmparr
				tmp     =WHERE([SequenceType,long(SequenceType)/10,long(SequenceType) mod 10] eq 3,count)
	   IF count GE 1 THEN BEGIN
             XX=fltarr(nd,scan)
             FOR i=0,nd-1 DO XX(i,*)=PV(13,*)+tmparr(i)
    ENDIF
    XT  ='2*Theta'
    IF scan gt 1 THEN BEGIN 
             YY=findgen(scan) 
             IF StroboType le 0 THEN BEGIN
                IF (SequenceType) mod 10 GE  2 AND long(SequenceType) mod 10 LE 8 THEN YY(*) = PV(10+long(SequenceType) mod 10,*)
             ENDIF
    ENDIF ELSE YY = round(numor)
	   IF StroboType le 0 THEN YT='Steps' ELSE YT='Slices'
    IF scan le 1 THEN BEGIN
        YT = 'Counts' 
        IF normalize NE 0 THEN YT=YT+'*'+STRCOMPRESS(STRING(ROUND(normalize/PP(30))),/remove_all)+')'
    ENDIF ELSE BEGIN
        IF StroboType le 0 THEN YT=ScanText
	       IF MAX(YY)-MIN(YY) eq 0.0 THEN BEGIN
	         YY=indgen(scan)
	         IF StroboType le 0 THEN YT='Steps' ELSE YT='Slices'
        ENDIF
    ENDELSE
    IF  SequenceType gt 10 THEN BEGIN
             YT='Steps'
             YY=indgen(scan)
    ENDIF
	   IF scan le 1 THEN BEGIN
      ZT = 'Counts' 
      IF normalize NE 0 THEN ZT=ZT+'('+STRCOMPRESS(STRING(normalize),/remove_all)+')'
    ENDIF ELSE ZT  ='Numor' & ZZ=PV
    DATE=DATI

  w=wout

  zerocounters=WHERE(TOTAL(REFORM(wout,N_ELEMENTS(wout(*,0)),N_ELEMENTS(wout(0,*))),2) LE 0)
  tmp=N_ELEMENTS(ZeroCounters)
		NbOfZeroCounters=tmp
;  print,''
;  IF NbOfZeroCounters GE 1 THEN PRINT,' Zero ',STRMID(ZeroCounters(0:13<N_ELEMENTS(ZeroCounters)-1),8,4)
  tmp=0*ZeroCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN FOR i=0,NbOfZeroCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ ZeroCounters(i) THEN tmp(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN BEGIN
    ind=where(tmp,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(ZeroCounters(ind),8,4)
  ENDIF
  tmp=TOTAL(REFORM(w,N_ELEMENTS(w(*,0)),N_ELEMENTS(w(0,*))),2)
  ind=findgen(N_ELEMENTS(tmp)-4)+2

  smoothed=tmp
  smoothed(ind)=2./3.*(tmp(ind-1)+tmp(ind-1))-(tmp(ind-2)+tmp(ind-2))/6.>0

  tmp0=TOTAL(REFORM(EE,N_ELEMENTS(EE(*,0)),N_ELEMENTS(EE(0,*))),2)/SQRT(N_ELEMENTS(EE(0,*)))
  tmp1=tmp-tmp0
  tmp2=tmp+tmp0

  MCounters=2+WHERE(tmp2(ind) LT (tmp1(ind-2)+tmp1(ind+2))/2./1.06 AND tmp1(ind-1)/1.02 GT (3.*tmp2(ind-2)+tmp2(ind+2))/4. AND tmp1(ind+1)/1.02 GT (tmp2(ind-2)+3.*tmp2(ind+2))/4.,NbOfMCounters)
  IF NbOfMCounters GE 2 THEN MCounters=MCounters(SORT((tmp(MCounters+2)+tmp(MCounters+1)+tmp(MCounters)+tmp(MCounters-1)+tmp(MCounters-2))/((tmp(MCounters+1)+tmp(MCounters-1))/2.-tmp(MCounters))))
;  IF NbOfMCounters GE 1 THEN PRINT,' "M"  ', STRMID(MCounters(0:13<N_ELEMENTS(MCounters)-1),8,4)
  tmp0=0*MCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN FOR i=0,NbOfMCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ MCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(MCounters(ind0),8,4)
  ENDIF

  WCounters=2+WHERE(tmp1(ind)/1.06 GT (tmp2(ind-2)+tmp2(ind+2))/2. AND tmp2(ind-1) LT (3.*tmp1(ind-2)+tmp1(ind+2))/4./1.02 AND tmp2(ind+1) LT (tmp1(ind-2)+3.*tmp1(ind+2))/4./1.02,NbOfWCounters)
  IF NbOfWCounters GE 2 THEN WCounters=WCounters(SORT((tmp(WCounters+2)+tmp(WCounters+1)+tmp(WCounters)+tmp(WCounters-1)+tmp(WCounters-2))/(tmp(WCounters)-(tmp(WCounters+1)+tmp(WCounters-1))/2.)))
;  IF NbOfWCounters GE 1 THEN PRINT,' "W"  ', STRMID(WCounters(0:13<N_ELEMENTS(WCounters)-1),8,4)
  tmp0=0*WCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN FOR i=0,NbOfWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ WCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
 ;   IF count GE 1 THEN PRINT,' excl.', STRMID(WCounters(ind0),8,4)
  ENDIF

  ind=findgen(N_ELEMENTS(tmp)-4)+2

  LowCounters =2+WHERE(tmp(ind) LT (smoothed(ind)-4.*SQRT(smoothed(ind)>0))-ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.-ABS(tmp(ind-1)-tmp(ind+1))/2. AND tmp(ind) GT 0,NbOfLowCounters)
  IF NbOfLowCounters GE 2 THEN LowCounters=LowCounters(SORT(smoothed(LowCounters)/(smoothed(LowCounters)-tmp(LowCounters))))
;  IF NbOfLowCounters GE 1 THEN PRINT,' Low  ', STRMID(LowCounters(0:13<N_ELEMENTS(LowCounters)-1),8,4)
  tmp0=0*LoWCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN FOR i=0,NbOfLoWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ LoWCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(LoWCounters(ind0),8,4)
  ENDIF

  HighCounters =2+WHERE(tmp(ind) GT (smoothed(ind)+4.*SQRT(smoothed(ind)>0))+ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.+ABS(tmp(ind-1)-tmp(ind+1))/2.,NbOfHighCounters)
  IF NbOfHighCounters GE 2 THEN HighCounters=HighCounters(SORT(smoothed(HighCounters)/tmp((HighCounters)-smoothed(HighCounters))))
;  IF NbOfHighCounters GE 1 THEN PRINT,' High ', STRMID(HighCounters(0:13<N_ELEMENTS(HighCounters)-1),8,4)
  tmp0=0*HighCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN FOR i=0,NbOfHighCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ HighCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(HighCounters(ind0),8,4)
  ENDIF

    good_cells           =indgen(nd)
    IF bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1 THEN BEGIN
      PP(38)= PP(38)+4 
      good_cells(bad_d20)=-1
      good_cells           =good_cells(WHERE(good_cells GE 0))
    ENDIF
    IF (bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1) THEN BEGIN
        ZZ=[bad_d20]
    ENDIF ELSE ZZ=[0]
    IF N_ELEMENTS(bad_d20) GE 1 THEN ZZ=[bad_d20] ELSE ZZ=[0]
    IF interpol_flag EQ 1 THEN BEGIN
      IF (bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1) THEN BEGIN
        ;PRINT,'Bad cells will be excluded AND interpolated, numbers of bad cells in Z'
						  IF (N_ELEMENTS(ang_d20) NE nd OR ang_flag EQ 0 OR N_ELEMENTS(cal_d20) NE nd) THEN BEGIN ;noang
          PP(38)= PP(38)+8 
          IF N_ELEMENTS(WOUT(0,*)) GE N_ELEMENTS(XX(0,*)) THEN BEGIN  
            FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO BEGIN
								      WOUT(bad_d20,i)=interpol(WOUT(good_cells,i),XX(good_cells),XX(bad_d20))
								      EE  (bad_d20,i)=interpol(EE  (good_cells,i),XX(good_cells),XX(bad_d20))
						    		ENDFOR
          ENDIF ELSE BEGIN
						      WOUT(bad_d20,*)=interpol(WOUT(good_cells,*),XX(good_cells),XX(bad_d20))
						      EE  (bad_d20,*)=interpol(EE  (good_cells,*),XX(good_cells),XX(bad_d20))
						    ENDELSE
								ENDIF 
      ENDIF 
	     IF N_ELEMENTS(ang_d20) EQ nd AND N_ELEMENTS(cal_d20) EQ nd AND ang_flag EQ 1 THEN BEGIN
          PP(38)= PP(38)+8 
          IF N_ELEMENTS(WOUT(0,*)) GE N_ELEMENTS(XX(0,*)) THEN BEGIN
										  XXold=XX(good_cells)
												XX=XX(0)+findgen(nd)/10.
            FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO BEGIN
						    		  WOUT(*,i)=interpol(WOUT(good_cells,i),XXold,XX)
						    		  EE  (*,i)=interpol(EE  (good_cells,i),XXold,XX)
						    		ENDFOR
          ENDIF ELSE BEGIN
										  XXold=XX(good_cells)
												FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO XX(*,i)=XX(0,i)+findgen(nd)/10.
						      WOUT=interpol(WOUT,XXold,XX)
						      EE  =interpol(EE  ,XXold,XX)
					    	ENDELSE

								ENDIF;ang
				ENDIF ELSE BEGIN ; NO interpolation
				  IF bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1 THEN BEGIN
        ;PRINT,'Bad cells will be excluded and NOT interpolated, numbers of BAD cells in Z!'
        ;PRINT,'Attention, some macros may fail on irregular data (missing cells)!'
						  WOUT=WOUT(good_cells,*)
						  XX  =XX  (good_cells,*)
						  EE  =EE  (good_cells,*)
				  ENDIF
				ENDELSE
			 IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
						FOR i=0,scan-1 DO BEGIN
						  WOUT(*,i)=      WOUT(*,i)/ NN(i)*normalize
						  EE  (*,i)=      EE  (*,i) /NN(i)*normalize								
						ENDFOR
      par1(54)=par1(54)/par1(50)*normalize ; 2nd monitor
      normalization_factor=NN
      normalization_factor=NN/normalize
      normalization_factor=1./normalization_factor
						NN=NN*0+normalize
						PP(39)=normalize
      normalization_factor=NN/normalize
				ENDIF
    IF N_ELEMENTS(pv(0,*)) GT 1 THEN BEGIN
      ;help,NN
	  IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
        NN=[[REFORM(NN,1,1,N_ELEMENTS(NN))],[REFORM(PV(5,*)*normalization_factor,1,1,N_ELEMENTS(PV(5,*)))],[REFORM(PV(5,*)*0.+par1(54)*normalization_factor,1,1,N_ELEMENTS(PV(5,*)))]]
      ENDIF ELSE BEGIN
        NN=[[REFORM(NN,1,1,N_ELEMENTS(NN))],[REFORM(PV(5,*),1,1,N_ELEMENTS(PV(5,*)))],[REFORM(PV(5,*)*0.+par1(54),1,1,N_ELEMENTS(PV(5,*)))]]
      ENDELSE
    ENDIF ELSE BEGIN
	  IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
        NN=[[NN],[PV(5,*)*normalization_factor],[par1(54)*normalization_factor]]
        ; Mod. 4/2/98 Hansen: 2nd monitor
      ENDIF ELSE BEGIN
        NN=[[NN],[PV(5,*)],[par1(54)]] ; Mod. 4/2/98 Hansen: 2nd monitor
      ENDELSE
    ENDELSE
    IF float_flag EQ 0 THEN WOUT=LONG(WOUT)
    
    

	 END

	   else:
	   ENDCASE
	   END

   '3axes':BEGIN
   	   DATE=strmid   (partx(5),7,9)
   	   WT  =strmid(partx(2),7,11) +' '+linec
   	   OT  =insv +' '+partx(5)+' '+partx(2)+' Run ' + FILENAME
   	   XT  =strcompress(strmid(partx(6),7,69))
   	   YT  ='CNTS'
   	   PP  =fltarr(n_elements(partx))
   	   PTXT=partx
   	   PV  =vparm
   	   
   	   idx =where(linet eq 'CNTS') & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN WOUT=reform(vparm(idx,*)) ELSE WOUT=reform(vparm)
	   
   	   idx =where(linet eq 'M1')   & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN NN  =reform(vparm(idx,*))

   	   idx =where(linet eq step)   & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN BEGIN XX  =reform(vparm(idx,*))
   	   					     id  =sort(XX)
   	   					     XX  =XX  (id)
   	   					     WOUT=WOUT(id)
   	   					     IF n_elements(NN) gt 1  THEN  NN=NN(id)
   	   					     XT  =XT+' unit= '+step  &  ENDIF
	   EE  =sqrt(WOUT)
   	   END
   'tof':  BEGIN nd =0
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
           XT  ='Channels'
           YT  ='Angles'
	   ZT  ='Numor' & ZZ=numor

     	   CASE INST(0) of
     	   'in13':BEGIN wavel=2.23
		    IF (size(WOUT))(2) eq 74 THEN BEGIN  nd=70
			  IF n_elements(cal_in13) eq 0 THEN $
			     P_DID_CALOD, INST(0),INST(0)+'.cal', flg
			  YY=[round(param(0 :34)*100)/100.      ,.1,.2,$
			      round(param(0 :34)*100)/100.+0.001,.3,.4]
			  sx=(size(WOUT))(1)
			  NN=lonarr(sx,3)
			  NN(*,1)=WOUT(*,36)>1 & NN(*,2)=WOUT(*,73)>1
			  WOUT=float(WOUT)
			  FOR i=0 ,34 do WOUT(*,i)=WOUT(*,i)/NN(*,1)
			  FOR i=37,71 do WOUT(*,i)=WOUT(*,i)/NN(*,2)
			  NN(*,0)=round(total(NN)/sx)

			  idx =sort(YY) & WOUT=WOUT(*,idx) & YY=YY(idx)
					  WOUT=WOUT(*,4:*) & YY=YY(4:*)
			  WOUT=WOUT*NN(0,0)
			  IF n_elements(cal_in13) eq nd THEN BEGIN
				FOR i=0,nd-1 DO wout(0,i)=wout(*,i)/cal_in13(i)
				OT=OT+' /'+inf_in13(0)
			  ENDIF
			  XX  =findgen (sx)*par1(11)+par1(1)-par1(2)
			  YY  =4*!pi/wavel*sin(YY/2*!pi/180.)
           		  XT  ='Energy micro eV   (normalized)'
           		  YT  ='Q(0) pairs'
			  IF par1(8) gt 0 THEN BEGIN ZZ=(par1(9)+par1(10))/2
						     ZT='Temperature' & ENDIF
		    ENDIF ELSE $
		    IF (size(WOUT))(0) eq 1  THEN BEGIN  nd=35 & sx=1
		     	  NN  =WOUT(36)
			  WOUT=float(WOUT(0:34))
			  XX  =round(param(0 :34)*100)/100. & XX  =XX(sort(XX))
			  XX  =4*!pi/wavel*sin(XX/2*!pi/180.)
           		  XT  ='Q(0)'
			  YY=(par1(9)+par1(10))/2
			  YT  ='Counts'
		    ENDIF
		    IF nd gt 0 THEN BEGIN
			  EE  =sqrt(WOUT)
			  PP  =[13.,par1(0),par1(3),par1(1),par1(2),par1(11),wavel,par1(8),$
				par1(9),par1(10)]
			  PTXT=['Type  of scan      (index)   ','Duration of scan   (second)  ',$
				'Chopper frequency            ','Energy   center    (micro eV)',$
				'Energy half range  (micro eV)','Channel  width     (micro eV)',$
				'Wave lenght        (angstrom)','Requested  Temperature (Kelv)',$
				'Temperature at start         ','Temperature at end           ']
		    ENDIF
		  END
	   else:
	   ENDCASE
	   END
   'lss':  BEGIN
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
           XT  ='X detector'
           YT  ='Y detector'
	   END
   else:
   ENDCASE
   
   DATP={w_tit:WT ,x_tit:XT ,y_tit:YT ,z_tit:ZT ,other_tit:OT ,time:DATE,p:PP,par_txt:PTXT,$
         x:XX     ,y:yy     ,z:ZZ     ,n:NN     ,pv:PV        ,e:EE}
   
ENDIF

RETURN, WOUT
END
FUNCTION rdand0 , name , first ,last, extension
;********
;**
;** The call is w6=rdand0('khp',1216,1363,'.prf')

Wout=0
d=1
wout=rdrun(name+STRCOMPRESS(first,/RE)+extension,datp=d)
e=d.e
n=d.n
pv=d.pv
FOR i=first+1,last DO BEGIN
  w=rdrun(name+STRCOMPRESS(i,/RE)+extension,datp=d)
  Wout=[[Wout],[w]]
  IF N_ELEMENTS(d.e ) EQ N_ELEMENTS(w) THEN e= [ [e ] , [d.e ]]
  IF N_ELEMENTS(d.n ) GT 0             THEN n= [[[n ]],[[d.n ]]]
  IF N_ELEMENTS(d.pv) GT 0             THEN pv=[ [pv] , [d.pv]]
ENDFOR
mod_datp,d,'e',e
mod_datp,d,'n',n
mod_datp,d,'pv',pv
mod_datp,d,'y',INDGEN(last-first+1)+first
give_datp,d
return, Wout
end
FUNCTION rdand_isis, run1, run2, flip=step
; called from rdand for ISIS data. Concatenate data into w21. Read data into w'wi'
@lamp.cbk

	w21=0 & x21=0 & n21=0 & e21=0 & stati=0 & xcat=0
	IF (NOT KEYWORD_SET(step)) THEN step=1
	wi=one	& ws=STRTRIM(STRING(wi),2)

	p_did_getrun, run1, 21, status
	IF (status NE 0) THEN GOTO, finished
	sz=(SIZE(w21))(0)	& nruns=0
	FOR run=LONG(run1)+step,run2,step DO BEGIN
		p_did_getrun, run, wi, status
		IF (status NE 0) THEN GOTO, readerror
		IF (sz EQ 1) THEN BEGIN			; 1-dimensional data
			iii=EXECUTE('w21=[[w21],[w'+ws+']]')
			iii=EXECUTE('e21=[[e21],[e'+ws+']]')
			iii=EXECUTE('n21=[[n21],[n'+ws+']]')
		ENDIF ELSE IF (sz EQ 2) THEN BEGIN	; 2-dimensional data
			nx0=(SIZE(x21))(1) & iii=EXECUTE('nx1=(SIZE(x'+ws+'))(1)')
			IF (nx1 GT nx0) THEN BEGIN
				PRINT,'rdand_isis: error - first run must be the biggest'
				RETURN, 0
			ENDIF ELSE IF (nx1 LT nx0) THEN BEGIN
				xcat=1
				iii=EXECUTE('x'+ws+'=[x'+ws+',FLTARR(nx0-nx1)]')
				ny=N_ELEMENTS(y21)
				iii=EXECUTE('w'+ws+'=TEMPORARY([w'+ws+',FLTARR(nx0-nx1,ny)])')
				iii=EXECUTE('e'+ws+'=TEMPORARY([e'+ws+',FLTARR(nx0-nx1,ny)-1.])')
				ny=(SIZE(n21))(2)
				iii=EXECUTE('n'+ws+'=[n'+ws+',FLTARR(nx0-nx1,ny)]')
				iii=EXECUTE('x21=[ [x21] , [x'+ws+'] ]')
			ENDIF
			iii=EXECUTE('w21=TEMPORARY([[[w21]],[[w'+ws+']]])')
			iii=EXECUTE('e21=TEMPORARY([[[e21]],[[e'+ws+']]])')
			iii=EXECUTE('n21=[[[n21]],[[n'+ws+']]]')
		ENDIF
		iii=EXECUTE('pv21=[[pv21], [p'+ws+'] ]')
		nruns=nruns+1
		IF (rdstop(run1+step,run2,(run))) THEN run=run2+1
	ENDFOR
readerror:
	stati=run
	iii=EXECUTE('e'+ws+'= e21')
	iii=EXECUTE('n'+ws+'= n21')
	iii=EXECUTE('pv'+ws+'=pv21')
	iii=EXECUTE('p'+ws+'(4)='+STRTRIM(STRING(nruns),2))
	IF (sz EQ 1) THEN BEGIN
		iii=EXECUTE('y'+ws+'=REFORM(pv21(0,*))')
		y_tit(wi)='Run number'
	ENDIF ELSE IF (sz EQ 2 AND xcat EQ 1) THEN $
		iii=EXECUTE('x'+ws+'=x21')
finished:
	RETURN, w21
	END

function rdcon,n
;
; Macro (started 28/10/96 by TH.HANSEN) in order to effectuate a concatenating reading of multiple 
; numors
;
; Last modification 19-Jun-97 by Th.Hansen
;
IF n_params() ge 1 THEN BEGIN
  datp = 0
  w    = 0
  e    = 0
  x    = 0
  pv   = 0
  nn   = 0
  n = long (REFORM (n,n_elements(n)))
  FOR i=0,n_elements(n)-1 DO BEGIN
    wtmp = rdrun(n(i))
    take_datp,datptmp
    IF n_elements(w) le 1 THEN BEGIN
      w   = wtmp
      wt  = datptmp.w_tit		; choose a common title!
      IF i eq 0 THEN ot  = datptmp.other_tit	; choose a common title!
      p   = datptmp.p		; if there are differences in p, no concatenation possible
      pt  = datptmp.par_txt
      pv  = datptmp.pv
      e   = datptmp.e
      nn  = datptmp.n
      x   = datptmp.x		
      y   = datptmp.y		
      z   = datptmp.z
      xt  = datptmp.x_tit
      yt  = datptmp.y_tit
      zt  = datptmp.z_tit
      t   = datptmp.time
      IF n_elements(x) ne n_elements(wtmp) THEN BEGIN
        xtmptmp=wtmp*0.0
        FOR j=0,n_elements(wtmp(0,*))-1 DO xtmptmp(*,j)=x(*)
	x=xtmptmp
      ENDIF
      IF n_elements(y) ne n_elements(wtmp) THEN BEGIN
        ytmptmp=wtmp*0.0
        FOR j=0,n_elements(wtmp(*,0))-1 DO ytmptmp(j,*)=y(*)
	y=ytmptmp
      ENDIF
    ENDIF ELSE BEGIN
      etmp = datptmp.e
      xtmp = datptmp.x
      ytmp = datptmp.y
      ntmp = datptmp.n
      IF n_elements(xtmp) ne n_elements(wtmp) THEN BEGIN
        xtmptmp=wtmp*0.0
        FOR j=0,n_elements(wtmp(0,*))-1 DO xtmptmp(*,j)=xtmp(*)
	xtmp=xtmptmp
      ENDIF
      IF n_elements(ytmp) ne n_elements(wtmp) THEN BEGIN
        ytmptmp=wtmp*0.0
        FOR j=0,n_elements(wtmp(*,0))-1 DO ytmptmp(j,*)=ytmp(*)
	ytmp=ytmptmp
      ENDIF
      IF n_elements(w(*,0)) gt n_elements(wtmp(*,0)) THEN BEGIN
        wtmp=[wtmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
        etmp=[etmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
        xtmp=[xtmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
        ytmp=[ytmp,fltarr(n_elements(w(*,0))-n_elements(wtmp(*,0)),n_elements(wtmp(0,*)))]
      ENDIF
      IF n_elements(w(*,0)) lt n_elements(wtmp(*,0)) THEN BEGIN
        w   =[w,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
        e   =[e,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
        x   =[x,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
        y   =[y,fltarr(n_elements(wtmp(*,0))-n_elements(w(*,0)),n_elements(w(0,*)))]
      ENDIF
      w =   [[w] ,[wtmp      ]]
      e   = [[e] ,[etmp      ]]
      x   = [[x] ,[xtmp      ]]
      y   = [[y] ,[ytmp      ]]
      pv  = [[pv],[datptmp.pv]]
      nn  = [ nn , ntmp       ]
    ENDELSE
  ENDFOR
  mod_datp,datptmp,'w_tit', wt
  mod_datp,datptmp,'other_tit', ot+strcompress(string(round(n(i-1))))
  mod_datp,datptmp,'p', p
  mod_datp,datptmp,'par_txt', pt
  mod_datp,datptmp,'pv', pv
  mod_datp,datptmp,'e', e
  mod_datp,datptmp,'n', nn
  mod_datp,datptmp,'x', x
  mod_datp,datptmp,'y', y
  mod_datp,datptmp,'z', z
  mod_datp,datptmp,'x_tit', xt
  mod_datp,datptmp,'y_tit', yt
  mod_datp,datptmp,'z_tit', zt
  mod_datp,datptmp,'time', t
  give_datp,datptmp  
ENDIF
return,w
END
function rd_d2b, INST , PATH , FILENAME , STATUS , DATP
;******* *************  
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.
 DATA  =0
 STATUS=11
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

 ON_IOERROR, no_file
 OPENR,unit, PATH+FILENAME,/get_lun				;Open the data file

     STATUS=13
     ON_IOERROR, read_err
     wt=' '
     line=' '
     readf, unit , wt
     readf, unit , line

     IF strpos(line,'BANK') lt 0 THEN BEGIN  ; CASE .DAT FORMAT
;                                             *******************
        bidon=0 & zero= -220. & d2th= double(10.)
        reads, line, bidon, bidon, d2th
	readf, unit, zero
	readf, unit , line

	npoints=5000                ;make big array (2,5000) for data
	datall=intarr(2,npoints)
	ON_IOERROR, read_err2
	readf, unit, datall , format="(10(I2,I6))"

	print, "Table of data too small:",npoints

	read_err2:FREE_LUN,unit

	data=reform(datall(1,*))*1.
	err =reform(datall(0,*))*1.

	i=npoints-1
	WHILE data(i) le 0 DO  i=i-1
	data=data(0:i)
	err =err (0:i)
	npoints=i+1

	err=sqrt(data)/sqrt((err >.25))

     ENDIF ELSE BEGIN                        ; CASE .GSAS FORMAT
;                                             ********************
	npoints=0 & nlines=0 & nn=1 & zero= -220. & d2th= double(10.)
	vb1=0 & vb2=0
	line1=strmid(line, 4,80)
	line2=strmid(line,47,80)
	reads,line1, nn, npoints, nlines
	reads,line2+' -77 -77', zero, d2th, vb1, vb2
	d2th=d2th/100.
	zero=zero/100.

	if vb1 eq -77 then readf, unit , line ;one line to be read or not!


	datall=intarr(2,npoints)
	readf, unit, datall, format="(10(I2,I6))"

	data=reform(datall(1,*))*1.
	err=sqrt(data)/sqrt((datall(0,*)>.25))
     ENDELSE

	    xv       =  FINDGEN(npoints)*d2th+zero	;Normaly in data file
	    xt       =' 2 theta (degrees) '			;         .
	    par      = [        3.0       ,        5.5        ]	;	  .
	    ptxt     = ['First  parameter','Second parameter' ]	;	  .
	    pall     =  INDGEN(20,8)

      STATUS=0							;Status is ok
;     ********
      DATP={X:      xv,    $					;Pass those variables which were 
            W_TIT:  wt,    $ 				;read-in into the DATP structure
	           X_TIT:  xt,    $                   
	           P:      par,   $
	           PAR_TXT:ptxt,  $
            E:      err,        $
            N:      fltarr(npoints)+100000. , $
	           PV:     pall   }
;     **********************  					
	    

 RETURN, DATA
 read_err:  FREE_LUN,unit
 no_file: print,!err_string
 RETURN, DATA

 END
function rddat, INST , PATH , FILENAME , STATUS , DATP
  ;print,'rddat'
;******* *****
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).
PRINT, 'Filetype/Instrumentname:    ',inst(0)
IF N_ELEMENTS(inst) GT 1 THEN PRINT, 'Filegroup/Instrumentgroup: ',inst(1)
;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.
;**		  if FILENAME(1) exists,  this is the requested image number in the file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.

 common c_rdid , dzap, pzap, pzip ,pzup

 DATA  =0
 STATUS=11
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif
 IF n_elements(pzup) eq 0 THEN pzup=""				;Check sub-directory & filename
 MYFILE=FILENAME
 MYPATH=PATH
 IF strpos(strlowcase(MYFILE), 'cyc.res')  ge 0 THEN BEGIN
			  IF pzup ne "" THEN MYPATH=MYPATH+pzup+'/' $
					;ELSE MYPATH=MYPATH+strmid(MYFILE,0,5)+'-'+strmid(!stime,9,2)+'/'
					ELSE MYPATH=MYPATH;+'/'
 ENDIF ELSE		  IF pzup ne "" THEN BEGIN  ON_IOERROR,misfix
					     MYPATH=MYPATH+pzup+'/'
					     tmp=fix(MYFILE)  & if tmp ge 10 then tmp=string(tmp,format='(i2)') $
					     			else	     tmp= '0'+string(tmp,format='(i1)')
					     MYFILE=strmid(pzup,0,5)+'n'+tmp+'.spe' &  misfix: & ENDIF
 ON_IOERROR, no_file & unit=-1
 OPENR,unit, MYPATH+MYFILE,/get_lun				;Open the data file

      STATUS=13
      ON_IOERROR, read_err

;PRINT, strpos(strlowcase(MYFILE), '.xyz')

IF strpos(strlowcase(INST(0)), '1600')  ge 0 THEN BEGIN
  a=1600
  DATA=FLTARR(a)
  READF,unit,DATA
      STATUS=0							;Status is ok
      DATP={X:         INDGEN(a),     $		;Pass those variables which were 
            Y_TIT:	    'value',       $ 	;read-in into the DATP structure
            X_TIT:	    'index', $ 					
            W_TIT:     INST+' : '+MYPATH+MYFILE,        $ 					
            OTHER_TIT: string(a)+' values' }

ENDIF ELSE IF strpos(strlowcase(MYFILE), '.xyz')  ge 0 THEN BEGIN
  print,'try to read xyz format (Turrillas/Hansen, July 1998)'
  row=FLTARR(4)
  READF,unit,row
  data=[[row]]
  y=row(1)
  PRINT,'y=',y
  WHILE NOT EOF(unit) DO BEGIN
    READF,unit,row
    IF y NE row(1) THEN BEGIN
      y=row(1)
      PRINT,'y=',y
    ENDIF
    ;PRINT,N_ELEMENTS(data),row
    data=[[data],[row]]
  ENDWHILE  
  ny=N_ELEMENTS(UNIQ(data(1,*)))
  nx=N_ELEMENTS(data(1,*))/ny
      STATUS=0							;Status is ok
      DATP={X:         REFORM(data(0,*),nx,ny),   $ ;Pass those variables which were 
            Y:         REFORM(data(1,*),nx,ny),   $ ;Pass those variables which were 
            E:         REFORM(data(3,*),nx,ny),   $ ;Pass those variables which were 
            Y_TIT:	    'value',       $ 	;read-in into the DATP structure
            X_TIT:	    'index', $ 					
            W_TIT:     INST+' : '+MYPATH+MYFILE,        $ 					
            OTHER_TIT: strcompress(N_ELEMENTS(data(0,*)))+' values' }
data=REFORM(data(2,*),nx,ny)

ENDIF ELSE BEGIN
IF strpos(strlowcase(MYFILE), 'cyc.res')  ge 0 THEN BEGIN
  print,'try to read result file from "cyclic" fullprof run'
  line='text'
  READF,unit,line
  tit=strmid(line,5,STRLEN(line)-5)
  print,tit
  cyc=0
  par=0
  x_tit='Step'
  WHILE NOT EOF(unit) DO BEGIN
    WHILE strmid(line,0,4) NE 'PHAS' DO BEGIN ; Header
      READF,unit,line
      IF strmid(line,0,4) EQ 'DATT' THEN BEGIN
        print,cyc,float(strmid(line,17,12))
        IF par GT 0 THEN PP=[PP,float(strmid(line,17,12))] ELSE  PP=[float(strmid(line,17,12))]
        par=par+1
        IF cyc EQ 0 THEN BEGIN
            IF N_ELEMENTS(txt) GT 0 THEN BEGIN
              txt=[txt,'Temperature ']
            ENDIF ELSE txt='Temperature '
        ENDIF
        IF cyc GT 0 THEN x=[x,float(strmid(line,17,12))] ELSE BEGIN
          x=float(strmid(line,17,12))
          x_tit='Temperature'
        ENDELSE
      ENDIF
    ENDWHILE
    IF N_ELEMENTS(x) NE cyc+1 THEN IF cyc THEN x=[x,cyc] ELSE x=cyc
    WHILE strmid(line,0,3) NE '---' DO BEGIN ; Phases
      IF cyc EQ 0 THEN print,line
      phase=long(strmid(line,4,1))
      READF,unit,line
      WHILE strmid(line,0,4) NE 'PHAS' AND strmid(line,0,3) NE '---' DO BEGIN ; Phase
        READF,unit,line
        IF strmid(line,0,4) EQ 'CELL' THEN BEGIN
          cell=fltarr(6)
          READS,strmid(line,4,STRLEN(line)-4),cell
          IF par GT 0 THEN PP=[PP,float(cell)] ELSE  PP=[float(cell)]
          par=par+6
          IF cyc EQ 0 THEN BEGIN
            IF N_ELEMENTS(txt) GT 0 THEN BEGIN
              txt=[txt,'a('+strcompress(PHASE,/re)+')     ']
            ENDIF ELSE txt='a'+strcompress(PHASE,/re)+')     '
            txt=[txt,'b('+strcompress(PHASE,/re)+')     ']
            txt=[txt,'c('+strcompress(PHASE,/re)+')     ']
            txt=[txt,'alpha('+strcompress(PHASE,/re)+') ']
            txt=[txt,'beta ('+strcompress(PHASE,/re)+') ']
            txt=[txt,'gamma('+strcompress(PHASE,/re)+') ']
          ENDIF
          READF,unit,line
          sig_cell=fltarr(6)
          READS,strmid(line,4,STRLEN(line)-4),sig_cell
          IF par GT 0 THEN PP=[PP,float(sig_cell)] ELSE  PP=[float(sig_cell)]
          par=par+6
          IF cyc EQ 0 THEN BEGIN
            IF N_ELEMENTS(txt) GT 0 THEN BEGIN
              txt=[txt,'sigma (a('+strcompress(PHASE,/re)+'))     ']
            ENDIF ELSE txt='sigma (a'+strcompress(PHASE,/re)+'))     '
            txt=[txt,'sigma (b('+strcompress(PHASE,/re)+'))     ']
            txt=[txt,'sigma (c('+strcompress(PHASE,/re)+'))     ']
            txt=[txt,'sigma (alpha('+strcompress(PHASE,/re)+')) ']
            txt=[txt,'sigma (beta ('+strcompress(PHASE,/re)+')) ']
            txt=[txt,'sigma (gamma('+strcompress(PHASE,/re)+')) ']
          ENDIF
          IF phase EQ 1 THEN IF cyc GT 0 THEN BEGIN
            DATA=[[DATA],    [cell]] 
            EE=  [[EE],  [sig_cell]] 
          ENDIF ELSE BEGIN
            DATA=    cell
            EE  =sig_cell
          ENDELSE
        ENDIF ELSE IF strmid(line,0,4) EQ 'SCAL' THEN BEGIN
          bid=fltarr(2)
          READS,strmid(line,4,STRLEN(line)-4),bid
          IF par GT 0 THEN PP=[PP,float(bid)] ELSE  PP=[float(bid)]
          IF cyc EQ 0 THEN IF N_ELEMENTS(txt) GT 0 THEN txt=[txt,'scale('+strcompress(PHASE,/re)+')    ','sigma (scale('+strcompress(PHASE,/re)+')) '] ELSE txt=['scale('+strcompress(PHASE,/re)+')    ','sigma (scale('+strcompress(PHASE,/re)+')) ']
          par=par+2
        ENDIF
      ENDWHILE
    ENDWHILE
    IF cyc GT 0 THEN PV=[[PV],[PP]] ELSE PV=PP
    cyc=cyc+1
    par=0
  ENDWHILE
      STATUS=0				;Status is ok
      DATP={PV:        PV,$
            P:         PP,$
            PAR_TXT:   txt,$
            E:         EE,            $	 ; 
            X:         indgen(6), $	 ;
            Y:         X,                       $	 ;Pass those variables which were 
            Z_TIT:     'lattice',               $ 	;read-in into the DATP structure
            Y_TIT:     'abc/angles',            $ 	;
            X_TIT:     x_tit, $ 					
            W_TIT:     INST+' : '+MYPATH+MYFILE,        $ 					
            OTHER_TIT: tit }

ENDIF ELSE  IF strpos(strlowcase(MYFILE), '.prf')  ge 0 THEN BEGIN
  print,'try to read profile (prf) file'
  hkl=[[0,0,0]]
  bragg=0
  line='text'
  READF,unit,line
 IF strmid(line,0,4) EQ 'IGOR' THEN BEGIN ; *** Fullprof output format 2 (IGOR) ***
  PRINT,'*** Fullprof output format 2 (IGOR)'
  a=0.
  b=0.
  c=0.
  TwoTheta=0.0
  Iobs=0.0
  Icalc=0.0
  READF,unit,line
  READF,unit,line
  READF,unit,line
  WHILE strmid(line,0,3) NE 'END' DO BEGIN
    READS,line+' 0 0 0',a,b,c
    TwoTheta=[Twotheta,a]
    Iobs= [Iobs,b]
    Icalc=[Icalc,c]
    READF,unit,line
  ENDWHILE
  other_tit=line
  WHILE strmid(other_tit,0,3) NE 'X |' DO BEGIN
    READF,unit,other_tit
  ENDWHILE
  READF,unit,line
  other_tit=strmid(line,17,strlen(line)-17)+' '+strmid(other_tit,23,strlen(other_tit)-23)
  Twotheta=twotheta(1:n_elements(twotheta)-1)
  iobs=iobs(1:n_elements(iobs)-1)
  icalc=icalc(1:n_elements(icalc)-1)
  diff=iobs-icalc
 ENDIF ELSE BEGIN
  ttstart =0.
  ttstep=0.
  bid=0.
  phases=0
  lambda1=0.
  lambda2=0.
  ratio=0.
  steps=long(0)
  other_tit='Profile (fit) : '+STRCOMPRESS(line)
  READF,unit,line
  PRINT,line
  IF strmid(line,0,3) EQ '  1' OR strmid(line,0,3) EQ '  2'  OR strmid(line,0,3) EQ '  3'THEN BEGIN ; *** Fullprof output format -3 (if input INSTR=10) ***
   PRINT,'*** Fullprof output format -3 (if input INSTR=10) ***'
   READS,line+' 0 0 0 0 0 0 0',phases, steps, lambda1,lambda2,bid,bid,bid
    Icalc=FLTARR(steps)
    TwoTheta=FLTARR(steps)
    Iobs=FLTARR(steps)
    Idiff=FLTARR(steps)
    bg=FLTARR(steps)
    READF,unit,line
    phase=INTARR(phases)
    IF phases GT 1 THEN BEGIN
      READS,line+' 0 0 0',bid,reflections,phase,excludedregions
    ENDIF ELSE READS,line+' 0 0 0',reflections,phase,excludedregions
    IF excludedregions GT 0 THEN BEGIN
      excluded0=FLTARR(excludedregions)
      excluded1=FLTARR(excludedregions)
    ENDIF
    ;help,steps,bg,excludedregions,reflections
    hkl=INTARR(3,reflections)
    bragg=FLTARR(reflections)
    e0=0.
    e1=0.
    FOR i=0,excludedregions-1 DO BEGIN
      READF,unit,e0,e1
      excluded0(i)=e0
      excluded1(i)=e1
    ENDFOR
    READF,unit,line
    tt=0.
    braggpos=0.
    h=0
    k=0
    l=0
    FOR i=0,steps-1 DO BEGIN
      READF,unit,line
      IF i LT reflections THEN BEGIN
        ;PRINT,line
        READS,line,tt,bid,int,bid,bid,braggpos
        bragg(i)=braggpos
        ;print,braggpos,bid
        line=STRMID(line,STRPOS(line,'(')+1, STRLEN(line)-STRPOS(line,'(')-1)
        ;PRINT,line
        READS,line,h,k,l
        hkl(*,i)=[h,k,l]
        ;print,hkl(*,i)
      ENDIF ELSE BEGIN
        READS,line,tt,bid,int,bid
      ENDELSE
      TwoTheta(i)=tt
      Icalc(i)=int
    ENDFOR
  ENDIF ELSE BEGIN ; *** Fullprof output format 1 (standard : PLOTPOW etc.) ***
    PRINT,'*** Fullprof output format 1 (standard : PLOTPOW etc.) ***'
    READF,unit,line
    READS,line+' 0 0 0',bid,ttstart,ttstep
    READF,unit,line
    READS,line+' 0 0 0 0 0',bid,steps,lambda1,lambda2,ratio
    other_tit=other_tit+' lambda='+STRCOMPRESS(lambda1)
    READF,unit,line
    TwoTheta=ttstart+ttstep*findgen(steps) 
    Iobs    =fltarr(steps) 
    READF,unit,Iobs
    Icalc    =fltarr(steps) 
    READF,unit,Icalc
  ENDELSE
      STATUS=0				;Status is ok
      DATP={P:         [lambda1,lambda2],$
            PAR_TXT:   ['lambda1','lambda2'],$
            X:         twotheta, $	 ;Pass those variables which were 
            Y:         hkl,$
            Z:         bragg, $	 ;Pass those variables which were 
            Y_TIT:     'counts', $ 	;read-in into the DATP structure
            X_TIT:     '2Theta', $ 					
            Z_TIT:     'hkl pos.', $ 					
            W_TIT:     INST+' : '+MYPATH+MYFILE,        $ 					
            OTHER_TIT: other_tit }
 ENDELSE
 DATA=Icalc 

ENDIF ELSE IF strpos(strlowcase(MYFILE), 'd20_') ge 0 AND strpos(strlowcase(MYFILE), '.bad') lt 0  THEN BEGIN
  print,'read d20 efficiency correction file'
  line='text'
  READF,unit,line
  nd_cal=0 ;FIX(line)
  IF nd_cal EQ 0 THEN nd_cal=1600
  x=findgen(nd_cal)
  data=fltarr(nd_cal)
  READF,unit,x,DATA
      STATUS=0							;Status is ok
      DATP={X:          x,                 $					;Pass those variables which were 
            Y_TIT:	    'eff-cor',          $ 					;read-in into the DATP structure
            X_TIT:	    '2Theta+Offset',    $ 					
            OTHER_TIT:	line,               $ 					
            W_TIT:     INST+' : '+MYPATH+MYFILE }

ENDIF ELSE IF strpos(strlowcase(MYPATH), 'bad_cells') ge 0 OR strpos(strlowcase(MYFILE), '.bad') ge 0 THEN BEGIN
  ;print,'try to read bad cells'
  a=0
  READF,unit,a
  DATA=FLTARR(a)
  READF,unit,DATA
      STATUS=0							;Status is ok
      DATP={X:         INDGEN(a),     $		;Pass those variables which were 
            Y_TIT:	    'value',       $ 	;read-in into the DATP structure
            X_TIT:	    'index', $ 					
            W_TIT:     INST+' : '+MYPATH+MYFILE,        $ 					
            OTHER_TIT: string(a)+' values' }

ENDIF ELSE BEGIN
  print,'try to read simple array'
  a=0
  READF,unit,a
  DATA=FLTARR(a)
  READF,unit,DATA
      STATUS=0							;Status is ok
      DATP={X:         INDGEN(a),     $		;Pass those variables which were 
            Y_TIT:	    'value',       $ 	;read-in into the DATP structure
            X_TIT:	    'index', $ 					
            W_TIT:     INST+' : '+MYPATH+MYFILE,        $ 					
            OTHER_TIT: string(a)+' values' }

ENDELSE
ENDELSE
 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:   IF unit lt 0 THEN print,!err_string, string(7b)

 RETURN, DATA							;Return the data values

 END
FUNCTION rddef, INST , PATH , FILENAME , STATUS , DATP ; , p1 , p2 ,p3 ...
;********
;**
;** The call is w6=mymacro(...)

OPENR,unit,PATH+FILENAME,/GET_LUN
elements=0
READF,unit,elements
Wout=FLTARR(elements)
x=Wout
READF,unit,x,Wout
FREE_LUN,unit
DATP={X:                  x, $	;Pass those variables which were 
      Y_TIT:	   'counts', $ 	;read-in into the DATP structure
      X_TIT:	    '2theta', $ 					
      W_TIT:     INST+' : '+PATH+FILENAME,        $ 					
      OTHER_TIT: string(elements)+' values' }
;GIVE_DATP,datp
STATUS=0
return, Wout
end
;************************************************************************
;* rdedf.pro                                             		*
;* Pupose:      rdedf is the function to read and display the ESRF data *
;*		files with LAMP from ILL.				*	
;* Author:      Tobias Karrer                               	    	*
;* Created On:  10/03/97                                        	*
;*----------------------------------------------------------------------*
;* Modifications:                                               	*
;* 30/05/97	changed the way to read the data, because LAMP wasn't	*
;*		able to read modified Images (p. ex. with saxs_add)	*
;* 11/06/97	added the variable 'pref' to specify the prefix of the  *
;*		filename						*
;* 12/06/97	modified the way to get the filename, after doing tests *
;* 02/07/97	removed code to display image number			*
;* 30/07/97	added code to read format and dimension out of header	*
;* 21/06/01	status=11 before the OPENR (D.R.)			*
;* 21/06/01	imgNo =0  only when entering rdedf (D.R.)		*
;* 21/06/01	nofile:if c_unit le 0 then c_file='?' (D.R.)		*
;* 15/11/01	get parameters differently (D.R.)		        *
;************************************************************************

;***************************************************************************************
function rdedf ,inst , path , filename , status , datp
;******* *****
;**

common c_edf	 , pref  ,suf
common c_edf_open, c_unit, c_file, c_imgNo

data  =0

;** if an error occurs, CATCH makes to quit the function, printing the error messages **
CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

imgNo=0			;** variable to keep the image number
maxilen=169		;** length of the maximal header in the edf-file
w=0 & s=0 & i=0 & j=0	;** variables to count loops, arrays, etc...
flag=0			;** variable for title - 0:no title, 1:display title
title =''		;** variable to keep the title of the image
head=STRARR(maxilen) 	;** whole header
par =STRARR(maxilen) 	;** value of header params
text=STRARR(maxilen)	;** name of header params
line=''			;** temporary variable for one headerline
formt='?'

;** pref is a common block defined variable and is set with function 'set_pref' ******
IF N_ELEMENTS(pref) EQ 1 THEN BEGIN
				IF STRPOS(pref,'_') EQ -1 THEN prefname=pref+'_' $
						  	  ELSE prefname=pref
			      ENDIF ELSE prefname=''

;** suf is a common block defined variable and is set with function 'set_suf' ******
IF N_ELEMENTS(suf) EQ 1 THEN BEGIN
				IF STRPOS(suf,'_') EQ -1 THEN sufname='_'+suf $
						  	 ELSE sufname=suf 
			     ENDIF ELSE sufname=''

;** if filename is an array, first element = filename, second = image number ******
IF N_ELEMENTS(filename) GT 1 THEN BEGIN imgNo=fix(filename(1))-1
					filename=filename(0) & ENDIF

IF N_ELEMENTS(c_unit)   EQ 0 THEN BEGIN c_unit=0 & c_file=''
					c_imgNo=0 & ENDIF


;** looking for the extension '.edf'  ******
ext=STRPOS(filename,'.edf')

IF ext LT 0 THEN file=prefname+filename+sufname+'.edf' $
ELSE BEGIN hypnorm =STRPOS(filename,'[',ext)		;** '[' given? ******
	   hypshift=STRPOS(filename,'{',ext)		;** '{' given? ******
	   IF (hypnorm LT 0) AND (hypshift LT 0) THEN BEGIN file=filename

	   ENDIF $
	   ELSE BEGIN 		;** get the given image number ******
		file=strmid(filename,0,ext+4)
		ON_IOERROR, mislong	;** on convert error to 'long,
					;** jump to label mislong
		imgNo=long(strmid(filename,ext+5,6))-1
		flag=1
		mislong: IF imgNo LT 0 THEN print,'No valid image number'
	   ENDELSE
ENDELSE

ON_IOERROR,nofile	;** on open error jump to label nofile

status=11		;** display ' Cant open the file or file not found' ******

;** it is checked, if the file out of which to read the image is already open ******  
if (file ne c_file) or (imgNo lt c_imgNo) then begin
	 if c_unit  gt 0 then FREE_LUN,c_unit
	 c_file=file & c_unit=0      & c_imgNo=0
	 OPENR,c_unit,path+file,/GET_LUN
	 endif

ON_IOERROR,erread	;** on read error jump to label erread
status=13		;** display ' Data file incomplete' ******

;** read image data and header values ******
;**
FOR loop=c_imgNo,imgNo DO BEGIN

	j=0
	;** read each single line of the file and save it in head(j), ******
	;** until line contains '}' ******
	REPEAT BEGIN READF,c_unit,line & if j lt maxilen then head(j)=line & j=j+1

	;** looking for 'DataType'  in the header ******
	IF STRPOS(line,'DataType') GT -1 THEN BEGIN
		w=STRPOS(line,'=')
		s=STRPOS(line,';')
		formt=STRCOMPRESS(STRMID(line,w+1,s-w-1), /REMOVE_ALL)
	ENDIF
	;** looking for dimension 1 in the header ******
	IF STRPOS(line,'Dim_1') GT -1 THEN BEGIN
		w=STRPOS(line,'=')
		s=STRPOS(line,';')
		dim1=long(STRMID(line,w+1,s-w-1))
	ENDIF
	;** looking for dimension 2  in the header ******
	IF STRPOS(line,'Dim_2') GT -1 THEN BEGIN
		w=STRPOS(line,'=')
		s=STRPOS(line,';')
		dim2=long(STRMID(line,w+1,s-w-1))
		IF N_ELEMENTS(formt) EQ 1 THEN BEGIN
			CASE formt OF
			'ShortValue':		data=INTARR(dim1,dim2)
			'UnsignedShort':	data=INTARR(dim1,dim2)
			'IntegerValue':		data=LONARR(dim1,dim2) 
			'UnsignedInteger':	data=LONARR(dim1,dim2) 
			'FloatValue':		data=FLTARR(dim1,dim2)
			'DoubleValue':		data=DBLARR(dim1,dim2)
			ELSE:
	    		ENDCASE
		ENDIF
		IF N_ELEMENTS(data) EQ 1 THEN BEGIN
			print, "DataType:",formt," not known, using UnsignedShort as default"
			data=INTARR(dim1,dim2) & formt='UnsignedShort'
		ENDIF
	ENDIF
	;** looking for image number in the header ******
	;** if found, store value in 'titleVal' ******
	IF STRPOS(line,'Image') GT -1 THEN $
		titleVal=STRMID(line,0,STRPOS(line,';'))
	ENDREP UNTIL (StrPos(line,'}') NE -1)

	;** read the image data *******
	READU,c_unit,data  & status=0		;** display 'Successful read' ******
	swap =0
	IF (!version.os_family ne 'unix') and (!version.os_family ne 'mac') then swap=1
	IF swap then CASE formt OF
			'ShortValue':		BYTEORDER,data,/sswap
			'UnsignedShort':	BYTEORDER,data,/sswap
			'IntegerValue':		BYTEORDER,data,/lswap
			'UnsignedInteger':	BYTEORDER,data,/lswap
			ELSE:
	    		ENDCASE
			
	if formt eq 'UnsignedShort' then positive,data

	;** the 'for' loop stores the names and the values of the headerlines ******
	;** in their variables ******
	k=0
	on_ioerror,misflt
	head=strtrim(head,2)
	FOR i=0,(j<maxilen)-1 DO BEGIN
		w=STRPOS(head(i),'=')
		if w gt 0 then begin
		   s=STRPOS(head(i),';')
		   ok=0
		   if s gt w then begin
			text(k)=STRMID(head(i),0,w-1)+' '+STRMID(head(i),s+1,100)
			num=STRMID(head(i),w+1,s-w-1)
			num=float(num) & ok=1 & misflt:
		   endif
		   if (ok) then par(k)=num else text(k)=STRMID(head(i),w+1,100)
		   k=k+1
		endif
	ENDFOR
	text=text(0:k-1)
	par =par (0:k-1)
ENDFOR ;** loop=c_imgNo,imgNo ******

erread:c_imgNo = imgNo+1

;** when flag=1, imagenumber is displayed as title ******
IF flag EQ 1 THEN title=titleVal

;** passing of header to lamp ******
datp={PAR_TXT:text,P:par,W_tit:title,OTHER_tit:file}

nofile:if c_unit le 0 then c_file='?'

RETURN,data
END




;RDFILTER was written by Philippe Cuerq on August 1996
;With this interface it is possible to select a part of a run, and
;make three different projections too.

;Version 2.0		Date : 08/96

; ************************ Widgets Creating Procedure ******************
; Rd_Filter			Create main RDFILTER interface

; ************************ Event processing procedures *****************
; P_Fil_Event		,event,uv

; ************************ Functions of this file **********************
; Ph_Verif		,value1,value2,vect,siz

; ************************ Procedures of this file *********************
; Ph_Common
; P_Fil_Event		,event,uv
; Ph_Write		,label,mess
; Ph_Help_RS	
; Ph_Filter		,wks
; Rd_Filter	


; ******************************** BEGINNING ***************************

;    *******************************************************************
;    *                       PROCEDURE PH_COMMON                       *
;    *								       *
;    * Description :   This procedure is simply used to declare        *
;    *		   the commons.					       *
;    *								       *
;    *******************************************************************

pro Ph_Common

Common cm_filgal	,filter_config $; This structure contains the state of
					;  xrange,yrange,zrange,xproj,yproj,
					; zproj,cons,moni
					; Ex. filter_config.xproj=1 then
					; x projection is selected etc....
			,mes_lab $	; Widget Id of message label
			,xtol    $	; Widget Id of tolerance
			,xmkb    $	; Widget Id of X mask list
			,ymkb    $	; Widget Id of Y mask list
			,nomb    $	; Widget Id of Monitor
			,xtolf   $	; float  value of tolerance
			,roto    $	; other  value of tolerance
			,xmsk,mk_x    $	; X mask list (string,value)
			,ymsk,mk_y    $	; Y mask list (string,value)
			,nomo    $	; Monitor value
			,first_time	; To know if RDFILTER is or was active
					; in the same Lamp session. 
			
Common cm_filini	,xmin $		; Keep the xmin value
			,xmax $		; Keep the xmax value
			,ymin $		; Keep the ymin value
			,ymax $		; Keep the ymax value
			,zmin $		; Keep the zmin value
			,zmax $		; Keep the zmax value
			,spect1 $ 	; Keep the first  "run selection"
			,spect2 $	; Keep the second "run selection"
			,spect3		; Keep the third  "run selection"
	
Return 
End

;    *******************************************************************
;    *                   INTERFACES WITH -NW MODE OF LAMP              *
;    *								       *
;    *******************************************************************

pro ph_setmask, wmsk,mk_w
;** **********
;**
		on_ioerror,miswmsk & ok=0
		mk_w=intarr(50)-1  & tm1=' -1 -1 -1 -1 -1 -1 -1 -1 -1 -1'
		reads,wmsk+tm1+tm1+tm1+tm1+tm1, mk_w & ok=1
		miswmsk:   idx =where(mk_w ge 0)
		if (idx (0) ge 0) and (ok) then mk_w=mk_w(idx) else mk_w=-1
		ni=n_elements(idx) & mk_w=reform(mk_w,ni,1)
		wmsk='' & if mk_w(0) ge  0 then for i=0,ni-1 do $
					wmsk=wmsk+strtrim(string(mk_w(i)),2)+' '
end

pro ph_works, selection ,uv
;** ********
;**
@lamp.cbk
Common cm_filgal
Common cm_filini
		selection=strtrim(selection(0),2)
		If (selection ne '') then begin			; Calls Rdmulti
		    monoto=0
		    if (filter_config.moni eq 2) then monoto=-1
		    if (filter_config.moni eq 3) then begin on_ioerror,mismoni & monoto=float(nomo) & mismoni: & endif

		    if (filter_config.cons) and (strpos(selection,':') lt 0) then $
			Ph_Write,mes_lab,'!Sigma apply with concatenation'$
		    else begin
			if (strpos(selection,'>') ge 0) or (strpos(selection,'+') ge 0) then begin
			    if xtol gt 0 then begin roto='0' & widget_control,xtol,bad_id=i,get_value=roto & endif
			    on_ioerror,misxtol & r=0 & r=float(roto(0)) & misxtol:
			    if r ne xtolf then tolerance=r
			endif
		   	w20=0
			if (monimon lt 0) and (monoto ge 0) then RDSET,/def
			if (monimon ge 0) and (monoto lt 0) then RDSET,/raw
			Filterpro,'Ph_Filter'				; on each
			RdMulti,selection,status,uv(0),20,monoto	; selected part
			Filterpro,''					; of the numor
			
			If not status  then begin			; Display the run

				if (strpos(selection,'>') ge 0) or (strpos(selection,'+') ge 0) then begin
				    if xtol gt 0 then widget_control,xtol,bad_id=i,set_value=strtrim(string(toler),2) $
						 else roto=toler
				    xtolf=float(string(toler))
				endif

				to_don_history, 20,0,'w20=RDOPR("'+selection+'") ;RDFILTER '+inst_value
    			     
				r=execute('spect'+strtrim(string(uv(1)),1)+'=selection')
				
				If (filter_config.cons and (size(w20))(0) ge 2) $
				then begin Ph_Write,mes_lab,'Sigma evaluation ...' & w19=0
					   XICUTER,'w19=corel(w20)>1' 
					   if uv(0) gt 0 then forcplot,w=19
				endif else if uv(0) gt 0 then forcplot,w=20
			endif
		   endelse	
		endif
end

;    *******************************************************************
;    *                       PROCEDURE PH_ FIL_EVENT                   *
;    *								       *
;    * Description :   This procedure is the events maintenance .It    *
;    *		   is called by Lamp with the event and the user value *
;    *             of the event.                                       *
;    *								       *
;    *******************************************************************

pro P_Fil_Event,event,uv
;** ***********
;**
Common cm_filgal
Common cm_filini


case uv(2) of 

	1 : filter_config.xrange=event.select	; filter_config.xrange=1 => x
						; range selected
	
	2 : filter_config.yrange=event.select	; idem
	
	3 : filter_config.zrange=event.select	; idem
	
	4 :  filter_config.xproj=event.select	; filter_config.xproj=1 ==> x 
						; projection selected
				
	5 :  filter_config.yproj=event.select	; idem
					    	
	6 :  filter_config.zproj=event.select	; idem
	
	7 :  begin
	       filter_config.cons =event.select	; idem
	       If event.select then chaine='Sigma W19' $
	       		       else chaine='Sigma'
	       Widget_Control,event.id,Set_Value=chaine
	       end
	
	8 :  filter_config.moni =uv(3)		; Normalize

	10 : Ph_Help_RS				; help for run selector
	
	11 : Widget_Control,event.top,/Destroy	; exit event : destroy all 
						; the bases
	
	12 : Begin Ph_Write,mes_lab,''		; initialization
		   Ph_Write,uv(10) ,''

		Widget_Control,nomb,Get_Value=nomo & nomo=strcompress(nomo(0),/remove_all)
		Widget_Control,xmkb,Get_Value=xmsk & xmsk=strtrim(xmsk(0),2)
		Widget_Control,ymkb,Get_Value=ymsk & ymsk=strtrim(ymsk(0),2)

		if xmsk ne ''  then begin ph_setmask, xmsk,mk_x
					  Widget_Control,xmkb,Set_Value=xmsk & endif
		if ymsk ne ''  then begin ph_setmask, ymsk,mk_y
					  Widget_Control,ymkb,Set_Value=ymsk & endif

		If (filter_config.xrange eq 1) then begin	 ; to catch xmin 
			Widget_Control,uv(3),Get_Value=mini	 ; and xmax
			on_ioerror,misxmin & xmin=float(mini(0)) & misxmin:
			Widget_Control,uv(4),Get_Value=maxi
			on_ioerror,misxmax & xmax=float(maxi(0)) & misxmax:
			If (xmax lt xmin) then begin
				Ph_Write,mes_lab,'Xmax > Xmin  !!!'
				return
			endif  
		endif
		
		If (filter_config.yrange eq 1) then begin	 ; to catch ymin
			Widget_Control,uv(5),Get_Value=mini	 ; and ymax
			on_ioerror,misymin & ymin=float(mini(0)) & misymin:
			Widget_Control,uv(6),Get_Value=maxi
			on_ioerror,misymax & ymax=float(maxi(0)) & misymax:
			If (ymax lt ymin) then begin
				Ph_Write,mes_lab,'Ymax > Ymin  !!!'
			   	return
			endif
		endif
		
		If (filter_config.zrange eq 1) then begin	 ; to catch zmin
			Widget_Control,uv(7),Get_Value=mini	 ; and zmax
			on_ioerror,miszmin & zmin=float(mini(0)) & miszmin:
			Widget_Control,uv(8),Get_Value=maxi
			on_ioerror,miszmax & zmax=float(maxi(0)) & miszmax:
			If (zmax lt zmin) then begin
				Ph_Write,mes_lab,'Zmax > Zmin  !!!'
				return
			endif
		endif
					   	   
		selection=''			   		; to catch 
		Widget_Control,uv(9),Get_Value=selection	; the runs
		PH_WORKS, selection ,[uv(10),uv(11)]
	     end
	
	else : return      	

endcase		
return
end

;    *******************************************************************
;    *                       PROCEDURE PH_ WRITE                       *
;    *                                                                 *
;    * Description :   This procedure displays a message(mess)         *
;    *                 in a label(label).                              *
;    *                                                                 *
;    *******************************************************************

pro Ph_Write,label,mess


; Write messages in the label
if label gt 0	then Widget_Control,label,Set_Value=mess $
		else print,mess
Return
End

;    *******************************************************************
;    *                       PROCEDURE PH_ HELP_RS                     *
;    *                                                                 *
;    * Description :   This procedure calls a Lamp function :show_helps*
;    *                 which display a help.                           *
;    *                                                                 *
;    *******************************************************************

pro Ph_Help_RS
show_helps,[-88,594]
return
end



;    *******************************************************************
;    *                       FUNCTION PH_ VERIF                        *
;    *                                                                 *
;    * Description :   This function checks :    		       *
;    *                       - if at least one value is in the interval*  
;    *                  ==> returns a structure with a specific        *
;    *                  value (Aff=1)and the indices of the values     *
;    *                  in the vector (ex:{Aff=1,min=10,max=20}.       *
;    *                       - if not ==> returns a structure with a   *
;    *		        specific value(ex: {Aff=0}).                   *
;    *                                                                 *
;    *******************************************************************

function Ph_Verif,value1,value2,vect,siz


error1=0 & error2=0

If n_elements(vect) ne siz then vect=indgen(siz)+1 

If (vect(0)-vect(1)) gt 0 then begin 
	val=value1
	value1=value2 
	value2=val  
endif

indmax=siz-1 
indmin=0

If (value1 lt vect(0) or value1 gt vect(n_elements(vect)-1)) then error1=1 $
else begin 
	indmin=where(vect ge value1)  
	indmin=indmin(0)
endelse

If (value2 gt vect(n_elements(vect)-1) or value2 lt vect(0)) then error2=1 $
else begin	 
	indmax=where(vect le value2) 
	indmax=indmax(n_elements(indmax)-1)
endelse

If (error1 and error2) then aff={aff:0} $
else begin 
	vect=vect(indmin:indmax)
	aff={aff:1,min:indmin,max:indmax}
endelse	

return, aff	       	
end      	




;    *******************************************************************
;    *                       PROCEDURE PH_FILTER                       *
;    *                                                                 *
;    * Description :   This function selects a part of a workspace and *
;    *                 applies projections to it.                      *
;    *                 Note that data are always restored in workspace *
;    *                 20 and Ph_filter is called by Lamp, Lamp        *
;    *                 specifies that the work happens in W20.	       *
;    *		  		                                       *
;    *                                                                 *
;    *******************************************************************

pro Ph_Filter,wks

; Work= 0 ---> makes projections (if selected)
; Work= 1 ---> modifies workspace and makes projections (if selected)
; Work=-1 ---> does nothing

@lamp.cbk
Common cm_filgal
Common cm_filini

;changes the Lamp workspace for the w20

If wks ne 20 then XICUTE,'w20=w'+strtrim(string(wks),2)
Ph_Write,mes_lab,'---> '+w_numor(20)
siz =Size(w20)
sizn=Size(N20)
Work=0
Wmsk=0
If n_elements(E20) eq  n_elements(W20)	  then ero=1 else ero=0
If (sizn(0) ge 1) and (sizn(1) eq siz(1)) then ern=1 else ern=0

;---------------------- Selection on x axis ----------------------

if siz(0) ge 1 then begin
   If  xmsk ne '' then begin
	If n_elements(x20) lt siz(1) then  x20=indgen(siz(1))+1
	If (size(mk_x))(0) eq 2 then begin tmp=lonarr(siz(1)) & mk_x=mk_x<(siz(1)-1)
					   tmp(mk_x)=-1 & mk_x=where(tmp ge 0)  & endif
	x20=x20 (mk_x,*)    &	if (size(y20))(0) eq 2 then y20=y20(mk_x,*)
	w20=w20 (mk_x,*,*)  &	if  ero then E20=E20(mk_x,*,*)
				if  ern then N20=N20(mk_x,*)     & siz =Size(w20)
   endif
   indxmin=0 & indxmax=siz(1)-1

   If  filter_config.xrange then begin
	S_result=Ph_Verif(xmin,xmax,x20,siz(1))
	If S_result.aff then begin
		indxmin=S_result.min
		indxmax=S_result.max
		if (size(y20))(0) eq 2 then y20=y20(indxmin:indxmax,*)
		Work=1
	endif else begin
		Ph_Write,mes_lab, 'Warning : Xmin='+strtrim(string(min(x20)),2)$
		+'  Xmax='+strtrim(string(max(x20)),2)
		Work=-1
		endelse
   endif
endif
;---------------------- Selection on y axis ----------------------
			       
if siz(0) ge 2 then begin
   If  ymsk ne '' then begin
	If n_elements(y20) ne siz(2) then  y20=indgen(siz(2))+1 
	If (size(mk_y))(0) eq 2 then begin tmp=lonarr(siz(2)) & mk_y=mk_y<(siz(2)-1)
					   tmp(mk_y)=-1 & mk_y=where(tmp ge 0) & endif 
	if (size(y20))(0) eq 2  then y20=y20 (*,mk_y) else  y20=y20  (mk_y)
	if (size(x20))(0) eq 2  then x20=x20 (*,mk_y)
	w20=w20 (*,mk_y,*)  &   if  ero then E20=E20(*,mk_y,*)   & siz =Size(w20)
   endif
   indymin=0 & indymax=siz(2)-1

   If (filter_config.yrange) and (Work ne -1)  then begin
	S_result=Ph_Verif(ymin,ymax,y20,siz(2))
	If S_result.aff then begin
		indymin=S_result.min
		indymax=S_result.max
		If not filter_config.xrange then if (size(x20))(0) eq 2 then x20=x20(*,indymin:indymax)
		Work=1
	endif else begin 
		Ph_Write,mes_lab, 'Warning : Ymin='+strtrim(string(min(y20)),2)$
		+'  Ymax='+strtrim(string(max(y20)),2)
		Work=-1
	        endelse
   endif    	  	     
endif
;---------------------- Selection on z axis ----------------------

indzmin=0 & indzmax=siz(3)-1
If (filter_config.zrange and Work ne -1 and siz(0) eq 3) then begin
	S_result=Ph_Verif(zmin-1,zmax-1,indgen(siz(3)),siz(3))
	If S_result.aff then begin
		indzmin=S_result.min
		indzmax=S_result.max
		Work=1
	endif else begin 
		Ph_Write,mes_lab, 'Warning : Zmin= 1 '+'  Zmax='+$
		strtrim(string(siz(3)),2)
		Work=-1
	        endelse	    	  	     
endif
;--------------------- X,Y or Z projection according to workspace size ---

If Work ne -1 then  CASE siz(0) of
		1 : begin
			If Work then  begin w20=w20(indxmin:indxmax)
				if ern then N20=N20(indxmin:indxmax,*)
				if ero then E20=E20(indxmin:indxmax) & endif
			If filter_config.yproj then  begin w20=total(w20,1)
				if ern then N20=total(N20(*,0))
				if ero then E20=sqrt(total(E20^2,1)) & endif
		    end

		2 : begin
			If Work then  begin w20=w20(indxmin:indxmax,indymin:indymax)
				if ern then N20=N20(indxmin:indxmax,*)
				if ero then E20=E20(indxmin:indxmax,indymin:indymax) & endif
			If filter_config.xproj then  begin w20=total(w20,2)
				if ero then E20=sqrt(total(E20^2,2)) & endif
			If filter_config.yproj then  begin w20=total(w20,1)
				if ern then N20=total(N20(*,0))
				if ero then E20=sqrt(total(E20^2,1)) & endif
		    end

		3 : begin
			If Work then  begin w20=w20(indxmin:indxmax,indymin:indymax,indzmin:indzmax)
				if ern then N20=N20(indxmin:indxmax,*)
				if ero then E20=E20(indxmin:indxmax,indymin:indymax,indzmin:indzmax) & endif
			If filter_config.zproj then  begin w20=total(w20,3)
				if ero then E20=sqrt(total(E20^2,3)) & endif
			If filter_config.xproj then  begin w20=total(w20,2)
				if ero then E20=sqrt(total(E20^2,2)) & endif
			If filter_config.yproj then  begin w20=total(w20,1)
				if ern then N20=total(N20(*,0))
				if ero then E20=sqrt(total(E20^2,1)) & endif
		    end
				    
		else:   return

		    ENDCASE

If Work ne -1 then begin
	if (siz(0) eq 3) and (filter_config.zproj) then begin
	    x_tit(20)=x_tit(20)+' (Frames projection)'
	endif
	if (siz(0) ge 1) and (filter_config.xproj) then begin
	    y_tit(20)=z_tit(20)
	    y20=z20(0) & if  y20 eq 0 then y_tit(20)='Numor'
	    if y20 eq 0 then y20=long(w_numor(20))
	endif
	if (siz(0) ge 2) and (filter_config.yproj) then begin
	    x_tit(20)=y_tit(20) & y_tit(20)=z_tit(20) & x20=y20
	    y20=z20(0) & if  y20 eq 0 then y_tit(20)='Numor'
	    if y20 eq 0 then y20=long(w_numor(20))
	endif
endif
	
If n_elements(w20) eq 1 then begin 
	x_tit(20)=''   
	y_tit(20)='Total Values'
	on_ioerror,mis & x20=long(w_numor(20))
	mis: 
endif

;re-establishes Lamp workspace

If wks ne 20 then XICUTE,'w'+strtrim(string(wks),2)+'=w20'

return		    	    	
end



;    *******************************************************************
;    *                       PROCEDURE RDFILTER                        *
;    *                                                                 *
;    * Description :   This  procedure builds the interface            *
;    *                                                                 *
;    *		  		                                       *
;    *******************************************************************


pro rdfilter ,pth ,XRANGE=xrg ,YRANGE=yrg ,ZRANGE=zrg ,XMASK=xtext ,YMASK=ytext, MONIMOD=momod $
		  ,XPROJ=xproj,YPROJ=yproj,ZPROJ=zproj,WKSP =wksp $
		  ,MONIVAL=moval ,SIGMA=sigma ,TOLERANCE=latol ,SELECTION=selec

@lamp.cbk

Common cm_filgal
Common cm_filini

If n_elements(first_time) eq 0 then begin 
	first_time=1
	mes_lab   =0
	xtol	  =0
	filter_config={xrange:0,yrange:0,zrange:0,xproj:0,yproj:0,zproj:0,cons:0,moni:1}
	xmin  =0 & xmax=0
	ymin  =0 & ymax=0
	zmin  =0 & zmax=0
	spect1='' & spect2='' & spect3='' & xmsk='' & ymsk='' & nomo='100000.' & roto='0'
endif
kef=0		
if n_elements(xtext) eq 1 then begin xmsk =string(xtext) & if xmsk ne ''  then ph_setmask, xmsk,mk_x & kef=1 & endif
if n_elements(ytext) eq 1 then begin ymsk =string(ytext) & if ymsk ne ''  then ph_setmask, ymsk,mk_y & kef=1 & endif

if n_elements(xrg)   eq 2 then begin xmin =xrg(0) & xmax=xrg(1)		& kef=1
				     if xmax le xmin then filter_config.xrange=0 else filter_config.xrange=1
				     if xmax lt xmin then Ph_Write,mes_lab,'Xmax > Xmin  !!!'      &   endif
if n_elements(yrg)   eq 2 then begin ymin =yrg(0) & ymax=yrg(1)		& kef=1
				     if ymax le ymin then filter_config.yrange=0 else filter_config.yrange=1
				     if ymax lt ymin then Ph_Write,mes_lab,'Ymax > Ymin  !!!'      &   endif
if n_elements(zrg)   eq 2 then begin zmin =zrg(0) & zmax=zrg(1)		& kef=1
				     if zmax le zmin then filter_config.zrange=0 else filter_config.zrange=1
				     if zmax lt zmin then Ph_Write,mes_lab,'Zmax > Zmin  !!!'      &   endif

if n_elements(xproj) eq 1 then begin filter_config.xproj=xproj  & if xproj eq 1 then kef=1 & endif
if n_elements(yproj) eq 1 then begin filter_config.yproj=yproj  & if yproj eq 1 then kef=1 & endif
if n_elements(zproj) eq 1 then begin filter_config.zproj=zproj  & if zproj eq 1 then kef=1 & endif

if n_elements(momod) eq 1 then begin filter_config.moni=fix(momod)>1<3	& kef=1 & endif
if n_elements(moval) eq 1 then begin nomo=string(moval)			& kef=1 & endif

if n_elements(sigma) eq 1 then begin if sigma then filter_config.cons=1 else filter_config.cons=0  & kef=1 & endif
if n_elements(latol) eq 1 then begin roto=string(latol) & kef=1 & endif

if n_elements(selec) eq 1 then begin if n_elements(wksp) eq 1 then wk='W'+strtrim(string(wksp),2) else wk=''
				     if wk ne '' then XICUTER, wk+'=0'
				     PH_WORKS  ,selec ,[0,1] & kef =1
				     if wk ne '' then XICUTER, wk+'=w20'
				     endif
if (!D.flags and 65536)    ne 0 then if b_labins(3) eq 0 then $
if xregistered('RDFILTER') le 0 then if    kef      eq 0 then begin

filter_config.cons=0

;============================== BASE  ========================================	
base	   =Widget_Base(/Column	,Title='FILTER 2.0',resource_name='lamptouch')


;============================== BASE 1 =======================================
base1	   =Widget_Base   (base    	,/Column)


;============================== BASE 11 SCALES FILTER ========================
base11	   =Widget_Base   (base1   ,/Column,/Frame)

b_ico	   =Widget_Base   (base11  ,/row)
fs_lab	   =Widget_Label  (b_ico   ,value='SCALES',font=ft_biggest)
	    put_logo,b_ico
if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

base111	   =Widget_Base   (base11  ,/Row)

base1111   =Widget_Base   (base111 ,/Nonexclusive)
xrange_but =Widget_Button (base1111,value='X Range :',uvalue=[-88,379,1] ,font=ft_normal)
xmin_text  =Widget_Text   (base111 ,xsize=5+cap,value=strtrim(string(xmin),1),/Editable,font=ft_propor)
xmax_text  =Widget_Text   (base111 ,xsize=5+cap,value=strtrim(string(xmax),1),/Editable,font=ft_propor)

base112    =Widget_Base   (base11	 ,/Row)

base1121   =Widget_Base   (base112 ,/Nonexclusive)              
yrange_but =Widget_Button (base1121,value='Y Range :',uvalue=[-88,379,2] ,font=ft_normal)
ymin_text  =Widget_Text   (base112 ,xsize=5+cap,value=strtrim(string(ymin),1),/Editable,font=ft_propor)
ymax_text  =Widget_Text   (base112 ,xsize=5+cap,value=strtrim(string(ymax),1),/Editable,font=ft_propor)

base113    =Widget_Base   (base11  ,/Row)

base1131   =Widget_Base   (base113 ,/Nonexclusive)              
zrange_but =Widget_Button (base1131,value='Z Range :',uvalue=[-88,379,3],font=ft_normal)
zmin_text  =Widget_Text   (base113 ,xsize=5+cap,value=strtrim(string(zmin),1),/Editable,font=ft_propor)
zmax_text  =Widget_Text   (base113 ,xsize=5+cap,value=strtrim(string(zmax),1),/Editable,font=ft_propor)

;============================== BASE 12 PROJECTIONS , SIGMA ===================

base12     =Widget_Base   (base1   ,/Column,/Frame)
pf_lab	   =Widget_Label  (Widget_Base(base12,/row)  ,value='PROJECTIONS',font=ft_biggest)

base112    =Widget_Base   (base12  ,/Row,/Nonexclusive)
xproj_but  =Widget_Button (base112 ,value='X Projection',uvalue=[-88,379,4],font=ft_normal)
yproj_But  =Widget_Button (base112 ,value='Y Projection',uvalue=[-88,379,5],font=ft_normal)
base113    =Widget_Base   (base12  ,/Row,/Nonexclusive)
zproj_But  =Widget_Button (base113 ,value='Z Projection',uvalue=[-88,379,6],font=ft_normal)
cons_but   =Widget_Button (base113 ,value='Sigma       ',uvalue=[-88,379,7],font=ft_normal)	

base113    =Widget_Base   (base12  ,/row)
bid	   =Widget_Label  (base113 ,value='X merging Tolerance=',font=ft_normal)
xtolf	   =float(string(tolerance))
xtol	   =Widget_Text	  (base113 ,value=strtrim(string(tolerance),2),xsize=8+cap,/Editable,font=ft_propor)

;============================== BASE 12b MASKS & NORM ===================

base12     =Widget_Base   (base1   ,/Column,/Frame)
pf_lab	   =Widget_Label  (Widget_Base(base12,/row)  ,value='MASKS & NORM.',font=ft_biggest)

base113    =Widget_Base   (base12  ,/row)
bid	   =Widget_Label  (base113 ,value='X masks 0,..n :',font=ft_normal)
xmkb	   =Widget_Text	  (base113 ,value=strtrim(string(xmsk),2),xsize=14,/Editable,font=ft_propor)

base113    =Widget_Base   (base12  ,/row)
bid	   =Widget_Label  (base113 ,value='Y masks 0,..n :',font=ft_normal)
ymkb	   =Widget_Text	  (base113 ,value=strtrim(string(ymsk),2),xsize=14,/Editable,font=ft_propor)

base113    =Widget_Base   (base12  ,/row)
moni_but   =Widget_Base   (base113 ,/row,/exclusive)
moni_def   =Widget_Button (moni_but,value='Def',font=ft_normal,uvalue=[-88,379,8,1],/no_release)
moni_raw   =Widget_Button (moni_but,value='Raw',font=ft_normal,uvalue=[-88,379,8,2],/no_release)
moni_mon   =Widget_Button (moni_but,value='M:' ,font=ft_normal,uvalue=[-88,379,8,3],/no_release)
nomb	   =Widget_Text	  (base113 ,value=strtrim(string(nomo),2),xsize=7+cap,/Editable  ,font=ft_propor)

;============================== BASE 13 RUNS SELECTOR ========================
base13     =Widget_Base  (base1	   ,/Column,/Frame)

base131	   =Widget_Base	 (base13   ,/Row)
rs1_lab	   =Widget_Label (base131  ,value='RUNS SELECTOR ',font=ft_biggest)
helprs_but =Widget_Button(base131  ,value='?',uvalue=[-88,379,10]  ,font=ft_b_normal)

base132	   =Widget_Base	 (base13   ,/Row)
spect1_text=Widget_Text	 (base132  ,xsize=20,/Editable,value=spect1,font=ft_propor)
read1_but  =Widget_Button(base132  ,value='Read',font=ft_b_normal)

base133	   =Widget_Base	 (base13   ,/Row)
spect2_text=Widget_Text	 (base133  ,xsize=20,/Editable,value=spect2,font=ft_propor)
read2_but  =Widget_Button(base133  ,value='Read',font=ft_b_normal)

mes_lab	   =Widget_Label (base13   ,value=string(replicate(32b,50)),font=ft_b_normal,xsize=200)

rsmes_lab  =Widget_Label (base13   ,value=string(replicate(32b,50)),font=ft_b_normal,xsize=200)

;============================== EXIT =========================================

if n_elements(pth) eq 1 then begin
	buse=Widget_Base   (base,/Row)
	exit_but   =Widget_Button (buse,value='EXIT',uvalue=[-88,379,11],font=ft_biggest)
	bid =Widget_Label  (buse,value='Path:',font=ft_b_normal)
	bid =widget_button(buse,font=ft_b_normal,value=cycle,menu=2) 
	  uval =[-88,561,0,b_labins(0),b_labins(1)]
	  for i=0,n_elements(lamp_ali)-1 do begin
	      if strpos(strlowcase(lamp_ali(i)),'c_year') ge 0 then begin
		yr =strtrim(strmid(lamp_ali(i),7,15),2) & yr=strmid(yr,2,2)
		didon=widget_button(bid  ,font=ft_b_normal,menu=2		    	,value=lamp_ali(i))
		for j=1,5 do begin  yrs=yr+strtrim(string(j),2)
		 bido=widget_button(didon,font=ft_b_normal,uvalue=[uval,i,bid,long(yrs)],value='Cycle '+yrs)
		endfor
	      endif else $
		bidon=widget_button(bid  ,font=ft_b_normal,uvalue=[uval,i,bid,0]	,value=lamp_ali(i))
	  endfor   

endif else exit_but=Widget_Button (base,value='EXIT',uvalue=[-88,379,11],font=ft_biggest)

;============================== END BASE =====================================

;============================== Set_Uvalue Read buttons ======================

if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1

Widget_Control,	read1_but  ,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect1_text,rsmes_lab,'1']
Widget_Control,	read2_but  ,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect2_text,rsmes_lab,'2']
if txev then $
Widget_Control,	spect1_text,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect1_text,rsmes_lab,'1']
if txev then $
Widget_Control,	spect2_text,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect2_text,rsmes_lab,'2']

					
If filter_config.xrange then Widget_Control,	xrange_but,	/Set_Button				
If filter_config.yrange then Widget_Control,	yrange_but,	/Set_Button
If filter_config.zrange then Widget_Control,	zrange_but,	/Set_Button

If filter_config.xproj  then Widget_Control,	xproj_but,	/Set_Button				
If filter_config.yproj  then Widget_Control,	yproj_but,	/Set_Button
If filter_config.zproj  then Widget_Control,	zproj_but,	/Set_Button

If filter_config.moni eq 1 then Widget_Control,	moni_def ,	/Set_Button
If filter_config.moni eq 2 then Widget_Control,	moni_raw ,	/Set_Button
If filter_config.moni eq 3 then Widget_Control,	moni_mon ,	/Set_Button


Widget_Control,	 base   ,group_leader=lamp_b1,/Realize & put_logo

if lamp_b1 gt 0  then $
	Xmanager,'RDFILTER',base,Event_Handler='LAMP_EVENT_PARSER',/just_reg $
else	Xmanager,'RDFILTER',base,Event_Handler='LAMP_EVENT_PARSER'

endif
return
end


function rdgsas, INST , PATH , FILENAME , STATUS , DATP
;******* *************  
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.
 DATA  =0
 STATUS=11
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

 ON_IOERROR, no_file
 OPENR,unit, PATH+FILENAME,/get_lun				;Open the data file

     STATUS=13
     ON_IOERROR, read_err
     wt='                                                                 '
     readf, unit , wt, format='(A80)'
     st1='            ' & st2= '           '
     npoints=0 & nlines=0 & nn=1 & zero= -220. & d2th= 10
     st4='            ' & st3= '           '
     readf, unit,     st1, nn ,npoints,nlines,st2,zero,d2th, $ 
            format = '(A4, I2, I5, I4, A6, I5, I3)'
     datall=intarr(2,npoints)
     readf, unit, datall, format = '(10(I2, I6))'      
     data=fltarr(npoints)+1.
     data=data*datall(1,*)
     err=fltarr(npoints)+1.
     err=err*sqrt(data)/sqrt((datall(0,*)>.25))
	    xv       =  FINDGEN(npoints)*d2th/100.+zero/100.			;Normaly in data file
	    xt       =' 2 theta (degrees) '			;         .
	    par      = [        3.0       ,        5.5        ]	;	  .
	    ptxt     = ['First  parameter','Second parameter' ]	;	  .
	    pall     =  INDGEN(20,8)

      STATUS=0							;Status is ok
;     ********
      DATP={X:      xv,    $					;Pass those variables which were 
            W_TIT:  wt,    $ 				;read-in into the DATP structure
	           X_TIT:  xt,    $                   
	           P:      par,   $
	           PAR_TXT:ptxt,  $
            E:      err,        $
            N:      fltarr(npoints)+100000. , $
	           PV:     pall   }
;     **********************  					
	    
 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:
 
 RETURN, DATA							;Return the data values
;************

 END
	PRO rdid_d17, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
             	     WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE

	iprint=0


;LAMP data-read interface for D17 data (ILL format) called from rdid.pro
;**********************************************************************
;
;							JRS,RC 9/5/00
;
;Parameters to return
;********************
;WOUT             (modified data)
;WT,XT,YT,ZT,OT   (titles)
;PP,PTXT          (parameter floatting table and textarea)
;XX,YY,ZZ         (coordinates)
;NN               (monitors)
;PV               (supplement parameter table of any dimension)
;EE               (errors from WOUT)



;Useful input parameters from rdid
;*********************************

	IF (iprint GT 0) THEN BEGIN
		HELP, INST 	& PRINT, INST
		HELP, numor 	& PRINT, numor
		HELP, nvers 	& PRINT, nvers
		HELP, text 	& PRINT, text
		HELP, exper 	& PRINT, exper
		HELP, scan 	& PRINT, scan
		HELP, cnt 	& PRINT, cnt
		HELP, WOUT
		HELP, vparm 	& PRINT, vparm
		HELP, param 	& PRINT, param   
		HELP, par1 	& PRINT, par1
		HELP, par2	& IF (N_ELEMENTS(par2) GT 0) THEN PRINT, par2
	ENDIF
		

;Parameters to return
;********************
;WOUT             (modified data)
;WT,XT,YT,ZT,OT   (titles)
;PP,PTXT          (parameter floatting table and textarea)
;XX,YY,ZZ         (coordinates)
;NN               (monitors)
;PV               (supplement parameter table of any dimension)
;EE               (errors from WOUT)

	IF (iprint GT 0) THEN PRINT,'rdid_d17: starting'
	PRINT,'Reading run',numor

	inst       = STRMID(text,0,4)
	user       = STRMID(text,4,12)

	IF (iprint GT 0) THEN BEGIN
		PRINT, 'inst =',inst
		PRINT, 'user =',user
	ENDIF

	user=STRMID(exper(0),0,10)
	main_title=STRMID(exper(0),10,39)
	prop=STRMID(exper(0),49,9)
	sub_title=STRMID(exper(0),60,20)

	IF (iprint GT 0) THEN BEGIN
		PRINT,'user =',user
		PRINT,'main_title =',main_title
		PRINT,'prop =',prop
		PRINT,'sub_title =',sub_title
	ENDIF

;------------------------------------
;	Assign Parameter block
;
	open_req=45.-(param(43)-param(41))
	open_act=45.-(param(47)-param(45))
	period=60./param(44)
	delay_ang=(285.-open_act)/2.
	delay_tim=(delay_ang/360.)*period

	npars=29
	p_buf=FLTARR(npars)
	par_txt_buf=STRARR(npars)

	p_buf(0)=numor 		& par_txt_buf(0)  =' 0  Numor            ='
	p_buf(1)=par1(94)	& par_txt_buf(1)  =' 1  Time Channels    ='
	p_buf(2)=par1(97)	& par_txt_buf(2)  =' 2  X1               ='
	p_buf(3)=par1(98)	& par_txt_buf(3)  =' 3  X2               ='
	p_buf(4)=par1(99)	& par_txt_buf(4)  =' 4  Y1               ='
	p_buf(5)=par1(100)	& par_txt_buf(5)  =' 5  Y2               ='
	p_buf(6)=par1(95)	& par_txt_buf(6)  =' 6  Channel width    ='
	p_buf(7)=par1(96)	& par_txt_buf(7)  =' 7  Electr TOF delay ='
	p_buf(8)=par1(101)	& par_txt_buf(8)  =' 8  NX               ='
	p_buf(9)=par1(102)	& par_txt_buf(9)  =' 9  NY               ='
	p_buf(10)=param(40)	& par_txt_buf(10) =' 10 chop 1 speed req ='
	p_buf(11)=param(41)	& par_txt_buf(11) =' 11 chop 1 phase req ='
	p_buf(12)=param(42)	& par_txt_buf(12) =' 12 chop 2 speed req ='
	p_buf(13)=param(43)	& par_txt_buf(13) =' 13 chop 2 phase req ='
	p_buf(14)=param(44)	& par_txt_buf(14) =' 14 chop 1 speed act ='
	p_buf(15)=param(45)	& par_txt_buf(15) =' 15 chop 1 phase act ='
	p_buf(16)=param(46)	& par_txt_buf(16) =' 16 chop 2 speed act ='
	p_buf(17)=param(47)	& par_txt_buf(17) =' 17 chop 2 phase act ='
	p_buf(18)=open_req	& par_txt_buf(18) =' 18 chop opening req ='
	p_buf(19)=open_act	& par_txt_buf(19) =' 19 chop opening act ='
	p_buf(20)=period	& par_txt_buf(20) =' 20 chop period      ='
	p_buf(21)=delay_ang	& par_txt_buf(21) =' 21 chop delay angle ='
	p_buf(22)=delay_tim	& par_txt_buf(22) =' 22 chop delay time  ='
	p_buf(23)=param(15)	& par_txt_buf(23) =' 23 sam-det distance ='
	p_buf(24)=param(2)	& par_txt_buf(24) =' 24 sample angle     ='
	p_buf(25)=param(16)	& par_txt_buf(25) =' 25 detector angle   ='
	p_buf(26)=par1(2)/10.	& par_txt_buf(26) =' 26 run time         ='
	p_buf(27)=param(8)	& par_txt_buf(27) =' 27 slity thing      ='
	p_buf(27)=par1(4)	& par_txt_buf(28) =' 27 monitor          ='	

	IF (iprint GT 0) THEN PRINT,'parameters assigned OK'

;------------------------------------
	
	tot=cnt
	tsize=LONG(par1(94))
	xsize=LONG(par1(98)-par1(97)+1)
	ysize=LONG(par1(100)-par1(99)+1)

	;IF (tot ne ((xsize*ysize*tsize))) THEN PRINT,'read_d17: Error in data array dimensions'
	IF (iprint GT 0) THEN BEGIN	
		PRINT,'tsize= ',tsize,' detector size= ',xsize*ysize
		PRINT,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',xsize*ysize*tsize,' tot2= ',tot
	ENDIF

	w_buf=WOUT(0:xsize*ysize*tsize-1)
	;if tsize gt 1 then mo=WOUT(xsize*ysize*tsize:cnt-1)	
	mon=par1(4)
        ;if mon le 0. then begin 
	  ;mon=total(mo)
          ;mo=WOUT(xsize*ysize*tsize:cnt-1)
	  ;print,'Using old monitor format'
	;endif
	det=REFORM(w_buf,ysize,xsize,tsize)
	w_buf=FLTARR(xsize,ysize,tsize)
	FOR i=0,tsize-1 DO w_buf(*,*,i)=ROTATE(det(*,*,i),3) 
	x_buf=INDGEN(xsize)+par1(97)
	y_buf=INDGEN(ysize)+par1(99)
	z_buf=INDGEN(tsize)
	n_buf=mon

;------------------------------------
	WOUT=w_buf
	PP=p_buf
	PTXT=par_txt_buf
	NN=n_buf
	XX=x_buf
	YY=y_buf
	ZZ=z_buf
	WT=sub_title
	OT=inst+' '+user+' '+main_title
	XT='X pixels'
	YT='Y pixels'
	ZT='Time channels'
	
	IF (iprint GT 0) THEN PRINT,'rdid_d17: finished'

	RETURN
	END
PRO rdid_d20, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                 WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE

common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
  common d20, bad_d20 ,flag_d20, wav_d20, psd_d20  

  if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION RDDAT')

  WOUT=WOUT>0
  nd=cnt
  DATI     = strmid(exper(5),20,18)
  IF strpos(DATI,'Stop',0) GE 0 THEN BEGIN
    DATI='16-Apr-02 20:00:00'
  ENDIF
  day      = strmid(DATI,0,2)
  month    = strmid(DATI,3,3)
  year     = strmid(DATI,7,2)
  hour     = strmid(DATI,10,2)
  minute   = strmid(DATI,13,2)
  second   = strmid(DATI,16,2)
  charpos=0
  IF  STRMID(year,0,1) GT '9' OR  STRMID(year,0,1) LT '0'  OR STRMID(year,1,1) GT '9' OR  STRMID(year,1,1) LT '0' THEN BEGIN 
			  	charpos=strpos(text(0),':',0)-2
			  	hour=strmid(text(0),charpos,2)
		  		hour=strmid('00'+hour,strlen(hour),2)
				charpos=charpos+3
			  	secpos=strpos(text(0),':',charpos)
				minute=strmid(text(0),charpos,secpos-charpos)
			  	minute=strmid('00'+minute,strlen(minute),2)
			  	second=strmid(text(0),secpos+1,2)
			  	second=strmid('00'+second,strlen(second),2)
			  	charpos=strpos(text(0),' ',secpos)+1
		  		secpos=strpos(text(0),'-',charpos)
				day=strmid(text(0),charpos,secpos-charpos)
			  	day=strmid('00'+day,strlen(day),2)
			  	charpos=secpos+1
		 	        secpos=strpos(text(0),"-",charpos)
			  	month=strmid(text(0),charpos,secpos-charpos)
			  	month=strmid('   '+month,strlen(month),3)
			  	charpos=secpos+1
			  	year=strmid(text(0),charpos,2)
			  	year=strmid('00'+year,strlen(year),2)
				DATI=day+"-"+month+"-"+year+" "+hour+":"+minute+":"+second
  ENDIF ELSE BEGIN
  	hour     = strmid(DATI,10,2)
  	minute   = strmid(DATI,13,2)
  	second   = strmid(DATI,16,2)
  ENDELSE
  IF nd EQ 1600 THEN BEGIN
	IF total(WOUT(128:1599,*)) EQ 0 AND year EQ "96" THEN BEGIN     ; old PSD 128 cells
            	WOUT  =  WOUT(0:127,*)
            	nd=128
            	if n_elements(vparm) lt 26.*scan then vparm=fltarr(26,scan)
  	ENDIF
  ENDIF
  WOUT=float(WOUT)
  IF N_ELEMENTS(vparm) GE  1 THEN vparm=vparm(*,0:N_elements(WOUT(0,*))-1)
  nj = N_ELEMENTS(wout(0,*))
  EE  = WOUT/sqrt(1+WOUT)
  IF n_elements(par5) eq 0 THEN BEGIN                          ; Numor bug fix
	       par5=par4
	       par4=par3
	       par3=0
  ENDIF
  IF year GT 60 THEN par1(51)=par1(51)/1000000.                ; CntTime in sec (raw data before 2000: microsec)
  IF n_elements(par5) eq 25 THEN BEGIN                         ; Numor bug fix
	   	par5=[par5(0:19),0.,0.,0.,0.,0.,par5(20:24)]
       	param=[0.,param]
     	FOR i=0,nj-1 Do wout(*,i)=[wout(nd-1,i),wout(0:nd-2,i)] 
  ENDIF
  CntTime  = par1(51)
  proposal = strmid(exper(2),20 ,9)
  WT  =  ' '+strcompress(strmid(exper(0),20,40)) $
   	    +' '+strcompress(strmid(exper(3),20,40))
  OT = INST(0)  +' '+ DATI $
     	        +' User '+strmid(exper(1),20,8)$
     	  	    +' L.C.' +strmid(exper(4),20,7)$
		        +' Run'  +strcompress(string(numor)) 
  CASE month OF
       'Jan':  MON=1
       'Feb':  MON=2
       'Mar':  MON=3
       'Apr':  MON=4
       'May':  MON=5
       'Jun':  MON=6
       'Jul':  MON=7
       'Aug':  MON=8
       'Sep':  MON=9
       'Oct':  MON=10
       'Nov':  MON=11
       'Dec':  MON=12
  ENDCASE					
  IF par5(25) LT 963 THEN BEGIN                                  ; evt. missing reactor cycle
	  	par5(25)=year*10+ROUND(((mon-1.)*30.5+(day-1.))/366.*5.)
  ENDIF
  CYCLE = long(par5(25))
  IF N_ELEMENTS(inf_d20) EQ 0 THEN BEGIN
      IF CYCLE NE long(year*10+1+ROUND(((mon-1.)*30.5+(day-1.))/366.*4.)) THEN PRINT,"Cycle is",cycle," but probably should be",long(year*10+1+ROUND(((mon-1.)*30.5+(day-1.))/366.*4.))
  ENDIF
  if year le 60 then century=20 else century=19
  jul_day=julday(mon,day,century*100+year)-julday(1,1,1970)
  jul_sec=hour*3600.0+minute*60.0+second
  ;****** CHECK WAVELENGTH ************
  IF ROUND(10*par5(3)) LE 26 AND ROUND(10*par5(3)) GE 25 THEN BEGIN
      wav=2.52
      IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
        IF ROUND(par5(1)) NE   1 THEN PRINT,'2.52A, HOPG-Monochromator, Filters should be in but they are not'
        IF ROUND(par5(4)) NE  44 THEN PRINT,'2.52A, HOPG-Monochromator, TakeOff should be 44deg but it is at',ROUND(par5(4))
        IF ROUND(par5(5)) NE 120 THEN PRINT,'2.52A, HOPG-Monochromator, MonoChanger should be 120deg but it is at',ROUND(par5(5))
      ENDIF
  ENDIF ELSE BEGIN
      IF ROUND(10*par5(3)) LE 24 AND ROUND(10*par5(3)) GE  20 THEN BEGIN
        wav=2.41
        IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
          IF ROUND(par5(1)) NE   1 THEN PRINT,'2.41A, HOPG-Monochromator, Filters should be in but they are not'
          IF ROUND(par5(4)) NE  42 THEN PRINT,'2.41A, HOPG-Monochromator, TakeOff should be 42 deg but it is at',ROUND(par5(4))
          IF ROUND(par5(5)) NE 120 THEN PRINT,'2.41A, HOPG-Monochromator, MonoChanger should be 120 deg but it is at',ROUND(par5(5))
        ENDIF
      ENDIF ELSE BEGIN
        IF ROUND(10*par5(3)) LE 19 AND ROUND(10*par5(3)) GE 15 THEN BEGIN
          wav=1.36
          IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
            IF ROUND(par5(1)) NE   0 THEN PRINT,'1.36A, Cu-Monochromator, Filters should be out but they are not'
            IF ROUND(par5(4)) NE  44 THEN PRINT,'1.36A, Cu-Monochromator, TakeOff should be 44 deg but it is at',ROUND(par5(4))
            IF ROUND(par5(5)) NE 210 THEN PRINT,'1.36A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
          ENDIF
        ENDIF ELSE BEGIN
          IF ROUND(10*par5(3)) LE 13 AND ROUND(10*par5(3)) GE 10 THEN BEGIN
            wav=1.30
            IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
              IF ROUND(par5(1)) NE   0 THEN PRINT,'1.30A, Cu-Monochromator, Filters should be out but they are not'
              IF ROUND(par5(4)) NE  42 THEN PRINT,'1.30A, Cu-Monochromator, TakeOff should be 42 deg but it is at',ROUND(par5(4))
              IF ROUND(par5(5)) NE 210 THEN PRINT,'1.30A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
            ENDIF
          ENDIF ELSE BEGIN
            IF ROUND(100*par5(3)) LE 99 AND ROUND(100*par5(3)) GE 91 THEN BEGIN
              wav=0.94
              IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                IF ROUND(par5(1)) NE   0 THEN PRINT,'0.94A, Cu-Monochromator, Filters should be out but they are not'
                IF ROUND(par5(4)) NE  30 THEN PRINT,'0.94A, Cu-Monochromator, TakeOff should be 30 deg but it is at',ROUND(par5(4))
                IF ROUND(par5(5)) NE 210 THEN PRINT,'0.94A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
              ENDIF
            ENDIF ELSE BEGIN
              IF ROUND(100*par5(3)) LE 90 AND ROUND(100*par5(3)) GE 85 THEN BEGIN
                wav=0.88
                IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                  IF ROUND(par5(1)) NE   0 THEN PRINT,'0.88A, Cu-Monochromator, Filters should be out but they are not'
                  IF ROUND(par5(4)) NE  28 THEN PRINT,'0.88A, Cu-Monochromator, TakeOff should be 28 deg but it is at',ROUND(par5(4))
                  IF ROUND(par5(5)) NE 210 THEN PRINT,'0.88A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
                ENDIF
              ENDIF ELSE BEGIN
                IF ROUND(100*par5(3)) LE 84 AND ROUND(100*par5(3)) GE 70 THEN BEGIN
                  wav=0.82
                  IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                    IF ROUND(par5(1)) NE   0 THEN PRINT,'0.82A, Cu-Monochromator, Filters should be out but they are not'
                    IF ROUND(par5(4)) NE  26 THEN PRINT,'0.82A, Cu-Monochromator, TakeOff should be 28 deg but it is at',ROUND(par5(4))
                    IF ROUND(par5(5)) NE 210 THEN PRINT,'0.82A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
                  ENDIF
                ENDIF ELSE BEGIN
                  IF N_ELEMENTS(inf_d20) LE 1 THEN PRINT,'Do you really have a wavelength of',par5(3),' Angstroem?'
                ENDELSE
              ENDELSE
            ENDELSE
          ENDELSE
        ENDELSE
      ENDELSE
  ENDELSE
  ;WIDGET_CONTROL,wid1,/APPEND,SET_VALUE='Reading Flags'
  ;########VVVVVVV Reading several flags form rdid.flag VVVVVVV######################
  IF N_ELEMENTS(flag_d20) LT 8 THEN flag,/noprint,old=flag_d20
		bad_flag=     flag_d20(0)
		interpol_flag=flag_d20(1)
		ang_flag=     flag_d20(2)
		wav_flag=     flag_d20(3)
		normalize=    flag_d20(4)
		float_flag=   flag_d20(5)
		eff_flag  =   flag_d20(6)
		cor_flag=     flag_d20(7)
  ;########VVVVVV EFFICIENCY/Angle CALIBRATION VVVVVVVV######################
  IF N_ELEMENTS(inf_d20) EQ 0 THEN BEGIN
      inf_d20='autod20.cal'
  ENDIF ELSE IF N_ELEMENTS(inf_d20) EQ 1 THEN IF STRCOMPRESS(inf_d20,/RE) EQ '0' THEN inf_d20 ='autod20.cal'
  IF N_ELEMENTS(cal_d20) EQ 0 THEN BEGIN
      cal_d20=0
  ENDIF  
  default_cal = 0
  IF n_elements(inf_d20) EQ 0 THEN BEGIN
  		default_cal=1 
  ENDIF ELSE BEGIN
  	IF inf_d20(0) EQ 'autod20.cal' THEN BEGIN
		default_cal=1
  	ENDIF ELSE BEGIN
		IF N_ELEMENTS(inf_d20) GE 3 THEN BEGIN
			IF inf_d20(2) EQ 'autod20.cal' THEN BEGIN
				default_cal=1
			ENDIF
		ENDIF
  	ENDELSE
  ENDELSE
  IF default_cal EQ 1 AND (ang_flag EQ 1 OR eff_flag EQ 1) THEN BEGIN
	IF N_ELEMENTS(inf_d20) EQ 0 THEN inf_d20=['autod20.cal','not loaded','autod20.cal']
	count=N_ELEMENTS(inf_d20)
	IF count LT 4 THEN BEGIN
    	PRINT,'Looking up for calibration files in ',PATHCAL
		tmf     =PATHCAL
		current_dir=''
		cd,current=current_dir,tmf
		tmp     =findfile(inst(0)+'_????_??_??????.???',count=tmc) 
		cd,current_dir
		IF tmc GT 0 THEN filelist=strmid(tmp,strpos(tmp(0),inst(0)),22) else print,"Are you really on the right workstation (d20sgi.ill.fr)?"
		IF N_ELEMENTS(filelist) LE 0 THEN BEGIN
			PRINT,'NO auto-calibration file found!'
			inf_d20=['','','']
			default_cal=0
			filelist=''
		ENDIF else print,'Files in ~lambda/CALIBRATION ',filelist
        IF N_ELEMENTS(inf_d20) LT 2 THEN inf_d20=['autod20.cal','']
		inf_d20=[inf_d20(0:1),'autod20.cal',STRING(filelist)]
	ENDIF ELSE filelist= inf_d20(3:count-1)  ; NEW calibration file naming
    tmplist=filelist	
    tmp=where(STRMID(filelist,strlen(inst(0))+16,3) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3),count)
    IF count LE 0 THEN tmp=where(STRMID(filelist,strlen(inst(0))+16,2) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,2),count)
    IF count le 0 then BEGIN
    	tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,1),count)
        IF count le 0 then tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*((wav+1)<9))),1,1),count)
        IF count le 0 then tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*((wav-1)>0))),1,1),count)
    ENDIF
    IF count gt 0 then begin
    	tmplist=filelist(tmp)
    	tmp=where(tmplist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3),count)
    ENDIF
	IF count GT 0 THEN tmp=MAX(tmplist(tmp)) ELSE BEGIN
      	PRINT,'Apparently there is no calibration for ',wav,' Angstroem ',STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3)
		tmp=WHERE(filelist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+STRMID(STRING(f='(I4)',1000+ROUND(100*par5(3))),1,3),count)
		IF count GT 0 THEN tmp=MAX(filelist(tmp)) ELSE tmp=MIN(filelist)
        PRINT,tmp,' will be taken for calibration'
    ENDELSE
	calfile=STRCOMPRESS(tmp,/re)
  ENDIF
  ON_IOERROR,badmisread
		IF bad_flag EQ 1  OR  bad_flag NE 1 THEN BEGIN
			count=N_ELEMENTS(psd_d20)
			;help,psd_d20
			IF count LT 1 THEN psd_d20=['empty']
			IF count LT 2 THEN BEGIN
				tmf     =PATHCAL ; P_LAMBDA(0)+'/BAD_CELLS/'
				cd,current=current_dir,tmf
				tmp     =findfile(tmf+inst(0)+'_????_??_??????.bad',count=tmc) ; NEW  file names
				cd,current_dir
				if tmc gt 0 then badlist=strmid(tmp,strpos(tmp(0),inst(0)),22) else print,"Are you really on the right workstation (d20sgi.ill.fr)?"
				IF N_ELEMENTS(badlist) LE 0 THEN BEGIN
					PRINT,'NO bad cells file found!'
					psd_d20=['empty']
					bad_flag=0
					badlist=''
				ENDIF ELSE BEGIN
            		IF bad_flag EQ 1 THEN print,'Creating new bad cells filelist'
            		IF bad_flag EQ 1 THEN PRINT,' ',badlist
          		ENDELSE
				psd_d20=[string(psd_d20(0)),badlist]
				;help,psd_d20
			ENDIF ELSE badlist=psd_d20(1:count-1)
       		tmp=where(badlist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+'bad',count)
			IF count GT 0 THEN tmp=MAX(badlist(tmp)) ELSE  tmp=MIN(badlist)
 			IF psd_d20(0) NE tmp THEN BEGIN
            	psd_d20(0)=tmp
            	IF bad_flag EQ 1 THEN print,'data       : ',PATHCAL+psd_d20(0)
				bad_d20=rddat('data',PATHCAL,psd_d20(0),rddat_status,rddat_datp)
				PRINT,'Bad_cells file loaded : ',psd_d20(0)
            	IF bad_flag EQ 1 THEN print,'Bad cells: ',STRCOMPRESS(ROUND(bad_d20))
       		ENDIF
		ENDIF
  badmisread:
		IF wav_flag EQ 1 THEN BEGIN
	    count=N_ELEMENTS(wav_d20)
  	 	IF count LT 1 THEN wav_d20=[0.,0.,0.]
  	 	IF count LT 4 THEN BEGIN
					p_lambda,plambda
				    	tmf     =PLAMBDA+'/RIETVELD/'
					cd,current=current_dir,tmf
				    	tmp     =findfile(tmf+'?????????.d20',count=tmc)
					cd,current_dir
				    	if tmc gt 0 then filelist=LONG(strmid(tmp,strpos(tmp(0),'.d20')-9,9))
					    IF N_ELEMENTS(filelist) LE 0 THEN BEGIN
						    		  PRINT,'NO wavelength/zeroshift file found!'
					  	  				wav_d20=[0.,0.,0.]
					  	  				bad_flag=0
										    filelist=''
					  	 ENDIF else print,'Creating newwavelength/zeroshift file list',filelist
					  	 wav_d20=[wav_d20(0:2),filelist]
				ENDIF ELSE filelist=wav_d20(1:count-1)
				tmp=WHERE(filelist LE LONG(cycle)*1000000+numor,count)
				IF count GT 0 THEN tmp=MAX(filelist(tmp)) ELSE tmp=MIN(filelist)
				wav_d20(0)=LONG(tmp)
				OPENR,tmp,tmf+STRING(STRCOMPRESS(wav_d20(0),/REMOVE_ALL))+'.d20',/get_lun
				READF,tmp,line
				READF,tmp,wav_d20(1:2)
				FREE_LUN,tmp
		ENDIF
  ;help,inf_d20
  ;print,inf_d20
		IF N_ELEMENTS(inf_d20) ge 3 THEN IF N_ELEMENTS(calfile) GE 1 THEN IF calfile NE inf_d20(0) THEN IF inf_d20(2) EQ 'autod20.cal' THEN BEGIN
         inf_d20(2) = 'autochoice'
         P_DID_CALOD, INST(0),calfile, flg 
         inf_d20(2) = 'autod20.cal'
  ENDIF
  IF N_ELEMENTS(inf_d20) GE 2 THEN BEGIN
    IF STRMID(inf_d20(1),37,8) LT '3' THEN wavelength=FLOAT(STRMID(inf_d20(1),37,8)) 
  ENDIF ELSE wavelength=0
  ;####### Efficiency Correction by MULTIPLICATION with efficiency-CORRECTION data! ###########
  IF float_flag EQ 1 THEN WOUT=FLOAT(WOUT)
  IF n_elements(cal_d20(*,0)) eq nd AND eff_flag EQ 1 THEN BEGIN 
         OT=OT+'*'+inf_d20(0)
         FOR i=0,nj-1 DO FOR j=0,nd-1 DO BEGIN 
           wout(j,i)=wout(j,i)*cal_d20(j,0) 
           EE(j,i)= EE(j,i)*cal_d20(j,0) 
         ENDFOR 
  ENDIF
  IF n_elements(cal_d20(*,0)) eq 0 THEN cal_d20=0
  IF float_flag NE 1 THEN BEGIN
      IF eff_flag EQ 1 OR normalize GT 0 THEN PRINT,'Attention : Workspace is NOT floating point, but it should be!'
  ENDIF
  SequenceType    = par1(0) 
  StroboType      = par1(40) 
  NbOfSegments    = par1(1)  
	 PV = fltarr(31,scan)
	 NN = fltarr(scan)
	 FOR i=0,scan-1 DO BEGIN
	       PV(0:4,i)   = par1(0:4)	
	       PV(5,i)     = par1(51)		    				; CntTime in sec.
	       PV(6:7,i)   = par5(26:27)	  					; RtrPower,D19
	       PV(8,i)     = par5(14)		    				; OS
	       PV(9:19,i)  = param(0:10) 	 					; SampEnv,TempValues,MotorValues,Voltmeter1
	       PV(20,i)    = (par5(12)<30)+(par5(13)<30) 	 	; hor.  MonoSlits
	       PV(21,i)    = (par5(10)<140)+(par5(11)<140) 	 	; vert. MonoSlits
	       PV(22,i)    = par5(18)+par5(19) 	 				; hor.  SampleSlits
	       PV(23,i)    = par5(16)+par5(17) 	 				; vert. SampleSlits
	       PV(24,i)    = 0.0		         				; TimeStep
	       PV(25:27,i) = par1(45:47)	  					; TimeSlice,TimeDelay,TimeWindow
	       PV(28,i)    = i             						; Slice_No or sub-numor, for scans it will contain the inner stepwidth (later on ...)
	       PV(29,i)    = numor
	       PV(30,i)    = par1(50)      						; monitor
	       NN(i)       = par1(50)
	   ENDFOR
	   IF nj LE 1 THEN NN = par1(50)
	   IF N_ELEMENTS(vparm) GE 1 THEN BEGIN
      IF N_ELEMENTS(vparm(*,0)) GE 26 THEN BEGIN                                 ; NOT Stroboscopie
	       PV(0:4,*)  = vparm(0:4,*) 
        PV(5:20,*) = vparm(6:21,*) 
        PV(5,*)    = PV(5,*)/1000000.                          ; CntTime in sec (not microsec)
		      NN(*)= (vparm(5,*) EQ 0.)*NN(*)+vparm(5,*)
		      PV(30,*)=nn(*)
      ENDIF ELSE BEGIN 
        IF N_ELEMENTS(vparm(*,0)) GE 5 THEN BEGIN
	         PV(25:27,*)= vparm(0:2,*)  
	         PV(5,*)    = vparm(4,*) /1000000.                          ; time in sec (not microsec)
		        NN(*)= (vparm(3,*) EQ 0.)*NN(*)/PV(5,0)*PV(5,*)+vparm(3,*) ; tot.monitor if slice-mon. zero 
          IF vparm(4,0) LT vparm(3,0) THEN BEGIN                     ; Monitor-time confusion in the reading of the 51st scaler
		          PV(5,*)    = vparm(3,*) /1000000.                        ; time in sec (not microsec)
					       NN(*)      = vparm(4,*)
            IF nvers EQ 2 THEN BEGIN
              brico=indgen(nj)*3
		  						  		brico=brico(WHERE(brico LT nj))
		            PV(26:27,brico)= vparm(0:1,brico)                                ; even more confusions
		            PV(25,brico)   = vparm(2,brico)                                  ; even more confusions
              brico=indgen(nj)*3+1
								    		brico=brico(WHERE(brico LT nj))
		            PV(25:26,brico)= vparm(1:2,brico)                                ; even more confusions
		            PV(27,brico)   = vparm(0,brico)                                  ; even more confusions
					  	    ENDIF
					  	  ENDIF
		        PV(30,*)=nn(*)
				    ENDIF
				  ENDELSE
				ENDIF
    IF cor_flag EQ 1 THEN IF Cycle LE 974 THEN IF cycle GE 973 THEN IF numor LE 20200 THEN IF numor GE 8451 THEN BEGIN
      IF StroboType EQ 0 THEN IF scan EQ 1 OR SequenceType NE 0 THEN BEGIN
	    p_lambda,plambda
        corname =PLAMBDA+'/MONITOR/'+STRCOMPRESS(STRING(LONG(cycle)), /REMOVE_ALL)+'.cor'
        OPENR,cor,corname,/get_lun
        READF,cor,corrections
        IF corrections GT 0 THEN BEGIN
	      cornum=fltarr(3,corrections)
	      READF,cor,cornum
		ENDIF
		FREE_LUN,cor
		corind=WHERE(cornum(0,*) EQ numor,corrections)
		IF corrections EQ 1 THEN BEGIN
			PRINT,'Corrections will be applied: ',corname
			cornum=cornum(1:2,corind)
        	PV(30,*)=PV(30,*)-cornum(0)
        	NN      =NN      -cornum(0)
        	PV(5,*) =PV(5,*) -cornum(1)
		ENDIF ELSE PRINT,'Looked for corrections but found nothing',corrections
      ENDIF
	ENDIF
	MotPar=fltarr(6)
	MotTxt=['2*Theta/deg.     ','Omega  /deg.     ',$
	        'Chi    /deg.     ','Phi    /deg.     ',$
		    'Tr.1   /mm (horz)','Tr.2   /mm (vert)']
	FOR i=0,5 DO BEGIN 
		IF par1(12+i*5) EQ 0.0 THEN BEGIN
	       MotPar(i)=param(4+i) 
	       MotTxt(i)=MotTxt(i)+'       '
	    ENDIF ELSE BEGIN
	       MotPar(i)=par1(12+i*5)
	       MotTxt(i)=MotTxt(i)+'       '
      	ENDELSE
	ENDFOR
    step_or_sub='Sub-Numor or Slice-No.  '
    ScanText=   'Unknown Scan Type       '                        
    IF  SequenceType eq  0 THEN ScanText='Single Data Acquisition '
    IF  SequenceType eq  1 THEN ScanText='Sequential Acquisition  '
    IF  SequenceType eq  2 THEN ScanText='Temperature Scan        '
    IF  SequenceType eq  3 THEN ScanText='2Theta Scan             '
    IF  SequenceType eq  4 THEN ScanText='Omega Scan              '
    IF  SequenceType eq  5 THEN ScanText='Chi Scan                '
    IF  SequenceType eq  6 THEN ScanText='Phi Scan                '
    IF  SequenceType eq  7 THEN ScanText='Translation 1 Scan      '
    IF  SequenceType eq  8 THEN ScanText='Translation 2 Scan      '
    IF  SequenceType eq  9 THEN ScanText='Other Scan              '
				inner=long(SequenceType)-2
    IF  SequenceType gt 10 THEN BEGIN
             ScanTextArray=['Sing.','Sequ.','Temp.','2Th. ','Omega','Chi  ','Phi  ','Tr.1 ','Tr.2 ','Seven','Else ']
             ScanText=ScanTextArray((long(SequenceType) /   10)<10)
             outertext=ScanText
             outer=(long(SequenceType)  /  10) - 2
             ScanText=ScanTextArray((long(SequenceType) mod   10)<10)
             innertext=ScanText
             inner=(long(SequenceType) mod 10) - 2
             ScanText=outerText+'/'+innertext+'coupled Scan '
    ENDIF
    IF inner GE 0 THEN BEGIN
				  PV(28,*)=par1(7+inner*5) 
						step_or_sub='Sub-Numor or Slice-No.  '
						step_or_sub='(inner) Scan Step-Width '
    ENDIF
	   PP  =[PV(0:30),par5(0:1),par5(3),$                   
		        StroboType,$      
		        par1(41),0,0,0,0]
    IF CntTime EQ 0.0 THEN BEGIN            ; IF Real Counting Time not measured
				  CntTime=PV(25,0)*PP(35)/8000000.      ; missing 51st scaler, 1 ACQ = 1 Slice (before modification)
						PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.)
				ENDIF
    IF CntTime LT 0.0 THEN BEGIN            ; Real Counting Time GE 1 hour: Value becomes negative
				  CntTime=PV(25,0)*PP(35)/8000000.*2.   ; 51st scaler present, 1 ACQ = 2 Slices (after modification)
						IF StroboType eq 0 THEN PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.*2.) ELSE PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.)
				ENDIF
				PP(5)=TOTAL(PV(5,*))                    ; Total counting time in fixed parameter 
				CntTime=PP(5)
    IF charpos NE 0 THEN BEGIN
				  day  = STRCOMPRESS(STRING(LONG(day)   -   LONG(CntTime)  /  86400),/remove_all)
				  hour  =STRCOMPRESS(STRING(LONG(hour)  -  (LONG(CntTime) MOD 86400)  /  3600),/remove_all)
				  minute=STRCOMPRESS(STRING(LONG(minute)- ((LONG(CntTime) MOD 86400) MOD 3600)  /  60),/remove_all)
				  second=STRCOMPRESS(STRING(LONG(second)-(((LONG(CntTime) MOD 86400) MOD 3600) MOD 60)),/remove_all)
      IF LONG(second) LT 0 THEN BEGIN
						  second = STRCOMPRESS(STRING(LONG(second)+60),/remove_all)
							 minute = STRCOMPRESS(STRING(LONG(minute)- 1),/remove_all)
						ENDIF
      IF LONG(minute) LT 0 THEN BEGIN
						  minute = STRCOMPRESS(STRING(LONG(minute)+60),/remove_all)
							 hour   = STRCOMPRESS(STRING(LONG(hour  )- 1),/remove_all)
						ENDIF
      IF LONG(hour  ) LT 0 THEN BEGIN
						  hour   = STRCOMPRESS(STRING(LONG(hour  )+60),/remove_all)
							 day    = STRCOMPRESS(STRING(LONG(day   )- 1),/remove_all)
						ENDIF
      IF LONG(day   ) LT 0 THEN BEGIN
						  second = STRCOMPRESS(STRING(0),/remove_all)
						  minute = STRCOMPRESS(STRING(0),/remove_all)
						  hour   = STRCOMPRESS(STRING(0),/remove_all)
							 day    = STRCOMPRESS(STRING(1),/remove_all)
						ENDIF
      day='00'+day
      day=strmid(day,strlen(day)-2,2)
      hour='00'+hour
      hour=strmid(hour,strlen(hour)-2,2)
      minute='00'+minute
      minute=strmid(minute,strlen(minute)-2,2)
      second='00'+second
      second=strmid(second,strlen(second)-2,2)
						DATI=day+"-"+month+"-"+year+""+hour+":"+minute+":"+second
      OT = INST(0)   +' '+ DATI $
     	   +' User '+strmid(exper(1),20,8)$
     	  	+' L.C.' +strmid(exper(4),20,7);$
		       ;+' Run'  +strcompress(string(numor)) 
				ENDIF
    PTXT=[$
                  ScanText   $
                 ,'Number of Segments      ','Segment Number          '$
                 ,'Number of Data Sets     ','Data Set Number         '$
                 ,'TOTAL Counting Time/s   ','Reactor Power / MW      '$
                 ,'D19 State               ','OS closed/open (0/1)    '$
                 ,'Sample Environment      ','Set Temperature         '$
                 ,'Regulation Temperature  ','Sample Temperature      '$
                 , MotTxt(0:5)$
                 ,'Voltmeter1              ','hor. MonoSlits / mm     '$
                 ,'vert. MonoSlits / mm    ','hor. SampleSlits / mm   '$
                 ,'vert. SampleSlits / mm  ','Time Step               '$
                 ,'Time Slice              ','Time Delay              '$
                 ,'Time Window             ', step_or_sub              $
                 ,'Numor                   ','Original Monitor Counts '$
                 ,'Incid. divergence alpha1','HOPG Filters IN/OUT     '$
                 ,'Wavelength / Angstroem  '$
                 ,'Stroboscopic Mode       ','Number of strob. Cycles '$
                 ,'Calibration Wavelength/A','Raw Data TwoTheta Offset'$
                 ,'Correction Eff./Ang./Bad','Normalisation Mon./Time '$
                 ,'Monochromator TakeOff   ','Monochromator Changer   '$
                 ,'Monochromator Rocking   ','Monochromator Tilt      '$
                 ,'Monochromator Bending   ','Lead Blocks             '$
                 ,'Monochromator Slit Top  ','Monochromator Slit Bottm'$
                 ,'Monochromator Slit Left ','Monochromator Slit Right'$
                 ,'Vacuum tube pressure    '$
                 ,'Sample Slit Top         ','Sample Slit Bottom      '$
                 ,'Sample Slit Left        ','Sample Slit Right       '$
                 ,'ReactorCycle            ','Magnetic Field          '$
		 ,'Julian Days since 1970  ','Seconds since noon      ']
           mag=0.0
           IF N_ELEMENTS(param) GE 16 THEN mag=param(15)
	PP=[PP,par5(4:13),par5(15:19),par5(25),mag,jul_day,jul_sec]
	FOR i=0,N_ELEMENTS(PP)-1 DO PTXT(i)=PTXT(i)+' ('+STRMID(STRCOMPRESS(100+i,/RE),1,2)+')'
	IF N_ELEMENTS(PV(0,*)) GT 1 THEN BEGIN
		PV_tmp=PV
		old_dim=N_ELEMENTS(PV(*,0))
		PV=FLTARR(N_ELEMENTS(PP),N_ELEMENTS(PV(0,*)))
		PV(0:old_dim-1,*)=PV_tmp(0:old_dim-1,*)
		FOR i=0,scan-1 DO PV(old_dim:N_ELEMENTS(PP)-1,i)=PP(old_dim:N_ELEMENTS(PP)-1)	
	ENDIF ELSE BEGIN
		PV=[PV,PP(N_ELEMENTS(PV):N_ELEMENTS(PP)-1)]
	ENDELSE
	IF year GT 60 THEN twotheta_offset=-32.2 ELSE twotheta_offset=0.0  
    tmparr=FINDGEN(nd)/10.
	   PP(38)= (n_elements(cal_d20) eq nd AND eff_flag EQ 1) 
	   IF ang_flag NE 0 AND n_elements(ang_d20) EQ nd AND n_elements(cal_d20) EQ nd THEN BEGIN 
	       PP(38)= PP(38)+2 
			     twotheta_offset = ang_d20(0)
        tmparr=ang_d20-twotheta_offset
        PP(38)= PP(38)+2*(n_elements(ang_d20) eq nd) 
        IF wav_flag NE 0 THEN IF Wavelength NE 0 THEN PP(36)=Wavelength
    ENDIF
    IF (TwoTheta_OffSet+PP(13) GE 10 AND nd EQ 1600) THEN TwoTheta_Offset=TwoTheta_Offset-66.666667
    PV(13,*)=TwoTheta_OffSet+PV(13,*)
    PP(13)  =TwoTheta_OffSet+PP(13)
    PP(37)  =TwoTheta_Offset
    XX      =PV(13,0)+tmparr
				tmp     =WHERE([SequenceType,long(SequenceType)/10,long(SequenceType) mod 10] eq 3,count)
	   IF count GE 1 THEN BEGIN
             XX=fltarr(nd,scan)
             FOR i=0,nd-1 DO XX(i,*)=PV(13,*)+tmparr(i)
    ENDIF
    XT  ='2*Theta'
    IF scan gt 1 THEN BEGIN 
             YY=findgen(scan) 
             IF StroboType le 0 THEN BEGIN
                IF (SequenceType) mod 10 GE  2 AND long(SequenceType) mod 10 LE 8 THEN YY(*) = PV(10+long(SequenceType) mod 10,*)
             ENDIF
    ENDIF ELSE YY = round(numor)
	   IF StroboType le 0 THEN YT='Steps' ELSE YT='Slices'
    IF scan le 1 THEN BEGIN
        YT = 'Counts' 
        IF normalize NE 0 THEN YT=YT+'*'+STRCOMPRESS(STRING(ROUND(normalize/PP(30))),/remove_all)+')'
    ENDIF ELSE BEGIN
        IF StroboType le 0 THEN YT=ScanText
	       IF MAX(YY)-MIN(YY) eq 0.0 THEN BEGIN
	         YY=indgen(scan)
	         IF StroboType le 0 THEN YT='Steps' ELSE YT='Slices'
        ENDIF
    ENDELSE
    IF  SequenceType gt 10 THEN BEGIN
             YT='Steps'
             YY=indgen(scan)
    ENDIF
	   IF scan le 1 THEN BEGIN
      ZT = 'Counts' 
      IF normalize NE 0 THEN ZT=ZT+'('+STRCOMPRESS(STRING(normalize),/remove_all)+')'
    ENDIF ELSE ZT  ='Numor' & ZZ=PV
    DATE=DATI

  w=wout

  zerocounters=WHERE(TOTAL(REFORM(wout,N_ELEMENTS(wout(*,0)),N_ELEMENTS(wout(0,*))),2) LE 0)
  tmp=N_ELEMENTS(ZeroCounters)
		NbOfZeroCounters=tmp
;  print,''
;  IF NbOfZeroCounters GE 1 THEN PRINT,' Zero ',STRMID(ZeroCounters(0:13<N_ELEMENTS(ZeroCounters)-1),8,4)
  tmp=0*ZeroCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN FOR i=0,NbOfZeroCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ ZeroCounters(i) THEN tmp(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN BEGIN
    ind=where(tmp,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(ZeroCounters(ind),8,4)
  ENDIF
  tmp=TOTAL(REFORM(w,N_ELEMENTS(w(*,0)),N_ELEMENTS(w(0,*))),2)
  ind=findgen(N_ELEMENTS(tmp)-4)+2

  smoothed=tmp
  smoothed(ind)=2./3.*(tmp(ind-1)+tmp(ind-1))-(tmp(ind-2)+tmp(ind-2))/6.>0

  tmp0=TOTAL(REFORM(EE,N_ELEMENTS(EE(*,0)),N_ELEMENTS(EE(0,*))),2)/SQRT(N_ELEMENTS(EE(0,*)))
  tmp1=tmp-tmp0
  tmp2=tmp+tmp0

  MCounters=2+WHERE(tmp2(ind) LT (tmp1(ind-2)+tmp1(ind+2))/2./1.06 AND tmp1(ind-1)/1.02 GT (3.*tmp2(ind-2)+tmp2(ind+2))/4. AND tmp1(ind+1)/1.02 GT (tmp2(ind-2)+3.*tmp2(ind+2))/4.,NbOfMCounters)
  IF NbOfMCounters GE 2 THEN MCounters=MCounters(SORT((tmp(MCounters+2)+tmp(MCounters+1)+tmp(MCounters)+tmp(MCounters-1)+tmp(MCounters-2))/((tmp(MCounters+1)+tmp(MCounters-1))/2.-tmp(MCounters))))
;  IF NbOfMCounters GE 1 THEN PRINT,' "M"  ', STRMID(MCounters(0:13<N_ELEMENTS(MCounters)-1),8,4)
  tmp0=0*MCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN FOR i=0,NbOfMCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ MCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(MCounters(ind0),8,4)
  ENDIF

  WCounters=2+WHERE(tmp1(ind)/1.06 GT (tmp2(ind-2)+tmp2(ind+2))/2. AND tmp2(ind-1) LT (3.*tmp1(ind-2)+tmp1(ind+2))/4./1.02 AND tmp2(ind+1) LT (tmp1(ind-2)+3.*tmp1(ind+2))/4./1.02,NbOfWCounters)
  IF NbOfWCounters GE 2 THEN WCounters=WCounters(SORT((tmp(WCounters+2)+tmp(WCounters+1)+tmp(WCounters)+tmp(WCounters-1)+tmp(WCounters-2))/(tmp(WCounters)-(tmp(WCounters+1)+tmp(WCounters-1))/2.)))
;  IF NbOfWCounters GE 1 THEN PRINT,' "W"  ', STRMID(WCounters(0:13<N_ELEMENTS(WCounters)-1),8,4)
  tmp0=0*WCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN FOR i=0,NbOfWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ WCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
 ;   IF count GE 1 THEN PRINT,' excl.', STRMID(WCounters(ind0),8,4)
  ENDIF

  ind=findgen(N_ELEMENTS(tmp)-4)+2

  LowCounters =2+WHERE(tmp(ind) LT (smoothed(ind)-4.*SQRT(smoothed(ind)>0))-ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.-ABS(tmp(ind-1)-tmp(ind+1))/2. AND tmp(ind) GT 0,NbOfLowCounters)
  IF NbOfLowCounters GE 2 THEN LowCounters=LowCounters(SORT(smoothed(LowCounters)/(smoothed(LowCounters)-tmp(LowCounters))))
;  IF NbOfLowCounters GE 1 THEN PRINT,' Low  ', STRMID(LowCounters(0:13<N_ELEMENTS(LowCounters)-1),8,4)
  tmp0=0*LoWCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN FOR i=0,NbOfLoWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ LoWCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(LoWCounters(ind0),8,4)
  ENDIF

  HighCounters =2+WHERE(tmp(ind) GT (smoothed(ind)+4.*SQRT(smoothed(ind)>0))+ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.+ABS(tmp(ind-1)-tmp(ind+1))/2.,NbOfHighCounters)
  IF NbOfHighCounters GE 2 THEN HighCounters=HighCounters(SORT(smoothed(HighCounters)/tmp((HighCounters)-smoothed(HighCounters))))
;  IF NbOfHighCounters GE 1 THEN PRINT,' High ', STRMID(HighCounters(0:13<N_ELEMENTS(HighCounters)-1),8,4)
  tmp0=0*HighCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN FOR i=0,NbOfHighCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ HighCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(HighCounters(ind0),8,4)
  ENDIF

    good_cells           =indgen(nd)
    IF bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1 THEN BEGIN
      PP(38)= PP(38)+4 
      good_cells(bad_d20)=-1
      good_cells           =good_cells(WHERE(good_cells GE 0))
    ENDIF
    IF (bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1) THEN BEGIN
        ZZ=[bad_d20]
    ENDIF ELSE ZZ=[0]
    IF N_ELEMENTS(bad_d20) GE 1 THEN ZZ=[bad_d20] ELSE ZZ=[0]
    IF interpol_flag EQ 1 THEN BEGIN
      IF (bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1) THEN BEGIN
        ;PRINT,'Bad cells will be excluded AND interpolated, numbers of bad cells in Z'
						  IF (N_ELEMENTS(ang_d20) NE nd OR ang_flag EQ 0 OR N_ELEMENTS(cal_d20) NE nd) THEN BEGIN ;noang
          PP(38)= PP(38)+8 
          IF N_ELEMENTS(WOUT(0,*)) GE N_ELEMENTS(XX(0,*)) THEN BEGIN  
            FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO BEGIN
								      WOUT(bad_d20,i)=interpol(WOUT(good_cells,i),XX(good_cells),XX(bad_d20))
								      EE  (bad_d20,i)=interpol(EE  (good_cells,i),XX(good_cells),XX(bad_d20))
						    		ENDFOR
          ENDIF ELSE BEGIN
						      WOUT(bad_d20,*)=interpol(WOUT(good_cells,*),XX(good_cells),XX(bad_d20))
						      EE  (bad_d20,*)=interpol(EE  (good_cells,*),XX(good_cells),XX(bad_d20))
						    ENDELSE
								ENDIF 
      ENDIF 
	     IF N_ELEMENTS(ang_d20) EQ nd AND N_ELEMENTS(cal_d20) EQ nd AND ang_flag EQ 1 THEN BEGIN
          PP(38)= PP(38)+8 
          IF N_ELEMENTS(WOUT(0,*)) GE N_ELEMENTS(XX(0,*)) THEN BEGIN
										  XXold=XX(good_cells)
												XX=XX(0)+findgen(nd)/10.
            FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO BEGIN
						    		  WOUT(*,i)=interpol(WOUT(good_cells,i),XXold,XX)
						    		  EE  (*,i)=interpol(EE  (good_cells,i),XXold,XX)
						    		ENDFOR
          ENDIF ELSE BEGIN
										  XXold=XX(good_cells)
												FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO XX(*,i)=XX(0,i)+findgen(nd)/10.
						      WOUT=interpol(WOUT,XXold,XX)
						      EE  =interpol(EE  ,XXold,XX)
					    	ENDELSE

								ENDIF;ang
				ENDIF ELSE BEGIN ; NO interpolation
				  IF bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1 THEN BEGIN
        ;PRINT,'Bad cells will be excluded and NOT interpolated, numbers of BAD cells in Z!'
        ;PRINT,'Attention, some macros may fail on irregular data (missing cells)!'
						  WOUT=WOUT(good_cells,*)
						  XX  =XX  (good_cells,*)
						  EE  =EE  (good_cells,*)
				  ENDIF
				ENDELSE
			 IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
						FOR i=0,scan-1 DO BEGIN
						  WOUT(*,i)=      WOUT(*,i)/ NN(i)*normalize
						  EE  (*,i)=      EE  (*,i) /NN(i)*normalize								
						ENDFOR
      par1(54)=par1(54)/par1(50)*normalize ; 2nd monitor
      normalization_factor=NN
      normalization_factor=NN/normalize
      normalization_factor=1./normalization_factor
						NN=NN*0+normalize
						PP(39)=normalize
      normalization_factor=NN/normalize
				ENDIF
    IF N_ELEMENTS(pv(0,*)) GT 1 THEN BEGIN
      ;help,NN
	  IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
        NN=[[REFORM(NN,1,1,N_ELEMENTS(NN))],[REFORM(PV(5,*)*normalization_factor,1,1,N_ELEMENTS(PV(5,*)))],[REFORM(PV(5,*)*0.+par1(54)*normalization_factor,1,1,N_ELEMENTS(PV(5,*)))]]
      ENDIF ELSE BEGIN
        NN=[[REFORM(NN,1,1,N_ELEMENTS(NN))],[REFORM(PV(5,*),1,1,N_ELEMENTS(PV(5,*)))],[REFORM(PV(5,*)*0.+par1(54),1,1,N_ELEMENTS(PV(5,*)))]]
      ENDELSE
    ENDIF ELSE BEGIN
	  IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
        NN=[[NN],[PV(5,*)*normalization_factor],[par1(54)*normalization_factor]]
        ; Mod. 4/2/98 Hansen: 2nd monitor
      ENDIF ELSE BEGIN
        NN=[[NN],[PV(5,*)],[par1(54)]] ; Mod. 4/2/98 Hansen: 2nd monitor
      ENDELSE
    ENDELSE
    IF float_flag EQ 0 THEN WOUT=LONG(WOUT)
	;HELP,PTXT,PP,PV
	;PRINT,'CouCou'
  RETURN
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO rdid_d7, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param, $
		     par1,par2,par3,par4,par5,WT ,XT ,YT ,ZT ,OT,DATE,PP,PTXT,$
		     XX ,YY ,ZZ ,NN ,PV ,EE

;LAMP data-read interface for D7 data (ILL format) called from rdid.pro
;**********************************************************************
;
; Doesn't read D7 data in cycles 962-965 (#7002 - #9583) which was 
; badly formatted.  This data may be read with the macro "read_d7_96.pro"
;
;
;Parameters to return
;********************
;WOUT             (modified data)
;WT,XT,YT,ZT,OT   (titles)
;PP,PTXT          (parameter floatting table and textarea)
;XX,YY,ZZ         (coordinates)
;NN               (monitors)
;PV               (supplement parameter table of any dimension)
;EE               (errors from WOUT)
;
;							JRS 9/8/01
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	iprint=0

	datasource=0	; 0 => take data from appropriate counters
			; 1 => take data from hytec counters always
			; 2 => take data from tof counters always

;Useful input parameters from rdid
;*********************************

	IF (iprint GT 0) THEN BEGIN
		HELP, INST 	& PRINT, INST
		HELP, numor 	& PRINT, numor
		HELP, nvers 	& PRINT, nvers
		HELP, text 	& PRINT, text
		HELP, exper 	& PRINT, exper
		HELP, scan 	& PRINT, scan
		HELP, cnt 	& PRINT, cnt
		HELP, WOUT
		HELP, vparm 	& PRINT, vparm
		HELP, param 	& PRINT, param   
		HELP, par1 	& PRINT, par1
		HELP, par2	& IF (N_ELEMENTS(par2) GT 0) THEN PRINT, par2
	ENDIF

	IF (iprint GT 0) THEN PRINT,'rdid_d7: starting'
	PRINT,'Reading run',numor

	IF (nvers LT 1) THEN BEGIN
;
;-------------------------------------------------------------------------
; Old Data Format

	IF (iprint GT 0) THEN PRINT,'Old data format'

	inst  = STRMID(text,0 ,4)
	numexp= STRMID(text,4 ,10)
	date  = STRMID(text,14,18)
	main_title=numexp
	sub_title=main_title
	start_time=date

;      -------------------------------
;      MONITOR VALUES in n
;      -------------------------------      

	n_buf=FLTARR(4,7)		; first line is zeros except for n(0,0)
	n_buf(0,1)=par1(14)		; Time      Z up-up    
	n_buf(0,2)=par1(114)	 	; Time      Z up-down
	n_buf(0,3)=param(0)  	 	; Time      X up-up    
	n_buf(0,4)=param(12)     	; Time      X up-down
	n_buf(0,5)=param(24)		; Time      Y up-up 
	n_buf(0,6)=param(36)		; Time      Y up-down
	n_buf(1,1)=par1(3)    		; Monitor 1 Z up-up
	n_buf(1,2)=par1(103) 		; Monitor 1 Z up-down 
	n_buf(1,3)=par1(117) 		; Monitor 1 X up-up
	n_buf(1,4)=param(1)		; Monitor 1 X up-down
	n_buf(1,5)=param(13)		; Monitor 1 Y up-up 
	n_buf(1,6)=param(25)		; Monitor 1 Y up-down
	n_buf(2,1)=par1(12)    		; Monitor 2 Z up-up
	n_buf(2,2)=par1(112)	 	; Monitor 2 Z up-down 
	n_buf(2,3)=par1(126) 		; Monitor 2 X up-up
	n_buf(2,4)=param(10)		; Monitor 2 X up-down
	n_buf(2,5)=param(22)		; Monitor 2 Y up-up 
	n_buf(2,6)=param(34)		; Monitor 2 Y up-down
	n_buf(3,1)=par1(13)		; Handshake Z up-up
	n_buf(3,2)=par1(113)		; Handshake Z up-down
	n_buf(3,3)=par1(127)		; Handshake X up-up
	n_buf(3,4)=param(11)		; Handshake X up-down
	n_buf(3,5)=param(23)		; Handshake Y up-up
	n_buf(3,6)=param(35)		; Handshake Y up-down
	n_buf(*,0)=0.	; & n_buf(0,0)=n_buf(0,1)/100.	; Z up-up time in secs
	IF (n_buf(0,2) EQ 0.) THEN BEGIN
		ratioZ=0.
		ratioX=0.
		ratioY=0.
	ENDIF ELSE IF (n_buf(0,3) EQ 0.) THEN BEGIN
		IF (n_buf(2,2) EQ 0.) THEN ratioZ=999. ELSE $
			ratioZ=(n_buf(2,1)/n_buf(1,1))/(n_buf(2,2)/n_buf(1,2))
		ratioX=0.
		ratioY=0.
	ENDIF ELSE BEGIN
		IF (n_buf(2,2) EQ 0.) THEN ratioZ=999. ELSE $
			ratioZ=(n_buf(2,1)/n_buf(1,1))/(n_buf(2,2)/n_buf(1,2))
		IF (n_buf(2,4) EQ 0.) THEN ratioX=999. ELSE $
			ratioX=(n_buf(2,3)/n_buf(1,3))/(n_buf(2,4)/n_buf(1,4))
		IF (n_buf(2,6) EQ 0.) THEN ratioY=999. ELSE $
			ratioY=(n_buf(2,5)/n_buf(1,5))/(n_buf(2,6)/n_buf(1,6))
	ENDELSE
	
	nspectra=64
	IF (scan EQ 1) THEN BEGIN	; No TOF
		TOF=0
		nchannels=1
		IF (n_buf(0,2) EQ 0.) THEN BEGIN		; no PA
			nphases=1
		ENDIF ELSE IF (n_buf(0,3) EQ 0.) THEN BEGIN 	; only Z-PA
			nphases=2
		ENDIF ELSE BEGIN				; full XYZ-PA
			nphases=6
		ENDELSE

		x_buf=par1(23:86)	; x-axis is scattering angle
		y_buf=INDGEN(nphases)
		z_buf=x_buf
		w_buf=FLTARR(nspectra,nphases)
		FOR iphase=0,nphases-1 DO $
			w_buf(*,iphase)=WOUT(80*iphase:80*iphase+63)
		chel=0.
		nb_chn=1
		nb_spc=nspectra
	ENDIF ELSE BEGIN
		TOF=1
		nchannels=cnt
		nphases=scan/nspectra
		x_buf=INDGEN(nchannels)+1 ; x-axis is channel number
		y_buf=FLTARR(scan)	  ; y-axis is scattering angle
		FOR iphase=0,nphases-1 DO y_buf(iphase*64:iphase*64+63)=par1(23:86)
		z_buf=y_buf
		w_buf=FLTARR(nchannels,scan)
		FOR ispec=0,scan-1 DO BEGIN
			w_buf(*,ispec)=WOUT(*,ispec)
		ENDFOR
		w_tmp=FLTARR(nchannels)
		FOR i=1,scan,2 DO w_tmp=w_tmp+w_buf(*,i)
		Imax=MAX(w_tmp,ichel)
		chel=FLOAT(ichel)
	ENDELSE
	
	lambda=par1(15)
	IF (lambda GT 4.5) AND (lambda LE 5.0) THEN lambda=4.838 $
	ELSE IF (lambda LT 3.5) THEN lambda=3.02
	IF (lambda GT 5.0) THEN lambda=5.98

;      -------------------------------
;      PARAMETER ASSIGNMENT IN Pn
;      -------------------------------      
	npar=34
	p_buf=FLTARR(npar)
	par_txt_buf=STRARR(npar)

	p_buf(0)=numor		& par_txt_buf(0) =' 0 Numor                   ='
	p_buf(1)=nspectra	& par_txt_buf(1) =' 1 Number of spectra       ='
	p_buf(2)=nphases	& par_txt_buf(2) =' 2 Number of phases        ='
	p_buf(3)=1.		& par_txt_buf(3) =' 3 Number of runs          ='
	p_buf(4)=lambda		& par_txt_buf(4) =' 4 Wavelength (A)          ='
	p_buf(5)=0.		& par_txt_buf(5) =' 5 Chopper Speed (rpm)     ='
	p_buf(6)=nchannels	& par_txt_buf(6) =' 6 Number of Time Channels ='
	p_buf(7)=par1(17)	& par_txt_buf(7) =' 7 Channel Width (mcs)     ='
	p_buf(8)=TOF		& par_txt_buf(8) =' 8 TOF mode (0/1)          ='
	p_buf(9)=chel		& par_txt_buf(9) =' 9 Elastic Peak Channel    ='
	p_buf(10)=0.		& par_txt_buf(10)='10 Set-pt Temp Start       ='
	p_buf(11)=0.		& par_txt_buf(11)='11 Set-pt Temp End         ='
	p_buf(12)=0.		& par_txt_buf(12)='12 Regul Temp Start        ='
	p_buf(13)=0.		& par_txt_buf(13)='13 Regul Temp End          ='
	p_buf(14)=0.		& par_txt_buf(14)='14 Sample Temp Start       ='
	p_buf(15)=par1(16)	& par_txt_buf(15)='15 Sample Temp End         ='
	p_buf(16)=0.		& par_txt_buf(16)='16 Bank1 Position          ='
	p_buf(17)=0.		& par_txt_buf(17)='17 Bank2 Position          ='
	p_buf(18)=0.		& par_txt_buf(18)='18 Bank3 Position          ='
	p_buf(19)=0.		& par_txt_buf(19)='19 Bank4 Position          ='
	p_buf(20)=0.		& par_txt_buf(20)='20 Lower Sample Rotation   ='
	p_buf(21)=par1(22)	& par_txt_buf(21)='21 Upper Sample Rotation   ='
	p_buf(22)=0.		& par_txt_buf(22)='22 Z Flipper Current       ='
	p_buf(23)=0.		& par_txt_buf(23)='23 Z Correction Current    ='
	p_buf(24)=0.		& par_txt_buf(24)='24 X Flipper Current       ='
	p_buf(25)=0.		& par_txt_buf(25)='25 X Correction Current    ='
	p_buf(26)=0.		& par_txt_buf(26)='26 Y Flipper Current       ='
	p_buf(27)=0.		& par_txt_buf(27)='27 Y Correction Current    ='
	p_buf(28)=ratioZ	& par_txt_buf(28)='28 Z Flipping Ratio        ='
	p_buf(29)=ratioX	& par_txt_buf(29)='29 X Flipping Ratio        ='
	p_buf(30)=ratioY	& par_txt_buf(30)='30 Y Flipping Ratio        ='
	p_buf(31)=0.		& par_txt_buf(31)='31 Run Time (seconds)      ='
	p_buf(32)=0.		& par_txt_buf(32)='32 Start time (hours)      ='
	p_buf(33)=0.		& par_txt_buf(33)='33 End Time (hours)        ='

;------------------------------------------------------------------------
; New data format

	ENDIF ELSE BEGIN
	
	IF (iprint GT 0) THEN PRINT,'New data format'
	
	inst         = STRMID(text,0,4)
	save_time    = STRMID(text,14,18)
	main_title   = STRTRIM(exper(0),2)
	sub_title    = STRTRIM(exper(1),2)
	IF (numor GE 9609 AND numor LE 10318) OR $
	   (numor GE 10327 AND numor LE 11062) THEN BEGIN	
		user         = STRMID(exper(3),0,8)
		local_contact= STRMID(exper(3),8,8)
		start_time   = ''
		stop_time    = ''
		scan_type    = ''
		pol_mode     = ''
		Time_mode    = ''	
	ENDIF ELSE BEGIN
		user         = STRMID(exper(2),0,8)
		local_contact= STRMID(exper(2),8,8)
		start_time   = STRMID(exper(3),0,18)
		stop_time    = STRMID(exper(3),20,18)
		scan_type    = STRMID(exper(3),38,9)
		pol_mode     = STRMID(exper(3),47,5)
		Time_mode    = STRMID(exper(3),52,6)
	ENDELSE

	IF (iprint GT 0) THEN BEGIN
		PRINT,'inst         =',inst
		PRINT,'main_title   =',main_title
		PRINT,'sub_title    =',sub_title
		PRINT,'user         =',user
		PRINT,'local_contact=',local_contact
		PRINT,'start_time   =',start_time
		PRINT,'stop_time    =',stop_time
		PRINT,'save_time    =',save_time
		PRINT,'scan_type    =',scan_type
		PRINT,'pol_mode     =',pol_mode
		PRINT,'Time_mode    =',Time_mode
	ENDIF

	nspectra=64
	IF (scan EQ 1) THEN TOFformat=0 ELSE TOFformat=1

	IF (NOT TOFformat AND (datasource EQ 0 OR datasource EQ 2)) THEN BEGIN	; no TOF
		IF (iprint GT 0) THEN PRINT,'non-TOF data'
		TOF=0
		nsp_tof=cnt
		nph_tof=cnt/nspectra
		nchannels=1
		c_tof=WOUT
	ENDIF ELSE IF (datasource EQ 1) THEN TOF=0 $
	ELSE BEGIN	; with TOF
		IF (iprint GT 0) THEN PRINT,'TOF data'

; mon1 and mon2 tof channels added as dets 65 and 66 from #42356 (23/11/99)

		IF (numor GE 42356) THEN nspectra=66 ELSE nspectra=64
		TOF=1
		nsp_tof=scan
		nph_tof=scan/nspectra
		nchannels=FIX(par2(2))
		c_tof=WOUT
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'nsp=',nsp_tof,' nph=',nph_tof,' nchannels=',nchannels
	IF (iprint GT 0) THEN PRINT,'Data read OK from ', nspectra, 'detectors'

;------------------------------------
;	Monitor Values in n
;------------------------------------

	n_buf=FLTARR(4,7)		; first line is zeros except for n(0,0)
	n_buf(0,1)=par1(13)		; Time      Z up-up    
	n_buf(0,2)=par1(22)	 	; Time      Z up-down
	n_buf(0,3)=par1(31)   		; Time      X up-up    
	n_buf(0,4)=par1(40)     	; Time      X up-down
	n_buf(0,5)=par1(49)		; Time      Y up-up 
	n_buf(0,6)=par1(58)		; Time      Y up-down
	n_buf(1,1)=par1(15)    		; Monitor 1 Z up-up
	n_buf(1,2)=par1(24) 		; Monitor 1 Z up-down 
	n_buf(1,3)=par1(33) 		; Monitor 1 X up-up
	n_buf(1,4)=par1(42)		; Monitor 1 X up-down
	n_buf(1,5)=par1(51)		; Monitor 1 Y up-up 
	n_buf(1,6)=par1(60)		; Monitor 1 Y up-down
	n_buf(2,1)=par1(16)    		; Monitor 2 Z up-up
	n_buf(2,2)=par1(25)	 	; Monitor 2 Z up-down 
	n_buf(2,3)=par1(34) 		; Monitor 2 X up-up
	n_buf(2,4)=par1(43)		; Monitor 2 X up-down
	n_buf(2,5)=par1(52)		; Monitor 2 Y up-up 
	n_buf(2,6)=par1(61)		; Monitor 2 Y up-down
	n_buf(3,1)=par1(14)		; Handshake Z up-up
	n_buf(3,2)=par1(23)		; Handshake Z up-down
	n_buf(3,3)=par1(32)		; Handshake X up-up
	n_buf(3,4)=par1(41)		; Handshake X up-down
	n_buf(3,5)=par1(50)		; Handshake Y up-up
	n_buf(3,6)=par1(59)		; Handshake Y up-down
	n_buf(*,0)=0.	; & n_buf(0,0)=n_buf(0,1)/100.	; Z up-up time in secs
	IF (iprint GT 0) THEN PRINT,'monitor assigned OK'

;--------------------------------
;	Calculate Flipping Ratios
;--------------------------------

	IF (n_buf(0,2) EQ 0.) THEN BEGIN
		ratioZ=0.	& dratioZ=0.
		ratioX=0.	& dratioX=0.
		ratioY=0.	& dratioY=0.
	ENDIF ELSE IF (n_buf(0,3) EQ 0.) THEN BEGIN
		IF (n_buf(2,2) EQ 0.) THEN BEGIN
			ratioZ=999. & dratioZ=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,1)	& m1_1=n_buf(1,2)
			m2_0=n_buf(2,1)	& m2_1=n_buf(2,2)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioZ=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioZ=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
		ratioX=0. & dratioX=0.
		ratioY=0. & dratioY=0.
	ENDIF ELSE BEGIN
		IF (n_buf(2,2) EQ 0.) THEN BEGIN
			ratioZ=999.	& dratioZ=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,1)	& m1_1=n_buf(1,2)
			m2_0=n_buf(2,1)	& m2_1=n_buf(2,2)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioZ=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioZ=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
		IF (n_buf(2,4) EQ 0.) THEN BEGIN
			ratioX=999.	& dratioX=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,3)	& m1_1=n_buf(1,4)
			m2_0=n_buf(2,3)	& m2_1=n_buf(2,4)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioX=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioX=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
		IF (n_buf(2,6) EQ 0.) THEN BEGIN
			ratioY=999.	& dratioY=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,5)	& m1_1=n_buf(1,6)
			m2_0=n_buf(2,5)	& m2_1=n_buf(2,6)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioY=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioY=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
	ENDELSE
	IF (iprint GT 0) THEN PRINT,'Flipping Ratios OK'

;------------------------------
;	Calculate Running Times
;------------------------------

	h1=LONG(0)	& m1=LONG(0)	& s1=LONG(0)
	h2=LONG(0)	& m2=LONG(0)	& s2=LONG(0)
	IF (start_time NE '' AND stop_time NE '') THEN BEGIN
		READS, start_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', da1, h1, m1, s1
		READS, stop_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', da2, h2, m2, s2
		time1=FLOAT(3600*h1+60*m1+s1)/3600.+24.*da1
		time2=FLOAT(3600*h2+60*m2+s2)/3600.+24.*da2
		IF (h2 GE h1) THEN run_time=FLOAT(3600*(h2-h1)+60*(m2-m1)+(s2-s1)) $
			ELSE run_time=FLOAT(3600*(24+h2-h1)+60*(m2-m1)+(s2-s1))
	ENDIF ELSE BEGIN
		time1=0.
		time2=0.
		run_time=0.
	ENDELSE

;------------------------------
	nspectra=64
	shytec=SIZE(param)
	c_hytec=param
	nsp_hytec=shytec(1)
	nph_hytec=nsp_hytec/nspectra
	nphases=nph_hytec

	IF (scan EQ 1) THEN TOFformat=0 ELSE TOFformat=1

	IF (NOT TOFformat AND (datasource EQ 0 OR datasource EQ 2)) THEN BEGIN	; no TOF
		IF (iprint GT 0) THEN PRINT,'non-TOF data'
		TOF=0
		nsp_tof=cnt
		nph_tof=cnt/nspectra
		nchannels=1
		c_tof=WOUT
	ENDIF ELSE IF (datasource EQ 1) THEN TOF=0 $
	ELSE BEGIN	; with TOF
		IF (iprint GT 0) THEN PRINT,'TOF data'
; mon1 and mon2 tof channels added as dets 65 and 66 from #42356 (23/11/99)
		IF (numor GE 42356) THEN nspectra=66 
		TOF=1
		nsp_tof=scan
		nph_tof=scan/nspectra
		nchannels=FIX(par2(2))
		c_tof=WOUT
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'nsp=',nsp_tof,' nph=',nph_tof,' nchannels=',nchannels
	IF (iprint GT 0) THEN PRINT,'nphases=',nphases, 'nspectra=',nspectra

	TOFfactor=FLTARR(6)	& TOFfactor(*)=1.
	IF (TOF EQ 0) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'TOF=0'
		IF (datasource EQ 2) THEN w_buf=reform(c_tof,nspectra,nphases) $
			ELSE w_buf=reform(c_hytec,nspectra,nphases)
		x_buf=par2(6:69)
		IF (nphases EQ 1) THEN y_buf=LONG(numor) $
				    ELSE y_buf=INDGEN(nphases)
		z_buf=x_buf
		chel=0.
		norm=1.
	ENDIF ELSE BEGIN
		IF (iprint GT 0) THEN PRINT,'TOF=1'
		w_buf=c_tof
		x_buf=INDGEN(nchannels)+1
		y_buf=FLTARR(nsp_tof)
		FOR iph=0,nph_tof-1 DO y_buf(iph*nspectra:iph*nspectra+63)=par2(6:69)
		z_buf=y_buf
		w_tmp=LONARR(nchannels)	& w_tmp(*)=0
		FOR i=1,nsp_tof,2 DO w_tmp(*)=w_tmp(*)+w_buf(*,i)
		Imax=MAX(w_tmp,ichel)
		chel=FLOAT(ichel)
		FOR iphase=0,nphases-1 DO BEGIN
			lowlim = iphase*64
			highlim = (iphase*63)+63+iphase
			sumh=TOTAL(c_hytec(lowlim:highlim))
			tott=TOTAL(FLOAT(c_tof),1)
			lowlim = iphase*66
			highlim = (iphase*65)+63+iphase
			sumt=TOTAL(tott(lowlim:highlim))
			IF (sumh EQ 0) THEN sumh=sumt
			TOFfactor(iphase)=sumt/sumh
		ENDFOR
		IF (iprint GT 0) THEN PRINT,'sumh=',sumh,' sumt=',sumt
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'scattering angles and chel OK'

;-------------------------
;	Parameters
;-------------------------

	lambda=par2(0)
	IF (lambda GT 3.5) AND (lambda LE 5.0) THEN lambda=4.838 $
	ELSE IF (lambda LT 3.5) THEN lambda=3.02
	IF (lambda GT 5.0) THEN lambda=5.98
	IF (numor GE 8434 AND numor LE 8573) THEN lambda=3.02
	IF (iprint GT 0) THEN PRINT,'lambda=',lambda

	p_buf=FLTARR(50)
	par_txt_buf=STRARR(50)
	p_buf(0)=numor		& par_txt_buf(0) =' 0 Numor                   ='
	p_buf(1)=nspectra	& par_txt_buf(1) =' 1 Number of spectra       ='
	p_buf(2)=nph_hytec	& par_txt_buf(2) =' 2 Number of phases        ='
	p_buf(3)=1.		& par_txt_buf(3) =' 3 Number of runs          ='
	p_buf(4)=lambda		& par_txt_buf(4) =' 4 Wavelength (A)          ='
	p_buf(5)=par2(1)  	& par_txt_buf(5) =' 5 Chopper Speed (rpm)     ='
	p_buf(6)=par2(2)  	& par_txt_buf(6) =' 6 Number of Time Channels ='
	p_buf(7)=par2(3)  	& par_txt_buf(7) =' 7 Channel Width (mcs)     ='
	p_buf(8)=TOF		& par_txt_buf(8) =' 8 TOF mode (0/1)          ='
	p_buf(9)=chel		& par_txt_buf(9) =' 9 Elastic Peak Channel    ='
	p_buf(10)=par1(0) 	& par_txt_buf(10)='10 Set-pt Temp Start       ='
	p_buf(11)=par1(3) 	& par_txt_buf(11)='11 Set-pt Temp End         ='
	p_buf(12)=par1(1) 	& par_txt_buf(12)='12 Regul Temp Start        ='
	p_buf(13)=par1(4) 	& par_txt_buf(13)='13 Regul Temp End          ='
	p_buf(14)=par1(2) 	& par_txt_buf(14)='14 Sample Temp Start       ='
	p_buf(15)=par1(5) 	& par_txt_buf(15)='15 Sample Temp End         ='
	p_buf(16)=par2(76)	& par_txt_buf(16)='16 Bank1 Position          ='
	p_buf(17)=par2(77)	& par_txt_buf(17)='17 Bank2 Position          ='
	p_buf(18)=par2(78)	& par_txt_buf(18)='18 Bank3 Position          ='
	p_buf(19)=par2(79)	& par_txt_buf(19)='19 Bank4 Position          ='
	p_buf(20)=par2(80)	& par_txt_buf(20)='20 Upper Sample Rotation   ='
	p_buf(21)=par2(81)	& par_txt_buf(21)='21 Lower Sample Rotation   ='
	p_buf(22)=par1(17)	& par_txt_buf(22)='22 Z Flipper Current       ='
	p_buf(23)=par1(18)	& par_txt_buf(23)='23 Z Correction Current    ='
	p_buf(24)=par1(35)	& par_txt_buf(24)='24 X Flipper Current       ='
	p_buf(25)=par1(36)	& par_txt_buf(25)='25 X Correction Current    ='
	p_buf(26)=par1(53)	& par_txt_buf(26)='26 Y Flipper Current       ='
	p_buf(27)=par1(54)	& par_txt_buf(27)='27 Y Correction Current    ='
	p_buf(28)=ratioZ	& par_txt_buf(28)='28 Z Flipping ratio        ='
	p_buf(29)=ratioX	& par_txt_buf(29)='29 X Flipping ratio        ='
	p_buf(30)=ratioY	& par_txt_buf(30)='30 Y Flipping ratio        ='
	p_buf(31)=run_time	& par_txt_buf(31)='31 Run Time (seconds)      ='
	p_buf(32)=time1		& par_txt_buf(32)='32 Start time (hours)      ='
	p_buf(33)=time2		& par_txt_buf(33)='33 End Time (hours)        ='
	p_buf(34)=par2(70)	& par_txt_buf(34)='34 Mono1 (psiA)            ='
	p_buf(35)=par2(71)	& par_txt_buf(35)='35 Mono2 (psiB)            ='
	p_buf(36)=par2(72)	& par_txt_buf(36)='36 Mono3 (psiC)            ='
	p_buf(37)=par2(73)	& par_txt_buf(37)='37 Mono4 (thetaA)          ='
	p_buf(38)=par2(74)	& par_txt_buf(38)='38 Mono5 (thetaB)          ='
	p_buf(39)=par2(75)	& par_txt_buf(39)='39 Mono6 (thetaC)          ='
	p_buf(40)=TOFfactor(0)	& par_txt_buf(40)='40 Z  TOFfactor            ='
	p_buf(41)=TOFfactor(1)	& par_txt_buf(41)='41 Z1 TOFfactor            ='
	p_buf(42)=TOFfactor(2)	& par_txt_buf(42)='42 X  TOFfactor            ='
	p_buf(43)=TOFfactor(3)	& par_txt_buf(43)='43 X1 TOFfactor            ='
	p_buf(44)=TOFfactor(4)	& par_txt_buf(44)='44 Y  TOFfactor            ='
	p_buf(45)=TOFfactor(5)	& par_txt_buf(45)='45 Y1 TOFfactor            ='
	p_buf(46)=dratioZ	& par_txt_buf(46)='46 Z dFlipping ratio       ='
	p_buf(47)=dratioX	& par_txt_buf(47)='47 X dFlipping ratio       ='
	p_buf(48)=dratioY	& par_txt_buf(48)='48 Y dFlipping ratio       ='
	p_buf(49)=par2(82)	& par_txt_buf(49)='49 Polariser Angle         ='
	
	IF (iprint GT 0) THEN PRINT,'parameters assigned OK'

;----------------------------------------------------------------------
;
; 22/9/98 Problem with bank4 - recabled using coder 5 cables. Result is 10.21 
; degree shift in coder reading

	IF (numor GE 30721 AND numor LE 31064) THEN p_buf(19)=p_buf(19)+10.21-1.2

; 15/10/98 Looking at magnetic Bragg peak in UCu5, another 1.2 degree shift is
; required to bring bank4 peak into agreement with bank1
;
;----------------------------------------------------------------------

	ENDELSE


	WOUT=w_buf
	PP=p_buf
	PTXT=par_txt_buf
	NN=n_buf
	XX=x_buf
	YY=y_buf
	ZZ=z_buf
	WT=sub_title
	OT=inst+' '+main_title
	
	IF (TOF EQ 0) THEN BEGIN
		XT = 'Scattering Angle'
		IF (nphases EQ 1) THEN YT='Counts' $
		ELSE BEGIN
			YT='Phase'
			ZT='Counts'
		ENDELSE
	ENDIF ELSE BEGIN
		XT = 'Time Channels'
		YT = 'Scattering Angle'
		ZT = 'Counts'
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'rdid_d7: finished'

	RETURN
	END
;procedures in comment for pv-wave:
;*********************************
;RDID_D7
;RDID_D20
;RDID_D17
;GROUPY
;CATCH       now is dummy
;EXPAND_PATH now is dummy
;P_LAMBDA p_did_calib p_did_calev p_did_calod p_did_caldo (dummy for calibration)
;READS as been redefined
;## is changed by #
;structure {...} now is {,...} for DATP

FUNCTION P_LAMBDA, dummy
;******* ********
;**
@lamp.cbk

rst=lamp_macro
idx=strpos(lamp_macro,'macros')
if  idx gt 0 then begin rst= strmid(lamp_macro,0,idx-1) +lamp_dvd
			if   lamp_dvd eq "" then rst=rst+"]"
             endif else if   lamp_dvd ne "" then rst=rst+lamp_dvd

if strmid       (rst,strlen(rst)-1,1) ne lamp_dvd then rst=rst+lamp_dvd
bid=findfile    (rst+'*',count=n)
if n eq 0 then rst=''
return, rst
end


pro p_did_calib, inst, lamp_b1
;** ***********
;**
common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 , inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
common calibrotion         , cal_in4 , idx_in4 , shf_in4 , inf_in4

common calib	  , base0,lirlist,listcal,comment,curfil,bacur,nwork,swork,filen,lodfil,minst,ytext
common c_lamp_font

if (!D.flags and 65536) eq 0 then RETURN
IF xregistered('CALIB') gt 0 then widget_control,bad_id=ii,base0,map=1 $
ELSE BEGIN

CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN & endif
      MINST   = strlowcase(inst)
	PATHCAL = sys_dep('INSUB',P_LAMBDA(0),'CALIBRATION')
		    bid=findfile(pathcal+'*',count=nn) & if nn eq 0 then pathcal=''
      CD,PATHCAL,current=mee & lirlist = findfile('*'+MINST+'*') & CD,mee
      IF n_elements(CURFIL) eq 0 THEN CURFIL  =  MINST+'.cal'
      IF n_elements(SWORK)  eq 0 THEN swork   =' 0 '
      LODFIL=CURFIL

base0	=  widget_base  (title = 'CALIBRATION',resource_name='lamptouch',/column)
base0a	=  widget_base  (base0  ,/row   ,frame=4)
base0a1 =  widget_base  (base0a ,/column)
bid	=  widget_label (base0a1,value = PATHCAL,font=ft_b_bigger)
listcal	=  widget_list  (base0a1,value = lirlist,ysize = 7	,uvalue = [-88,394,1])

base0a1 =  widget_base  (base0a ,/column)
bid     =  widget_label (base0a1,value = 'for '+inst ,font=ft_b_bigger)
	   put_logo	,widget_base(base0a1,/row)
bid	=  widget_button(base0a1,value = 'Load selected file'	,uvalue = [-88,394,2])
bid	=  widget_button(base0a1,value = 'NO Calibration'	,uvalue = [-88,394,3])
bid	=  widget_button(base0a1,value = 'EXIT'			,uvalue = [-88,399  ])

base03	=  widget_base  (base0  ,/row)
bid	=  widget_label (base03 ,value = 'Current Calibration: '  ,font=ft_b_normal)
bacur	=  widget_label (base03 ,value = string(replicate(45b,30)),font=ft_b_normal)
comment	=  widget_label (base0  ,value = string(replicate(45b,50)),font=ft_b_normal)

base0b	=  widget_base  (base0  ,/column,frame=4)
bid	=  widget_label (base0b ,value = 'Make a Calibration file from raw data',font=ft_b_bigger)
base06	=  widget_base  (base0b ,/row)
bid	=  widget_label (base06 ,value='Wk_space #')
NWORK	=  widget_text  (base06 ,/editable,xsize =3 ,value= SWORK	,font=ft_propor)
bid	=  widget_label (base06 ,value='Comment:')
YTEXT	=  widget_text  (base06 ,/editable,xsize =15,value= 'no comment',font=ft_propor)
base07	=  widget_base  (base0b ,/row)
bid	=  widget_label (base07 ,value ='Filename:')
FILEN	=  widget_text  (base07 ,/editable,xsize =20,value='new'+MINST+'.cal',font=ft_propor)
bid	=  widget_button(base07 ,value = 'MAKE'			,uvalue = [-88,394,4])
bid	=  widget_label (base07 ,value ='(Put "'+MINST+'" in filename)')

widget_control  ,base0 , group_leader = lamp_b1,/realize  & put_logo
widget_control  ,bacur , set_value    = curfil
XMANAGER,'CALIB',base0 , event_handler='LAMP_EVENT_PARSER',/just_reg
ENDELSE
RETURN
END

pro p_did_calev, event,uv
;** ***********
;**
common calibration
common calibrotion
common calib

widget_control,comment,bad_id=ii,set_value=' '
CASE uv(2) of
;**SELECT
   1:	   lodfil = lirlist(event.index)
;**LOAD
   2:begin P_DID_CALOD, minst,lodfil, flg ,COMMENT=line
	   IF flg THEN begin curfil=lodfil & com= line+' is accepted ...' & endif $
		  ELSE begin curfil='None' & com= 'Bad Calibration file !!!' & endelse
	   widget_control,bacur  ,bad_id=ii, set_value=curfil
	   widget_control,comment,bad_id=ii, set_value=com
     end
;**NONE
   3:begin curfil='None' &  P_DID_CALOD, minst & widget_control,bacur,bad_id=ii,set_value=curfil & END
;**MAKE
   4:begin widget_control,nwork,bad_id=ii,get_value=swork & swork=strtrim(swork(0),2)
	   on_ioerror,mis_w & flg=0 & wn=fix(swork) & if (wn gt 0) and (wn le 20) then flg=1 & mis_w:
	   widget_control,filen,bad_id=ii,get_value=filnm & filnm=strtrim(filnm(0),2)
	   widget_control,ytext,bad_id=ii,get_value=text  & text =strtrim(text (0),2)
	   if flg eq 0 then com='Bad workspace number !!!' $
	   else begin	    P_DID_CALOD, minst,filnm,flg,wn , text
	   		    if flg eq  0 then com='Problem writting ' +filnm  +' !!!' else $
			    if flg eq -1 then com='Access denied:'    +pathcal+' !!!' $
					 else com= filnm+' write success ...'
      			    CD,PATHCAL,current=mee & lirlist = findfile('*'+MINST+'*') & CD,mee
			    widget_control,listcal , bad_id=ii,set_value=lirlist
	   endelse  &  widget_control,comment,bad_id=ii, set_value=com
     end
ELSE:
ENDCASE
RETURN
END

pro p_did_calod,minst,file, OK ,wn ,text ,LIST=list, COMMENT=line
;** ***********
;**
@lamp.cbk
common calibration
common calibrotion

IF n_elements(wn)   eq 1 then mot='MAKE'  else $
IF n_elements(file) eq 1 then mot='READ'  else $
IF keyword_set(list)     then mot='LIST'  else mot='CLEAR'

OK=-1 & in=0 & out=0 & line=''
IF mot eq 'READ' then begin on_ioerror,mis_read & OPENR,in ,pathcal+file,/get_lun
			    mis_read:  if in le 0 then mot='CLEAR'			& endif
IF mot eq 'MAKE' then begin on_ioerror,mis_writ & OPENW,out,pathcal+file,/get_lun
			    tmp=1 & ii=execute('tmp=float(W'+strtrim(string(wn),2)+')')	& endif
ok=0

IF mot eq 'LIST' then begin tmp=FINDFILE(pathcal+'*'+minst+'*' ,count=cc)
			    j  =strlen  (pathcal) & k=strpos(tmp(0),pathcal)
			    if cc gt 0 then begin   print,'Note:  CALIBRATION [,file="myfile"] [,/nocal] [,/list]'
						    print,'Actual calibration files:'
						    for i=0,cc-1  do if k lt 0 then print,tmp(i) $
						    else    print,strmid(tmp(i),j,30)
			    endif
endif else $
CASE  minst of
'd16':  IF mot eq 'READ' then begin
	   on_ioerror,misd16
	   inf_d16 =[file]
	   READF,  in,line
	   i =strpos(line,'(')   & j=strpos(line,'*')   & k=strpos(line,')')
	   sx=long(strmid(line,i+1,j-i-1)) & sy=long(strmid(line,j+1,k-j-1))
	   cal_d16 =fltarr(sx,sy)
 	   READF,in,cal_d16	&   ok=1
	   misd16: IF ok eq 0 THEN  cal_d16 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd16
	   sz=SIZE(tmp) & sx=strtrim(string(sz(1)),2) & sy=strtrim(string(sz(2)),2)
	   PRINTF, out,'Calib('+sx+'*'+sy+') ' +systime()+' '+text
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd16:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d16 =0

'd1a':  IF mot eq 'READ' then begin cal_d1a =fltarr(25)  & ang_d1a=findgen(25)
	   on_ioerror,misd1a
	   inf_d1a =[file]
	   READF,  in,line  & READF,in,ang_d1a,cal_d1a	 & ok=1
	   misd1a: IF ok eq 0 THEN  cal_d1a =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd1a
	   PRINTF, out,'Calib(25)    ' +systime()+' '+text
	   TAKE_DATP,p,w=wn
	   PRINTF, out, P.x
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd1a:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d1a =0

'd2b':  IF mot eq 'READ' then begin cal_d2b =fltarr(64)  & ang_d2b=findgen(64)
	   on_ioerror,misd2b
	   inf_d2b =[file]
	   READF,  in,line  & READF,in,format='(64F8.3)',ang_d2b
			      READF,in,format='(64F8.5)',cal_d2b	 & ok=1
	   misd2b: IF ok eq 0 THEN  cal_d2b =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd2b
	   PRINTF, out,'Calib(64)    ' +systime()+' '+text
	   TAKE_DATP,p,w=wn
	   PRINTF, out, P.x
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd2b:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d2b =0

'd20': IF mot eq 'READ' then begin cal_d20 =fltarr(1600)& ang_d20=findgen(1600)
 	   on_ioerror,misd20
     	IF file EQ ' default' THEN BEGIN
       		inf_d20=[file,'not loaded','autod20.cal']
     	ENDIF ELSE BEGIN
 	     	READF,  in,line 
       		cal_d20 =fltarr(1600,long(strmid(line,6,4))/1600)
       		READF,in,ang_d20,cal_d20	 & ok=1
		IF N_ELEMENTS(inf_d20) EQ 0 THEN inf_d20=[file,line,'manualchoice'] ELSE inf_d20(0:1)=[file,line]
       		print,'New Calibration file loaded: ', inf_d20(0)
       		print,inf_d20(1)
       		if N_ELEMENTS(inf_d20) GE 3 THEN IF inf_d20(2) EQ 'autochoice' THEN BEGIN
         		PRINT,'D20 automatic default calibration by the right file - attention to wavelength!' 
       		ENDIF ELSE BEGIN
         		PRINT,'D20 manual choice of calibration file - pay attention to wavelength!' 
         		inf_d20(2) = 'manualchoice'
       		ENDELSE
 		misd20: IF ok eq 0 THEN  cal_d20 =0
     	ENDELSE
       ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd20
	IF N_ELEMENTS(inf_d20) GE 1 THEN inf_d20=inf_d20(0:2)
 	PRINTF, out,'Calib('+strtrim(string(N_ELEMENTS(tmp)),2)+')  ' +systime()+' '+text
 	TAKE_DATP,p,w=wn
 	PRINTF, out, P.x(0:1599,0,0)
 	PRINTF, out, tmp & ok=1 & mikd20:
       ENDIF ELSE BEGIN
	cal_d20 =0
	inf_d20(0:2)=['','','']
	print,'NO Calibration',STRLEN(inf_d20(0))
       ENDELSE
	
'in13': IF mot eq 'READ' then begin cal_in13=fltarr(70)
	   on_ioerror,misin13
	   inf_in13=[file]
	   READF,  in,line  & READF,in,cal_in13		 & ok=1
	   misin13:IF ok eq 0 THEN  cal_in13=0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin13 & mikin13:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in13=0

'in6':  IF mot eq 'READ' then begin
	   on_ioerror,misin6
	   inf_in6 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in6 =fltarr(sz)  & idx_in6=intarr(sz) & shf_in6=intarr(sz)
	   READF,in,cal_in6	& READF,in,idx_in6 & READF,in,shf_in6 & ok=1
	   idx_in6=where(idx_in6 ge 0)
	   misin6: IF ok eq 0 THEN  cal_in6 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin  on_ioerror,mikin6
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf*0 & ok=1 & mikin6:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in6 =0

'in5':  IF mot eq 'READ' then begin
	   on_ioerror,misin5
	   inf_in5 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in5 =fltarr(sz)  & idx_in5=intarr(sz) & shf_in5=intarr(sz)
	   READF,in,cal_in5	& READF,in,idx_in5 & READF,in,shf_in5 & ok=1
	   idx_in5=where(idx_in5 ge 0)
	   misin5: IF ok eq 0 THEN  cal_in5 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin5
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf & ok=1 & mikin5:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in5 =0

'in4':  IF mot eq 'READ' then begin
	   on_ioerror,misin4
	   inf_in4 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in4 =fltarr(sz)  & idx_in4=intarr(sz) & shf_in4=intarr(sz)
	   READF,in,cal_in4	& READF,in,idx_in4 & READF,in,shf_in4 & ok=1
	   idx_in4=where(idx_in4 ge 0)
	   misin4: IF ok eq 0 THEN  cal_in4 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin4
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf & ok=1 & mikin4:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in4 =0
ELSE:
ENDCASE
mis_writ:
IF in  gt 0 THEN FREE_LUN,in
IF out gt 0 THEN FREE_LUN,out
RETURN
END

pro p_did_caldo,minst,WOUT,YOUT,ok
;** ***********
;**
common calibration
common calibrotion
ok=0
CASE  minst of
'in4':begin	IF n_elements(cal_in4) eq 0 THEN P_DID_CALOD, minst,minst+'.cal', flg
		IF n_elements(cal_in4) gt 1 THEN BEGIN WOUT = float(WOUT)
			sz=(size(WOUT))(2)   & sc= n_elements(cal_in4)
			if sz ne sc then begin cal_in4=0 & print,' # of Angles in calibration file is different !!!' & endif
			if sz ge sc then begin sw=sz-sc & sc=0
			endif	    else begin sc=sc-sz & sw=0 & endelse
			FOR i=sw,sz-1 DO WOUT(*,i)=SHIFT(WOUT(*,i),shf_in4(i-sw+sc)) $
								  /cal_in4(i-sw+sc)
			ok=1
			if sw gt 0 then  idx=[indgen(sw),idx_in4+sw]   else $
			if sc gt 0 then  idx=idx_in4(where((idx_in4-sc) ge 0))-sc $
				   else  idx=idx_in4
			WOUT=WOUT(*,idx) & YOUT=YOUT(idx)
		ENDIF
	end
'in5':begin	IF n_elements(cal_in5) eq 0 THEN P_DID_CALOD, minst,minst+'.cal', flg
		IF n_elements(cal_in5) gt 1 THEN BEGIN WOUT = float(WOUT)
			sz=(size(WOUT))(2)   & sc= n_elements(cal_in5)
			if sz ge sc then begin sw=sz-sc & sc=0
			endif	    else begin sc=sc-sz & sw=0 & endelse
			FOR i=sw,sz-1 DO WOUT(*,i)=SHIFT(WOUT(*,i),shf_in5(i-sw+sc)) $
								  /cal_in5(i-sw+sc)
			ok=1
			if sw gt 0 then  idx=[indgen(sw),idx_in5+sw]   else $
			if sc gt 0 then  idx=idx_in5(where((idx_in5-sc) ge 0))-sc $
				   else  idx=idx_in5
			WOUT=WOUT(*,idx) & YOUT=YOUT(idx)
		ENDIF
	end
'in6':begin	IF n_elements(cal_in6) eq 0 THEN P_DID_CALOD, minst,minst+'.cal', flg
		IF n_elements(cal_in6) gt 1 THEN BEGIN WOUT = float(WOUT)
			sz=(size(WOUT))(2)   & sc= n_elements(cal_in6)
			if sz ne sc then begin cal_in6=0 & print,' # of Angles in calibration file is different !!!' & endif
			if sz ge sc then begin sw=sz-sc & sc=0
			endif	    else begin sc=sc-sz & sw=0 & endelse
			FOR i=sw,sz-1 DO WOUT(*,i)=SHIFT(WOUT(*,i),shf_in6(i-sw+sc)) $
								  /cal_in6(i-sw+sc)
			ok=1
			if sw gt 0 then  idx=[indgen(sw),idx_in6+sw]         else $
			if sc gt 0 then  idx=idx_in6(where((idx_in6-sc) ge 0))-sc $
				   else  idx=idx_in6
			WOUT=WOUT(*,idx) & YOUT=YOUT(idx)
		ENDIF
	end
ELSE:
ENDCASE
RETURN
END


pro skipline , in,line,cnt,nvers=nvers
;** ********
;**
	ON_IOERROR,nocnt
	cnt=0L & bid=0L & READS,line+' 0 0 0',cnt,bid,nvers
	IF bid gt 0 THEN FOR i=1,bid DO READF,in,line
	nocnt:
RETURN
END

pro skipvpar ,vpb,vpara,in
;** ********
;**
IF vpb gt 0 THEN BEGIN deco=''
		 FOR I=0,vpb-1 DO BEGIN
			 READF,in,deco
			 READF,in,deco     & SKIPLINE,in,deco,vpb
			 vpara=fltarr(vpb) & READF,in,vpara
		 ENDFOR
ENDIF
RETURN
END


FUNCTION rdid , INST_GRP,PATH,FILENAME,STATUS,DATP ,COMP=comp
;******* ****
;**
common calibration
common calibrotion
common c_rdid , dzap, pzap, pzip ,pzup

;help, INST_GRP,PATH,FILENAME,STATUS,DATP ,COMP
;print,INST_GRP,PATH,FILENAME,STATUS,DATP

IF n_elements(PATHCAL )   eq 0 then begin PATHCAL =sys_dep('INSUB',P_LAMBDA(0),'CALIBRATION')
					  bid=findfile(pathcal+'*',count=nn) & if nn eq 0 then pathcal='' & endif
IF n_elements(INST_GRP)   le 1 then return,1
CATCH,stat & if stat ne 0 then begin CATCH,/cancel & print,!err_string
				     FREE_LUN,in   & RETURN, WOUT & endif

WOUT=0 & WT='' & DATE='' & OT='' & XT='' & YT='' & ZT='' & PP=0 & PTXT=''
WOU =0 & XX=0  & YY  =0  & ZZ=0  & NN=0  & PV=0  & EE=0

scan=0 & Vri=-1 & text='' & exper='' & partx='' & param=0  & parai=0 & vparm=0
pthv=PATH
INST=strlowcase(INST_GRP)
IF n_elements(FILENAME) gt 1 THEN BEGIN NIMG=fix(FILENAME(1)) & FILENAME=FILENAME(0)
			     ENDIF ELSE NIMG=0

IF (INST(0) EQ 'd16') OR   (INST(0) EQ 'db21') THEN INST(1) ='dif'
IF  INST(3) EQ '1'  THEN IF INST(1) EQ 'dif'   THEN IF INST(0) NE 'd1a' THEN  $
						    IF INST(0) NE 'd2b' THEN  $
						    IF INST(0) NE 'd10' THEN  $
						    IF strpos(pthv,INST(0)) gt 0 THEN $
		    pthv=pthv+INST(0)+'_'+strmid(FILENAME,1,1)+sys_dep('DIVIDER')
IF  INST(0) EQ 'd11tof' THEN BEGIN P=strpos(pthv,'tof')
				   if P gt 0 THEN pthv=strmid(pthv,0,P)+'/' & ENDIF
;Compressed or not!
;---------- -- ---
form=findfile(pthv+FILENAME+'.Z',count=cprs)
IF cprs GT 0  THEN BEGIN
	IF pthv NE '' THEN bid=sys_dep      ('COPY',FILENAME+'.Z',pthv) ELSE cprs=0
			   bid=sys_dep      ('UN_Z',FILENAME+'.Z')       &   pthv=''
ENDIF

ON_IOERROR,misopen
STATUS=11
in=125
GET_LUN,in & if in ge 125 then for i=125,128 do free_lun,i
OPENR,in,pthv+FILENAME

	STATUS=13
	line  =''   & deco='' & form ='' & cnt =0L & bid=0L & numor=0L & vpb=0L
	linet =[''] & nvers=0 & formb='' & cntb=0L
	ON_IOERROR,misread
	
	READF,in,line     & READF,in,deco   & READF,in,line
	SKIPLINE,in,deco,numor,nvers=nvers

;	Contact and date
;	------- --- ----	
	READF,in,deco  & cnt=80
	SKIPLINE,in,deco,cnt
	nbl  =cnt/80      & IF nbl*80 lt cnt  THEN  nbl=nbl+1
	text =strarr(nbl) & READF,in,text   & READF,in,form
	form =strmid(form,0,2)
     	insv =strlowcase(strtrim(strmid(text(0),0,4),2))
	if (inst(0) eq 'd9') or (inst(0) eq 'd10') then insv=inst(0)  ;!!!!!!! to comment in some days
	if (inst(0) eq 'd11tof') then insv=inst(0)

	IF  form ne 'VV'  THEN BEGIN
	 WHILE form ne 'AA' DO BEGIN READF,in,form & form=strmid(form,0,2)
	 ENDWHILE

;	 Experiment
;	 ----------	
	 READF,in,deco     & SKIPLINE,in,deco,cnt
	 nbl  =cnt/80      & IF nbl*80 lt cnt  THEN  nbl=nbl+1
	 exper=strarr(nbl) & READF,in,exper  & READF,in,form
	 form =strmid(form,0,2)
	 WHILE form lt 'AA' DO BEGIN READF,in,form & form =strmid(form,0,2) & ENDWHILE
	ENDIF

;	Parameters
;	----------
	WHILE (form ne 'SS') AND (form ne 'VV') DO BEGIN
		
		READF,in,deco     & SKIPLINE,in,deco,cnt
		nbl  =cnt/80      & IF nbl*80 lt cnt  THEN  nbl=nbl+1
		IF form eq 'FF'  THEN BEGIN
 				      IF n_elements(par4)  gt 0 THEN par5=par4
 				      IF n_elements(par3)  gt 0 THEN par4=par3
 				      IF n_elements(par2)  gt 0 THEN par3=par2
 				      IF n_elements(par1)  gt 0 THEN par2=par1
				      IF n_elements(param) gt 1 THEN par1=param
				      param=fltarr(cnt) & ENDIF ELSE $
		IF form eq 'II'  THEN parai=lonarr(cnt)   ELSE  $
		IF form eq 'AA'  THEN bidon=strarr(nbl)
	
		IF form eq 'AA'  THEN READF,in,bidon ELSE $
		IF form eq 'II'  THEN READF,in,parai ELSE $
		IF form eq 'FF'  THEN READF,in,param
		READF,in,form
		form=strmid(form,0,2)
	
	ENDWHILE
	
	IF form eq 'SS' THEN BEGIN
;***	** **** ** **** **** ***** ---> DIF TOF
;***	** **** ** **** **** ***** ---> DIF TOF
;***	** **** ** **** **** ***** ---> DIF TOF

;	# scans
;	-------
	
	READF,in,deco     & READS,deco+' 0 0 0 0 0 0',bid,scan,bid,bid,bid,vpb
	SKIPVPAR,vpb,vpara, in
	READF,in,form     & form=strmid(form,0,2)
	IF form eq 'JJ' THEN form='II'
	IF scan lt  1   THEN scan=1 ELSE scan=scan+1

	READF,in,deco     & SKIPLINE,in,deco,cnt
	
	forcl=1 & forcd=0 & m19=0
	
	CASE insv OF
	'd19' : begin   vp=10 & forcl=0
		IF (scan gt 1) and (cnt eq 512.*16) THEN BEGIN  forcd=1
		    bad_d=intarr(512) & m19=2*512 & cnt=cnt-m19 & ENDIF
	        end
	'd9'  : begin   vp=10 & forcl=0 & end
	'db21': begin   vp=10 & forcl=0 & end
	'd16' : begin   vp=10 & end
	'd1b' : begin   vp=3  & end
	else  : begin   vp=0  & end
	ENDCASE

	IF vpb gt 0 THEN vp=0

	cnt  =  cnt-vp
	IF cnt  ge 1 THEN BEGIN
	IF vp   gt 0 THEN BEGIN vparm=lonarr(vp ,scan) & vpara=lonarr(vp) & ENDIF
	IF vpb  gt 0 THEN	vparm=fltarr(vpb,scan)
	IF scan gt   1    THEN $
	IF form eq 'II'   THEN buf=lonarr(cnt) $
	                  ELSE buf=fltarr(cnt)

	IF form ne 'II'   THEN WOUT=fltarr(cnt,scan) $
	                  ELSE IF   forcl  eq 0 THEN $
			           WOUT=intarr(cnt,scan) $
	                  ELSE WOUT=lonarr(cnt,scan)
;	Read data
;	---- ----
	ib=0 & scanv=scan
	FOR i=0,scanv-1 DO   BEGIN
	    IF  i gt 0  THEN BEGIN
	    	READF,in,line   & READF,in,deco
		READS,deco+' 0 0 0 0 0 0',bid,bid,bid,bid,bid,vpb
		SKIPVPAR,vpb,vpara,in
		READF,in,formb	& formb=strmid(formb,0,2) & IF formb eq 'JJ' THEN formb='II'
	    	READF,in,deco 	& SKIPLINE,in,deco,cntb & cntb=cntb-m19
		IF   cntb ne cnt+1 THEN $
		IF ((cntb ne cnt) or (formb ne form)) and (vp eq 0) then begin
				cnt=cntb & form=formb & WOU=WOUT(*,0:i-1) & ib=i  & scan=(scan-i)>1
				IF form eq 'II' THEN buf =lonarr(cnt)      ELSE buf =fltarr(cnt)
				IF form eq 'II' THEN WOUT=lonarr(cnt,scan) ELSE WOUT=fltarr(cnt,scan)
				ENDIF
	    ENDIF
	    IF vpb  gt 0 THEN   vparm(0,i)=vpara
	    IF scan le 1 THEN   BEGIN
	    			IF vp eq 0 THEN READF, in,         WOUT  $
	    			ELSE      BEGIN READF, in, vpara , WOUT
	    			                vparm(0,i)=vpara & ENDELSE
	    ENDIF	 ELSE   BEGIN
	    			IF vp eq 0 THEN BEGIN
				  IF forcd eq 1 THEN READF,in,bad_d,buf,bad_d $
				                ELSE READF,in,buf
				ENDIF      ELSE BEGIN
				  IF forcd eq 1 THEN READF,in,vpara,bad_d,buf,bad_d $
				                ELSE READF,in,vpara,buf
	    			  vparm(0,i)=vpara
				ENDELSE
	    		      WOUT(0,i-ib)=buf
	    ENDELSE
	    Vri=i+1
	ENDFOR
	STATUS=0
	ENDIF
	ENDIF ELSE $
	IF form eq 'VV' THEN BEGIN
;***	** **** ** **** **** ***** --->  TAS
;***	** **** ** **** **** ***** --->  TAS
;***	** **** ** **** **** ***** --->  TAS

	NP=0
	READF,in,line & partx=[line]   &  READF,in,line
	linec='' & step='!!'
	WHILE strpos(line,'DATA_:') lt 0 DO BEGIN
	      IF strpos(line,'COMND:') eq 0 THEN BEGIN
	      			i=strpos(strlowcase(line),' np ')
	      			IF i  gt 0 THEN READS,strmid(line,i+4,5)+' 0' ,NP
	      			IF NP eq 0 THEN NP=100
	      			linec=strmid(strtrim(strcompress(line),2),7,50)
	      			ENDIF
	      IF strpos(line,'STEPS:') eq 0 THEN $
				step=strmid(strtrim(strmid(line,6,6),2),1,6)
	      partx=[partx,line]
	      READF,in,line
	ENDWHILE
	READF,in,line & line=strtrim(strcompress(line),2)+' ' & partx=[partx,line]
			l=strlen(line) & j=0
			FOR i=0,l-1 DO IF strmid(line,i,1) eq ' ' THEN BEGIN
					  linet=[linet,strmid(line,j,i-j)] & j=i+1 & ENDIF
			linet=linet(1:*)
	partx=strtrim(partx,2)

	IF NP  GT 0 THEN BEGIN
	   pos=0L & POINT_LUN,-in,pos
	   	    READF,in,line & line=strtrim(strcompress(line),2)
	   	    POINT_LUN, in,pos
	   cnt=0 & i=0 & WHILE i ge 0 DO BEGIN cnt=cnt+1 & i=strpos(line,' ',i+1)  & ENDWHILE
	
	   ON_IOERROR,eofread
	   vparm=fltarr(cnt,NP)
	   READF,in,vparm
	   
	   IF vparm(0,NP-1) eq 100 THEN BEGIN   buf=fltarr(cnt)
	   					WHILE (1) DO BEGIN READF,in,buf
	   						     vparm=[[[vparm]],[buf]]
	   						     NP=NP+1 & ENDWHILE & ENDIF
	eofread:STATUS=0
	IF n_elements(vparm) gt 1 THEN BEGIN i=NP-1 & WHILE (i gt 0) and (vparm(0,i) eq 0) do i=i-1
						vparm=vparm(*,0:i>0)               & ENDIF
	ENDIF
	ENDIF
	
misread:FREE_LUN,in
	IF Vri gt 0 then IF Vri lt scan THEN begin scan=Vri & WOUT=WOUT(*,0:scan-1) & STATUS=0
					IF vp+vpb gt 0 THEN vparm=vparm(*,0:scan-1) & endif
IF cprs gt 0 THEN bid=sys_dep ('DELET', FILENAME)

misopen:FREE_LUN,in

IF STATUS eq 11 THEN print,'File "'+pthv+FILENAME+'" Not found  !!!'
IF STATUS eq 13 THEN print,'File "'+pthv+FILENAME+'" Read error !!!'
IF STATUS eq 0  THEN BEGIN

   CASE INST(1) OF
   'dif':  BEGIN
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' Run ' + FILENAME    ;+' User '     +strmid(text,4,10)  
           XT  ='Detector X .'
           YT  ='Detector Y .'
           IF    scan gt 1 THEN ZT ='Points' ELSE  ZT ='Counts'
	   NN  = 1
	   ntype=0 & kctrl=0 & manip=0 & nbang=0 & icdes=[0] & ub=fltarr(3,3)
	   if n_elements(parai) gt 25 then begin
	   	ntype=parai(1)
	   	kctrl=parai(2)
	   	manip=parai(3)
	   	nbang=parai(4)<6
	   	icdes=parai(24:24+nbang+1)
	   	ub   =reform(param(8:16),3,3)
	   endif
	   IF   n_elements(param) ge 50      THEN  BEGIN
	   	   PP  = [param(3:6),param(17)   ,param(45:47),param(29),param(35:36),param(38),$
		          param(0:2),param(21:23),param(8 :16),manip ,kctrl]
	   	   PTXT= ['Phi    ','Chi    ','Omega  ','2*Theta',$
	   	   	  'Wave lenght',$
	   	   	  'Requested  Temperature  ',$
	   	   	  'Regulation Temperature  ',$
	   	   	  'Sample (K) Temperature  ',$
	   	   	  'Sample-Detector Distance',$
		   	  'Starting Angle  ',$
		   	  'Angle Variation ',$
		   	  'Preset (monitor)',$
			  'Hmin','Kmin','Lmin','Hmax or 0','Kmax or 0','Lmax or 0',$
			  'ub(1,1)','ub(1,2)','ub(1,3)','ub(2,1)','ub(2,2)','ub(2,3)','ub(3,1)','ub(3,2)','ub(3,3)',$
			  'Manip 1:gamma 2:omega 3:chi 4:phi','Kctrl 1:around hkl']
		   NN  = param(38)
	   	   ENDIF
    	   IF   n_elements(vparm) ge scan*2  THEN  NN =[vparm(0,0:scan-1),vparm(1,0:scan-1)]
    	   IF  (n_elements(vparm) ge scan*4) and (scan gt 1) and ((nbang ge 1) or (icdes(0) eq -1)) THEN BEGIN
    	           ZZ  =[ vparm(3,0:scan-1)]/1000.
     	           PV  =[ vparm(3:2+(nbang>1),0:scan-1)]/1000.
		   XT='X' & YT='Z' & ZT='Scan'
		   AX_g=fltarr(scan)+param(6)*!pi/180. & AX_o=fltarr(scan)+param(5)*!pi/180.
		   AX_c=fltarr(scan)+param(4)*!pi/180. & AX_p=fltarr(scan)+param(3)*!pi/180.
		   FOR i=0,nbang-1 do begin
		     case icdes(i) of
		     -1:begin if i eq 0 then ZT='Temperature'                           & end
		      1:begin if i eq 0 then ZT='Gamma' & AX_g=reform(PV(i,*))*!pi/180. & end
		      2:begin if i eq 0 then ZT='Omega' & AX_o=reform(PV(i,*))*!pi/180. & end
		      3:begin if i eq 0 then ZT='Chi'   & AX_c=reform(PV(i,*))*!pi/180. & end
		      4:begin if i eq 0 then ZT='Phi'   & AX_p=reform(PV(i,*))*!pi/180. & end
		      else:
		      endcase
		   ENDFOR
		   UB1=invert((ub),statub)
		   IF  statub eq 0 then begin
		                        SIN_g=2*sin(AX_g/2.)/param(17)
		      if insv eq 'd10' then COS_o=cos(AX_o-AX_g/2.) else COS_o=cos(AX_o)
		      if insv eq 'd10' then SIN_o=sin(AX_o-AX_g/2.) else SIN_o=sin(AX_o)
		      COS_c=cos(AX_c) & SIN_c=sin(AX_c)
		      COS_p=cos(AX_p) & SIN_p=sin(AX_p)
		      HMU  =[[(COS_o * COS_c * COS_p - SIN_o * SIN_p)* SIN_g] , $
		             [(COS_o * COS_c * SIN_p + SIN_o * COS_p)* SIN_g] , $
		             [(COS_o * SIN_c)* SIN_g]]
		      HKL  =transpose((UB1)##(HMU))
		      d=10000. & HKL=round(HKL*d) & HKL=HKL/d
		      PV   =[PV,HKL]
		   ENDIF
     	   ENDIF ELSE IF scan gt 1 then ZZ=indgen(scan)+1 else ZZ=0

     	   CASE insv of
     	   'd19':  BEGIN IF n_elements(cal_d19) eq 0 THEN BEGIN
     	   		 ENDIF
			 IF n_elements(WOUT) eq 64.*64*scan then $
			      IF scan le 1 THEN WOUT=reform(WOUT,64,64     ,/overwrite) $
			                   ELSE WOUT=reform(WOUT,64,64,scan,/overwrite) $
     	   		 ELSE WOUT=reform(WOUT,512  ,n_elements (WOUT)/512 ,/overwrite)
		   END
	   'd9':   BEGIN IF scan gt 1 THEN WOUT=reform   (WOUT,32,32,n_elements(WOUT)/32/32,/overwrite)$
	    	   	      	      ELSE WOUT=reform   (WOUT,32,32, /overwrite)
			 
			 IF sys_dep('VERSION') ge 4.0 then $
			 IF scan gt 1 THEN ii=execute('WOUT=transpose(WOUT,[1,0,2])') $
				      ELSE WOUT=transpose(WOUT)
		   END
	   'd10':  BEGIN IF scan gt 1 THEN WOUT=reform   (WOUT,32,32,n_elements(WOUT)/32/32,/overwrite)$
	    	   	      	      ELSE WOUT=reform   (WOUT,32,32, /overwrite)
				
			 IF sys_dep('VERSION') ge 4.0 then $
			 IF scan gt 1 THEN ii=execute('WOUT=transpose(WOUT,[1,0,2])') $
				      ELSE WOUT=transpose(WOUT)
		   END
	   'd15':  BEGIN IF scan gt 1 THEN WOUT=reform   (WOUT,32,32,n_elements(WOUT)/32/32,/overwrite)$
	    	   	      	      ELSE WOUT=reform   (WOUT,32,32, /overwrite)
			 
			 IF sys_dep('VERSION') ge 4.0 then $
			 IF scan gt 1 THEN ii=execute('WOUT=transpose(WOUT,[1,0,2])') $
				      ELSE WOUT=transpose(WOUT)
		   END
	   'd16':  BEGIN nel=n_elements(WOUT) & nxy=nel/scan & sy=nxy/64 & sx=nxy/sy
	   		 IF nxy ge 64.*64 then begin  & sy=sqrt(nxy) & sx=nxy/sy & endif
			 IF scan gt 1 THEN WOUT=reform   (WOUT,sx,sy,nel/sx/sy,/overwrite) $
	    	   	      	      ELSE WOUT=reform   (WOUT,sx,sy, /overwrite)
					   IF sy eq 16 then begin
					    WOUT=reverse  (WOUT(1:sx-2,1:sy-2,*),1) & sx=sx-2 & sy=sy-2
					   ENDIF
			 sw=size(WOUT) & if sw(0) eq 3 then sz=sz(sw(3)) else sz=1
			 IF n_elements(cal_d16) eq 0 THEN $
			    P_DID_CALOD, insv,insv+'.cal', flg

			 IF n_elements(cal_d16) gt 1 THEN BEGIN WOUT=float(WOUT)
				FOR i=0,sz-1 DO WOUT(0,0,i)=WOUT(*,*,i)/cal_d16
				OT=OT+' /'+inf_d16(0) & ENDIF
		   ZZ  =numor
		   
		   if n_elements(pzip) eq 0 then pzip=0.
		   D2TH=pzip

		   PTXT= ['2*Theta   ','Omega     ','Chi       ','Phi       ',$
	   	   	  'Trans_X   ','Trans_Y   ','Rot       ','Beamstop  ',$
                          'Wave lenght             ','Requested  Temperature  ',$
	   	   	  'Regulation Temperature  ','Sample (K) Temperature  ',$
	   	   	  'Sample-Detector Distance','Starting Angle          ',$
                          'Angle Variation         ','Angle Range             ',$
			  'PRESET                  ','Coupling factor         ',$
                          'Motor scanned           ','Nb points requested     ','Nb points saved         ',$ 
			  'Count:Monitor or Time   ','Type of T-regulation    ','Type of Multi-meter     ',$
                          'Delta2th                ']
		   PP  =[param(6),param(5),param(4),param(3),0,0,0,0,param(17),param(45:47),$
                         param(29),param(35:38),param(42),parai(3),parai(5:7),parai(12:13),pzip]
                        
                   scan_t=parai(3)
                   nbang =parai(4)
                   FOR i=1,nbang DO IF parai(23+i) eq 0 THEN parai(23+i)=24

;                  ***Lecture pour les differents motors scans*****
	 	   PP(parai(24)-1)=vparm(3)/1000.
                   IF nbang eq 1 THEN BEGIN ZZ=PP(2) & ENDIF
		   IF nbang eq 2 THEN BEGIN PP(parai(25)-1)=vparm(4)/1000. & ENDIF
                   IF nbang eq 3 THEN BEGIN PP(parai(25)-1)=vparm(4)/1000. & PP(parai(26)-1)=vparm(5)/1000. & ENDIF
                   IF parai(3) gt 0 THEN BEGIN ZZ=round(vparm(3)*100/1000.) 
		       IF ZZ   eq 0 THEN ZZ=1
                       IF parai(3) eq 1  THEN  ZT='gamma*100'   & IF parai(3) eq 2 THEN ZT='omega*100'
                       IF parai(3) eq 3  THEN  ZT='chi*100'     & IF parai(3) eq 4 THEN ZT='phi*100'
                       IF parai(3) eq 5  THEN  ZT='Trans_X*100' & IF parai(3) eq 6 THEN ZT='Trans_Y*100'
                       IF parai(3) eq 7  THEN  ZT='Rot*100'
		   ENDIF
                   IF PP(12) le 0 THEN PP(12)=100.
		   if sy gt 16 then reso=.3 else reso=.254
		   if sy gt 64 then reso=.2
		   step = 180./!pi * reso/PP(12)
		   ste  = fix(step*1000) & ste = ste/1000.
		   set_tolerance,tt,/get & if tt eq 0 then set_tolerance,ste
		   offs = sx/2 -.5
		   XX   = findgen(sx)*step + PP(0) - offs*step
		   YY   =  indgen(sy)
                   NN   = vparm(1)

;                  ****Write the file in a regular grid determined by the delta2th parameter***
                   IF D2TH gt 0.001 THEN BEGIN
                     S=ROUND((XX(n_elements(XX)-1)-XX(0))/D2TH)+2
                     WINT=fltarr(S,sy) & FRAC=0 & XR=fltarr(S) & NN=lonarr(S)
;                    ***XR contains the 2th's rounded to the nearest step size**
		     tent=round(XX(0)/D2TH)*D2TH
                     if XX(0) gt tent then XR(0)=tent else XR(0)=tent-D2TH

                     for i=1,S-1   do XR(i)=XR(i-1)+D2TH  
;                    ****How to write the numor o the regular grid XR****
                     FOR i=0,sx-1 do begin 
                      FOR J=0,S-2 do begin
                       IF (XX(i) gt XR(j)) and (XX(i) lt XR(j+1)) then begin
			   FRAC=(XX(i)-XR(j))/D2TH & FRAC1=1-FRAC
                           WINT(j,*)=FRAC1*WOUT(i,*)+WINT(j,*)	& WINT(j+1,*)=FRAC*WOUT(i,*)+WINT(j+1,*) 
                             NN(j)  =FRAC1*vparm(1) +  NN(j)	&   NN(j+1)  =FRAC*vparm(1) +  NN(j+1) 
                       ENDIF
                      ENDFOR 
                     ENDFOR
		     XX=XR & WOUT=WINT 
                     EE = SQRT(WOUT)		; *** EE the error
                   ENDIF
                   XX=round(XX*10000) & XX=XX/10000.
           	   XT   ='2*theta'
		   END
	   'db21': BEGIN WOUT=reform(WOUT,128 ,128,/overwrite)
	   	   END
	   'd1b':  BEGIN
           	   XT  ='2*Theta'
           	   YT  ='Temperature'
           	   XX  =findgen(n_elements(WOUT)) * 79.8/(n_elements(WOUT)-1)+PP(3)
           	   YY  =param(46)
	   	   END
	   'd1a':  BEGIN nd=25. & IF n_elements(cal_d1a) eq 0 THEN $
				     P_DID_CALOD, insv,insv+'.cal', flg
		   nj  = n_elements(WOUT)/(nd+4)
		   if long(nj) ne nj then RETURN,0
	   	   WOUT= reform(WOUT,(nd+4),nj ,/overwrite)
		   NN  = WOUT(0,0)
		   YY  = reform(WOUT(2,*))/1000.
   	   	   YT  ='Counts'
		   WOUT= WOUT(4:*,*)
		   IF n_elements(cal_d1a) eq nd THEN BEGIN wout=float(wout) &  FOR i=0,nj-1 $
						        DO wout(0,i)=wout(*,i)/cal_d1a & fct=1.
							OT=OT+' /'+inf_d1a(0)
		   ENDIF ELSE fct = -6.

		   XX  =fct*ang_d1a+YY(0)
		   WOUT= reform(WOUT,nd*nj,/overwrite)
		   IF nj gt 1 then BEGIN FOR i=1,nj-1 do  XX=[XX , fct*ang_d1a+YY(i)]
		   			 idx=sort (XX) &  XX =XX(idx) & WOUT=WOUT(idx)
		   			 XX =round(XX/0.05) & XX=XX*0.05
		   			 YY =param(46)
		   		   ENDIF
           	   XT  ='2*Theta'
	   	   END
	   'd2b':  BEGIN
;			*** initialize parameters ***
			nd=64. & D2TH = param(36) 
		        if n_elements(dzap) eq 0 then dzap=0
		        if n_elements(pzap) eq 0 then pzap=0
;			*** read calibration file (if present)
			IF n_elements(cal_d2b) eq 0 THEN $
			   P_DID_CALOD, insv,insv+'.cal', flg

;		       *** nj = number of points ***
		   vp  = parai(4)+2
		   nj  = n_elements(WOUT)/(nd+vp)
;		       *** rewrite WOUT in matrix form (69 cols, nj rows) ***
	   	   WOUT= reform(WOUT,(nd+vp),nj ,/overwrite)
		   NN  = WOUT(0,0)
;			*** YY = 2th values for detector 1 ***
		   YY  = reform(WOUT(2,*))/1000.
;			*** set titles ***
   	   	   YT  ='Counts'
		   XT  =' 2*Theta' 
;			*** reform WOUT to eliminate first vp values (not data) ***
		   WOUT= WOUT(vp:*,*)

;		   *** detector zapping algorithm ***
;		   *** definition of new calibration arrays (default: equal to old)
		   newcal_d2b=cal_d2b
		   newang_d2b=ang_d2b
		   newd=nd
;		   *** test if dzap contains real detectors **
		   idz=where(dzap ge 1 and dzap le 64)
;		   *** in case, eliminate spurious values ***
		   if idz(0) ne -1 then dzap=dzap(idz) else dzap=0
;		   *** is there something left? ***
		   SD=SIZE(dzap)

;		   *** test if pzap contains real points **
		   idz=where(pzap ge 1 and pzap le nj)
;		   *** in case, eliminate spurious values ***
		   if idz(0) ne -1 then pzap=pzap(idz) else pzap=0
;		   *** is there something left? ***
		   SP=SIZE(pzap)

;		   *** if dzap has something, do the following ***
		   if SD(0) gt 0 then BEGIN
;		     *** set all dud values and calibration to -999 ***
		     WOUT(dzap-1,*)=-999
		     newcal_d2b(dzap-1)=-999
;		     *** good values are those which do not contain -999 ***
		     GOOD=where(WOUT ne -999)
		     if GOOD(0) eq -1 then return, GOOD(0)

;		     *** cut out dud values from WOUT and calibrations ***
		     WOUT=WOUT(GOOD)
		     newang_d2b=ang_d2b(where(newcal_d2b ne -999))
		     newcal_d2b=cal_d2b(where(newcal_d2b ne -999))
;		     *** redefine the detector number
		     newd=(nd-n_elements(dzap))
;		     *** reform WOUT to proper format
		     WOUT=reform(WOUT,newd,nj ,/overwrite)
		   ENDIF

;		   *** if pzap has something, do the following ***
		   if SP(0) gt 0 then BEGIN
;		     *** set all dud values -999 ***
		     WOUT(*,pzap-1)=-999
;		     *** good values are those which do not contain -999 ***
		     GOOD=where(WOUT ne -999)
;		     *** cut out dud values from WOUT ***
		     WOUT=WOUT(GOOD)
;		     *** redefine the number of points
		     nj=(nj-n_elements(pzap))
;		     *** reform WOUT to proper format
		     WOUT=reform(WOUT,newd,nj ,/overwrite)
		   ENDIF
;			*** if calibration available, calibrate by dividing ***
		   
		   IF n_elements(cal_d2b) eq nd THEN BEGIN wout=float(wout) &  FOR i=0,nj-1 $
							DO wout(0,i)=wout(*,i)/newcal_d2b & fct=1.
							OT=OT+' /'+inf_d2b(0)
;		        *** fct*newang_d2b always newd values spaced by ~ -2.5 ***
		   ENDIF ELSE fct = -2.5
;			*** XX array of initial 2th for all detectors ***
		   XX  =fct*newang_d2b+YY(0)
;			*** reform WOUT to be a 1-line vector ***
		   WOUT= reform(WOUT,newd*nj,/overwrite)
;			*** create a XX array by adding up all 2th for all dets **
;			*** in the same order as in WOUT


;			*** do the following if there are at least 2 points ***
		   IF nj gt 1 then BEGIN FOR i=1,nj-1 do  XX=[XX , fct*newang_d2b+YY(i)]
;			*** sort the XX and WOUT arrays (idx is the index array) ***
		   			 idx=sort (XX) &  XX =XX(idx) & WOUT=WOUT(idx)
;			*** XR contains the 2th's rounded to the nearest step size ***
		   			 XR =round(XX/D2TH) & XR=XR*D2TH
;			*** GRID contains the fractional indices of XR into XX ***					 
					 GRID=(XR-XX)/D2TH+findgen(n_elements(XX))				
;			*** WINT is WOUT interpolated onto the fractional indices *** 
					 WINT=interpolate(WOUT,GRID)
;			*** reassign XX and WOUT
					 XX=XR
				         WOUT=WINT
;			*** YY is the temperature, EE the error
		   			 YY =param(46)
;No error for Emanuelle			 EE = SQRT(WOUT)
		   		   ENDIF
	   	   END
		   
	'd20': rdid_d20, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                 WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE

	
	   else:
	   ENDCASE
	   END

   '3axes':BEGIN
   	   DATE=strmid   (partx(5),7,9)
   	   WT  =strmid(partx(2),7,11) +' '+linec
   	   OT  =insv +' '+partx(5)+' '+partx(2)+' Run ' + FILENAME
   	   XT  =strcompress(strmid(partx(6),7,69))
   	   YT  ='CNTS'
   	   PP  =fltarr(n_elements(partx))
   	   PTXT=partx
   	   PV  =vparm
   	   
   	   idx =where(linet eq 'CNTS') & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN WOUT=reform(vparm(idx,*)) ELSE WOUT=reform(vparm)
	   
   	   idx =where(linet eq 'M1')   & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN NN  =reform(vparm(idx,*))

   	   idx =where(linet eq step)   & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN BEGIN XX  =reform(vparm(idx,*))
   	   					     id  =sort(XX)
   	   					     XX  =XX  (id)
   	   					     WOUT=WOUT(id)
   	   					     IF n_elements(NN) gt 1  THEN  NN=NN(id)
   	   					     XT  =XT+' unit= '+step  &  ENDIF
	   EE  =sqrt(WOUT)
   	   END
   'tof':  BEGIN nd =0
   	   nb_chn=(SIZE(WOUT))(1)
   	   nb_spc=(SIZE(WOUT))(2)
	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
	   WT  =	                            strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
	   XT  ='Channels'
	   YT  ='Spectrum'
	   ZT  ='Numor' & ZZ=numor

     	   CASE insv of
	   
           'd7':   rdid_d7, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                    WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE
     	   'in16': BEGIN IF n_elements(WOUT) gt 1 THEN BEGIN Helas=0
			        IF n_elements(WOU) eq 1 THEN WOU=WOUT else Helas=1
				nb_chn=par1(6)          & nb_spc=par1(7)
				nb_mon=par1(8)          & md_pos=par1(64)
				n_md  =20               & ndind =nb_spc
				YY    =fltarr(nb_spc)
				NN    =WOU (0:nb_chn-1,nb_spc:nb_spc+nb_mon-1)>1
				PP    =[par1 (14),par1 (6 ),par1 (7 ),par1 (8 ),par1 (15),0.       ,$
				        0.       ,par1 (69),par1 (79),par1 (9 ),par1 (20),par1 (83),$
				        par1 (59),par1 (60),par1 (13),0.       ,0.       ,0.       ,$
				        0.       ,par1 (64),param(20),param(21),param(22),param(23),$
				        param(24),param(25),param(26),param(27),param(0 ),$
				        param(1 )-param(0 ),n_md]
				PTXT  =['Type of scan (index)            ','Number of channels              ',$
				        'Number of detectors             ','Number of monitors              ',$
				        'Mesuring time per step (seconds)','Not used                        ',$
				        'Not used                        ','Monochromator d-spacing (ang.)  ',$
				        'Analyser      d-spacing (ang.)  ','Average sample temperature  (K) ',$
				        'Deflector Chopper frequency (Hz)','Number of dead channels         ',$
				        'T1 (microsec.)                  ','T2 (microsec.)                  ',$
				        '1 if diffraction detector used  ','Not used                        ',$
				        'Not used                        ','Not used                        ',$
				        'Not used                        ','MD position                     ',$
				        'Single scattering angle 1 (deg.)','Single scattering angle 2 (deg.)',$
				        'Single scattering angle 3 (deg.)','Single scattering angle 4 (deg.)',$
				        'Single scattering angle 5 (deg.)','Single scattering angle 6 (deg.)',$
				        'Single scattering angle 7 (deg.)','Single scattering angle 8 (deg.)',$
				        'First angle MD-tube       (deg.)','Angle increment MD        (deg.)',$
				        'Number of MD-tubes              ']
				IF (nb_spc ge n_md)  THEN BEGIN
				  ndind = nb_spc - n_md
				  if ndind   gt   0  THEN YY(0    :ndind-1)     = param(n_md:n_md+ndind-1)
				  OFS=((md_pos-1)>0)*.5 & YY(ndind:ndind+n_md-1)= param(0:n_md-1)+OFS
				ENDIF   ELSE              YY(0    :ndind-1)     = param(n_md:n_md+ndind-1)

				IF par1(14) eq 0         THEN BEGIN		;*** DOPLER **
				  PP(2)=par1(2) & PP(3)=par1(7) & PP(4)=par1(8)
				  PP(5)=par1(0) & PP(6)=par1(1)
				  PTXT(2)='Average Doppler frequency       ' & PTXT(3)='Number of detectors             '
				  PTXT(4)='Number of monitors              ' & PTXT(5)='Duration of scan (seconds)      '
				  PTXT(6)='Counts in Monitor 1             '
				  XX=indgen(nb_chn)+1
				  ENDIF
				IF par1(14) eq 1         THEN BEGIN		;*** ELASTIC SCAN sample_t **
				  XX=WOU (0:nb_chn-1,nb_spc+nb_mon)/1000.
				  ENDIF
				IF par1(14) ge 2         THEN BEGIN		;*** ANGLE SCAN **
				  XX=WOU (0:nb_chn-1,nb_spc+nb_mon)/100.
				  ENDIF
				WOU =WOU (0:nb_chn-1,0:nb_spc-1)
				IF (nb_spc gt n_md)      THEN BEGIN
				  WOT =WOU
				  WOU (*,0:ndind-1)=WOT(*,n_md:n_md+ndind-1)	; Normal detectors
				  WOU (*,ndind:n_md+ndind-1)=WOT(*,0:n_md-1)	; Multi  detectors  
				  ENDIF
				if (INST(2) eq '0')      THEN BEGIN
				  OT     =OT + " Normalized"
				  moni   =round(total(NN(*,0)))/nb_chn & mona=moni/(NN(*,0)>1)
				  FOR  i =0,nb_spc-1 do WOU (*,i)=WOU (*,i)*mona
				  NN(*,0)=moni
				  ENDIF
				if (Helas)  THEN BEGIN ;par1(13)=1
				  OT = OT + " (Diff. on)"
				  PTXT(15) = 'Angle increment between detect. ' & PP(15)=par1(18)
				  PTXT(16) = 'Vert. angle wrt scattering plane' & PP(16)=par1(19)
				  PTXT=[PTXT,'Zero point (deg) of 1st det. Blk',$
				             'Zero point (deg) of 2nd det. Blk',$
				             'Zero point (deg) of 3rd det. Blk',$
				             'Zero point (deg) of 4th det. Blk',$
				             'Zero point (deg) of 5th det. Blk']
				  PP  =[PP  , par1(120),par1(121),par1(122),par1(123),par1(124)]
				  ENDIF
				YT='2-Theta (deg.)'
				CASE par1(14) of
				0:  BEGIN XT='Channels'                 & END
				1:  BEGIN XT='T/K'                      & END
				2:  BEGIN XT='Gamma-1 deg.'             & END
				3:  BEGIN XT='Gamma-2 deg.'             & END
				4:  BEGIN XT='THETA-S deg.'             & END
				5:  BEGIN XT='Sample Height'            & END
				6:  BEGIN XT='Theta-ANALYSER'           & END
				7:  BEGIN XT='2*Theta-ANALYSER'         & END
				8:  BEGIN XT='Theta-Monochromator deg.' & END
				9:  BEGIN XT='Gamma-Monochromator'      & END
				10: BEGIN XT='Theta-D1 deg.'            & END
				11: BEGIN XT='CD1'                      & END
				12: BEGIN XT='Theta-D2 deg.'            & END
				ELSE:
				ENDCASE
			
				IF n_elements(dzap) ne 1 THEN dzap=0 & if dzap eq 0 then Helas=0
				IF not Helas then WOUT=float(WOU) $	;*** INELASTIC **
				ELSE BEGIN			        ;*** MULTI DETECTOR **
				  sz  =size(WOUT)
				  XT  ='Angles' & YT='Counts'
				  a   =par1(18)
				  XX  =[findgen(32)*a+par1(120),findgen(32)*a+par1(121),findgen(32)*a+par1(122),$
				        findgen(32)*a+par1(123),findgen(32)*a+par1(124)]
				  IF  sz(0) ge 2 THEN BEGIN YT ='Scan set'
					YY=indgen(sz(2))+1 & ENDIF
				  PV  =WOU
				  WOUT=REVERSE(WOUT,1)
				ENDELSE
	                 ENDIF
	           END
     	   'in10': BEGIN
			mon =par1 (20)>1
			chn =par1 (23)
			spc =par1 (19)
			NN  =WOUT (0:chn-1,spc:spc+mon-1)
			YY  =param (0:spc-1)
			
				CASE par1(21) of
				0:  BEGIN XT='Channels'           & XX  =indgen(chn)+1                    & END ; DOPLER **
				1:  BEGIN XT='T/K'                & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ELASTIC SCAN **
				2:  BEGIN XT='T/K'                & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ELASTIC SCAN **
				3:  BEGIN XT='CHI_M  (deg.)'      & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ANGLE SCAN **
				4:  BEGIN XT='THETA_M2  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ""
				5:  BEGIN XT='THETA_M1  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				6:  BEGIN XT='CHI_E1  (deg.)'     & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				7:  BEGIN XT='CHI_E2  (deg.)'     & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				8:  BEGIN XT='THETA_G  (deg.)'    & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				9:  BEGIN XT='CHI_G  (deg.)'      & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				10: BEGIN XT='2THETA_G  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				11: BEGIN XT='OMEGA_E1  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				12: BEGIN XT='OMEGA_E2  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				13: BEGIN XT='Spectrum number'    & XX  =WOUT (0:chn-1,nb_spc-1)/1000.0   & END ; Monochromator-T **
				ELSE:
				ENDCASE
				
			WOUT=FLOAT(WOUT (0:chn-1,0:spc-1))
			PTXT=['Type of scan (index)                 =' , 'Duration of scan (seconds)           =']
			
			IF par1(21) eq 0 then begin
			 PTXT=[ PTXT,$
			'Max. Doppler frequency (Hz)          =' , 'Min. Doppler frequency (Hz)          =', +$
			'Chopper frequency (RPM)              =' , 'Lattice param. Monochromator (ang.)  =', +$
			'Lattice param. Analyser      (ang.)  =' , 'Lattice param. Deflector     (ang.)  =', +$
			'TOF Sample-Det. (microsec.)          =' , 'TOF Sample-M1   (microsec.)          =', +$
			'TOF Sample-M2   (microsec.)          =' , 'T1              (microsec.)          =', +$
			'T2              (microsec.)          =' , 'Number of detectors in use           =', +$
			'Number of monitors  in use           =' , 'Channel limit                        =', +$
			'Number of points in spectrum         =' , 'Scattering angle 1 (2*theta) (deg.)  =', +$
			'Scattering angle 2 (2*theta) (deg.)  =' , 'Scattering angle 3 (2*theta) (deg.)  =', +$
			'Scattering angle 4 (2*theta) (deg.)  =' , 'Scattering angle 5 (2*theta) (deg.)  =', +$
			'Scattering angle 6 (2*theta) (deg.)  =' , 'Scattering angle 7 (2*theta) (deg.)  =', +$
			'Scattering angle 8 (2*theta) (deg.)  =' , 'Deflector  angle Theta-g     (deg.)  =', +$
			'Not used =' , 'Not used =' , 'Not used =' , 'Not used =' , 'Not used =']
			 PP=[ $
			 par1 (21),par1 (0 ),par1 (1 ),par1 (2 ),par1 (3 ),par1 (81),par1 (83),par1 (82), +$
			 par1 (84),par1 (85),par1 (86),par1 (87),par1 (88),par1 (19),par1 (20),par1 (6 ), +$
			 par1 (23),param(0 ),param(1 ),param(2 ),param(3 ),param(4 ),param(5 ),param(6 ), +$
			 param(6 ),par1 (50),0. ,0. ,0. ,0. ,0. ]
			ENDIF
			
			IF (par1(21) ge 1) and (par1(21) le 12) then begin
			 PTXT=[ PTXT,$
			'Chopper frequency (RPM)              =' , 'Lattice param. Monochromator (ang.)  =', +$
			'Lattice param. Analyser      (ang.)  =' , 'Lattice param. Deflector     (ang.)  =', +$
			'TOF Sample-Det. (microsec.)          =' , 'TOF Sample-M1   (microsec.)          =', +$
			'TOF Sample-M2   (microsec.)          =' , 'T1              (microsec.)          =', +$
			'T2              (microsec.)          =' , 'Number of detectors in use           =', +$
			'Number of monitors  in use           =' , 'Number of points in spectrum         =', +$
			'Not used =' , 'Not used =' , 'Not used =' , 'Not used =' , 'Not used =']
			 PP=[ $
			 par1 (21),par1 (0 ),par1 (3 ),par1 (81),par1 (83),par1 (82),par1 (84),par1 (85), +$
			 par1 (86),par1 (87),par1 (88),par1 (19),par1 (20),par1 (23),0. ,0. ,0. ,0. ,0. ]
			ENDIF
			
			IF par1(21) eq 13 then begin
			 PTXT=[ PTXT,$
			'Chopper frequency (RPM)              =' , 'Monochromator coeff. A0              =', +$
			'Monochromator coeff. A1              =' , 'Monochromator coeff. A2              =', +$
			'Monochromator coeff. A3              =' , 'Monochromator coeff. B0              =', +$
			'Monochromator coeff. B1              =' , 'Monochromator coeff. B2              =', +$
			'Monochromator coeff. B3              =' , 'Coeff. transition  temperature (K)   =', +$
			'Max. monochromator temperature (K)   =' , 'Lattice param. Analyser      (ang.)  =', +$
			'Lattice param. Deflector     (ang.)  =' , 'TOF Sample-Det. (microsec.)          =', +$
			'TOF Sample-M1   (microsec.)          =' , 'TOF Sample-M2   (microsec.)          =', +$
			'T1              (microsec.)          =' , 'T2              (microsec.)          =', +$
			'Number of detectors in use           =' , 'Number of monitors  in use           =', +$
			'Number of points in spectrum         =' , 'Scattering angle 1 (2*theta) (deg.)  =', +$
			'Scattering angle 2 (2*theta) (deg.)  =' , 'Scattering angle 3 (2*theta) (deg.)  =', +$
			'Scattering angle 4 (2*theta) (deg.)  =' , 'Scattering angle 5 (2*theta) (deg.)  =', +$
			'Scattering angle 6 (2*theta) (deg.)  =' , 'Scattering angle 7 (2*theta) (deg.)  =', +$
			'Scattering angle 8 (2*theta) (deg.)  =' ]
       			 PP=[ $
			 par1 (21),par1 (0 ),par1 (3 ),par1 (66),par1 (67),par1 (68),par1 (69),par1 (70), +$
			 par1 (71),par1 (72),par1 (73),par1 (74),par1 (75),par1 (83),par1 (82),par1 (84), +$
			 par1 (85),par1 (86),par1 (87),par1 (88),par1 (19),par1 (20),par1 (23),param(0 ), +$
			 param(1 ),param(2 ),param(3 ),param(4 ),param(5 ),param(6 ),param(7 )]
			ENDIF
			if (INST(2) eq '0')  THEN BEGIN
				OT     =OT + " Normalized"
				moni   =round(total(NN(*,0))/chn) & mona=moni/(NN(*,0)>1)
				FOR  i =0,spc-1 do WOUT (*,i)=WOUT (*,i)*mona
				NN(*,0)=moni
				ENDIF
	           END
     	   'in4':  BEGIN an=strmid(DATE,6,3) & if strpos(an,'-') eq 0 then an=strmid(an,1,2)
	   		if (an gt '75') and (an lt '91') then off=2 else off=16
			NN  =      WOUT(0:nb_chn-2,0:1)
			WOUT=FLOAT(WOUT(0:nb_chn-2,off:nb_spc-1))
			XX  =indgen(nb_chn-1)+1
			YY  =par1  (31+off:31+nb_spc-1)
			PTXT=[ $
			'Run duration (seconds)             =' , 'Time in 0.1 seconds                =', +$
			'Number of reserved channels        =' , 'Counts in M1                       =', +$
			'Counts in M2                       =' , 'Not used                           =', +$
			'Total counts                       =' , 'Not used                           =', +$
			'Sample angle (deg.)                =' , 'Elastic peak position (channel)    =', +$
			'Numor                              =' , 'Sample temperature (K)             =', +$
			'Digital Voltmeter Reading          =' , 'Repetition period (microsec.)      =', +$
			'Multiplier for repetition period   =' , 'Not used                           =', +$
			'Not used                           =' , 'Not used                           =', +$
			'Channel width (microsec.)          =' , 'Number of channels used            =', +$
			'TOF delay (microsec.)              =' , 'Wavelength (angstroms)             =', +$
			'Distance CH4 - M1     (meter)      =' , 'Distance CH4 - Sample (meter)      =', +$
			'Not used                           =' , 'Distance M1  - M2     (meter)      =', +$
			'Not used                           =' , 'Distance Det - Sample (meter)      =', +$
			'Contents scaler 1                  =' , 'Contents scaler 2                  =', +$
			'Number of angles                   =' ]
       			 PP=[ $
			 par1 (2 ),par1 (5 ),param(1 ),par1 (3 ),par1 (4 ),  0.     ,par1 (7 ),  0.     , +$
			 par1 (17),param(8 ),param(9 ),param(10),par1 (15),param(12),param(13),  0.     , +$
			   0.     ,   0.    ,param(17),nb_chn-1 ,param(19),param(20),param(21),param(22), +$
			   0.     ,param(24),   0.    ,param(26),par1 (0 ),par1 (1 ),nb_spc-off]
			   
			if (INST(2) eq '0') THEN begin	P_DID_CALDO, insv,WOUT,YY,ok
							if ok then begin  XT=XT+' pre-Calibrated'
								monu= 500000.
								tot = monu/total(NN(*,0))
								WOUT= WOUT*tot
								NN(*,0) =0 & NN(0,0)=monu & endif & endif
	           END
     	   'in5':  BEGIN off=8
	   		IF n_elements(par2) eq 0 then begin par2=par1 & par1=param & off=6 & endif
			NN  =      WOUT(0:nb_chn-2,0:2)
			WOUT=FLOAT(WOUT(0:nb_chn-2,off:nb_spc-1))
			XX  =indgen(nb_chn-1)+1
			YY  =par2  (31+off:31+nb_spc-1)
			PTXT=[ $
			'Run duration (seconds)             =' , 'Time in 0.1 seconds                =', +$
			'Number of reserved channels        =' , 'Counts in M1                       =', +$
			'Counts in M2                       =' , 'Counts in M3                       =', +$
			'Total counts                       =' , 'Not used                           =', +$
			'Sample angle (deg.)                =' , 'Elastic peak position (channel)    =', +$
			'Numor                              =' , 'Sample temperature (K)             =', +$
			'Digital Voltmeter Reading          =' , 'Repetition period (microsec.)      =', +$
			'Multiplier for repetition period   =' , 'Not used                           =', +$
			'Not used                           =' , 'Not used                           =', +$
			'Channel width (microsec.)          =' , 'Number of channels used            =', +$
			'TOF delay (microsec.)              =' , 'Wavelength (angstroms)             =', +$
			'Distance CH4 - M1     (meter)      =' , 'Distance CH4 - Sample (meter)      =', +$
			'Not used                           =' , 'Distance M1  - M2     (meter)      =', +$
			'Distance M1  - M3     (meter)      =' , 'Distance Det - Sample (meter)      =', +$
			'Contents scaler 1                  =' , 'Contents scaler 2                  =', +$
			'Number of angles                   =' ]
       			 PP=[ $
			 par2 (2 ),par2 (5 ),par1 (1 ),par2 (3 ),par2 (4 ),par2 (6 ),par2 (7 ),  0.     , +$
			 par2 (17),par1 (8 ),par1 (9 ),par1 (10),par2 (15),par1 (12),par1 (13),  0.     , +$
			   0.     ,   0.    ,par1 (17),nb_chn-1 ,par1 (19),par1 (20),par1 (21),par1 (22), +$
			   0.     ,par1 (24),par1 (25),par1 (26),par2 (0 ),par2 (1 ),nb_spc-off]
			   
			if (INST(2) eq '0') THEN begin	P_DID_CALDO, insv,WOUT,YY,ok
							if ok then begin  XT=XT+' pre-Calibrated'
								monu= 500000.
								tot = monu/total(NN(*,0))
								WOUT= WOUT*tot
								NN(*,0) =0 & NN(0,0)=monu & endif & endif
	           END
     	   'in6':  BEGIN if nb_spc gt 300 then begin off=3  & mom=3
	                            endif else begin off=21 & mom=4 & endelse
			 if nb_spc lt 100 then off=6
			NN  =      WOUT(0:nb_chn-2,0:mom-1)
			WOUT=FLOAT(WOUT(0:nb_chn-2,off:nb_spc-1))
			XX  =indgen(nb_chn-1)+1
			YY  =par1  (31+off:31+nb_spc-1)
			PTXT=[ $
			'Run duration (seconds)             =' , 'Time in 0.1 seconds                =', +$
			'Number of reserved channels        =' , 'Counts in M1                       =', +$
			'Counts in M2                       =' , 'Counts in M3                       =', +$
			'Total counts                       =' , 'Not used                           =', +$
			'Sample angle (deg.)                =' , 'Elastic peak position (channel)    =', +$
			'Numor                              =' , 'Sample temperature (K)             =', +$
			'Digital Voltmeter Reading          =' , 'Repetition period (microsec.)      =', +$
			'Multiplier for repetition period   =' , 'Not used                           =', +$
			'Not used                           =' , 'Not used                           =', +$
			'Channel width (microsec.)          =' , 'Number of channels used            =', +$
			'TOF delay (microsec.)              =' , 'Wavelength (angstroms)             =', +$
			'Distance CH4 - M1     (meter)      =' , 'Distance CH4 - Sample (meter)      =', +$
			'Not used                           =' , 'Distance M1  - M2     (meter)      =', +$
			'Distance M1  - M3     (meter)      =' , 'Distance Det - Sample (meter)      =', +$
			'Contents scaler 1                  =' , 'Contents scaler 2                  =', +$
			'Number of angles                   =' ]
       			 PP=[ $
			 par1 (2 ),par1 (5 ),param(1 ),par1 (3 ),par1 (4 ),par1 (6 ),par1 (7 ),  0.     , +$
			 par1 (17),param(8 ),param(9 ),param(10),par1 (15),param(12),param(13),  0.     , +$
			   0.     ,   0.    ,param(17),nb_chn-1 ,param(19),param(20),param(21),param(22), +$
			   0.     ,param(24),param(25),param(26),par1 (0 ),par1 (1 ),nb_spc-off]
			   
			if (INST(2) eq '0') THEN begin	P_DID_CALDO, insv,WOUT,YY,ok
							if ok then begin  XT=XT+' pre-Calibrated'
								GROUPY,WOUT ,YY ,/average
								monu= 500000.
								tot = monu/total(NN(*,0))
								WOUT= WOUT*tot
								NN(*,0) =0 & NN(0,0)=monu & endif & endif
	           END
     	   'in13': BEGIN wavel=2.23
		    IF (size(WOUT))(2) eq 74 THEN BEGIN  nd=70
			  ;inelastic scan old format
			  ;*************************
			  IF n_elements(cal_in13) eq 0 THEN $
			     P_DID_CALOD, insv,insv+'.cal', flg
			  YY=[round(param(0 :34)*100)/100.      ,.1,.2,$
			      round(param(0 :34)*100)/100.+0.001,.3,.4]
			  sx=(size(WOUT))(1)
			  NN=lonarr(sx,3)
			  NN(*,1)=WOUT(*,36)>1 & NN(*,2)=WOUT(*,73)>1
			  WOUT=float(WOUT)
			  FOR i=0 ,34 do WOUT(*,i)=WOUT(*,i)/NN(*,1)
			  FOR i=37,71 do WOUT(*,i)=WOUT(*,i)/NN(*,2)
			  NN(*,0)=round(total(NN)/sx)

			  idx =sort(YY) & WOUT=WOUT(*,idx) & YY=YY(idx)
					  WOUT=WOUT(*,4:*) & YY=YY(4:*)
			  WOUT=WOUT*NN(0,0)
			  IF n_elements(cal_in13) eq nd THEN BEGIN
				FOR i=0,nd-1 DO wout(0,i)=wout(*,i)/cal_in13(i)
				OT=OT+' /'+inf_in13(0)
			  ENDIF
			  XX  =findgen (sx)*par1(11)+par1(1)-par1(2)
			  YY  =4*!pi/wavel*sin(YY/2*!pi/180.)
           		  XT  ='Energy micro eV   (normalized)'
           		  YT  ='Q(0) pairs'
			  IF par1(8) gt 0 THEN BEGIN ZZ=(par1(9)+par1(10))/2
						     ZT='Temperature' & ENDIF
		    ENDIF ELSE $
		    IF (par1(8) eq 1 or par1(8) eq 2)  THEN BEGIN  nd=par1(7)-2 & sx=(size(WOUT))(1)
			  ;inelastic scan
			  ;**************
			  IF n_elements(cal_in13) eq 0 THEN $
			     P_DID_CALOD, insv,insv+'.cal', flg
			  YY  =round(param(0 :nd-1)*100)/100.
			  WOUT=float(WOUT)
			  XX  =WOUT(*,nd+2) & XI=(XX(1)-XX(0))/2
			  XX  =(XX+Xi)/100.
			  if XI lt 0 then BEGIN
				XX=REVERSE(XX) & WOUT=REVERSE(WOUT,1)
			  ENDIF
		     	  NN  =WOUT(*,nd)>1
			  WOUT=WOUT(*,0 :nd-1)
			  idx =sort(YY) & WOUT=WOUT(*,idx) & YY=YY(idx)
			  if (INST(2) eq '0') then BEGIN
			  	OT   =OT + " Normalized"
				moni =round(total(NN)/sx) & mona=moni/(NN>1)
				FOR i=0,nd-1 do WOUT(*,i)=WOUT(*,i)*mona
				NN(*)=moni
			  ENDIF
		    ENDIF ELSE $
		    IF (scan    eq 1)  THEN BEGIN
			  ;elastic scan old format
			  ;***********************
		          nd=35 & sx=1
		     	  NN  =WOUT(36)
			  WOUT=float(WOUT(0:34))
			  XX  =round(param(0 :34)*100)/100.
			  idx =sort(XX) & XX  =XX(idx) & WOUT=WOUT(idx)
			  XX  =4*!pi/wavel*sin(XX/2*!pi/180.)
           		  XT  ='Q(0)'
			  YY=(par1(9)+par1(10))/2
			  YT  ='Counts'
		    ENDIF ELSE $
		    IF (par1(8) eq 0)  THEN BEGIN  nd=par1(7)-2 & sx=(size(WOUT))(1)
			  ;elastic scan
			  ;************
		     	  NN  =WOUT(*,nd)
			  YY  =WOUT(*,nd+3)/100.
			  WOUT=float(WOUT(*,0:nd-1))
			  WOUT=reform(TRANSPOSE(WOUT))
			  if (sx gt 1) and (INST(2) eq '0') then BEGIN
			  	OT   =OT + " corrected"
				moni =total(NN)/sx
				FOR i=0,sx-1 do WOUT(*,i)=WOUT(*,i)*moni/NN(i)
				NN   =moni
			  ENDIF
			  XX  =round(param(0 :nd-1)*100)/100.
			  idx =sort(XX) & XX  =XX(idx) & WOUT=WOUT(idx,*)
			  XX  =4*!pi/wavel*sin(XX/2*!pi/180.)
           		  XT  ='Q(0)'
			  YT  ='Counts'
		    ENDIF
		    IF nd gt 0 THEN BEGIN
			  EE  =sqrt(WOUT)
			  PP  =[par1(8),par1(0),par1(3),par1(1),par1(2),par1(11),wavel]
			  PTXT=['Type  of scan      (index)   ','Duration of scan   (second)  ',$
				'Chopper frequency            ','Energy   center    (micro eV)',$
				'Energy half range  (micro eV)','Channel  width     (micro eV)',$
				'Wave length        (angstrom)']
		    ENDIF
		  END
	   else:
	   ENDCASE
	   END
   'lss':  BEGIN
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
	   ZZ  = param(64)
	   NN  = param(0)
	   PP  = [0.0] & PTXT= [" "]
	   
	   dim= LONG(SQRT(n_elements(WOUT)))
	   IF dim*dim  eq n_elements(WOUT) then BEGIN
	   	WOUT=reform(WOUT,dim,dim,/overwrite)
	   	WOUT=float(WOUT)
	   	sw=size(WOUT)
		XX  = INDGEN(sw(1))
		YY  = INDGEN(sw(2))
		XT  ='X detector'
		YT  ='Y detector'
		ZT  ='Sample Angle'

	     PP=[param(0) ,param(1) ,param(2) ,param(3) ,param(14),param(15),param(16),param(17),param(18),$
	         param(25),param(30),param(32),param(33),param(50),param(51),param(52),param(53),param(57),$
		 param(60),param(61),param(62),param(63),param(64),param(65),param(66),param(80),numor,0,0,0,0]

	     PTXT=['PRESET 1                             ','PRESET 2                             ',$
		   'Run duration (1/10 sec.)             ',$
		   'Total detector counts                ','Detector offset angle (deg.)         ',$
		   'Coder 1: By (mm)                     ','Coder 2: Bx (mm)                     ',$
		   'Coder 3: Sample changer transl. (mm) ','Coder 4: Detector distance (set) (m) ',$
		   'Sample-Detector distance (calc.) (m) ','Sample Temperature (K)               ',$
		   'Value of IEEE-1 at start             ','Value of IEEE-1 at end               ',$
		   'Beam centre adress X0 (mm)           ','Beam centre adress Y0 (mm)           ',$
		   'Wavelength (angstroms)               ','Wavelength resolution                ',$
		   'Collimation  (m)                     ','Detector angle (set) (deg.)          ',$
		   'Detector translation (set) (mm)      ','Selector angle (deg.)                ',$
		   'Sample distance (mm)                 ','Sample rotation (deg.)               ',$
		   'Changer position                     ','Sample height (mm)                   ',$
		   'Shear speed (1/min.)                 ','Numor                                ',$
		   'Not used  ', 'Not used  ','Not used  ','Not used  ']
	   ENDIF
	   CASE insv of

           'd17': if nvers gt 0 then BEGIN
		   rdid_d17,INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                    WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE
		   WOUT=reform(WOUT)
		  ENDIF
	   'd22':
	   'd11': BEGIN PTXT(2) ='Run duration (sec.)                  '
			PTXT(21)='Sample distance (mm)                 '
			PTXT(22)='Sample rotation (deg.)               ' & WOUT(0,0)=1 & END
	   'd11tof': BEGIN
			WOUT=reform(WOUT,n_elements(WOUT),/overwrite)
			XT='T.O.F.' & YT='Counts' & XX=INDGEN(n_elements(WOUT))+1 & YY=0
			PP(*)=0.    & PTXT(*)='Not used  '  & END
	   else:
	   ENDCASE

	   END

   'test': BEGIN nd =0
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
           XT  ='OMEGA'
           YT  ='Counts'
	   ZT  ='Numor' & ZZ=numor

     	   CASE insv of
     	   't13a':BEGIN nd =n_elements(WOUT)/2
	   	  WOUT =reform(WOUT,2,nd)
		  XX   =reform(WOUT(0,*))
		  WOUT =reform(WOUT(1,*))
		  END
     	   't13c':BEGIN nd =n_elements(WOUT)/2
	   	  WOUT =reform(WOUT,2,nd)
		  XX   =reform(WOUT(0,*))
		  WOUT =reform(WOUT(1,*))
		  END
 	   else:
	   ENDCASE
	   END
		
   'lon':  BEGIN
           CASE insv OF
	   't3':BEGIN
			add = 1
			IF (STRMID(exper(2),0,3) EQ 'End') THEN add = 0 
	   		text = text(0)
	   		DATE = STRMID(text,14,18)
			i = STRPOS(exper(3),' ')
	   		XT = STRMID(exper(3),0,i)
			YT = 'Phase'
			ZT = 'Counts'
			OT = STRTRIM(text,2)
			IF (add EQ 0 AND STRPOS(exper(5),' ') EQ 0) THEN $
				bl = 1 ELSE bl = 0
			i = STRPOS(exper(8 + add + bl),',')
			jj = STRPOS(exper(7 + add  + bl),':')
			kk = RSTRPOS(exper(7 + add + bl),' ')
			WT = STRMID(exper(8 + add + bl),8,i-8)+STRMID(exper(7 + add + bl),jj+1,kk-jj)
                        WT = STRTRIM(WT,2)
			READS, STRMID(exper(5 + add + bl),13,3), nd
			nphases = (cnt/nd) - 3 - add
			WOUT = REFORM(WOUT,nphases + 3 + add,nd)
			WOUT = TRANSPOSE(WOUT)
			XX = WOUT(*,0+add)
			NN = WOUT(*,1+add:2+add)
			CASE nphases OF
			1: BEGIN
				WOUT = WOUT(*,3+add)
				YY = 0
			   END
			2: BEGIN
				WOUT = WOUT(*,3+add:4+add)
				YY = INDGEN(2)
			   END
			ENDCASE
			READS, STRMID(exper(4 + add),STRPOS(exper(4 + add),':')+1,5), b1
			READS, STRMID(exper(4 + add),RSTRPOS(exper(4 + add),':')+1,5), b2
			READS, STRMID(exper(8 + add + bl),RSTRPOS(exper(8 + add + bl),':')+1,5), lam
			i = RSTRPOS(exper(6 + add + bl),'=')
			READS, STRMID(exper(6 + add + bl),i+1,10), dbc1
			i = RSTRPOS(exper(6 + add + bl),',')
			READS, STRMID(exper(6 + add + bl),i+1,10), dbc2
			PP = [LONG(numor),lam,b1,b2,dbc1,dbc2]
			PTXT = ['0) Numor:                    ',$
				'1) Lambda:                   ',$
				'2) Flipper Current:          ',$
				'3) Correction Current:       ',$
				'4) Direct Beam (Cts/Sec):    ',$
				'5) Direct Beam (CtsMon/Sec): ']
		END
	   ENDCASE
	   END
   else:
   ENDCASE

   DATP={w_tit:WT ,x_tit:XT ,y_tit:YT ,z_tit:ZT ,other_tit:OT ,time:DATE,p:PP,par_txt:PTXT,$
         x:XX     ,y:YY     ,z:ZZ     ,n:NN     ,pv:PV        ,e:EE}
   
ENDIF ELSE begin print,!err_string, string(7b)
   ssz=SIZE(WOUT)
   if ssz(0) ge 1 then XX=indgen(ssz(1))+1 else XX=0
   if ssz(0) ge 2 then YY=indgen(ssz(2))+1 else YY=0
   DATP={x:XX ,y:YY}
ENDELSE

RETURN, WOUT
END
function rdinstr, INST , PATH , FILENAME , STATUS , DATP
;******* *************  
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.
 if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION RDRUN')
 DATA  =0
 STATUS=11
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

 ON_IOERROR, no_file
 OPENR,unit, PATH+FILENAME,/get_lun				;Open the data file

     STATUS=13
     ON_IOERROR, read_err
  line='text'
  READF,unit,line
 IF INST(0) EQ 'd1b' OR INST(0) EQ 'fil' THEN BEGIN
    p=FLTARR(40)
    par_txt=STRARR(40)
    READF,unit,line
    tit=line
    READF,unit,line
    bid=1
    numor=1000000
    READS,line,bid,numor
    print,' *** Fullprof INSTR format 3 (D1B "new" format created by fild1b/d20) *** '
    sub=PATH+FILENAME
    READF,unit,line
    bid=100
    step=0.1
    start=-2.2
    stop=157.7
    mon=100000.
    time=0.
    om=0.
    chi=0.
    phi=0.
    float_bid=0.
    wav=0.
    sp=0.
    tr=0.
    ts=0.
    nd=1600
    READS,line,mon,time,start,om,chi,phi,float_bid,wav,step,sp,tr,ts
    READF,unit,line
    READS,line,nd
    p(10)=sp
    p(11)=tr
    p(12)=ts
    p(13)=start
    p(14)=om
    p(15)=chi
    p(16)=phi
    par_txt(10)='Set Point/K             '
    par_txt(11)='Regulation Temperature/K'
    par_txt(12)='Sample Temperature      '
    par_txt(13)='2*Theta/deg.            '
    par_txt(13)='Omega/deg.              '
    par_txt(13)='Chi/deg.                '
    par_txt(13)='Phi/deg.                '
    READF,unit,line
    bid=0.
    SP=0.
    Treg=0.
    Tsamp=0.
    READS,line,mon,bid,SP,Treg,Tsamp
    p(10)=SP
    p(11)=Treg
    p(12)=Tsamp
    par_txt(10)='Set Point/K             '
    par_txt(11)='Regulation Temperature/K'
    par_txt(12)='Sample Temperature/K    '
    READF,unit,line
    datall=long(intarr(2,10))
    WHILE STRPOS(line,'   -1000') NE 0 DO BEGIN
      READS,line,datall, format = '(10(I2, I6))'
      IF N_ELEMENTS(data) LE 1 THEN BEGIN
        data=REFORM(datall(1,*),10)
        err= REFORM(sqrt(datall(1,*))/sqrt((datall(0,*)>.25)),10)
      ENDIF ELSE BEGIN
        data=[data,REFORM(datall(1,*),10)]
        err= [err, REFORM(sqrt(datall(1,*))/sqrt((datall(0,*)>.25)),10)]
      ENDELSE
      READF,unit,line     
    ENDWHILE     
    x=findgen(N_ELEMENTS(data))*step+start
 ENDIF ELSE IF strmid(line,0,2) EQ '# ' OR strmid(line,0,4) EQ '#XY ' OR strmid(line,0,6) EQ 'XYDATA' OR INST(0) EQ 'xy' THEN BEGIN ; *** Fullprof INSTR format 10 (X,Y,Sigma format with Header lines starting with ! or #) ***
   IF strmid(line,0,6) EQ 'XYDATA' THEN BEGIN
     READF,unit,line
     READF,unit,line
     READF,unit,line
   ENDIF   
   tit=strmid(line,2,78)
   print,' *** Fullprof INSTR format 10 (X,Y,Sigma format with Header lines starting with ! or #) *** '
   sub=PATH+FILENAME
   REPEAT BEGIN
     READF,unit,line
     IF strmid(line,0,1) NE '#' AND strmid(line,0,1) NE '!' THEN BEGIN
       IF N_ELEMENTS(x) LT 1 THEN BEGIN
         data=0.
         x=0.
         err=0.
         xx=x
         y=data
         dy=err
         READS,line,xx,y,dy
       ENDIF ELSE BEGIN
         READS,line,xx,y,dy
         x   = [x,xx]
         data= [data,y]
         err = [err,dy]
       ENDELSE
     ENDIF ELSE PRINT,STRMID(line,2,78)
   ENDREP UNTIL EOF(unit)
   p=FLTARR(40)
   par_txt=STRARR(40)
   mon=0.
 ENDIF ELSE IF strmid(line,0,5) EQ 'D1A5 ' THEN BEGIN ; *** Fullprof INSTR format 5 (general data format) ***
    IF strmid(line,0,9) NE 'D1A5 D1A6' THEN ff=1 ELSE ff=0
    print,' *** Fullprof INSTR format 5 (general data format) *** '
    READF,unit,line
    tit=STRCOMPRESS(line)+' '+PATH+FILENAME
    tit=tit+STRCOMPRESS(line)
    READF,unit,line
    sub=STRCOMPRESS(line)
    READF,unit,line
    line=line+' 0 0 0 0 0 0'
    nd =1600
    tem=300.
    wav=1.3
    typ=1 
    mon=100000.
    raw=100000.
    READS,line,nd,tem,wav,typ,mon,raw
    IF ff eq 1 THEN nd=(nd/10)*10 
    READF,unit,line
    step=0.1
    start=-2.2
    stop=157.7
    READS,line,start,step,stop
    x=findgen(nd)*step+start
    data=fltarr(nd)
    READF,unit,data
    err=fltarr(nd)
    READF,unit,err
    p=FLTARR(40)
    p(12)=tem
    p(13)=start
    p(30)=raw
    p(33)=wav
    par_txt=STRARR(40)
    par_txt(12)='Sample Temperature      '
    par_txt(13)='2*Theta/deg.            '
    par_txt(30)='Original Monitor Counts '
    par_txt(33)='Wavelength / Angstroem  '
  ENDIF ELSE  BEGIN
   ; The line should contain only numbers, points, hyphens and blanks!
   test=STRCOMPRESS(line,/REMOVE_ALL)
   test=STR_SEP(test,'.')
   new=''
   FOR i=0,N_ELEMENTS(test)-1 DO new=new+test(i)
   test=new
   test=STR_SEP(test,'-')
   new=''
   FOR i=0,N_ELEMENTS(test)-1 DO new=new+test(i)
   test=new
   FOR j=0,9 DO BEGIN
      test=STR_SEP(test,STRCOMPRESS(j,/REMOVE_ALL))
      new=''
      FOR i=0,N_ELEMENTS(test)-1 DO new=new+test(i)
      test=new
   ENDFOR
  IF strlen(test) EQ 0 THEN BEGIN ; *** Fullprof INSTR format ... (*.dat) ***
    tit=line
    print,' *** Fullprof INSTR format 1 (D1A/D2B - original Rietveld-Hewat format) *** '
    sub=PATH+FILENAME
    line=line+' 0 0 0 0 0 0 0 '
    bid=100
    step=0.1
    start=-2.2
    stop=157.7
    mon=100000.
    READS,line,start,step,stop
    nd=ROUND((stop-start)/step)
    x=findgen(nd)*step+start
    datall=long(intarr(2,nd))
    readf, unit, datall, format = '(10(I2, I6))'      
    data=fltarr(nd)+1.
    data=data*datall(1,*)
    err=fltarr(nd)+1.
    err=err*sqrt(data)/sqrt((datall(0,*)>.25))
    p=FLTARR(40)
    par_txt=STRARR(40)
    p(13)=start
    par_txt=STRARR(40)
    par_txt(13)='2*Theta/deg.            '
   ENDIF ELSE BEGIN  ; *** Fullprof INSTR format ... (*.ill) ***
    p=FLTARR(40)
    par_txt=STRARR(40)
    tit=line
    print,' *** Fullprof INSTR format 6 (D1A/D2B/ILL standard format created by sumd2b/d1a) *** '
    sub=PATH+FILENAME
    READF,unit,line
    bid=100
    step=0.1
    start=-2.2
    stop=157.7
    mon=100000.
    READS,line,bid,bid,step
    READF,unit,line
    READS,line,start
    p(13)=start
    par_txt(13)='2*Theta/deg.            '
    READF,unit,line
    bid=0.
    SP=0.
    Treg=0.
    Tsamp=0.
    READS,line,mon,bid,SP,Treg,Tsamp
    p(10)=SP
    p(11)=Treg
    p(12)=Tsamp
    par_txt(10)='Set Point/K             '
    par_txt(11)='Regulation Temperature/K'
    par_txt(12)='Sample Temperature/K    '
    READF,unit,line
    datall=long(intarr(2,10))
    dummy=' 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0'
    WHILE STRPOS(line,'   -1000') NE 0 DO BEGIN
      READS,line+dummy,datall, format = '(10(I2, I6))'
      IF N_ELEMENTS(data) LE 1 THEN BEGIN
        data=REFORM(datall(1,*),10)
        err= REFORM(sqrt(datall(1,*))/sqrt((datall(0,*)>.25)),10)
      ENDIF ELSE BEGIN
        data=[data,REFORM(datall(1,*),10)]
        err= [err, REFORM(sqrt(datall(1,*))/sqrt((datall(0,*)>.25)),10)]
      ENDELSE
      READF,unit,line     
    ENDWHILE   
    x=findgen(N_ELEMENTS(data))*step+start
   ENDELSE
  ENDELSE
      STATUS=0							;Status is ok
;     ********
      DATP={X:      x,    $					;Pass those variables which were 
            W_TIT:  tit,    $ 				;read-in into the DATP structure
            OTHER_TIT:  sub,    $ 				;read-in into the DATP structure
	           X_TIT:  '2theta',    $                   
	           Y_TIT:  'counts',    $                   
            E:      err,        $
            P:      p,        $
            PAR_TXT: PAR_TXT,        $
            N:      mon   }
;     **********************  					
	    
 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:
 
 RETURN, DATA							;Return the data values
;************

 END
PRO rdmon,monitor,cyc=cyc

take_datp,datp
unit=1
unittxt='s '
lambda =P_LAMBDA()
IF KEYWORD_SET(cyc) THEN cyc=ROUND(cyc) ELSE BEGIN
  OPENR,in,lambda+'/CALIBRATION/last.cyc',/get_lun
  READF,in,cyc
  CLOSE,in
ENDELSE
filename=lambda+'/MONITOR/'+STRCOMPRESS(STRING(LONG(cyc)), /REMOVE_ALL)+'.mon'
  OPENR,in,filename,/get_lun
  READF,in,n0,n1,refday,elements,unit
		n0=LONG(n0)
		n1=LONG(n1)
		refday=LONG(refday)
		elements=LONG(elements)
		unit=LONG(unit)
  IF unit EQ 7*86400 THEN   unittxt='w '
  IF unit EQ 86400   THEN 	 unittxt='d '
  IF unit EQ 3600    THEN 	 unittxt='h '
		IF unit EQ 60      THEN			unittxt='mn'
  x=fltarr(elements)

help,x
  e=fltarr(elements)
	 monitor=lonarr(elements)
	 y=intarr(elements)
	 n=lonarr(elements)
  READF,in,x,monitor,e,n,y
  CLOSE,in
  CALDAT,refday,MON,DD,YY
  since=STRCOMPRESS(STRING(DD),/remove_all)+'/'+STRCOMPRESS(STRING(MON),/remove_all)+'/'+$
		      STRCOMPRESS(STRING(YY),/remove_all)
  PRINT,'First Day of Cycle',cyc,':',since
mod_datp,datp,'par_txt',['First Numor:  ','Last Numor:   ']
mod_datp,datp,'p',[n0,n1]
mod_datp,datp,'e',e
mod_datp,datp,'n',n
mod_datp,datp,'y',y
mod_datp,datp,'x',x
help,x
help,datp
help,datp.x
mod_datp,datp,'w_tit','Monitor/time for Cycle'+STRING(cyc)
mod_datp,datp,'other_tit','Numors from'+STRING(n0)+' to'+STRING(n1)
mod_datp,datp,'y_tit','cnt/sec'
mod_datp,datp,'x_tit','time/'+unittxt+' since '+since
give_datp,datp
end
function rdspe, INST , PATH , FILENAME , STATUS , DATP
;******* *****
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.
;**		  if FILENAME(1) exists,  this is the requested image number in the file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.

 common c_rdid , dzap, pzap, pzip ,pzup

 DATA  =0
 UNIT  =-1
 STATUS=11
 CATCH,stat &	IF stat ne 0 then begin print,!err_string
 		IF unit gt 0 THEN FREE_LUN,unit & RETURN, DATA & endif
 IF n_elements(pzup) eq 0 THEN pzup=""				;Check sub-directory & filename
 MYFILE=FILENAME
 MYPATH=PATH
 abc   =0
 dvd   =sys_dep("DIVIDER")
 IF strpos(strlowcase(MYFILE), '.spe')  ge 0 THEN BEGIN
 			  IF  strpos(MYFILE,'-') eq 2 then $
			  IF rstrpos(MYFILE,'-') eq 5 then $
					     MYPATH=MYPATH+strmid(MYFILE,0,8)+dvd
 ENDIF ELSE		  IF pzup ne "" THEN BEGIN  ON_IOERROR,misfix
					     MYPATH=MYPATH+strmid(pzup,0,8)  +dvd
					     abc=fix(MYFILE)  & tmp=strtrim(string(abc),2)
					     if abc lt 100 then tmp= '0'+tmp
					     if abc lt  10 then tmp= '0'+tmp
					     MYFILE=pzup+tmp+'.spe' &  misfix: & ENDIF
 ON_IOERROR, no_file
 OPENR,unit, MYPATH+MYFILE,/get_lun				;Open the data file

      STATUS=13
      ON_IOERROR, read_err
      IF !version.os_family eq 'unix' then swap=1 else swap=0
      HEADER =BYTARR(4100)
      READU,unit,HEADER						;Read the header

	nx = fix (header, 42)	& if swap then BYTEORDER,nx,/sswap
	ny = fix (header, 656)	& if swap then BYTEORDER,ny,/sswap
	nf = long(header, 1446) & if swap then BYTEORDER,nf,/lswap & nf = nf>1
	ty = fix (header, 108)	& if swap then BYTEORDER,ty,/sswap
	case ty of
        0: DATA = fltarr(nx, ny, nf)
        1: DATA = lonarr(nx, ny, nf)
        2: DATA = lonarr(nx, ny, nf)
        3: DATA = intarr(nx, ny, nf)
        else:
	endcase
	READU,unit,DATA & DATA=reform(DATA)			;Read the data

      IF swap then begin
	    if (ty eq 1) or (ty eq 2) then BYTEORDER,DATA,/lswap
	    if (ty eq 3)              then BYTEORDER,DATA,/sswap ;Swap the bytes
      ENDIF
      ;if (ty eq 3)  then DATA = long(DATA) and 'ffff'x  ;does not have unsigned int

      index=where ( DATA lt 0 ) & DATA =long  ( DATA )
      IF index(0) ge 0 then DATA(index)=65536+DATA(index)

      STATUS=0							;Status is ok
;     ********

;offset = 3000
;xcal = { $
;        offset:         double(header, offset), $
;        factor:         double(header, offset+8), $
;        current_unit:   byte  (header, offset+16), $
;        reserved1:      byte  (header, offset+17), $
;        string1:        byte  (header, offset+18, 40), $
;        reserved2:      byte  (header, offset+58, 40), $
;        calib_valid:    byte  (header, offset+98), $
;        input_unit:     byte  (header, offset+99), $
;        polynom_unit:   byte  (header, offset+100), $
;        polynom_order:  byte  (header, offset+101), $
;        calib_count:    byte  (header, offset+102), $
;        pixel_pos:      double(header, offset+103, 10), $
;        calib_value:    double(header, offset+183, 10), $
;        polynom_coeff:  double(header, offset+263, 6), $
;        laser_position: double(header, offset+311), $
;        reserved3:      byte  (header, offset+319), $
;        new_calib_flag: byte  (header, offset+320), $
;        calib_label:    byte  (header, offset+321, 81), $
;        expansion:      byte  (header, offset+402, 87) $
;}

;offset = 3489
;ycal = { $
;    offset:         double(header, offset), $
;    factor:         double(header, offset+8), $
;    current_unit:   byte  (header, offset+16), $
;    reserved1:      byte  (header, offset+17), $
;    string1:        byte  (header, offset+18, 40), $
;    reserved2:      byte  (header, offset+58, 40), $
;    calib_valid:    byte  (header, offset+98), $
;    input_unit:     byte  (header, offset+99), $
;    polynom_unit:   byte  (header, offset+100), $
;    polynom_order:  byte  (header, offset+101), $
;    calib_count:    byte  (header, offset+102), $
;    pixel_pos:      double(header, offset+103, 10), $
;    calib_value:    double(header, offset+183, 10), $
;    polynom_coeff:  double(header, offset+263, 6), $
;    laser_position: double(header, offset+311), $
;    reserved3:      byte  (header, offset+319), $
;    new_calib_flag: byte  (header, offset+320), $
;    calib_label:    byte  (header, offset+321, 81), $
;    expansion:      byte  (header, offset+402, 87) $
;}
;x_calibration = poly(findgen(nx), xcal.polynom_coeff(0:xcal.polynom_order))
;y_calibration = poly(findgen(ny), ycal.polynom_coeff(0:ycal.polynom_order))
 
;comments= byte  (header, 200, 80, 5) & comments=strtrim(string (comments),2)+' '
;date    = byte  (header, 20 , 10)    & date    = string(date)
;hour    = fix   (header, 30) & if swap then BYTEORDER,hour  ,/sswap
;minute  = fix   (header, 32) & if swap then BYTEORDER,minute,/sswap
;second  = fix   (header, 38) & if swap then BYTEORDER,second,/sswap
;date    = date + ":" + string(hour,   format='(i2.2)') $
;               + ":" + string(minute, format='(i2.2)') $
;               + ":" + string(second, format='(i2.2)')

x_calibration =       indgen(nx)+1
y_calibration =       indgen(ny)+1

offset  = 3566

user    = byte  (header, offset+0  ,10)  & user   =strtrim(string (user),2)
date    = byte  (header, offset+50 ,10)  & date   =strtrim(string (date),2)
time    = byte  (header, offset+60 ,10)  & time   =strtrim(string (time),2)
sample  = byte  (header, offset+70 ,10)  & sample =strtrim(string (sample) ,2)
comment = byte  (header, offset+80 ,50)  & comment=strtrim(string (comment),2)
Diffrac = byte  (header, offset+130)

Collima = byte  (header, offset+131,4 )  & if swap then Collima=reverse(Collima)
Collima = float (Collima,0,1)

Axname  = byte  (header, offset+169,100) & Axname=reform(Axname,10,10)
Axname  = strtrim(string (Axname),2)+' '


Omeg=fltarr(10)
for i=0,9 do begin
Omega   = byte  (header, offset+279+i*4,4 )  & if swap then Omega  =reverse(Omega)
Omega   = float (Omega  ,0,1) & Omeg(i)=Omega
endfor
if omeg(0) ne 0 then ZOB=omeg(0) else ZOB=0.0001

if comment eq "" then comment=MYFILE+' ('+sample+')'

      DATP={X:     x_calibration, X_TIT:'X detector',$
            Y:     y_calibration, Y_TIT:'Y detector',$
	    Z:     ZOB ,$
	    PAR_TXT: ['file number ',Axname  ,'Diffractometer ','Collimator (mm) '] ,$
	    P:       [ abc          , Omeg   , Diffrac         , Collima] ,$
            TIME:  date,$
            W_TIT: comment,$
            other_TIT:  MYFILE+' User:'+user+' Sample:'+sample+' Time:'+date+' '+time}
;     **********************  					

 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:   IF unit lt 0 THEN print,!err_string, string(7b)
 
 RETURN, reverse(DATA,2)					;Return the data values
;************

 END
function rdthresh,fil

OPENR,in,fil,/get_lun
w=fltarr(1600)
readf,in,w
free_lun,in
RETURN,w

END
FUNCTION rdxrin, filename

take_datp,datp
Openr,in,strmid(filename,0,3)+'in.obc',/get_lun
readf,in,first,step,last,steps,bid
steps=round((last-first)/step)+1
x=findgen(steps)*step+first
w1=fltarr(steps)
w2=fltarr(steps)
readf,in,w1
readf,in,w2
close,in
free_lun,in

plot,x,w2,yrange=[0,max(w1)]
plot,x,w1,yrange=[0,max(w1)],/noerase

set_plot,'ps'
device,filename='xrin.ps'
plot,x,w2,yrange=[0,max(w1)],TITLE=filename
plot,x,w1,yrange=[0,max(w1)],/noerase
device,/close
XICUTE,'$lp -dlj1_d20 xrin.ps'

set_plot,'X'
mod_datp,datp,'x',x
mod_datp,datp,'e',SQRT(w1)
give_datp,datp
return,w2
END
; $Id: read_binary.pro,v 1.18 2001/05/22 23:29:17 kschultz Exp $
;
; Copyright (c) 1996-2001, Research Systems, Inc.  All rights reserved.
;       Unauthorized reproduction prohibited.
;+
; NAME:
;       READ_BINARY
;
; PURPOSE:
;       Load contents of a binary file into IDL.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       result = READ_BINARY([file])
;
; INPUTS:
;       FILE: The filename or logical unit number of a file to be read.
;           If a logical unit number is supplied, it must be open
;           on a file for reading. If no FILE argument is supplied,
;           READ_BINARY will call DIALOG_PICKFILE to prompt the user to
;           select a file for reading.
;
; INPUT KEYWORD PARAMETERS:
;       TEMPLATE: A template structure describing the file to be read.
;           A template can be created using BINARY_TEMPLATE.
;
;           Keyword TEMPLATE cannot be used simultaneously with keywords
;           DATA_START, HEADER, DATA_TYPE, DATA_DIMS or ENDIAN.
;
;       DATA_START: Where to begin reading in a file.  This value is
;           as an offset, in bytes, that will be applied to the
;           initial position in the file.  Default is 0.
;
;       DATA_TYPE: IDL typecode of the data to be read.  See
;           documentation for the IDL SIZE command for a listing
;           of typecodes.  Default is 1 (IDL's BYTE typecode).
;
;       DATA_DIMS: A scalar, or array of up to eight elements specifying
;           the size of the data to be read and returned.  For example,
;           DATA_DIMS=[512,512] specifies that a 2D, 512 by 512 array be
;           read and returned.  DATA_DIMS=0 specifies that a single,
;           scalar value be read and returned.  Default is -1, which,
;           if a TEMPLATE is not supplied that specifies otherwise,
;           indicates that READ_BINARY will read to end-of-file and
;           store the result in a 1D array.
;
;       ENDIAN: 'big', 'little' or 'native'.  Specifies the byte ordering
;           of the file to be read.  If the computer running Read_Binary
;           uses byte ordering that is different than that of the file,
;           Read_Binary will swap the order of bytes in multi-byte
;           data types read from the file.  Default: 'native' == perform
;           no byte swapping.
;
; OUTPUTS:
;       Function Read_Binary returns data read from the specified file.
;       If keyword TEMPLATE is used, Read_Binary returns a structure with
;       fields specified by the template.
;
; SIDE EFFECTS:
;       If a logical unit number is given for the file argument, the
;       current position of a file opened for reading on that logical
;       unit number is advanced.
;
; RESTRICTIONS:
;       Note: variables used in this routine are prefixed with "rb_".
;       This is to avoid conflicts with template-specified expressions
;       or field names.  Templates having field names, offset expressions
;       dimension expressions or verify value expressions containing
;       the character sequence "rb_" or "bt_" are not allowed.
;
;       READ_BINARY does not have functionality to read strings, but
;       strings can be read as an arrays of bytes, and then converted
;       via IDL's STRING command.
;
; EXAMPLES:
;
;       To select a file and read all of it as a simple, "raw" vector
;       of bytes...
;
;           result = READ_BINARY()
;
;       To read 149600 bytes from a file, and display as an image...
;
;           datafile = FILEPATH('hurric.dat', SUBDIR=['examples', 'data'])
;           TVSCL, READ_BINARY(datafile, DATA_DIMS=[440, 340])
;
;       or...
;
;           GET_LUN, lun
;           OPENR, lun, FILEPATH('hurric.dat', SUBDIR=['examples', 'data'])
;           TVSCL, REFORM(READ_BINARY(lun), 440, 340)
;           CLOSE, lun
;           FREE_LUN, lun
;
; MODIFICATION HISTORY
;       PCS, 6/1999 - Written.
;
;-
;
@rb_routines

function read_binary, $
    rb_file, $
    template=rb_template, $
    data_start=rb_data_start, $
;   header=rb_header, $
    data_type=rb_data_type, $
    data_dims=rb_data_dims, $
    endian=rb_endian, $
    debug=rb_debug

on_error, 2 ; Return to caller on error.
if keyword_set(rb_debug) then $
    on_error, 0

catch, rb_error_status
if rb_error_status ne 0 then begin
    catch, /cancel
    if keyword_set(rb_free_lun_on_cleanup) then $
        free_lun, rb_lun
    message, !error_state.msg
    end
if keyword_set(rb_debug) then $
    catch, /cancel

if !version.os_family eq 'vms' then $
    message, 'Read_Binary is not supported on VMS.', /noname
;
;Validate keywords.
;
if n_elements(rb_template) gt 0 or arg_present(rb_template) then begin
    if n_elements(rb_data_start) gt 0 then $
        message, $
            'DATA_START and TEMPLATE keywords cannot be used ' + $
                'simultaneously.', $
            /noname
;   if n_elements(rb_header) gt 0 then $
;       message, $
;           'HEADER and TEMPLATE keywords cannot be used ' + $
;               'simultaneously.', $
;           /noname
    if n_elements(rb_data_type) gt 0 then $
        message, $
            'DATA_TYPE and TEMPLATE keywords cannot be used ' + $
                'simultaneously.', $
            /noname
    if n_elements(rb_data_dims) gt 0 then $
        message, $
            'DATA_DIMS and TEMPLATE keywords cannot be used ' + $
                'simultaneously.', $
            /noname
    if n_elements(rb_endian) gt 0 then $
        message, $
            'ENDIAN and TEMPLATE keywords cannot be used ' + $
                'simultaneously.', $
            /noname

    if not rb_template_is_valid(rb_template, msg=rb_msg) then begin
        message, rb_msg[0], /noname
        end
    end

if n_elements(rb_data_start) gt 0 then begin
    if n_elements(rb_data_start) gt 1 then $
        message, 'DATA_START must be a scalar.', /noname
    if not rb_is_integral(rb_data_start) then $
        message, 'DATA_START is not an integer.', /noname
    end

if n_elements(rb_data_type) gt 0 then begin
    if n_elements(rb_data_type) gt 1 then $
        message, 'DATA_TYPE must be a scalar.', /noname
    if not rb_is_integral(rb_data_type) then $
        message, 'DATA_TYPE should be an integer value.', /noname

    case rb_data_type of
        0: message, 'DATA_TYPE is undefined type.', /noname
        1: rb_byte_size = 1   ; byte
        2: rb_byte_size = 2   ; int
        3: rb_byte_size = 4   ; long
        4: rb_byte_size = 4   ; float
        5: rb_byte_size = 8   ; double
        6: rb_byte_size = 8   ; complex
        7: message, $
            'Reading strings via READ_BINARY is not supported. ' + $
                '(Specify an array of bytes instead.)', $
            /noname
        8: message, $
            'Reading strucures via READ_BINARY is not supported.', $
            /noname
        9: rb_byte_size = 16  ; dcomplex
        10: message, $
            'Reading pointers via READ_BINARY is not supported.', $
            /noname
        11: message, $
            'Reading object references via READ_BINARY is not ' + $
                'supported.', $
            /noname
        12: rb_byte_size = 2   ; uint
        13: rb_byte_size = 4   ; ulong
        14: rb_byte_size = 8   ; long64
        15: rb_byte_size = 8   ; ulong64
        else: message, 'DATA_TYPE must be less than 16.', /noname
        endcase
    end

if n_elements(rb_data_dims) gt 0 then begin
    if n_elements(rb_data_dims) gt 8 then $
        message, 'DATA_DIMS must have 8 or less values.', /noname
    if not rb_is_integral(rb_data_dims) then $
        message, 'DATA_DIMS must be integer(s).', /noname
    if rb_data_dims[0] ne -1 then begin ; -1 == use the default
        if min(rb_data_dims) lt 0 then $
            message, 'Invalid DATA_DIMS.', /noname
        end
    end

if n_elements(rb_endian) gt 0 then begin
    if n_elements(rb_endian) gt 1 then $
        message, 'ENDIAN cannot be an array.', /noname
    if size(rb_endian, /tname) ne 'STRING' then $
        message, 'Endian must be a string.', /noname
    if strupcase(rb_endian) ne 'NATIVE' $
    and strupcase(rb_endian) ne 'LITTLE' $
    and strupcase(rb_endian) ne 'BIG' then $
        message, 'ENDIAN must be "native", "little" or "big."', /noname
    end
;
;Obtain a valid file.
;
rb_tname = size(rb_file, /tname)
if rb_tname eq 'UNDEFINED' then begin
    if arg_present(rb_file) then $
        message, 'Filename argument is undefined.', /noname $
    else begin
        rb_file = dialog_pickfile( $
            /must_exist, $
            /read $
            )
        if rb_file eq '' then $
            message, 'No file was selected for reading.', /noname
        rb_tname = 'STRING'
        end
    end

if rb_tname eq 'POINTER' $
or rb_tname eq 'STRUCT' $
or rb_tname eq 'OBJREF' $
or rb_tname eq 'COMPLEX' $
or rb_tname eq 'DCOMPLEX' then $
    message, $
        'First argument must be a file name or a logical unit number.', $
        /noname

if rb_tname eq 'STRING' then begin
    if rb_file eq '' then $
        message, 'The given file name is an empty string.'
    rb_void = findfile(rb_file, count=rb_count)
    if rb_count eq 0 then $
        message, 'Could not find file: ' + rb_file, /noname
    get_lun, rb_lun
    rb_free_lun_on_cleanup = 1b
    openr, rb_lun, rb_file, error=rb_error
    if rb_error ne 0 then $
        message, 'Unable to open ' + rb_file + ' for reading.', /noname
    rb_file_status = fstat(rb_lun)
    end $
else begin
    rb_lun = rb_file
    rb_file_status = fstat(rb_lun)
    case 1 of
        rb_file_status.open eq 0: $
            message, $
                'The supplied Logical Unit has not been Opened.', $
                /noname
        rb_file_status.isatty: $
            message, $
                'The supplied Logical Unit is a terminal ("TTY").', $
                /noname
        rb_file_status.isagui: $
            message, 'The supplied Logical Unit is not a file.', /noname
        rb_file_status.read eq 0: $
            message, $
                'The supplied Logical Unit is not open for read access.', $
                /noname
        else:
        endcase
    end
if rb_file_status.size le 0 then $
    message, 'The file to be read has zero length.', /noname
;
;Obtain a template.
;
if n_elements(rb_template) gt 0 then begin
    rb_template_use = rb_template
    rb_return_structure = 1b
    end $
else begin
;
;   Default template: specify one big byte vector into which the file
;   will be read.
;
    rb_fstat = fstat(rb_lun)
    rb_template_use = { $
        version: 1.0, $
        endian: 'native', $
        fieldcount: 1, $
        typecodes: 1, $ ; byte
        names: 'rb_result', $
        offsets: '>0', $
        numdims: 1, $
        dimensions: strcompress( $
            transpose([rb_fstat.size - rb_fstat.cur_ptr, intarr(7)]) $
            ), $
        reverseflags: transpose(intarr(8)), $
        absoluteflags: 0, $
        returnflags: 1, $
        verifyflags: 0 $
        }
;
;   Override defaults with any pertinant specified keywords.
;
    if n_elements(rb_data_start) gt 0 then begin
        if rb_fstat.size - rb_data_start le 0 then $
            message, 'DATA_START is at or beyond the end of file.', /noname
        rb_template_use.Dimensions[0] = $
            strcompress(rb_fstat.size - rb_data_start, /remove_all)
        rb_template_use.Offsets = $
            strcompress(rb_data_start, /remove_all)
        rb_template_use.absoluteflags = 1
        end

    if n_elements(rb_data_type) gt 0 then begin
        rb_template_use.Typecodes = rb_data_type

        if n_elements(rb_data_start) gt 0 then begin
            rb_template_use.Dimensions[0] = strcompress( $
                ((rb_fstat.size - rb_data_start) / rb_byte_size) > 1, $
                /remove_all $
                )
            end $
        else begin
            rb_template_use.Dimensions[0] = strcompress( $
                (rb_fstat.size / rb_byte_size) > 1, $
                /remove_all $
                )
            end
        end

    if n_elements(rb_data_dims) gt 0 then begin
        if rb_data_dims[0] ne -1 then begin ; -1 == use default.
            rb_template_use.Dimensions = strcompress(rb_data_dims)

            rb_template_use.NumDims = n_elements(rb_data_dims)
            for rb_i=n_elements(rb_data_dims)-1,0,-1 do begin
                if rb_data_dims[rb_i] le 0 then $
                    rb_template_use.NumDims = rb_i
                end
            end
        end

    if n_elements(rb_endian) gt 0 then begin
        rb_template_use.endian = rb_endian
        end

    rb_return_structure = 0b
    end
;
;Template has been obtained and validated. Proceed....
;
rb_varnames = strcompress(rb_template_use.names, /remove_all)
rb_machine_endian = (['BIG', 'LITTLE'])[(byte(1, 0, 2))[0] eq 1b]
for rb_i=0,rb_template_use.fieldcount-1 do begin
;
;   Declare variable.
;
    rb_str = rb_varnames[rb_i]
    if rb_template_use.numdims[rb_i] eq 0 then begin ; Scalar.
        rb_str = rb_str + ' = fix(0, type=rb_template_use.typecodes[rb_i])'
        end $
    else begin ; Array
        rb_str = rb_str $
            + ' = make_array(' $
            + 'dimension=' $
            +   rb_dim_str( $
                    rb_template_use.dimensions[rb_i, *], $
                    rb_template_use.numdims[rb_i] $
                    ) $
            +   ', ' $
            + '/nozero, ' $
            + 'type=rb_template_use.typecodes[rb_i]' $
            + ')'
        end
    if not execute(rb_str, 1) then begin
        print, 'Error executing string: ' + rb_str
        message, !error_state.msg, /noname
        end
;
;   Move to the appropriate file position.
;
    if rb_template_use.absoluteflags[rb_i] eq 1 then begin
        rb_str = 'point_lun, rb_lun, ' $
            + rb_template_use.offsets[rb_i]

        if not execute(rb_str, 1) then begin
            print, 'Error executing string: ' + rb_str
            message, !error_state.msg, /noname
            end
        end $
    else begin
        point_lun, -rb_lun, rb_pos ; Get the current position.
        if strpos(rb_template_use.offsets[rb_i], '>') eq 0 then begin
            rb_str = 'point_lun, rb_lun, rb_pos + ' $
                + strmid(rb_template_use.offsets[rb_i], 1)
            if not execute(rb_str, 1) then begin
                print, 'Error executing string: ' + rb_str
                message, !error_state.msg, /noname
                end
            end $
        else begin
            rb_str = 'point_lun, rb_lun, (rb_pos - ' $
                + strmid(rb_template_use.offsets[rb_i], 1) $
                + ') > 0'
            if not execute(rb_str, 1) then begin
                print, 'Error executing string: ' + rb_str
                message, !error_state.msg, /noname
                end
            end
        end
;
;   Read the declared variable.
;
    rb_str = 'readu, rb_lun, ' + rb_varnames[rb_i]
    if not execute(rb_str, 1) then begin
        print, 'Error executing string: ' + rb_str
        message, !error_state.msg, /noname
        end
;
;   Swap endian-ness.
;
    if rb_template_use.typecodes[rb_i] gt 1 then begin
        if ( $
            strupcase(rb_template_use.endian) eq 'LITTLE' $
            and $
            rb_machine_endian eq 'BIG' $
            ) $
        or ( $
            strupcase(rb_template_use.endian) eq 'BIG' $
            and $
            rb_machine_endian eq 'LITTLE' $
            ) $
        then begin
            rb_str = rb_varnames[rb_i] $
                + ' = swap_endian(' $
                + rb_varnames[rb_i] $
                + ')'
            if not execute(rb_str, 1) then begin
                print, 'Error executing string: ' + rb_str
                message, !error_state.msg, /noname
                end
            end
        end
;
;   Verify the value we read.
;
    if rb_template_use.VerifyFlags[rb_i] then begin
        rb_str = 'rb_verify_val = ' + rb_template_use.verifyvals[rb_i]
        message, /reset
        if not execute(rb_str, 1) then begin
            message, $
                'Could not determine the verification value for field ' $
                    + strupcase(rb_varnames[rb_i]) $
                    + '. ' $
                    + !error_state.msg $ ; e.g. syntax error.
                    + ' ' $
                    + !error_state.sys_msg, $ ; e.g. we ran out of memory.
                /noname
            end
        rb_str = 'rb_test = ' $
            + rb_varnames[rb_i] $
            + ' eq rb_verify_val'
        if not execute(rb_str, 1) then begin
            print, 'Error executing string: ' + rb_str
            message, !error_state.msg, /noname
            end
        if rb_test eq 0 then begin
            message, $
                'Value read from file did not pass verification: ' $
                    + strupcase(rb_varnames[rb_i]) $
                    + ' does not equal ' $
                    + strtrim(rb_template_use.verifyvals[rb_i], 2) $
                    + '.', $
                /noname
            end
        end
;
;   Reverse in the first three dimensions of the variable, if desired.
;   (The IDL REVERSE command can only operate on the first
;   three dimensions of an array.)
;
    for rb_j=0,2<(rb_template_use.NumDims[rb_i]-1) do begin
        if rb_template_use.reverseflags[rb_i, rb_j] eq 1 then begin
            rb_str = rb_varnames[rb_i] $
                + ' = reverse(temporary(' $
                + rb_varnames[rb_i] $
                + '), rb_j + 1)'
            if not execute(rb_str, 1) then begin
                print, 'Error executing string: ' + rb_str
                message, !error_state.msg, /noname
                end
            end
        end
    end
if keyword_set(rb_free_lun_on_cleanup) then $
    free_lun, rb_lun

if rb_return_structure then begin
;
;   Put the fields into a structure.
;
    rb_returns_indx = where(rb_template_use.ReturnFlags ne 0)
    rb_str = 'rb_result = create_struct(' $
        + 'rb_varnames[rb_returns_indx[0]], ' $
        + 'temporary(' + rb_varnames[rb_returns_indx[0]] + ')' $
        + ')'
    if not execute(rb_str, 1) then begin
        print, 'Error executing string: ' + rb_str
        message, !error_state.msg, /noname
        end
    for rb_i=1,n_elements(rb_returns_indx)-1 do begin
        rb_str = 'rb_result = create_struct(' $
            + 'temporary(rb_result), ' $
            + 'rb_varnames[rb_returns_indx[rb_i]], temporary(' $
            + rb_varnames[rb_returns_indx[rb_i]] $
            + '))'
        if not execute(rb_str, 1) then begin
            print, 'Error executing string: ' + rb_str
            message, !error_state.msg, /noname
            end
        end
    end

return, rb_result
end
	PRO read_d17
; Reads D17 data. Called from MICS.PRO
;
;						JRS,RC 26/04/00
@lamp.cbk
@mics.cbk

	iprint=0

	IF (iprint GT 0) THEN PRINT,'read_d17: starting'
	
	ON_IOERROR, error_message
	GET_LUN, ilun

	OPENR, ilun, file_found(0)

	line=''	& num=LONG(0)	& num1=0	& num2=0

	READF, ilun, line
	READF, ilun, num	& numor=num

	PRINT,'Reading run',numor

	READF, ilun, line
	READF, ilun, line
	READF, ilun, line
	inst       = STRMID(line,0,4)
	user       = STRMID(line,4,12)
	READF, ilun, line
	IF(iprint GT 0) THEN BEGIN
		PRINT, 'inst =',inst
		PRINT, 'user =',user
	ENDIF

;------------------------------------
	READF, ilun, num1
	block0=INTARR(num1)
	READF, ilun, block0
	IF (iprint GT 0) THEN PRINT,'Block0 read OK'

;------------------------------------
	READF, ilun, line
	READF, ilun, num1
	READF, ilun, line
	user=STRMID(line,0,10)
	title=STRMID(line,10,39)
	prop=STRMID(line,49,11)
	subt=STRMID(line,60,20)
	IF (iprint GT 0) THEN BEGIN
		PRINT,'user =',user
		PRINT,'title =',title
		PRINT,'prop =',prop
		PRINT,'subt =',subt
	ENDIF
	READF, ilun, line
	READF, ilun, line
	READF, ilun, line
	READF, ilun, line
	READF, ilun, line
	READF, ilun, line
	IF (iprint GT 0) THEN PRINT,'Block1 read OK'
;------------------------------------
	READF, ilun, line
	READF, ilun, num1
	block2=FLTARR(num1)
	READF, ilun, block2
	IF (iprint GT 0) THEN PRINT,'Block2 read OK'

;------------------------------------
	READF, ilun, line
	READF, ilun, num1
	block3=FLTARR(num1)
	READF, ilun, block3
	IF (iprint GT 0) THEN PRINT,'Block3 read OK'

;------------------------------------

	p_buf=FLTARR(npars)

	p_buf(0)=numor 		& par_txt(nwk_select,0) =' 0 Numor ='
	p_buf(1)=block2(94)	& par_txt(nwk_select,1) =' 1 Time Channels ='
	p_buf(2)=block2(97)	& par_txt(nwk_select,2) =' 2 X1 ='
	p_buf(3)=block2(98)	& par_txt(nwk_select,3) =' 3 X2 ='
	p_buf(4)=block2(99)	& par_txt(nwk_select,4) =' 4 Y1 ='
	p_buf(5)=block2(100)	& par_txt(nwk_select,5) =' 5 Y2 ='
	p_buf(6)=block2(95)	& par_txt(nwk_select,6) =' 6 Channel width ='
	p_buf(7)=block2(96)	& par_txt(nwk_select,7) =' 7 Electronic TOF delay ='
	p_buf(8)=block2(101)	& par_txt(nwk_select,8) =' 8 NX ='
	p_buf(9)=block2(102)	& par_txt(nwk_select,9) =' 9 NY ='
	p_buf(10)=block3(40)	& par_txt(nwk_select,10) =' 10 chop 1 speed req ='
	p_buf(11)=block3(41)	& par_txt(nwk_select,11) =' 11 chop 1 phase req ='
	p_buf(12)=block3(42)	& par_txt(nwk_select,12) =' 12 chop 2 speed req ='
	p_buf(13)=block3(43)	& par_txt(nwk_select,13) =' 13 chop 2 phase req ='
	p_buf(14)=block3(44)	& par_txt(nwk_select,14) =' 14 chop 1 speed act ='
	p_buf(15)=block3(45)	& par_txt(nwk_select,15) =' 15 chop 1 phase act ='
	p_buf(16)=block3(46)	& par_txt(nwk_select,16) =' 16 chop 2 speed act ='
	p_buf(17)=block3(47)	& par_txt(nwk_select,17) =' 17 chop 2 phase act ='

	p_buf(18)=45.-(block3(43)-block3(41))	& par_txt(nwk_select,18) =' 18 chop opening req ='
	p_buf(19)=45.-(block3(47)-block3(45))	& par_txt(nwk_select,19) =' 19 chop opening act ='
	p_buf(20)=60./block3(44)		& par_txt(nwk_select,20) =' 20 chop period ='
	p_buf(21)=(285.-p_buf(19))/2.		& par_txt(nwk_select,21) =' 21 chop delay angle ='
	p_buf(22)=(p_buf(21)/360.)*p_buf(20)	& par_txt(nwk_select,22) =' 22 chop delay time ='

	p_buf(23)=block3(15)	& par_txt(nwk_select,23) =' 23 sample-detector distance ='
	p_buf(24)=block3(2)	& par_txt(nwk_select,24) =' 24 sample angle ='
	p_buf(25)=block3(16)	& par_txt(nwk_select,25) =' 25 detector angle ='
	p_buf(26)=block2(2)/10.	& par_txt(nwk_select,26) =' 26 run time ='
	
	IF (iprint GT 0) THEN PRINT,'parameters assigned OK'

;------------------------------------

	READF, ilun, line
	READF, ilun, line
	READF, ilun, line
	READF, ilun, tot

	tsize=long(block2(94))
	xsize=long(block2(98)-block2(97)+1)
	ysize=long(block2(100)-block2(99)+1)

	IF (tot ne ((xsize*ysize*tsize)+tsize)) THEN PRINT,'read_d17: Error in data array dimensions'
	IF (iprint GT 0) THEN BEGIN	
		print,'tsize= ',tsize,' detector size= ',xsize*ysize
		print,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',xsize*ysize*tsize,' tot2= ',tot
	ENDIF

	det=lonarr(ysize,xsize,tsize)
	mon=lonarr(tsize)

	READF, ilun,det,mon

	w_buf=FLTARR(xsize,ysize,tsize)
	FOR i=0,tsize-1 DO w_buf(*,*,i)=ROTATE(det(*,*,i),3) 
	x_buf=INDGEN(xsize)+block2(97)
	y_buf=INDGEN(ysize)+block2(99)
	z_buf=INDGEN(tsize)
	n_buf=mon

	junk= EXECUTE('x'+swk_select+'=x_buf')
	junk= EXECUTE('y'+swk_select+'=y_buf')
	junk= EXECUTE('w'+swk_select+'=w_buf')
	junk= EXECUTE('n'+swk_select+'=n_buf')
	junk= EXECUTE('p'+swk_select+'=p_buf')
       	junk= EXECUTE('z'+swk_select+'=z_buf')


	w_tit    (nwk_select) = strtrim(subt,2)
	other_tit(nwk_select) = 'D17B '+strtrim(user,2)+' '+strtrim(title,2)
 	x_tit    (nwk_select) = 'X pixels'
	y_tit    (nwk_select) = 'Y pixels'
	z_tit    (nwk_select) = 'Time channels'
	
	head_tit(nwk_select,0) = subt
	head_tit(nwk_select,1) = title
	head_tit(nwk_select,2) = 'D17B'
	head_tit(nwk_select,3) = STRING(numor)
	head_tit(nwk_select,4) = ''
	head_tit(nwk_select,5) = ''
	head_tit(nwk_select,6) = x_tit(nwk_select)
	head_tit(nwk_select,7) = y_tit(nwk_select)
	head_tit(nwk_select,8) = z_tit(nwk_select)
	head_tit(nwk_select,9) = ''

	GOTO, end_read_d17

error_message:
	PRINT,'Input/Output error encountered in read_d17'

end_read_d17:
	FREE_LUN, ilun

	IF (iprint GT 0) THEN PRINT,'read_d17: finished'

	return
	end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO read_d7_96, cyc, numor, w_out1

; Reads D7 data written using incorrect formatting during cycles
; 962-695, and less than numor #9583
; user must input cycle, numor and workspace (eg. read_d7_96, 965, 9502, w1) 
;
;							JRS 4/5/00
;-------------------------------------------------------------------------------
;*******************************************************************************

@lamp.cbk

	iprint=0

	TAKE_W, w_out1, W=inw

	datasource=0	; 0 => take data from appropriate counters
			; 1 => take data from hytec counters always
			; 2 => take data from tof counters always

	IF (iprint GT 0) THEN PRINT,'read_d7_96: starting'
	
	ON_IOERROR, error_message
	GET_LUN, ilun

	IF (cyc LT 962 OR cyc GT 965) THEN GOTO, error2
	IF (cyc EQ 965 AND numor GT 9583) THEN GOTO, error2	

	pthv='/usr/illdata/'+STRTRIM(STRING(cyc),2)+'/d7/'
	filename='00'+STRTRIM(STRING(numor),2)
	form=findfile(pthv+FILENAME+'.Z',count=cprs)
	IF cprs GT 0  THEN BEGIN
		IF pthv NE '' THEN bid=sys_dep('COPY',filename+'.Z',pthv) ELSE cprs=0
		bid=sys_dep('UN_Z',filename+'.Z')       &   pthv=''
	ENDIF
	file_found=pthv+filename

	OPENR, ilun, file_found

	line=''	& num=LONG(0)	& num1=0	& num2=0

	READF, ilun, line
	READF, ilun, num	& numor=num

	PRINT,'Reading run '+STRTRIM(STRING(numor),2)+' into w'+STRTRIM(STRING(inw),2)

	READF, ilun, line
	READF, ilun, line
	line=line+' -1'		& READS, line, num1, num2

;     -------------------------------
;     READ HEADER & PARAMETERS BLOCKS
;     -------------------------------
	num3=LONG(0)	& num4=LONG(0)
	IF (numor GE 100 AND numor LE 7152) THEN BEGIN	; data from cycle 962 (Acet)
		IF (iprint GT 0) THEN PRINT,'Data is from cycle 962'
		FOR i=1,num2 DO READF, ilun, line
		READF, ilun, line
		inst       = STRMID(line,0,4)
		READF, ilun, line
		main_title = STRMID(line,0,71)
		READF, ilun, line
		sub_title  = STRMID(line,0,71)
		READF, ilun, line
		user       = STRMID(line,0,8)
		local_contact=STRMID(line,8,8)
		start_time = STRMID(line,16,18)
		stop_time  = STRMID(line,34,18)
		scan_type  = STRMID(line,52,8)
		pol_mode   = STRMID(line,60,5)
		Time_mode  = STRMID(line,65,6)
	ENDIF ELSE IF (numor GE 100 AND numor LE 9365) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'Data is from cycles 963-964'
; control characters written into character block: some text irretrievable
		READF, ilun, line
		inst       = STRMID(line,0,4)
		user       = STRMID(line,4,8)
		start_time = ''
		stop_time  = ''
		scan_type  = ''
		pol_mode   = ''
		Time_mode  = ''
		FOR i=2,num2 DO READF, ilun, line
		READF, ilun, line
		main_title = STRMID(line,0,71)
		READF, ilun, line
		sub_title  = STRMID(line,0,71)
		READF, ilun, line
		local_contact=''
		IF (iprint GT 0) THEN BEGIN
			PRINT,'inst=',inst
			PRINT,'user=',user
			PRINT,'start_time=',start_time
			PRINT,'stop_time=',stop_time
			PRINT,'scan_type=',scan_type
			PRINT,'pol_mode=',pol_mode
			PRINT,'Time_mode=',Time_mode
			PRINT,'main_title=',main_title
			PRINT,'sub_title=',sub_title
			PRINT,'local_contact=',local_contact
		ENDIF
	ENDIF ELSE BEGIN
		IF (iprint GT 0) THEN PRINT,'Data is from cycle 965-'
		READF, ilun, line
		inst       = STRMID(line,0,4)
		user       = STRMID(line,4,8)
		save_time  = STRMID(line,14,18)
		READF, ilun, line
		READF, ilun, line
		READS, line, num1, num2
		FOR i=1,num2 DO READF, ilun, line
		READF, ilun, line
		main_title=line
		READF, ilun, line
		sub_title=line
		IF (numor GE 9609 AND numor LE 10318) OR $
		   (numor GE 10327 AND numor LE 11062) THEN $
			READF, ilun, line	; error in data format
		READF, ilun, line
		user       = STRMID(line,0,8)
		local_contact=STRMID(line,8,8)
		READF, ilun, line
		start_time = STRMID(line,0,18)
		stop_time  = STRMID(line,20,18)
		scan_type  = STRMID(line,38,9)
		pol_mode   = STRMID(line,47,5)
		Time_mode  = STRMID(line,52,6)
		IF (iprint GT 0) THEN BEGIN
			PRINT,'start_time=',start_time
			PRINT,'stop_time=',stop_time
			PRINT,'scan_type=',scan_type
			PRINT,'pol_mode=',pol_mode
			PRINT,'Time_mode=',Time_mode
		ENDIF
	ENDELSE

	main_title=STRTRIM(main_title,2)
	sub_title=STRTRIM(sub_title,2)

;------------------------------------
	READF, ilun, line
	READF, ilun, num1, num2
	FOR i=1,num2 DO READF, ilun, line
	block0=INTARR(num1)
	READF, ilun, block0
	IF (iprint GT 0) THEN PRINT,'Block0 read OK'
;------------------------------------
	READF, ilun, line
	READF, ilun, num1, num2
	FOR i=1,num2 DO READF, ilun, line
	block1=FLTARR(num1)
	READF, ilun, block1
	IF (iprint GT 0) THEN PRINT,'Block1 read OK'
;------------------------------------	
	READF, ilun, line
	READF, ilun, num1, num2
	FOR i=1,num2 DO READF, ilun, line
	block2=FLTARR(num1)
	READF, ilun, block2
	IF (iprint GT 0) THEN PRINT,'Block2 read OK'
;------------------------------------
	READF, ilun, line
	READF, ilun, num1, num2
	FOR i=1,num2 DO READF, ilun, line
	nsp_hytec=num1
	nph_hytec=num1/64
	c_hytec=FLTARR(nsp_hytec)
	READF, ilun, c_hytec
	IF (iprint GT 0) THEN BEGIN
		PRINT,'nsp_hytec=',nsp_hytec
		PRINT,'nph_hytec=',nph_hytec
		PRINT,'c_hytec read OK'
	ENDIF
;------------------------------------
	READF, ilun, line
	READF, ilun, num1, num2, num3, num4

	nspectra=64
	IF (num3 EQ 1) THEN TOFformat=0 ELSE TOFformat=1

	IF (NOT TOFformat AND datasource EQ 0) THEN BEGIN	; no TOF
		IF (iprint GT 0) THEN PRINT,'non-TOF data'
		TOF=0
		READF, ilun, line
		READF, ilun, num1
		nsp_tof=num1
		nph_tof=num1/nspectra
		nchannels=1
		c_tof=LONARR(nsp_tof)
		READF, ilun, c_tof
	ENDIF ELSE IF (datasource EQ 1) THEN TOF=0 $
	ELSE BEGIN	; with TOF
		IF (iprint GT 0) THEN PRINT,'TOF data'

		nspectra=64

		TOF=1
		nsp_tof=num3
		nph_tof=num3/nspectra
		nchannels=FIX(block1(2))
		c_tof=LONARR(nchannels,nsp_tof)
		temp=LONARR(nchannels)
		IF (iprint GT 0) THEN PRINT,'nsp=',nsp_tof,' nph=',nph_tof,' nchannels=',nchannels
		FOR ispec=0,nsp_tof-1 DO BEGIN
			IF (iprint GT 0) THEN PRINT,'ispec=',ispec
			READF, ilun, line
			READF, ilun, num1
			IF (num1 NE nchannels) THEN PRINT,'Error 1: ispec=',ispec,' num1=',num1 $
			ELSE BEGIN
			  READF, ilun, temp
			  c_tof(*,ispec)=temp
			  IF (ispec NE nsp_tof-1) THEN BEGIN
			    READF, ilun, line
			    READF, ilun, line
			  ENDIF
			ENDELSE
		ENDFOR
	ENDELSE
	IF (iprint GT 0) THEN PRINT,'Data read OK from ', nspectra, 'detectors'

;------------------------------------

	n_buf=FLTARR(4,7)	; first line is zeros except for n(0,0)
	IF (numor LE 7043 AND numor GE 100) THEN BEGIN
		n_buf(0,1)=block2(8)		; Time      Z up-up    
		n_buf(0,2)=block2(12)	 	; Time      Z up-down
		n_buf(0,3)=block2(16)   	; Time      X up-up    
		n_buf(0,4)=block2(20)     	; Time      X up-down
		n_buf(0,5)=block2(24)		; Time      Y up-up 
		n_buf(0,6)=block2(28)		; Time      Y up-down
		n_buf(1,1)=block2(10)    	; Monitor 1 Z up-up
		n_buf(1,2)=block2(14) 		; Monitor 1 Z up-down 
		n_buf(1,3)=block2(18) 		; Monitor 1 X up-up
		n_buf(1,4)=block2(22)		; Monitor 1 X up-down
		n_buf(1,5)=block2(26)		; Monitor 1 Y up-up 
		n_buf(1,6)=block2(30)		; Monitor 1 Y up-down
		n_buf(2,1)=block2(11)    	; Monitor 2 Z up-up
		n_buf(2,2)=block2(15)	 	; Monitor 2 Z up-down 
		n_buf(2,3)=block2(19) 		; Monitor 2 X up-up
		n_buf(2,4)=block2(23)		; Monitor 2 X up-down
		n_buf(2,5)=block2(27)		; Monitor 2 Y up-up 
		n_buf(2,6)=block2(31)		; Monitor 2 Y up-down
		n_buf(3,1)=block2(9)		; Handshake Z up-up
		n_buf(3,2)=block2(13)		; Handshake Z up-down
		n_buf(3,3)=block2(17)		; Handshake X up-up
		n_buf(3,4)=block2(21)		; Handshake X up-down
		n_buf(3,5)=block2(25)		; Handshake Y up-up
		n_buf(3,6)=block2(29)		; Handshake Y up-down
	ENDIF ELSE BEGIN
		n_buf(0,1)=block2(13)		; Time      Z up-up    
		n_buf(0,2)=block2(22)	 	; Time      Z up-down
		n_buf(0,3)=block2(31)   	; Time      X up-up    
		n_buf(0,4)=block2(40)     	; Time      X up-down
		n_buf(0,5)=block2(49)		; Time      Y up-up 
		n_buf(0,6)=block2(58)		; Time      Y up-down
		n_buf(1,1)=block2(15)    	; Monitor 1 Z up-up
		n_buf(1,2)=block2(24) 		; Monitor 1 Z up-down 
		n_buf(1,3)=block2(33) 		; Monitor 1 X up-up
		n_buf(1,4)=block2(42)		; Monitor 1 X up-down
		n_buf(1,5)=block2(51)		; Monitor 1 Y up-up 
		n_buf(1,6)=block2(60)		; Monitor 1 Y up-down
		n_buf(2,1)=block2(16)    	; Monitor 2 Z up-up
		n_buf(2,2)=block2(25)	 	; Monitor 2 Z up-down 
		n_buf(2,3)=block2(34) 		; Monitor 2 X up-up
		n_buf(2,4)=block2(43)		; Monitor 2 X up-down
		n_buf(2,5)=block2(52)		; Monitor 2 Y up-up 
		n_buf(2,6)=block2(61)		; Monitor 2 Y up-down
		n_buf(3,1)=block2(14)		; Handshake Z up-up
		n_buf(3,2)=block2(23)		; Handshake Z up-down
		n_buf(3,3)=block2(32)		; Handshake X up-up
		n_buf(3,4)=block2(41)		; Handshake X up-down
		n_buf(3,5)=block2(50)		; Handshake Y up-up
		n_buf(3,6)=block2(59)		; Handshake Y up-down
	ENDELSE
	n_buf(*,0)=0.	; & n_buf(0,0)=n_buf(0,1)/100.	; Z up-up time in secs
	IF (iprint GT 0) THEN PRINT,'monitor assigned OK'
	IF (n_buf(0,2) EQ 0.) THEN BEGIN
		ratioZ=0.	& dratioZ=0.
		ratioX=0.	& dratioX=0.
		ratioY=0.	& dratioY=0.
	ENDIF ELSE IF (n_buf(0,3) EQ 0.) THEN BEGIN
		IF (n_buf(2,2) EQ 0.) THEN BEGIN
			ratioZ=999. & dratioZ=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,1)	& m1_1=n_buf(1,2)
			m2_0=n_buf(2,1)	& m2_1=n_buf(2,2)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioZ=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioZ=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
		ratioX=0. & dratioX=0.
		ratioY=0. & dratioY=0.
	ENDIF ELSE BEGIN
		IF (n_buf(2,2) EQ 0.) THEN BEGIN
			ratioZ=999.	& dratioZ=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,1)	& m1_1=n_buf(1,2)
			m2_0=n_buf(2,1)	& m2_1=n_buf(2,2)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioZ=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioZ=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
		IF (n_buf(2,4) EQ 0.) THEN BEGIN
			ratioX=999.	& dratioX=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,3)	& m1_1=n_buf(1,4)
			m2_0=n_buf(2,3)	& m2_1=n_buf(2,4)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioX=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioX=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
		IF (n_buf(2,6) EQ 0.) THEN BEGIN
			ratioY=999.	& dratioY=0.
		ENDIF ELSE BEGIN
			m1_0=n_buf(1,5)	& m1_1=n_buf(1,6)
			m2_0=n_buf(2,5)	& m2_1=n_buf(2,6)
			nonflip=m2_0/m1_0	& flip=m2_1/m1_1
			ratioY=nonflip/flip
			dnonflip=SQRT(m2_0/m1_0^2+m2_0^2/m1_0^3)
			dflip=SQRT(m2_1/m1_1^2+m2_1^2/m1_1^3)
			dratioY=SQRT((dnonflip/flip)^2+(nonflip*dflip/flip^2)^2)
		ENDELSE
	ENDELSE
	IF (iprint GT 0) THEN PRINT,'Flipping Ratios OK'

	h1=LONG(0)	& m1=LONG(0)	& s1=LONG(0)
	h2=LONG(0)	& m2=LONG(0)	& s2=LONG(0)
	IF (start_time NE '' AND stop_time NE '') THEN BEGIN
		READS, start_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', da1, h1, m1, s1
		READS, stop_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', da2, h2, m2, s2
		time1=FLOAT(3600*h1+60*m1+s1)/3600.+24.*da1
		time2=FLOAT(3600*h2+60*m2+s2)/3600.+24.*da2
		IF (h2 GE h1) THEN run_time=FLOAT(3600*(h2-h1)+60*(m2-m1)+(s2-s1)) $
			ELSE run_time=FLOAT(3600*(24+h2-h1)+60*(m2-m1)+(s2-s1))
	ENDIF ELSE BEGIN
		time1=0.
		time2=0.
		run_time=0.
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'run time OK'

	nphases=nph_hytec
	TOFfactor=FLTARR(6)	& TOFfactor(*)=1.
	IF (TOF EQ 0) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'TOF=0'
		IF (datasource EQ 2) THEN w_buf=reform(c_tof,nspectra,nphases) $
			ELSE w_buf=reform(c_hytec,nspectra,nphases)
		x_buf=block1(6:69)
		IF (nphases EQ 1) THEN y_buf=LONG(numor) $
				    ELSE y_buf=INDGEN(nphases)
		z_buf=x_buf
		chel=0.
		norm=1.
	ENDIF ELSE BEGIN
		IF (iprint GT 0) THEN PRINT,'TOF=1'
		w_buf=c_tof
		x_buf=INDGEN(nchannels)+1
		y_buf=FLTARR(nsp_tof)
		FOR iph=0,nph_tof-1 DO y_buf(iph*nspectra:iph*nspectra+63)=block1(6:69)
		z_buf=y_buf
		w_tmp=LONARR(nchannels)	& w_tmp(*)=0
		FOR i=1,nsp_tof,2 DO w_tmp(*)=w_tmp(*)+w_buf(*,i)
		Imax=MAX(w_tmp,ichel)
		chel=FLOAT(ichel)
		FOR iphase=0,nphases-1 DO BEGIN
			sumh=c_hytec(64*iphase)
			sumt=TOTAL(FLOAT(c_tof(*,nspectra*iphase)))
			IF (sumh EQ 0) THEN sumh=sumt
			TOFfactor(iphase)=sumt/sumh
		ENDFOR
		IF (iprint GT 0) THEN PRINT,'sumh=',sumh,' sumt=',sumt
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'scattering angles and chel OK'

	lambda=block1(0)
	IF (lambda GT 3.5) AND (lambda LE 5.0) THEN lambda=4.838 $
	ELSE IF (lambda LT 3.5) THEN lambda=3.02
	IF (lambda GT 5.0) THEN lambda=5.98
	IF (numor GE 8434 AND numor LE 8573) THEN lambda=3.02
	IF (iprint GT 0) THEN PRINT,'lambda=',lambda
	IF (iprint GT 0) THEN PRINT,'npars=',49

	p_buf=FLTARR(49)
	p_buf(0)=numor		& par_txt(inw,0) =' 0 Numor                   ='
	p_buf(1)=nspectra	& par_txt(inw,1) =' 1 Number of spectra       ='
	p_buf(2)=nph_hytec	& par_txt(inw,2) =' 2 Number of phases        ='
	p_buf(3)=1.		& par_txt(inw,3) =' 3 Number of runs          ='
	p_buf(4)=lambda		& par_txt(inw,4) =' 4 Wavelength (A)          ='
	p_buf(5)=block1(1)	& par_txt(inw,5) =' 5 Chopper Speed (rpm)     ='
	p_buf(6)=block1(2)	& par_txt(inw,6) =' 6 Number of Time Channels ='
	p_buf(7)=block1(3)	& par_txt(inw,7) =' 7 Channel Width (mcs)     ='
	p_buf(8)=TOF		& par_txt(inw,8) =' 8 TOF mode (0/1)          ='
	p_buf(9)=chel		& par_txt(inw,9) =' 9 Elastic Peak Channel    ='
	p_buf(10)=block2(0)	& par_txt(inw,10)='10 Set-pt Temp Start       ='
	p_buf(11)=block2(3)	& par_txt(inw,11)='11 Set-pt Temp End         ='
	p_buf(12)=block2(1)	& par_txt(inw,12)='12 Regul Temp Start        ='
	p_buf(13)=block2(4)	& par_txt(inw,13)='13 Regul Temp End          ='
	p_buf(14)=block2(2)	& par_txt(inw,14)='14 Sample Temp Start       ='
	p_buf(15)=block2(5)	& par_txt(inw,15)='15 Sample Temp End         ='
	p_buf(16)=block1(76)	& par_txt(inw,16)='16 Bank1 Position          ='
	p_buf(17)=block1(77)	& par_txt(inw,17)='17 Bank2 Position          ='
	p_buf(18)=block1(78)	& par_txt(inw,18)='18 Bank3 Position          ='
	p_buf(19)=block1(79)	& par_txt(inw,19)='19 Bank4 Position          ='
	p_buf(20)=block1(80)	& par_txt(inw,20)='20 Lower Sample Rotation   ='
	p_buf(21)=block1(82)	& par_txt(inw,21)='21 Upper Sample Rotation   ='
	p_buf(22)=block2(17)	& par_txt(inw,22)='22 Z Flipper Current       ='
	p_buf(23)=block2(18)	& par_txt(inw,23)='23 Z Correction Current    ='
	p_buf(24)=block2(35)	& par_txt(inw,24)='24 X Flipper Current       ='
	p_buf(25)=block2(36)	& par_txt(inw,25)='25 X Correction Current    ='
	p_buf(26)=block2(53)	& par_txt(inw,26)='26 Y Flipper Current       ='
	p_buf(27)=block2(54)	& par_txt(inw,27)='27 Y Correction Current    ='
	p_buf(28)=ratioZ	& par_txt(inw,28)='28 Z Flipping ratio        ='
	p_buf(29)=ratioX	& par_txt(inw,29)='29 X Flipping ratio        ='
	p_buf(30)=ratioY	& par_txt(inw,30)='30 Y Flipping ratio        ='
	p_buf(31)=run_time	& par_txt(inw,31)='31 Run Time (seconds)      ='
	p_buf(32)=time1		& par_txt(inw,32)='32 Start time (hours)      ='
	p_buf(33)=time2		& par_txt(inw,33)='33 End Time (hours)        ='
	p_buf(34)=block1(70)	& par_txt(inw,34)='34 Mono1 (psiA)            ='
	p_buf(35)=block1(71)	& par_txt(inw,35)='35 Mono2 (psiB)            ='
	p_buf(36)=block1(72)	& par_txt(inw,36)='36 Mono3 (psiC)            ='
	p_buf(37)=block1(73)	& par_txt(inw,37)='37 Mono4 (thetaA)          ='
	p_buf(38)=block1(74)	& par_txt(inw,38)='38 Mono5 (thetaB)          ='
	p_buf(39)=block1(75)	& par_txt(inw,39)='39 Mono6 (thetaC)          ='
	p_buf(40)=TOFfactor(0)	& par_txt(inw,40)='40 Z  TOFfactor            ='
	p_buf(41)=TOFfactor(1)	& par_txt(inw,41)='41 Z1 TOFfactor            ='
	p_buf(42)=TOFfactor(2)	& par_txt(inw,42)='42 X  TOFfactor            ='
	p_buf(43)=TOFfactor(3)	& par_txt(inw,43)='43 X1 TOFfactor            ='
	p_buf(44)=TOFfactor(4)	& par_txt(inw,44)='44 Y  TOFfactor            ='
	p_buf(45)=TOFfactor(5)	& par_txt(inw,45)='45 Y1 TOFfactor            ='
	p_buf(46)=dratioZ	& par_txt(inw,46)='46 Z dFlipping ratio       ='
	p_buf(47)=dratioX	& par_txt(inw,47)='47 X dFlipping ratio       ='
	p_buf(48)=dratioY	& par_txt(inw,48)='48 Y dFlipping ratio       ='
	
	IF (iprint GT 0) THEN PRINT,'parameters assigned OK'
	
	sti=STRTRIM(STRING(inw),2)	

	junk= EXECUTE('x'+sti+'=x_buf')
	junk= EXECUTE('y'+sti+'=y_buf')
	junk= EXECUTE('w'+sti+'=w_buf')
	junk= EXECUTE('n'+sti+'=n_buf')
	junk= EXECUTE('p'+sti+'=p_buf')
       	junk= EXECUTE('z'+sti+'=z_buf')


	w_tit    (inw) = strtrim(sub_title,2)
	other_tit(inw) = strtrim(main_title,2)
 
	IF (TOF EQ 0) THEN BEGIN
		x_tit(inw) = 'Scattering Angle'
		IF (nphases EQ 1) THEN y_tit(inw)='Counts' $
		ELSE BEGIN
			y_tit(inw)='Phase'
			z_tit(inw)='Counts'
		ENDELSE
	ENDIF ELSE BEGIN
		x_tit(inw) = 'Time Channels'
		y_tit(inw) = 'Scattering Angle'
		z_tit(inw) = 'Counts'
	ENDELSE

	head_tit(inw,0) = sub_title
	head_tit(inw,1) = main_title
	head_tit(inw,2) = inst_value
	head_tit(inw,3) = STRING(numor)
	head_tit(inw,4) = start_time
	head_tit(inw,5) = ''
	head_tit(inw,6) = x_tit(inw)
	head_tit(inw,7) = y_tit(inw)
	head_tit(inw,8) = z_tit(inw)
	head_tit(inw,9) = ''

	GOTO, end_read_d7_96

error_message:
	PRINT,'Input/Output error encountered in read_d7'
	GOTO, end_read_d7_96

error2:
	PRINT,'You should read this data normally'


end_read_d7_96:
	FREE_LUN, ilun
	bid=sys_dep('DELET',filename)

	IF (iprint GT 0) THEN PRINT,'read_d7_96: finished'

	return
	end
;-------------------------------------------------------------------------------
;*******************************************************************************

	PRO read_d7sum, file

; Reads D7 data. Called from monitor.pro, summary.pro and newsummary.pro
; Assumes that data format is new (i.e. same as September 1996) or format 
; of Mompean experiment (November 1995)
;							KHA, 1/5/98
;-------------------------------------------------------------------------------
;*******************************************************************************


COMMON mon,	date, mon1rate, dmon1rate, time1, time2

COMMON mut,	user, local_contact, main_title, sub_title, $
		start_time, run_time, pol_mode, Time_mode, scan_type, $
		nkmes, npmes

	iprint=0

	IF (iprint GT 0) THEN PRINT,'read_d7: starting'
	
	ON_IOERROR, error_message

	ilun=1
	IF (iprint GT 0) THEN PRINT,'Opening ',file
	OPENR, ilun, file

	line=''	& num=LONG(0)	& num1=0	& num2=0

	READF, ilun, line
	READF, ilun, num	& numor=num

;	PRINT,'Reading run',numor

	IF (numor LE 5000) THEN BEGIN

	READF, ilun, line
	READF, ilun, line
	READF, ilun, line
	user=''	& local_contact=''	& main_title=''
	stop_time=''	& scan_type='         '
	nkmes=0	& npmes=0	& run_time=0.
	inst=STRMID(line,0,4)
	sub_title=STRMID(line,4,6)
	start_time=STRMID(line,14,18)
	WHILE (STRMID(line,0,3) NE 'SSS') DO BEGIN
		READF, ilun, line
;		PRINT, line
	ENDWHILE
	READF, ilun, i1, i2, i3, i4
	IF (i2 EQ 0) THEN BEGIN
		Time_mode='NOTOF'
		READF, ilun, line
		READF, ilun, n
		counts=LONARR(n-1)
		READF, ilun, counts
		i=WHERE(counts NE 0,n)
		imax=i(n-1)
		IF (imax LT 80) THEN pol_mode='NOP' $
		ELSE IF (imax LT 160) THEN pol_mode='ZP' $
		ELSE pol_mode='XYZP'
	ENDIF ELSE BEGIN
		Time_mode='TOF'
		IF (i3 EQ 64) THEN pol_mode='NOP' $
		ELSE IF (i3 EQ 128) THEN pol_mode='ZP' $
		ELSE pol_mode='XYZP'
	ENDELSE

	GOTO, end_read_d7

	ENDIF ELSE BEGIN	; Numor > 5000

	READF, ilun, line
	READF, ilun, line
	line=line+' -1'		& READS, line, num1, num2

	IF (num2 LT 0) THEN BEGIN
		PRINT,'Error: Old data format'
		GOTO, end_read_d7
	ENDIF


;     -------------------------------
;     READ HEADER & PARAMETERS BLOCKS
;     -------------------------------
	num3=LONG(0)	& num4=LONG(0)
	IF (numor GE 100 AND numor LE 7152) THEN BEGIN	; data from cycle 962 (Acet)
		IF (iprint GT 0) THEN PRINT,'Data is from cycle 962'
		FOR i=1,num2 DO READF, ilun, line
		READF, ilun, line
		inst       = STRMID(line,0,4)
		READF, ilun, line
		main_title = STRMID(line,0,71)
		READF, ilun, line
		sub_title  = STRMID(line,0,71)
		READF, ilun, line
		user       = STRMID(line,0,8)
		local_contact=STRMID(line,8,8)
		start_time = STRMID(line,16,18)
		stop_time  = STRMID(line,34,18)
		scan_type  = STRMID(line,52,8)
		pol_mode   = STRMID(line,60,5)
		Time_mode  = STRMID(line,65,6)
	ENDIF ELSE IF (numor GE 100 AND numor LE 9365) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'Data is from cycles 963-964'
; control characters written into character block: some text irretrievable
		READF, ilun, line
		inst       = STRMID(line,0,4)
		user       = STRMID(line,4,8)
;		start_time = STRMID(line,14,18)
;		stop_time  = STRMID(line,32,18)
;		scan_type  = STRMID(line,50,8)
;		pol_mode   = STRMID(line,50,6)
;		Time_mode  = STRMID(line,56,5)
		start_time = ''
		stop_time  = ''
		scan_type  = ''
		pol_mode   = ''
		Time_mode  = ''
		FOR i=2,num2 DO READF, ilun, line
		READF, ilun, line
		main_title = STRMID(line,0,71)
		READF, ilun, line
		sub_title  = STRMID(line,0,71)
		READF, ilun, line
;		local_contact=STRMID(line,8,8)
		local_contact=''
		IF (iprint GT 0) THEN BEGIN
			PRINT,'inst=',inst
			PRINT,'user=',user
			PRINT,'start_time=',start_time
			PRINT,'stop_time=',stop_time
			PRINT,'scan_type=',scan_type
			PRINT,'pol_mode=',pol_mode
			PRINT,'Time_mode=',Time_mode
			PRINT,'main_title=',main_title
			PRINT,'sub_title=',sub_title
			PRINT,'local_contact=',local_contact
		ENDIF
	ENDIF ELSE BEGIN
		IF (iprint GT 0) THEN PRINT,'Data is from cycle 965-'
		READF, ilun, line
		inst       = STRMID(line,0,4)
		user       = STRMID(line,4,8)
		save_time  = STRMID(line,14,18)
		READF, ilun, line
		READF, ilun, line
		READS, line, num1, num2
		FOR i=1,num2 DO READF, ilun, line
		READF, ilun, line
		main_title=line
		READF, ilun, line
		sub_title=line
		IF (numor GE 9609 AND numor LE 10318) OR $
		   (numor GE 10327 AND numor LE 11062) THEN $
			READF, ilun, line	; error in data format
		READF, ilun, line
		user       = STRMID(line,0,8)
		local_contact=STRMID(line,8,8)
		READF, ilun, line
		start_time = STRMID(line,0,18)
		stop_time  = STRMID(line,20,18)
		scan_type  = STRMID(line,38,9)
		pol_mode   = STRMID(line,47,5)
		Time_mode  = STRMID(line,52,6)
		IF (iprint GT 0) THEN BEGIN
			PRINT,'start_time=',start_time
			PRINT,'stop_time=',stop_time
			PRINT,'scan_type=',scan_type
			PRINT,'pol_mode=',pol_mode
			PRINT,'Time_mode=',Time_mode
		ENDIF
	ENDELSE

	main_title=STRTRIM(main_title,2)
	sub_title=STRTRIM(sub_title,2)

;------------------------------------
	READF, ilun, line
	READF, ilun, num1, num2
	FOR i=1,num2 DO READF, ilun, line
	block0=INTARR(num1)
	READF, ilun, block0
	IF (iprint GT 0) THEN PRINT,'Block0 read OK'
;------------------------------------
	READF, ilun, line
	READF, ilun, num1, num2
	FOR i=1,num2 DO READF, ilun, line
	block1=FLTARR(num1)
	READF, ilun, block1
	IF (iprint GT 0) THEN PRINT,'Block1 read OK'
;------------------------------------	
	READF, ilun, line
	READF, ilun, num1, num2
	FOR i=1,num2 DO READF, ilun, line
	block2=FLTARR(num1)
	READF, ilun, block2
	IF (iprint GT 0) THEN PRINT,'Block2 read OK'
;------------------------------------

	nkmes=block0(0)
	npmes=block0(1)

	n_buf=FLTARR(4,7)	; first line is zeros except for n(0,0)
	IF (numor LE 7043 AND numor GE 100) THEN BEGIN
		n_buf(0,1)=block2(8)		; Time      Z up-up    
		n_buf(0,2)=block2(12)	 	; Time      Z up-down
		n_buf(0,3)=block2(16)   	; Time      X up-up    
		n_buf(0,4)=block2(20)     	; Time      X up-down
		n_buf(0,5)=block2(24)		; Time      Y up-up 
		n_buf(0,6)=block2(28)		; Time      Y up-down
		n_buf(1,1)=block2(10)    	; Monitor 1 Z up-up
		n_buf(1,2)=block2(14) 		; Monitor 1 Z up-down 
		n_buf(1,3)=block2(18) 		; Monitor 1 X up-up
		n_buf(1,4)=block2(22)		; Monitor 1 X up-down
		n_buf(1,5)=block2(26)		; Monitor 1 Y up-up 
		n_buf(1,6)=block2(30)		; Monitor 1 Y up-down
		n_buf(2,1)=block2(11)    	; Monitor 2 Z up-up
		n_buf(2,2)=block2(15)	 	; Monitor 2 Z up-down 
		n_buf(2,3)=block2(19) 		; Monitor 2 X up-up
		n_buf(2,4)=block2(23)		; Monitor 2 X up-down
		n_buf(2,5)=block2(27)		; Monitor 2 Y up-up 
		n_buf(2,6)=block2(31)		; Monitor 2 Y up-down
		n_buf(3,1)=block2(9)		; Handshake Z up-up
		n_buf(3,2)=block2(13)		; Handshake Z up-down
		n_buf(3,3)=block2(17)		; Handshake X up-up
		n_buf(3,4)=block2(21)		; Handshake X up-down
		n_buf(3,5)=block2(25)		; Handshake Y up-up
		n_buf(3,6)=block2(29)		; Handshake Y up-down
	ENDIF ELSE BEGIN
		n_buf(0,1)=block2(13)		; Time      Z up-up    
		n_buf(0,2)=block2(22)	 	; Time      Z up-down
		n_buf(0,3)=block2(31)   	; Time      X up-up    
		n_buf(0,4)=block2(40)     	; Time      X up-down
		n_buf(0,5)=block2(49)		; Time      Y up-up 
		n_buf(0,6)=block2(58)		; Time      Y up-down
		n_buf(1,1)=block2(15)    	; Monitor 1 Z up-up
		n_buf(1,2)=block2(24) 		; Monitor 1 Z up-down 
		n_buf(1,3)=block2(33) 		; Monitor 1 X up-up
		n_buf(1,4)=block2(42)		; Monitor 1 X up-down
		n_buf(1,5)=block2(51)		; Monitor 1 Y up-up 
		n_buf(1,6)=block2(60)		; Monitor 1 Y up-down
		n_buf(2,1)=block2(16)    	; Monitor 2 Z up-up
		n_buf(2,2)=block2(25)	 	; Monitor 2 Z up-down 
		n_buf(2,3)=block2(34) 		; Monitor 2 X up-up
		n_buf(2,4)=block2(43)		; Monitor 2 X up-down
		n_buf(2,5)=block2(52)		; Monitor 2 Y up-up 
		n_buf(2,6)=block2(61)		; Monitor 2 Y up-down
		n_buf(3,1)=block2(14)		; Handshake Z up-up
		n_buf(3,2)=block2(23)		; Handshake Z up-down
		n_buf(3,3)=block2(32)		; Handshake X up-up
		n_buf(3,4)=block2(41)		; Handshake X up-down
		n_buf(3,5)=block2(50)		; Handshake Y up-up
		n_buf(3,6)=block2(59)		; Handshake Y up-down
	ENDELSE
	time=n_buf(0,1)	; time Z up-up
	mon1=n_buf(1,1)	; mon1 Z up-up
	mon1rate=mon1*100./time
	dmon1rate=SQRT(mon1)*100./time

	h1=LONG(0)	& m1=LONG(0)	& s1=LONG(0)
	h2=LONG(0)	& m2=LONG(0)	& s2=LONG(0)
	IF (start_time NE '' AND stop_time NE '') THEN BEGIN
		READS, start_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', d1, h1, m1, s1
		READS, stop_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', d2, h2, m2, s2
		time1=FLOAT(3600*h1+60*m1+s1)/3600.+24.*d1
		time2=FLOAT(3600*h2+60*m2+s2)/3600.+24.*d2
		IF (h2 GE h1) THEN run_time=FLOAT(3600*(h2-h1)+60*(m2-m1)+(s2-s1)) $
			ELSE run_time=FLOAT(3600*(24+h2-h1)+60*(m2-m1)+(s2-s1))
	ENDIF ELSE BEGIN
		time1=0.
		time2=0.
		run_time=0.
	ENDELSE
	date=(time1+time2)/48.

	IF (iprint GT 0) THEN PRINT,'run time OK'

	GOTO, end_read_d7

	ENDELSE

error_message:
	PRINT,'Input/Output error encountered in read_d7 while reading from ',file

end_read_d7:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'read_d7: finished'

	return
	end
; *********************************************************************************
; S. Rols August 2001
; for question : srols@anl.gov
; This program reads ascii dcs file derived
; from the dcs_binary2ascii routines written by J. Copley
; N.B: all the experimental parameter were saved ... will read only a few of them
; *********************************************************************************
function read_dcsasc, INST , PATH , FILENAME , STATUS , DATP

 DATA  =0
 STATUS=11	;Handle non-IO errors
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

;** ***********************************
;** newpath and newfile construction **
;** ***********************************
    NEWPATH=PATH
    NEWFILE=FILENAME(0)
    if strlen(NEWFILE) eq 6 then begin
;	Input PATH     is of the form "/........../2001/"
;	Input FILENAME is of the form "MMDDnb"
;	--------------------------------------
	ii=strlen(NEWPATH)
	yy=strmid(NEWPATH,ii-5,4)
	mm=strmid(NEWFILE,0,2)
	dd=strmid(NEWFILE,2,2)
	nb=strmid(NEWFILE,4,2)
	if (mm gt 12) or (dd gt 31) then return,DATA
	NEWPATH=strmid(NEWPATH,0,ii-1)+mm+strmid(NEWPATH,ii-1,1)
	NEWFILE=yy+mm+dd+'_'+nb+'.dcs'
    strrunn=yy+mm+dd+nb
	run_number=float(strrunn)
	rr=findfile(NEWPATH+NEWFILE+'.gz.',count=n)
	if n gt 0 then NEWFILE=NEWFILE+'.gz.'
    endif else begin
    ii=strlen(NEWFILE)
    yy=strmid(NEWFILE,0,4)
	mm=strmid(NEWFILE,4,2)
	dd=strmid(NEWFILE,6,2)
	nb=strmid(NEWFILE,9,2)
	strrunn=yy+mm+dd+nb
	run_number=float(strrunn)
	endelse

;   Open  the data file, use EXECUTE for compatibility with Idl5.2
;   --------------------------------------------------------------
;   ON_IOERROR, no_file
    if strpos(NEWFILE,'.gz') gt 0 then cmps=',/compress' else cmps=''
    unit=-1
    rr=EXECUTE('OPENR,unit, NEWPATH+NEWFILE,/get_lun'+cmps)
    if unit le 0 then return,DATA

;** **********************
;** End of construction ******************************************
;** **********************


      STATUS=13
      ON_IOERROR, read_err
      iunit=unit

;** **************************************
;** Reading in the .asc files and dealing
;** with data and parameter
;** **************************************
twolines=strarr(2)
while (not eof(iunit)) do begin
readf, iunit, twolines
;print, twolines
strname=strcompress(twolines(0),/remove_all) & len0=strlen(strname)-6
strtype=strcompress(twolines(1),/remove_all) & len1=strlen(strtype)-6
;print, strname
;print, strtype
strname=strmid(strname,6,len0)
strtype=strmid(strtype,6,len1)
;print, strname
;print, strtype
; On a lu le nom de la variable dans strname
; On a lu le type de cette variable et on va creer une variable tampon du meme type: vartamp
case strtype of
"scalar": begin
vartamp=0.
end
"matrix": begin
readf,iunit, twolines
twolines=strcompress(twolines,/remove_all)
strrow=twolines(0) & len0=strlen(strrow)-6
strcolumn=twolines(1) & len1=strlen(strcolumn)-9
strrow=strmid(strrow,6,len0)
strcolumn=strmid(strcolumn,9,len1)
nrow=float(strrow) & ncolumn=float(strcolumn)
vartamp=fltarr(nrow,ncolumn)
end
"stringarray": begin
strnumel=strarr(1)
readf, iunit, strnumel
strnumel=strcompress(strnumel,/remove_all) & len0=strlen(strnumel(0))-10
strnumel=strmid(strnumel,10,len0)
nelement=float(strnumel(0))
;print, strnumel
;print, nelement
if (nelement gt 1.) then begin
vartamp=strarr(2*nelement)
endif else begin
strlength=strarr(1)
readf,iunit, strlength
vartamp=strarr(1)
endelse
end
endcase
case strname of
"CH_INPUT": begin ; des frequences de rotation des choppers
readf, iunit,vartamp
w_chop=vartamp(1) & ratio1=vartamp(2)
ratio2=vartamp(3) & ratio3=vartamp(4)
w_aoverlap=vartamp(5)
end
"COMMENTS": begin ; lecture du titre du run
title=''
readf, iunit, vartamp
title=vartamp(0)
end
"DET_DIS" : begin ; lecture de la distance Sample-detector
readf, iunit, vartamp
dist_sd=vartamp
end
"DURATION": begin ; lecture de la duree du run
readf, iunit, vartamp
duration=vartamp
end
"HISTOHIGH": begin ; lecture du moniteur
readf, iunit, vartamp
spec_mon=vartamp(*,3)
end
"HISTODATA": begin ;lecture des donnees
readf, iunit, vartamp
DATA=vartamp
end
"START_DATE": begin ; lecture de la date START
startd=''
readf, iunit, vartamp
startd=vartamp
end
"STOP_DATE": begin ; lecture de la date STOP
stopd=''
readf, iunit, vartamp
stopd=vartamp
end
"CH_WL": begin ; lecture de la long. d'onde incidente
readf, iunit, vartamp
lambda=vartamp
end
"TSDMIN": begin ; lecture du TOF-delay
readf, iunit, vartamp
tof_delay=vartamp
print, 'tof_delay',vartamp,tof_delay
end
"DETSUM": begin ; lecture des moniteurs
readf, iunit, vartamp
mon1=vartamp(915,0)
mon2=vartamp(916,0)
end
else: readf,iunit, vartamp ; on lit pour rien ATTENTION AUX STRING ARRAY !!!
endcase
endwhile
Result=dialog_message('Lecture successful !!',/information)
close, iunit

; ** Correspondance between detector # and position (in 2 theta)
; ** Reading from Jeremy Cook's file det_pos_jcc2.dat (col1=det#;col5=2Theta)
; ** This array doesn't appear in the raw data file ... have to enter it "by hand"
; ********************************************************************************

    vartamp=fltarr(10,913)
    get_lun,unit_angle
    ;angle_file=dialog_pickfile(title='Open the angle file',filter='*.dat')
    angle_file='angles.dat'
    openr,unit_angle,angle_file
    readf,unit_angle,vartamp
    close,unit_angle
    free_lun,unit_angle
    Y_wk=vartamp(9,*)

    dist_sd=4010.0
	X_wk=findgen(1024)+1.
;	S   =size(DATA)
;	NN= indgen(20)
	ch_width=12.                                       ;!!!!!!! ch_width used 07/2001 to be modified !!!!!!!
	nrji=81.799/(lambda^2)
	tel=sqrt(5.2267*(1.e-6*dist_sd)^2*lambda^2/81.799) ;temps de vol S-D pour un neutron elastique en s
	nch_el=(1.e6*tel-tof_delay)/ch_width
	inch_el=fix(nch_el)


; ** Dealing with parameters
; ** ************************
	PP=fltarr(15)
	PT=strarr(15)

    PT(0)='Run number'                         &    PP(0)=run_number
	PT(1)='Chopper speed (rpm)'                &    PP(1)=w_chop
	PT(2)='Ratio 1'                            &    PP(2)=ratio1
	PT(3)='Ratio 2'                            &    PP(3)=ratio2
	PT(4)='Ratio 3'                            &    PP(4)=ratio3
	PT(5)='Anti-overlap speed (rpm)'           &    PP(5)=w_aoverlap
	PT(6)='Sample to Detector distance (mm)'   &    PP(6)=dist_sd
	PT(7)='Duration of the run (s)'            &    PP(7)=duration
	PT(8)='Incident wavelength (A)'            &    PP(8)=lambda
	PT(9)='Incident energy (meV)'              &    PP(9)=nrji
	PT(10)='Calculated elastic channel #'      &    PP(10)=inch_el
	PT(11)='TOF delay (us)'                    &    PP(11)=tof_delay
	PT(12)='Sum Monitor 0 (counts)'            &    PP(12)=mon1
	PT(13)='Sum Monitor 1 (counts)'            &    PP(13)=mon2
	PT(14)='Channel Width (us)'				   &	PP(14)=ch_width




      STATUS=0							;Status is ok
;     ********

  DATP={X:      X_wk,                $
        Y:      Y_wk,                $
        W_TIT:  title,               $
        X_TIT:  'Channel #',        $
        Y_TIT:  'Detector angle',         $
        P:      PP,                  $
        PAR_TXT:PT,                  $
        N:      spec_mon,            $
        TIME:   startd+' to '+stopd}

;     **********************

 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:   FREE_LUN,unit
 RETURN, DATA							;Return the data values
;************

 END
;******* ***********
;**
;**	Standard call for a data-read function interfacing LAMP.

;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 INST(2)  is "1" if raw  button is set.
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.
;**		  if FILENAME(1) exists,  this is the requested image number in the file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of float parameter values up to 41
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.
;------------ initialise NeXus routines first
@nidl.pro
function readfocus, INST , PATH , FILENAME , STATUS , DATP
;******* *************  
;**
;**	Reads a NeXus FOCUS data file into  LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.
;**		  if FILENAME(1) exists,  this is the requested image number in the file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.
;**
;** Mark Koennecke, August 1998

 DATA  =0
 STATUS=11
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

   if strpos(filename,'.') lt 0 then begin
 ;-------- build filename
 ;----- find year, as last element of path string
   res = str_sep(path,'/')
   i = N_ELEMENTS(res)
   year = res(i-2)
   num = String(filename,Format= '(I5.5)') 
   fname = inst(0)+num+STRING(year)+'.hdf' 
   fpath=path + fname

   endif else begin fname=filename & fpath=path + fname & endelse

   print, 'Lamp opening : ' + fpath

;------ open the file
   test = nxopen(fpath,'read',handle)
   if test NE 1 THEN BEGIN
      status = 11
      return, 0
   END
;-------- get some global attributes
   test1 = nxgetattr(handle,'file_time',ftime,typ)
   test2 = nxgetattr(handle,'file_name',foriname, typ)
   test3 = nxgetattr(handle,'owner',user,typ)
   IF (test1 NE 1) OR (test2 NE 1) OR (test3 NE 1) THEN BEGIN
       status = 24
       return,0
   END 
;------ open data vGroup and get counts, two_theta
   test = nxopengroup(handle,'entry1','NXentry')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxopengroup(handle,'bank1','NXdata')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxopendata(handle,'counts')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,cnts)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test = nxopendata(handle,'theta')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,detnum)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test = nxopendata(handle,'time_binning')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,tof)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
;------ leave this vGroup
   test=nxclosegroup(handle)
;------ get title Information
   test = nxopendata(handle,'title')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,title)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
  ; -------- get sample information
   test = nxopengroup(handle,'sample','NXsample')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxopendata(handle,'name')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,sample)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test = nxopendata(handle,'distance')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,sadist)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test = nxopendata(handle,'temperature_mean')
   IF test NE 1 THEN BEGIN
      ; ignore
       temp = -999.
   END ELSE BEGIN
     test = nxgetdata(handle,temp)
     IF test NE 1 THEN BEGIN
        status = 24
        return,0
      END
     test = nxclosedata(handle)
   END
;----- close sample groups
   test=nxclosegroup(handle)
; ------- enter instrument group
   test = nxopengroup(handle,'FOCUS','NXinstrument')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
; ------- enter monochromator group
   test = nxopengroup(handle,'monochromator','NXmonochromator')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
;------ get lambda
   test = nxopendata(handle,'lambda')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,lambda)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test = nxclosegroup(handle)
;------- get monitor
   test = nxopengroup(handle,'counter','NXmonitor')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
;------ get monitor
   test = nxopendata(handle,'monitor')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,monitor)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test=nxclosegroup(handle) 
;------- fermi-chopper
   test = nxopengroup(handle,'fermi_chopper','NXchopper')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
;------ get speed
   test = nxopendata(handle,'rotation_speed')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,fermispeed)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
;-------- get phase
   test = nxopendata(handle,'phase')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,fermiphase)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
;------ fermi-distance
   test = nxopendata(handle,'distance')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,fermidist)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test=nxclosegroup(handle) 
;-------- disk chopper
   test = nxopengroup(handle,'disk_chopper','NXchopper')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
;------ get speed
   test = nxopendata(handle,'rotation_speed')
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxgetdata(handle,diskspeed)
   IF test NE 1 THEN BEGIN
      status = 24
      return,0
   END
   test = nxclosedata(handle)
   test = nxclosegroup(handle)
;------ close the file
  test = nxclosegroup(handle)
  test = nxclose(handle) 
;--------- find the elastic line
  len = n_elements(tof)
  maxi = -999999
  pos =  0
  FOR I = 0, (len-1) DO BEGIN
     IF (cnts(I,75) GT maxi) THEN BEGIN
         maxi = cnts(I,75)
         pos = I
     END
  END
;-------- build parameter info
   pp = fltarr(31)
   pp(0) = temp
   pp(1) = lambda
   pp(2) = monitor
   pp(3) = fermispeed
   pp(4) = diskspeed
   pp(5) = fermiphase
   pp(6) = fermidist
   pp(7) = sadist
   pp(8) = 2500.0
   pp(21) = pp(1)
   pp(27) = 2.9997
   pp(18) = tof(2) - tof(1)
   pp(9) = pos
   ppi =  strarr(31)
   ppi(0) ='mean_temperature'
   ppi(1) = 'Lambda'
   ppi(2) = 'Monitor_Counts'
   ppi(3) = 'fermi_chopper_speed'
   ppi(4) = 'disk_chopper speed'
   ppi(5) = 'chopper_phase'
   ppi(6) = 'fermi_chopper_distance'
   ppi(7) = 'sample_distance'
   ppi(8) = 'detector_distance'
   ppi(9) = 'elastic_peak'
   ppi(18) = 'channel_width'
   ppi(21) = 'Lamda'
   ppi(27) = 'flight_path'

   ot = sample + ',' + string(foriname) 
   ott = ot + ',' + string(user)

;------ fill in structure				xv       =  FINDGEN(40)*2 +15			;Normaly in data file
      STATUS=0							;Status is ok
;     ********
      DATP={X:      detnum,    $
            Y:      tof,       $					;Pass those variables which were 
            W_TIT:  title,    $ 					;read-in into the DATP structure
            OTHER_TIT: ott, $
	    X_TIT:  'time-of-flight',    $
            Y_TIT:  'two theta',$
            Z_TIT:  'Counts', $                   
            TIME: ftime , $
	    P:      pp,   $
	    PAR_TXT: ppi }
;     **********************  					
	    
 
 RETURN, cnts							;Return the data values
;***********

 END

;************************
function HDx_OPEN       , FileName , read=read
;************************
common   HDx_com,hdf5,vers,file_id,root,att_loc,att_names,grp_loc,grp_names,grp_id,sd_loc,sd_id,sd_names,vg_lone,Natts

if n_elements(vers) eq 0 then begin  hdf5=0 & vers=4
	 if !version.release ge '5.5' then if !version.release lt '5.6' then hdf5=execute('dlm_load,"hdf5"') else hdf5=1
endif &  if hdf5 then begin b=0 & ii=execute('b=H5F_IS_HDF5(FileName)') & if b then vers=5 else vers=4 & endif
if vers eq 5 then begin
	 att_loc=-1L & file_id=H5F_OPEN( FileName)
	 grp_loc=-1L & grp_id =0L & grp_names=''
	 sd_loc =-1L & sd_id  =0L & sd_names =''
	 root=H5G_OPEN( file_id  , '/')     & Natts=H5A_GET_NUM_ATTRS(root)
	 N   =H5G_GET_NMEMBERS(file_id,'/') & ok=0 & sk=0
	 if N gt 0 then begin
	    for i=0,N-1 do begin
		g=H5G_GET_MEMBER_NAME(file_id,'/',i)
		s=H5G_GET_OBJINFO    (root,g)
		if s.type eq 'GROUP'   then begin   grpi=H5G_OPEN(root,g)
			grp_id =[grp_id,grpi] & grp_loc=[grp_loc,root]  & grp_names  =[grp_names,g] & ok=ok+1 & endif
		if s.type eq 'DATASET' then begin
			sd_id  =[sd_id ,0]    & sd_loc =[sd_loc ,root]  & sd_names   =[sd_names ,g] & sk=sk+1 & endif
	    endfor
	    if sk gt 0 then begin sd_id  =sd_id  (1:sk) & sd_loc =sd_loc (1:sk) & sd_names =sd_names (1:sk) & endif
	    if ok gt 0 then begin grp_id =grp_id (1:ok) & grp_loc=grp_loc(1:ok) & grp_names=grp_names(1:ok) & endif
	 endif
	 if grp_loc(0) eq -1 then vg_lone=-1 $
	               else begin vg_lone=indgen(n_elements(grp_loc))
                              for j=0,n_elements(grp_loc)-1 do hd0_init_vgsd, grp_loc(j),grp_names(j),grp_id(j) & endelse
 	 return,file_id
endif else $
return,  HDF_OPEN       ( FileName , read=read)
end

;************************
function HDx_SD_START   , FileName , read=read
;************************
common   HDx_com
if vers eq 5 then begin
         return,root
endif else $
return,  HDF_SD_START   ( FileName , read=read)
end

;************************
function HDx_SD_ATTRFIND, sdid, name
;************************
common   HDx_com
if vers eq 5 then begin
	 if att_loc ne sdid then begin N=H5A_GET_NUM_ATTRS(sdid) & att_names='!'
	    if N gt 0 then begin
	       att_names=strarr(N)
	       att_loc=sdid
	       for i=0,N-1 do begin a=H5A_OPEN_IDX(sdid,i)
	                            atn  =H5A_GET_NAME(a)
	                            h4   =strpos(atn,'_GLO') & if h4 gt 0 then atn=strmid(atn,0,h4) ;(h4toh5)
	                            att_names(i)= atn
				    H5A_CLOSE,a & endfor
	 endif & endif
	 idx=where(strlowcase(att_names) eq strlowcase(name)) & return,idx(0)
endif else $
return,  HDF_SD_ATTRFIND( sdid, name)
end

;************************
function HDx_VG_LONE    , fid
;************************
common   HDx_com
if vers eq 5 then begin
         return,vg_lone
endif else $
return,  HDF_VG_LONE    ( fid)
end

;************************
function HDx_VG_ATTACH  , fid,j
;************************
common   HDx_com
if vers eq 5 then begin
         return,grp_id(j) ;Group already opened
endif else $
return,  HDF_VG_ATTACH  ( fid,j)
end

;************************
function HDx_SD_SELECT  , sdid,j
;************************
common   HDx_com
if vers eq 5 then begin
         selid=H5D_OPEN(sd_loc(j),sd_names(j))
         sd_id(j)=selid
         return  ,selid
endif else $
return,  HDF_SD_SELECT  ( sdid,j)
end

;************************
function HDx_SD_NAMETOINDEX, sdid,name
;************************
common   HDx_com
if vers eq 5 then begin
         j=where(sd_names eq name)
         return,j(0)
endif else $
return,  HDF_SD_NAMETOINDEX( sdid,name)
end

;************************
function HDx_SD_IDTOREF , sdsid
;************************
common   HDx_com
if vers eq 5 then begin
         j=where(sd_id eq sdsid)
         return,j(0)
endif else $
return,  HDF_SD_IDTOREF ( sdsid)
end

;************************
function HDx_SD_DIMGETID, kp_id,n
;************************
common   HDx_com
if vers eq 5 then begin
         return,-1 ;Obsolete
endif else $
return,  HDF_SD_DIMGETID( kp_id,n)
end

;************************
pro      HDx_SD_ATTRINFO, sdsid,j,NAME=Aname,TYPE=tip,COUNT=count,DATA=tmp
;************************
common   HDx_com
if vers eq 5 then begin
         a=H5A_OPEN_IDX  (sdsid,j)
         Aname=H5A_GET_NAME(a)
         tmp  =H5A_READ(a)
         count=n_elements(tmp) & if strpos(Aname,'HDF4_') eq 0 then count=0 ;(h4toh5)
         tip  ='STRING' & ii=execute('tip=size(tmp,/tname)')
         H5A_CLOSE,a
endif else $
         HDF_SD_ATTRINFO, sdsid,j,NAME=Aname,TYPE=tip,COUNT=count,DATA=tmp
end

;************************
pro      HDx_VG_GETINFO , tid, name=nm,class=cn
;************************
common   HDx_com
if vers eq 5 then begin
	 j  =where(grp_id eq tid) & j=j(0)
	 nm =grp_names(j)
	 cn =' '
	 idx=HDx_SD_ATTRFIND(tid, 'NX_class')
	 if idx lt 0 then idx=HDx_SD_ATTRFIND(tid, 'class')
	 if idx lt 0 then idx=HDx_SD_ATTRFIND(tid, 'NXclass')
	 if idx lt 0 then idx=HDx_SD_ATTRFIND(tid, 'HDF4_VGROUP_CLASS') ;(h4toh5)
	 if idx ge 0 then begin a=H5A_OPEN_IDX  (tid,idx) & cn=H5A_READ(a) & H5A_CLOSE,a & endif
   ;Bug in API
	 if strlowcase(cn) eq 'nxinstrumen' then cn='NXinstrument'
	 if strlowcase(cn) eq 'nxmonito' then cn='NXmonitor'
	 if strlowcase(cn) eq 'nxsampl' then cn='NXsample'
	 if strlowcase(cn) eq 'nxentr' then cn='NXentry'
	 if strlowcase(cn) eq 'nxdat' then cn='NXdata'
	 if strlowcase(cn) eq 'nxbea' then cn='NXbeam'
	 if strlowcase(cn) eq 'nxuse' then cn='NXuser'
	 if strlowcase(cn) eq 'nxlo' then cn='NXlog'
   ;end of Bug
endif else $
         HDF_VG_GETINFO , tid, name=nm,class=cn
end

;************************
pro      HDx_VG_GETTRS  , gid,tags,refs
;************************
common   HDx_com
if vers eq 5 then begin
         tags=-1 & refs=-1
         gp_r  =where(grp_loc eq gid) & if gp_r(0) ge 0 then begin refs= gp_r & tags=gp_r*0+1965 & endif     ;magic
         sd_r  =where(sd_loc  eq gid) & if sd_r(0) ge 0 then $
	                                if refs(0) ge 0 then begin refs=[refs,sd_r] & tags=[tags,sd_r*0+720] ;magic
	                                endif           else begin refs= sd_r & tags=sd_r*0+720  & endelse
endif else $
         HDF_VG_GETTRS  , gid,tags,refs
end

;************************
pro      HDx_SD_FILEINFO, sdid  ,  Nsets, Nattrib
;************************
common   HDx_com
if vers eq 5 then begin
         Nattrib=Natts
         Nsets  =n_elements(sd_loc)
endif else $
         HDF_SD_FILEINFO, sdid  ,  Nsets, Nattrib
end

;************************
pro      HDx_SD_GETINFO ,sdsid, NAME=Sname,TYPE=tip,DIMS=dims,LABEL=label,UNIT=unit,NATTS=nattrib
common   HDx_com
if vers eq 5 then begin
         j=where(sd_id eq sdsid) & j=j(0)
         Sname  =sd_names(j)
         label  =' ' & unit=' ' ;Obsolete
         nattrib=H5A_GET_NUM_ATTRS(sdsid)
         ref_t  =H5D_GET_TYPE     (sdsid)
            tip =H5T_GET_CLASS(ref_t) & tip=strupcase(strmid(tip,4,20))
            H5T_CLOSE,ref_t
         sp     =H5D_GET_SPACE(sdsid)
            dims=H5S_GET_SIMPLE_EXTENT_DIMS(sp)
            H5S_CLOSE,sp
endif else $
         HDF_SD_GETINFO ,sdsid, NAME=Sname,TYPE=tip,DIMS=dims,LABEL=label,UNIT=unit,NATTS=nattrib
end

;************************
pro      HDx_SD_GETDATA ,sdsid, Data
;************************
common   HDx_com
if vers eq 5 then begin
         Data=H5D_READ(sdsid)
endif else $
         HDF_SD_GETDATA ,sdsid, Data
end

;************************
pro      HDx_SD_DIMGET  , dmid, LABEL=xt, UNIT=unit, SCALE=x, COUNT=cn
;************************
common   HDx_com
if vers eq 5 then begin
         xt=' ' & unit=' ' & x=0 & count=1 ;Obsolete
endif else $
         HDF_SD_DIMGET  , dmid, LABEL=xt, UNIT=unit, SCALE=x, COUNT=cn
end

;************************
pro      HDx_SD_ENDACCESS,sdsid
;************************
common   HDx_com
if vers eq 5 then begin
         H5D_CLOSE      , sdsid
endif else $
         HDF_SD_ENDACCESS,sdsid
end

;************************
pro      HDx_VG_DETACH  , gid
;************************
common   HDx_com
if vers eq 5 then begin
	;keep Group opened
endif else $
         HDF_VG_DETACH  , gid
end

;************************
pro      HDx_SD_END     , sdid
;************************
common   HDx_com
if vers eq 5 then begin
         H5G_CLOSE      , sdid
endif else $
         HDF_SD_END     , sdid
end

;************************
pro      HDx_CLOSE      , fid
;************************
common   HDx_com
if vers eq 5 then begin
         H5F_CLOSE      , fid
         H5_CLOSE
endif else $
         HDF_CLOSE      , fid
end

;** ***********
pro hd0_init_vgsd, grp,name,recur
;** ***********
common   HDx_com
	 N  =H5G_GET_NMEMBERS(grp,name)
	 for i=0,N-1 do begin
		g=H5G_GET_MEMBER_NAME(grp,name,i)
		s=H5G_GET_OBJINFO    (recur,g)
		    if s.type eq 'GROUP'   then begin   grpi=H5G_OPEN(recur,g)
			   grp_id =[grp_id,grpi]  & grp_loc=[grp_loc,recur]  & grp_names  =[grp_names,g]
		           hd0_init_vgsd, recur,g,grpi & endif
		    if s.type eq 'DATASET' then begin
		           sd_id  =[sd_id ,0]     & sd_loc =[sd_loc ,recur]  & sd_names   =[sd_names ,g]
		           if sd_loc(0) eq -1 then begin sk= n_elements(sd_loc)-1
		                                    sd_id=sd_id(1:sk) & sd_loc=sd_loc(1:sk) & sd_names=sd_names(1:sk) & endif
            endif
     endfor
end

;** ********
pro read_hdf, FileName , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
;** ********
                         , PR=p, PV=pv, PAR_TXT=p_txt            $
                         , W_tit=wt   , X_tit=xt , Y_TIT=yt      $
                         , Z_tit=zt   , OTHER_TIT=ot , SNAP=snap $
                         , SOURCE=src , Img=immg , HIST=his

;** Read HDF Lamp format & NeXus.

;** Input  parameters: FileName & optionnaly immg="1.1" for "first entry . first data".
;**		       Data must be set to 0 (read all) or -88 (read attributs only)

;** Output parameters: All others+Data

magic = 1965 ;& magic=720
fid=0 & sdid=0
CATCH,stat & IF stat ne 0 then begin print,!err_string & if sdid gt 0 then HDx_SD_END,sdid & catch, /cancel
                                                         if fid  gt 0 then HDx_CLOSE,fid   & return & endif
ON_IOERROR,mis

;*****************
;**Preliminaries**
;*****************
imm= 1 & if n_elements(immg) ne 1 then img=1 else begin  ON_IOERROR,mismg
		simg=str_sep(string(immg),'.')   &  img=long(simg(0))>1
		if n_elements(simg) eq 2 then begin img=long(simg(1))>1 & imm=long(simg(0))>1 & endif
		mismg:ON_IOERROR,mis
         endelse
src='' & his ='' & lim ='' & p=0  & xd='' & yd='' & zd=''  & wt='' & xt=''  & yt='' & aff='' & mel=''
zt ='' & ot  ='' & mach='' & snap=bindgen(2,2)    & x =0   & y = 0 & z = 0  & lampF=0
pv = 0 & e   = 0 & n   = 0 & p_txt=' ='   & pa_txt=[' =0'] & tiip='UNKNOWN' & axes=['?']
idy=-1 & time='' & D88 = Data(0)          & space=' '      & transp=0
Quiet=!quiet     & !quiet=1

;*****************
;**Open HDF file**
;*****************
fid  = HDx_OPEN     (FileName , /READ)
;*     ********
if fid gt 0 then begin Data=[1,2,3,4]

 sdid = HDx_SD_START (FileName, /READ)
 ;*     ************
 idx =HDx_SD_ATTRFIND(sdid, 'file_name')   & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=his
 idx =HDx_SD_ATTRFIND(sdid, 'title')       & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=his
 idx =HDx_SD_ATTRFIND(sdid, 'titl')        & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=his
 idx =HDx_SD_ATTRFIND(sdid, 'file_time')   & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=time
 idx =HDx_SD_ATTRFIND(sdid, 'user_name')   & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=src
 idx =HDx_SD_ATTRFIND(sdid, 'owner')       & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=src
 idx =HDx_SD_ATTRFIND(sdid, 'user')        & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=src
 idx =HDx_SD_ATTRFIND(sdid, 'affiliation') & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=aff
 idx =HDx_SD_ATTRFIND(sdid, 'email')       & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=mel
 time=strtrim(string(byte(time)>32b),2)    & his =strtrim(string(byte(his)>32b),2) & src=strtrim(string(byte(src)>32b),2)
 aff =strtrim(string(byte(aff) >32b),2)    & mel =strtrim(string(byte(mel)>32b),2)
 if aff gt ' ' then src=src+' ('+aff+')'   & if mel gt ' ' then src=src+' ->'+mel
 his =his+' '+time
 ot  =src
 wt  =his
 idx =HDx_SD_ATTRFIND(sdid, 'instrument')  & if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=ins
                                             if idx ge 0 then begin src =strtrim(string(byte(ins)>32b),2)
                                                                    ot  =src+' '+ot & endif
;************************
;**Select right NXentry**
;************************
 lest=HDx_VG_LONE(fid)   & NXentry=0 & list=["","",""] & nlest='0'
 ;*   ***********
 if lest(0) ge 0 then FOR j=0,n_elements(lest)-1 do begin
                          tid= HDx_VG_ATTACH (fid,lest(j)) & HDx_VG_GETINFO,tid, class=cn
                               HDx_VG_DETACH, tid
                          if   strlowcase(cn) ne "nxentry" then lest(j)=-1
                      ENDFOR & idx=where(lest ge 0)
 if idx(0)  ge 0 then begin        lest =lest(idx)
                                   imm  =imm< n_elements(lest)
                                   nlest=strtrim(string(n_elements(lest)),2)
                                   NXentry=HDx_VG_ATTACH(fid ,lest((imm-1)>0))
                                           HDx_VG_GETTRS,NXentry,tags,refs
                                   FOR  i= 0,n_elements(tags)-1 do IF tags(i) eq magic then begin
                                      tid= HDx_VG_ATTACH(fid ,refs(i))
                                           HDx_VG_GETINFO,tid, name=nm,class=cn
                                           HDx_VG_DETACH, tid
                                           list=[list,string(refs(i)),nm+'1',cn]
                                   endif & list=strlowcase(list)  &   endif
                                   
;***********************
;**Select right NXdata**
;***********************
 idx =where(list eq "nxdata")  &  nidx  ='0'
           if  idx(0) gt 0  then  nidx  =strtrim(string(n_elements(idx)),2)
 img=img<n_elements(idx) &  idxd= img-1  &  NXdata=idx(idxd)

 if  NXdata  gt 0   then  NXdata=HDx_VG_ATTACH(fid , long(list(NXdata-2)))
 if  NXdata  gt 0   then  begin  HDx_VG_GETTRS,NXdata,tags, refs
                                 NXF="NeXus  entry:"+strtrim(string(imm),2)+"/"+nlest
                                 NXF= NXF + " data:"+strtrim(string(img),2)+"/"+nidx
                    endif  else  NXF="HDF"

     HDx_SD_FILEINFO,sdid  ,  Nsets, Natts

;**  ***************
;**Check for Writer*
;*******************
 idx=HDx_SD_ATTRFIND(sdid, 'Written_by_LAMP') & if idx ge 0 then lampF=1
 if  idx lt 0 then $
 idx=HDx_SD_ATTRFIND(sdid, 'LAMP_FORMAT')     & if idx ge 0 then lampF=1
 ;*  ***************
 if lampF then begin

  HDx_SD_ATTRINFO, sdid, idx, DATA=time

  idx=HDx_SD_ATTRFIND(sdid, 'SOURCE')
      if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=src

  idx=HDx_SD_ATTRFIND(sdid, 'HISTORY')
      if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=his

  idx=HDx_SD_ATTRFIND(sdid, 'TITLES')
      if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=wt

  idx=HDx_SD_ATTRFIND(sdid, 'OTHER')
      if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=ot

  idx=HDx_SD_ATTRFIND(sdid, 'MIN_MAX_VALUES')
      if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=lim

  idx=HDx_SD_ATTRFIND(sdid, 'PARAMETERS')
	if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=P

 ;idx=HDx_SD_ATTRFIND(sdid, 'MACHINE')
 ;    if idx ge 0 then HDx_SD_ATTRINFO,sdid,idx,DATA=mach

  kp_id=HDx_SD_SELECT(sdid,HDx_SD_NAMETOINDEX(sdid,'DATA'))

  FOR i=0, Nsets-1 do begin OK=1
    sdsid=HDx_SD_SELECT(sdid,i)
    if NXdata gt 0 then begin idx=where(refs eq HDx_SD_IDTOREF(sdsid))
       if idx(0) lt 0 then OK=0 & endif
    if OK then begin
       HDx_SD_GETINFO,sdsid, NAME=Sname, TYPE=tip, DIMS=dims & Sname=strupcase(Sname)

      case Sname of
     'PARAMETERS'   : begin HDx_SD_GETDATA,sdsid, pa_txt
                            pa_txt=STR_SEP(pa_txt,' '+string(10b)+' ')
                            if n_elements (pa_txt) eq 1 then $
	                      pa_txt=STR_SEP(pa_txt(0),' '+string(14b)+' ')
                            cn=n_elements (pa_txt)-1 & P=fltarr(cn) & ON_IOERROR,mes
                            p_txt=strarr(cn)
                            for j=0,cn-1 do begin  tmp=pa_txt(j) & r=RSTRPOS(tmp,'=')>0
                                if r ge 0 then begin P(j)=FLOAT(STRMID(tmp,r+1,30))
                                                     p_txt(j)=  STRMID(tmp,0,r+1) & endif
                            endfor
                            mes:ON_IOERROR,mis
                      end
     'DATA'         : begin if D88 ne -88 then HDx_SD_GETDATA ,sdsid, Data & tiip=tip & dims=string(dims)
                            xd=dims(0) & if n_elements(dims) ge 2 then yd=dims(1) & if n_elements(dims) ge 3 then zd=dims(2)
                            idy=HDx_SD_ATTRFIND(sdsid, 'Y_VALUE') & if idy ge 0 then HDx_SD_ATTRINFO,sdsid,idy,DATA=Y
                            idz=HDx_SD_ATTRFIND(sdsid, 'Z_VALUE') & if idz ge 0 then HDx_SD_ATTRINFO,sdsid,idz,DATA=Z
                            idn=HDx_SD_ATTRFIND(sdsid,'MONITORS') & if idn ge 0 then HDx_SD_ATTRINFO,sdsid,idn,DATA=N
                            END
     'X'            : begin if D88 ne -88 then HDx_SD_GETDATA ,sdsid,x & idx=HDx_SD_ATTRFIND(sdsid,'units')
                            if idx ge  0  then HDx_SD_ATTRINFO,sdsid,idx,DATA=xt & END
     'X_COORDINATES': begin dmid=HDx_SD_DIMGETID (kp_id,0)
                            HDx_SD_DIMGET, dmid, LABEL=xt, UNIT=unit, SCALE=x, COUNT=cn
                            if strpos(unit,'-->') ge 0 then begin off=0L & ON_IOERROR,mex
                               reads,unit,off & mex:x=lindgen(cn)+off    & ON_IOERROR,mis
                            endif  & end
     'Y'            : begin if D88 ne -88 then HDx_SD_GETDATA ,sdsid,y & idx=HDx_SD_ATTRFIND(sdsid,'units')
                            if idx ge  0  then HDx_SD_ATTRINFO,sdsid,idx,DATA=yt & END
     'Y_COORDINATES': begin dmid=HDx_SD_DIMGETID (kp_id,1)
                            HDx_SD_DIMGET, dmid, LABEL=yt, UNIT=unit, SCALE=y, COUNT=cn
                            if strpos(unit,'-->') ge 0 then begin off=0L & ON_IOERROR,mey
                               reads,unit,off & mey:y=lindgen(cn)+off    & ON_IOERROR,mis
                            endif  & end
     'Z'            : begin if D88 ne -88 then HDx_SD_GETDATA ,sdsid,z & idx=HDx_SD_ATTRFIND(sdsid,'units')
                            if idx ge  0  then HDx_SD_ATTRINFO,sdsid,idx,DATA=zt & END
     'Z_COORDINATES': begin dmid=HDx_SD_DIMGETID (kp_id,2)
                            HDx_SD_DIMGET, dmid, LABEL=zt, UNIT=unit, SCALE=z
                      end
     'VAR_PARAMS'   : if D88 ne -88 then HDx_SD_GETDATA,sdsid, pv
     'ERRORS'       : if D88 ne -88 then HDx_SD_GETDATA,sdsid, e
     'SNAPSHOT'     : if D88 eq -88 then HDx_SD_GETDATA,sdsid, snap
      ELSE          :
      endcase
    endif
    HDx_SD_ENDACCESS, sdsid
  ENDFOR

  if (n_elements(y) eq 1) and (idy lt 0) then begin
     idx=HDx_SD_ATTRFIND(kp_id, 'X_SPACE') & if idx ge 0 then HDx_SD_ATTRINFO,kp_id,idx,DATA=X
     idx=HDx_SD_ATTRFIND(kp_id, 'Y_SPACE') & if idx ge 0 then HDx_SD_ATTRINFO,kp_id,idx,DATA=Y
     idx=HDx_SD_ATTRFIND(kp_id, 'Z_SPACE') & if idx ge 0 then HDx_SD_ATTRINFO,kp_id,idx,DATA=Z
     if  idx ge 0 then space=' SPACE MODEL:'
  endif

 ;*****************
 ;Writer is'nt LAMP
 ;*****************
 endif else begin
  FOR i=0, Nsets-1 do begin  ok=1
    sdsid=HDx_SD_SELECT(sdid,i)
    if NXdata gt 0 then begin idx=where(refs eq HDx_SD_IDTOREF(sdsid))
       if idx(0) lt 0 then OK=0 & endif

    if OK then begin
      HDx_SD_GETINFO,sdsid, NAME=Sname,TYPE=tip,DIMS=dims,LABEL=label,UNIT=unit,NATTS=natts & Sname=strupcase(Sname)

      if NXdata le 0 then begin
         if Sname eq 'CNT1' then if (D88 ne -88) and (n_elements(data) eq 4) then HDx_SD_GETDATA,sdsid, data
         if Sname eq 'Y'    then if (D88 ne -88)                             then HDx_SD_GETDATA,sdsid, data
         if Sname eq 'X'    then if (D88 ne -88)                             then HDx_SD_GETDATA,sdsid, X
         if Sname eq 'TTHE' then if (D88 ne -88)                             then HDx_SD_GETDATA,sdsid, Y
         if Sname eq 'TTHE' then yt='Two theta'
         if Sname eq 'SPEC' then if (D88 ne -88)                             then HDx_SD_GETDATA,sdsid, Isis_SPEC
         if Sname eq 'MDET' then if (D88 ne -88)                             then HDx_SD_GETDATA,sdsid, Isis_MDET
         if Sname eq 'LEN2' then if (D88 ne -88)                             then HDx_SD_GETDATA,sdsid, Isis_LEN2
         if Sname eq 'NSP1'                                                  then HDx_SD_GETDATA,sdsid, Isis_NSP1
         if Sname eq 'XUNITS'                                                then HDx_SD_GETDATA,sdsid, xt
         if Sname eq 'YUNITS'                                                then HDx_SD_GETDATA,sdsid, zt
         if Sname eq 'TITL'                                                  then HDx_SD_GETDATA,sdsid, wt & wt=strtrim(wt,2)
         if Sname eq 'NAME'                                                  then HDx_SD_GETDATA,sdsid, src
      endif else if Sname eq 'ERRORS' then begin if D88 ne -88               then HDx_SD_GETDATA,sdsid, e
      endif else begin
	 idx=HDx_SD_ATTRFIND(sdsid, 'long_name')
	    if idx ge 0 then       HDx_SD_ATTRINFO,sdsid,idx,DATA=Lname else Lname=' ' & Lname=strtrim(string(byte(Lname)>32b),2)
	 idx=HDx_SD_ATTRFIND(sdsid, 'units')
	    if idx ge 0 then       HDx_SD_ATTRINFO,sdsid,idx,DATA=Lunit else Lunit=' ' & Lunit=strtrim(string(byte(Lunit)>32b),2)
	 idx=HDx_SD_ATTRFIND(sdsid, 'title')
	    if idx ge 0 then       HDx_SD_ATTRINFO,sdsid,idx,DATA=Ltitl else Ltitl=' ' & Ltitl=strtrim(string(byte(Ltitl)>32b),2)
	 idx=HDx_SD_ATTRFIND(sdsid, 'monitor')
	    if idx ge 0 then       HDx_SD_ATTRINFO,sdsid,idx,DATA=N

	 idx=HDx_SD_ATTRFIND(sdsid, 'signal')
	    if idx ge 0 then begin HDx_SD_ATTRINFO,sdsid,idx,DATA=vaa & val=1
	                           ON_IOERROR,misvaa1 & val=long(vaa(0)) & misvaa1:ON_IOERROR,mis
	                           if val eq 1 then begin
	                           ON_IOERROR,mis1
	                           if D88 ne -88 then  HDx_SD_GETDATA,sdsid, Data & mis1:tiip=tip
	                           ON_IOERROR,mis
	                           if label gt ' ' then  wt=label & lim=''  &  zt=Sname+' '+Lunit
				   if ltitl gt ' ' then  wt=ltitl+' '+Lunit $
	                                           else  wt=Sname+' '+Lunit+' '+wt+' '+Lname
	                           if yt    eq ''  then  yt=zt
	                           FOR j=0, n_elements(dims)-1  DO lim=lim+string(dims(j))+' '
	                           endif & endif
	 ON_IOERROR,mis
	 idx=HDx_SD_ATTRFIND(sdsid, 'axis')
	    if idx ge 0 then begin HDx_SD_ATTRINFO,sdsid,idx,DATA=vaa & val=1
	       ON_IOERROR,misvaa2 & val=long(vaa(0)) & misvaa2:ON_IOERROR,mis
	       idx=HDx_SD_ATTRFIND(sdsid, 'primary') & vaa=1
	       if idx ge 0 then    HDx_SD_ATTRINFO,sdsid,idx,DATA=vaa & prim=1
	       ON_IOERROR,misvaa3 & prim=long(vaa(0)) & misvaa3:ON_IOERROR,mis
	                        if prim   eq 1 then begin tt=label
				   if ltitl gt ' ' then   tt=ltitl+' '+Lunit $
	                                           else   if tt eq '' then tt=Sname+' '+Lunit+' '+Lname
	                           if val eq 1 then begin ON_IOERROR,mis2 & HDx_SD_GETDATA,sdsid, x & mis2:xt=tt & endif
	                           if val eq 2 then begin ON_IOERROR,mis3 & HDx_SD_GETDATA,sdsid, y & mis3:yt=tt & endif
	                           if val eq 3 then begin ON_IOERROR,mis4 & HDx_SD_GETDATA,sdsid, z & mis4:zt=tt & endif
	                           ON_IOERROR,mis
	    endif       &       endif
	 idx=HDx_SD_ATTRFIND(sdsid, 'axes')
	    if idx ge 0 then begin HDx_SD_ATTRINFO,sdsid,idx,DATA=axes & axes=strtrim(string(byte(axes)>32b),2)
	       b=strpos(axes,'[') & if b ge 0 then  axes=strmid (axes,b+1,100)
	       b=strpos(axes,']') & if b gt 0 then  axes=strmid (axes, 0 , b )
	       axes=strcompress(axes,/remove_all) & axes=str_sep(axes,',')
	    endif
      endelse
    endif
    HDx_SD_ENDACCESS, sdsid
  ENDFOR
 endelse
 ;*****************
 if NXdata gt 0 then HDx_VG_DETACH, NXdata

 ;***************
 ;NXother  groups
 ;***************
 idx=where(list eq "nxinstrument")  &  NXinstrument=idx(0) &  tags=[-1] &  refs=[-1] & grnm=''
 idx=where(list eq "nxmonitor")     &  NXmonitor   =idx(0) & stags=[-1] & srefs=[-1]
 idx=where(list eq "nxsample")      &  NXsample    =idx(0) & ttags=[-1] & trefs=[-1]
 idx=where(list eq "nxdata")        &  NXdata      =idx(idxd)
 idx=where(list eq "nxbeam")        &  NXbeam      =idx(0)
 idx=where(list eq "nxlog")         &  NXlog       =idx(0)
;idx=where(list eq "nxuser")        &  NXuser      =idx(0)

 if NXinstrument gt 0 then   begin
    NXinstrument=HDx_VG_ATTACH(fid, long(list(nxinstrument-2))) & HDx_VG_GETTRS,NXinstrument,ttags,trefs
    FOR  i= 0,n_elements(ttags)-1 do $
    IF ttags(i) eq magic then begin tid=HDx_VG_ATTACH(fid ,trefs(i))
       HDx_VG_GETTRS,tid,stags,srefs & HDx_VG_GETINFO,tid, name=nm,class=cn & cn=strmid(cn,2,20)
    tags=[tags,stags] & refs=[refs,srefs] & t=string(stags) & t(*)='(I '+cn+') '   & grnm=[grnm,t] & HDx_VG_DETACH, tid  & endif
    tags=[tags,ttags] & refs=[refs,trefs] & t=string(ttags) & t(*)='(Instrument) ' & grnm=[grnm,t] & HDx_VG_DETACH, NXinstrument
    ttags=[-1] & trefs=[-1] & endif

 if NXmonitor    gt 0 then   begin
    NXmonitor   =HDx_VG_ATTACH(fid,long(list(nxmonitor-2)))     & HDx_VG_GETTRS,NXmonitor,ttags,trefs
    tags=[tags,ttags] & refs=[refs,trefs] & t=string(ttags) & t(*)='(Monitor) '    & grnm=[grnm,t] & HDx_VG_DETACH, NXmonitor
    ttags=[-1] & trefs=[-1] & endif

 if NXsample     gt 0 then   begin
    NXsample    =HDx_VG_ATTACH(fid,long(list(nxsample-2)))      & HDx_VG_GETTRS,NXsample,ttags,trefs
    tags=[tags,ttags] & refs=[refs,trefs] & t=string(ttags) & t(*)='(Sample) '     & grnm=[grnm,t] & HDx_VG_DETACH, NXsample
    ttags=[-1] & trefs=[-1] & endif

 if NXentry      gt 0 then   begin                                HDx_VG_GETTRS,NXentry,ttags,trefs
    tags=[tags,ttags] & refs=[refs,trefs] & t=string(ttags) & t(*)='(Entry) '      & grnm=[grnm,t]
    ttags=[-1] & trefs=[-1] & endif

 if NXdata       gt 0 then   if (not lampF) then begin
    NXdata      =HDx_VG_ATTACH(fid, long(list(nxdata-2)))       & HDx_VG_GETTRS,NXdata,ttags,trefs
    tags=[tags,ttags] & refs=[refs,trefs] & t=string(ttags) & t(*)='(Data) '       & grnm=[grnm,t] & HDx_VG_DETACH, NXdata
    ttags=[-1] & trefs=[-1] & endif

 if NXbeam       gt 0 then   begin
    NXbeam      =HDx_VG_ATTACH(fid, long(list(nxbeam-2)))       & HDx_VG_GETTRS,NXbeam,ttags,trefs
    tags=[tags,ttags] & refs=[refs,trefs] & t=string(ttags) & t(*)='(Beam) '       & grnm=[grnm,t] & HDx_VG_DETACH, NXbeam
    ttags=[-1] & trefs=[-1] & endif

 if NXlog        gt 0 then   begin
    NXlog       =HDx_VG_ATTACH(fid, long(list(nxlog-2)))        & HDx_VG_GETTRS,NXlog,ttags,trefs
    tags=[tags,ttags] & refs=[refs,trefs] & t=string(ttags) & t(*)='(Vlog) '       & grnm=[grnm,t] & HDx_VG_DETACH, NXlog
    ttags=[-1] & trefs=[-1] & endif

 if n_elements(tags) gt 1 then begin
    FOR i=0, Nsets-1 do begin
	sdsid = HDx_SD_SELECT(sdid,i) & idx=where(refs eq HDx_SD_IDTOREF(sdsid)) & idx=idx(0)
	if idx ge 0 then begin
	  HDx_SD_GETINFO,sdsid, NAME=Sname,TYPE=tip,DIMS=dims,NATTS=natts
	  itx= HDx_SD_ATTRFIND(sdsid, 'units')
	   if (itx ge 0) then  HDx_SD_ATTRINFO,sdsid,itx,DATA=Lu else Lu=' ' & Lu=strtrim(string(byte(Lu)>32b),2)
	  itx= HDx_SD_ATTRFIND(sdsid, 'signal')
	   if (itx ge 0) then signal=1 else signal=0
;	************************
;	Check for SDS parameters
;	************************
	  ON_IOERROR,mis5
	  HDx_SD_GETDATA,sdsid,tmp & mis5:ON_IOERROR,mis

	  if (grnm(idx) eq '(Monitor) ') and (((n_elements(N) eq 1) and (N(0)  eq 0)) or signal)   then N=tmp else $
	  if (strpos(strlowcase(Sname),'monitor') eq 0) and (N(0) eq 0) then N=tmp

	  if (tip eq 'BYTE') then begin on_ioerror,misOb & t=strtrim(string(byte(tmp)>32b),2) & tmp=t & dims=1 & tip='STRING' & misOb:ON_IOERROR,mis & endif
	  totdim=n_elements(tmp)
	  ida=where(axes eq Sname) & ida=ida(0)

	  if (grnm(idx) eq '(Data) ') and (ida ge 0) then begin
		j=HDx_SD_ATTRFIND(sdsid, 'long_name')
	     if j   ge 0 then HDx_SD_ATTRINFO,sdsid,j,DATA=Lname else Lname=Sname & Lname=strtrim(string(byte(Lname)>32b),2)
		j=HDx_SD_ATTRFIND(sdsid, 'units')
	     if j   ge 0 then HDx_SD_ATTRINFO,sdsid,j,DATA=Lunit else Lunit=' '   & Lunit=strtrim(string(byte(Lunit)>32b),2)
	     if ida eq 0 then begin x=tmp & xt=Lname+' '+Lunit & endif
	     if ida eq 1 then begin y=tmp & yt=Lname+' '+Lunit & endif
	     if ida eq 2 then begin z=tmp & zt=Lname+' '+Lunit & endif

	  endif else if totdim le 12 then begin if totdim gt 1 then tmp=reform(tmp,totdim)
	    if (strpos(strlowcase(Sname),'title') eq 0) then wt=string(tmp(0)) else begin
		if (tip eq 'STRING') then begin Sname=Sname+': '+strmid(tmp(0),0,40) & tmp=0 & endif
		on_ioerror,misOd & t=0 & t=float(tmp)   & misOd:ON_IOERROR,mis & p=[p,t] & t=string(t)
		if n_elements(t) gt 1 then tix='_'+strtrim(sindgen(n_elements(t)),2) else tix=''
		pa_txt=[pa_txt,grnm(idx)+Sname+tix+' '+Lu+' = '+t] & t(*)=' ' & p_txt=[p_txt ,grnm(idx)+Sname+tix+' '+Lu+' ='+t]
	    endelse
	  endif
	  if grnm(idx) eq '(Vlog) ' then if n_elements(tmp) gt 1 then PV=tmp
;	************************
;	Check for ATT parameters
;	************************
	  if (natts gt 0) then FOR j=0,natts-1 do begin
	   HDx_SD_ATTRINFO,sdsid,j,NAME=Aname,TYPE=tip,COUNT=count,DATA=tmp
	   if count gt 0 then begin
	    if (strpos(strlowcase(Aname),'monitor') eq 0) and (n_elements(N) eq 1) and (N(0) eq 0) then N=tmp
	    if (tip eq 'BYTE') then begin on_ioerror,misOy & t=strtrim(string(byte(tmp)>32b),2) & tmp=t & count=1 & tip='STRING' & misOy:ON_IOERROR,mis & endif
	    if (count le 9) and (Aname ne 'axis') and (Aname ne 'signal') and (Aname ne 'units') and (Aname ne 'axes') then begin
		if (tip eq 'STRING') then begin Aname=Aname+': '+strmid(tmp(0),0,40) & tmp=0 & endif
		on_ioerror,misOa & t=0 & t=float(tmp)   & misOa:ON_IOERROR,mis & p=[p,t] & t=string(t)
		if n_elements(t) gt 1 then tix='_'+strtrim(sindgen(n_elements(t)),2) else tix=''
		pa_txt=[pa_txt,grnm(idx)+Aname+tix+' = '+t] & t(*)=' ' & p_txt=[p_txt ,grnm(idx)+Aname+tix+' ='+t] & endif
	   endif
	  ENDFOR
;	********************
	endif & HDx_SD_ENDACCESS, sdsid
    ENDFOR
    ;***************
    ;Sort parameters
    ;***************
    if (n_elements(p) gt 1) and (p_txt(0) eq ' =') and (p(0) eq 0) then begin p_txt=p_txt(1:*)
        idx=sort(strmid(p_txt,0,40)) & p_txt=p_txt(idx) & p=p(idx+1) & pa_txt=pa_txt(idx+1) & endif
 endif

 if NXentry gt 0 then HDx_VG_DETACH, NXentry

 ;**********************************
 ;Show what we have seen for browser
 ;**********************************
 if D88 eq -88 then begin Data=[time,' ']
      Data=[Data,' SOURCE:         '+src,' '  ,' HISTORY:        '+his ,' ']
  if (lampF  eq 1)  then $
	Data=[Data,' X_SIZE:         '+xd       ,' Y_SIZE:         '+yd      ,' Z_SIZE:         '+zd,space]
	Data=[Data,' FORMAT:         '+NXF      ,' TYPE:           '+tiip,' ',' RANGES:         '+lim ,' ']
	Data=[Data,' TITLES: '+wt,'      X: '+xt,'      Y: '+yt              ,'      Z: '+zt,'  OTHER: '+ot,' ']

	Data=[Data,' PARAMETERS:',' ----------']
	for i=0,n_elements(pa_txt)-1 do $
	Data=[Data,' * '+pa_txt(i)]

 ;if (lampF  eq 1)  then Data=[Data,' ',' MACHINE: '+mach,' ']

 ;****************************************
 ;Else give back the data in correct order
 ;****************************************
 endif else begin siz=SIZE(Data)
 	;*****
 	;Isis?
 	;*****
	if (siz(0) eq 2) and (n_elements(Isis_SPEC) gt 1) then begin
	   if siz(2)  eq Isis_NSP1(0)+1 then begin DATA=DATA(*,1:*) & siz=SIZE(Data) & endif
	   if n_elements(Isis_MDET) gt 0 then begin
	      Isis_MDET=Isis_MDET-1
	      Isis_SPEC=Isis_SPEC-1
	      N  =Data (*,Isis_SPEC(Isis_MDET))
	      Mdist=Isis_LEN2(Isis_MDET)
	      P    =[P,MDIST]
	      P_TXT=[P_TXT,'Distance Monitor '+strtrim(string(indgen(n_elements(N))+1),2)+' ']
	      Isis_SPEC(Isis_MDET)=-1 & Isis_SPEC=Isis_SPEC(where(Isis_SPEC ge 0))
	      Y(Isis_MDET)=-1         & idn =where(Y ge 0)
	      Y  =Y(idn)
	      Isis_LEN2=Isis_LEN2(idn)
	   endif
	   idn =sort (Y) & Y=float(Y(idn))
	   PV  =Isis_LEN2(idn)
	   X   =float(X) & if xt eq '' then xt='Channels'
	   DATA=DATA (*,Isis_SPEC(idn)) & siz=SIZE(Data)
	endif
 	;**********
 	;Histogram?
 	;**********
 	if   siz(0) ge 1 then begin sxs=SIZE(x) & sys=SIZE(y)
	 if  sxs(0) eq 1 then if (sxs(1) ne siz(1))  and (sxs(1) ne siz(2))   then $
	                      if (sxs(1) eq siz(1)+1) or (sxs(1) eq siz(2)+1) then begin
				x =x+(shift(x,-1)-x)/2. & x=x(0:n_elements(x)-2)
				ot=ot+' (histogram)
			      endif
	 if  sys(0) eq 1 then if (sys(1) ne siz(1))  and (sys(1) ne siz(2))   then $
	                      if (sys(1) eq siz(1)+1) or (sys(1) eq siz(2)+1) then begin
				y =y+(shift(y,-1)-y)/2. & y=y(0:n_elements(y)-2)
			      endif
	endif
 	;**********
 	;Transpose?
 	;**********
	if (siz(1) eq n_elements(y))    and (siz(2) eq n_elements(x)) then transxy=1 else transxy=0
  	if  siz(0) ge 2 then if (transp) or (siz(1) ne siz(2)) then $
	if (transxy) or (transp) then begin
		if (siz(1) lt siz(2)*2/3) then transp=1
		trans2=transxy*transp
		if (SIZE(x))(0)  ge 2  then if (not trans2) then x =transpose(x)
		if (SIZE(y))(0)  ge 2  then if (not trans2) then y =transpose(y)
		if (transp) then begin Data=transpose(Data)
		                       if (SIZE(e))(0) ge 2 then e=transpose(e)
		endif
		if (not trans2) then  begin tmp=yt & yt=xt & xt=tmp  & tmp=y & y=x & x =tmp & endif
		if (SIZE(n)) (0) ge 2  then if (SIZE(n)) (2) eq (SIZE(data))(1) then n =transpose(n)
		if (SIZE(pv))(0) ge 2  then if (SIZE(pv))(2) eq (SIZE(data))(1) then pv=transpose(pv)
	endif
	if (siz(siz(0)+1) eq 12) then Data=long (Data)
 	if (siz(siz(0)+1) eq 13) then Data=float(Data)
 endelse

 HDx_SD_END, sdid
;**********
 HDx_CLOSE , fid
;*********
endif
!quiet=Quiet
return
mis:	print,!err_string
end

;-----------------------------------------------------------------------------
;*****************************************************************************

	FUNCTION read_het, inst, path, filename, status, datp

; Reads in HET data.  Requires LAMP running on Windows, and ISIS_GI.DLL and
; ISIS_GI.DLM in the '..rsi\idl\bin\bin.x86' directory.

;						JRS  27/3/02
;
;	w1(nchan,nspec) is counts, normalised to channel bin width
;	n1(nchan,0) = M1 counts/mus
;	n1(nchan,1) = M1 errors
;	n1(nchan,2) = M2 counts/mus
;	n1(nchan,3) = M2 errors
;	n1(nchan,4) = M3 counts/mus
;	n1(nchan,5) = M3 errors
;	n1(nchan,6) = M4 counts/mus
;	n1(nchan,7) = M4 errors
;	n1(nchan,8) = Lineup Monitor counts/mus
;	n1(nchan,9) = Lineup Monitor errors
;	n1(nchan,10) = time channel widths
;	x1(nchan) = time of flight
;	y1(nchan) = 2 theta
;	z1(nspec) = L2 for each detector
;
;-----------------------------------------------------------------------------
;*****************************************************************************

	iprint = 0		;turn on debugging messages

; Make OpenGenie friendly path variable
	a = STR_SEP(path,'\')
	b = SIZE(a)
	cpath = a(0)
	FOR j = 1, b(1)-1 DO cpath = cpath+'\\'+a(j)
	cpath = STRTRIM(cpath,2)

; Check data file exists

	in_file = 'HET'+STRMID(filename,1)+'.RAW'
	j = FINDFILE(path+in_file,COUNT=found)
	IF (found EQ 0) THEN BEGIN
		PRINT, 'File: '+path+in_file+' not found'
		GOTO, finished
	ENDIF ELSE BEGIN
		PRINT, 'Reading run ',LONG(filename)
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'Read_het: finished checking data'
;-----------------------------------------------------------------------------
;*****************************************************************************
; OpenGenie read in routines using ISIS_GI.DLM

	i = GI_activate_session('GENIE', iprint, iprint)
	i = GI_select_source(cpath+in_file)
	i = GI_get('h_HDR',  'HDR',  0)
	i = GI_get('h_NSP1', 'NSP1', 0)
	i = GI_get('h_NTC1', 'NTC1', 0)
	i = GI_get('h_RUN',  'RUN',  0)
	i = GI_get('h_TITL', 'TITL', 0)
	i = GI_get('h_SPEC', 'SPEC', 0)
	i = GI_get('h_TTHE', 'TTHE', 0)
	i = GI_get('h_CNT1', 'CNT1', 0)
	i = GI_get('h_LEN2', 'LEN2', 0)
	i = GI_get('h_NMON', 'NMON', 0)
	i = GI_get('h_MDET', 'MDET', 0)
	i = GI_get('h_NDET', 'NDET', 0)
	i = GI_get('h_IVPB', 'IVPB', 0)
	i = GI_get('h_RPB',  'RPB',  0)
	i = GI_get('h_DATA', '',0)
	i = GI_transfer('h_HDR',  '-->', 'STRING',   infob,  1, [80L])
	i = GI_transfer('h_NSP1', '-->', 'INT32',    nspec, 0, 0)
	i = GI_transfer('h_NTC1', '-->', 'INT32',    nchan, 0, 0)
	i = GI_transfer('h_RUN',  '-->', 'INT32',    numor, 0, 0)
	i = GI_transfer('h_TITL', '-->', 'STRING',   title, 1, [80L])
	i = GI_transfer('h_NDET', '-->', 'INT32',    ndet, 0, 0)
	i = GI_transfer('h_SPEC', '-->', 'INT32[]',  specarr, 1, [ndet])
	i = GI_transfer('h_TTHE', '-->', 'FLOAT32[]',thetarr, 1, [ndet])
	i = GI_transfer('h_CNT1', '-->', 'INT32[]',  cnt, 1, [(nspec+1)*(nchan+1)])
	i = GI_transfer('h_LEN2', '-->', 'FLOAT32[]',l2arr, 1, [ndet])
	i = GI_transfer('h_NMON', '-->', 'INT32',    nmon, 0, 0)
	i = GI_transfer('h_MDET', '-->', 'INT32[]',  mdet, 1, [nmon])
	i = GI_transfer('h_IVPB', '-->', 'INT32[]',  ivpb, 1, [64])
	i = GI_transfer('h_RPB',  '-->', 'INT32[]',  rpb, 1, [32])
	i = GI_transfer('h_DATA.X','-->','FLOAT64[]',xvals,1, [nchan+1])

	IF (iprint GT 0) THEN PRINT, 'Read_HET: finished reading data'
;------------------------------------------------------------------------------
;******************************************************************************
; Data Manipulations

	IF (iprint GT 0) THEN PRINT,'Read_HET: Arranging workspace...'
	w_out = REFORM(cnt,nchan+1,nspec+1)
	w_out = FLOAT(w_out(1:*,1:*)) ;remove first time channel and spectrum 0 (unassigned data)
	e_out = SQRT(w_out)

	IF (iprint GT 0) THEN BEGIN
		PRINT, 'Nspec:  ',nspec
		PRINT, 'Ndet:   ',ndet
		PRINT, 'Nchan:  ',nchan
	ENDIF

; assign spectra indexes

	IF (iprint GT 0) THEN PRINT,'Read_HET: Assigning 2theta and L2...'
	y_out = FLTARR(nspec)
	z_out = FLTARR(nspec)
	y_out(specarr-1) = thetarr		;2 theta indexes
	z_out(specarr-1) = l2arr		;L2 indexes

; normalise data to channel widths

	IF (iprint GT 0) THEN PRINT,'Read_HET: Normalising to channel widths..'
	i = INDGEN(nchan) + 1
	tbin = xvals(i) - xvals(i-1)		;time channel width array
	FOR i=0,nspec-1 DO BEGIN
		w_out(*,i) = w_out(*,i)/tbin
		e_out(*,i) = e_out(*,i)/tbin
	ENDFOR

; prepare monitor array

	IF (iprint GT 0) THEN PRINT,'Read_HET: Assigning monitors...'
	m_ind = specarr(mdet-1)			;monitor indexes
	sm = SIZE(m_ind)
	lineupm_ind = m_ind(sm(1)-1) + 1
	m_ind = [m_ind,lineupm_ind]		;monitor & lineup indexes
	m = w_out[*,m_ind-1]			;monitors 1 to 3
	em = e_out[*,m_ind-1]			;errors
	narr = [[m(*,0)],[em(*,0)]]
	sm = SIZE(m)
	FOR i = 1,sm(2)-1 DO narr = [[narr],[m(*,i)],[em(*,i)]]
	narr = [[narr],[tbin]]

; exclude monitors in data array

	IF (iprint GT 0) THEN PRINT,'Read_HET: Assigning data...'
	sw = SIZE(w_out)
	w_ind = REPLICATE(1L, sw(2))
	w_ind(m_ind-1) = 0L
	i = WHERE(w_ind EQ 1)
	tmp = w_out[*,i] & w_out = tmp
	tmp = e_out[*,i] & e_out = tmp
	z_out = z_out[i]
	y_out = y_out[i]

	IF (iprint GT 0) THEN PRINT, 'Read_HET: finished data manipulation'

;-----------------------------------------------------------------------------
;*****************************************************************************
;parameters

	p = FLTARR(31)
	p_txt = STRARR(31)

	numaps = FLOAT(STRMID(infob,72,8))

	p(0) = rpb(0)		& p_txt(0) =  '0)  Run duration (s)           ='
	p(1) = rpb(0)*10.0	& p_txt(1) =  '1)  Run duration (0.1s)        ='
	p(2) = nchan		& p_txt(2) =  '2)  Number of time channels    ='
	p(3) = rpb(13)		& p_txt(3) =  '3)  Counts in M1               ='
	p(4) = rpb(14)		& p_txt(4) =  '4)  Counts in M2               ='
	p(5) = rpb(15)		& p_txt(5) =  '5)  Counts in M3               ='
	p(6) = numaps		& p_txt(6) =  '6)  muAmp Hours                ='
	p(7) = ivpb(21)		& p_txt(7) =  '7)  Detector vaccumm (0/1)     ='
	p(8) = 5146.83		& p_txt(8) =  '8)  Elastic t-o-f   (4m bank)  ='
	p(9) = 4647.61		& p_txt(9) =  '9)  Elastic t-o-f (2.5m bank)  ='
	p(10) = numor		& p_txt(10) = '10) Numor                      ='
	p(11) = 0.0		& p_txt(11) = '11) Sample Temperature (K)     ='
	p(12) = ivpb(23)	& p_txt(12) = '12) Chopper frequency (50)    ='
	p(13) = xvals(nchan-1)	& p_txt(13) = '13) Repetition period (musecs) ='
	p(14) = ivpb(26)	& p_txt(14) = '14) Slit package               ='
	p(15) = ivpb(15)	& p_txt(15) = '15) Main shutter (0/1)         ='
	p(16) = ivpb(16)	& p_txt(16) = '16) Thermal shutter (0/1)      ='
	p(17) = ivpb(20)	& p_txt(17) = '17) Moderator type             ='
	p(18) = 0.0		& p_txt(18) = '18) Channel width is variable, contained in n1(*,10)         '
	p(19) = nchan		& p_txt(19) = '19) No. of channels used       ='
	p(20) = 0.0		& p_txt(20) = '20) TOF delay variable                                       '
	p(21) = 0.0		& p_txt(21) = '21) Incident Energy            ='
	p(22) = 0.0		& p_txt(22) = '22) Not used                   ='
	p(23) = 0.0		& p_txt(23) = '23) Not used                   ='
	p(24) = 0.0		& p_txt(24) = '24) Not used                   ='
	p(25) = 0.0		& p_txt(25) = '25) Not used                   ='
	p(26) = 0.0		& p_txt(26) = '26) Not used                   ='
	p(27) = 0.0		& p_txt(27) = '27) L2 is variable, contained in z1                          '
	p(28) = 0.0		& p_txt(28) = '28) Not used                   ='
	p(29) = 0.0		& p_txt(29) = '29) Not used                   ='
	p(30) = ndet		& p_txt(30) = '30) Number of detectors        ='
;-----------------------------------------------------------------------------
;*****************************************************************************
;Return data and parameters

	STATUS = 0
	DATA = w_out
	other_tit='HET: #'+STRTRIM(STRING(numor),2)+STRMID(infob,52,12)
	datp = {X:xvals(1:*), $
		Y:y_out, $
		Z:z_out, $
		E:e_out, $
		P:p, $
		PAR_TXT:p_txt, $
		W_TIT:title,N:narr, $
		X_TIT:'Time of flight (!4m!3s)', $
		Y_TIT:'Detector Angle (degrees)',$
		OTHER_TIT:other_tit}
	IF (iprint GT 0) THEN PRINT,'Read_HET: Returning data...'
	RETURN, DATA

finished:
	IF(iprint GT 0) THEN PRINT, 'Read_HET: finished'

	END
;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION read_mcstas, in_file

;Reads McStas 1d and 2d monitor files and scan files into LAMP
;
;						JRS 22/2/02
;
;-------------------------------------------------------------------------------
;*******************************************************************************
	
	iprint=0	; if iprint>0, show debugging messages
	IF (iprint GT 0) THEN PRINT,'Start input:'
	take_datp, dat

	OPENR, 1, in_file, ERROR=err
	IF (err NE 0) THEN BEGIN
		PRINT, !ERR_STRING
		GOTO, finished
	ENDIF

	PRINT,'Opening McStas file: '+STRTRIM(in_file,2)

	nparams = 0
	param = STRARR(100)
	line=' '

;------------------------------------------------------------------------------
; Read Header block	

	FOR i = 1,100 DO BEGIN
		READF, 1, line
		IF(STRPOS(line,'#') EQ 0) THEN BEGIN
			a = STRPOS(line,':')
			head = STRMID(line,2,a-2)
			linepos = STRMID(line,a+2)
			IF (head EQ 'Instrument-source') THEN inst = linepos
			IF (head EQ 'Date') THEN date = linepos
			IF (head EQ 'Ncount') THEN READS, linepos, N
			IF (head EQ 'Param') THEN BEGIN
				param(nparams) = linepos
				nparams = nparams + 1
			ENDIF
			IF (head EQ 'type') THEN BEGIN
				b = STRPOS(line,'(') & c = STRPOS(line,')')
				IF(STRMID(line, b-2, 2) EQ '1d') THEN BEGIN
					READS, STRMID(line,b+1,c-b+1), xdim
					ydim = 1
				ENDIF ELSE BEGIN
					READS, STRMID(line,b+1,c-b+1), xdim, ydim
				ENDELSE
			ENDIF
			IF (head EQ 'component') THEN comp = linepos
			IF (head EQ 'title') THEN title = linepos
			IF (head EQ 'xlabel') THEN BEGIN
				b = STRPOS(line,"'") & c = RSTRPOS(line,"'")
				dat.x_tit = STRMID(line,b+1,c-b-1)
			ENDIF
			IF (head EQ 'ylabel') THEN BEGIN
				b = STRPOS(line,"'") & c = RSTRPOS(line,"'")
				dat.y_tit = STRMID(line,b+1,c-b-1)
			ENDIF	
			IF (head EQ 'xylimits') THEN READS, STRMID(line,a+2),xmin,xmax,ymin,ymax
			IF (head EQ 'xlimits') THEN READS, STRMID(line,a+2),xmin,xmax
			IF (head EQ 'variables') THEN BEGIN
				parts = STR_SEP(STRMID(line,a+2),' ')
				sp = SIZE(parts)
				keep = WHERE(STRLEN(parts) NE 0)
				parts = parts(keep)
				sp = SIZE(parts)
				IF(N_ELEMENTS(comp) EQ 0) THEN comp = ' '
			ENDIF

;-------------------------------------------------------------------------------
; Read data

		ENDIF ELSE BEGIN
			POINT_LUN, 1, 0
			heads = STRARR(i-1)
			READF, 1, heads
			xdim = FIX(xdim) & ydim = FIX(ydim)
			IF(ydim NE 1) THEN BEGIN
			w_out = DBLARR(xdim,ydim) & e_out = DBLARR(xdim,ydim)
				READF, 1, w_out
				READF, 1, line
				READF, 1, line
				READF, 1, e_out
			ENDIF ELSE BEGIN
				in = DBLARR(sp(1),xdim)
				nscans = (sp(1) - 1)/2
				w_out = DBLARR(xdim,nscans)
				e_out = DBLARR(xdim,nscans)
				w_index = INDGEN(nscans)*2 + 1
				e_index = w_index + 1
				READF, 1, in
				x_out = in(0,*)
				FOR i = 0,nscans-1 DO BEGIN
					w_out(*,i) = in(w_index(i),*)
					e_out(*,i) = in(e_index(i),*)
				ENDFOR
			ENDELSE
			i = WHERE(w_out LT 1e-20) & w_out(i) = 0.0
			i = WHERE(e_out LT 1e-20) & e_out(i) = 0.0
			CLOSE, 1
			GOTO, nomoreheads
		ENDELSE
	ENDFOR

nomoreheads:

	IF(ydim NE 1) THEN x_out = FINDGEN(xdim)*(xmax - xmin)/(xdim - 1) + xmin
	IF(ydim NE 1) THEN y_out = FINDGEN(ydim)*(ymax - ymin)/(ydim - 1) + ymin
	IF(comp NE ' ') THEN dat.w_tit = title + ': ' + comp ELSE dat.w_tit = title
	n_out = N
	par = FLTARR(nparams + 1)
	partxt = STRARR(nparams + 1)
	ot = ' '
	par(0) = N
	partxt(0) = 'Counts='
	FOR i = 0,nparams-1 DO BEGIN
		a = STR_SEP(param(i),'=')
		par(i + 1) = FLOAT(a(1))
		partxt(i + 1) = a(0)
		ot = ot + param(i) + ' '
	ENDFOR
	dat.other_tit = date + ot + ' Inst = ' + inst
	mod_datp, dat, "x", x_out
	mod_datp, dat, "y", y_out
	mod_datp, dat, "e", e_out
	mod_datp, dat, "n", n_out
	mod_datp, dat, "p", par
	mod_datp, dat, "par_txt", partxt
	give_datp, dat

finished:
	RETURN, w_out
	END
	
	
		
						
function read_mibemol, INST , PATH , FILENAME , STATUS , DATP
;*****************************************************************************
;** Reading Data files from raw MiBeMol data files
;** input file #1 : ????.asc file = contains raw DATA (S(n_channel,2theta))
;** input file #2 : ????.ust files = contains PARAMETERS of the run # ????
;**
;** Stephane Rols 11/2001 srols@anl.gov
;** modified by S. Rols (put free_lun ...) on 03/18/02
;*****************************************************************************

; ** Initializing of some parameters and arrays
; ** *******************************************
print,'Begin reading ...'
iprint=0
DATA  =0
PAR_TXT=STRARR(31) & P=fltarr(31)
n_channels=512 & str_n_channels=STRCOMPRESS(STRING(n_channels-4),/REMOVE_ALL)
xv=FINDGEN(n_channels-4)+1.							; The channel array
STATUS=7
;CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

; ** First Step : Read the parameters of the run # FILENAME contained
; ** in the FILENAME.ust file
; ** ****************************************************************

ON_IOERROR, no_file
FILENAME=STRMID(FILENAME,2,4)
print, PATH+'d'+FILENAME+'.ust'
OPENR,unit, PATH+'d'+FILENAME+'.ust',/get_lun                   ;Open the ????.ust file
print, PATH+'d'+FILENAME+'.ust'

; ** File is open ... now read it:

ON_IOERROR, read_err
STATUS=13
str='stringv'
READF,unit,str										; Read the first blank line
READF,unit,str										; Read the second line ... but don't record it ... we already have the run # in FILENAME
READF,unit,str									; Read start date and time line
str_date=STRMID(str,0,10) & str_time=STRMID(str,11,8)
READF,unit,str										;Read the second blank line
READF,unit,str										; Read the '# of subrun asked' line ... don't care
READF,unit,str										; Read the 'current # of subrun ' line ... don't care
READF,unit,str									; Read the Ratemeter control line
str_ratemT=STRMID(str,0,17) & str_act=STRMID(str,18,6)
READF,unit,str										; Read the Temperature control param line ... don't care
READF,unit,str										; Read the temperature asked ... don't care
READF,unit,str									; Read the initial measured temperature of the sample
str=STRCOMPRESS(str,/REMOVE_ALL) & str_temp_i=STRMID(str,29,7)
READF,unit,str									; Read the final measured temperature of the sample
str=STRCOMPRESS(str,/REMOVE_ALL) & str_temp_f=STRMID(str,27,7)
READF,unit,str										; Read the final temp regulation line ... don't care
READF,unit,str									; Read the TOF delay
str=STRCOMPRESS(str,/REMOVE_ALL) & str_delay=STRMID(str,9,STRLEN(str)-9)
READF,unit,str									; Read the channel width value
str=STRCOMPRESS(str,/REMOVE_ALL) & str=STRMID(str,16,STRLEN(str)-16) & str_ch_width=strcompress(string(float(str)/10.),/REMOVE_ALL)
READF,unit,str										; Read the time preset line ... don't care
READF,unit,str										; Read the Exp. param line ... don't care
READF,unit,str										; Read dashed line
READF,unit,str									; Read the run title
str_rtitle=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read the user names
str_uname=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read the incident wavelength
str_lambda=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read the sample holder description
str_s_holder=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read the sample angle
str_sangle=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read the frequency of chopper 4
str_fre_ch4=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read value of ratio
str_ratio=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read value of ratio2 (chopper #)
str_ratio2=STRMID(str,23,STRLEN(str)-23)
READF,unit,str									; Read the number of detector used
str_n_spectra=STRMID(str,30,STRLEN(str)-30)
READF,unit,str										; Read "position of the detectors:" line

; ** Now read the value of the 2theta angle in degree for each detector
n_spectra=FIX(str_n_spectra) & n_spectra=n_spectra(0)
yv=FLTARR(n_spectra) & str_yv=STRARR(n_spectra)
nlines=1 & nlines=n_spectra/10
;FOR i=0,7 DO READF,unit,str,FORMAT='(A6)'
FOR i=1,nlines DO BEGIN
READF,unit,str,FORMAT='(A60)'
FOR j=0,9 DO BEGIN
yv((i-1)*10+j)=FLOAT(STRCOMPRESS(STRMID(str,j*6,6),/REMOVE_ALL))
ENDFOR
ENDFOR
IF nlines NE n_spectra*10 THEN BEGIN
imax=n_spectra-nlines*10
str_format="'(A"+STRCOMPRESS(STRING(6*imax),/REMOVE_ALL)+")'" & str_format=str_format(0)
READF,unit,str,FORMAT='(A60)'
FOR i=0,imax-1 DO yv(10*nlines+i)=FLOAT(STRCOMPRESS(STRMID(str,i*6,6),/REMOVE_ALL))
ENDIF
free_lun,unit

IF iprint THEN PRINT,yv

; ** Second Step : Read the DATA of the run # FILENAME contained
; ** in the FILENAME.asc file
; ** ****************************************************************

ON_IOERROR, no_file
print, PATH+'d'+FILENAME+'.asc'
OPENR,unit, PATH+'d'+FILENAME+'.asc',/get_lun                   ;Open the ????.asc file
print, PATH+'d'+FILENAME+'.asc'

; ** File is open ... now read it:

DATA_LECT=FLTARR(n_channels,n_spectra)                    ;=S(t,2theta)
ON_IOERROR, read_err
STATUS=13
READF,unit,DATA_LECT
free_lun,unit
;CLOSE,unit

; ** Data are read ... Now extract the monitor and the error arrays
; ** and pass into the DATP structure
; ** ***************************************************************

DATA=DATA_LECT(0:n_channels-5,1:n_spectra-1)
DATPN=DATA_LECT(n_channels-4,*)
DATAE=SQRT(DATA)
DATPPV=DATA_LECT(n_channels-3,1:n_spectra-1)
DATPX=xv & DATPY=yv(1:n_spectra-1)
DATPW_TIT=str_rtitle
DATPX_TIT='Channel #'
DATPY_TIT='2 theta (degree)'
DATPOTHER_TIT=str_uname
DATPTIME=str_date

; ** Also find the elastic channel and pass it into the DATP str
; ** ****************************************************************

x_in=xv & w_in=DATA &
i=INDGEN(n_spectra)
xtot=x_in & ytot=TOTAL(w_in(*,i),2) & etot=SQRT(ytot)
y0=MAX(ytot,i0)   & xmin=xtot((i0-20)>0) & xmax=xtot((i0+20)<(n_channels-1))
fitgauss, xtot, ytot, etot, xmin, xmax, gauss, dgauss
chel=gauss(2) & str_chel=STRCOMPRESS(STRING(chel),/REMOVE_ALL)   ; elastic channel

; ** Pass into the DATP structure
; ** *****************************

; ** Now write the read parameters in the DATP.P corresponding array
; ** ***************************************************************

P(0)=0.             &         PAR_TXT(0)='Not used                           ='
;P(0)=str_rtitle       &         PAR_TXT(0)='Experimental Title                 ='
P(1)=0.             &         PAR_TXT(1)='Not used                           ='
P(2)=float(str_n_channels)   &         PAR_TXT(2)='Number of reserved channels        =' 
P(3)=0.             &         PAR_TXT(3)='Not used                           ='
;P(3)=str_date         &         PAR_TXT(3)='Start Date                         ='
P(4)=0.             &         PAR_TXT(4)='Not used                           ='
;P(4)=str_time         &         PAR_TXT(4)='Start Time                         ='
P(5)=0.             &         PAR_TXT(5)='Not used                           ='
;P(5)=str_act          &         PAR_TXT(5)='Ratemeter Control                  ='
P(6)=float(str_temp_i)	  	  &		      PAR_TXT(6)='Initial Temperature                ='
P(7)=float(str_temp_f)	   	  &		      PAR_TXT(7)='Final Temperature                  ='
P(8)=float(str_sangle)	      &		      PAR_TXT(8)='Sample angle (deg.)                ='
P(9)=float(str_chel)         &         PAR_TXT(9)='Elastic peak position (channel)    ='
P(10)=float(FILENAME)        &         PAR_TXT(10)='Numor                              ='
P(11)=float(str_temp_f)      &         PAR_TXT(11)='Sample temperature (K)             ='
P(12)=0.             &         PAR_TXT(12)='Not used                           ='
;P(12)=str_uname		    &		      PAR_TXT(12)='User Name                          ='
P(13)=float(str_fre_ch4)	    &		      PAR_TXT(13)='Frequency Chopper 4                ='
P(14)=float(str_ratio)	  	  &		      PAR_TXT(14)='Ratio                              ='
P(15)=float(str_ratio2)	    &		      PAR_TXT(15)='Ratio 2                            ='
P(16)=0.            &         PAR_TXT(16)='Not used                           ='
P(17)=0.             &         PAR_TXT(17)='Not used                           ='
;P(17)=str_s_holder	  &		      PAR_TXT(17)='Sample Holder type                 ='
P(18)=float(str_ch_width)	  &		      PAR_TXT(18)='Channel width (microsec.)          ='
P(19)=510.           &         PAR_TXT(19)='Number of channels used            ='
P(20)=float(str_delay)		    &		      PAR_TXT(20)='TOF delay (microsec.)              ='
P(21)=float(str_lambda)      &		      PAR_TXT(21)='Wavelength (angstroms)             ='
P(22)='0.'            &         PAR_TXT(22)='Not used                           ='
P(23)='0.'            &         PAR_TXT(23)='Not used                           ='
P(24)='0.'            &         PAR_TXT(24)='Not used                           ='
P(25)='0.'            &         PAR_TXT(25)='Not used                           ='
P(26)='0.'            &         PAR_TXT(26)='Not used                           ='
P(27)=3.58		      &		      PAR_TXT(27)='Distance Det - Sample (meter)      ='
P(28)='0.'            &         PAR_TXT(28)='Not used                           ='
P(29)='0.'            &         PAR_TXT(29)='Not used                           ='
P(30)=float(str_n_spectra)   &		      PAR_TXT(30)='Number of angles                   ='


DATP={X:			DATPX,			$
	  Y:			DATPY,			$
	  W_TIT:		DATPW_TIT,		$
	  X_TIT:		DATPX_TIT,		$
	  Y_TIT:		DATPY_TIT,		$
	  N:			DATPN,			$
	  E:			DATAE,			$
	  OTHER_TIT:	DATPOTHER_TIT,	$
	  TIME:			DATPTIME,		$
	  PV:			DATPPV,			$
	  P:			P,				$
	  PAR_TXT:		PAR_TXT }
STATUS=0
print,'Reading successful !'
read_err:  FREE_LUN,unit                             ;Free the unit number
no_file:

RETURN, DATA                                         ;Return the data values
;************
END
function read_nexus, INST , PATH , FILENAME , STATUS , DATP
;******* **********
;**
;**	Standard call for a data-read function interfacing LAMP.

STATUS=24
DATA  =0
if !version.release lt '4.0' then begin print,"IDL version is too low !!!",string(7b) & return,DATA & endif
FileN=PATH+FILENAME(0)
if n_elements(FILENAME) gt 1 then img=FILENAME(1) else img=1

i=strpos(FileN,'{') & if i gt 1 then begin j=strpos(FileN,'}')
                         if j gt i+1  then img=strmid(FileN,i+1,j-i-1)
                         FileN=strmid(FileN,0,i) & endif

read_hdf, FileN    , Data, XC=x, YC=y , ZC=z , E=e  , N=n        $
                         , PR=p, PV=pv, PAR_TXT=p_txt            $
                         , W_tit=wt   , X_tit=xt , Y_TIT=yt      $
                         , Z_tit=zt   , OTHER_TIT=ot , SNAP=snap $
                         , SOURCE=src , Img=img

if n_elements(Data) gt 1 then STATUS=0

DATP={X:      x   , Y:y , Z:z , E:e , N:n   ,$
      W_TIT:  wt  , X_TIT:xt  , Y_TIT:yt    ,$
      Z_TIT:  zt  , OTHER_TIT:ot            ,$
      P:      p   ,    $
      PAR_TXT:p_txt,   $
      PV:     pv       }
;     **********************

 RETURN, DATA
;************
 END

FUNCTION readon,Win,numor=numor,monitor=monitor,time=time,maxnumor=maxnumor,$
				noplot=noplot,noprint=noprint,$
				minmonitor=minmonitor,minpsd=minpsd,mintime=mintime
;********
;**
;** The call is w6=rdand(62571,62572)&normalize,w6,24e6&w7=readon(w6,mon=24e6)
;** or w2=rdrun(82699)&normalize,w2,1e5&w3=readon(w2,mon=1e5)
;** This function will append all more recent numors to a given workspace
;** starting from the maximum numor (plus one) in the given workspace
;** or an optionally given numor (greater than the maximum numor in the workspace)
;** Last modification 02-May-02 by Th.Hansen: noprint and noplot
;** Last modification 06-May-02 by Th.Hansen: min(psd/monitor/time)

take_datp,datp
Wout=Win
E=datp.e
Y=datp.y
PV=datp.pv
N=datp.n
IF NOT KEYWORD_SET(minpsd) THEN minpsd=0
IF NOT KEYWORD_SET(mintime) THEN mintime=0
IF NOT KEYWORD_SET(minmonitor) THEN minmonitor=0
IF NOT KEYWORD_SET(numor) THEN numor=0 ELSE numor=numor-1
IF NOT KEYWORD_SET(maxnumor) THEN maxnumor=999999
IF NOT KEYWORD_SET(monitor) AND NOT KEYWORD_SET(monitor) THEN BEGIN
	IF datp.p(39) GT 0 THEN monitor=datp.p(39)
ENDIF
numor=(numor>MAX(datp.pv(29,*)))+1
numor=ROUND(numor)
IF NOT KEYWORD_SET(noprint) THEN PRINT,'First numor to append: ',numor
d=1
REPEAT BEGIN
	;PRINT,'Try to read numor',numor
	W=rdrun(numor,datp=d)
	IF N_ELEMENTS(W) GT 1 AND TOTAL(W(*,0)) GT minpsd AND d.n(0) GT minmonitor AND d.n(1) GT mintime THEN BEGIN
		IF NOT KEYWORD_SET(noprint) THEN PRINT,'Appending numor',numor
		IF NOT KEYWORD_SET(noplot) THEN SEE,w1,/below
		IF KEYWORD_SET(monitor) THEN BEGIN
			W=W/d.n(0)*monitor
			d.E=d.E/d.n(0)*monitor
			d.N=d.N/d.n(0)*monitor
		ENDIF ELSE IF KEYWORD_SET(time) THEN BEGIN
			W=W/d.n(1)*time
			d.E=d.E/d.n(1)*time
			d.N=d.N/d.n(1)*time
		ENDIF
		Wout=[[Wout],[W]]
		E=[[E],[d.e]]
		Y=[Y,d.y]
		PV=[[PV],[d.pv]]
		N=[[[N]],[[d.N]]]
	ENDIF ELSE PRINT,'Not appending',numor, TOTAL(W(*,0)), d.n(0:1<(n_elements(d.n)-1))
	numor=numor+1
ENDREP UNTIL N_ELEMENTS(W) LE 1 OR numor GT maxnumor
IF NOT KEYWORD_SET(noprint) THEN PRINT,'Last Numor',numor-2
mod_datp,datp,'e',E
mod_datp,datp,'y',Y
mod_datp,datp,'pv',PV
mod_datp,datp,'n',N
pos=STRPOS(datp.other_tit,'Run ',0)
pos2=STRPOS(datp.other_tit,'*d20',0)
IF NOT KEYWORD_SET(noprint) THEN print,pos
subtitle=datp.other_tit
subtitle=STRMID(subtitle,0,pos+4)$
	+STRCOMPRESS(MIN(ROUND(datp.pv(29,*))),/RE)+':'$
	+STRCOMPRESS(MAX(ROUND(datp.pv(29,*))),/RE)$
	+STRMID(subtitle,pos2,strlen(subtitle)-pos2)
IF NOT KEYWORD_SET(noprint) THEN PRINT,subtitle
datp.other_tit=subtitle
mod_datp,datp,'e',E
give_datp,datp
return, Wout
end
pro did_readf,line,fmt,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10
;** *********
;**
for i=1,n_elements(fmt) do begin 
    if fmt(i-1) gt 0 then line=strmid(line,fmt(i-1),200)
    ii=execute('reads,line,v'+strtrim(string(i),2)+',line')
endfor
end

pro READ_ORG, pthfil, w,x,y,z,e, head,step,m,n,f,a,b,c,d, org,pair,mxi, status=pp2,ws=ws,strtit=strtit
;** ********
;**
on_ioerror,misopen
OPENR,u,pthfil,/get_lun & line=' '
on_ioerror,misread

case org of
0:	fmt=[a,b]
1:	fmt=[a,b,c]
2:	fmt=[a,b,c]
3:	fmt=[a,b,c,d]
4:	fmt=[a,b,c,d]
else:
endcase

if head gt 0 then begin strtit=strarr(head<10)         &    readf,u,strtit
                        if head gt 10 then for i=11L,head do readf,u,line
endif

clearpar,fix(ws),ws

if org  eq 5 then begin w=fltarr(m,n)   & readf,u,w & x=lindgen(m)+1 & y=lindgen(n)+1
endif else $
if org  eq 6 then begin w=fltarr(m,n,f) & readf,u,w & x=lindgen(m)+1 & y=lindgen(n)+1 & z=lindgen(f)+1
endif else $
if pair eq 1 then begin w=fltarr(n)     & x=fltarr (n)
   case org of
   0:   begin readf,u,x & if step gt 1 then for i=2,step do readf,u,line
              readf,u,w
        end
   1:   begin readf,u,x & if step gt 1 then for i=2,step do readf,u,line
              readf,u,w & if step gt 1 then for i=2,step do readf,u,line & e=fltarr(n)
              readf,u,e
        end
   2:   begin y=fltarr (n) & z=fltarr(n) & w(*)=1
              readf,u,x & if step gt 1 then for i=2,step do readf,u,line
              readf,u,y & if step gt 1 then for i=2,step do readf,u,line
              readf,u,z
        end
   3:   begin y=fltarr(n) & z=fltarr(n)
              readf,u,x & if step gt 1 then for i=2,step do readf,u,line
              readf,u,y & if step gt 1 then for i=2,step do readf,u,line
              readf,u,z & if step gt 1 then for i=2,step do readf,u,line
              readf,u,w
        end
   4:   begin y=fltarr(n) & z=fltarr(n)
              readf,u,w & if step gt 1 then for i=2,step do readf,u,line
              readf,u,x & if step gt 1 then for i=2,step do readf,u,line
              readf,u,y & if step gt 1 then for i=2,step do readf,u,line
              readf,u,z
        end
   else:
   endcase
endif else begin
  on_ioerror,miseof & cnt=0L & dim=500 & tmp=fltarr(dim) & w=fltarr(dim) & x=fltarr(dim)
                      cnp=0L &  v1=0.  & v2=0.  & v3=0.  & v4=0.
                      if org eq 1 then  e=fltarr(dim)
                      if org ge 2 then  begin y =fltarr(dim) & z=fltarr(dim) & endif
                      if total(fmt) eq 0 then sp=1 else sp=0
  trou=1
  while (trou) do begin print
   case org of
   0:   begin if sp then readf,u,v1,v2       else begin readf,u,line & did_readf,line,fmt,v1,v2       & endelse
              x(cnp)=v1 & w(cnp)=v2
              if cnt eq dim-1 then begin w=[w,tmp] & x=[x,tmp]                         & cnt=0  & endif else cnt=cnt+1
        end
   1:   begin if sp then readf,u,v1,v2,v3    else begin readf,u,line & did_readf,line,fmt,v1,v2,v3    & endelse
              x(cnp)=v1 & w(cnp)=v2 & e(cnp)=v3
              if cnt eq dim-1 then begin w=[w,tmp] & x=[x,tmp] & e=[e,tmp]             & cnt=0  & endif else cnt=cnt+1
        end
   2:   begin if sp then readf,u,v1,v2,v3    else begin readf,u,line & did_readf,line,fmt,v1,v2,v3    & endelse
              x(cnp)=v1 & y(cnp)=v2 & z(cnp)=v3
              if cnt eq dim-1 then begin x=[x,tmp] & y=[y,tmp] & z=[z,tmp]             & cnt=0  & endif else cnt=cnt+1
        end
   3:   begin if sp then readf,u,v1,v2,v3,v4 else begin readf,u,line & did_readf,line,fmt,v1,v2,v3,v4 & endelse
              x(cnp)=v1 & y(cnp)=v2 & z(cnp)=v3 & w(cnp)=v4
              if cnt eq dim-1 then begin w=[w,tmp] & y=[y,tmp] & x=[x,tmp] & z=[z,tmp] & cnt=0  & endif else cnt=cnt+1
        end
   4:   begin if sp then readf,u,v1,v2,v3,v4 else begin readf,u,line & did_readf,line,fmt,v1,v2,v3,v4 & endelse
              w(cnp)=v1 & x(cnp)=v2 & y(cnp)=v3 & z(cnp)=v4
              if cnt eq dim-1 then begin w=[w,tmp] & y=[y,tmp] & x=[x,tmp] & z=[z,tmp] & cnt=0  & endif else cnt=cnt+1
        end
   else:
   endcase
   cnp=cnp +1
   if step gt 1 then for i=2,step do readf,u,line
   if mxi  gt 0 then if  cnp  eq mxi then  trou=0
  endwhile
  miseof:
  if org eq 0 then begin w=w(0:cnp-1) & x=x(0:cnp-1) & endif
  if org eq 1 then begin w=w(0:cnp-1) & x=x(0:cnp-1) & e=e(0:cnp-1)   & endif
  if org eq 2 then begin x=x(0:cnp-1) & y=y(0:cnp-1) & z=z(0:cnp-1)   & w=fltarr(cnp) & w(*)=1 & endif
  if org eq 3 then begin x=x(0:cnp-1) & y=y(0:cnp-1) & z=z(0:cnp-1)   & w=w(0:cnp-1)  & endif
  if org eq 4 then begin x=x(0:cnp-1) & y=y(0:cnp-1) & z=z(0:cnp-1)   & w=w(0:cnp-1)  & endif
endelse
misread:free_lun,u
pp2=0
misopen:
end
FUNCTION READ_PAR , inst ,path, filename, status, datp
;-----------------------------------------------------

CASE inst OF 

'demo'	: RETURN,read_tmp	(['demo',' ']	,path,filename,status,datp)
'IN4'	: RETURN,rdid		(['IN4','TOF']	,path,filename,status,datp)
'IN5'	: RETURN,rdid		(['IN5','TOF']	,path,filename,status,datp)
'IN6'	: RETURN,rdid		(['IN6','TOF']	,path,filename,status,datp)
'IN10'	: RETURN,rdid		(['IN10','TOF']	,path,filename,status,datp)
'IN16'	: RETURN,rdid		(['IN16','TOF']	,path,filename,status,datp)
'D7'	: RETURN,rdid		(['D7','TOF']	,path,filename,status,datp)
'D11'	: RETURN,rdid		(['D11','LSS']	,path,filename,status,datp)
'D17'	: RETURN,rdid		(['D17','LSS']	,path,filename,status,datp)
'D22'	: RETURN,rdid		(['D22','LSS']	,path,filename,status,datp)
'PN1'	: RETURN,ill		(['PN1','NFP']	,path,filename,status,datp)
'INX'	: RETURN,inx_in		(['INX','TOF']	,path,filename,status,datp)
'D1B'	: RETURN,rdid		(['D1B','DIF']	,path,filename,status,datp)
'IN8'	: RETURN,rdid		(['IN8','3Axes'],path,filename,status,datp)
'D19'	: RETURN,rdid		(['D19','DIF']	,path,filename,status,datp)
'D9'	: RETURN,rdid		(['D9','DIF']	,path,filename,status,datp)
'D1A'	: RETURN,rdid		(['D1A','DIF']	,path,filename,status,datp)
'D16'	: RETURN,rdid		(['D16','LSS']	,path,filename,status,datp)
'DB21'	: RETURN,rdid		(['DB21','LSS']	,path,filename,status,datp)
'IN1'	: RETURN,rdid		(['IN1','3Axes'],path,filename,status,datp)
'lamp'	: RETURN,rlamp		(['lamp',' ']	,path,filename,status,datp)
'IN14'	: RETURN,rdid		(['IN14','3Axes'],path,filename,status,datp)
'IN20'	: RETURN,rdid		(['IN20','3Axes'],path,filename,status,datp)
'D2B'	: RETURN,rdid		(['D2B','DIF']	,path,filename,status,datp)
'D20'	: RETURN,rdid		(['D20','DIF']	,path,filename,status,datp)
'IN13'	: RETURN,rdid		(['IN13','TOF']	,path,filename,status,datp)
'D11tof'	: RETURN,rdid		(['D11tof','LSS'],path,filename,status,datp)
'XRAY'	: RETURN,rdspe		(['XRAY','LON']	,path,filename,status,datp)
'inx.'	: RETURN,write_inx	(['inx.',' ']	,path,filename,status,datp)
't13a'	: RETURN,rdid		(['t13a','LON']	,path,filename,status,datp)
't13c'	: RETURN,rdid		(['t13c','LON']	,path,filename,status,datp)
'NeXus'	: RETURN,read_nexus	(['NeXus',' ']	,path,filename,status,datp)
'DCSasc'	: RETURN,read_dcsasc	(['DCSasc','NIST'],path,filename,status,datp)
'DCSbin'	: RETURN,read_dcsbin	(['DCSbin','NIST'],path,filename,status,datp)
'D10'	: RETURN,rdid		(['D10','DIF']	,path,filename,status,datp)
'D15'	: RETURN,rdid		(['D15','DIF']	,path,filename,status,datp)
'Spec'	: RETURN,read_spec	(['Spec',' ']	,path,filename,status,datp)
'EDF'	: RETURN,rdedf		(['EDF','ESRF']	,path,filename,status,datp)
'dat.'	: RETURN,export_dat	(['dat.','DIF']	,path,filename,status,datp)
'gsas.'	: RETURN,export_gsa	(['gsas.','DIF'],path,filename,status,datp)
'fpcyc.'	: RETURN,export_cyc	(['fpcyc.','DIF'],path,filename,status,datp)
'xy.'	: RETURN,export_xy	(['xy.','DIF']	,path,filename,status,datp)
'prn.'	: RETURN,export_prn	(['prn.','DIF']	,path,filename,status,datp)
'gsas'	: RETURN,rd_d2b		(['gsas','DIF']	,path,filename,status,datp)
'fil'	: RETURN,rdinstr		(['fil','DIF']	,path,filename,status,datp)
'FPdat'	: RETURN,rdinstr		(['FPdat','DIF'],path,filename,status,datp)
'd20cal'	: RETURN,rddat		(['d20cal','DIF'],path,filename,status,datp)
'prf'	: RETURN,rddat		(['prf','DIF']	,path,filename,status,datp)
'xyz'	: RETURN,rddat		(['xyz','DIF']	,path,filename,status,datp)
'FPcyc'	: RETURN,rddat		(['FPcyc','DIF'],path,filename,status,datp)
'MiBeMol'	: RETURN,read_mibemol	(['MiBeMol','LLB'],path,filename,status,datp)
'QENS'	: RETURN,read_qens	(['QENS','IPNS'],path,filename,status,datp)
'res'	: RETURN,read_res	(['res','DIF']	,path,filename,status,datp)
'cufe'	: RETURN,read_res	(['cufe','DIF']	,path,filename,status,datp)
'fat'	: RETURN,read_res	(['fat','DIF']	,path,filename,status,datp)
'eth.'	: RETURN,export_eth	(['eth.','DIF']	,path,filename,status,datp)
'test'	: RETURN,read_res	(['test','DIF']	,path,filename,status,datp)
'FAT1'	: RETURN,read_res	(['FAT1','DIF']	,path,filename,status,datp)
'init'	: BEGIN  Status=0

  ttinst   = ['demo']		;exec
  ttinst   = [ttinst,'IN4']	;exec
  ttinst   = [ttinst,'IN5']	;exec
  ttinst   = [ttinst,'IN6']	;exec
  ttinst   = [ttinst,'IN10']	;exec
  ttinst   = [ttinst,'IN16']	;exec
  ttinst   = [ttinst,'D7']	;exec
  ttinst   = [ttinst,'D11']	;exec
  ttinst   = [ttinst,'D17']	;exec
  ttinst   = [ttinst,'D22']	;exec
  ttinst   = [ttinst,'PN1']	;exec
  ttinst   = [ttinst,'INX']	;exec
  ttinst   = [ttinst,'D1B']	;exec
  ttinst   = [ttinst,'IN8']	;exec
  ttinst   = [ttinst,'D19']	;exec
  ttinst   = [ttinst,'D9']	;exec
  ttinst   = [ttinst,'D1A']	;exec
  ttinst   = [ttinst,'D16']	;exec
  ttinst   = [ttinst,'DB21']	;exec
  ttinst   = [ttinst,'IN1']	;exec
  ttinst   = [ttinst,'lamp']	;exec
  ttinst   = [ttinst,'IN14']	;exec
  ttinst   = [ttinst,'IN20']	;exec
  ttinst   = [ttinst,'D2B']	;exec
  ttinst   = [ttinst,'D20']	;exec
  ttinst   = [ttinst,'IN13']	;exec
  ttinst   = [ttinst,'D11tof']	;exec
  ttinst   = [ttinst,'XRAY']	;exec
  ttinst   = [ttinst,'inx.']	;exec
  ttinst   = [ttinst,'t13a']	;exec
  ttinst   = [ttinst,'t13c']	;exec
  ttinst   = [ttinst,'NeXus']	;exec
  ttinst   = [ttinst,'DCSasc']	;exec
  ttinst   = [ttinst,'DCSbin']	;exec
  ttinst   = [ttinst,'D10']	;exec
  ttinst   = [ttinst,'D15']	;exec
  ttinst   = [ttinst,'Spec']	;exec
  ttinst   = [ttinst,'EDF']	;exec
  ttinst   = [ttinst,'dat.']	;exec
  ttinst   = [ttinst,'gsas.']	;exec
  ttinst   = [ttinst,'fpcyc.']	;exec
  ttinst   = [ttinst,'xy.']	;exec
  ttinst   = [ttinst,'prn.']	;exec
  ttinst   = [ttinst,'gsas']	;exec
  ttinst   = [ttinst,'fil']	;exec
  ttinst   = [ttinst,'FPdat']	;exec
  ttinst   = [ttinst,'d20cal']	;exec
  ttinst   = [ttinst,'prf']	;exec
  ttinst   = [ttinst,'xyz']	;exec
  ttinst   = [ttinst,'FPcyc']	;exec
  ttinst   = [ttinst,'MiBeMol']	;exec
  ttinst   = [ttinst,'QENS']	;exec
  ttinst   = [ttinst,'res']	;exec
  ttinst   = [ttinst,'cufe']	;exec
  ttinst   = [ttinst,'fat']	;exec
  ttinst   = [ttinst,'eth.']	;exec
  ttinst   = [ttinst,'test']	;exec
  ttinst   = [ttinst,'FAT1']	;exec

  ttproc   = ['read_tmp']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'ill']	;exec
  ttproc   = [ttproc,'inx_in']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rlamp']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdspe']	;exec
  ttproc   = [ttproc,'write_inx']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'read_nexus']	;exec
  ttproc   = [ttproc,'read_dcsasc']	;exec
  ttproc   = [ttproc,'read_dcsbin']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'rdid']	;exec
  ttproc   = [ttproc,'read_spec']	;exec
  ttproc   = [ttproc,'rdedf']	;exec
  ttproc   = [ttproc,'export_dat']	;exec
  ttproc   = [ttproc,'export_gsa']	;exec
  ttproc   = [ttproc,'export_cyc']	;exec
  ttproc   = [ttproc,'export_xy']	;exec
  ttproc   = [ttproc,'export_prn']	;exec
  ttproc   = [ttproc,'rd_d2b']	;exec
  ttproc   = [ttproc,'rdinstr']	;exec
  ttproc   = [ttproc,'rdinstr']	;exec
  ttproc   = [ttproc,'rddat']	;exec
  ttproc   = [ttproc,'rddat']	;exec
  ttproc   = [ttproc,'rddat']	;exec
  ttproc   = [ttproc,'rddat']	;exec
  ttproc   = [ttproc,'read_mibemol']	;exec
  ttproc   = [ttproc,'read_qens']	;exec
  ttproc   = [ttproc,'read_res']	;exec
  ttproc   = [ttproc,'read_res']	;exec
  ttproc   = [ttproc,'read_res']	;exec
  ttproc   = [ttproc,'export_eth']	;exec
  ttproc   = [ttproc,'read_res']	;exec
  ttproc   = [ttproc,'read_res']	;exec

  ttgroup  = [' ']		;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'LSS']	;exec
  ttgroup  = [ttgroup,'LSS']	;exec
  ttgroup  = [ttgroup,'LSS']	;exec
  ttgroup  = [ttgroup,'NFP']	;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'3Axes']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'LSS']	;exec
  ttgroup  = [ttgroup,'LSS']	;exec
  ttgroup  = [ttgroup,'3Axes']	;exec
  ttgroup  = [ttgroup,' ']	;exec
  ttgroup  = [ttgroup,'3Axes']	;exec
  ttgroup  = [ttgroup,'3Axes']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'TOF']	;exec
  ttgroup  = [ttgroup,'LSS']	;exec
  ttgroup  = [ttgroup,'LON']	;exec
  ttgroup  = [ttgroup,' ']	;exec
  ttgroup  = [ttgroup,'LON']	;exec
  ttgroup  = [ttgroup,'LON']	;exec
  ttgroup  = [ttgroup,' ']	;exec
  ttgroup  = [ttgroup,'NIST']	;exec
  ttgroup  = [ttgroup,'NIST']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,' ']	;exec
  ttgroup  = [ttgroup,'ESRF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'LLB']	;exec
  ttgroup  = [ttgroup,'IPNS']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec
  ttgroup  = [ttgroup,'DIF']	;exec

  ttsymbol = ['Current Path']			;exec
  ttsymbol = [ttsymbol,'Current Cycle']		;exec
  ttsymbol = [ttsymbol,'Previous Cycle']	;exec
  ttsymbol = [ttsymbol,'On_Line']		;exec
  ttsymbol = [ttsymbol,'C_Year 1995']		;exec
  ttsymbol = [ttsymbol,'C_Year 1996']		;exec
  ttsymbol = [ttsymbol,'C_Year 1997']		;exec
  ttsymbol = [ttsymbol,'C_Year 1998']		;exec
  ttsymbol = [ttsymbol,'C_Year 1999']		;exec
  ttsymbol = [ttsymbol,'C_Year 2000']		;exec
  ttsymbol = [ttsymbol,'C_Year 2001']		;exec
  ttsymbol = [ttsymbol,'C_Year 2002']		;exec
  ttsymbol = [ttsymbol,'d2b']		;exec
  ttsymbol = [ttsymbol,'in10']		;exec
  ttsymbol = [ttsymbol,'in16']		;exec
  ttsymbol = [ttsymbol,'d20']		;exec
  ttsymbol = [ttsymbol,'d16']		;exec
  ttsymbol = [ttsymbol,'xray']		;exec
  ttsymbol = [ttsymbol,'in5']		;exec
  ttsymbol = [ttsymbol,'in6']		;exec
  ttsymbol = [ttsymbol,'d11']		;exec
  ttsymbol = [ttsymbol,'d22']		;exec
  ttsymbol = [ttsymbol,'in4']		;exec
  ttsymbol = [ttsymbol,'d1a']		;exec
  ttsymbol = [ttsymbol,'d7']		;exec
  ttsymbol = [ttsymbol,'d17']		;exec
  ttsymbol = [ttsymbol,'d15']		;exec
  ttsymbol = [ttsymbol,'d10']		;exec
  ttsymbol = [ttsymbol,'db21']		;exec
  ttsymbol = [ttsymbol,'in5_864']		;exec
  ttsymbol = [ttsymbol,'in4_862']		;exec
  ttsymbol = [ttsymbol,'in6_882']		;exec
  ttsymbol = [ttsymbol,'in4_893']		;exec
  ttsymbol = [ttsymbol,'in6_892']		;exec

  ttpath   = ['.']				;exec
  ttpath   = [ttpath,'/usr/illdata/data']		;exec
  ttpath   = [ttpath,'/usr/illdata/data-1']		;exec
  ttpath   = [ttpath,'rpc']			;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/usr/illdata']		;exec
  ttpath   = [ttpath,'/hosts/d2b/users/data']		;exec
  ttpath   = [ttpath,'/hosts/in10/users/data']		;exec
  ttpath   = [ttpath,'/hosts/in16/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d20/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d16/users/data']		;exec
  ttpath   = [ttpath,'/usr/illdata/xray/xraydur']		;exec
  ttpath   = [ttpath,'/hosts/in5/users/data']		;exec
  ttpath   = [ttpath,'/hosts/in6/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d11/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d22/users/data']		;exec
  ttpath   = [ttpath,'/hosts/in4c/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d1a/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d7/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d17/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d10a/users/data']		;exec
  ttpath   = [ttpath,'/hosts/d10/users/data']		;exec
  ttpath   = [ttpath,'/hosts/db21/users/data']		;exec
  ttpath   = [ttpath,'/usr/illdata/864/in5']		;exec
  ttpath   = [ttpath,'/usr/illdata/862/in4']		;exec
  ttpath   = [ttpath,'/usr/illdata/882/in6']		;exec
  ttpath   = [ttpath,'/usr/illdata/893/in4']		;exec
  ttpath   = [ttpath,'/usr/illdata/892/in6']		;exec

  ttouch   = '/home/cs/TOUCH_BASE'			;exec

  ttmacro  = '/home/cs/lambda/macros'		;exec

  ttaccess = 'rdfilter'				;exec

  ttsite   = 'd20_widget'				;exec

  ttmagi   = '6' ;exec

  ttwall   = 'out' ;exec

  ttpars   = '120' ;exec

  datp     = {a:ttinst,  b:ttproc,  c:ttgroup,  $
              d:ttsymbol,e:ttpath,  f:ttouch,   $
              g:ttmacro, h:ttaccess,i:ttsite,j:ttmagi,k:ttwall,l:ttpars}

  return,0

         END

ELSE :

ENDCASE

Status = 14

return,0

END

;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION read_pol, w_in

;reads in the calculated polariser transmissions from polariser.dat
;w_in is a dummy workspace - not used for anything
;							KHA, 30/10/96
;-------------------------------------------------------------------------------
;*******************************************************************************

	take_datp, datp

	in_file='/hosts/d7sgi/usr1/people/lambda/polariser.dat'

	line=''
	A=FLTARR(6,32)
	OPENR, 1, in_file, ERROR=err
	IF (err NE 0) THEN PRINT, !ERR_STRING
	READF, 1, A
	CLOSE, 1
	x_out=A(0,*)
	w_out=A(3,*)/10000.
	e_out=FLTARR(32)	& e_out(*)=0.

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out

	datp.x_tit='Neutron Wavelength'
	datp.y_tit='Transmission'

	give_datp, datp

	RETURN, w_out
	END
; ***************************************************
pro HeaderSetup, IPNSHeader1,Debug=Debug
; Check to see if Debug option is used if not assign a false value
if (not N_Elements(Debug)) then Debug = 0

IPNSTable1  = {IPNSTable , Location:0L, Size:0L}

IPNSHeader1 = {IPNSHeader, $
	  CNT: IPNSTable1, $
	  MAP: IPNSTable1, $
	  TTP: IPNSTable1, $
	  TSC: IPNSTable1, $
	  TSH: IPNSTable1, $
	  CST: IPNSTable1, $
	  DDL: IPNSTable1, $
	  DataD: 0L, $
	  Block: 0L, $
	  Free: 0L, $
	  VERSN: 0L, $
	  DEG: IPNSTable1, $
	  LFI: IPNSTable1, $
	  ZDE: IPNSTable1, $
	  IDE: IPNSTable1, $
	  CTL: IPNSTable1, $
	  HST: IPNSTable1, $
	  NDE: 0, $
	  NAM: String(' ', FORMAT='(a20)'), $
	  TTL: String(' ', FORMAT='(a80)'), $
	  RUN: 0L, $
	  RCY: 0L, $
	  SDT: String(' ', FORMAT='(a9)'), $
	  STM: String(' ', FORMAT='(a8)'), $
	  EDT: String(' ', FORMAT='(a9)'), $
	  ETM: String(' ', FORMAT='(a8)'), $
	  STS: 0B,$
	  VMN: ' ', $
	  PRC: 0L, $
	  ELM: 0L, $
	  NCY: 0, $
	  ICY: 0, $
	  NEN: 0L, $
	  ELN: 0L, $
	  DCL: '    ', $
          DNT: ' ', $
	  PTN: ' ', $
	  LI: 0.0, $
	  LCH: 0.0, $
	  MCL: '    ', $
	  FMN: 0, $
	  CMN: 0, $
	  NHT: 0, $
	  NTY: 0, $
	  NCT: 0, $
	  ICT: 0, $
	  NSH: 0, $
	  NCH: 0L, $
	  PLS: 0L, $
	  SIZ: 0L, $
	  TMN: 0L, $
	  TMX: 0L, $
	  HTD: 0L, $
	  XNM: 0, $
	  YNM: 0, $
	  WNM: 0, $
	  WMA: 0L, $
	  WMI: 0L, $
	  DTA: 0.0, $
	  DTD: 0.0, $
	  OMG: 0.0, $
	  CHI: 0.0, $
	  PHI: 0.0, $
	  XLT: 0.0, $
	  XRT: 0.0, $
	  YLO: 0.0, $
	  YUP: 0.0, $
	  XDS: 0.0, $
	  YDS: 0.0, $
	  XLG: 0.0, $
	  CHW: 0, $
	  CWL: 0, $
	  L1D: 0L, $
	  L2D: 0L, $
	  LOF: 0L, $
	  NCI: 0L, $
	  NOV: 0, $
	  CLK: 0.0, $
	  MSZ: 0L, $
	  KSZ: 0L, $
	  DSZ: 0L, $
	  LSZ: 0L, $
	  ZSZ: 0L, $
	  ISZ: 0L, $
	  TSZ: 0L, $
	  SSZ: 0L, $
	  EIN: 0.0, $
	  EOU: 0.0, $
	  NHS: 0, $
	  PROT: 0.0, $
	  BIN: 0, $
	  MIC: 0, $
	  MOF: 0, $
	  FOF: 0L, $
	  ENM: 0L, $
	  RFI: 0L, $
	  RLA: 0L, $
	  PSN: 0, $
	  DRN: 0L, $
	  NHBLK: 0, $
	  IFSORT: 0, $
	  MSG: IPNSTable1, $
	  DSC: IPNSTable1, $
	  DID: IPNSTable1, $
	  SP4: IPNSTable1, $
	  SP5: IPNSTable1, $
	  SP6: IPNSTable1, $
	  SP7: IPNSTable1, $
	  SP8: IPNSTable1, $
	  SP9: IPNSTable1, $
	  SP10: IPNSTable1, $
	  SP11: IPNSTable1, $
	  SP12: IPNSTable1, $
	  SP13: IPNSTable1, $
	  SP14: IPNSTable1, $
	  SP15: IPNSTable1, $
	  CKS: 0.0, $
	  CKL: 0.0, $	  
	  CK2: 0.0 	}	  

end
; ***************************************************
Pro GetHeader, filename, header,Debug=Debug,lvopen=lvopen
; Check to see if Debug option is used if not assign a false value
if (not N_Elements(Debug)) then Debug = 0
if (not N_Elements(lvopen)) then lvopen = 0

HeaderSetup, header

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   OpenR, LUN, filename, /Get_Lun, /swap_if_big_endian
endelse

point_lun,lun,0
ReadU, Lun, header

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   close,Lun
   free_lun,Lun
endelse

end


; ***************************************************
PRO GetZDE, FileName, IErr, ZDE, ZDESize,debug=debug,lvopen=lvopen
if (not N_Elements(Debug)) then Debug = 0
if (not N_Elements(lvopen)) then lvopen = 0

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   OpenR, Lun, Filename, /GET_LUN,/block, /swap_if_big_endian
endelse

GetHeader, filename, header,Debug=Debug,lvopen=lun
ZDESize = Header.ZDE.Size/4
ZDELoc = Header.ZDE.Location
if(debug) then Begin
    help,ZDEloc
Endif

ZDEtemp= Assoc(Lun, FltArr(ZDESize), ZDELoc)
ZDE = ZDETemp(0)


IErr = 0L
if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   close,lun
   free_lun, lun
endelse
END


; ***************************************************
PRO GetLFI, FileName, IErr, LFI, LFISize,debug=debug,lvopen=lvopen
if (not N_Elements(Debug)) then Debug = 0
if (not N_Elements(lvopen)) then lvopen = 0

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   OpenR, Lun, Filename, /GET_LUN,/block, /swap_if_big_endian
endelse

GetHeader, filename, header,Debug=Debug,lvopen=lun
LFISize = Header.LFI.Size/4
LFILoc = Header.LFI.Location
if (debug) then begin
    help,lfiloc
Endif


Lfitemp= Assoc(Lun, FltArr(LfiSize), LfiLoc)
LFI = LfiTemp(0)


IErr = 0L
if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   close,lun
   free_lun, lun
endelse
END


; ***************************************************
PRO GetDEG, FileName, IErr, DEG, DEGSize,Debug=Debug,lvopen=lvopen
if (not N_Elements(Debug)) then Debug = 0
if (not N_Elements(lvopen)) then lvopen = 0

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   OpenR, Lun, Filename, /GET_LUN,/block, /swap_if_big_endian
endelse

GetHeader, filename, header,Debug=Debug,lvopen=lun
DEGSize = Header.DEG.Size/4
DEGLoc = Header.DEG.Location

If(Debug) then Begin
   help,degloc
endif

Degtemp= Assoc(Lun, FltArr(DegSize), DegLoc)
DEG = DegTemp(0)


IErr = 0L
if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   close,lun
   free_lun, lun
endelse
END


; ***************************************************
PRO GetTTP, FileName, IErr, TTP, TTPSize,debug=debug,lvopen=lvopen
if (not N_Elements(Debug)) then Debug = 0
if (not N_Elements(lvopen)) then lvopen = 0


if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   OpenR, Lun, Filename, /GET_LUN,/block, /swap_if_big_endian
endelse

GetHeader, filename, header,debug=debug,lvopen=lun

TTPSize = Header.TTP.Size/16
TTPLoc = Header.TTP.Location
TFT_binary = Replicate({nchann:0, Flags:0, ClMin:0L, ClRange:0L, chw:0, $
                         vcwl:0},header.nty)

TFT_b= Assoc(Lun, TFT_Binary, TTPLoc)
TFT_b2 = TFT_b(0)

TFT = Replicate({T_Min: 0.0, T_Max:0.0, T_Step:0.0, T_DoubleLen: 0L, $
       NumOfChannels:0, TimeFocusBit:0, EmissionDelayBit:0, $
       ConstantDelayBit:0, dBit:0, eBit:0, fBit:0, gBit:0, hBit:0}, header.nty)
;print,tft_b2
index=where(TFT_b2.chw ne 0)
   TFT(index).NumOfChannels = $
(TFT_b2(index).ClRange-TFT_b2(index).ClMin)/TFT_b2(index).chw

TFT.T_Min = TFT_b2.ClMin / 8.0
TFT.T_Max = TFT_b2.ClRange / 8.0
TFT.T_Step = TFT_b2.chw / 8.0
TFT.T_DoubleLen = TFT_b2.vcwl
TFT.TimeFocusBit = ishft(TFT_b2.Flags, -15) AND 1
TFT.EmissionDelayBit = ishft(TFT_b2.Flags, -14) AND 1
TFT.ConstantDelayBit = ishft(TFT_b2.Flags, -13) AND 1
TFT.dBit = ishft(TFT_b2.Flags, -12) AND 1
TFT.eBit = ishft(TFT_b2.Flags, -11) AND 1
TFT.fBit = ishft(TFT_b2.Flags, -10) AND 1
TFT.gBit = ishft(TFT_b2.Flags, -9) AND 1
TFT.hBit = ishft(TFT_b2.Flags, -8) AND 1

TTP = TFT
IErr = 0L

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   close,lun
   free_lun, lun
endelse

END


; ***************************************************
PRO GetMAP, FileName, IErr, MAP, MAPSize,Debug=Debug,lvopen=lvopen
if (not N_Elements(Debug)) then Debug = 0
if (not N_Elements(lvopen)) then lvopen = 0

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   OpenR, Lun, Filename, /GET_LUN,/block, /swap_if_big_endian
endelse

GetHeader, filename, header,debug=debug,lvopen=lun
MAPSize = Header.MAP.Size/4
;BYTEORDER,MAPSize ,/lswap
MAPLoc = Header.MAP.Location
;BYTEORDER,MAPLoc ,/lswap
Maptemp= Assoc(Lun, LonArr(MapSize), MapLoc)
MAP_b2 = MapTemp(0)

MAP=Replicate({Address:0L, TFType:0L, MoreHistBit:0L},Mapsize)

MAP.Address = MAP_b2 AND "037777777L
MAP.TFType = ISHFT(MAP_b2, -24) And "0377L
MAP.MoreHistBit = ISHFT(MAP_b2,-23) AND "01L

IErr = 0L

if (lvopen ne 0) then begin
   LUN = lvopen
endif else begin
   close,lun
   free_lun, lun
endelse
END

;***************************************************************************

PRO GetSpectrumByID, Filename, Ierr, Spectrum, ID,Debug=Debug,lvopen=lvopen
; Check to see if Debug option is used if not assign a false value
if (not N_Elements(Debug)) then Debug = 0
if (not N_Elements(lvopen)) then lvopen = 0

;  Read runfile header structure

if (lvopen NE 0) then begin
   LUN = lvopen
endif else begin
   OpenR, LUN, filename, /get_lun, /block, /swap_if_big_endian
endelse

getHeader, filename, header, lvopen=lun

; Read Mapping Tables and Detector location info

getMAP, filename, Ierr, DetectorMap, DMAPSize,lvopen=lun
GetTTP, filename, IErr, TimeFieldTable, TFTSize,lvopen=lun
GetDEG, filename, IErr, Angle, AngleSize,lvopen=lun
GetLFI, filename, IErr, Distance, DistanceSize,lvopen=lun
GetZDE, filename, IErr, Height, HeightSize,lvopen=lun

;Check to see if referenced detector ID holds data
If(DetectorMap(ID-1).TFType eq 0) then begin
   If (debug) then Begin
	print, 'Detector has no data'
   Endif
	ierr=-1
	if (lvopen ne 0) then begin
	   LUN=lvopen
	endif else begin
	   close,lun
	   free_lun,lun
	endelse
	return
endif else begin

;Open File for reading spectrum data

;OpenR, LUN, filename, /get_lun, /block, /swap_if_big_endian

if(header.PTN eq 'I') then begin
   If (debug) then Begin
	   print, 'Run was Chopper Focused'
   endif
   IF (not TimeFieldTable(DetectorMap(ID-1).TFType-1).TimeFocusBit) then Begin
   ; *********Detector element not focused ***************
     TMin= Float(TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Min) - $
           float(header.htd)/8.0
     TMax= float(TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Max) - $
              float(header.htd)/8.0
     TMin = TMin + header.LI/sqrt(header.ein/5.22707E6)
     TMax = TMax + header.LI/sqrt(header.ein/5.22707E6)
   endif else begin
   ; *********Detector element is focused ****************
     TMin= Float(TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Min) + $
           header.LI/sqrt(header.ein/5.22707E6)
     TMax= float(TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Max) + $
              header.LI/sqrt(header.ein/5.22707E6)
   endelse
      TStep= TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Step
endif else begin
   If (debug) then Begin
   	print, '************Run was not focused*************'
   EndIf
   TMin= TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Min - header.htd/8.0
   TMax= TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Max - header.htd/8.0
   TStep= TimeFieldTable(DetectorMap(ID-1).TFType-1).T_Step
endelse

nchannels= FIX((TMax-TMin)/TStep)

; Read the data for this spectrum
if (header.wnm gt 0) then begin
	OFFST = header.DataD + header.nch*2 + DetectorMap(ID-1).address+4
endif else begin
	OFFST = header.DataD + DetectorMap(ID-1).address+4
endelse
spec=Assoc(LUN, IntArr(nchannels),OFFSt)
data=long(spec(0))

If (Debug) then Begin
	Print, 'FOF, LOF, NOV, NCH, NCI'
	Print,header.fof,header.lof,header.nov,header.nch,header.nci
Endif



; Parse the overflows to produce an array with the number of overflows for
;  this ID
totchan = header.nch + header.nci
nover = header.lof-totchan

If (header.lof Gt totchan) then begin
	OFs = Assoc(LUN,LonArr(nover), header.DataD+totchan*2)
	OverFlows = OFs(0)
	If (debug) then print,overflows
	ofindex=where(overflows gt header.l1d)
	overflows(ofindex)=(overflows(ofindex)-header.l1d)
	AddOverFlows = Histogram(Overflows, MIN=DetectorMap(ID-1).address+4, $
                         MAX=DetectorMap(ID-1).address+4 + nchannels*2 -2,bin=2)
	if (debug) then begin
		print,addoverflows
		help,addoverflows
	endif
endif else Begin
	addoverflows=0
endelse

;Create a time array
Times = TMin + IndGen(nchannels)*TStep

;  IDL uses signed integers. IPNS DAS uses unsigned integers need to correct
;   for this
indices=where(Data LT 0)
if (indices(0) ne -1)then data(indices)=data(indices)+65536

;  Add in Overflows
data=data+addoverflows*65536

; Package the spectrum data
Spectrum = {data:data, Times:Times, $
             Angle:Angle(ID-1), Distance:Distance(ID-1), Height:Height(ID-1)}

if (lvopen ne 0) then begin
   LUN=lvopen
endif else begin
   close,lun
   free_lun,lun
endelse
endelse
End

;*****************************************************************************

function read_qens, INST , PATH , FILENAME , STATUS , DATP
;*****************************************************************************
;** Reading Data files from raw QENS data files
;** input file #1 : QENS????.RUN file = contains raw DATA (S(n_channel,2theta))
;** and parameters of the run like angles, tof, and flight distance
;** Stephane Rols 11/2001 srols@anl.gov
;** Modified by S.R 03/18/02
;*****************************************************************************

; ** Initializing of some parameters and arrays
; ** *******************************************
;print,'c est parti mon kiki'
iprint=0
DATA  =0
PAR_TXT=STRARR(20) & P=PAR_TXT
n_channels=1800 & str_n_channels=STRCOMPRESS(STRING(n_channels),/REMOVE_ALL)
n_channels_mon=3880 & str_n_channels_mon=STRCOMPRESS(STRING(n_channels_mon),/REMOVE_ALL)
xv=FINDGEN(n_channels)+1.							; The channel array
nsiz_max=258 & y_read=FLTARR(nsiz_max)
STATUS=7
;CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif
FILENAME=STRMID(FILENAME,2,4)

; ** First Step : Read the angles of the detectors in the angles array
; ** and the detector distances in the distances array
; ** ****************************************************************

STATUS=13

;********** Distances in meters **********
y_read=[    2.18400,      2.18400,      2.18400,      2.18400,      2.18400,      2.18400,$
            2.18400,      2.18400,      2.18400,      2.18400,      2.18400,      1.94000,$
            1.94000,      1.94000,      1.94000,      1.94000,      1.94000,      1.94000,$
            1.94000,      1.94000,      1.94000,      1.72500,      1.72500,      1.72500,$
            1.72500,      1.72500,      1.72500,      1.72500,      1.72500,      1.72500,$
            1.53000,      1.53000,      1.53000,      1.53000,      1.53000,      1.53000,$
            1.53000,      1.53000,      1.35300,      1.35300,      1.35300,      1.35300,$
            1.35300,      1.35300,      1.35300,      1.19400,      1.19400,      1.19400,$
            1.19400,      1.19400,      1.19400,      1.05100,      1.05100,      1.05100]
y_read=[y_read,      1.05100,      1.05100,     1.05100,    0.922000,    0.922000,    0.922000]
y_read=[y_read,     0.922000,     0.922000,    0.806000,    0.806000,    0.806000,    0.806000]
y_read=[y_read,     0.703000,     0.703000,    0.703000,    0.703000,    0.610000,    0.610000]
y_read=[y_read,     0.610000,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.610000,    0.610000]
y_read=[y_read,     0.610000,    0.000000,    0.703000,    0.703000,    0.703000,    0.703000]
y_read=[y_read,     0.806000,    0.806000,    0.806000,    0.806000,    0.922000,    0.922000]
y_read=[y_read,     0.922000,    0.922000,    0.922000,     1.05100,     1.05100,     1.05100]
y_read=[y_read,      1.05100,     1.05100,     1.05100,     1.19400,     1.19400,     1.19400]
y_read=[y_read,      1.19400,     1.19400,     1.19400,     1.35300,     1.35300,     1.35300]
y_read=[y_read,      1.35300,     1.35300,     1.35300,     1.35300,     1.53000,     1.53000]
y_read=[y_read,      1.53000,     1.53000,     1.53000,     1.53000,     1.53000,     1.53000]
y_read=[y_read,      1.72500,     1.72500,     1.72500,     1.72500,     1.72500,     1.72500]
y_read=[y_read,      1.72500,     1.72500,     1.72500,     1.94000,     1.94000,     1.94000]
y_read=[y_read,      1.94000,     1.94000,     1.94000,     1.94000,     1.94000,     1.94000]
y_read=[y_read,      1.94000,     2.18400,     2.18400,     2.18400,     2.18400,     2.18400]
y_read=[y_read,      2.18400,     2.18400,     2.18400,     2.18400,     2.18400,     2.18400]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    -1.38250,    0.000000]

index_d=WHERE(y_read NE 0) & distances=y_read(index_d)
d_mod_mon=ABS(distances(n_elements(distances)-1))
distances=distances(0:n_elements(distances)-2)

;********** Detectors Angles in Degree **********
y_read=[      16.5000,     16.5000,     16.5000,     16.5000,     16.5000,     16.5000]
y_read=[y_read,      16.5000,     16.5000,     16.5000,     16.5000,     16.5000,     23.5000]
y_read=[y_read,      23.5000,     23.5000,     23.5000,     23.5000,     23.5000,     23.5000]
y_read=[y_read,      23.5000,     23.5000,     23.5000,     30.5000,     30.5000,     30.5000]
y_read=[y_read,      30.5000,     30.5000,     30.5000,     30.5000,     30.5000,     30.5000]
y_read=[y_read,      37.5000,     37.5000,     37.5000,     37.5000,     37.5000,     37.5000]
y_read=[y_read,      37.5000,     37.5000,     44.5000,     44.5000,     44.5000,     44.5000]
y_read=[y_read,      44.5000,     44.5000,     44.5000,     51.5000,     51.5000,     51.5000]
y_read=[y_read,      51.5000,     51.5000,     51.5000,     58.5000,     58.5000,     58.5000]
y_read=[y_read,      58.5000,     58.5000,     58.5000,     65.5000,     65.5000,     65.5000]
y_read=[y_read,      65.5000,     65.5000,     72.5000,     72.5000,     72.5000,     72.5000]
y_read=[y_read,      79.5000,     79.5000,     79.5000,     79.5000,     86.5000,     86.5000]
y_read=[y_read,      86.5000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,     93.5000,     93.5000]
y_read=[y_read,      93.5000,    0.000000,     100.500,     100.500,     100.500,     100.500]
y_read=[y_read,      107.500,     107.500,     107.500,     107.500,     114.500,     114.500]
y_read=[y_read,      114.500,     114.500,     114.500,     121.500,     121.500,     121.500]
y_read=[y_read,      121.500,     121.500,     121.500,     128.500,     128.500,     128.500]
y_read=[y_read,      128.500,     128.500,     128.500,     135.500,     135.500,     135.500]
y_read=[y_read,      135.500,     135.500,     135.500,     135.500,     142.500,     142.500]
y_read=[y_read,      142.500,     142.500,     142.500,     142.500,     142.500,     142.500]
y_read=[y_read,      149.500,     149.500,     149.500,     149.500,     149.500,     149.500]
y_read=[y_read,      149.500,     149.500,     149.500,     156.500,     156.500,     156.500]
y_read=[y_read,      156.500,     156.500,     156.500,     156.500,     156.500,     156.500]
y_read=[y_read,     156.500,     163.500,     163.500,     163.500,     163.500,     163.500]
y_read=[y_read,      163.500,     163.500,     163.500,     163.500,     163.500,     163.500]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]
y_read=[y_read,     0.000000,    0.000000,    0.000000,    0.000000,    0.000000,    0.000000]

index_a=WHERE(y_read NE 0) & angles=y_read(index_d)
IF N_ELEMENTS(index_a)+1 NE N_ELEMENTS(index_d) THEN message,'Problem angles and distances arrays have not the right dimensions'

t_min=2000.00 & ch_width=10.0

t_min_mon=600.00 & ch_width_mon=5.0


IF iprint NE 0 THEN BEGIN
PRINT,'Angles in degree'
PRINT,angles
PRINT,'Distances in meters'
PRINT,distances
ENDIF
print,'second step'
; ** Second Step : Read the DATA in neutron counts in the DATA_LECT array
; ** This uses the GetSpectrumById.pro pocedure written by J. Hammonds
; ** ********************************************************************
str_filen=PATH+'qens'+FILENAME+'.run'
n_spectra=N_ELEMENTS(index_a) & str_n_spectra=STRCOMPRESS(STRING(n_spectra),/REMOVE_ALL)
DATA_LECT=FLTARR(n_channels,n_spectra)	;=S(t,2theta)
FOR i=0,N_ELEMENTS(index_a)-1 DO BEGIN
ID=FIX(index_a(i)) & ID=ID(0)
GetSpectrumByID,str_filen,ierr,Spectrum,ID+1
DATA_LECT(*,i)=Spectrum.data(*)
ENDFOR

GetSpectrumByID,str_filen,ierr,Spectrum,index_d(N_ELEMENTS(index_d)-1)+1 ;Lecture monitor
MON=Spectrum.data

; ** Now deal with some input parameters found in the header
; ** This uses the GetHeader.pro procedure written by J. Hammonds
; ** ***************************************************************

GetHeader,str_filen,header
str_uname=strtrim(header.nam,2)
str_date=strtrim(header.sdt,2)
str_rtitle=strtrim(header.ttl,2)

; ** Data are read ... Now extract the monitor and the error arrays
; ** and pass into the DATP structure
; ** ***************************************************************

DATA=DATA_LECT
DATPN=MON
DATAE=SQRT(DATA)
DATPPV=distances
DATPX=xv & DATPY=angles(0:n_spectra-1)
DATPW_TIT=str_rtitle
DATPX_TIT='channel'
DATPY_TIT='spectrum'
DATPOTHER_TIT=str_uname
DATPTIME=str_date

; ** Also find the elastic channel and pass it into the DATP str
; ** ****************************************************************

;x_in=xv & w_in=DATA &
;i=INDGEN(n_spectra)
;xtot=x_in & ytot=TOTAL(w_in(*,i),2) & etot=SQRT(ytot)
;y0=MAX(ytot,i0)   & xmin=xtot((i0-20)>0) & xmax=xtot((i0+20)<(n_channels-1))
;fitgauss, xtot, ytot, etot, xmin, xmax, gauss, dgauss
;chel=gauss(2) & str_chel=STRCOMPRESS(STRING(chel),/REMOVE_ALL)   ; elastic channel

; ** Pass into the DATP structure
; ** *****************************

; ** Now write the read parameters in the DATP.P corresponding array
; ** ***************************************************************

P(0)=FILENAME		  &		PAR_TXT(0)='Run Number'
P(1)=header.sdt		  &		PAR_TXT(1)='Start Date'
P(2)=header.edt		  &		PAR_TXT(2)='Stop Date'
P(3)=header.stm		  &		PAR_TXT(3)='Start Time'
P(4)=header.etm	 	  &		PAR_TXT(4)='Stop Time'
P(5)=header.rfi	  	  &		PAR_TXT(5)='First Run#'
P(6)=header.rla		  &		PAR_TXT(6)='Last Run#'
P(7)='10'		 	  &		PAR_TXT(7)='Channel Width (mmsec)'
P(8)=str_rtitle	  	  &		PAR_TXT(8)='Experimental Title'
P(9)=str_uname		  &		PAR_TXT(9)='User Name'
P(10)=str_n_spectra   &		PAR_TXT(10)='Number of Detectors'
P(11)=str_n_channels  &		PAR_TXT(11)='Number of TOF Channels'
P(12)=header.pls	  &		PAR_TXT(12)='Total Number of Pulses in this Run'
P(13)=t_min			  &		PAR_TXT(13)='Minimum TOF (channel 1) detected'
P(14)=ch_width		  &		PAR_TXT(14)='Channel Width spectra'
P(15)=t_min_mon		  &		PAR_TXT(15)='Minimum TOF (channel 1) detected for mon'
P(16)=ch_width_mon	  &		PAR_TXT(16)='Channel Width monitor'
P(17)=d_mod_mon		  &		PAR_TXT(17)='Moderator to Monitor Distance'

DATP={X:			DATPX,			$
	  Y:			DATPY,			$
	  W_TIT:		DATPW_TIT,		$
	  X_TIT:		DATPX_TIT,		$
	  Y_TIT:		DATPY_TIT,		$
	  N:			DATPN,			$
	  E:			DATAE,			$
	  OTHER_TIT:	DATPOTHER_TIT,	$
	  TIME:			DATPTIME,		$
	  PV:			DATPPV,			$
	  P:			P,				$
	  PAR_TXT:		PAR_TXT }
STATUS=0

no_file:

RETURN, DATA                                         ;Return the data values
;************
END
;Dids!!! Dialog_Message, spec2hdf have been commented

function sdep, DS=ds, PS=ps, VF=vf, VS=vs, W=w

;+
; NAME:
;	SDEP
;
; PURPOSE:
;	Returns several System DEPendent parameters, like OS family (default), 
;	directory separator, path separator, etc. 
;
; CATEGORY:
;	General utilities
;
; CALLING SEQUENCE:
; 
;	Result = SDEP()
;
; INPUTS:
;	None
;
; KEYWORD PARAMETERS:
;	DS:	(Directory Separator) When set, SDEP returns the directory 
;		separator (i.e. 
;		/ (slash) under Unix or \ (backslash) under Windows).
;	PS:	(Path Separator) When set, SDEP returns the path separator 
;		(i.e. :  under Unix or ; (backslash) under Windows).
;	VS:	(Version Short) returns the idl short-version (i.e. 
;		'5' for idl 5.0.2)
;	VF:	(Version Full) returns the idl full versiom (i.e. 
;		'5.0.2' for idl 5.0.2)
;	W:	(Widget allowed?) Returns 1 when widget are allowed (i.e. 
;		!d.nane is 'WIN','X' or 'MAC') otherwise returns 0 (i.e. 'PS').
;
; OUTPUTS:
;	This function returns (with no keywords) the !version.os_family
;	value in uppercase. If any keyword is set, the returned value
;	is changed to the one described below.
;
; RESTRICTIONS:
;	Never used under Mac
;
; PROCEDURE:
;	Straightforward
;
; EXAMPLE:
;	print,sdep()
;
; MODIFICATION HISTORY:
; 	Written by:	srio@esrf.fr and dejus@aps.anl.gov
;	Sept, 1997	
;	97/10/16 srio@esrf.fr adds /w keyword.
;	98/12/23 srio@esrf.fr tentative update for Mac
;-
; returns system dependent values
; returns osversion if no keywords are set, otherwise returns the
; requested separator (ds = directory separator, ps = path separator)
; srio@esrf.fr 97-09-15 and dejus@aps.anl.gov 09/15/97.

osversion = StrUpCase(!version.os_family)

if keyword_set(ds) then begin		; directory separator
  CASE osversion OF
    'UNIX': 	return,'/'
    'WINDOWS': 	return,'\'
    'MACOS': 	return,':'
    else:		return,''
  ENDCASE
endif

if keyword_set(ps) then begin		; path separator
  CASE osversion OF
    'UNIX': 	return,':'
    'WINDOWS':	return,';'
    'MACOS': 	return,','
     else:		return,''
  ENDCASE
endif

if keyword_set(vf) then return,!version.release

if keyword_set(vs) then return,strmid(!version.release,0,1)

if keyword_set(w) then begin		; path separator
  CASE !d.name OF
    'WIN': 	return,1
    'X':	return,1
    'MAC': 	return,1
     else:	return,0
  ENDCASE
endif

return, osversion
end ; sdep

; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function checks if the parameter is a valid handle to a Spec data file.
function __isaspechandle, handle
   a=size(handle)
   if a(2) ne 8 then return, 0
   a = tag_names(handle)
   if a(0) ne 'SPECFILE' then return, 0 else return, 1
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function returns the first token found in the string `line' and
; modifies the content of `line' to hold only the remainder of the string.
function __linecut, line
   line = strtrim(line, 1) + ' '
   len = strlen(line)
   p = strpos(line, ' ')
   aux = strmid(line, 0, p)
   p = p + 1
   line = strtrim(strmid(line, p, len - p), 2)
   return, aux
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function returns an array loaded with the tokens found in the input
; string `oldline'. Tokens are separated by a 1 or 2 white spaces according
; to the parameter `nspaces'. The function returns an error if the numbers
; of tokens found is less than `imin' or greater than `imax'. This feature
; can be cancelled by setting `imin' and/or `imax' to zero.
function __linesplit, oldline, nspaces, imin, imax
   case nspaces of
      1: begin
         line = strtrim(strcompress(' ' + oldline))
         pos = where(byte(line) eq 32b)
      end

      2: begin
         line = '  ' + strtrim(oldline, 2)
         aux0 = byte(line)
         aux = aux0 eq 32b
         pos = where(aux and [aux(1:*), 0b] and     $
                     not [0b, aux(0:n_elements(aux)-2)])
         aux0(pos) = 1B
         line = strcompress(string(aux0))
         pos = where(byte(line) eq 1B)
      end

      else: return, ''
   endcase

   n = n_elements(pos)
   if n eq 1 then begin
      list = strmid(line, nspaces, strlen(line) - nspaces)
   endif else begin
      length = [pos(1:*), strlen(line)] - pos - nspaces
      pos = pos + nspaces
      list = strarr(n)
      for i = 0, n-1 do list(i) = strmid(line, pos(i), length(i))
   endelse

   if imin gt 0 and n_elements(list) lt imin then      $
      message, 'Too few fields in <'+oldline+'>' 
   if imax gt 0 and n_elements(list) gt imax then      $
      message, 'Too many fields in <'+oldline+'>' 

   return, list
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function makes up an error message.
function __cleanmsg, msg
   p = strpos(msg, ':')
   return, strtrim(strmid(msg, p+1, strlen(msg) - p), 2)
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure reads a new full logic line from the data file.
pro __readline, Unit, line
   readf, Unit, line
   p = strlen(line) - 1
   aux=''
   while strmid(line, p, 1) eq '\' do begin
      strput, line, ' ', p
      readf, Unit, aux
      line = line + aux
      p = strlen(line) - 1
   endwhile
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure loads `array' with the data in the string `line'. The data
; type depends on the initial type of array. If in `line' there are less data
; than the number of elements in `array', the remainder elements are filled
; with 0 or '' and the variable `error' is set to 1.
pro __reads, line, array, error
   if (size(array(0)))(1) ne 7 then begin
      array(*)=0
      on_ioerror, toofew
      !ERROR = 0
      reads, line, array
toofew: 
      on_ioerror, null
      if !ERROR eq 0 then error = 0 else error =1
   endif else begin
      array(*) = ''
      narr = n_elements(array)
      _line = strtrim(strcompress(' ' + line))
      pos = where(byte(_line) eq 32b)
      n = n_elements(pos)
      if n eq 1 then begin
         array(0) = strmid(_line, 1, strlen(_line) - 1)
      endif else begin
         length = [pos(1:*), strlen(_line)] - pos - 1
         nread = (narr < n)
         if n ge narr then error = 0 else error =1
         list = strarr(n)
         for i = 0, nread - 1 do begin
            array(i) = strmid(_line, pos(i) + 1, length(i))
         endfor
      endelse
   endelse
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure appends a scan `s' to the array `scanlist' and is only
; used by spec_access().
pro __addscan, scanlist, s, linect, range, scancounter
   s.headerlines =   linect(0)
   s.predatalines =  linect(1)
   s.datalines =     linect(2)
   s.postdatalines = linect(3)

   if scancounter eq 0 then scanlist = s else scanlist=[scanlist, s]

   scancounter = scancounter + 1 
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure produces and error if the parameter is not a valid handle.
pro __speccheck, handle
;Dids
   if not __isaspechandle(handle) then message, 'Variable is not a valid SPEC handle.'
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure loads in `handle' the information contained in the main header
; block that correspond to the current scan.
pro __headerload, handle 
   if handle.headerpt ne handle.scan(handle.currscan).headerpt then begin
      n = handle.scan(handle.currscan).headerlines
      motorlbl = handle.motornames
      motorlbl(*, *) = ''
      motor_no = handle.motor_no
      motor_no(*) = 0
      epoch = -1L
      nmotlines = -1
      if n gt 0 then begin
         openr, Unit, handle.specfile, /get_lun
         point_lun, Unit, handle.scan(handle.currscan).headerpt
         line = ''
         motline = 0
	 ; srio 98/08/25 places "nmotlines = -1" outside the "if" block
         ;nmotlines = -1
         for i = 1, n do begin
            __readline, Unit, line
            case strmid(line, 1, 1) of
               'E': begin
                  epoch=long(strmid(line, 2, strlen(line)-2))
               end

               'O': begin
                  aux = __linecut(line)
                  reads, aux, format='(2X,I)', motline
                  aux = __linesplit(line, 2, 0, 0)
                  if aux(0) eq '' then begin
                     motor_no(motline) = 0
                  endif else begin
                     motor_no(motline) = n_elements(aux)
                     motorlbl(motline, 0:n_elements(aux) - 1) = aux
                  endelse
                  if motline + 1 gt nmotlines then nmotlines = motline + 1
               end

               else:

            endcase
         endfor
         free_lun, Unit
      endif
      handle.headerpt = handle.scan(handle.currscan).headerpt
      handle.epoch = epoch
      handle.nmotorlines = nmotlines
      handle.motor_no = motor_no
      handle.motornames = motorlbl
   endif
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure makes the scan specified by `scan_id' the current one.
pro __specload, handle, scan_id, errmsg, INDEX=idx

   aux = size(scan_id)
   if aux(0) ne 0 then begin
      message, 'Scan number must be a scalar value'
   endif

   n = handle.currscan
   if n ge 0 then begin
      curr_n = handle.scan(n).scan_n
      curr_ap = handle.scan(n).scan_ap
   endif else begin
      curr_n = -1
      curr_ap = -1
   endelse

   if aux(1) eq 0 then begin
   endif else if aux(1) eq 7 then begin
      Up_scan_id = strupcase(scan_id)
      case Up_scan_id of
         'CURRENT': begin
            if n lt 0 then begin
               errmsg = 'No current scan'
               !ERR = 1
               return 
            endif else begin
               goto, load
            endelse
         end

         'NEXT': begin
            if n ge 0 and n lt handle.total-1  then begin
               n = n + 1
               goto, load
            endif else begin
               errmsg = 'No next scan'
               !ERR = 1
               return 
            endelse
         end

         'FIRST': begin
            if handle.total gt 0  then begin
               n = 0 
               goto, load
            endif else begin
               errmsg = 'No first scan'
               !ERR = 1
               return 
            endelse
         end

         'LAST': begin
            if handle.total gt 0  then begin
               n = handle.total - 1 
               goto, load
            endif else begin
               errmsg = 'No last scan' 
               !ERR = 1
               return 
            endelse
         end

         else: begin
            s_no = 0
            on_ioerror, isastring
            s_no = fix(scan_id)
isastring:  on_ioerror, null
            p = strpos(scan_id, '.') + 1
            if p gt 0 then begin 
               s_ap = fix(strmid(scan_id, p, strlen(scan_id)-p))
            endif else begin
               s_ap = 0
            endelse
         end
      endcase
   endif else begin
      if aux(1) lt 1 or aux(1) gt 5 then begin
         errmsg = 'Not a valid scan number.'
         !ERR = 1
         return 
      endif
      s_no = fix(scan_id)
      s_ap = round(100*(scan_id - s_no)) 
   endelse

   if s_no eq 0 or (s_no lt 0 and not keyword_set(idx)) then begin
      errmsg = 'Not a valid scan number.'
      !ERR = 1
      return 
   end

   if keyword_set(idx) then begin
      if s_no lt 0 then s_no = handle.total + s_no + 1
      if s_no gt 0 and s_no le handle.total then begin
         n = s_no - 1
         goto, load
      endif else begin
         errmsg = 'Not enough scans in "' + handle.specfile + '".'
         !ERR = 1
         return 
      endelse
   endif else if s_no eq curr_n and (s_ap eq 0 or s_ap eq curr_ap) then begin
      goto, load
   endif 
   if s_ap eq 0 then begin
      if n ge 0 then begin
         for n = n, handle.total-1 do begin
            if handle.scan(n).scan_n eq s_no then goto, load 
         endfor
      endif
      s_ap=1
   endif
   for n = 0, handle.total-1 do begin
      if handle.scan(n).scan_n  eq s_no and           $
         handle.scan(n).scan_ap eq s_ap then begin
            goto, load
      endif
   endfor
   
   errmsg = 'Scan '+strtrim(string(s_no),2)+'['+strtrim(string(s_ap),2)+ $
            '] not found in "'+ handle.specfile + '".'
   !ERR = 1
   return 

LOAD:
   if n ne handle.currscan then begin
      handle.label(*)=''

      if handle.scan(n).n_col gt 0 and handle.scan(n).labelpt gt 0 then begin
         openr,Unit,handle.specfile,/get_lun
         point_lun, Unit, handle.scan(n).labelpt+2
         line=''
         __readline, Unit, line
         free_lun, Unit

         aux = __linesplit(line, 2, handle.scan(n).n_col, handle.scan(n).n_col)
         handle.label=aux 
      endif

      handle.currscan = n
   endif
   !ERR = 0
   end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_COLUMNS()
;
; PURPOSE:
;       This function returns the number of data columns of a particular scan
;       in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_COLUMNS(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       MCDATA: Set this keyword to return the number of channels in the
;               multichannel data lines instead of the number of standard
;               data columns.
;
; OUTPUT: 
;       The number of columns in the selected scan. If the MCDATA keyword is
;       not set the information is obtained from the `#N' line in the SPEC
;       data file and corresponds to the number of standard data columns.
;       When MCDATA is set, the returned value is the number of channels in
;       the multichannel data lines obtained from the `#@CHANN' line.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To print the number of data columns in the second occurrence of the
;       scan 150 in the file 'baddata', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'baddata')
;       PRINT, SPEC_COLUMNS(File1_handle, 150.02)
;______________________________________________________________________________
;-

function spec_columns, handle, scan_id, INDEX=idx, MCDATA=mcdata
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string) ;, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'
   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg

   if keyword_set(mcdata) then begin
      return, handle.scan(handle.currscan).n_chan
   endif else begin
      return, handle.scan(handle.currscan).n_col 
   endelse
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_DATA()
;
; PURPOSE:
;       This function returns an array with data from a scan in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_DATA(Handle, Scan_Id [, Columns])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; OPTIONAL INPUTS:
;       Columns  - Vector that describes the columns to be loaded in the output
;                  array. This vector can be of either numeric or string type.
;                  When numbers are used columns are selected by their relative
;                  position in the data file. When non-numeric strings are used
;                  they must match the labels of the columns to select. By
;                  using a string array it is possible to combine both
;                  selection methods.
;                  If negative numbers are used it is assumed that the column
;                  position is obtained by counting backwards from the last
;                  one: i.e. -1 means the last column, -2 the one before the
;                  last, and so on.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       MCDATA: Set this keyword to return data from the multichannel data
;               lines instead of the standard data columns.
;
;       LABELS: String vector to be filled with the labels of the returned
;               columns. This option can only be used if the MCDATA keyword
;               is not set.
;
;       OFFSET: Number of points that will be skipped before extracting the
;               required data. This value is defaulted to 0.
;
;       STEP:   Interval used to extract data points. Only the first one of
;               each group of STEP consecutive data points will be extracted.
;               The default value is 1.
;
;       NPOINTS: Maximum number of points that will be returned. If it is
;               zero or greater than the actual number of available data
;               points, this keyword has not any effect.
;
;       CHANNELS: Float vector to be filled with the channel numbers of the
;               multichannel data. It is not used if the MCDATA keyword is
;               not set.
;
;       CALIBRATED: Float vector to be filled with the calibrated values
;               (usually energy) of the channels in the multichannel data set.
;               It is not used if the MCDATA keyword is not set.
;
;       STRING: Set this keyword to force the output to be a string array. 
;
;       DOUBLE: Set this keyword to force the output to be a double-precision
;               array.
;
;       FLOAT:  Set this keyword to force the output to be a single-precision
;               floating-point array.
;
;       LONG:   Set this keyword to force the output to be a longword integer
;               array.
;
;       INT:    Set this keyword to force the output to be an integer array.
;
; OUTPUT: 
;       This function returns an array containing the data columns selected by
;       the Columns parameter. If no Columns parameter is given, all the
;       columns in the selected scan are returned. By default the output 
;       is a double-precision array for standard data and a long array for
;       multichannel data, but the output array can be forced to any type by
;       setting the proper keyword.
;       If a particular column does not exist in the SPEC file, the
;       corresponding column in the output array is filled with zeros.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To load the array GoodData with the position of the first column of the
;       scan 5, the monitor counts and the detector counts (that are assumed to
;       be in the last column of the file), enter:
;
;       Dummy = SPEC_ACCESS(File_handle, 'weakdata')
;       GoodData = SPEC_DATA(File_handle, 27, ['1', 'Monitor', '-1'])
;
;______________________________________________________________________________
;-

function spec_data, handle, scan_id, columns, INDEX=idx, MCDATA=mcdata,        $
                           LABELS=labels, OFFSET=offset, STEP=step,NPOINTS=np,$
                           CHANNELS=chann, CALIBRATED=calib,                  $
                           DOUBLE=dtype, FLOAT=ftype, LONG=ltype, INT=itype,  $
                           STRING=stype
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() lt 2 or N_PARAMS() gt 3 then  $
                                   message, 'Incorrect number of arguments.'
   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg

   if keyword_set(mcdata) and keyword_set(labels) then  $
                                   message, 'No labels in multichannel data.'
   if not keyword_set(offset) then offset = 0
   if not keyword_set(step) then step = 1
   if not keyword_set(np) then np = 0
   offset = long(offset)
   step = long(step)
   np = long(np)
   if offset lt 0 then message, 'OFFSET must be a positive value.'
   if step lt 1 then message, 'STEP must be >= 1.'
   if step lt 0 then message, 'NPOINTS must be >= 0.'

   if keyword_set(mcdata) then begin
      n = handle.scan(handle.currscan).n_chan
      npoints = handle.scan(handle.currscan).a_datapoints
   endif else begin
      n = handle.scan(handle.currscan).n_col
      npoints = handle.scan(handle.currscan).n_datapoints
   endelse
   if npoints le 0 then message, 'No data points.'
   if npoints le offset then message, 'Offset too big.'
   npoints = long((npoints - offset - 1)/step) + 1
   if np gt 0 and npoints gt np then npoints = np

   if N_PARAMS() eq 2 then begin
      ncols = n
      index = indgen(ncols)
   endif else begin
      aux = size(columns)
      if aux(0) gt 1 then message, 'Too many dimensions.'
      ncols= aux(aux(0) + 2)
      index=intarr(ncols)
      aux = aux(aux(0) + 1)
      if aux gt 0 and aux lt 6 then begin
         index = fix(columns)  
      endif else if aux eq 7 then begin
         for i=0, ncols-1 do begin
            c=0
            on_ioerror, isastring
            c=fix(columns(i)) 
isastring:  on_ioerror, null
            if c eq 0 then begin
               if keyword_set(mcdata) then begin
                  message, "Not labels allowed with multichannel data."
               endif
               for j=1, n do begin
                  if columns(i) eq handle.label(j-1) then begin
                     c=j 
                     goto, set
                  endif
               endfor
            endif 
set:        index(i)=c
         endfor
      endif else begin
         message, "Bad data type."
      endelse
      index = index * (index ge -n and index le n) - 1
      index = index + (n+1)*(index lt -1) 
   endelse

   aux = where(index lt 0)
   if aux(0) ne -1 then begin
      message, "Wrong column specification [" +                  $
                                    strtrim(string(columns(aux(0))),2) + "]."
   endif

   if keyword_set(stype) then begin
      data = strarr(ncols, npoints)
      datal = strarr(n)
      datatype = 2
   endif else if keyword_set(mcdata) and not keyword_set(ftype) and  $
                                      not keyword_set(dtype) then begin
      data = lonarr(ncols, npoints)
      datal = lonarr(n)
      datatype = 1
   endif else begin
      data = dblarr(ncols, npoints)
      datal = dblarr(n)
      datatype = 0
   endelse

   openr,Unit,handle.specfile,/get_lun
   point_lun, Unit, handle.scan(handle.currscan).datapt
   line=''
   point = -offset
   pt = 0L
   for i = 0L, handle.scan(handle.currscan).datalines -1 do begin
      if pt eq npoints then goto, done
      __readline, Unit, line
      ok = point ge 0 and (point mod step) eq 0
      found = 0
      case strmid(line, 0, 1) of
         '':  ; Empty line. Do nothing

         '#': ; Header or comment. Do nothing

         '@': begin
            if keyword_set(mcdata) and strmid(line, 1, 1) eq 'A' then begin
               found = 1
               if ok then begin
                  aux0 = __linecut(line)
                  __reads, line, datal
               endif
            endif
         end

         else: begin
            if not keyword_set(mcdata) then begin
               found = 1
               if ok then begin
                  __reads, line, datal
               endif
            endif
         end
      endcase
      if found then begin
         if ok then begin
            data(*, pt) = datal(index)
            pt = pt + 1
         endif
         point = point + 1
      endif
   endfor
done:
   if keyword_set(mcdata) then begin
      nchan = 0      ; integer
      chmin = 0.     ; float
      chmax = 0.     ; float
      Chreduc = 0    ; integer
      calA = 0.      ; float
      calB = 1.      ; float
      calC = 0.      ; float
      point_lun, Unit, handle.scan(handle.currscan).scanpt
      for i = 1, handle.scan(handle.currscan).predatalines do begin
         __readline, Unit, line
         if strmid(line, 0, 7) eq '#@CHANN' then begin
            line = strmid(line, 7, strlen(line)-7) + ' 0 0 0 0'
            reads, line, nchan, chmin, chmax, chreduc
            if chreduc eq 0 then chreduc = 1
            if chmin eq chmax and nchan gt 1 then begin
               chmax = chmin + (nchan - 1) * chreduc
            endif
         endif else if strmid(line, 0, 7) eq '#@CALIB' then begin
            line = strmid(line, 7, strlen(line)-7) + ' 0 0 0'
            reads, line, calA, calB, calC 
         endif
      endfor
      if nchan gt 1 then begin
         chann = chmin + findgen(nchan)*(chmax-chmin)/(nchan - 1)
      endif else begin
         chann = chmin
      endelse
      calib = calA + chann * (calB + chann * calC)
   endif
   free_lun, Unit

   if not keyword_set(mcdata) then begin
      aux = [handle.label, '']
      labels = aux(index)
   endif

   if keyword_set(stype) then return, data
   if keyword_set(ftype) then return, float(data)
   if keyword_set(itype) then return, fix(data)
   if keyword_set(ltype) then return, long(data)
   return, reform(data)
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_HEADERS()
;
; PURPOSE:
;       This function returns header lines from a particular scan in a SPEC
;       data file. Header lines begin by the '#' character and can be situated
;       before or after the block of data lines.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_HEADERS(Handle, Scan_Id [, Selec_Array])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; OPTIONAL INPUTS:
;       Selec_Array - Array that contains selectors to the header lines.
;                  A selector is a string with the first characters of the
;                  header lines that are wanted to be returned. A selector can
;                  include or not the first '#' character of the header lines.
;                  For instance, the string 'P' selects all the headers in the
;                  scan that contain motor positions (those that begin with 
;                  the '#P' characters) and the string '#G0' selects the 
;                  first line of geometry parameters.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       ALL:    Set this keyword to extend the scope of the search and include
;               the main block of header lines as well as comments embedded in
;               the data block.
;               In normal SPEC data files the main header block is placed at
;               the beginning of the file and includes the file name line ('#F')
;               the epoch line ('#E') and the motor names ('#O' lines). If 
;               there are more than one main header block in the file, the
;               function uses the last one before the given scan.
;               Comment lines appear embedded in the data block when a scan
;               is resumed after been aborted from SPEC.
;
; OUTPUT: 
;       This function returns a string array that contains all the header lines
;       that match the selection criteria. If Selec_Array is not specified
;       all the header lines are returned.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To load the string array NewHeaders with the header lines that contain
;       the positions of the first eight motors ('#P0' line) and the user
;       defined values ('#U' lines), enter:
;
;       Dummy = SPEC_ACCESS(FileHandle, 'baddata')
;       Nscans = SPEC_HEADERS(FileHandle, BestScan, ['#P0','U'])
;
;       (the file in this example is 'baddata' and the scan number is in the
;       variable called BestScan)
;______________________________________________________________________________
;-

function spec_headers, handle, scan_id, headers, ALL=all, INDEX=idx
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() lt 2 then message, 'Incorrect number of arguments.'
   if N_PARAMS() eq 2 then begin
      headers = ''
   endif
   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   if keyword_set(all) then begin
      __headerload, handle
      nlh = handle.scan(handle.currscan).headerlines 
   endif else begin
      nlh = 0L
   endelse

   aux = size(headers)
   if aux(aux(0) + 1) ne 7 or aux(0) gt 1 then begin
       message, 'Argument is not a valid header specification.'
   endif
   nheaders = aux(aux(0) + 2)
   _headers = strarr(nheaders)

   for i = 0L, nheaders - 1 do begin
      if strmid(headers(i), 0, 1) ne '#' then begin
         _headers(i) = '#' + headers(i)
      endif else begin
         _headers(i) = headers(i)
      endelse
   endfor
   headlen = strlen(_headers)

   nl0 = nlh + handle.scan(handle.currscan).predatalines 
   nl1 = nl0 + handle.scan(handle.currscan).datalines
   nlt = nl1 + handle.scan(handle.currscan).postdatalines

   openr,Unit,handle.specfile,/get_lun
   if nlh gt 0 then begin
      point_lun, Unit, handle.scan(handle.currscan).headerpt
   endif 
   line = ''
   ct = 0L
   for i = 1L, nlt do begin
      if i eq nlh + 1 then begin
         point_lun, Unit, handle.scan(handle.currscan).scanpt
      endif
      __readline, Unit, line
      if i le nl0 or i gt nl1 or keyword_set(all) then begin
         if line ne '' and strmid(line, 0, 1) eq '#' then begin
            for j = 0L, nheaders - 1 do begin
               if strmid(line, 0, headlen(j)) eq _headers(j) then begin
                  if ct eq 0 then begin
                     result = line
                  endif else begin
                     result = [result, line]
                  endelse
                  ct = ct + 1
                  goto, outfor
               endif
            endfor
outfor:
         endif
      endif
   endfor
   free_lun, Unit

   if ct eq 0 then begin
      return, ''
   endif else begin
      return, result
   endelse
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_LABELS()
;
; PURPOSE:
;       This function returns the labels of data columns of a particular scan
;       in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_LABELS(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
; OUTPUT: 
;       This function returns an string array that contains the labels of the
;       the data columns in the SPEC file. The information is extracted from
;       the '#L' line. The dimension of the array depends on the number of
;       columns of this particular scan.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To load the array NewLabels with the labels of the data columns of the
;       scan no. 27 from a file called 'karaoke', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'karaoke')
;       NewLabels = SPEC_LABELS(File1_handle, 27)
;______________________________________________________________________________
;-

function spec_labels, handle, scan_id, INDEX=idx
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   n=handle.scan(handle.currscan).n_col
   if n gt 0 then return, handle.label(0:n-1) else return, ''
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_MOTORS()
;
; PURPOSE:
;       This function returns the names or position of motors in a particular
;       scan in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_MOTORS(Handle, Scan_Id [, MotorList [, BadValue]])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; OPTIONAL INPUTS:
;       MotorList - String array that contains the names of the motors which
;                  position is requested.
;                  In addition to motor names, it is also possible to specify
;                  a motor by using a string with the format 'line,motor' where
;                  `line' in the number of the `#P' header line that includes
;                  the motor information, and `motor' is the relative position
;                  of the motor in that line. For instance, '2,1' refers to
;                  the first motor in the `#P2' line.
;
;       BadValue - Dummy value to be returned as a motor position if the
;                  corresponding motor is not found or when the headers are
;                  corrupted and the NOERROR ketword is set. This value is
;                  defaulted to 1E20.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       NOERROR: Set this keyword to not return an error when the file headers
;               are corrupted. 
;
; OUTPUT: 
;       If MotorList is specified this function returns the position of the
;       motors included in the list. Otherwise it returns a string array
;       that contains the names of all the motors associated to the given scan.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;       If the file was created with an old version of SPEC and a motor name
;       has more than 8 characters this function will not work. It will not
;       work if a motor name includes two or more consecutive white spaces.
;
; EXAMPLE:
;       To print the position of the motors 'Theta', 'Piezo 1' and the second
;       motor of the first `#P' line in the fifth scan of a file called
;       'baddata', enter:
;
;       Dummy = SPEC_ACCESS(HHH, 'baddata')
;       PRINT, SPEC_MOTORS(HHH, -5, ['Theta', 'Piezo 1', '0,2'])
;______________________________________________________________________________
;-
function spec_motors, handle, scan_id, motorlist, badvalue, INDEX=idx,   $
                                                           NOERROR=noerror
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() lt 2 or N_PARAMS() gt 4 then       $
                                    message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   __headerload, handle
 
   if N_PARAMS() ge 3 then begin
      aux = size(motorlist)
      if aux(aux(0) + 1) eq 7 then begin
         list = strtrim(motorlist, 2)
      endif else begin
         message, 'Argument is not a valid motor name list.'
      endelse
   endif

   if N_PARAMS() lt 4 then begin
      returnbadvalue = 0
      badvalue = 1E20
   endif else begin
      returnbadvalue = 1
   endelse

   headersP = spec_headers(handle, 'current', '#P')
   motorlines = n_elements(headersP)

   if motorlines eq 0 then begin
      rows = 0
   endif else begin
      for i = 0, motorlines - 1 do begin
         auxline = headersP(i)
         aux = __linecut(auxline)
         headersP(i) = auxline
         reads, aux, format='(2X,I)', motline
         mot = __linesplit(auxline, 1, 0, 0)
         if i eq 0 then begin
            linelist = motline
            motlist = n_elements(mot)
         endif else begin
            linelist = [linelist, motline]
            motlist = [motlist, n_elements(mot)]
         endelse
      endfor
      rows = max(linelist) + 1
      cols = intarr(rows)
      allmotpos = fltarr(rows, max(motlist))

      for i = 0, motorlines - 1 do begin
         motline = linelist(i)
         cols(motline) = motlist(i)
         mot = __linesplit(headersP(i), 1, 0, 0)
         allmotpos(motline, 0:cols(motline)-1) = float(mot(0:cols(motline)-1))
      endfor
   endelse

   if handle.nmotorlines ne rows then begin
      corrupted = 1
   endif else begin
      corrupted = 0
      for i = 0, rows - 1 do begin
         if cols(i) ne handle.motor_no(i) then begin
            corrupted = 1
         endif
      endfor
   endelse

   if corrupted and not keyword_set(noerror) then begin
      message, 'File headers corrupted'
   endif

   if N_PARAMS() eq 2 then begin
      motornames = ''
      if not corrupted then begin
         for i = 0, handle.nmotorlines - 1 do begin
            for j = 0, handle.motor_no(i) - 1 do begin
               if motornames(0) eq '' then begin
                  motornames = handle.motornames(i, j)
               endif else begin
                  motornames = [motornames, handle.motornames(i, j)]
               endelse
            endfor
         endfor
      endif
      return, motornames
   endif else begin
      for k = 0, n_elements(list) - 1 do begin
         pos = badvalue
         motfound = 0
         for i = 0, rows - 1 do begin
            for j = 0, cols(i) - 1 do begin
               if not corrupted then begin
                  if handle.motornames(i, j) eq list(k) then begin
                     pos = allmotpos(i, j)
                     motfound = 1
                     goto, found
                  endif
               endif
            endfor
         endfor
         if not motfound then begin
            p = strpos(list(k), ',')
            if p gt 0 then begin
               on_ioerror, arestrings
               x = fix(strmid(list(k), 0, p))
               y = fix(strmid(list(k), p+1, strlen(list(k))-p-1)) - 1
               if x ge 0 and x lt rows then begin
                  if y ge 0 and y le cols(x) then begin
                     pos = allmotpos(x, y)
                     motfound = 1
                  endif
               endif
arestrings:    on_ioerror, null
            endif
         endif
found:
         if motfound or returnbadvalue or keyword_set(noerror) then begin
            if k eq 0 then begin
               motorpos = pos
            endif else begin
               motorpos = [motorpos, pos]
            endelse
         endif else begin
            message, 'Motor "'+ list(k) +'" not found.'
         endelse
      endfor
      return, motorpos
   endelse

end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_NAME()
;
; PURPOSE:
;       This function returns the name of a particular scan in a SPEC file.
;       In most of the cases the name of a scan is the full macro that was
;       used to produce obtain the data.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_NAME(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
; OUTPUT: 
;       The name of the selected scan. The information is obtained from the
;       '#S' line.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To print the name of the scan 150 from a file called 'baddata', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'baddata')
;       PRINT, SPEC_NAME(File1_handle, 150)
;______________________________________________________________________________
;-

function spec_name, handle, scan_id, INDEX=idx
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   return, handle.scan(handle.currscan).name 
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_POINTS()
;
; PURPOSE:
;       This function returns the number of data points of a particular scan
;       in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_POINTS(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts various syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       MCDATA: Set this keyword to make the function return the number of
;               points with multichannel data (MCA, ...) instead of the 
;               conventional data. 
;
; OUTPUT: 
;       The number of data points in the scan specified by Scan_Id.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To print the number of data points in the scan 999 from a file called
;       'sosada', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'sosada')
;       PRINT, SPEC_POINTS(File1_handle, 999)
;______________________________________________________________________________
;-

function spec_points, handle, scan_id, INDEX=idx, MCDATA=mcdata
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg

   if keyword_set(mcdata) then begin
      npoints = handle.scan(handle.currscan).a_datapoints
   endif else begin
      npoints = handle.scan(handle.currscan).n_datapoints
   endelse
   return, npoints 
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_SCAN()
;
; PURPOSE:
;       This function returns a vector loaded with the numbers of a group of
;       scans in a SPEC file.
;       The values returned correspond to either the numbers ('#S' lines) of
;       the scans or their indexes (relative position in the file).
;       This function can be used to check if a scan or group of scans exist
;       in a SPEC data file before calling any other function of the library.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_SCAN(Handle, ScanList [, ErrMsg])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       ScanList - List of scans in the SPEC data file. ScanList can be a 
;                  scalar or an array. In the case of arrays all the elements 
;                  are included in the list. ScanList can also be of numeric
;                  or string type.
;                  When using character strings one can specify a group of
;                  consecutive scans in compressed form using the syntax
;                  `first-last'. If `first' or `last' are not specified they
;                  are defaulted to the first and last scan in the file. It is
;                  also possible to include several scans or groups of scans
;                  in a single string by using commas or white spaces as
;                  separators.
;                  The values in ScanList follow the same convention used for
;                  scan identifiers (see the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). By default, numeric values are
;                  interpreted as SPEC scan numbers, but this behaviour is
;                  changed by the INDEX keyword.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret the numeric values in ScanList
;               as the indexes of the scans instead of as scan numbers.
;               Care must be taken when using indexes in strings that specify
;               groups of scans. In order to allow the use of negative indexes
;               the sign of the index must be explicitly included when the
;               expression can be ambiguous. As an example compare the
;               following expressions when INDEX is set: 
;                  '-2'    represents the scan before the last one (index=-2).
;                  '--2'   represents the scans from the first to the one
;                           before the last (index=1 to index=-2).
;                  '-+2'   represents the first two scans in the file
;                           (index=1 to index=2).
;
;       RETURN_INDEX: Set this keyword to return the index of the scans instead
;               of the scan numbers.
;
;       OCCURRENCE: Set this keyword to return the scan number and the scan
;               occurrence in the format SSSS.OO as explained in the `SCAN
;               IDENTIFIERS' section at the beginning of this file). This 
;               keyword has not any effect if RETURN_INDEX is also set.
;
;       STRING: Set this keyword to force the output as a string vector instead
;               of float.
;
;       NO_EMPTY: Set this keyword to make the output value of the function
;               refer only to those scans that actually contain standard data
;               columns, excluding the empty ones.
;
;       MCDATA: Set this keyword to make the output value of the function
;               refer only to those scans that contain multichannel data.
;
;       NO_RANGE: Set this keyword to force the function to accept only 
;               single scans as input instead of lists.
;
; OUTPUT: 
;       If there is no error this function returns a vector that contains the
;       list of scans specified in ScanList. If any of the scans is not found
;       or any other error occurs, the function return -1.
;
; OPTIONAL OUTPUTS:
;
;       ErrMsg  - Error message if an error occurs.
;    
; SIDE EFFECTS:
;       The `current' scan is set to the last scan in the list.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;
; EXAMPLE:
;       To print the number of most recently accessed scan, enter:
;
;       PRINT, SPEC_SCAN(OldHandle, 'current')
;______________________________________________________________________________
;-
function spec_scan, handle, scan_list, errmsg, INDEX=idx, RETURN_INDEX=rindex,$
                                               OCCURRENCE=occurr, STRING=str, $
                                               NO_EMPTY=noemp, MCDATA=mca,    $
                                               NO_RANGE=no_range
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 and N_PARAMS() ne 3 then begin
      message, 'Incorrect number of arguments.'
   endif
   errmsg = ''

   __speccheck, handle

   aux = size(scan_list)
   nelem = n_elements(scan_list)
   isstring = (aux(aux(0)+1) eq 7)
   if keyword_set(no_range) then begin
      if nelem gt 1 then return, -1
      if isstring then begin
         if strpos(scan_list(0),',') ne -1 or strpos(scan_list(0),'-') ne -1 $
                                                   then return, -1
      endif
   endif

   if not isstring then begin
      for i=0, nelem - 1 do begin
         __specload, handle, scan_list(i), errmsg, INDEX=idx
         if !ERR then return, -1
         if i eq 0 then begin
            indexlist = handle.currscan
         endif else begin
            indexlist = [indexlist, handle.currscan]
         endelse
      endfor
   endif else begin
      _scan_list = scan_list(0)
      for i=1, nelem - 1 do _scan_list = _scan_list + ',' + scan_list(i)
      _scan_list = strcompress(_scan_list, /remove_all)
      p = strpos(_scan_list, ',')
      while p ge 0 do begin
         strput, _scan_list, ' ', p
         p = strpos(_scan_list, ',')
      endwhile
      _scan_list = __linesplit(strcompress(_scan_list), 1, 0, 0)
      ngroups = n_elements(_scan_list)
      if ngroups eq 1 and _scan_list(0) eq '' then return, -1
      for i=0, ngroups-1 do begin
         p = strpos(_scan_list(i), '-')
         if p eq 0 and keyword_set(idx) then begin
            nextchar = strmid(_scan_list(i), 1, 1)
            if nextchar ne '-' and nextchar ne '+' and nextchar ne '' then begin
               p = strpos(_scan_list(i), '-', 1) 
            endif
         endif
         if p ge 0 then begin
            scan0 = strmid(_scan_list(i), 0, p)
            if scan0 eq '' then scan0 = 'FIRST'
            scan1 = strmid(_scan_list(i), p + 1, strlen(_scan_list(i)) - p - 1)
            if scan1 eq '' then scan1 = 'LAST'
         endif else begin
            scan0 = _scan_list(i)
            scan1 = ''
         endelse
         __specload, handle, scan0, errmsg, INDEX=idx
         if !ERR then return, -1 
         firstscan = handle.currscan
         if i eq 0 then begin
            indexlist = firstscan
         endif else begin
            indexlist = [indexlist, firstscan]
         endelse
         if scan1 ne '' then begin
            __specload, handle, scan1, errmsg, INDEX=idx
            if !ERR then return, -1 
            if handle.currscan ge firstscan then delta = 1 else delta = -1
            for j = firstscan + delta, handle.currscan, delta do begin
               indexlist = [indexlist, j]
            endfor
         end
      endfor
   endelse

   if keyword_set(mca) then begin
      dpoints = handle.scan(indexlist).a_datapoints
   endif else if keyword_set(noemp) then begin
      dpoints = handle.scan(indexlist).n_datapoints
   endif else goto, NoFilter
   aux = where(dpoints gt 0)
   if aux(0) eq -1 then return, -1
   indexlist = indexlist(aux)

NoFilter:
   if keyword_set(rindex) then begin
      result = indexlist + 1
   endif else if keyword_set(occurr) then begin
      result = handle.scan(indexlist).scan_n +     $
               handle.scan(indexlist).scan_ap/100.
   endif else begin
      result = handle.scan(indexlist).scan_n 
   endelse

   return, result
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_SAVE()
;
; PURPOSE:
;       This function saves the data contained in a 2D numeric array into a file
;       following the SPEC data file format. If the file does not exist it is created.
;       I the file exits, it must be a valid SPEC data file and the data is appended
;       as a new scan. 
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_SAVE(Handle, Data [, File])
;
; INPUTS:
;       Handle - Handle to the SPEC data file. It is initialized, if necessary, and
;                updated after the data is saved.
;
;       Data   - Numeric array containing the data to be saved. The first dimension
;                correspond to the data columns in the SPEC file.
;
; OPTIONAL INPUT/OUTPUT
;       File   - If Handle is not a valid SPEC file handle, this is parameter is the
;                name of the file where the data will be saved. Otherwise File
;                specifies a named variable where the actual name of the file will be
;                returned.
;
; KEYWORDS:
;       COLUMNS: Vector that specifies the columns in the array Data that will be
;               saved. If this keyword is not set all the columns are saved.
;
;       LABELS: String vector that contains the labels for the data columns.
;
;       COMMENTS: String vector that contains comment lines that will be included
;               in the header section of the scan.
;
;       NAME:   String that will appear as scan name in the `#S' line.
;
;       OVERWRITE: Set this keyword to overwrite the file if it exists. By default
;               data is appended to existing files.
;
;       NO_CONFIRM: Set this keyword to not ask for confirmation when writting data
;               on existing files.
;
;       NO_ERROR: Set this keyword to not produce an IDL error if an error is found
;               when writting the data. 
;
;	DIALOG_PARENT: Set this keyword equal to a string that specifies the name 
;		of the parent widget (to be passed to Dialog_Message)
;
; OUTPUT: 
;       This function returns the scan number under which the data is saved in the
;       file. If the operation is cancelled, the function returns zero. If an error
;       happens and NO_ERROR is set the function returns -1 and the error message
;       is stored in the system variable !ERR_STRING.
;
; EXAMPLE:
;       To save the data in the array NewData in the file 'Newfile', enter:
;
;       PRINT, SPEC_SAVE(DummyHandle, NewData, 'Newfile')
;______________________________________________________________________________
;-
function spec_save, handle, data, file, COLUMNS=columns, LABELS=labels,      $
                     COMMENTS=comm, NAME=name, NO_ERROR=noerror,             $
                     OVERWRITE=overwrite, NO_CONFIRM=no_conf,                $
		     DIALOG_PARENT=dialog_parent
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      if keyword_set(noerror) then return, -1
      message, __cleanmsg(!err_string);, /traceback
   endif

   aux = size(data)
   if aux(0) ne 2 then begin
      message, 'Data is not a 2D array.'
   end
   totcol = aux(1)

   if n_elements(columns) eq 0 then columns = indgen(totcol)
   ncol = n_elements(columns)
   if min(columns) lt 0 or max(columns) ge totcol then begin
      message, 'Column values are out of range.'
   endif

   nlab = n_elements(labels)
   if nlab lt ncol then begin
      extralbl= ('Column'+strtrim(indgen(ncol),2))(nlab:ncol-1)
      if nlab eq 0 then begin
         labels = extralbl
      endif else begin
         labels = [labels, extralbl]
      endelse
   endif
   labels = labels(0:ncol-1)

   if not keyword_set(name) then name = ''
;Dids
   if not keyword_set(file) then begin
      if __isaspechandle(handle) then begin
         file = handle.specfile
      endif else return, 0
   endif

   ; Check if writable and if new or SPEC file 

   openw, Unit, file, /get_lun, /append, error=err
   if err then begin
      message, 'Cannot open "'+file+'" for writting.'
   endif
   status = fstat(Unit)
   if status.size gt 0 then begin
      if spec_access(handle, file) eq 0 then begin
         free_lun, Unit
         message, 'Exists and is not a SPEC file'
      endif else begin
         scan = spec_scan(handle, 'last') + 1
      endelse
   endif else begin
      scan = 1
   endelse

   if keyword_set(overwrite) then begin
      if not keyword_set(no_conf) and scan gt 1 then begin
        ;tmp = Dialog_Message('SPEC file exists, overwrite data ?', /default_no, $
        ;                     title='Writting data', /question, $
	;		      DIALOG_PARENT=dialog_parent)
	 tmp = 'Yes'
         if tmp eq 'No' then begin
            free_lun, Unit
            return, 0
         endif
      endif
      free_lun, Unit
      openw, Unit, file, /get_lun
      scan = 1
   endif else begin
      if not keyword_set(no_conf) and scan gt 1 then begin
        ;tmp = Dialog_Message('SPEC file exists, append data ?', /question, $
        ;                      title='Writting data',		       $
	;		       DIALOG_PARENT=dialog_parent)
	 tmp = 'Yes'
         if tmp eq 'No' then begin
            free_lun, Unit
            return, 0
         endif
      endif
   endelse

   ; Write the data

   if scan eq 1 then begin
      printf, Unit, '#F ',file
      printf, Unit, '#E',strcompress(long(systime(1)))
      printf, Unit, '#D ',systime(0)
   endif 
   printf, Unit, ''
   printf, Unit, '#S',strcompress(scan),' ',name
   printf, Unit, '#D ',systime(0)
   if keyword_set(comm) then printf, Unit, transpose('#C ' + comm)
   printf, Unit, format='("#N ", I2)' ,ncol
   printf, Unit, format= '("#L",'+string(ncol)+'("  ",A))', labels
   printf, Unit, format='('+string(ncol)+'(G0.6," "))', data(columns, *)
   free_lun, Unit

   return, scan
end
;Dids PRO spec2hdf,filein,fileout,GROUP=group
;Dids ;+
;Dids ; NAME:
;Dids ;       SPEC2HDF
;Dids ;
;Dids ; PURPOSE:
;Dids ;       This procedure reads a SPEC file and creates an HDF file
;Dids ;	with its contents.
;Dids ;
;Dids ; CATEGORY:
;Dids ;       Filters.
;Dids ;
;Dids ; CALLING SEQUENCE:
;Dids ;       SPEC2HDF [, infile, outfile] 
;Dids ;
;Dids ; OPTIONAL INPUTS:
;Dids ;       infile - Name of the input file.
;Dids ;       outfile - Name of the output file.
;Dids ;	(if infile and/or outfile are not input, a dialog window 
;Dids ;	will appear to define them).
;Dids ;
;Dids ; KEYWORDS:
;Dids ;       GROUP: Set this keyword to the widget ID of an existing widget
;Dids ;               that serves as "group leader".
;Dids ;
;Dids ; OUTPUT:
;Dids ;
;Dids ; PROCEDURE:
;Dids ;	Uses SPECACCESS and HDF routines.
;Dids ;
;Dids ; EXAMPLE:
;Dids ;
;Dids ; MODIFICATION HISTORY:
;Dids ;       00-10-26  Written by M. Sanchez del Rio (srio@esrf.fr)
;Dids ;-
;Dids ;
;Dids ;=====================================================================
;Dids ;
;Dids COMMON spec2hdf_paths,pathIn,pathOut
;Dids 
;Dids On_Error,2
;Dids 
;Dids IF N_Elements(pathIn) EQ 0 THEN pathIn = ''
;Dids IF N_Elements(pathOut) EQ 0 THEN pathOut = ''
;Dids 
;Dids IF SDep(/w) NE 1 AND N_Params() LT 2 THEN Message,$
;Dids   'Usage: spec2hdf,filein,fileout'
;Dids 
;Dids IF N_Params() EQ 0 THEN BEGIN
;Dids   filein = Dialog_Pickfile(/READ,DIALOG_PARENT=group, $
;Dids      GET_PATH=pathin,PATH=pathIn)
;Dids   IF filein EQ '' THEN RETURN
;Dids   fileout=filein+'.hdf'
;Dids   fileout = Dialog_Pickfile(/WRITE,DIALOG_PARENT=group,FILE=fileout, $
;Dids     GET_PATH=pathOut,PATH=pathOut)
;Dids   IF fileout EQ '' THEN RETURN
;Dids ENDIF
;Dids IF N_Params() EQ 1 THEN BEGIN
;Dids   fileout = Dialog_Pickfile(/WRITE,DIALOG_PARENT=group,FILE=filein+'.hdf',$
;Dids     GET_PATH=pathOut,PATH=pathOut)
;Dids   IF fileout EQ '' THEN RETURN
;Dids ENDIF
;Dids 
;Dids Message,/Info,'Scanning file: '+filein
;Dids n=spec_access(h,filein)
;Dids hdffile=fileout
;Dids 
;Dids hdfhandle = HDF_SD_START(hdffile, /CREATE)
;Dids IF hdfhandle EQ 0 THEN message,'Error opening HDF file: '+hdffile
;Dids 
;Dids inormal = spec_scan(h,'-',/return_index)
;Dids imcdata = spec_scan(h,'-',/mcdata,/return_index)
;Dids 
;Dids ;
;Dids ; file header
;Dids ;
;Dids IF inormal[0] NE -1 THEN txt = spec_headers(h,1,/index,/all)  ELSE $
;Dids                          txt = spec_headers(h,1,/index,/all,/mcdata) 
;Dids 
;Dids igood = where(strmid(StrCompress(txt,/Remove_All),0,2) EQ '#S')
;Dids IF igood[0] NE -1 THEN BEGIN
;Dids   headerfile = txt[0:igood[0]-1]
;Dids   ihandle = HDF_SD_CREATE(hdfhandle,'File header',[0])
;Dids   FOR j=0L,N_ELEMENTS(headerfile)-1 DO BEGIN
;Dids         tmp = headerfile[j]
;Dids         HDF_SD_ATTRSET,ihandle,headerfile[j],headerfile[j]
;Dids   ENDFOR
;Dids ENDIF
;Dids 
;Dids ;
;Dids ; normal scans
;Dids ;
;Dids n = n_elements(inormal)
;Dids IF inormal[0] NE -1 THEN BEGIN
;Dids   Message,/Info,'Writing '+StrCompress(n,/Remove_All)+' normal scans...  '
;Dids   FOR i=0,n-1 DO BEGIN
;Dids     iscan = inormal[i]
;Dids     txt = spec_headers(h,iscan,/index,all=iall) 
;Dids     npoints = spec_points(h,iscan,/index)
;Dids     IF npoints GT 0 THEN BEGIN
;Dids       data = spec_data(h,iscan,/index)
;Dids       name = spec_headers(h,iscan,'S',/index)
;Dids       nx = (size(data))[1]
;Dids       ny = (size(data))[2]
;Dids       nn=[nx,ny]
;Dids       ihandle = HDF_SD_CREATE(hdfhandle,name,[nx,ny],/float)
;Dids       HDF_SD_ADDDATA,ihandle,data
;Dids       FOR j=0,n_elements(txt)-1 DO BEGIN
;Dids         HDF_SD_ATTRSET,ihandle,txt[j],txt[j]
;Dids       ENDFOR
;Dids     ENDIF
;Dids   ENDFOR
;Dids ENDIF
;Dids 
;Dids ;
;Dids ; mcdata scans
;Dids ;
;Dids n = n_elements(imcdata)
;Dids IF imcdata[0] NE -1 THEN BEGIN
;Dids   Message,/Info,'Writing '+StrCompress(n,/Remove_All)+' MCA scans...  '
;Dids   FOR i=0,n-1 DO BEGIN
;Dids     iscan = imcdata[i]
;Dids     txt = spec_headers(h,iscan,/index,all=iall) 
;Dids     npoints = spec_points(h,iscan,/index)
;Dids     IF npoints GT 0 THEN BEGIN
;Dids       data = spec_data(h,iscan,/index,/mcdata)
;Dids       name = spec_headers(h,iscan,'S',/index)
;Dids       nx = (size(data))[1]
;Dids       ny = (size(data))[2]
;Dids       nn=[nx,ny]
;Dids       ihandle = HDF_SD_CREATE(hdfhandle,name+' [MCDATA]',[ny,nx],/float)
;Dids       HDF_SD_ADDDATA,ihandle,data,/noreverse
;Dids       FOR j=0,n_elements(txt)-1 DO BEGIN
;Dids         HDF_SD_ATTRSET,ihandle,txt[j],txt[j]
;Dids       ENDFOR
;Dids     ENDIF
;Dids   ENDFOR
;Dids ENDIF
;Dids 
;Dids 
;Dids ; HDF_CLOSE,hdfhandle
;Dids HDF_SD_END,hdfhandle
;Dids Message,/Info,'File written to disk: '+fileout
;Dids 
;Dids END
; Version  3.00beta  10/10/1995
; European Synchrotron Radiation Facility (ESRF)
;______________________________________________________________________________
;+
; FILE: `spec_access.pro'
;
; OVERVIEW:
;       Set of IDL functions to read and write SPEC data files. These functions
;       provide information about the SPEC file (number of scans, scan list,
;       etc...) or about a particular scan (scan data, motor positions, header
;       information ...).
;       In order to speed up the access to the data, a file must be open by the
;       function SPEC_ACCESS() before any other operation is performed. This
;       function returns a handle to the file that has to be used in all
;       subsequent file access. The handle is a variable used to transfer
;       information internally between different functions and must not be
;       modified by the main program. A handle is associated to each individual
;       file and therefore several SPEC files can be accessed by managing
;       different handles.
;       All the functions require at least a file handle as parameter. If the
;       file handle has not been previously initialized, the functions call
;       internally SPEC_ACCESS() and prompt the user for a file name.
;       Most of the functions require also a scan identifier (see below). If 
;       the scan identifier is missing the functions call to XSPECSCAN that
;       is an utility procedure that displays the available scans in the data
;       file and lets the user select one.
;
; SCAN IDENTIFIERS
;       A scan identifier is an expression that designates a particular scan
;       in the data file. It must be a numeric or string scalar. Numeric values
;       can be expressed as strings by using their alphanumeric representation.
;       A scan identifier must be of one of the following three types:
;
;       Scan Number - A non-zero positive number that corresponds to the SPEC
;                     scan number included in the `#S' line in the data file.
;                     A mechanism has been provided to deal with files that
;                     include scans with repeated numbers: if a scan identifier
;                     is expressed as a decimal number SSSS.OO, it refers to
;                     the OOth occurrence of the scan SSSS in the data file.
;                     Special care must be taken when using this feature with
;                     number-valued expressions because the first two decimal
;                     places are always considered. For instance, the
;                     identifier 12.02 refers to the second occurrence of the
;                     scan 12, while 12.2 refers to the 20th occurrence of the
;                     same scan. This problem does not arise when string
;                     expressions are involved: the identifiers '12.02' and
;                     '12.2' refer both to the same scan in the data file.
;
;       Scan Index  - A non-zero integer number that indicates the position of
;                     the scan in the data file. Positive indexes correspond
;                     to the position of scan from the beginning of the file,
;                     the first scan in the file has an index 1. Negative
;                     indexes indicate the position of the scan by counting
;                     backwards from the end: -1 is the last scan in the file,
;                     -2 is the one before the last, and so on.
;                     When an index is used as a scan identifier, the INDEX
;                     keyword must be set in the function call in order to
;                     avoid ambiguities with scan numbers.
;
;       Descriptor  - One of the following words:
;                     'FIRST'  : refers to the first scan in the file.
;                     'LAST'   : refers to the last scan in the file.
;                     'CURRENT': refers to the scan that has been most
;                                recently accessed by any of the functions
;                                of this library.
;                     'NEXT'   : refers to the scan immediately after the
;                                `current' scan.
;       
;       
; FUNCTION LIST:
;       SPEC_ACCESS()  - Returns the number of scans in the file or a scan list.
;       SPEC_COLUMNS() - Returns the number of data columns in a given scan.
;       SPEC_DATA()    - Returns the data from a given scan.
;       SPEC_HEADERS() - Returns headers from a given scan.
;       SPEC_LABELS()  - Returns the column labels in a given scan.
;       SPEC_MOTORS()  - Returns the positions or names of the motors in a scan.
;       SPEC_NAME()    - Returns the name of a given scan.
;       SPEC_POINTS()  - Returns the number of data points in a given scan.
;       SPEC_SAVE()    - Saves data in a SPEC data file.
;       SPEC_SCAN()    - Returns the numbers or the indexes of a list of scans.
;
; MODIFICATION HISTORY:
;       1.00 March/95,  Written by P. Fajardo.
;                       based on 'spec_analyzer.pro' from M. Sanchez del Rio
;       2.00  June/95,  Added support for Multichannel Data (P. Fajardo).
;       2.01  5/07/95,  SPEC_DATA() modified to speed up data access. Default
;                       return data type is no longer string. New __reads
;                       procedure and __linesplit() function.
;                       Now the error handling routines return to the caller
;                       when an error is found (P. Fajardo).
;       2.02 21/08/95,  Fixed a bug in the handling of split lines. New CHANNELS
;                       and CALIBRATED keywords in SPEC_DATA() (P. Fajardo).
;       2.03 29/09/95,  New NO_EMPTY, MCDATA and FILENAME keywords in
;                       SPEC_ACCESS(). New NO_EMPTY, MCDATA and NO_RANGE
;                       keywords in SPEC_SCAN() (P. Fajardo).
;       3.00  --------
;       3.01 16/12/96,  Some elements of file handles changed from integer to
;                       long to cope with very long files.
;       3.02 01/10/97,  srio@esrf.fr places the function spec_access() at
;			the end of the file to allow idl to resolve all
;			names (for use in xop).
;______________________________________________________________________________
;-


;______________________________________________________________________________
;+
; NAME:
;       SPEC_ACCESS()
;
; PURPOSE:
;       This function returns the number of scans in a SPEC data file or
;       optionally the list of scans. The first time that it is called or if
;       the datafile is modified it reads the file and creates an internal
;       index to speed up the subsequent access to the data.
;       This function must be called before any other function of the library.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_ACCESS(Handle [, SPECfile])
;
; INPUTS:
;       Handle   - Variable used as a handle to the file. This variable is
;                  modified internally by the function and must be used in
;                  all subsequent function calls to access the data file.
;                  If the variable used is not a valid handle to the file in
;                  SPECfile or if the length of the file has changed, the
;                  internal index is rebuilt. 
;                  If the variable used is a valid handle that has been 
;                  initialised in a previous call to SPEC_ACCESS(), the
;                  function checks if the current size of the file is the
;                  same than in the previous call. If so, the internal index
;                  is not rebuilt. 
;
; OPTIONAL INPUTS:
;       SPECfile - String that contains the name of the data file. This
;                  parameter is only optional in the case that Handle is a
;                  valid SPEC file handle initialised in a previous call to
;                  SPEC_ACCESS().
;
;
; KEYWORDS:
;       LIST:   Set this keyword to produce a list of the scans in the file.
;               By default the list is a vector that contains all the numbers
;               of the scans in the file. This behaviour can be changed by
;               the COMPRESS and STRING keywords.
;
;       COMPRESS: Set this keyword to return the scan list in a compressed
;               format. In a compressed list the scans with consecutive numbers
;               are grouped in blocks. Each block is described by the numbers
;               of its first and last scan. If the STRING keyword is not set
;               the result is an array with two dimensions where the element
;               (0, i) is the number of the first scan in the group i, and the
;               element (1, i) is the number of the last scan in the group.
;               This keyword has no effect if the LIST keyword is not set.
;
;       STRING: Set this keyword to format the result as a character string
;               rather than as a number, vector or array. If the result is a
;               compressed list, the groups in the output string are separated
;               by commas (',') and the first and last scan number of each
;               group are separated by a minus sign ('-').
;
;       READALWAYS: Set this keyword to force the function to read the file
;               and build the internal index even in the case that Handle is a
;               valid handle to the same file and the size of the file has not
;               changed. If READALWAYS is set, the parameters SPECfile must
;               be specified.
;
;       NOREAD: Set this keyword to force the function not to read again the
;               file even in the case that its size has changed.
;
;       NO_EMPTY: Set this keyword to make the output value of the function
;               refer only to those scans that actually contain standard data
;               columns, excluding the empty ones.
;
;       MCDATA: Set this keyword to make the output value of the function
;               refer only to those scans that contain multichannel data.
;
;       FILENAME: Variable to be loaded with the name of the Spec data file.
;               This keyword is only useful when the function is called with
;               a previously initialized SPEC file handle and the file name
;               is not known.
;
; OUTPUT: 
;       If the LIST keyword is not set this function returns the total number
;       of scans in the SPEC data file. If the LIST keyword is set, it returns
;       a list of the scans.
;
; SIDE EFFECTS:
;       When the internal index is built the `current' scan is set to the
;       first scan in the file.
;
; RESTRICTIONS:
;       This function only works with ASCII files that follow the conventions
;       used by the program SPEC to generate data files.
;
; EXAMPLE:
;       To create an internal index of the SPEC data file 'data.run23' and
;       load the variable Nscans with the total number of scans in the file,
;       enter:
;
;       Nscans = SPEC_ACCESS(File1_handle, "data.run23")
;
;       The variable File1_handle should not be modified by the main program.
;       It may be used to access information from the same file by other
;       function calls.
;______________________________________________________________________________
;-
function spec_access, handle, file, LIST=list, STRING=str, COMPRESS =compress,$
                                    READALWAYS=rall,  NOREAD=noread, $
                                    FILENAME=file0, MCDATA=mca, NO_EMPTY=noemp
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string) ;, /traceback
   endif

; Check arguments
   if N_PARAMS() eq 0 then begin
      message, 'Incorrect number of arguments.'
   endif

;Dids
   if N_PARAMS() eq 1 then begin
      if not __isaspechandle(handle) then message, 'No file selected.' $
      else begin
         file = handle.specfile
      endelse
   endif 

   file0 = file

   if keyword_set(noread) then begin
      goto, result
   endif

; Open SPEC data file
;
; srio changed these lines *porting to Windows* 97/01/13
;   file=(findfile(file))(0)
;   if file eq '' then message, 'File not found'
   if (findfile(file))(0) eq '' then message, 'File not found'
   openr, Unit, file, /get_lun
   status = fstat(Unit)

   if not keyword_set(rall) and __isaspechandle(handle) then begin
      if handle.specfile eq file and handle.filesize eq status.size then begin
         goto, close
      endif 
   endif

   scancounter = 0
   scanlist = 'no scans'

   line = ''
   name = ''
   range = 0B
   linect=lonarr(4)
   n_colmax = 1                              
   n_motlinesmax = 0
   n_motperlinemax = 0
   maxnumber = 0

   s = {scan,                $
          scan_n: 0L,        $
          scan_ap: 0L,       $
          name: '',          $
          predatalines: 0L,  $
          datalines: 0L,     $
          postdatalines: 0L, $
          scanpt: 0L,        $
          labelpt: -1L,      $
          datapt: 0L,        $
          n_col: -1L,        $
          n_chan: -1L,       $
          n_datapoints: 0L,  $
          a_datapoints: 0L,  $
          headerpt: 0L,      $
          headerlines: 0L    $
       }
;
; Start a loop to identify all the scans in the file 
;
   linect(0) = -1
   while (not EOF(Unit)) do begin
      point_lun,-Unit,memory_pointer
      __readline,Unit,line
      linect(range)=linect(range)+1

      if strmid(line,0,1) eq '#' then begin
         if range eq 2 then range = 3

         case strmid(line,1,1) of
            'S': begin
               scan_n=-1
               aux = strmid(line, 2, strlen(line)-2)+' '
               reads, aux, scan_n, name       ; read scan no.
               if strmid(line,2,1) eq ' ' and scan_n gt 0 then begin
                  if range gt 0 then begin
                     __addscan, scanlist, s, linect, range, scancounter
                  endif

                  range = 1
                  linect([1, 2, 3]) = 0
                  if scan_n gt maxnumber then maxnumber = scan_n
                  s.scan_n = scan_n
                  s.name = strtrim(name, 2)
                  s.scanpt = memory_pointer
                  s.n_col = -1
                  s.n_datapoints = 0
                  s.a_datapoints = 0
                  s.datapt = 0L
                  s.labelpt=-1L
               end
            end 

            'N': begin
               ; get no. of data columns
               s.n_col=fix(strmid(line, 2, strlen(line)-2))      
               if s.n_col gt n_colmax then n_colmax = s.n_col
            end

            'L': begin
               s.labelpt=memory_pointer
            end

            'F': begin
               if range gt 0 then begin
                  __addscan, scanlist, s, linect, range, scancounter
                  range = 0
                  s.headerpt = memory_pointer
                  linect(0) = 0
               endif
            end

            'E': begin
               if range gt 0 then begin
                  __addscan, scanlist, s, linect, range, scancounter
                  range = 0
                  s.headerpt = memory_pointer
                  linect(0) = 0
               endif
            end

            'O': begin
               if range gt 0 then begin
                  __addscan, scanlist, s, linect, range, scancounter
                  range = 0
                  s.headerpt = memory_pointer
                  linect(0) = 0
               endif

               aux = __linecut(line)
               reads, aux, format='(2X,I)', aux        ;get no. of motor lines
               if aux + 1 gt n_motlinesmax then n_motlinesmax = aux + 1

               aux = n_elements(__linesplit(line, 2, 0, 0))
               if aux gt n_motperlinemax then n_motperlinemax = aux
            end

            '@': begin
               if strmid(line, 2, 5) eq 'CHANN' then begin
                  reads, line + ' -1', format='(7X,I)', aux
                  s.n_chan = aux
               end
            end

            else: 

         endcase
      endif else if line ne '' then begin
         if range eq 1 then begin
            s.datapt = memory_pointer
            range = 2
         endif else if range eq 3 then begin
            linect(2) = linect(2) + linect(3)
            linect(3) = 0
            range = 2
         endif

         if range eq 2 then begin
            if strmid(line, 0, 2) eq '@A' then begin
               s.a_datapoints = s.a_datapoints + 1
            endif else begin
               s.n_datapoints = s.n_datapoints + 1
            endelse
         endif
      endif
   endwhile

   if range gt 0 then begin
      linect(range)=linect(range)+1
      __addscan, scanlist, s, linect, range, scancounter
   endif

   index = intarr(maxnumber + 1)
   for i = 0, scancounter - 1 do begin
      aux = scanlist(i).scan_n
      index(aux) = index(aux) + 1
      scanlist(i).scan_ap = index(aux)
   endfor

   if n_motlinesmax eq 0 or n_motperlinemax eq 0 then begin
      n_motlinesmax = 1
      n_motperlinemax = 1
   endif 

   handle = {                   $
      SPECfile: file,           $  ;SPEC filename
      filesize: status.size,    $  ;filesize in bytes
      total: scancounter,       $  ;total no. of scans
      scan: scanlist,           $  ;individual scan information
                                $
      currscan: -1,             $  ;current scan 
      label: strarr(n_colmax),  $  ;column labels for currscan
                                $
      headerpt: -1L,            $  ;pointer to last loaded header 
      epoch: -1L,               $  ;epoch value in main header block
      nmotorlines: 0,           $  ;no. motor lines in the main header block
      motor_no: intarr(n_motlinesmax),                     $
                                $  ;motors per line in the main header block
      motornames: strarr(n_motlinesmax, n_motperlinemax)   $
                                $  ;motor names in the main header block
   }

   __specload, handle, 1, /INDEX

close:
   free_lun, Unit

result:
   if handle.total gt 0 then begin
      if keyword_set(mca) and keyword_set(noemp) then begin
         aux = where(handle.scan(*).a_datapoints gt 0 or    $
                     handle.scan(*).n_datapoints gt 0)
         if aux(0) ne -1 then fulllist = handle.scan(aux).scan_n
      endif else if keyword_set(mca) then begin
         aux = where(handle.scan(*).a_datapoints gt 0)
         if aux(0) ne -1 then fulllist = handle.scan(aux).scan_n
      endif else if keyword_set(noemp) then begin
         aux = where(handle.scan(*).n_datapoints gt 0)
         if aux(0) ne -1 then fulllist = handle.scan(aux).scan_n
      endif else begin
         fulllist = handle.scan(*).scan_n
      endelse
   endif
   totsize = n_elements(fulllist)

   if totsize eq 0 then  begin
      if keyword_set(str) then begin
         return, ''
      endif else begin
         return, 0
      endelse
   endif
   ncols = 1
   ngroups = 1
   if keyword_set(list) then begin
      if not keyword_set(compress) then begin
         list = fulllist
         ngroups = totsize
      endif else begin
         ncols = 2
         list = [fulllist(0), fulllist(0)]
         for i = 1L, totsize - 1 do begin
            n = fulllist(i)
            if n eq list(1, ngroups - 1) + 1 then begin
               list(1, ngroups - 1) = n
            endif else begin
               list = [[list], [n, n]]
               ngroups = ngroups + 1
            endelse
         endfor
      endelse
   endif else begin
      list = totsize
   endelse

   
   if not keyword_set(str) then begin
      return, list
   endif else begin
      str=''
      for i = 0, ngroups - 1 do begin 
         if ncols eq 1 then begin
            str0 = strtrim(string(list(i)), 2)
         endif else if list(0, i) eq list(1, i) then begin
            str0 = strtrim(string(list(0, i)), 2)
         endif else begin
            str0 = strtrim(string(list(0, i)), 2) + '-'  $
                 + strtrim(string(list(1, i)), 2)
         endelse

         if i eq 0 then str = str0 else str = str + ', ' + str0
      endfor
      return, str 
   endelse
end

;*******************************************************************************************
;*******************************************************************************************
;*******************************************************************************************

pro spec_wplot,event, runtxt
;** **********
;**
common c_rdspec, c_hand, c_fil, c_siz, c_inor, c_imcd, c_ot, c_list, c_lz, c_fifi, c_bas

runtxt=''
index =event.index
txt   = c_list(index)
i     = strpos(txt,'.')
if (i gt 0) and (i lt 8) then begin    ;runtxt=c_fifi+'{'+strtrim(strmid(txt,0,i),2)+'}'
	r1 = strtrim(string(c_hand.scan(index).scan_n ),2)
	r2 = strtrim(string(c_hand.scan(index).scan_ap),2)
	runtxt=c_fifi+'{'+r1+'.'+r2+'}'
endif
if n_elements(c_list) ne c_lz then SPEC_WLIST
end

pro spec_wlist,lbase
;** **********
;**
common c_rdspec, c_hand, c_fil, c_siz, c_inor, c_imcd, c_ot, c_list, c_lz, c_fifi, c_bas

c_lz =n_elements(c_list)
if n_elements(lbase) eq 1 then $
     c_bas=widget_list(lbase,xsize=20,ysize=c_lz,value=c_list,uvalue=[-88,569,0,-1,0]) $
else if c_bas gt 0 then widget_control,bad_id=ii,c_bas,set_value=c_list
end

function read_spec, INST , PATH , FILENAME , STATUS , DATP
;******* *********
;**
;**	Standard call for a data-read function interfacing LAMP.

common c_rdspec, c_hand, c_fil, c_siz, c_inor, c_imcd, c_ot, c_list, c_lz, c_fifi, c_bas

if n_elements(INST) eq 0 then return,1

STATUS=11
DATA  =0

CATCH,stat & if stat ne 0 then begin CATCH,/cancel & print,!err_string & return,DATA & endif

;Check for scan number
;---------------------
FileN=FILENAME(0)
if n_elements(FILENAME) gt 1 then immg=FILENAME(1) else immg=1
ac=0
i =strpos(FileN,'{')                     & if i lt 0 then i=strpos(FileN,'[')
if i gt 1 then begin j=strpos(FileN,'}') & if j lt 0 then j=strpos(FileN,']')
                     ac=1
                     if j gt i+1  then immg=strmid(FileN,i+1,j-i-1)
		     FileN=strmid(FileN,0,i) & endif
c_fifi=FileN
FileN =PATH+FileN
img= 1 & imm=1   & simg = str_sep(string(immg),'.')
ON_IOERROR,mismg &  img = long(simg(0))>1
if n_elements(simg) eq 2 then imm=long(simg(1))>1
mismg:
imgs=strtrim(string(img),2)+'.'+strtrim(string(imm),2)
if not ac then FILENAME(0)=FILENAME(0)+'{'+imgs+'}'

;Check for file
;--------------
if n_elements(c_fil) eq 0 then begin c_fil='' & c_bas=0L & endif
if c_fil eq FileN         then new=0 else begin new=1 & c_fil=FileN & endelse

ON_IOERROR ,misfil
OPENR, Unit, FileN, /get_lun & S=fstat(Unit) & free_lun,unit
STATUS=13

if not new then if c_siz ne S.size then new=1

;Initialize Handel
;-----------------
if new  then begin print,'Initialising input file ....'
   n=spec_access(c_hand,FileN)
   if n le 0 then  return,DATA
   c_inor = spec_scan(c_hand,'-',/no_empty)
   c_imcd = spec_scan(c_hand,'-',/mcdata)
   c_fil  = FileN
   c_siz  = S.size
   HEAD   = spec_headers(c_hand,1,/ALL,/INDEX)
   F='' & D='' & C=''
   for i=n_elements(HEAD)-1,0,-1 do begin HD=strcompress(HEAD(i))
	a = strmid(HEAD(i),0,2)
	if a eq '#F' then F=' Origin:...'+strmid(HD,(strlen(HD)-20)>3,20)
	if a eq '#D' then D=' Start:'    +strmid(HD,3,25)
	if a eq '#C' then C=' Sample:'   +strmid(HD,3,50)
   endfor
   c_ot   = C+D+F

   inor   = spec_scan(c_hand,'-',/return_index)-1
   imcd   = spec_scan(c_hand,'-',/return_index,/mcdata)-1
   c_list = '<none>'
   if  inor(0) ge 0 then c_list= strtrim(string(c_hand.scan(inor).scan_n),2)+'. '   + $
                                 c_hand.scan(inor).name
   if  imcd(0) ge 0 then begin
    if inor(0) ge 0 then c_list=[c_list,'  ----','MCdata-> '+strtrim(string(c_hand.scan(imcd).scan_n),2)+' '+ $
                                 c_hand.scan(imcd).name]
    if inor(0) lt 0 then c_list= strtrim(string(c_hand.scan(imcd)),2)+'. MC '+ $
                                 c_hand.scan(imcd).name
   endif
   c_lz =0
   P_MAC_EVENT,0,[-88,570,0,-1]
   if n_elements(c_list) ne c_lz then SPEC_WLIST
endif
STATUS=9

;Check if scan number is there
;-----------------------------
mcd=0 & nor=0
idx=where(c_inor eq img) & if idx(0) ge 0 then nor=1
idx=where(c_imcd eq img) & if idx(0) ge 0 then mcd=1
if mcd+nor eq 0 then return,DATA
STATUS=14

;Prepare all variables
;---------------------
P_TXT=spec_headers(c_hand,imgs)+'  '
P_TXT=[P_TXT,FileN+'{'+imgs+'} points--> in PVi variable of Lamp  ']
P    =intarr(n_elements(P_TXT))
PV=0
X =0 & Y =img & Z =img
E =0
N =0
WT='' & XT='' & YT='' & ZT='' & OT=c_ot

T=0. & M=0. & Q='' & Tp=''
For i=n_elements(P_TXT)-1,0,-1 do begin
	a = strmid(P_TXT(i),0,2)
	if a eq '#S' then WT=strmid(strcompress(P_TXT(i)),3,100)
	if a eq '#Q' then Q =' (hkl:' +strmid(strcompress(P_TXT(i)),3,50)+')'
	if a eq '#X' then Tp=' Temp:'+strmid(strcompress(P_TXT(i)),3,50)
	if a eq '#T' then reads,strmid(P_TXT(i),2,20), T
	if a eq '#M' then reads,strmid(P_TXT(i),2,20), M
endfor
WT=WT+Tp     ;+Q
N =[[M],[T]]

;Read the data
;-------------
STATUS=0
if nor then begin
		PV   =spec_data(c_hand,imgs,LABELS=LABL)
		
		if not mcd then begin
		 YT   =LABL(n_elements(LABL)-1)
		 XT   =LABL(0)
		 sz   =SIZE(PV)
		 if sz(0) eq 2 then begin
		   DATA=reform(PV(sz(1)-1,*))
		   MONI=reform(PV(sz(1)-2,*))
		   X  =0 & ok=-1
		   for i=0,sz(1)-3 do begin
			if ok lt 0 then if PV(i,0) ne PV(i,sz(2)-1) then begin
				X=reform(PV(i,*)) & ok=i & endif
		   endfor
		   if ok ge 0 then XT=LABL(ok)
		   E=sqrt(DATA)
		   if N(0,1) gt 0 then begin N=fltarr(sz(2),2) & N(*,0)=MONI & N(*,1)=T
		   endif else $
		   if N(0,0) gt 0 then begin N=fltarr(sz(2),2) & N(*,0)=M & N(*,1)=MONI & endif
		 endif else begin
		   DATA=PV
		 endelse
		endif
endif
if mcd then begin
		DATA =spec_data(c_hand,imgs,/MCDATA,CHANNELS=X,CALIBRATED=calib)
		sz=SIZE(DATA)
		XT='Channels'
		Nt=N
		N =fltarr(sz(1),3) & N(*,0)=M & N(*,1)=T & N(*,2)=calib
		Y =indgen(sz(2))
		if nor then begin
		 sz   =SIZE(PV)
		 YT   =LABL(0)
		 if sz(0) eq 2 then begin
		   ok=-1
		   for i=0,sz(1)-2 do begin
			if ok lt 0 then if PV(i,0) ne PV(i,sz(2)-1) then begin
				Y=reform(PV(i,*)) & ok=i & endif
		   endfor
		   if ok ge 0 then YT=LABL(ok)
		 endif
		endif
endif

;Return every thing
;------------------
DATP={X:      x   , Y:y , Z:z , E:e , N:n   ,$
      W_TIT:  wt  , X_TIT:xt  , Y_TIT:yt    ,$
      Z_TIT:  zt  , OTHER_TIT:ot            ,$
      P:      p   ,    $
      PAR_TXT:p_txt,   $
      PV:     pv       }


misfil: RETURN, DATA
;       ************
 END
function TEMPLATE_read, INST , PATH , FILENAME , STATUS , DATP
;******* *************  
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 INST(2)  is "1" if raw  button is set.
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.
;**		  if FILENAME(1) exists,  this is the requested image number in the file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.

 DATA  =0
 STATUS=11
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

 ON_IOERROR, no_file
 OPENR,unit, PATH+FILENAME,/get_lun				;Open the data file

      STATUS=13
      ON_IOERROR, read_err
      DATA =FLTARR(40,60)					;Make a floating array
      READU,unit,DATA						;Read the data

	    xv       =  FINDGEN(40)*2 +15			;Normaly in data file
	    wt       =' Template_read test '			;         .
	    xt       =' This is the X axis '			;         .
	    par      = [        3.0       ,        5.5        ]	;	  .
	    ptxt     = ['First  parameter','Second parameter' ]	;	  .
	    pall     =  INDGEN(20,8)

      STATUS=0							;Status is ok
;     ********
      DATP={X:      xv,    $					;Pass those variables which were 
            W_TIT:  wt,    $ 					;read-in into the DATP structure
	    X_TIT:  xt,    $                   
	    P:      par,   $
	    PAR_TXT:ptxt,  $
	    PV:     pall   }
;     **********************  					
	    
 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:
 
 RETURN, DATA							;Return the data values
;************

 END
function NXmlparse, fileN, lun, tag,att,str,data, look=look
;******* *********
;**
data= 0  & lan =0
line= '' & str =[''] & tag =[''] & att =['']
ON_IOERROR,mis
if n_elements(lun) eq 0 then lun=0 & if lun eq 0 then OPENR,lun,fileN,/get_lun
ok  = 1
WHILE (ok) do begin
 READF,lun,line & line=strtrim(strcompress(line),2)
 WHILE line ne '' do begin
  bo=strpos(line,'<') & bf=strpos(line,'>') & ni=n_elements(str)-1
;*******************
;*handle xml syntax*
;*******************
  if (bo lt 0) or  (bf lt bo) then begin   str(ni)=str(ni)+line+' '  & line=''
  endif else begin      blc=strpos(line,' ',bo+2)<bf
      if blc lt bo then blc=bf     &       tag =[tag,strmid(line,bo+1 ,blc-bo-1)]
      if blc eq bf then arr=''   else      arr =     strmid(line,blc+1,bf-blc-1)
	if bo  gt 0  then str(ni)=str(ni)+strmid(line,0,bo)+' '
	att=[att,arr]  &  str=[str,'']
	ln=strlen(line)-1 & if bf eq ln then line='' else line=strmid(line,bf+1,ln-bf)
;*******************
;*handle NXml data *
;*******************
	searchATT,arr, 'type', type & if type eq '' then type='float'
	searchATT,arr, 'dims', dims & if strpos(dims,'[') eq 0 then dims=strmid(dims,1,strlen(dims)-2)
	searchATT,arr, 'file_name', fn

	if dims ne '' then begin    ii = EXECUTE("data=make_array("+dims+",/"+type+")")
	  if fn eq '' then begin            ;********** Read values in current xml file
	     READF,lun, data & ok=0
	  endif else if not look then begin ;********** Read values from "file_name"
	     ON_IOERROR,mio
	     searchATT,arr, 'code', codx
	     if strpos(fn,'.gz') lt 0 then begin
			if strpos(fn,'.txt') lt 0 then begin OPENR,lan,fn,/get_lun,/XDR      & READU,lan,data & ok=0
			endif                     else begin OPENR,lan,fn,/get_lun           & READF,lan,data & ok=0
			                          endelse
	     endif else if !version.release ge '5.3' then begin
			if strpos(fn,'.txt') lt 0 then begin OPENR,lan,fn,/get_lun,/compress & READU,lan,data & ok=0
			endif                     else begin OPENR,lan,fn,/get_lun,/compress & READF,lan,data & ok=0
			                          endelse
	     endif else print,'!!!  .gz files supported since V5.3 of Idl'
	     mio:if lan gt 0 then FREE_LUN,lan & ON_IOERROR,mis
	  endif
	endif else begin                    ;********** Read string next lines
	     searchATT, arr, 'lines', nbl
	     if nbl ne '' then begin  data=strarr(long(nbl)) & READF,lun, data & data=strtrim(data,2) & ok=0 & endif
	endelse
  endelse
 ENDWHILE
ENDWHILE
return,1
mis:if lun gt 0 then FREE_LUN,lun & lun=0
return,0
end

pro searchATT, attr, name, value
;** *********
nam=strlowcase(name) & value='' & att=strlowcase(attr)  & getquotATT, att,nam, qt,v,di
if di ge 0 then begin  nl=strlen(nam)+v   & dj =strpos(att, qt ,di+nl)
                       value=strmid(attr,di+nl,dj-di-nl) & endif & END

pro getallATT, attr, names, values
;** *********
names=[''] &   values=[''] & att=attr
WHILE att gt ' '  do  begin getquotATT, att,'', qt,v,di   &   nc=strlen(att)
      if di ge 0 then begin dj =strpos (att, qt ,di+v)    &   names=[names,strmid(att,0,di)]
                 values=[values,strmid(att,di+v,dj-di-v)] &   att  =strmid(att,dj+2,nc-dj-1)
      endif else att=''
ENDWHILE
END

pro getquotATT, att,nam, qt,v,di
;** **********
                       v=1   & nom=nam+ '='         & di =strpos(att, nom) & bi=strpos(att,nam+' =')
if (di lt 0) or ((bi ge 0) and (bi eq di-1)) then begin v=2 & nom=nam+' =' & endif
                                                      di =strpos(att, nom) & bi=strpos(att,nom+' ')
if bi eq di then begin v=v+1 & nom=nom+ ' ' & endif & bi =strpos(att, nom+'"') & qt='"'
if bi ne di then begin          qt="'"              & di =strpos(att, nom+"'") & endif
v=v+1 & END

pro read_xml, FileName , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
;** ********
                         , PR=p, PV=pv, PAR_TXT=p_txt            $
                         , W_tit=wt   , X_tit=xt , Y_TIT=yt      $
                         , Z_tit=zt   , OTHER_TIT=ot , SNAP=snap $
                         , SOURCE=src , Img=immg , HIST=his

CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
STATUS=24
X=0 & Y=0 & Z=0 & E=0 & N=0 & P=0. & PV=0. & P_TXT='' & time='' & lampF=0
LIM   ="" &  WT='' & XT='' & YT='' & ZT='' & OT='' & SNAP=0 & SRC='' & HIS=''
if Data(0) eq -88 then look=1 else look=0  & Data=0
FileN =FILENAME
imm= 1 & if n_elements(immg) ne 1 then img=1 else begin
		simg=str_sep(string(immg),'.')   &  img=long(simg(0))>1
		if n_elements(simg) eq 2 then begin img=long(simg(1))>1 & imm=long(simg(0))>1 & endif
         endelse
ok =1 & NXF='XML' & tiip='UNKNOWN' & nxcur="" & nxI="" & imi =0 & imj  =0
nxdata=0 & nxmonitor=0 & nxsample=0 & nxinstrument=0 & nxbeam=0 & nxlog=0
ON_IOERROR,misloop
WHILE (ok) do begin
	 ok=NXmlparse(fileN, lun, tag,att,str, value ,look=look)
		;print,'<'+tag+' '+att+'>'+str & print,value
	 jj=0
	 WHILE jj lt n_elements(tag) DO begin CASE strlowcase(tag(jj)) of

	 'nxmlfile':begin	searchATT, att(jj), 'file_name' , his  & NXF='NXml'
				searchATT, att(jj), 'file_time' , time & his=his+' '+time
				searchATT, att(jj), 'instrument', ins
				searchATT, att(jj), 'user'      , src  & if ins gt "" then src=ins+" " +src
				if strpos( str(jj), 'LAMP') gt 0 then begin time=str(jj) & lampF=1  & endif
			end
	 'nxentry': begin	imi = imi+1 & if imi le imm then if str(jj) gt ' ' then  his=str(jj)
				if imi gt imm then begin ok=0 & jj=n_elements(tag)  & nxcur="Entry" & endif
			end
	 'nxdata':  begin imj = imj+1 & if imj eq img then nxdata=1 else nxdata=0
				if nxdata  then begin
				searchATT, att(jj), 'title'    , wt   & lim=str(jj) & nxcur="Data"
				searchATT, att(jj), 'sub_title', ot   & if ot  eq ''  then ot=FILENAME(0)
				searchATT, att(jj), 'source'   , hit  & if hit gt ' ' then src=hit
				searchATT, att(jj), 'param'    , hit  & if hit gt ' ' then begin p_txt=[p_txt,'(data) param =']
				                                                                 p    =[p,float(hit)] & endif
				endif & end
	 'parameters':if nxdata then begin
				cn=n_elements(value) & P=fltarr(cn) & p_txt=strarr(cn)  & lampF=1
				for j=0,cn-1 do begin  tmp=value (j)  & r=RSTRPOS(tmp,'=')>0
                                if r ge 0 then begin P(j)=FLOAT(STRMID(tmp,r+1,30))
                                                     p_txt(j)=  STRMID(tmp,0,r+1)   & endif
				endfor
			  endif
	 'var_params':if nxdata then pv= value

	 'errors':    if nxdata then e = value

	 'snapshot':  if nxdata then begin
			  endif
	 'monitors':  begin if  nxmonitor then n=value else if nxdata then if n(0) eq 0 then n=value
			  end
	 'nxinstrument': begin  nxinstrument=1 & nxcur="Instrument" & nxI="I " & end
	 'nxmonitor':    begin  nxmonitor=1    & nxcur="Monitor"  & end
	 'nxsample':     begin  nxsample=1     & nxcur="Sample"  & end
	 'nxbeam':       begin  nxbeam=1       & nxcur="Beam"  & end
	 'nxlog':        begin  nxlog=1        & nxcur="Log"  & pv= value & end

	 '/nxinstrument':begin  nxinstrument=0 & nxcur="" & nxI="" & end
	 '/nxmonitor':   begin  nxmonitor=0    & nxcur="" & end
	 '/nxsample':    begin  nxsample=0     & nxcur="" & end
	 '/nxdata':      begin  nxdata=0       & nxcur="" & end
	 '/nxbeam':      begin  nxbeam=0       & nxcur="" & end
	 '/nxlog':       begin  nxlog=0        & nxcur="" & end
	  ELSE:
	  ENDCASE

	  getallATT, att(jj),  names , values & flg=''
	  if  strpos(strlowcase(tag(jj)),'nx') eq 0 then nxcur=nxI+strmid(tag(jj),2,15)
	  FOR ii=1,n_elements(names)-1 do begin val=values(ii)
				 CASE strlowcase(names(ii)) of
				'signal':begin
				         if val eq '1' then if nxdata then begin DATA=value & flg='d' & endif
				         end
				'axis':  if nxdata then begin
				         if val eq '1'  then begin x=value & flg='1' & endif
				         if val eq '2'  then begin y=value & flg='2' & endif
				         if val eq '3'  then begin z=value & flg='3' & endif
				         endif
				'label': if nxdata then begin
				         if flg eq 'd'  then wt=wt+' '+val
				         if flg eq '1'  then xt=xt+' '+val
				         if flg eq '2'  then yt=yt+' '+val
				         if flg eq '3'  then zt=zt+' '+val
				         endif
				'units': if nxdata then begin
				         if flg eq 'd'  then wt=wt+' '+val
				         if flg eq '1'  then xt=xt+' '+val
				         if flg eq '2'  then yt=yt+' '+val
				         if flg eq '3'  then zt=zt+' '+val
				         endif
				'y_value':  if nxdata then y=float(val)
				'z_value':  if nxdata then z=float(val)
				'file_name':
				'file_time':
				'sub_title':
				'title':
				'lines':
				'size':
				'user':
				'min':
				'max':
				'dims':  if flg eq ''  then begin nc=n_elements(value)
				            if nc le 9 then begin
				               p_txt=[p_txt,strarr(nc)+tag(jj)]  & p=[p,value] & endif
				         end
				'type':  if nxdata then if flg eq 'd' then tiip=val
				 else:   begin mesi='('+nxcur+') '+names(ii) & id=strpos(p_txt,mesi)
				               id=where(id ge 0)  & if id(0) lt 0 then begin   uk=0
				                  ON_IOERROR,misF & valf=0 & valf=float(val) & uk=1 & misF:
							ON_IOERROR,misloop
				                  if uk eq 0 then mesi=mesi+': '+val
				                  p_txt=[p_txt,mesi+' ='] & p=[p,valF]
				                  if strpos(names(ii),'monitor') eq 0 then if n(0) eq 0 then n=valF
				               endif & end
				 ENDCASE
	  ENDFOR
	  misloop:jj=jj+1
	 ENDWHILE
ENDWHILE

if (n_elements(p) gt 1) and (p(0) eq 0) then begin p_txt=p_txt(1:*) & p=p(1:*) & endif

if n_elements(Data) gt 1 then STATUS=0

 IF look then begin
      Data=[time,' ']
      Data=[Data,' SOURCE:         '+src,' '  ,' HISTORY:        '+his ,' ']
	Data=[Data,' FORMAT:         '+NXF      ,' TYPE:           '+tiip,' ',' RANGES:         '+lim ,' ']
	Data=[Data,' TITLES: '+wt,'      X: '+xt,'      Y: '+yt ,'      Z: '+zt,'  OTHER: '+ot,' ']

	Data=[Data,' PARAMETERS:',' ----------']
	for i=0,n_elements(p_txt)-1 do $
	Data=[Data,' * '+p_txt(i)+string(p(i))]
 ENDIF
 END
;-----------------------------------------------------------------------------
;*****************************************************************************
	FUNCTION reb, w_in, dE=dE, force=forcebin, eb, fb
;
;For IN4, IN5, IN6 and D7 data.
;
; rebins output workspace from t2e to constant energy bin width.
;
;ARGUMENTS:
; dE	: required energy bin width
; (eb and fb are obsolete and kept for backwards compatability)
;
;KEYWORDS:
; /force	: rebin over entire energy range
;		  otherwise: rebin only where dE is > point spacing (default)
;
;DIMENSIONS
; w_in=(nE,nspectra) -> w_out(dE, nspectra)
;
;COMMAND SYNTAX:
; w10=reb(w9,dE=<dE>[,/force])
;
; (optional keywords shown in square brackets)
;
;							KHA,JRS 9/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start reb:'

	take_datp, datp
	IF(N_ELEMENTS(eb) GT 0) THEN dE=eb
	IF(N_ELEMENTS(fb) GT 0) THEN forcebin=fb

;-------------------------------------------------------------------------------
;Set up input workspace

	par  =datp.p
	w_out=0

	sw=SIZE(w_in)
	IF (sw(0) EQ 1) THEN nspectra=1     ELSE $
	IF (sw(0) EQ 2) THEN nspectra=sw(2) ELSE return,w_in
	nchannels=sw(1)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	IF (iprint GT 0) THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra

	npts=nchannels

	IF (N_ELEMENTS(dE) EQ 0) THEN BEGIN
		PRINT,'reb: error - dE not specified'
		return,w_in
	ENDIF

	IF (N_ELEMENTS(forcebin) EQ 0) THEN forcebin=0

	x_in=datp.x
	e_in=datp.e

        se=size(e_in)
	sw=size(w_in)

	errors=1
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN errors=0

	IF (iprint GT 0) THEN PRINT,'npts=',npts,' nspectra=',nspectra,' forcebin=',forcebin
	IF (iprint GT 0) THEN PRINT,'End of input setup section'

;-------------------------------------------------------------------------------
;Set up rebin arrays

	IF (forcebin EQ 0) THEN xmin=x_in(0) $
			ELSE xmin=MAX([x_in(0),-50.])
	xmax=x_in(npts-1)

	dx_in=x_in
	dx_in(1:npts-2)=(x_in(2:npts-1)-x_in(0:npts-3))/2.
	dx_in(0)=x_in(1)-x_in(0)	& dx_in(npts-1)=x_in(npts-1)-x_in(npts-2)

	x_in0=FLTARR(npts+1)	; histogram
	x_in0(1:npts-1)=(x_in(0:npts-2)+x_in(1:npts-1))/2.
	x_in0(0)=x_in0(1)-(x_in(1)-x_in(0))
	x_in0(npts)=x_in0(npts-1)+(x_in(npts-1)-x_in(npts-2))

	IF (iprint GT 0) THEN BEGIN
		PRINT,'   channel      x_in        dx_in        x01         x02'
		FOR i=0,npts-1 DO PRINT, i, x_in(i), dx_in(i), x_in0(i), x_in0(i+1)
	ENDIF

	nbin=LONG((xmax-xmin)/dE)+2

	IF (forcebin EQ 1) THEN BEGIN
		IF (iprint GT 0) THEN PRINT,'forcebin=1'
neverwider:
		i0=0
		IF (iprint GT 0) THEN PRINT,'rebin everything'
		xstart=dE*FLOAT(FIX(xmin/dE)-1)
		x_bin=FLOAT(INDGEN(nbin))*dE+xstart
	ENDIF ELSE BEGIN
		IF (iprint GT 0) THEN PRINT,'forcebin=0'
		wider=WHERE(dx_in GT dE, nw)
		IF (nw LE 0) THEN GOTO, neverwider
		x_bin=FLTARR(nbin)
		i0=wider(nw-1)	& x0=x_in(i0)
		IF (iprint GT 0) THEN PRINT,'rebin from x=',x0
		x_bin(0:i0)=x_in(0:i0)
		n=FIX((xmax-x0)/dE)
		IF (x0 LT 0.) THEN xstart=dE*FLOAT(FIX(x0/dE)+1) $
				ELSE xstart=dE*FLOAT(FIX(x0/dE)+2)
		x_bin(i0+1:i0+n)=FLOAT(INDGEN(n))*dE+xstart
		x_bin(i0+1)=(x_bin(i0)+x_bin(i0+2))/2.
		nbin=i0+n+1
		x_bin=x_bin(0:nbin-1)
	ENDELSE


	dx_bin=x_bin
	dx_bin(1:nbin-2)=(x_bin(2:nbin-1)-x_bin(0:nbin-3))/2.
	dx_bin(0)=x_bin(1)-x_bin(0)	& dx_bin(nbin-1)=x_bin(nbin-1)-x_bin(nbin-2)

	x_bin0=FLTARR(nbin+1)	; histogram
	x_bin0(1:nbin-1)=(x_bin(0:nbin-2)+x_bin(1:nbin-1))/2.
	x_bin0(0)=x_bin0(1)-(x_bin(1)-x_bin(0))
	x_bin0(nbin)=x_bin0(nbin-1)+(x_bin(nbin-1)-x_bin(nbin-2))

	IF (iprint GT 0) THEN BEGIN
		PRINT,'   bin      x_bin     dx_bin      x01       x02'
		FOR i=0,nbin-1 DO PRINT, i, x_bin(i), dx_bin(i), x_bin0(i), x_bin0(i+1)
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of rebin array setup section'

;-------------------------------------------------------------------------------
;Perform rebinning

	w_out=FLTARR(nbin,nspectra)
	IF (errors EQ 1) THEN e_out=FLTARR(nbin,nspectra)

	IF (i0 GT 0) THEN BEGIN	; do not rebin first points
		w_out(0:i0-1,*)=w_in(0:i0-1,*)
		IF (errors EQ 1) THEN e_out(0:i0-1,*)=e_in(0:i0-1,*)
	ENDIF

	iptmin=0
	ysum=FLTARR(nspectra)	& esum2=ysum

	FOR ibin=i0,nbin-1 DO BEGIN
		xmin=x_bin0(ibin)	& xmax=x_bin0(ibin+1)
		xsum=0.		& ysum(*)=0.	& esum2(*)=0.
		FOR ipt=iptmin,npts-1 DO BEGIN
			x2=x_in0(ipt+1)
			IF (x2 GT xmin) THEN BEGIN
				x1=x_in0(ipt)
				IF (x1 GT xmax) THEN GOTO, nomore
				IF (x2 LT xmax) THEN xhi=x2 ELSE xhi=xmax
				xhi=MIN([x2,xmax])
				xlo=MAX([x1,xmin])
				deltax=xhi-xlo
				IF (deltax LT 0.0) THEN PRINT,'Error in rebinning'
				xsum=xsum+deltax
				ysum=ysum+deltax*w_in(ipt,*)
				IF (errors EQ 1) THEN esum2=esum2+(deltax*e_in(ipt,*))^2
			ENDIF
		ENDFOR
nomore:		IF (xsum EQ 0.) THEN BEGIN
			w_out(ibin,*)=0.
			IF (errors EQ 1) THEN e_out(ibin,*)=-1.
		ENDIF ELSE BEGIN
			w_out(ibin,*)=ysum/xsum
			IF (errors EQ 1) THEN e_out(ibin,*)=SQRT(esum2)/xsum
		ENDELSE
		iptmin=(ipt-1)>0
	ENDFOR

	x_out=x_bin

	IF (iprint GT 0) THEN PRINT,'End of rebinning section'

;-------------------------------------------------------------------------------
;Remove zeroed points

	IF (errors EQ 1) THEN BEGIN
		WHILE (TOTAL(e_out(0,*)) LT -FLOAT(nspectra)+0.01) DO BEGIN
			x_out=x_out(1:nbin-1)
			w_out=w_out(1:nbin-1,*)
			e_out=e_out(1:nbin-1,*)
			nbin=nbin-1
		ENDWHILE
		WHILE (TOTAL(e_out(nbin-1,*)) LT -FLOAT(nspectra)+0.01) DO BEGIN
			x_out=x_out(0:nbin-2)
			w_out=w_out(0:nbin-2,*)
			e_out=e_out(0:nbin-2,*)
			nbin=nbin-1
		ENDWHILE
	ENDIF

	FOR ispec=0,nspectra-1 DO BEGIN
		IF (TOTAL(w_in(*,ispec),1) EQ 0.) THEN BEGIN
			w_out(*,ispec)=0.
			IF (errors EQ 1) THEN e_out(*,ispec)=-1.
		ENDIF
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of remove zeros section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "x", x_out
	IF (errors EQ 1) THEN mod_datp, datp, "e", e_out

	s=STRTRIM(STRING(dE),2) & i=RSTRPOS(s,'.') & dE=STRMID(s,0,i+3)
	datp.other_tit=datp.other_tit+' -rb('+dE+','+STRTRIM(STRING(forcebin),2)+')'

	IF (forcebin EQ 0) THEN BEGIN
		s=STRTRIM(STRING(x_out(i0)),2) & i=RSTRPOS(s,'.') & Elim=STRMID(s,0,i+2)
		range='where E>'+Elim+'meV'
	ENDIF ELSE range='everywhere'

	PRINT,'reb: rebinned '+range+' to constant energy bin width of '+dE+'meV'

	give_datp, datp

finished:
	RETURN, w_out

	END
pro refract,n1,x0,xr,x1,x2,y1,y2,y,nb

tr=fltarr(500)
lam=fltarr(500)
th2=fltarr(500)
nn=fltarr(500)
nb=fltarr(500)



dpr=180./!pi


count=30
rdan=2.3

dbtrs=5
range=2.
points=15.
shif=3
nx=1.
pcen=135.79/nx
mmpp=1.04*nx 

data_read,n1,w1,w2,y,m,q,th,san,dan,dett,nx,time

refarr=total(w1(xr-shif:xr+shif),1)
th1=san

   k=0.
   kk=0.
   print,'ref pixel maximum:',xr
   for i=xr-shif,xr+shif do begin
    k=k+total(w1(i,*),2)
    kk=kk+total(w1(i,*),2)*float(i)
   endfor

   ppr=kk/k

   print,'ref beam pixel fit:',ppr


thx=(2.*tan(san/dpr))*dett/mmpp
th1=180.*(atan((x0-xr)/dett))/(2.*!pi)
x0c=ppr+thx
print,'san was: ',san,dett,'cal th= ',th1
print,'direct beam calculated at pixel: ',x0c
print,'x0: ',x0

print,x1,x2,y1,y2
for j=0,y2-y1 do begin
   ypix=j+y1
   mm=max(w1(x1:x2,ypix:ypix),b)
   b=b+x1
   k=0.
   kk=0.
   print,'lam pixmax:',y(ypix),b
   for i=b-shif,b+shif do begin
    k=k+w1(i,ypix:ypix)
    kk=kk+w1(i,ypix:ypix)*float(i)
   endfor
   
   tr(j)=(kk/k)
   lam(j)=y(ypix)
   th2(j)=th1-dpr*atan((x0-tr(j))/(dett*mmpp))
   nn(j)=cos(th1/dpr)/cos(th2(j)/dpr)
   nb(j)=(1-nn(j))*2.*!pi/y(ypix)^2
   endfor

   for m=0,y2-y1 do begin
    print,y(m),tr(m),th2(m),nn(m),nb(m)
   endfor
   result=moment(nb(0:y2-y1))
   print,'mean  nb: ',mean(nb(0:y2-y1)),' +/- ',sqrt(result(1))
end
pro reg3d,w,filename,extension=extension,comment=comment,par=par,bad=bad,datp=datp
;+
; Variante of d20reg for 3D-workspaces ...
; Created 27 July 1998 by Th. Hansen after demand of X. Turrillas
;-
@lamp.cbk
IF N_ELEMENTS(w(0,*,0)) LE 1 THEN PRINT,'Attention: The macro is not usefull for simple 2D workspaces, better use d20reg!'
IF N_ELEMENTS(w(0,0,*)) GT 1 THEN PRINT,'Attention: This macro is not ready for 4D workspaces!'
IF NOT KEYWORD_SET(datp) THEN take_datp,datp
if n_elements(filename) eq 0 then filename=W_NUMOR(alone)
if n_elements(extension) eq 0 then extension='xyz'
datname=filename+'.'+extension
txtname=filename+'.'+'txt'
OPENW,txt,txtname,/get_lun
cross='#'
PRINTF,txt,'# ',strmid(datp.other_tit ,0,76)   
IF STRLEN(datp.other_tit) GT 76 THEN PRINTF,txt,cross+' ...',strmid(datp.other_tit ,76,72)
PRINTF,txt,cross+' ',strmid(datp.w_tit  ,0,76)   
IF STRLEN(datp.w_tit) GT 76 THEN PRINTF,txt,cross+' ... ',strmid(datp.w_tit ,76,72)
IF KEYWORD_SET(comment) THEN PRINTF,txt,cross+' ',comment
PRINTF,txt,cross+''
PRINTF,txt,cross+' telnet d20sgi.ill.fr | lamp -nw'
FOR i=1,20 DO BEGIN
    search='w'+strcompress(string(i),/remove)
    flag=0
    IF i NE alone THEN FOR j=0,STRLEN(his(alone))-STRLEN(search)-1 DO BEGIN
      test=strmid(his(alone),j,STRLEN(search))
      if test EQ search and flag eq 0 THEN  BEGIN
        PRINTF,txt,cross+'   '+strmid(his(i),0,76)   
        IF STRLEN(his(i)) GT 76 THEN PRINTF,txt,cross+' ...'+strmid(his(i) ,76,72)
        flag=1
      ENDIF
    ENDFOR
ENDFOR
PRINTF,txt,cross+'   '+strmid(his(alone),0,76)  
IF STRLEN(his(alone)) GT 76 THEN PRINTF,txt,cross+' ...'+strmid(his(alone) ,76,72)
PRINTF,txt,cross+' d20reg,W',strcompress(string(alone),/r),',"',filename,'","',extension,'"'
PRINTF,txt,cross+''
PRINTF,txt,cross+' Created: ',systime()
PRINTF,txt,cross+'      By: ',lamp_host
PRINTF,txt,cross+' x-y-z-dz to be read by xmgr, gnuplot, igor etc.' 
PRINTF,txt,cross+STRCOMPRESS(N_ELEMENTS(w(*,0,0)))+' *'+STRCOMPRESS(N_ELEMENTS(w(0,*,0)))+' points' 
IF KEYWORD_SET(par) THEN PRINTF,txt,cross+''
IF KEYWORD_SET(par) THEN par=par(WHERE(par LT N_ELEMENTS(datp.p) AND par GE 0))
IF KEYWORD_SET(par) THEN FOR i=0,N_ELEMENTS(par)-1 DO PRINTF,txt,cross+' ',datp.par_txt(par(i)),datp.p(par(i))
IF KEYWORD_SET(bad) THEN PRINTF,txt,cross+''
IF KEYWORD_SET(bad) THEN BEGIN
IF N_ELEMENTS(datp.z) EQ 0 THEN PRINTF,txt,cross+' no bad cells' ELSE BEGIN
    IF N_ELEMENTS(w(*,0))+N_ELEMENTS(datp.z) EQ 1600 THEN BEGIN
      PRINTF,txt,cross+string(N_ELEMENTS(datp.z))+' bad cells excluded : cell-no.' 
      FOR i=0,(N_ELEMENTS(datp.z)-1)/15 DO PRINTF,txt,cross+strcompress(datp.z(i*15:i*15+14))
    ENDIF ELSE BEGIN
      PRINTF,txt,cross+string(N_ELEMENTS(datp.z))+' bad cells not excluded, evt. interpolated : cell-no. angle (2th.)' 
      FOR i=0,(N_ELEMENTS(datp.z)-1) DO PRINTF,txt,cross,datp.z(i),datp.x(datp.z(i))
      ENDELSE
  ENDELSE
ENDIF
PRINTF,txt,cross+''
PRINTF,txt,cross+' Monitor/counts   Counting time/sec (A2,F15.0,F9.1)'
PRINTF,txt,format='(A2,F15.0,F9.1)',cross+' ',datp.n(0,0:1<(N_ELEMENTS(datp.n(0,*,0))-1),0)
PRINTF,txt,cross+''
PRINTF,txt,FORMAT="(2A1,A11,3A13)",cross,' ',datp.x_tit,datp.y_tit,datp.z_tit,'sigma'
FREE_LUN,txt
OPENW,dat,datname,/get_lun
PRINT,'Export of ',N_ELEMENTS(w(*,0,0)),' *',N_ELEMENTS(w(0,*,0)), ' cells to ',filename,'.',extension
IF N_ELEMENTS(datp.e(*,*,0)) NE N_ELEMENTS(w(*,*,0)) THEN e=SQRT(w) ELSE e=datp.e
j=(N_ELEMENTS(w(0,*,0)))
i=(N_ELEMENTS(w(*,0,0)))
k=INDGEN(N_ELEMENTS(w(*,*,0)))
out=FLTARR(4,N_ELEMENTS(w(*,*,0)))
IF N_ELEMENTS(datp.x(0,*)) LE 1 THEN  out(0,*) = datp.x(k mod i) ELSE BEGIN
  out(0,*) = datp.x(k mod i,(k / i)<(N_ELEMENTS(datp.x(0,*,0))-1),0)
ENDELSE
IF N_ELEMENTS(datp.y(0,*)) LE 1 THEN out(1,*) = datp.y(k / i) ELSE  BEGIN
  out(1,*) = datp.y((k mod i)<(N_ELEMENTS(datp.y(*,0,0))-1),(k / i)<(N_ELEMENTS(datp.y(0,*,0))-1),0)
ENDELSE
out(2,*) = w(k)
out(3,*) = e(k)
PRINTF, dat,out
PRINT, 'finished - use tempcat for list of numor - time - temperature - monitor ...'
FREE_LUN,dat
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION remove, w_in, min=xmin, max=xmax, xin, xax

; Removes points from 1-d data within x-region specified by xmin, xmax. 
;
;ARGUMENTS:
; min	: min of x-region
; max	: max of x-region
;
;DIMENSIONS
; 1-d data only
;
;COMMAND SYNTAX:
; w2=remove(w1,min=<min>,max=<max>)
;
;						KHA, 28/11/97
;-------------------------------------------------------------------------------
;*******************************************************************************

	take_datp, datp

	IF(N_ELEMENTS(xin) GT 0) THEN xmin=xin
	IF(N_ELEMENTS(xax) GT 0) THEN xmax=xax

	x_in=datp.x
	e_in=datp.e

	s=SIZE(w_in)
	IF (s(0) NE 1) THEN BEGIN
		PRINT,'remove: Error - workspace must be 1-dimensional'
		GOTO, finished
	ENDIF

	iOK=WHERE(x_in LE xmin OR x_in GE xmax, nOK)
	IF (nOK LE 0) THEN BEGIN
		PRINT,'remove: Error - no data points will be kept'
		GOTO, finished
	ENDIF

	x_out=x_in(iOK)
	w_out=w_in(iOK)
	e_out=e_in(iOK)

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out

finished:
	give_datp, datp

	RETURN, w_out
	END
;------------------------------------------------------------------------------
;******************************************************************************
;
	FUNCTION remove_spectra, w_in, badspecs, nolog=nolog
;
; For IN4, IN5, IN6 and HET
; Removes spectra with numbers given in array badspecs. Spectrum numbers
; run from 1 to nspectra.
;
;KEYWORDS
; /nolog	: if set, supresses output of badspecs in other_tit
;		  This is necessary in cases where other_tit exceeds 160 characters
;
;ARGUMENTS
; badspecs	: array of spectrum numbers to be deleted
;
;DIMENSIONS
; w_in(nchannels,nspectra) -> w_out(nchannels,nspectra-n) - n=number of bad specs
;
;COMMAND SYNTAX
;  e.g. w2=remove_spectra(w1,[3,90,202])	-remember square brackets
;
;							KHA,JRS 29/6/02
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start remove_specs:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace

	par=datp.p

	x_in=datp.x
	y_in=datp.y
	e_in=datp.e
	z_in=datp.z

	sw=size(w_in)
	nchannels=sw(1)
	IF (sw(0) EQ 1) THEN nspectra=1     ELSE $
	IF (sw(0) EQ 2) THEN nspectra=sw(2) ELSE return,w_in
	npts=nchannels

	se=size(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN e_in=SQRT(w_in)

	nbad=N_ELEMENTS(badspecs)
	IF (nbad EQ 0) THEN badspecs=1
	bad=badspecs-1

	IF (iprint GT 0) THEN PRINT,'npts=',npts,' nspectra=',nspectra,' nbad=',nbad
	IF (iprint GT 0) THEN PRINT,'End of input setup section'

;-------------------------------------------------------------------------------
;Remove bad spectra
;
	ispec=INDGEN(nspectra)
	FOR ibad=0,nbad-1 DO BEGIN
		i=WHERE(ispec NE bad(ibad), n)
		IF (n EQ nspectra) THEN $
			PRINT,'remove_specs: Warning - spectrum',bad(ibad)+1,' does not exist'
		ispec=ispec(i)
	ENDFOR

	w_out=w_in(*,ispec)
	e_out=e_in(*,ispec)
	y_out=y_in(ispec)
	z_out=z_in(ispec)
	IF (iprint GT 0) THEN PRINT,'End of "remove bad spectra" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out
	mod_datp, datp, "z", z_out
	IF (nbad EQ 0) THEN badstring='(0)' ELSE BEGIN $
		bad=STRTRIM(badspecs+1,2)	& badstring=bad(0)
		FOR i=1,nbad-1 DO badstring=badstring+','+bad(i)
		badstring='('+badstring+')'
	ENDELSE

	PRINT,'remove_specs: Removed spectra '+badstring
	IF NOT KEYWORD_SET(nolog) THEN $
		datp.other_tit=datp.other_tit+' -rs'+badstring

	give_datp, datp

finished:
	RETURN, w_out

	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION remove_zeros, w_in

;removes points with y=0 and e=-1 from 1-D workspace
;
;DIMENSIONS:
; 1d workspace only
;
;COMMAND SYNTAX
; w2=remove_zeroes(w1)
;
;							KHA, 8/12/96
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start remove_zeros:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	x_in=datp.x
	e_in=datp.e

	writedata=1
	sw=SIZE(w_in)
	IF (sw(0) NE 1) THEN BEGIN
		PRINT,'Remove_zeros: Error - w_in must be 1-D'
		GOTO, finished
	ENDIF

	se=SIZE(e_in)
	FOR i=0,se(0) DO IF (se(i) NE sw(i)) THEN GOTO, noerrors
	GOTO, errorsOK
noerrors:
	PRINT,'remove_zeros: Error - no error bars set'
	GOTO, finished
errorsOK:
	PRINT,'SIZE(w_in)=',sw
	npts=sw(1)

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Remove zeroed points

	x_out=x_in	& w_out=w_in	& e_out=e_in

	PRINT,'OK1'
	nout=0-1
	PRINT,'OK2'
	FOR i=0,npts-1 DO BEGIN
		PRINT,'OK3'
		IF (w_in(i) NE 0.) OR (e_in(i) GE 0.) THEN BEGIN
			nout=nout+1
			x_out(nout)=x_in(i)
			w_out(nout)=w_in(i)
			e_out(nout)=e_in(i)
		ENDIF
		PRINT,'OK4'
	ENDFOR
	nout=nout-1

	PRINT,'OK5'
	x_out=x_out(0:nout-1)
	w_out=w_out(0:nout-1)
	e_out=e_out(0:nout-1)
	PRINT,'OK6'

	IF (iprint GT 0) THEN PRINT,'End of "Remove zeroed points" section'

;-------------------------------------------------------------------------------
;Return and exit

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out

	give_datp, datp

finished:
	IF (iprint GT 0) THEN PRINT,'End remove_zeros:'

	RETURN, w_out
	END
;------------------------------------------------------------------------------
;******************************************************************************
;
	FUNCTION rescale_t, w_in, Told=Told, Tnew=Tnew

;For IN5 and IN6 data
;
;Rescales data taken at a temperature Told to a temperature Tnew, using
;the Bose thermal population factor. Workspace data must be as a function
;of energy transfer. Energies in meV.
;
;ARGUMENTS
; Told	: Temperature of input data
; Tnew	: Desired rescaling temperature
;
;DIMENSIONS
; w_in(dE,nspectra)=w_out
;
;COMMAND SYNTAX
; w10=rescale_t(w9,Told=<Told>,Tnew=<Tnew>)
;
;							KHA,JRS 7/8/00
;
;------------------------------------------------------------------------------
;******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start rescale_t:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace and energy parameters

	par=datp.p

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	nchannels=sw(1)
	IF (sw(0) EQ 1) THEN nspectra=1     ELSE $
	IF (sw(0) EQ 2) THEN nspectra=sw(2) ELSE return,w_in

	IF (iprint GT 0) THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	x_in=datp.x
	y_in=datp.y
	e_in=datp.e

	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN e_in=SQRT(w_in)

;-------------------------------------------------------------------------------------
;	Perform correction

	kB=0.0861735	; Boltzmann constant in meV/K

	w_out=w_in
	e_out=e_in
	x_out=FLTARR(nchannels)
	y_out=datp.y

	arg=x_in/(kB*Told)	& Bose=arg
	i=WHERE(arg LT -50.,n)
	IF (n GE 1) THEN arg(i)=-50.
	i=WHERE(arg GT 50.,n)
	IF (n GE 1) THEN arg(i)=50.
	i=WHERE(arg NE 0.,n)
	Bose(i)=1./(1.-EXP(-arg(i)))
	i=WHERE(arg EQ 0.,n)
	IF (n GE 1) THEN Bose(i)=10000.
	i=WHERE(ABS(Bose) GE 9999.,n)
	IF (n GE 1) THEN Bose(i)=Told
	Bold=Bose

	arg=x_in/(kB*Tnew)
	i=WHERE(arg LT -50.,n)
	IF (n GE 1) THEN arg(i)=-50.
	i=WHERE(arg GT 50.,n)
	IF (n GE 1) THEN arg(i)=50.
	i=WHERE(arg NE 0.,n)
	Bose(i)=1./(1.-EXP(-arg(i)))
	i=WHERE(arg EQ 0.,n)
	IF (n GE 1) THEN Bose(i)=10000.
	i=WHERE(ABS(Bose) GE 9999.,n)
	IF (n GE 1) THEN Bose(i)=Tnew
	Bnew=Bose

	corr=Bnew/Bold	; temperature correction factor

	IF (iprint GT 0) THEN BEGIN
		PRINT, 'channel      Eps       Bose(old)    Bose(new)   ratio'
		FOR i=0,nchannels-1 DO PRINT, i, x_in(i), Bold(i), Bnew(i), corr(i)
	ENDIF

	corr=corr#(FLTARR(1,nspectra)+1)

	w_out=w_in*corr
	e_out=e_in*corr

	IF (iprint GT 0) THEN PRINT,'End of main section'
;-------------------------------------------------------------------------------------

	datp.e=e_out

	s=STRTRIM(STRING(FLOAT(Told)),2) & i=RSTRPOS(s,'.') & Told=STRMID(s,0,i+2)
	s=STRTRIM(STRING(FLOAT(Tnew)),2) & i=RSTRPOS(s,'.') & Tnew=STRMID(s,0,i+2)
	datp.other_tit=datp.other_tit+' rt('+Told+','+Tnew+')'

	give_datp, datp

	PRINT,'rescale_t: Rescaled from T='+Told+'K to T='+Tnew+'K'

finished:
	RETURN, w_out
	END


pro res


;Read in two Dt/t's and two q's to establish variables
redo:
print,""
read,"Res1,q1,Res2,q2 :>",r1,q1,r2,q2
if r1 eq 9 then begin
	r1=.01
	q1=.05
	r2=.02
	q2=1.3
endif
if (r1 lt 0) or (r2 lt 0) or (q1 lt 0) or (q2 lt 0) then begin
	print,"No negative numbers allowed, please redo"
	goto, redo
endif

print,"Processing... Please Wait" 


;ensure accuracy
r1=float(r1) & r2=float(r2) & q1=float(q1) & q2=float(q2) 


;calculate gradient (m) and intercept (c)
rmin=r1<r2 & rmax=r1>r2 & qmin=q1<q2 & qmax=q1>q2
m=(rmax-rmin)/(qmax-qmin)
c=rmax-m*qmax
print,c,m

;Ranges Of The Variables (min,max) stored on disc
;in ranges.dat
d=[0.,0.]
dis=[0.,0.]
w=[0.,0.]
lamda=[0.,0.]
phi=[0.,0.]
r=0.
openr,1,'ranges.dat'
readf,1,d,dis,w,lamda,phi,r
close,1

;dis=Dis-(d(1)-d(0))/2 ;small correction
k=3956.0346035 ; In A
n=8;no of examples

;obtain dis and d
nd=101; higher means more accurate range
dist=dis(0)+findgen(nd)*(dis(1)-dis(0))/(nd-1)
dist=dist*c
if max((dist lt d(1)) and (dist gt d(0))) then begin
	dist=dist(where(dist lt d(1)))
	dist=dist(where(dist gt d(0)))
	d=[min(dist),max(dist)]; new range
	dis=[d(0)/c,d(1)/c]; new range
endif else begin
	print,"d range out of bounds"
	goto, pass
endelse
	

;obtain omega
nw=101
dist=dis(0)+findgen(nw)*(dis(1)-dis(0))/(nw-1)
w1=2*!pi*k/dist/lamda(1)
if max((w1 lt w(1)) and (min(w1) gt w(0))) then begin
	w1=w1(where(w1 gt w(0)))
	w1=w1(where(w1 lt w(1)))
	w(0)=[min(w1),max(w1)];new range
	dis=rotate(2*!pi*k/lamda(1)/w,2);new range
	d=c*dis;newrange
endif else begin
	print,"w range out of bounds"
	goto, pass
endelse

;obtain chopper angle
phil=2*!pi*m/((1/qmin)-(1/qmax))
phil=phil/!pi*180 ; do i do this line ???????????????????????
if ((phil gt phi(1)) or (phil lt phi(0))) then begin
	print, "Chopper angle invalid"
	goto, pass
endif



;delta x
velchop=w*r
velbeam=k/lamda,2
b=atan(velchop/velbeam)
x=d*sin(b)


;Draw the plot
ng=21 ;No of points in graph
Tt=fltarr(ng) ;Time Resolution
q=fltarr(ng) ;q values
q=qmin+(findgen(ng)*(qmax-qmin)/(ng-1))
Tt=m*q+c
plot,q,Tt,ystyle=1,xstyle=1,xtitle="q (1/m)",ytitle="Dt/t",title="Time Resolution For Double Chopper",$
psym=0


; Print data out
print,"Dist is in the range      :",dis(0),dis(1)
print,"d is in the range         :",d(0),d(1)
print,"Rpms are in the range     :",w(1)*60/2/!pi,w(0)*60/2/!pi
print,"The Chopper angle is      :",phil
print,'Range of Delta x          :',x
print,"Range of velocity of beam :",velbeam

;Generate n values of Dist,d and rpms
dist=dis(0)+findgen(n)*(dis(1)-dis(0))/(n-1)
dt=dist*c
w=2*!pi*k/lamda(1)/dist
print,""
print,"Examples :"
print,"Dist :",dist
print,"d    :",dt
print,"w    :",w*60/2/!pi

pass:
end
;TEMPORARY ROUTINE WHICH UPDATES THAT ONE CONTAINED IN BENS.PRO
;**************************************************************

pro rgp_groupNum,varAccess,n,disp
;;;;; This procedure calculates the groupings.
;;;;; The range of unmasked angles is searched, and then the list of
;;;;; the sinus of the half-angles is divided into `n' parts, which
;;;;; are of the same width. If a part is empty, ie it does not include
;;;;; any spectrum, it is removed. In a part, the `average' angle is
;;;;; set to the mean value of its limits, and not to the mean of
;;;;; the angles corresponding to the spectra. The 'grouped' spectrum
;;;;; is the average of all the included spectra.
   widget_control,get_uvalue=set,varAccess.settings
   if (n lt 0) then n=set.ngroups $
   else if (set.ngroups eq n) then return $
   else set.ngroups=n
   widget_control,get_uvalue=mask,varAccess.mask
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=daty,varAccess.datAccess.y
   msk=reform(mask.cur(0,*))
   temp=where(msk ne 0,usedCount)
   if (usedCount le 0) then return
   widget_control,set_uvalue=set,varAccess.settings
   sinList=1000*sin(!pi*msk*daty/360.0)
   temp=where((daty eq 0) and (msk ne 0),count)
   if (count gt 0) then begin
      minSub=min(temp)
      infVal=0
   end else begin
      minSub=min(where(sinList gt 0))
      infVal=sinList(minSub)
   end
   aver=(max(sinList,maxSub)-infVal)/n
   index=intarr(n+1,/nozero)
   sinAver=(360.0/!pi)*asin(aver/1000*(findgen(n)+0.5))
   index(0)=minSub
   for i=1,n-1 do begin
      infVal=infVal + aver
      temp=where(sinList gt infVal,count)
      if (count ne 0) then index(i)=min(temp) $
      else index(i)=index(i-1)
   end
   index(n)=maxSub+1
   ind=0
   ;;;;; The empty parts are now removed.
   for i=1,n do $
      if (index(i) ne index(ind)) then begin
	 ind=ind+1
	 index(ind)=index(i)
	 sinAver(ind-1)=sinAver(i-1)
      end
   if (ind eq 0) then return
   index=index(0:ind)
   sinAver=sinAver(0:ind-1) + min(daty) ;DID!
   ;;;;; The info label is updated.
   if (ind eq 1) then res='One group.' $
   else res=(NUM2STR(ind,0) + ' groups.')
   temp=n-ind
   if (temp ne 0) then begin
      if (temp eq 1) then temp='(-1)' $
      else temp=('(-'+NUM2STR(temp,0) + ')')
      res=(res + temp)
   end
   widget_control,set_value=res,IDs.info(2)
   widget_control,set_uvalue={index:index,sinAver:sinAver},varAccess.groups
   ;;;;; The display is updated if `disp' is set to 1.
   if disp then rgp_drawGroups,varAccess
end
PRO roberto 



f10scan,.17,10,0.01,200


d17mad,'temp'
d17mad,'pte 35'
wait,180
d17mad,'pte 37'
wait,30
d17mad,'pte 38'
wait,30
d17mad,'pte 39'
wait,30
d17mad,'pte 40'
wait,60
; total time to change the temperature 10 min.s
f10scan,.17,10,0.01,200

d17mad,'temp'
d17mad,'pte 55'
wait,180
d17mad,'pte 57'
wait,30
d17mad,'pte 58'
wait,30
d17mad,'pte 59'
wait,30
d17mad,'pte 60'
wait,60
; total time to change the temperature 10 min.s
f10scan,.17,10,0.01,200

d17mad,'temp'
d17mad,'pte 65'
wait,30
d17mad,'pte 67'
wait,30
d17mad,'pte 68'
wait,30
d17mad,'pte 69'
wait,30
d17mad,'pte 70'
wait,60
; total time to change the temperature 6 min.s
f10scan,.17,10,0.01,200

; putting magnetic field to 0
d17mad,'rmg'
wait,2
d17mad,'pmg 0.0 1 1000'


;heating up the sample at 120K
d17mad,'temp'
d17mad,'pte 90'
wait,600


end

pro setpar_txt, inst_val,wi
;** **********
@lamp.cbk
     		par_txt(wi,0) ='X Dectector size (pixels)         ='
     		par_txt(wi,1) ='Y Dectector size (pixels)         ='

		if (inst_val eq 'in15') then begin
     		   par_txt(wi,2) ='Time of Flight if 1               ='
     		   par_txt(wi,3) ='Preset Monitor if 1 , time if 2   ='
     		   par_txt(wi,4) ='Wave lenght                       ='
     		   par_txt(wi,5) ='TOF Channel resolution            ='
     		   par_txt(wi,6) ='TOF Channel width                 ='
     		   par_txt(wi,7) ='TOF Delay                         ='
     		   par_txt(wi,8) ='???                               ='
;**
		 endif else if (inst_val eq 'd19')  then begin
     		   par_txt(wi,2) ='Acquisition number (>0 for scan ) ='
     		   par_txt(wi,3) ='Starting points                   ='
     		   par_txt(wi,4) ='Scan angle (2=omega 3=chi 4=phi)  ='
     		   par_txt(wi,5) ='Scan angle 1 value                ='
     		   par_txt(wi,6) ='Non  Scan  angle phi              ='
     		   par_txt(wi,7) ='Non  Scan  angle chi              ='
     		   par_txt(wi,8) ='Non  Scan  angle omega            ='
     		   par_txt(wi,9) ='Non  Scan  angle 2 theta          ='
     		   par_txt(wi,10)='Monitor 1                         ='
     		   par_txt(wi,11)='Time 1                            ='
;**
  		 endif else if (inst_val eq 'db21') then begin
     		   par_txt(wi,2) ='Acquisition number (>0 for scan ) ='
     		   par_txt(wi,3) ='Starting points                   ='
     		   par_txt(wi,4) ='Scan angle (2=omega 3=chi 4=phi)  ='
     		   par_txt(wi,5) ='Scan angle 1 value                ='
     		   par_txt(wi,6) ='Non  Scan  angle phi              ='
     		   par_txt(wi,7) ='Non  Scan  angle chi              ='
     		   par_txt(wi,8) ='Non  Scan  angle omega            ='
     		   par_txt(wi,9) ='Non  Scan  angle 2 theta          ='
     		   par_txt(wi,10)='Monitor 1                         ='
     		   par_txt(wi,11)='Time 1                            ='
;**
		 endif
return
end

pro rpcill, inst_val,run,wi,wstr,status
;** ******
;   Used by ILL only
@lamp.cbk

	instru =long(0)
	ttp    ='=lonarr'
	
	if inst_val eq 'espace'  then inst_val='d19'  else $
	if inst_val eq 'in5sgi'  then inst_val='in5'  else $
	if inst_val eq 'in6sgi'  then inst_val='in6'  else $
	if inst_val eq 'in10sgi' then inst_val='in10' else $
	if inst_val eq 'd7sgi'   then inst_val='d7'   else $
	if inst_val eq 'd19sgi'  then inst_val='d19'  else $
	if inst_val eq 'db21sgi' then inst_val='db21'
	
;	if inst_val eq 'in4'     then instru=long(1)    else $
;	if inst_val eq 'in5'     then instru=long(2)    else $
;	if inst_val eq 'in6'     then instru=long(3)    else $
;	if inst_val eq 'in15'    then instru=long(5)    else $
;	if inst_val eq 'in10'    then instru=long(4)    else $
;	if inst_val eq 'in16'    then instru=long(6)    else $
;	if inst_val eq 'd7'      then instru=long(7)    else $
	if inst_val eq 'd9'      then instru=long(8)    else $
;	if inst_val eq 'd11'     then instru=long(9)    else $
;	if inst_val eq 'd17'     then instru=long(10)   else $
	if inst_val eq 'd19'     then begin
				      instru=long(11) & ttp='=intarr' & endif else $
	if inst_val eq 'd22'     then instru=long(12)   else $
	if inst_val eq 'db21'    then begin
				      instru=long(13) & ttp='=intarr' & endif
	
    if  (instru    gt   0) and $
       ((lamp_data eq 'hostvms') or (lamp_data eq 'idol')) then begin

        status =3
	run    =long(run)
	channel=long(0) & spect=long(0) & np=long(0) & text=bytarr(512) & param=fltarr(512)

	entri=sys_dep('ENTRY')   ;lamp_entry
	com1='status=call_external(lamp_exec,entri,instru,get,run,channel,spect,np,text,param,0,0)'
	com2='status=call_external(lamp_exec,entri,instru,get,run,channel,spect,np,text,param,nppar,'$
				   +'w'+wstr+')'
	stat=0 & iii=1
      	catch,stat
      	if (stat eq 0) and (iii eq 1) then begin
;**	Get the parameters
;**	*** *** **********
	    get=long(0)
      	    iii=execute(com1)
      	    status=get
      	    if iii ne 1 then status=23
      	    if (status eq 0) then begin 
      	      w0  =0
      	      full=0
      	      if (wi gt 0) and (wi le 20+3) then iii=execute('w'+wstr+'=0') else full=-1

	      if (np gt 201) then np=201
      	      if (full ge 0) and (np ge 0) then begin
;**	Allocate all spaces
;**	******** *** ******
		if (inst_val eq 'd11') or (inst_val eq 'd17') or (inst_val eq 'd22') then $
		    if (channel ge 64.*64.) and (spect  le 1) then begin channel=long(sqrt(channel))
		    							 spect  =channel & endif
      	    	if np gt 0 then nppar=fltarr(15,2,np) else nppar=0
      	    	if spect le 1 then iii=execute('w'+wstr+ttp+'(channel)')     else $
      	    	if np    le 1 then iii=execute('w'+wstr+ttp+'(channel,spect)'   ) $
      	    		      else iii=execute('w'+wstr+ttp+'(channel,spect,np)')

;**	Get the data
;**	*** *** ****
      	    	get    =long(1)
      	    	iii=execute(com2)
      	    	status=get
      	        if iii ne 1 then status=23
	      endif 	    else status=8
;**	Must be positive
;**	**** ** ********
	      if (status eq 0) and (ttp eq '=intarr') then begin
	      	  mini=0 & iii=execute('mini=min(w'+wstr+')')
	      	  if mini lt 0 then begin
	      	  	hhs=0 & iii=execute('hhs=where(w'+wstr+' lt 0)')
	      	  	iii=execute('w'+wstr+'=long(w'+wstr+')')
	      	  	iii=execute('w'+wstr+'(hhs)=65536+w'+wstr+'(hhs)')
	      endif & endif

;**	Place all parameters
;**	***** *** **********
		clearpar, wi,wstr
		
		npar=n_elements(param) & if npar gt npars then npar=npars
		iii =execute('p' +wstr+'= param(0:npar-1)')       
      	    	w_numor(wi)	 = strtrim(string(run),2)

     	        w_tit(wi)	 =strcompress(string(text(0:59)))
     	        x_tit(wi)	 ='Channels'   
     	        y_tit(wi)	 ='Spectra'   
     	        if np gt 1 then z_tit(wi) ='Points' else  z_tit(wi) ='Counts' 
     	        other_tit(wi)	 =w_numor(wi)+' '+strcompress(string(text(60:79))) $
     	        			     +' '+strcompress(string(text(80:159)))
     	        head_tit (wi,*)  =''
     	        head_tit (wi,2)  =inst_value
;**
		if (inst_val eq 'in15') or (inst_val eq 'd19') or (inst_val eq 'db21') then begin
     	         w_tit(wi)	=strcompress(string(text(36:107)))
     	         head_tit (wi,4)=				string(text(4:13))
     	         other_tit(wi)  =string(text(0:3))   +' Date '+ string(text(4:13))  +' Time '+ $
     	        		 string(text(14:21)) +' User '+ string(text(24:29)) +' '     + $
     	        		 string(text(30:35)) +' Run ' + w_numor(wi)
                 x_tit(wi)	='Detector X'   
     	         y_tit(wi)	='Detector Y'
		 setpar_txt, inst_val,wi
		  
		 if (inst_val eq 'in15') then begin
    	           iii=execute('p' +wstr+'= [param(0:3),param(33:37)]')       
    	           iii=execute('pv'+wstr+'=  nppar')       
;**
		 endif else if (inst_val eq 'd19')  then begin
     		   ptmp= [param(0:1),param(6),param(17),param(26),nppar(0,1,0),$
     		   	  param(36),param(37),param(38),param(39),nppar(0,0,0),$
     		   	  nppar(1,0,0)]
    	           iii=execute('p' +wstr+'= ptmp')       
    	           iii=execute('n' +wstr+'=[[nppar(0,0,0:np-1)],[nppar(1,0,0:np-1)]]')       
    	           iii=execute('z' +wstr+'=[ nppar(0,1,0:np-1)]')       
;     	           iii=execute('pv'+wstr+'=[ nppar(1,1,0:np-1)]')       
;** 	
  		 endif else if (inst_val eq 'db21') then begin
     		   ptmp= [param(0:1),param(6),param(17),param(26),nppar(0,1,0),$
     		   	  param(36),param(37),param(38),param(39),nppar(0,0,0),$
     		   	  nppar(1,0,0)]
    	           iii=execute('p' +wstr+'= ptmp')       
    	           iii=execute('n' +wstr+'=[[nppar(0,0,0:np-1)],[nppar(1,0,0:np-1)]]')       
    	           iii=execute('z' +wstr+'=[ nppar(0,1,0:np-1)]')
    	         endif       

 		endif else begin
 		   mic,1
		   P_MIC_SETRUN, run,wi,text,param
		endelse
      	      endif
      	    endif else begin catch,/cancel
			     P_MUS,'mus_cannon'
      	    		     status=23 & endelse
      	endif else begin
		bz   ='Current Cycle'
		idx=strpos(lamp_ali,inst_val)
		idx=where (idx ge 0)
		if  idx(0) ge 0 then bz=lamp_ali(idx(0))
		CYCLE=''
		RDSET , BASE=bz
		p_did_getrun, run,wi,status
	endelse
return
end
pro sansan

; program to set san=theta without using the dan coder

calsan

; that should get it to within 0.02 degrees

dbdan=1.
sanmax=0.7
sanstep=0.05
sanmin=0.1
count=10
mmpp=1.0213
dpr=180./!pi
pcen=139.98
range=5

mv,'dan',dbdan
mv,'dan',dbdan
mv,'san',0
mv,'trs',5

co,count,'t n'

   m=DIAL_MAD_READ('motors')
   d0=m(16)
   det=m(15)
   print,'dan error was dan-true=',dbdan-d0
   d17data,data
   s=size(data)
   if s(0) gt 1 then data=total(data,2)
   d=max(data,p0)

   print,'direct beam pixel maximum:',p0
   
   yy=gaussfit(findgen(286),data,a)
   print,'gausfit db: ',a(1)
   pp0=a(1)
  

; scan san 

mv,'trs',-0.5
mv,'trs',0.
points=floor(((sanmax-sanmin)/sanstep)+1)

sant=fltarr(points)
ppr=fltarr(points)

for i=0,points-1 do begin
  san=sanmax-float(i)*sanstep
  mv,'san',san
  m=DIAL_MAD_READ('motors')
  print,'moved san to ',m(2), (m(2)-san)
  prc=pp0-(2.*det*m(2))/(dpr*mmpp)
  ph=pp0-(det*m(2))/(dpr*mmpp)
  print,'expected reflection pixel: ',prc

  
  aa=total(fix(prc)-range)
  ab=total(fix(prc)+range)
  
  print,'will search between: ',aa,ab
  co,count,'t n'
   d17data,data
   s=size(data)
   if s(0) gt 1 then data=total(data,2)

   d=max(data(aa:ab),pr)

   pr=pr+aa
  
   print,'reflection pixel maximum:',pr

   yy=gaussfit((findgen(ab-aa+1)+float(aa)),data(aa:ab),a)
   print,'gaussfit centre: ',a(1)
   ppr(i)=a(1)
    
   print,'reflection pixel fit:',ppr(i)
   sant(i)=m(2)
endfor

ppr=pp0-ppr


z=poly_fit(ppr,sant,1,yout,yband,sigma,corr)

plot,ppr,sant,psym=2,xtitle='pixels',ytitle='san',$
yrange=[sanmin-0.1,sanmax+0.1]
xout=sant
oplot,ppr,yout


print,'calculated offset:  ',z(0),mean(yband)
print,'calculated gradient:',z(1),sigma/z(1)
mmppc=(z(1)*det/dpr)*2.0
print,'calculated mmpp based on this gradient:',mmppc
print,'present mmpp= ',mmpp
;print,'percentage difference: ', ((mmppc-mmpp)*100.)/mmpp

;print,'sigma',sigma

;print,'yerrors on fit',yband

mv,'san',z(0)
mv,'san',z(0)

d17mad,'par set san 0'

end






	FUNCTION s_background, w_in1, emp, cad, T

; Performs background subtraction of normalised SANS data.

; w_in1=sample run
; emp is number of workspace containing the background run
; cad is number of workspace containing the cadmium run (optional)
; For attenuation corrections without a cadmium run set cad=0

;						JRS, 2/3/00
 	
	iprint=0

	IF (iprint GT 0) THEN PRINT,'Start s_background:'

	take_datp, dat1
	take_w, w_in2, W=emp
	take_datp, dat2, W=emp
	IF(N_ELEMENTS(cad) EQ 0) THEN cad=0
	IF (cad GT 0) THEN BEGIN
		take_w, w_in3, W=cad
		take_datp, dat3, W=cad
	ENDIF ELSE BEGIN
		w_in3=0.*w_in2
	ENDELSE

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces and setup output workspace

	sw1=SIZE(w_in1)
	sw2=SIZE(w_in2)
	sw3=SIZE(w_in3)
	par1=dat1.p
	par2=dat2.p
	IF (cad GT 0) THEN par3=dat3.p
	parv2=dat2.pv
	IF (cad GT 0) THEN parv3=dat3.pv	
	e_in1=dat1.e
	e_in2=dat2.e
	IF(cad GT 0) THEN e_in3=dat3.e ELSE e_in3=0.*e_in2
		
	s1=SIZE(w_in1)
	s2=SIZE(w_in2)
	s3=SIZE(w_in3)
	IF (s1(0) EQ 3) THEN nruns=s1(3) ELSE nruns=1
	IF (s2(0) NE 2 OR s3(0) NE 2) THEN BEGIN
		PRINT, 's_background:ERROR - background runs should not be concatenated'
	ENDIF
	
	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
; Perform Backgound Subtraction

	IF(N_ELEMENTS(T) EQ 0) THEN T=1.		;default T=1

	PRINT,'Background Subtraction using:'
	PRINT,'Background runs in workspace',emp
	IF (cad GT 0) THEN PRINT,'Cadmium runs in workspace',cad ELSE $
			   PRINT,'No cadmium runs'
	PRINT,'T= ',T

        tarr=0.*w_in1+T
	w_out=w_in1
	e_out=e_in1
	FOR i=1,nruns DO BEGIN
		w_out(*,*,i-1)=(1./tarr)*(w_in1(*,*,i-1)-w_in3)-(w_in2-w_in3)
		e_out(*,*,i-1)=sqrt((e_in1(*,*,i-1)/tarr)^2+e_in2^2+((1.-1./tarr)*e_in3)^2)	
	ENDFOR

        IF(iprint GT 0) THEN PRINT,'End of background subtraction section'

;-------------------------------------------------------------------------------
;Return parameters and exit
	
	dat1.e=e_out

        bgnumor=STRTRIM(STRING(LONG(par2(26))),2)
	
	IF (cad GT 0) THEN BEGIN
        	cdnumor=STRTRIM(STRING(LONG(par3(26))),2)
	ENDIF ELSE BEGIN
		cdnumor='no cd'
	ENDELSE

	muRs=STRTRIM(STRING(T),2)
muR0:	n=STRLEN(muRs)	& i=RSTRPOS(muRs,'0')
	IF (i EQ n-1) THEN BEGIN
		muRs=STRMID(muRs,0,n-1)
		GOTO, muR0
	ENDIF

	params=muRs

	dat1.other_tit=dat1.other_tit+' -bg(#'+bgnumor+',#'+cdnumor+','+params+')'

finished:

	IF (iprint GT 0) THEN PRINT,'End background:'

	give_datp, dat1

	RETURN, w_out

	END
PRO resize_window,event
  widget_control,event.top,get_uvalue=pointertodata
  widget_control,pointertodata,get_uvalue=info
  drawwidgetid=widget_info(event.id,/child)
  widget_control,drawwidgetid,draw_xsize=event.x,draw_ysize=event.y
  wset,info.wid
  IF n_elements(info.data(0,*)) gt 1 THEN shade_surf,info.data,info.p.x,info.p.y ELSE plot,info.p.x,info.data
END

PRO FirstWid_Event,event
widget_control,event.top,get_uvalue=info
wset,info.wid
Widget_control,event.id,Get_value=buttonValue
CASE buttonValue OF
  'Shaded Plot':	IF n_elements(info.data(0,*)) gt 1 THEN Shade_surf,info.data,info.p.x,info.p.y
  'Surface Plot':	IF n_elements(info.data(0,*)) gt 1 THEN surface,info.data,info.p.x,info.p.y
  'Contour Plot':	IF n_elements(info.data(0,*)) gt 1 THEN contour,info.data,info.p.x,info.p.y,nlevels=12,/follow,c_colors=indgen(6)*20+80
  'Default Plot':	see,info.data
  'Line Plot':		IF n_elements(info.data(0,*)) le 1 THEN plot,info.p.x,info.data
  'Pretreatment':	pretreat,info.data
  'Calibration':	calib,info.data
  'Single Pattern':	unic,info.data
  'Goodbye':		BEGIN
  			  print,'See you later!'
			  Widget_Control,event.top,/Destroy
			END
ENDCASE
END

FUNCTION scan,w
tlb =		Widget_base  (Column=1,Title='First Widget Program',tlb_frame_attr=1)
topmenu =	widget_button(tlb,    value='Plot Options',/menu)
shadedplot =	widget_button(topmenu,value='Shaded Plot')
surfaceplot =	widget_button(topmenu,value='Surface Plot')
contourplot =	widget_button(topmenu,value='Contour Plot')
defaultplot =	widget_button(topmenu,value='Default Plot')
lineplot =	widget_button(topmenu,value='Line Plot')
pretreat =	widget_button(tlb,    value='Pretreatment')
calib =		widget_button(tlb,    value='Calibration')
unic =		widget_button(tlb,    value='Single Pattern')
byebutton =	widget_button(tlb,    value='Goodbye')
graphicsbase =	widget_base  (tlb_size_events=1,event_pro='Resize_Window',uvalue=tlb,xoffset=50,yoffset=75,group_leader=tlb)
draw=		Widget_Draw  (graphicsbase,xsize=200,ysize=200)
widget_control,tlb,/realize
widget_control,graphicsbase,/realize
widget_control,draw,get_value=windowindex
wset,windowindex
loadct,5
take_datp,datp
IF n_elements(w(0,*)) gt 1 THEN shade_surf,w,datp.x,datp.y ELSE plot,datp.x,w
info={data:w,p:datp,wid:windowindex}
widget_control,tlb,set_uvalue=info
XManager,'FirstWid',tlb,Event='FirstWid_Event'
give_datp,datp
return,w
END
	FUNCTION s_concatenate, w1, w2

;For SANS (D11,D22) data only
;
;concatenates two workspaces. Must be performed on raw data, i.e.
;before calling s_normalise.pro
;
; e.g. w3=concatenate(w1,w2)
;	w1(nspectra,nspectra,nrun1)
;	w2(nspectra,nspectra,nrun2) -> w3(nspectra,nspectra,nrun1+nrun2)
;
;						KHA,JRS 3/3/00

	COMMON c_lamp_access, inst

	IF (inst NE 'D11' AND inst NE 'D22') THEN BEGIN
		PRINT,'concatenate: Error - instrument must be D11 or D22'
		GOTO, finished
	ENDIF

	iprint=0

	take_datp, dat1
	take_datp, dat2, /third

;-------------------------------------------------------------------------------
; Check dimensions section

	x1=dat1.x	& x2=dat2.x
	y1=dat1.y	& y2=dat2.y
	n1=dat1.n	& n2=dat2.n	
	p1=dat1.p	& p2=dat2.p	
	pv1=dat1.pv	& pv2=dat2.pv
	e_in1=dat1.e	& e_in2=dat2.e

	sn1=SIZE(n1)
	sn2=SIZE(n2)
	IF (sn1(0) EQ 1) THEN n1=FLTARR(1)+n1(0)
	IF (sn2(0) EQ 1) THEN n2=FLTARR(1)+n2(0)

	s1=SIZE(w1)	& s2=SIZE(w2)
	IF (iprint GT 0) THEN PRINT,'size(w1)=',s1
	IF (iprint GT 0) THEN PRINT,'size(w2)=',s2
	nspectra1=s1(1)	& nspectra2=s2(1)
	IF (s1(0) EQ 3) THEN nruns1=s1(3) ELSE nruns1=1
	IF (s2(0) EQ 3) THEN nruns2=s2(3) ELSE nruns2=1

	IF (nspectra1 NE nspectra2) THEN BEGIN
		PRINT,'Concatenate: Error in par dimensions:'
		PRINT,'par(w1)=',p1
		PRINT,'par(w2)=',p2
		GOTO, finished
	ENDIF

	IF (N_ELEMENTS(e_in1) GT 1 OR N_ELEMENTS(e_in2) GT 1) THEN BEGIN
		PRINT,'Concatenate: Error - data must be raw, i.e. not normalised'
		GOTO, finished
	ENDIF

	nspectra=nspectra1

	IF (iprint GT 0) THEN PRINT,'nruns1=',nruns1,' nruns2=',nruns2

	IF (iprint GT 0) THEN PRINT,'s_concatenate: End of "check dimensions" section'

;-------------------------------------------------------------------------------
;Perform Concatenation

	IF (nruns1 EQ 1) THEN BEGIN
		IF (nruns2 EQ 1) THEN BEGIN
			pv_out=[[p1],[p2]]
		ENDIF ELSE BEGIN
			pv_out=[[p1],[pv2]]
		ENDELSE
	ENDIF ELSE BEGIN
		IF (nruns2 EQ 1) THEN BEGIN
			pv_out=[[pv1],[p2]]
		ENDIF ELSE BEGIN
			pv_out=[[pv1],[pv2]]
		ENDELSE
	ENDELSE

	n_out=[[n1],[n2]]
	w_out=[[[w1]],[[w2]]]

	nruns=nruns1+nruns2
	datp=dat1

	z_out=FLTARR(nruns)
	IF (iprint GT 0) THEN PRINT,'s_concatenate: End of "concatenation" section'

;-------------------------------------------------------------------------------
; Return data

	mod_datp, datp, "z", z_out
	mod_datp, datp, "n", n_out
	mod_datp, datp, "pv", pv_out

	s=dat1.other_tit & i=RSTRPOS(s,' ') & n=STRLEN(s)
	runs1=STRMID(s,i+1,n-1)

	s=dat2.other_tit & i=RSTRPOS(s,' ') & n=STRLEN(s)
        runs2=STRMID(s,3,i-1)

	IF (nruns1 EQ 1) THEN BEGIN
		IF (STRPOS(runs1,'>') EQ -1) THEN runs1=STRTRIM(STRING(LONG(p1(26))),2)
		r1='1 run'
	ENDIF ELSE BEGIN
		IF (STRPOS(runs1,'>') EQ -1 AND STRPOS(runs1,',') EQ -1) $
		THEN runs1=STRTRIM(STRING(LONG(pv1(26,0))),2)+':'+STRTRIM(STRING(LONG(pv1(26,nruns1-1))),2)
		r1=STRTRIM(STRING(nruns1),2)+' runs'
	ENDELSE
	IF (nruns2 EQ 1) THEN BEGIN
		IF (STRPOS(runs2,'>') EQ -1) THEN runs2=STRTRIM(STRING(LONG(p2(26))),2)
		r2='1 run'
	ENDIF ELSE BEGIN
		IF (STRPOS(runs2,'>') EQ -1 AND STRPOS(runs2,',') EQ -1) $
		THEN runs2=STRTRIM(STRING(LONG(pv2(26,0))),2)+':'+STRTRIM(STRING(LONG(pv2(26,nruns2-1))),2)
		r2=STRTRIM(STRING(nruns2),2)+' runs'
	ENDELSE

	PRINT,'concatenate: '+r1+' and '+r2+' concatenated to give '+STRTRIM(STRING(nruns),2)+' runs'
	s=datp.other_tit & i=STRPOS(s,' ') & n=STRPOS(s,'Start:') & datp.w_tit=STRTRIM(STRMID(s,i+1,n-4),2)	
	datp.other_tit=inst+'  #'+runs1+','+runs2+' -cc'

	give_datp, datp

finished:
	RETURN, w_out
	END
Function sdev,w,relation=relation
if n_elements(w(0,*)) ge 3 then begin
  take_datp,datp
  result=fltarr(N_elements(w(*,0)))
  IF KEYWORD_SET(relation) THEN relation=result
  for i=0,N_elements(w(*,0))-1 do begin
    if total(abs(w(i,*))) gt 0 then begin
      mean=moment(w(i,*),sdev=tmp) 
      result(i)=tmp
    endif else result(i)=0.
    IF KEYWORD_SET(relation) THEN if total(datp.e(i,*)) gt 0 then relation(i)=result(i)/(total(datp.e(i,*)))*n_elements(w(0,*))
  endfor
  datp.y_tit='sdev'
  give_datp,datp
  return,result/sqrt(N_ELEMENTS(w(0,*)))
endif else begin
  print,'Not enough data sets'
  relation=datp.e
  return,w
endelse
end
;-------------------------------------------------------------------------------
;*******************************************************************************

	PRO read_parameters, s

	V = DIAL_MAD_READ('t_para')
;------------------------------------------------------------------------------
; Setup parameter strings

	nparams = 52
	s = STRARR(nparams)
	s[0]     = STRTRIM(STRING(V.c_user),2)
	s[1]     = STRTRIM(STRING(V.c_lc),2)
	s[2]     = STRTRIM(STRING(V.c_txt),2)		
	s[3]     = STRTRIM(STRING(V.tof_cha_resol),2)
	s[4]     = STRTRIM(STRING(V.cha_width),2)
	s[5]     = STRTRIM(STRING(V.tof_delay),2)
	s[6]     = STRTRIM(STRING(V.wave),2)
	s[7]     = STRTRIM(STRING(V.icry),2)
	s[8]     = STRTRIM(STRING(V.preset_base),2)
	s[9]     = STRTRIM(STRING(V.preset_coef_z),2)
	s[10]    = STRTRIM(STRING(V.preset_coef_xyz),2)
	s[11:15] = STRTRIM(STRING(V.zcurrent[*]),2)
	s[16:20] = STRTRIM(STRING(V.xcurrent[*]),2)
	s[21:25] = STRTRIM(STRING(V.ycurrent[*]),2)
	s[26]    = STRTRIM(STRING(V.zpo_fli),2)
	s[27]    = STRTRIM(STRING(v.zpo_cor),2)
	s[28]    = STRTRIM(STRING(V.the_bob_dep),2)
	s[29]    = STRTRIM(STRING(v.the_bob_last),2)
	s[30]    = STRTRIM(STRING(V.the_bob_depx),2)
	s[31]    = STRTRIM(STRING(v.the_bob_lastx),2)
	s[32]    = STRTRIM(STRING(V.the_bob_depy),2)
	s[33]    = STRTRIM(STRING(v.the_bob_lasty),2)
	s[34]    = STRTRIM(STRING(V.the_bob2_dep),2)
	s[35]    = STRTRIM(STRING(v.the_bob2_last),2)
	s[36]    = STRTRIM(STRING(V.the_bob2_depx),2)
	s[37]    = STRTRIM(STRING(v.the_bob2_lastx),2)
	s[38]    = STRTRIM(STRING(V.the_bob2_depy),2)
	s[39]    = STRTRIM(STRING(v.the_bob2_lasty),2)
	s[40:42] = STRTRIM(STRING(V.bank1[*]),2)
	s[43:45] = STRTRIM(STRING(V.bank2[*]),2)
	s[46:48] = STRTRIM(STRING(V.bank3[*]),2)
	s[49:51] = STRTRIM(STRING(V.bank4[*]),2)

	FOR i = 0, nparams-1 DO BEGIN
		posdot = STRPOS(s[i],'.')
		pos00  = STRPOS(STRMID(s[i],posdot),'00')
		IF (pos00 NE -1) THEN s[i] = STRMID(s[i],0,pos00+posdot)
		last = STRLEN(s[i])
		IF STRPOS(s[i],'.') EQ last - 1 THEN s[i] = s[i]+'0'
		IF RSTRPOS(s[i],'0') EQ last - 1 THEN $
		IF STRPOS(s[i],'.') NE -1  THEN s[i] = STRMID(s[i],0,last-1)
	ENDFOR

	END

;-----------------------------------------------------------------------------
;*****************************************************************************

	PRO Set_Param_D7_event, ev

;-----------------------------------------------------------------------------

	WIDGET_CONTROL, ev.top, GET_UVALUE = info

	CASE ev.id OF

	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_2t0'): BEGIN
		a = STRARR(6)	
		FOR i = 0,5 DO BEGIN
			WIDGET_CONTROL, info.theta[0,i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par 2theta fli '+a[0]+a[1]+a[2]+a[3]+a[4]+a[5]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_2t1'): BEGIN
		a = STRARR(6)	
		FOR i = 0,5 DO BEGIN
			WIDGET_CONTROL, info.theta[1,i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par 2theta cor '+a[0]+a[1]+a[2]+a[3]+a[4]+a[5]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_2t2'): BEGIN
		a = STRARR(3)	
		FOR i = 0,2 DO BEGIN
			WIDGET_CONTROL, info.theta[2,i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par 2theta th1 '+a[0]+a[1]+a[2]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_2t3'): BEGIN
		a = STRARR(3)	
		FOR i = 0,2 DO BEGIN
			WIDGET_CONTROL, info.theta[3,i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par 2theta th2 '+a[0]+a[1]+a[2]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_2t4'): BEGIN
		a = STRARR(3)	
		FOR i = 0,2 DO BEGIN
			WIDGET_CONTROL, info.theta[4,i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par 2theta th3 '+a[0]+a[1]+a[2]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_2t5'): BEGIN
		a = STRARR(3)	
		FOR i = 0,2 DO BEGIN
			WIDGET_CONTROL, info.theta[5,i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par 2theta th4 '+a[0]+a[1]+a[2]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_s0'): BEGIN
		a = STRARR(2)	
		FOR i = 0,1 DO BEGIN
			WIDGET_CONTROL, info.setup[i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par name '+a[0]+a[1]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_s1'): BEGIN
		a = STRARR(2)	
		FOR i = 0,1 DO BEGIN
			WIDGET_CONTROL, info.setup[i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par name '+a[0]+a[1]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_s2'): BEGIN
		WIDGET_CONTROL, info.setup[2], GET_VALUE = dummy
		a = dummy+' '
		command = 'par mco '+a
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_c0'): BEGIN
		WIDGET_CONTROL, info.count[0], GET_VALUE = dummy
		a = dummy+' '
		command = 'par preset_b '+a
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_c1'): BEGIN
		WIDGET_CONTROL, info.count[1], GET_VALUE = dummy
		a = dummy+' '
		command = 'par preset_z '+a
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_c2'): BEGIN
		WIDGET_CONTROL, info.count[2], GET_VALUE = dummy
		a = dummy+' '
		command = 'par preset_xyz '+a
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_i0'): BEGIN
		WIDGET_CONTROL, info.inst[0], GET_VALUE = dummy
		a = FIX(dummy[0])
		command = 'par tof '+STRING(a)
		WIDGET_CONTROL, info.inst[0], SET_VALUE = STRTRIM(STRING(a),2)
		IF FIX(dummy[0]) EQ 1 THEN $
			FOR i = 1,2 DO WIDGET_CONTROL, info.inst[i], SENSITIVE = 0 $
		ELSE $
			FOR i = 1,2 DO WIDGET_CONTROL, info.inst[i], SENSITIVE = 1
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_i1'): BEGIN
		a = STRARR(3)	
		FOR i = 0,2 DO BEGIN
			WIDGET_CONTROL, info.inst[i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par tof '+a[0]+a[1]+a[2]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_i2'): BEGIN
		a = STRARR(3)	
		FOR i = 0,2 DO BEGIN
			WIDGET_CONTROL, info.inst[i], GET_VALUE = dummy
			a[i] = dummy+' '
		ENDFOR
		command = 'par tof '+a[0]+a[1]+a[2]
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_i3'): BEGIN
		WIDGET_CONTROL, info.inst[3], GET_VALUE = dummy
		a = dummy+' '
		command = 'par wav '+a
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_i4'): BEGIN
		WIDGET_CONTROL, info.inst[4], GET_VALUE = dummy
		a = FIX(dummy[0])
		command = 'par cryo '+STRING(a)
		WIDGET_CONTROL, info.inst[4], SET_VALUE = STRTRIM(STRING(a),2)
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_refresh'): BEGIN
		read_parameters, s
		FOR i = 0,2 DO WIDGET_CONTROL, info.setup[i], SET_VALUE = s[i]
		FOR i = 3,7 DO WIDGET_CONTROL, info.inst[i - 3], SET_VALUE = s[i]
		FOR i = 8,10 DO WIDGET_CONTROL, info.count[i - 8], SET_VALUE = s[i]
		null = ['','','']
		cpar = REFORM([s[11:27],null],5,4)
		FOR i = 0,4 DO FOR j = 0,3 DO IF (j LT 3) OR ((j EQ 3) AND (i LT 2)) THEN $
			WIDGET_CONTROL, info.bobs[j,i], SET_VALUE = cpar[i,j]
		tpar = REFORM([s[28:42],null,s[43:45],null,s[46:48],null,s[49:51],null], 6, 6)
		FOR i = 0,5 DO FOR j = 0,5 DO IF (j LT 2) OR ((j GE 2) AND (i LT 3)) THEN $
			WIDGET_CONTROL, info.theta[j,i], SET_VALUE = tpar[i,j]
		GOTO, finished
	    END
	    WIDGET_INFO(ev.top, FIND_BY_UNAME='d7p_exit'): BEGIN
		WIDGET_CONTROL, ev.top, /DESTROY
		GOTO, finished
	    END	

	    ELSE: GOTO, finished
	ENDCASE

; send command to MAD

	PRINT, 'Command sent to MAD: '+command
	dummy = DIAL_MAD_SEND('',0,command,'')
	
finished:

	END


;------------------------------------------------------------------------------
;******************************************************************************

	PRO Set_Param_D7

; Interactively reads and sets instrument parameters
; (perhaps to be bolted on to d7_status)
;
;						JRS 22/5/02
;------------------------------------------------------------------------------
;******************************************************************************

	COMMON c_lamp_font

	iprint = 0

	read_parameters, s

;-------------------------------------------------------------------------------
; Create Widgets

	d7p_base  = WIDGET_BASE(TITLE = 'D7 Parameters', UNAME = 'D7P_BASE', $
		   /COLUMN)
	d7p_row1  = WIDGET_BASE(d7p_base, /COLUMN, /ALIGN_CENTER)
	d7p_row11 = WIDGET_BASE(d7p_row1, /ROW, /ALIGN_CENTER)
	d7p_row12 = WIDGET_BASE(d7p_row1, /ROW, /ALIGN_CENTER)
	d7p_row2  = WIDGET_BASE(d7p_base, /ROW, /ALIGN_CENTER)
	d7p_setup = WIDGET_BASE(d7p_row11, FRAME = 1, /ROW)
	d7p_count = WIDGET_BASE(d7p_row11, FRAME = 1, /ROW)
	d7p_inst  = WIDGET_BASE(d7p_row12, FRAME = 1, /ROW)
	d7p_bobs  = WIDGET_BASE(d7p_row12, FRAME = 1, /ROW)
	d7p_2t    = WIDGET_BASE(d7p_row2,  FRAME = 1, /ROW)

;-------------------------------------------------------------------------------
; Setup base

	d7p_setup_l = INTARR(3)
	d7p_setup_b = INTARR(3)
	d7p_setup_d = INTARR(3)
	d7p_txt = ['User: ','Local Contact: ','Expt. Title: ']
	d7p_setup_label = WIDGET_LABEL(d7p_setup,VALUE = 'Setup: ', $
			  FONT = ft_b_bigger)
	d7p_setup_labs  = WIDGET_BASE(d7p_setup, /COLUMN)
	d7p_setup_boxes = WIDGET_BASE(d7p_setup, /COLUMN)
	d7p_setup_butts = WIDGET_BASE(d7p_setup, /COLUMN)
	FOR i = 0, 2 DO BEGIN
		d7p_setup_l[i]  = WIDGET_LABEL(d7p_setup_labs, VALUE = d7p_txt[i], $
				  XOFFSET = 1, YOFFSET = 3, SCR_YSIZE = 30, FONT = ft_normal, $
				  /ALIGN_RIGHT)
		d7p_setup_b[i]	= WIDGET_TEXT(d7p_setup_boxes, SCR_XSIZE = 200, SCR_YSIZE = 30, $
				  /EDITABLE, FONT = ft_propor, VALUE = s[i])
		d7p_setup_d[i]  = WIDGET_BUTTON(d7p_setup_butts, SCR_XSIZE = 30, SCR_YSIZE = 26, $
				  VALUE = 'Do',UNAME = 'd7p_s' + STRTRIM(STRING(i),2), $
				  FONT = ft_b_bigger, FRAME = 1)
	ENDFOR

;-------------------------------------------------------------------------------
; Instrument base

	d7p_inst_l = INTARR(5)
	d7p_inst_b = INTARR(5)
	d7p_inst_d = INTARR(5)
	d7p_txt = ['Time channels: ','Channel width: ','Delay: ',$
		   'Wavelength: ','Cryostat (0/1): ']
	d7p_inst_label = WIDGET_LABEL(d7p_inst, VALUE = 'Inst.: ', FONT = ft_b_bigger)
	d7p_inst_labs  = WIDGET_BASE(d7p_inst, /COLUMN)
	d7p_inst_boxes = WIDGET_BASE(d7p_inst, /COLUMN)
	d7p_inst_butts = WIDGET_BASE(d7p_inst, /COLUMN)
	FOR i = 0, 4 DO BEGIN
		d7p_inst_l[i]  = WIDGET_LABEL(d7p_inst_labs, VALUE = d7p_txt[i],$
				 XOFFSET = 1, YOFFSET = 3, SCR_YSIZE = 30, FONT = ft_normal, $
				 /ALIGN_RIGHT)
		d7p_inst_b[i]  = WIDGET_TEXT(d7p_inst_boxes, SCR_XSIZE = 100, SCR_YSIZE = 30, $
				 /EDITABLE, FONT = ft_propor, VALUE = s(i+3))
		d7p_inst_d[i]  = WIDGET_BUTTON(d7p_inst_butts, SCR_XSIZE = 30, SCR_YSIZE = 26, $
				 VALUE = 'Do', UNAME = 'd7p_i' + STRTRIM(STRING(i),2), $
				 FONT = ft_b_bigger, FRAME = 1)
	ENDFOR

;-------------------------------------------------------------------------------
; Count base

	d7p_count_l = INTARR(3)
	d7p_count_b = INTARR(3)
	d7p_count_d = INTARR(3)
	d7p_txt = ['preset_b: ','preset_z: ','preset_xyz: ']
	d7p_count_label = WIDGET_LABEL(d7p_count, VALUE = 'Count: ', FONT = ft_b_bigger)
	d7p_count_labs  = WIDGET_BASE(d7p_count, /COLUMN)
	d7p_count_boxes = WIDGET_BASE(d7p_count, /COLUMN)
	d7p_count_butts = WIDGET_BASE(d7p_count, /COLUMN)
	FOR i = 0, 2 DO BEGIN
		d7p_count_l[i]  = WIDGET_LABEL(d7p_count_labs, VALUE = d7p_txt[i], $
				  XOFFSET = 1, YOFFSET = 3, SCR_YSIZE = 30, FONT = ft_normal, $
				  /ALIGN_RIGHT)
		d7p_count_b[i]	= WIDGET_TEXT(d7p_count_boxes, SCR_XSIZE = 100, SCR_YSIZE = 30, $
				  /EDITABLE, FONT = ft_propor, VALUE = s(i+8))
		d7p_count_d[i]  = WIDGET_BUTTON(d7p_count_butts,SCR_XSIZE = 30,SCR_YSIZE = 26, $
				  VALUE = 'Do', UNAME = 'd7p_c' + STRTRIM(STRING(i),2), $
				  FONT = ft_b_bigger, FRAME = 1)
	ENDFOR

;-------------------------------------------------------------------------------
; Currents base

	d7p_bobs_l     = INTARR(5)		;no.of label lines
	d7p_bobs_l2    = INTARR(5)		;no of columns
	d7p_bobs_b     = INTARR(4,5)		;boxes table
	d7p_bobs_d     = INTARR(4)		;no. of do buttons
	d7p_bobs_boxes = INTARR(5)
	bpars	       = REFORM([s[11:27],'','',''],5,4)	;currents
	d7p_txt  = [' ','pcz: ','pcx: ','pcy: ','pczp: ']
	d7p_txt2 = ['b1','b2','b3','b4','b5']

	d7p_bobs_label    = WIDGET_LABEL(d7p_bobs, VALUE = 'Currents: ', FONT = ft_b_bigger)
	d7p_bobs_labs     = WIDGET_BASE (d7p_bobs, /COLUMN)
	FOR i=0,4 DO $
	d7p_bobs_boxes(i) = WIDGET_BASE (d7p_bobs, /COLUMN)
	d7p_bobs_butts    = WIDGET_BASE (d7p_bobs, /COLUMN)
	d7p_blank         = WIDGET_LABEL(d7p_bobs_butts, VALUE = ' ',XOFFSET = 1, $
			    YOFFSET = 3, SCR_YSIZE = 30)

	FOR i = 0, 4 DO BEGIN			;loop around rows

		d7p_bobs_l[i] = WIDGET_LABEL(d7p_bobs_labs, VALUE = d7p_txt[i], $
			        XOFFSET = 1, YOFFSET = 3, SCR_YSIZE = 30, $
			        FONT = ft_normal, /ALIGN_RIGHT)
		IF  i LT 4 THEN $
		d7p_bobs_d[i] = WIDGET_BUTTON(d7p_bobs_butts, $
		   		SCR_XSIZE = 30, SCR_YSIZE = 26, $
		   		VALUE = 'Do', UNAME = 'd7p_b' + STRTRIM(STRING(i),2), $
		   		FONT = ft_b_bigger, FRAME = 1)
				   
		FOR j = 0, 4 DO BEGIN		;loop around columns

			IF  i EQ 0 THEN $
			d7p_bobs_l2[j] = WIDGET_LABEL(d7p_bobs_boxes[j], VALUE = d7p_txt2[j], $
					 XOFFSET = 1, YOFFSET = 3, SCR_YSIZE = 30, $
					 FONT = ft_normal) $
			ELSE IF (i LT 4) OR ((i EQ 4) AND (j LT 2)) THEN $
			d7p_bobs_b[i-1,j] = WIDGET_TEXT(d7p_bobs_boxes[j], SCR_XSIZE = 50, $
					    SCR_YSIZE = 30, /EDITABLE, FONT = ft_propor, $
					    VALUE = bpars[j,i-1])
		ENDFOR
	ENDFOR

;-------------------------------------------------------------------------------
; 2theta base

	d7p_2t_l     = INTARR(8)		;no of label lines
	d7p_2t_l2    = INTARR(6)		;no of columns
	d7p_2t_l3    = INTARR(6)		;no of columns
	d7p_2t_b     = INTARR(6,6)		;boxes table
	d7p_2t_d     = INTARR(6)		;no.of do buttons
	d7p_2t_boxes = INTARR(6)
	null = ['','','']
	tpars = REFORM([s[28:42],null,s[43:45],null,s[46:48],null,s[49:51],null], 6, 6)
	d7p_txt  = [' ','Flipper: ','Corr.: ',' ','Bank1: ','Bank2: ','Bank3: ',$
		    'Bank4: ']
	d7p_txt2 = ['First Z','Last Z','First X','Last X','First Y','Last Y']
	d7p_txt3 = ['Start','End','Step',null]

	d7p_2t_label    = WIDGET_LABEL(d7p_2t, VALUE = '2Theta: ',FONT = ft_b_bigger)
	d7p_2t_labs     = WIDGET_BASE (d7p_2t, /COLUMN)
	FOR i=0,5 DO $
	d7p_2t_boxes(i) = WIDGET_BASE (d7p_2t, /COLUMN)
	d7p_2t_butts    = WIDGET_BASE (d7p_2t, /COLUMN)
	d7p_blank       = WIDGET_LABEL(d7p_2t_butts, VALUE = ' ', XOFFSET = 1, $
		          YOFFSET = 3, SCR_YSIZE = 30)

	FOR i = 0, 7 DO BEGIN			;loop around rows

		d7p_2t_l[i] = WIDGET_LABEL(d7p_2t_labs, VALUE = d7p_txt[i], $
			      XOFFSET = 1, YOFFSET = 3, SCR_YSIZE = 30, $
			      FONT = ft_normal, /ALIGN_RIGHT)
		IF i EQ 2 THEN $
		d7p_blank   = WIDGET_LABEL(d7p_2t_butts, VALUE = ' ', XOFFSET = 1, $
		    	      YOFFSET = 3, SCR_YSIZE = 30)
		IF (i LT 7) AND (i NE 2) THEN BEGIN
			IF i GT 2 THEN ii = i-1 ELSE ii = i
			d7p_2t_d(ii) = WIDGET_BUTTON(d7p_2t_butts, $
		   		       SCR_XSIZE = 30,SCR_YSIZE = 26, VALUE = 'Do', $
				       UNAME = 'd7p_2t' + STRTRIM(STRING(ii),2), $
		   		       FONT = ft_b_bigger, FRAME = 1)
		ENDIF

		FOR j = 0, 5 DO BEGIN		;loop around columns
			IF i EQ 0 THEN $
			d7p_2t_l2[j] = WIDGET_LABEL(d7p_2t_boxes[j], $
			   	       VALUE = d7p_txt2[j], XOFFSET = 1, YOFFSET = 3, $
				       SCR_YSIZE = 30,FONT = ft_normal) $
			ELSE IF i EQ 3 THEN $
			d7p_2t_l3[j] = WIDGET_LABEL(d7p_2t_boxes[j], $
				       VALUE = d7p_txt3[j],XOFFSET = 1, YOFFSET = 3, $
				       SCR_YSIZE = 30,FONT = ft_normal) $			
			ELSE IF (i LT 3) OR ((i GT 3) AND (j LT 3)) THEN BEGIN
			        IF i GT 3 THEN ii = i -1 ELSE ii = i
			        d7p_2t_b[ii-1,j] = WIDGET_TEXT(d7p_2t_boxes[j], $
						   SCR_XSIZE = 100, SCR_YSIZE = 30, /EDITABLE, $
						   FONT = ft_propor, VALUE = tpars[j,ii-1])
			ENDIF
		ENDFOR
	ENDFOR

;------------------------------------------------------------------------------
; Buttons
	
	d7p_refresh = WIDGET_BUTTON(d7p_row11, SCR_XSIZE = 80, $
		      VALUE = 'Update', FRAME = 1, FONT = ft_b_bigger, $
		      UNAME = 'd7p_refresh')
	d7p_exit    = WIDGET_BUTTON(d7p_base, SCR_XSIZE = 40, $
		      VALUE = 'Exit', FRAME = 1, FONT = ft_b_bigger, $
		      UNAME = 'd7p_exit')

;------------------------------------------------------------------------------
; Lauch interface and prepare info block

	WIDGET_CONTROL, d7p_base, /REALIZE
	info = {setup:d7p_setup_b, count:d7p_count_b, inst:d7p_inst_b, $
		theta:d7p_2t_b, bobs:d7p_bobs_b}
	WIDGET_CONTROL, d7p_base, SET_UVALUE = info
	IF FIX(s[3]) EQ 1 THEN BEGIN
		 WIDGET_CONTROL, d7p_inst_b(1), SENSITIVE = 0
		WIDGET_CONTROL, d7p_inst_b(2), SENSITIVE = 0
	ENDIF
	XMANAGER, 'Set_Param_D7', d7p_base, /JUST_REG

	END
pro set

close,3

openr,3,'data.'
w1=intarr(1101,571)
readf,3,w1
w1=reverse(w1,1)
window,6
tv,w1

m1=max(w1)
m2=min(w1)
m3=total(w1)
print,'total counts: ',m3
print,'min counts: ',m2
print,'max counts: ',m1

m=9
ll=m2+indgen(m)*((float(m1-m2))/float(m+1))
window,3,retain=2
;,xsize=500,ysize=1000

contour,w1,levels=ll,c_colors=indgen(10)*25
;,xrange=[0,525],yrange=[0,1053]
end
Pro SHOWVOL, v,p,vol
;Display the contour surface of a volume.
s = SIZE(vol)	;Get the dimensions of the volume.
SCALE3, XRANGE=[0, S(1)/5.], YRANGE=[0, S(2)], ZRANGE=[0, S(3)]
	;Use SCALE3 to establish the 3D transformation and coordinate ranges.
TV, POLYSHADE(v,p,/T3D)
END
FUNCTION signal_cathod, w, a,x=x,$
                        ps=ps,portrait=portrait,landscape=landscape
;a0 factor,
;a1 t0,
;a2 sigma
;a3 capture_ratio,
;a4 gamma_ratio,
;a5 gamma_exp,
;a6 trace/cell_width,
;a7 NO_CLET=0/CLET=1

take_datp,datp
wnew=w
IF N_ELEMENTS(w(0,*)) GT 1 THEN wnew=total(w,2)
signals=wnew
canals=N_ELEMENTS(signals)
FOR i=0, canals-1 DO signals(i) = TOTAL (wnew (i:canals-1))
y=signals/canals
IF NOT KEYWORD_SET(x) THEN x=datp.x
IF N_ELEMENTS(a) EQ 7 THEN a=[a,1.]
IF a(7) EQ 0. THEN clet=' without CLET ' ELSE clet=' with CLET '
IF a(7) EQ 0. THEN name='signal_pure.ps' ELSE name='signal_clet.ps'
IF KEYWORD_SET(ps) THEN BEGIN
  IF NOT KEYWORD_SET(portrait) THEN portrait=0 ELSE landscape=0
  IF NOT KEYWORD_SET(landscape) THEN landscape=0
  SET_PLOT,'ps'
  DEVICE,FILENAME=name,portrait=portrait,landscape=landscape
  PLOT,x,y,$
    TITLE='Integrated counts for detector cathod'+clet+systime(),$
    YTITLE='Number of counts',$
    XTITLE='Threshold',$
    SUBTITLE='hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
  DEVICE,/CLOSE
  SET_PLOT,'x'
ENDIF
mod_datp,datp,'w_tit','Integrated counts for detector cathod'+clet+systime()
mod_datp,datp,'other_tit','hght'+STRMID(STRCOMPRESS(STRING(a(0))),0,5)+$
             ', Pk'+STRMID(STRCOMPRESS(STRING(a(1))),0,5)+$
             ', sg'+STRMID(STRCOMPRESS(STRING(a(2))),0,5)+$
             ', cpt'+STRMID(STRCOMPRESS(STRING(a(3))),0,5)+$
             ', g_rt'+STRMID(STRCOMPRESS(STRING(a(4))),0,5)+$
             ', g_exp'+STRMID(STRCOMPRESS(STRING(a(5))),0,5)+$
             ', trc'+STRMID(STRCOMPRESS(STRING(a(6))),0,5)
give_datp,datp
RETURN, y

END
pro simple,name,y

  OPENR,in,name,/get_lun
  READF,in,y
  FREE_LUN,in

END

pro skipline , in,line,cnt,nvers=nvers,bid               ; ###### modified 11/3
;** ********
;**
	ON_IOERROR,nocnt
	cnt=0L & bid=0L & READS,line+' 0 0',cnt,bid,nvers   ; ###### modified 11/3
	IF bid gt 0 THEN FOR i=1,bid DO READF,in,line
	nocnt:
RETURN
END


pro skipvpar ,vpb,vpara,in
;** ********
;**
IF vpb gt 0 THEN BEGIN deco=''
		 FOR I=0,vpb-1 DO BEGIN
			 READF,in,deco
			 READF,in,deco     & SKIPLINE,in,deco,vpb
			 vpara=fltarr(vpb) & READF,in,vpara
		 ENDFOR
ENDIF
RETURN
END

;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION slab, w_in, angle=gamma0, muR=Nsigmat, Tmin=Amin, $
		       output_array = output_array

;For D7 data only - (useful for slab geometry single crystal omega scans)
;Corrects for sample attenuation of the scattered neutrons assuming 
;infinite slab geometry. 
;
;ARGUMENTS:
; angle	:angle in degrees of sample normal rel. to incident beam at omega=0. 
;	 Counterclockwise is +ve
; muR	:muR is Nsigmat where sample transmission=EXP(-Nsigmat)
;	 N*sigma=0.037 mm^-1 for vanadium
; Tmin	:Minimum transmission of sample (defined by real thickness and length)
;
;DIMENSIONS
; w_in(32,nphases,nruns) -> w_out(32,nphases,nruns)
;
;COMMAND SYNTAX:
; w5=slab(w4,angle=<angle>,muR=<muR>,Tmin=<Tmin>)
;
;							KHA,JRS 3/6/02
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start slab:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	sw = SIZE(w_in)
	IF iprint GT 0 THEN PRINT,'SIZE(w_in)=',sw

	par = datp.p
	nspectra = FIX(par[1])
	nphases = FIX(par[2])
	nruns = FIX(par[3])
	nchannels = FIX(par[6])
	TOF = FIX(par[8])

	IF iprint GT 0 THEN BEGIN
		PRINT, 'TOF      = ', TOF
		PRINT, 'nspectra = ', nspectra
		PRINT, 'nphases  = ', nphases
		PRINT, 'nruns    = ', nruns
	ENDIF

	IF nruns EQ 1 THEN BEGIN
		x_in=datp.x
		y_in=0.
	ENDIF ELSE BEGIN
		x_in=datp.z
		y_in=datp.pv[20,*]
		IF y_in[0] EQ y_in[nruns-1] THEN y_in=datp.pv[21,*]
		IF y_in[0] EQ y_in[nruns-1] THEN y_in[*]=0.
	ENDELSE

	e_in=datp.e
	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in)=',sw
		PRINT,'        SIZE(e_in)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	IF TOF EQ 1 THEN BEGIN
		PRINT,'Slab: eror - data must be non-TOF'
		GOTO, finished
	ENDIF

	IF iprint GT 0 THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Perform correction

	w_out=w_in
	e_out=e_in

	gamma0 = gamma0*!pi/180.
	xbuf = FLTARR(nspectra)
	ybuf = FLTARR(nspectra)
	FOR irun=0,nruns-1 DO BEGIN
		phi  = -x_in[*,irun]*!pi/180.	; anticlockwise is +ve
		xbuf = phi*180./!pi
		omega = y_in[irun]*!pi/180.
		gamma = gamma0 - omega
		IF (gamma LT -!pi/2.) THEN gamma=gamma+!pi $
		ELSE IF (gamma GT !pi/2.) THEN gamma=gamma-!pi
		IF (gamma LT -!pi/2.) THEN gamma=gamma+!pi $
		ELSE IF (gamma GT !pi/2.) THEN gamma=gamma-!pi
		pmin=gamma-!pi/2.
		pmax=gamma+!pi/2.
		IF (pmax GT !pi) THEN BEGIN
			pmin=pmin-!pi
			pmax=pmax-!pi
		ENDIF ELSE IF (pmin LT -!pi) THEN BEGIN
			pmin=pmin+!pi
			pmax=pmax+!pi
		ENDIF
		secg = 1./COS(gamma)
		IF (iprint GT 0) THEN BEGIN
			PRINT
			PRINT,'irun=',irun,' omega=',y_in(irun),' gamma=',gamma*180./!pi
			PRINT,'phimin=',pmin*180./!pi,' phimax=',pmax*180./!pi
			PRINT,'phi(0)=',phi(0)*180./!pi,' phi(max)=',phi(nspectra-1)*180./!pi
		ENDIF
		FOR i=0,nspectra-1 DO BEGIN
			p=phi(i)
			secpg=1./COS(p-gamma)
			IF (p GT pmin AND p LT pmax) THEN $	;transmission
				A=(EXP(-Nsigmat*secg)-EXP(-Nsigmat*secpg))/(Nsigmat*(secpg-secg)) $
			ELSE $		; reflection
				A=(1.-EXP(-Nsigmat*(secg-secpg)))/(Nsigmat*(secg-secpg))
			IF (A LT Amin) THEN A=Amin
			IF (nphases EQ 1) THEN BEGIN
				w_out(i,irun)=w_out(i,irun)/A
				e_out(i,irun)=e_out(i,irun)/A
			ENDIF ELSE BEGIN
				w_out(i,*,irun)=w_out(i,*,irun)/A
				e_out(i,*,irun)=e_out(i,*,irun)/A
			ENDELSE
			ybuf(i)=A
		ENDFOR
		IF iprint GT 0 THEN BEGIN
			DIALWSET
			plot, xbuf, ybuf
		ENDIF
	ENDFOR

	IF KEYWORD_SET(output_array) THEN w_out = ybuf

	IF iprint GT 0 THEN PRINT,'End of Correction section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.e=e_out


finished:
	IF (iprint GT 0) THEN PRINT,'End slab:'

	give_datp, datp

	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION slab_tof, w_in, angle=alpha, inc_xs=sigmai, abs_xs=sigmaa, $
		 thick=thick, N=N
;For D7, IN4, IN5 and IN6

;Takes a 2-D tof workspace and corrects for sample attenuation of the
;scattered neutrons assuming infinite slab geometry.
;
;ARGUMENTS
; angle	: the angle in degrees of sample normal rel. to incident beam
; inc_xs: inchorent cross-section of sample (barns)
; abs_xs: absorption cross-section for thermal neutrons (lambda=1.8) (barns)
; thick	: thickness of sample (mm)
; N	: number density of sample (*10^22 per cm^3)
;
;DIMENSIONS
; w_in(nchannels,nspectra) -> w_out(nchannels,nspectra)
;
;COMMAND SYNTAX
; w7=slab_tof(w6,angle=<angle>,inc_xs=<inc_xs>,abs_xs=<abs_xs>,thick=<thick>,N=<N>)
;
;							JRS, 10/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	COMMON c_lamp_access, inst
	IF (iprint GT 0) THEN PRINT,'Start slab_tof:'

	take_datp, datp

	alpha=FLOAT(alpha)
	sigmai=FLOAT(sigmai)
	sigmaa=FLOAT(sigmaa)
	thick=FLOAT(thick)
	N=FLOAT(N)
	alphar=alpha*!pi/180.
	Nr=N*1.e22

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw

	par=datp.p

	IF(inst NE 'D7') THEN BEGIN
		lambda=par(21)
		chw=par(18)		; channelwidth in microseconds
		chel=par(9)
	ENDIF ELSE BEGIN
		lambda=par(4)
		chw=par(7)
		chel=par(9)
	ENDELSE

	nspectra=sw(2)
	nchannels=sw(1)
	ei=81.8066/(lambda^2)

	IF (iprint GT 0) THEN BEGIN
		PRINT,'lambda=',lambda
		PRINT,'ei=',ei
		PRINT,'nspectra=',nspectra
		PRINT,'nchannels=',nchannels
	ENDIF

	x_in=datp.x	;time-of-flight
	y_in=datp.y	;scattering angle
	e_in=datp.e

	const1=5.22697          ; E(meV)=const1*V(mm/mus)^2 for neutron
	IF (inst EQ 'IN5') THEN L2=par(27)*1000
	IF (inst EQ 'IN6') THEN L2=2470
	IF (inst EQ 'D7') THEN L2=1500
	Vi=SQRT(ei/const1)
	Tel=L2/Vi		; time in microseconds

	time=chw*FLOAT(x_in-chel)+Tel
	Ef=const1*(L2/time)^2
	Eps=Ei-Ef

	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in)=',sw
		PRINT,'        SIZE(e_in)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF


	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Perform correction

	w_out=w_in
	e_out=FLTARR(nchannels,nspectra)

	ttheta=y_in*!pi/180.	; anticlockwise is +ve

	sigmaa1=sigmaa*1.E-24
	sigmai1=sigmai*1.E-24
	sigmaar=sigmaa1*lambda/1.8
	mu=Nr*(sigmaar+sigmai1)
	mu2=Nr*sigmaar*(SQRT(ei/(ei-Eps)))
	beta=mu/SIN(alphar)
	t=thick/10.

	IF (iprint EQ 1) THEN BEGIN
		PRINT,'sigmai1=',sigmai
		PRINT,'sigmaa1=',sigmaa
		PRINT,'sigmaar=',sigmaar
		PRINT,'mu=',mu
		PRINT,'t=',t
	ENDIF

	gama=FLTARR(nchannels,nspectra)

	FOR ang=0,nspectra-1 DO BEGIN
		gama(0,ang)=mu2/SIN(alphar-ttheta(ang))
	ENDFOR

	A=(EXP(-beta*t)-EXP(-gama*t))/(gama-beta)

	w_out=w_in*t/A
	e_out=e_in*t/A
	x_out=x_in
	y_out=y_in

	IF (iprint GT 0) THEN PRINT,'End of Correction section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.e=e_out
	
	als=STRTRIM(STRING(alpha),2)	& np=RSTRPOS(als,'.')+0	& als=STRMID(als,0,np)
	sis=STRTRIM(STRING(sigmai),2)	& np=RSTRPOS(sis,'.')+3	& sis=STRMID(sis,0,np)
	aas=STRTRIM(STRING(sigmaa),2)	& np=RSTRPOS(aas,'.')+3	& aas=STRMID(aas,0,np)
	ths=STRTRIM(STRING(thick),2)	& np=RSTRPOS(ths,'.')+3	& ths=STRMID(ths,0,np)
	Ns=STRTRIM(STRING(N),2)		& np=RSTRPOS(Ns,'.')+3	& Ns=STRMID(Ns,0,np)
	
	datp.other_tit=datp.other_tit+' -st('+als+','+sis+','+aas+','+ $
		ths+','+Ns+')'

finished:
	IF (iprint GT 0) THEN PRINT,'End slab_tof:'

	give_datp, datp

	RETURN, w_out
	END
PRO slicefield, xr, yr, zr, u, v, w, arrows=arrows, DAMPING=damp,size=size,$
                VELOVECT=velovect,scale=scale,$
                reduce=reduce
;+
;field2d,charge,[-.5,1.5,.1],[-.5,1.5,.1],[-.5,1.5,.1],u,v,w,sx=sx,sy=sy,sz=sz
;field2d,electrodes,[50,120,10],[380,420,10],[-1.5,1.5,1.],u,v,w,sx=sx,sy=sy,sz=sz,/prog
;SCALE3, X=[-2,2],Y=[-2,2],Z=[-2,2],ax=40,az=0
;flow3,u,v,w,arrowsize=.02,sx=sx,sy=sy,sz=sz
;-
IF NOT KEYWORD_SET(reduce) THEN reduce=1. ELSE reduce=FLOAT(reduce)
xsize=ABS(xr[1]-xr[0])
ysize=ABS(yr[1]-yr[0])
zsize=ABS(zr[1]-zr[0])
IF NOT KEYWORD_SET(scale) THEN scale=[0,MAX([N_ELEMENTS(u(*,0,0)),N_ELEMENTS(u(0,*,0)),N_ELEMENTS(u(0,0,*))])]
IF NOT KEYWORD_SET(damp) THEN BEGIN
  IF KEYWORD_SET(velovect) THEN damp=20. ELSE damp=200.
ENDIF
IF NOT KEYWORD_SET(arrows) THEN arrows=200
ASPECT=FLOAT(xsize)/FLOAT(ysize)
window,0,xsize=1000*aspect,ysize=1000
for k= 0,N_ELEMENTS(u(0,0,*))-1 DO BEGIN
  WSET,0
  field=SQRT(u(*,*,k)^2+v(*,*,k)^2)/damp
  IF KEYWORD_SET(VeloVect) THEN BEGIN
    VELOVECT,u(*,*,k),v(*,*,k),INDGEN(xsize/xr[2]+1)*xr[2]+xr[0],INDGEN(ysize/yr[2]+1)*yr[2]+yr[0],TITLE='z'+STRCOMPRESS(z),LENGTH=max(field)/reduce
  ENDIF ELSE BEGIN
    PLOT_FIELD,u(*,*,k),v(*,*,k),TITLE='z'+STRCOMPRESS(zr(0)+k*zr(2)),n=arrows,ASPECT=aspect,LENGTH=max(field)/reduce
  ENDELSE
ENDFOR
END
FUNCTION slitpos, w, first, last, step, delta, datp=datpp

IF NOT KEYWORD_SET(datpp) THEN TAKE_DATP, datp ELSE datp=datpp
x = datp.x
resw=FLTARR(1+FLOOR((last-first)/step))
resx=FLTARR(1+FLOOR((last-first)/step))
;HELP,resw,resx
FOR i = first, last, step DO BEGIN
  trapw=w(WHERE(x LE i+delta AND x ge i-delta))
  trapx=x(WHERE(x LE i+delta AND x ge i-delta))
  fit=GAUSSFIT(trapx,trapw,a)
  PRINT,ROUND((i-first)/step),i,a(1),a(0)*a(2)
  resx(ROUND((i-first)/step))=a(1)
  resw(ROUND((i-first)/step))=a(0)*a(2)
ENDFOR
resw=resw/TOTAL(resw)*N_ELEMENTS(resw)
MOD_DATP,datp,'x',resx
IF NOT KEYWORD_SET(datpp) THEN GIVE_DATP,datp ELSE datpp=datp
RETURN,resw

END
; Programme to calculate and display the intensity profile of neutrons incident
; on a sample trough two slits.

;===============================================================================
;shows error message window
;===============================================================================
PRO errormessage,messy

; common block holding the base's id
COMMON base_id,base

; desensitise base
	WIDGET_CONTROL,base,SENSITIVE=0
;create floating message widget
	msg_base=WIDGET_BASE(group_leader=base,/FLOATING,TITLE='Error Message',/COLUMN)

; label and give widget a button with 'ok' on
	mess=WIDGET_LABEL(msg_base,VALUE=messy)
	errbut=WIDGET_BUTTON(msg_base,VALUE='OK',UVALUE='ok')

; realise and pass control to event handler
	WIDGET_CONTROL,msg_base,/REALIZE
	XMANAGER,'message',msg_base
END

;===============================================================================
;handles events from errormessage
;===============================================================================
PRO message_event,event

; common block for base widget ID
COMMON base_id,base

; get user value from button that caused event
	WIDGET_CONTROL,event.id,GET_UVALUE=ev,GET_VALUE=val

; If Okay button was pressed then resensitise the base widget and destroy
; the message widget
IF ev EQ 'ok' THEN BEGIN
	WIDGET_CONTROL,event.top,/DESTROY
	WIDGET_CONTROL,base,SENSITIVE=1
ENDIF

END

;===============================================================================
; Function to extract a floating point from a text widget specified by
; widget_id. Returns a floating point or an error if incorrectly formatted.
;===============================================================================
FUNCTION getfield, widget_id

; Common block used to pass errors
COMMON eflags,eflag

; initialise: no error
	eflag=0 
	
; get string from text widget and remove white space
	WIDGET_CONTROL,widget_id,GET_VALUE=text
	text=STRCOMPRESS(text[0],/REMOVE_ALL)
; convert to a float
	number = FLOAT(text)
; convert back to string to compare to original string. If they're not the same
; then the string isn't a correctly formatted floating point number so signal error
	checkstr = STRCOMPRESS(STRING(number),/REMOVE_ALL)
; check to see if one is substring of the other (either will do). Can't just check
; that, e.g. checkstr is a substring of text 'coz if text is '1.' then checkstr
; ='1.000000' and vice vera
	IF (STRPOS(checkstr,text) EQ -1) AND  (STRPOS(text,checkstr) EQ -1)THEN BEGIN
		eflag = 1
		RETURN,0.0
; otherwise return the number
	ENDIF ELSE RETURN,number
END

;===============================================================================
; Procedure that does the calculations.
; No comments because I'm not really sure how it works.
;===============================================================================
PRO calculate,d1,d2,s1,s2,sam,theta

COMMON base_id,base
COMMON plot_base,plotbase,illum,delth

; convert theta to rad.
	theta=!pi*theta/180.0
; calc. footprint of sample (projection onto slit)
	footprint=sam*sin(theta)
	
	IF s1 GT s2 THEN fwhm=s1*180.0/(d1*!pi)	ELSE fwhm=s2*180.0/(d1*!pi)
	
	arange=2.0*ATAN((s1+s2)/(2.0*d1))
	
	
	del=fwhm*!pi/(theta*180.0)
	arange=arange*180.0/!pi
	
	IF s1 NE s2 THEN BEGIN
		x=d2-((d1*s2)/(s1-s2))
		w2=ABS((s2*x)/(d2-x))
	ENDIF ELSE BEGIN
		w2=s1
		x=9999.0
	END
	
	w1 = s2+((d2*(s1+s2))/d1)
		
; "Convert to and intensity distribution on sample" (apparently)
	th1=ATAN((s1+s2)/(2.0*d1))
	IF s1 EQ s2 THEN th2 = 0 ELSE th2 = ATAN(s2/(2.0*(d2-x)))
	
	r1=(sam/2.0)+(w2/(2.0*COS(theta)*(TAN(theta)+TAN(th2))))
	r2=(sam/2.0)+(w1/(2.0*COS(theta)*(TAN(theta)+TAN(th1))))
	l1=(sam/2.0)-(w1/(2.0*COS(theta)*(TAN(theta)-TAN(th1))))
	l2=(sam/2.0)-(w2/(2.0*COS(theta)*(TAN(theta)-TAN(th2))))
	
	nt=100
	
	xx=FLTARR(nt+1)
	yy=FLTARR(nt+1)

	FOR i=0,nt DO BEGIN
		xx[i]=(FLOAT(i)/nt)*sam
		y=(FLOAT(i)/nt)*sam
		IF y LT l1 THEN z=0
		IF (y GE l1) AND (y LT l2) THEN z=(y-l1)/(l2-l1)
		IF (y GE l2) AND (y LT r1) THEN z=1
		IF (y GE r1) AND (y LT r2) THEN z=(r2-y)/(r2-r1)
		IF y GE r2 THEN z=0
		yy[i]=z
	END

	dth_by_th = 2*ATAN((s1+s2)/(2.0*d1))/((theta/180.0)*!pi)
	illumination = 100*(r2-l1)/sam
	
	IF illumination GT 100 THEN $ 
	illumination = 'More than 100% ! (sample footprint smaller than beam)' $
	ELSE illumination = STRCOMPRESS(STRING(illumination),/REMOVE_ALL)+'%'
	
; check that plot base exists if it doesn't then create the widget
	WIDGET_CONTROL,plotbase,BAD_ID=check
	IF check NE 0 THEN BEGIN
; Create a drawing widget with the plot in
		plotbase=WIDGET_BASE(GROUP_LEADER=base,TITLE='Intensity across sample (mm)',/COLUMN)
		illum=WIDGET_LABEL(plotbase,/ALIGN_CENTER,/DYNAMIC_RESIZE,VALUE='Illumination = '+ illumination)
		delth=WIDGET_LABEL(plotbase,/ALIGN_CENTER,SCR_YSIZE=35,VALUE='d(theta)/theta = '+STRCOMPRESS(STRING(dth_by_th),/REMOVE_ALL))		
		graph=WIDGET_DRAW(plotbase,XSIZE=700,YSIZE=500,RETAIN=2)

; give it an ok button
		butt=WIDGET_BUTTON(plotbase,VALUE='OK',UVALUE='ok')
		WIDGET_CONTROL,plotbase,/REALIZE
		PLOT,xx,yy,YRANGE=[0,1.1]
	
; handle click of OK button using general message event handler
		XMANAGER,'message',plotbase
; If plotbase does exist then just replot
	ENDIF ELSE BEGIN
		PLOT,xx,yy,YRANGE=[0,1.1]
		WIDGET_CONTROL,illum,SET_VALUE=	'Illumination = '+illumination
		WIDGET_CONTROL,delth,SET_VALUE='d(theta)/theta = '+STRCOMPRESS(STRING(dth_by_th),/REMOVE_ALL)
	END
	
END

;===============================================================================
; Event handler for slitwit
;===============================================================================
PRO slitwit_event, ev

; common block for error flags
COMMON eflags,eflag

; common block containing ID's for text widgets
COMMON editfields, fields


; get user value (text string) to determine whihc button was pressed
	WIDGET_CONTROL, ev.id, GET_UVALUE=button_id

; If quit button was pressed then end
	IF (ev.select) AND (button_id eq 'QUIT') THEN WIDGET_CONTROL, ev.top, /DESTROY

; If do button was pressed perform calcs.
	IF (ev.select) AND (button_id eq 'DO') THEN BEGIN
		
		d1=getfield(fields[0])
		IF eflag NE 0 THEN BEGIN
			errormessage,'Inter Slit distance must be floating point!'
			RETURN
		END
		d2=getfield(fields[1])
		IF eflag NE 0 THEN BEGIN
			errormessage,'Sample-Slit distance must be floating point!'
			RETURN
		END
		sam=getfield(fields[2])
		IF eflag NE 0 THEN BEGIN
			errormessage,'Sample length must be floating point!'
			RETURN
		END
		theta=getfield(fields[3])
		IF eflag NE 0 THEN BEGIN
			errormessage,'Theta must be floating point!'
			RETURN
		END
		s2=getfield(fields[4])
		IF eflag NE 0 THEN BEGIN
			errormessage,'Sample slit width must be floating point!'
			RETURN
		END
		s1=getfield(fields[5])
		IF eflag NE 0 THEN BEGIN
			errormessage,'1st slit width must be floating point!'
			RETURN
		END
		
; If everything checks ok then do calculations
		calculate,d1,d2,s1,s2,sam,theta
	END
END

;===============================================================================
PRO slitwit

COMMON base_id,base

; common block to pass ID's of field widgets
COMMON editfields, fields

COMMON plot_base,plotbase,illum,delth

; Initialise plotbase: widget ID
	plotbase=-1
	
; base widget
	base = WIDGET_BASE(TITLE='SlitWit',/COLUMN)
	
; arrays for the id numbers of the label and field widgets
	labels = LONARR(6)
	fields = LONARR(6)
	
; base containing all of the fields to be enterd
	edit_base = WIDGET_BASE(base,COLUMN=2)
	
; column of labels
	labels[0] = WIDGET_LABEL(edit_base,/ALIGN_RIGHT,SCR_YSIZE=35,VALUE='Inter Slit distance (mm)')
	labels[1] = WIDGET_LABEL(edit_base,/ALIGN_RIGHT,SCR_YSIZE=35,VALUE='Sample-slit distance (mm)')
	labels[2] = WIDGET_LABEL(edit_base,/ALIGN_RIGHT,SCR_YSIZE=35,VALUE='Sample length (mm)')
	labels[3] = WIDGET_LABEL(edit_base,/ALIGN_RIGHT,SCR_YSIZE=35,VALUE='Theta (degrees)')
	labels[4] = WIDGET_LABEL(edit_base,/ALIGN_RIGHT,SCR_YSIZE=35,VALUE='Sample slit	width,s3w (mm)')
	labels[5] = WIDGET_LABEL(edit_base,/ALIGN_RIGHT,SCR_YSIZE=35,VALUE='1st slit width,s2w (mm)')

; column of field entry text widgets
	fields[0] = WIDGET_TEXT(edit_base,SCR_YSIZE=35,/EDITABLE,VALUE='3500.0')
	fields[1] = WIDGET_TEXT(edit_base,SCR_YSIZE=35,/EDITABLE,VALUE='200.0')
	fields[2] = WIDGET_TEXT(edit_base,SCR_YSIZE=35,/EDITABLE,VALUE='100.0')
	fields[3] = WIDGET_TEXT(edit_base,SCR_YSIZE=35,/EDITABLE,VALUE='0.5')
	fields[4] = WIDGET_TEXT(edit_base,SCR_YSIZE=35,/EDITABLE,VALUE='0.5')
	fields[5] = WIDGET_TEXT(edit_base,SCR_YSIZE=35,/EDITABLE,VALUE='0.5')
			
; Do and Quit buttons. UVALUE='...' allows the button to be indetified in the
; event handler without knowing which button the id corresponds to
	quit_button = WIDGET_BUTTON(base, VALUE='QUIT', UVALUE='QUIT')
	do_button = WIDGET_BUTTON(base, VALUE='DO IT!', UVALUE='DO')
	
	WIDGET_CONTROL, base, /REALIZE
	XMANAGER, 'SlitWit', base
END
;------------------------------------------------------------------------------
;******************************************************************************
;
	FUNCTION smooth_bkgd, w_in, ismooth
;
;For IN5 data only
;
; Performs a smoothing of a background measurement. Assumes that the signal
; consists of an elastic plus broad background scattering. ismooth must be odd. 
;
;ARGUMENTS
; ismooth<0 :	Replaces the elastic peak by a best-fit gaussian and performs a
;		moving filter smoothing (ABS(ismooth)) on the rest. 
; ismooth>0 :	Performs a moving filter smoothing (ismooth) everywhere. 
;
; ismooth=0 :	No smoothing (default)
;
;DIMENSIONS
; w_in=w_out(nhcannels,nspectra)
;
;COMMAND SYNTAX
; w5=smooth_bkgd(w4,<ismooth>)
;							KHA 17/7/98
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start smooth_bkgd:'

	IF (N_ELEMENTS(ismooth) EQ 0) THEN ismooth=0
	IF (ismooth EQ 0) THEN return,w_in

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace and energy parameters


	par=datp.p
	lambda=par(21)
	cheldet=par(9)	; elastic channel for high-angle detectors
	chw=par(18)
	const=3.956076
	Vi=const/lambda
	chelmul=cheldet-300./(Vi*chw)

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	nchannels=sw(1)
	IF (sw(0) EQ 1) THEN nspectra=1     ELSE $
	IF (sw(0) EQ 2) THEN nspectra=sw(2) ELSE return,w_in

	IF (iprint GT 0) THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	phi=datp.y
	x_in=datp.x
	e_in=datp.e

	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN e_in=SQRT(w_in)

	IF (iprint GT 0) THEN PRINT,'End of setup section'

;-------------------------------------------------------------------------------------
;	Fit Gaussians

	w_out=w_in	& e_out=e_in*0.
	gauss=FLTARR(4)	& dgauss=gauss
	x=x_in
	FOR ispec=0,nspectra-1 DO BEGIN
		y=w_in(*,ispec)
		e=e_in(*,ispec)
		IF (ismooth LT 0) THEN BEGIN
			IF (phi(ispec) LT 10) THEN x0=chelmul ELSE x0=cheldet
			IF (nspectra EQ 1) THEN x0=cheldet
			PRINT,'Fitting Gaussian to s',ispec
			fitgauss, x, y, e, x0-30., x0+30., gauss, dgauss, 1
			gaussian, x, gauss, ygauss
			centre=gauss(2)	& FWHM=gauss(3)*2.355
			ysmooth=SMOOTH(y,ABS(ismooth))
			i1=WHERE(x LT centre-3.*FWHM, n1)
			i2=WHERE(x GE centre-3.*FWHM AND x LE centre+3.*FWHM, n2)
			i3=WHERE(x GT centre+3.*FWHM, n3)
			yall=[ysmooth(i1),ygauss(i2),ysmooth(i3)]
		ENDIF ELSE yall=SMOOTH(y,ismooth)
		w_out(*,ispec)=yall
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of fitting section'

	datp.e=e_out

	give_datp, datp

finished:
	RETURN, w_out
	END


;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION smoothx, w_in, nsmooth

; Smoothes using a moving filter in the x-dimension to one- or 
; two-dimensional data. smoothes over -nsmooth to +nsmooth
;
;						KHA, 6/5/98
;-------------------------------------------------------------------------------
;*******************************************************************************

	w_out=w_in

	take_datp, datp

	x_in=datp.x
	e_in=datp.e
	e_out=e_in

	sw=SIZE(w_in)
	nx=sw(1)
	PRINT,'nx=',nx
	IF (sw(0) EQ 1) THEN BEGIN
		FOR i=0,nx-1 DO BEGIN
			i1=(i-nsmooth)>0
			i2=(i+nsmooth)<(nx-1)
			r=FLOAT(i2-i1+1)
			w=TOTAL(w_in(i1:i2))
			e=SQRT(TOTAL(e_in(i1:i2)^2))
			w_out(i)=w/r	& e_out(i)=e/r
		ENDFOR
	ENDIF ELSE IF (sw(0) EQ 2) THEN BEGIN
		FOR i=0,nx-1 DO BEGIN
			i1=(i-nsmooth)>0
			i2=(i+nsmooth)<(nx-1)
			r=FLOAT(i2-i1+1)
			w=TOTAL(w_in(i1:i2,*),1)
			e=SQRT(TOTAL(e_in(i1:i2,*)^2,1))
			w_out(i,*)=w/r	& e_out(i,*)=e/r
		ENDFOR
	ENDIF ELSE BEGIN
		PRINT,'Smooth: Error - workspace dimensions cannot be greater than 2'
		GOTO, finished
	ENDELSE

	datp.e=e_out
	datp.other_tit=datp.other_tit+' -sx'
finished:
	give_datp, datp

	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION smoothy, w_in, nsmooth

; smoothes using a moving filter in the y-dimension to 
; two-dimensional data. smoothes over -nsmooth to +nsmooth
;
;						KHA, 6/5/98
;-------------------------------------------------------------------------------
;*******************************************************************************

	w_out=w_in

	take_datp, datp

	y_in=datp.y
	e_in=datp.e
	e_out=e_in

	sw=SIZE(w_in)
	ny=sw(2)
	PRINT,'ny=',ny
	IF (sw(0) EQ 2) THEN BEGIN
		FOR i=0,ny-1 DO BEGIN
			i1=(i-nsmooth)>0
			i2=(i+nsmooth)<(ny-1)
			r=FLOAT(i2-i1+1)
			w=TOTAL(w_in(*,i1:i2),2)
			e=SQRT(TOTAL(e_in(*,i1:i2)^2,2))
			w_out(*,i)=w/r	& e_out(*,i)=e/r
		ENDFOR
	ENDIF ELSE BEGIN
		PRINT,'Smooth: Error - workspace dimension must be 2'
		GOTO, finished
	ENDELSE

	datp.e=e_out
	datp.other_tit=datp.other_tit+' -sy'
finished:
	give_datp, datp

	RETURN, w_out
	END
;*******************************************************************************
;
	FUNCTION s_normalise, w_in0, inorm
;
; Normalises raw sans data to monitor or counting time, depending on value of
; inorm. 
; Also finds the position of the elastic peak. ikeep not used. 
;
; inorm=0 => no normalisation
; inorm=1 => 1000 monitor counts (default)
; inorm=2 => time in minutes (incorrect for data added with rdsum or '>')
;
;Output format:
;  		  w_out(xarray,yarray,nruns)
;
;
;							JRS 30/3/00
;
;-------------------------------------------------------------------------------


	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start normalise:'

	COMMON c_lamp_access, inst

	take_datp, datp

	IF (N_ELEMENTS(inorm) EQ 0) THEN inorm=1

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	m_in0=datp.n
	x_in0=datp.x	
	y_in0=datp.y	
	z_in0=datp.z	
	e_in0=datp.e
	par=datp.p
	parv=datp.pv
	se=SIZE(e_in0)
	sw=SIZE(w_in0)
	sm=SIZE(m_in0)
	IF (sm(0) EQ 1) THEN m_in0=FLTARR(1)+m_in0(0)

	FOR i=0,se(0) DO IF (se(i) NE sw(i)) THEN GOTO, seterr
	GOTO, noseterr
seterr:
	IF (iprint GT 0) THEN PRINT,'Normalise: No error bars defined for w_in. Use sqrt'
	e_in0=SQRT(w_in0)
noseterr:

	IF (sw(0) EQ 0) THEN BEGIN
		PRINT,'normalise_d7: Error - workspace is empty'
		GOTO, finished
	ENDIF

	IF (sw(0) EQ 3) THEN nruns=sw(3) ELSE nruns=1
	IF (nruns EQ 1) THEN parv=par
	nspectra=sw(1)

	IF (iprint GT 0) THEN BEGIN
		PRINT,'nspectra=',nspectra
		PRINT,'nruns=',nruns
		PRINT,'inorm=',inorm
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of Check Dimensions Section:'

;-------------------------------------------------------------------------------
; Perform Normalisation

	w_buf=FLTARR(nspectra,nspectra,nruns)
	e_buf=FLTARR(nspectra,nspectra,nruns)

	IF (inorm EQ 1) THEN BEGIN
		FOR irun=0,nruns-1 DO BEGIN
			PRINT,'Normalising run #',FIX(parv(26,irun)),' to ',m_in0(irun),' monitor counts'
			w_buf(*,*,irun)=w_in0(*,*,irun)*1000./m_in0(irun)
			e_buf(*,*,irun)=e_in0(*,*,irun)*1000./m_in0(irun)
		ENDFOR
	ENDIF ELSE IF (inorm EQ 2) THEN BEGIN
		FOR irun=0,nruns-1 DO BEGIN
			PRINT,'Normalising run #',FIX(parv(26,irun)),' to time'
			w_buf(*,*,irun)=w_in0(*,*,irun)/parv(2,irun)
			e_buf(*,*,irun)=e_in0(*,*,irun)/parv(2,irun)
		ENDFOR
	ENDIF ELSE BEGIN
		FOR irun=0,nruns-1 DO BEGIN
			PRINT,'Not normalising run #',FIX(parv(26,irun))
			w_buf(*,*,irun)=w_in0(*,*,irun)
			e_buf(*,*,irun)=e_in0(*,*,irun)
		ENDFOR
	ENDELSE
	
	w_out=FLTARR(nspectra,nspectra,nruns) & w_out=w_buf
	e_out=FLTARR(nspectra,nspectra,nruns) & e_out=e_buf

	IF (iprint GT 0) THEN PRINT,'End of perform normalisation section:'

;-------------------------------------------------------------------------------
;Return data

	s=datp.other_tit & i=RSTRPOS(s,' ') & n=STRLEN(s) & numor=STRMID(s,i+1,n-1)
        IF (nruns EQ 1 AND STRPOS(numor,'>') EQ -1 AND STRPOS(numor,'+') EQ -1) $
		THEN numor=STRTRIM(STRING(LONG(par(26))),2)
	IF (nruns NE 1 AND STRPOS(numor,'>') EQ -1 AND STRPOS(numor,',') EQ -1) $
		THEN numor=STRTRIM(STRING(LONG(parv(26,0))),2)+':'+STRTRIM(STRING(LONG(parv(26,nruns-1))),2)
	
	normnum=STRTRIM(STRING(inorm),2)

	IF (STRPOS(s,' -cc') EQ -1) THEN BEGIN 	; data not previously concatenated
		s=datp.other_tit & i=STRPOS(s,' ') & n=STRPOS(s,'Start:') & datp.w_tit=STRTRIM(STRMID(s,i+1,n-6),2)	
		datp.other_tit=inst+'  #'+numor+' -sn('+normnum+')' 
	ENDIF ELSE datp.other_tit=datp.other_tit+' -sn('+normnum+')'

finished:

	IF (iprint GT 0) THEN PRINT,'SANS Normalise finished'

	mod_datp, datp, "e", e_out
	give_datp, datp

	RETURN, w_out
	END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION splice, w_in1, w_in2, min=xmin, max=xmax, xl

; Splices together two data sets together. Takes w_in1 outside the 
; xmin->xmax region and w_in2 inside. 
;
;ARGUMENTS:
; min	:min of w_in2 region
; max	:max of w_in2 region
;
;DIMENSIONS
; must be 2 1-d arrays input
;
;COMMAND SYNTAX:
; w3=splice(w1,w2,min=<min>,max=<max>)
;
;						KHA,JRS 21/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	IF(N_ELEMENTS(xl) GT 0) THEN xlimits=xl ELSE xlimits=[xmin,xmax]

	take_datp, dat1
	take_datp, dat2, /third

	datp=dat1

	xmin=xlimits(0)
	xmax=xlimits(1)

	x_in1=dat1.x
	x_in2=dat2.x

	e_in1=dat1.e
	e_in2=dat2.e

	s1=SIZE(w_in1)
	s2=SIZE(w_in2)

	IF (s1(0) NE s2(0)) THEN BEGIN
		PRINT,'splice: Error - input workspaces must have same dimensions'
		GOTO, finished
	ENDIF
	nin1=s1(1)	& nin2=s2(1)

	n1=1	& n2=1
	IF (s1(0) NE 1) THEN BEGIN
		IF (s1(0) EQ 2) THEN n1=s1(2) ELSE BEGIN
			n1=s1(2)
			n2=s1(3)
		ENDELSE
	ENDIF
	
	iOK1=WHERE(x_in1 LE xmin OR x_in1 GE xmax, nOK1)
	iOK2=WHERE(x_in2 GE xmin AND x_in2 LE xmax, nOK2)
	IF (nOK1 LE 0 OR nOK2 LE 0) THEN BEGIN
		PRINT,'splice: Error - one of the workspaces has no data points to be kept'
		GOTO, finished
	ENDIF

	nout=nOK1+nOK2

	x_out=FLTARR(nout)
	w_buf=FLTARR(nout)
	e_buf=FLTARR(nout)

	w_out=FLTARR(nout,n1,n2)
	e_out=FLTARR(nout,n1,n2)

	x_out=[x_in1(iOK1),x_in2(iOK2)]
	isort=SORT(x_out)
	x_out=x_out(isort)

	FOR i1=0,n1-1 DO BEGIN
		FOR i2=0,n2-1 DO BEGIN
			w_buf=[w_in1(iOK1,i1,i2),w_in2(iOK2,i1,i2)]
			w_buf=w_buf(isort)
			w_out(*,i1,i2)=w_buf
			e_buf=[e_in1(iOK1,i1,i2),e_in2(iOK2,i1,i2)]
			e_buf=e_buf(isort)
			e_out(*,i1,i2)=e_buf
		ENDFOR
	ENDFOR

	IF (n2 EQ 1) THEN e_out=REFORM(e_out,nout,n1)
	IF (n1 EQ 1) THEN e_out=REFORM(e_out,nout)

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out

        smin=STRTRIM(STRING(xmin),2)
trymin:	n=STRLEN(smin)     & i=RSTRPOS(smin,'0')
        IF (i EQ n-1) THEN BEGIN
                smin=STRMID(smin,0,n-1)
                GOTO, trymin
        ENDIF
        smax=STRTRIM(STRING(xmax),2)
trymax:	n=STRLEN(smax)     & i=RSTRPOS(smax,'0')
        IF (i EQ n-1) THEN BEGIN
                smax=STRMID(smax,0,n-1)
                GOTO, trymax
        ENDIF

	PRINT,'Splice: w_in1 taking outside ['+smin+','+smax+'] region, w_in2 outside'
	datp.other_tit=datp.other_tit+' -sp('+smin+','+smax+')'

finished:
	give_datp, datp

	RETURN, w_out
	END
PRO spondle,fil,a,b,c

y=fltarr(10000)
x=fltarr(10000)
e=fltarr(10000)
d=fltarr(10000)
xx='xxxxx'
print,fil
openr,unit,fil,/get_lun
i=0
while strmid(xx,1,3) ne 'lam' do begin
  readf,unit,xx
  print,xx
endwhile
readf,unit,xx
print,xx
while  not eof(unit) do begin

 readf,unit,k,l,m,n
 
 y(i)=k & x(i)=l & e(i)=m
 i=i+1
endwhile

a=alog10(x(0:i-1)) & b=y(0:i-1) & c=e(0:i-1)/(x(0:i-1)*alog(10))


free_lun,unit
return
print,!stime
end
;--------------------------------------------------------------------------------
;********************************************************************************
;
	FUNCTION sqw_interp, w_in, dQ=dQ, dE=dE, Emin=Emin, $
		 all_angles=all_angles, pos_angles=pos_angles, $
		 neg_angles=neg_angles, qb, eb, em, ib
;
; For IN4, IN5, IN6 and D7
;
;converts output data from t2e to regular-grid interpolated S(Q,w) data.
;input workspace must be in energy transfer versus scattering angle.
;
;ARGUMENTS:
;	dQ :	Q bin width
;	dE :	energy bin width
;	Emin :	minimum energy (neutron energy gain is defined as negative)
;
;KEYWORDS (- only for D7 data)
; /neg_angles	: use only negative angles
; /pos_angles	: use only positive angles
; /all_angles	: use all angles (default)
;		input workspace must be in energy transfer versus scattering angle,
;		i.e. only one component or spin phase.
; (qb, eb, em and ib are obsolete, kept for backwards compatability)
;
;DIMENSIONS:
; w_in(nE,nphi) -> w_out(nQs,nEs)
;
;COMMAND SYNTAX:
; w10=spw_interp(w9,dQ=<dQ>,dE=<dE>, Emin=<Emin>[,/neg_angles][,/pos_angles][,/all_angles])
;
; (optional keywords shown in square brackets)
;
;							KHA,JRS 10/8/00
;--------------------------------------------------------------------------------
;********************************************************************************

	common c_lamp_access, inst

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start sqw_interp:'

	take_datp, datp

	ibank=2
	IF(N_ELEMENTS(qb) GT 0) THEN dQ=qb
	IF(N_ELEMENTS(eb) GT 0) THEN dE=eb
	IF(N_ELEMENTS(em) GT 0) THEN Emin=em
	IF(N_ELEMENTS(ib) GT 0) THEN ibank=ib

	IF KEYWORD_SET(pos_angles) THEN ibank=1
	IF KEYWORD_SET(neg_angles) THEN ibank=0
	IF KEYWORD_SET(all_angles) THEN ibank=2
;-------------------------------------------------------------------------------
;Set up starting parameters

	par=datp.p

	swap_QE=0	; swap_QE=0 => Q is x-axis, E is y-axis
			; swap_QE=1 => E is x-axis, Q is y-axis

	noneg=1	; noneg=1 => set all negative values to zero

	IF (N_ELEMENTS(Emin) NE 1) THEN BEGIN
		PRINT,'sqw_rebin: Error - dQ, dE, Emin must be specified'
		return,w_in
	ENDIF

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	IF (sw(0) NE 2) THEN BEGIN
		PRINT,'sqw_interp: Error - input workspace must be 2-D: E vs. phi'
		return,w_in
	ENDIF
	nEps=sw(1)
	nphi=sw(2)
	IF (iprint GT 0) THEN PRINT,'nEps=',nEps,' nphi=',nphi
	x_in=datp.x	& sx=SIZE(x_in)
	y_in=datp.y	& sy=SIZE(y_in)
	IF (nEps NE sx(1)) OR (nphi NE sy(1)) THEN BEGIN
		PRINT,'sqw_interp: Error - sx=',sx,' sy=',sy
		return,w_in
	ENDIF

	e_in=datp.e
	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN e_in=w_in*0.

	IF (iprint GT 0) THEN PRINT,'Instrument = ',inst
	IF (inst EQ 'D7') THEN BEGIN
		lambda=par(4)
		IF (N_ELEMENTS(ibank) EQ 0) THEN ibank=2
		TOF=FIX(par(8))
		IF (TOF NE 1) THEN BEGIN
			PRINT,'sqw_rebin: Error - workspace data is not in TOF'
			return,w_in
		ENDIF
	ENDIF ELSE lambda=par(21)

	IF (iprint GT 0) THEN PRINT,'lambda=',lambda,'A'

;-------------------------------------------------------------------------------------
;	Set constants and interpolate to regular Q-E grid

	const1=5.22697		; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571	; E(meV)=const2*k(A^-1)^2 for neutron
	const3=3.956076		; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066		; E(meV)=const4/lambda(A)^2 for neutron

	Ei=const4/lambda^2
	ki=SQRT(Ei/const2)

	i=WHERE(x_in GT Emin,nEps)	& Eps=x_in(i)
	w_buf=w_in(i,*)	& e_buf=e_in(i,*)

	phi=y_in*!pi/180.	; convert to radians

	IF (inst EQ 'D7') THEN BEGIN
		IF (ibank EQ 0) THEN BEGIN
			i=WHERE(phi LT 0.,nphi) & phi=ABS(phi(i))
			w_buf=w_buf(*,i)	& e_buf=e_buf(*,i)
		ENDIF ELSE IF (ibank EQ 1) THEN BEGIN
			i=WHERE(phi GT 0.,nphi) & phi=phi(i)
			w_buf=w_buf(*,i)	& e_buf=e_buf(*,i)
		ENDIF ELSE BEGIN
			phi=abs(phi)
			i=SORT(phi)
			phi=phi(i)
			w_buf=w_buf(*,i)	& e_buf=e_buf(*,i)
		ENDELSE
	ENDIF

	Eco=Eps#(FLTARR(1,nphi)+1.)
	COSphi=(FLTARR(nEps)+1.)#COS(phi)
	Qco=SQRT((2.*Ei-Eco-2.*SQRT(Ei*(Ei-Eco))*COSphi)/const2)

	IF(iprint GT 0) THEN help, Eco, Qco, COSphi, w_buf, e_buf

	TRIANGULATE, Qco, Eco, triangles

	Qmin=0.	& Qmax=MAX(Qco)	& Emax=MAX(Eco)
	GS=[dQ,dE]
	Limits=[Qmin,Emin,Qmax,Emax]
	w_out=TRIGRID(Qco,Eco,w_buf,triangles,GS,Limits)
	e_out=TRIGRID(Qco,Eco,e_buf,triangles,GS,Limits)

	sw=SIZE(w_out)
	nQs=sw(1)
	nEs=sw(2)
	Qarr=FINDGEN(nQs)*dQ+Qmin
	Earr=FINDGEN(nEs)*dE+Emin

	IF (iprint GT 0) THEN PRINT,'Qarr=',Qarr
	IF (iprint GT 0) THEN PRINT,'Earr=',Earr

	IF (iprint GT 0) THEN PRINT,'End of "Interpolate to regular grid" section'

;-------------------------------------------------------------------------------
;Set points outside measured region to zero

	phimin=MIN(phi)-2.*!pi/180.	& COSmax=COS(phimin)
	phimax=MAX(phi)+2.*!pi/180.	& COSmin=COS(phimax)
	Q=Qarr#(FLTARR(1,nEs)+1.)
	E=(FLTARR(nQs)+1.)#REFORM(Earr,1,nEs)

	COSphi=(2.*Ei-E-const2*Q^2)/(2.*SQRT((Ei*(Ei-E))>0.))

	outside=WHERE(COSphi GT COSmax OR COSphi LT COSmin)
	w_out(outside)=0.
	e_out(outside)=-1.
	below=WHERE(E LT Eps(0)-dE/2., n)
	IF (n GE 1) THEN w_out(below)=0.
	IF (n GE 1) THEN e_out(below)=-1.
	above=WHERE(E GT Eps(nEps-1)+dE/2., n)
	IF (n GE 1) THEN w_out(above)=0.
	IF (n GE 1) THEN e_out(above)=-1.

;-------------------------------------------------------------------------------------
;	Chop off superfluous bits

checkQ1:
;	iw0=WHERE(w_out(0,*) EQ 0.,nw0) & ie0=WHERE(e_out(0,*) EQ -1.,ne0)
;	IF (nw0 EQ nEs AND ne0 EQ nEs) THEN BEGIN
;		nQs=nQs-1
;		w_out=w_out(1:nQs,*) & e_out=e_out(1:nQs,*) & Qarr=Qarr(1:nQs)
;		GOTO, checkQ1
;	ENDIF

checkQ2:
	iw0=WHERE(w_out(nQs-1,*) EQ 0.,nw0) & ie0=WHERE(e_out(nQs-1,*) EQ -1.,ne0)
	IF (nw0 EQ nEs AND ne0 EQ nEs) THEN BEGIN
		nQs=nQs-1
		w_out=w_out(0:nQs-1,*) & e_out=e_out(0:nQs-1,*) & Qarr=Qarr(0:nQs-1)
		GOTO, checkQ2
	ENDIF

checkEps1:
	iw0=WHERE(w_out(*,0) EQ 0.,nw0) & ie0=WHERE(e_out(*,0) EQ -1.,ne0)
	IF (nw0 EQ nQs AND ne0 EQ nQs) THEN BEGIN
		nEs=nEs-1
		w_out=w_out(*,1:nEs) & e_out=e_out(*,1:nEs) & Earr=Earr(1:nEs)
		GOTO, checkEps1
	ENDIF

checkEps2:
	iw0=WHERE(w_out(*,nEs-1) EQ 0.,nw0) & ie0=WHERE(e_out(*,nEs-1) EQ -1.,ne0)
	IF (nw0 EQ nQs AND ne0 EQ nQs) THEN BEGIN
		nEs=nEs-1
		w_out=w_out(*,0:nEs-1) & e_out=e_out(*,0:nEs-1) & Earr=Earr(0:nEs-1)
		GOTO, checkEps2
	ENDIF

;-------------------------------------------------------------------------------------
;	zero negative counts

	IF (noneg EQ 1) THEN BEGIN
		ineg=WHERE(w_out LT 0., n)
		IF (n GE 1) THEN w_out(ineg)=0.
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of "set outside points to zero" section'


;-------------------------------------------------------------------------------------
;	Return parameters and exit

	IF (swap_QE EQ 0) THEN BEGIN
		datp.y_tit=datp.x_tit
		datp.x_tit='Wavevector Transfer (A-1)'
		mod_datp, datp, "x", Qarr
		mod_datp, datp, "y", Earr
	ENDIF ELSE BEGIN
		w_out=TRANSPOSE(w_out)	& e_out=TRANSPOSE(e_out)
		datp.y_tit='Wavevector Transfer (A-1)'
		mod_datp, datp, "x", Earr
		mod_datp, datp, "y", Qarr
	ENDELSE

	mod_datp, datp, "e", e_out

	s=STRTRIM(STRING(FLOAT(dQ)),2)  & i=STRPOS(s,'.') & dQ=STRMID(s,0,i(0)+3)
	s=STRTRIM(STRING(FLOAT(dE)),2)  & i=STRPOS(s,'.') & dE=STRMID(s,0,i(0)+3)
	Emin=STRTRIM(STRING(FIX(Emin)),2)
	s=' -si('+dQ+','+dE+','+Emin
	IF (inst EQ 'D7') THEN s=s+','+STRTRIM(STRING(ibank),2)+')' ELSE s=s+')'
	datp.other_tit=datp.other_tit+s

	PRINT, 'sqw_interp: Interpolated to constant Q-w: dQ='+dQ+'A-1, dE='+dE+'meV'

	give_datp, datp

finished:
	RETURN, w_out
	END


function sqw,in_wk,xinc,yinc,xmin,xmax,ymin,ymax,fast=ky
;
;converts array w_in  to energy/Q in w_out.....GJK 1994
;Modified for 2-d x and y input - Nov 96
;Example call: w2=sqw(1,0.05,0.1,-2.0,2.0,0,2)
;         convert tof spectrum in w1 to energy and output in w2
;         with energy increment 0.05meV
;         with Q increment 0.1 A-1
;         energy range between -2.0 and 2.0 mev
;         q range between 0 and 2 A-1
;
; Repeated use with different scales:
;                      w2=sqw(1,0.05,0.1,-2.0,2.0,0,2,/fast)
;Available if no other macro used since last sqw function
; 
;
@mac.in
my_check=size(in_wk)
x_check=size(x_in)
  if my_check(0) lt 1 then  begin
     P_MUS,'mus_cannon'
     mess='Problem with input workspace'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
   endif
  P_MUS,'mus_shot'
  nch=my_check(1)
  nang=my_check(2)
        incs=[xinc,yinc]
	limits=[xmin,ymin,xmax,ymax]
    if not keyword_set(ky) then begin        
	coef=fltarr(nch)
        w_out=fltarr(nch,nang)   
        w_buf=fltarr(nch,nang)
	triang=lonarr(3,(nch*nang-2))
;
; Prepare y_array for Q values and x for energy
	y_buf=fltarr(nch,nang)
	x_buf=fltarr(nch,nang)

	wvl=p_in(21)
	pi=3.141592653 
	ei=81.799/p_in(21)^2 
	wvec_in=.695014*sqrt(ei)
	wv_in2=wvec_in^2 
	wvec_out=0.695014*sqrt(ei-x_in)
;
; Get 2-dimensional array y_out with q of each point
        if x_check(0) gt 1 then begin
	   x_buf=x_in
           y_buf=sqrt(wv_in2+wvec_out^2-2.0*wvec_in*wvec_out*cos(y_in*0.0174533))
	endif else begin
	   for i=0,nang-1 do begin
              x_buf(0,i)=x_in
	      y_buf(0,i)=sqrt(wv_in2+wvec_out^2-2.0*wvec_in*wvec_out*cos(y_in(i)*0.0174533))
	   endfor
	endelse
;
; Deluanay triangulate
        triangulate,x_buf,y_buf,triang
        endif
        w_out=trigrid(x_buf,y_buf,w_in,triang,incs,limits)
	if n_elements(e_in) eq n_elements(w_in) then $
	 e_out=SQRT(trigrid(x_buf,y_buf,e_in^2,triang,incs,limits))
	nx=1+fix((xmax-xmin)/xinc)
	ny=1+fix((ymax-ymin)/yinc)
       sighs=size(w_out)
	x_out=fltarr(sighs(1))
	y_out=fltarr(sighs(2))
       x_out(0)=xmin
        for i=1,sighs(1)-1 do x_out(i)=xmin+i*xinc
        y_out(0)=ymin
        for i=1,sighs(2)-1 do y_out(i)=ymin+i*yinc
        

	p_out=p_in
		x_tit(one)='Energy Transfer'
	y_tit(one)='Momentum Transfer (A-1)'
@mac.out
	return,w_out
	end

;--------------------------------------------------------------------------------
;********************************************************************************
;
	FUNCTION sqw_rebin, w_in, dQ=dQ, Emin=Emin0, all_angles=all_angles, $
		 pos_angles=pos_angles, neg_angles=neg_angles, qb, em, ib
;
; For IN4, IN5, IN6 and D7
;
;rebins output data from t2e and reb to regular-grid S(Q,w) data using the old
;KHA IN6 rebin algorithm. Proper rebionning routine with error analysis (unlike
;sqw_interp.pro).
;
;ARGUMENTS:
;	dQ :	Q bin width
;	Emin0:	Minimum energy value (meV) - neutron energy gain is negative
;
;KEYWORDS (- only for D7 data)
; /neg_angles	: use only negative angles
; /pos_angles	: use only positive angles
; /all_angles	: use all angles (default)
;		input workspace must be in energy transfer versus scattering angle,
;		i.e. only one component or spin phase.
; (qb, em and ib are obsolete, kept for backwards compatability)
;
;DIMENSIONS:
; w_in(nE,nphi) -> w_out(nQs,nEs)
;
;COMMAND SYNTAX:
; w10=spw_rebin(w9,dQ=<dQ>, Emin=<Emin>[,/neg_angles][,/pos_angles][,/all_angles])
;
; (optional keywords shown in square brackets)
;
;							KHA,JRS 10/8/00
;--------------------------------------------------------------------------------
;********************************************************************************

	common c_lamp_access, inst

	common grid, Qmin, Qmax, Emin, Emax

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start sqw_rebin:'

	take_datp, datp

	ibank=2
	IF(N_ELEMENTS(qb) GT 0) THEN dQ=qb
	IF(N_ELEMENTS(em) GT 0) THEN Emin=em
	IF(N_ELEMENTS(ib) GT 0) THEN ibank=ib

	IF KEYWORD_SET(pos_angles) THEN ibank=1
	IF KEYWORD_SET(neg_angles) THEN ibank=0
	IF KEYWORD_SET(all_angles) THEN ibank=2

;-------------------------------------------------------------------------------
;Set up starting parameters

	swap_QE=0	; swap_QE=0 => Q is x-axis, E is y-axis
			; swap_QE=1 => E is x-axis, Q is y-axis

	IF (N_ELEMENTS(dQ) NE 1) THEN BEGIN
		PRINT,'sqw_rebin: Error - dQ must be specified'
		return,w_in
	ENDIF
	IF (N_ELEMENTS(Emin0) NE 1) THEN Emin0=-1.E+10

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	IF (sw(0) NE 2) THEN BEGIN
		PRINT,'sqw_rebin: Error - input workspace must be 2-D: E vs. phi'
		return,W_in
	ENDIF
	nx=sw(1)
	ny=sw(2)
	IF (iprint GT 0) THEN PRINT,'nx=',nx,' ny=',ny
	x_in=datp.x	& sx=SIZE(x_in)
	y_in=datp.y	& sy=SIZE(y_in)
	IF (nx NE sx(1)) OR (ny NE sy(1)) THEN BEGIN
		PRINT,'sqw_rebin: Error - sx=',sx,' sy=',sy
		return,w_in
	ENDIF

	e_in=datp.e
	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN e_in=w_in*0.

	par=datp.p

	IF (iprint GT 0) THEN PRINT,'Instrument = ',inst
	IF (inst EQ 'D7') THEN BEGIN
		lambda=par(4)
		IF (N_ELEMENTS(ibank) EQ 0) THEN ibank=2
		TOF=FIX(par(8))
		IF (TOF NE 1) THEN BEGIN
			PRINT,'sqw_rebin: Error - workspace data is not in TOF'
			return,w_in
		ENDIF
	ENDIF ELSE lambda=par(21)

	IF (iprint GT 0) THEN PRINT,'lambda=',lambda,'A'

;-------------------------------------------------------------------------------------
;	Set constants and prepare arrays for rebinning to regular Q-E grid

	const1=5.22697		; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571	; E(meV)=const2*k(A^-1)^2 for neutron
	const3=3.956076		; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066		; E(meV)=const4/lambda(A)^2 for neutron

	Ei=const4/lambda^2
	ki=SQRT(Ei/const2)
	y_in=y_in*!pi/180.	; convert to radians

	nEps=nx+1	& Eps=FLTARR(nEps)
	Eps(0)=x_in(0)-(x_in(1)-x_in(0))/2.
	Eps(1:nx-1)=(x_in(0:nx-2)+x_in(1:nx-1))/2.
	Eps(nx)=x_in(nx-1)+(x_in(nx-1)-x_in(nx-2))/2.

	IF (iprint GT 0) THEN PRINT,'x=',x_in

	iEarr=WHERE(x_in GT Emin0)
	IF (iprint GT 0) THEN PRINT,'iEarr(0)=',iEarr(0),' nx=',nx
	Eps=Eps(iEarr(0):nx)	& nEps=nx-iEarr(0)+1
	Emin=Eps(0)	& Emax=Eps(nEps-1)
	Qmin=0.	& Qmax=SQRT((2.*Ei-Emin-2.*SQRT(Ei*(Ei-Emin))*COS(y_in(ny-1)))/const2)
	IF (iprint GT 0) THEN PRINT,'Emin=',Emin,' Emax=',Emax,' meV'
	IF (iprint GT 0) THEN PRINT,'Qmin=',Qmin,' Qmax=',Qmax,' A-1'

	IF (iprint GT 0) THEN PRINT,'Eps=',Eps

	nQ=FIX((Qmax-Qmin)/dQ)+1
	IF (iprint GT 0) THEN PRINT,'nQ=',nQ

	w_out=FLTARR(nQ,nEps)	& w_out(*,*)=0.	& e_out=w_out-1.
	Q=Qmin+FLOAT(INDGEN(nQ))*dQ
	IF (iprint GT 0) THEN PRINT,'Q=',Q

	IF (iprint GT 0) THEN PRINT,'y_in=',y_in*180./!pi

	IF (inst EQ 'D7') THEN BEGIN
		i=WHERE(y_in GT 0.,n)
		IF (n LE 0 OR n EQ ny) THEN BEGIN
			PRINT,'sqw_rebin: Error - For D7 both -ve and +ve angles must be present'
			return,w_in
		ENDIF
		IF (ibank EQ 2) THEN BEGIN
			twice=1
			iphi1=0		& iphi1next=i(0)
			iphi2=i(0)-1	& iphi2next=ny-1
		ENDIF ELSE BEGIN
			twice=0
			IF (ibank EQ 0) THEN BEGIN
				iphi1=0
				iphi2=i(0)-1
			ENDIF ELSE IF (ibank EQ 1) THEN BEGIN
				iphi1=i(0)
				iphi2=ny-1
			ENDIF ELSE BEGIN
				PRINT,'Sqw: Error - ibank =',ibank
				return,w_in
			ENDELSE
		ENDELSE
	ENDIF ELSE BEGIN
		twice=0
		iphi1=0	& iphi2=ny-1
	ENDELSE
	IF (iprint GT 0) THEN PRINT,'twice=',twice,' iphi1=',iphi1,' iphi2=',iphi2

start:
	nphi=iphi2-iphi1+2
	phi=FLTARR(nphi)
	phi(0)=y_in(iphi1)-(y_in(iphi1+1)-y_in(iphi1))/2.
	phi(1:nphi-2)=(y_in(iphi1:iphi2-1)+y_in(iphi1+1:iphi2))/2.
	phi(nphi-1)=y_in(iphi2)+(y_in(iphi2)-y_in(iphi2-1))/2.
	COSphi=COS(phi)

	w_buf=w_in(iEarr,iphi1:iphi2)
	e_buf=e_in(iEarr,iphi1:iphi2)
	y_buf=y_in(iphi1:iphi2)
	IF (phi(0) LT 0.) THEN BEGIN ; reverse array direction for negative angles
		w_buf=REVERSE(w_buf,2)
		e_buf=REVERSE(e_buf,2)
		y_buf=ABS(REVERSE(y_buf))
		phi=ABS(REVERSE(phi))
		COSphi=REVERSE(COSphi)
	ENDIF

	IF (iprint GT 0) THEN PRINT,'phi=',phi*180./!pi

	IF (iprint GT 0) THEN PRINT,'End of "prepare arrays" section'

;-------------------------------------------------------------------------------------
;	Rebin to constant Q grid

	a=const2		;	E(meV)=a*Q(A**-1)**2   for neutron

	iprint0=iprint
	oldymin=0.

	IF (iprint GT 0) THEN BEGIN
		b=''
		PRINT,'About to start rebinning. Hit return to continue'
		READ, b
	ENDIF

	FOR iQ=0,nQ-1 DO BEGIN
;		IF (iprint GT 0) THEN $
;			PRINT,'Rebinning at Q =',Q(iQ),' +/-',dQ/2.
		iprint=0
		IF (iprint0 GT 0) AND (10*(iQ/10) EQ iQ) THEN iprint=1
		IF (iprint GT 0) THEN PRINT,'iQ=',iQ
		Qmin=Q(iQ)-dQ/2.	& Qmax=Q(iQ)+dQ/2.
		Q00=[Qmin,Qmin,Qmax,Qmax]
		IF (iprint GT 0) THEN PRINT,Qmin,' < Q <',Qmax
		FOR iEps=0,nEps-2 DO BEGIN
			IF (iprint GT 0) THEN PRINT,'iEps=',iEps
			Emin=Eps(iEps)	& Emax=Eps(iEps+1)
			corrarea=dQ*(Emax-Emin)
			Eps0=[Emin,Emax,Emax,Emin]
			IF (iprint GT 0) THEN PRINT,Emin,' < Eps <',Emax
			COSphi0=(2.*Ei-Eps0-a*Q00^2)/(2.*SQRT(Ei*(Ei-Eps0)))
			IF (iprint GT 0) THEN PRINT,' COS(phi1-4):',COSphi0
			IF (MAX(ABS(COSphi0)) GE 1.) THEN GOTO, outside
			phi0=ACOS(COSphi0)
			IF (iprint GT 0) THEN PRINT,' phi0=',phi0*180./!pi
			phimin=MIN(phi0)	& phimax=MAX(phi0)
			IF (iprint GT 0) THEN PRINT,'Outside if: phimax=',phimax*180./!pi,'< phi(0)=',phi(0)*180./!pi
			IF (iprint GT 0) THEN PRINT,'        or: phimin=',phimin*180./!pi,'> phi(nphi-1)=',phi(nphi-1)*180./!pi,'  nphi=',nphi
			IF (phimax LT phi(0) OR phimin GT phi(nphi-1)) THEN GOTO, outside
			IF (iprint GT 0) THEN PRINT,'phi within range'
			iphi=WHERE(phi GT phimin AND phi LT phimax, nlines)
			iphi0=(iphi(0)-1)>0
			IF (nlines EQ 0) THEN BEGIN
				phimean=(phimin+phimax)/2.
				ip=WHERE(phi LT phimean, np)
				iphi0=ip(np-1)
			ENDIF
startrebin:		Areasum=0.
			wsum=0.
			e2sum=0.
			phiminmeas=7.	& phimaxmeas=0.
			FOR iphi=iphi0,(iphi0+nlines)<(nphi-2) DO BEGIN
				IF (iprint GT 0) THEN BEGIN
					ip1=iphi0
					ip2=(iphi0+nlines)<(nphi-2)
					PRINT,'FOR iphi=',ip1,',',ip2
					PRINT,'phi(',ip1,')=',phi(ip1)*180./!pi
					PRINT,'phi(',ip2+1,')=',phi(ip2+1)*180./!pi
				ENDIF
				COSphi1=COSphi(iphi)	& COSphi2=COSphi(iphi+1)
				COSphi0=[COSphi1,COSphi1,COSphi2,COSphi2]
				IF (iprint GT 0) THEN PRINT,'phi1=',phi(iphi)*180./!pi,$
								' phi2=',phi(iphi+1)*180./!pi
				Q0=SQRT((2.*Ei-Eps0-2.*SQRT(Ei*(Ei-Eps0))*COSphi0)/a)
				area=overlap(Q0,Eps0,iprint,oldymin)
				IF (area GT 0.) THEN BEGIN
					IF (iprint GT 0) THEN PRINT,'Area>0'
					w=w_buf(iEps,iphi)	& e=e_buf(iEps,iphi)
					IF (w NE 0. OR e GE 0.) THEN BEGIN
						areasum=areasum+area
						wsum=wsum+area*w
						e2sum=e2sum+(area*e)^2
						phiminmeas=phiminmeas<phi(iphi)
						phimaxmeas=phimaxmeas>phi(iphi+1)
						IF (iprint GT 0) THEN PRINT, $
							'w_buf(',iEps,',',iphi,')=',w
						IF (iprint GT 0) THEN PRINT, $
							'e_buf(',iEps,',',iphi,')=',e
						IF (iprint GT 0) THEN PRINT, $
						phiminmeas,' < phimeas <',phimaxmeas
					ENDIF
				ENDIF ELSE IF (iprint GT 0) THEN PRINT,'Area<=0'
			ENDFOR
			IF (areasum NE 0.) THEN BEGIN
				IF (iprint GT 0) THEN PRINT,'areasum NE 0. - OK'
				w_out(iQ,iEps)=wsum/areasum
				e_out(iQ,iEps)=SQRT(e2sum)/areasum
				GOTO, binned
			ENDIF ELSE IF (iprint GT 0) THEN PRINT,'areasum is zero'
outside:		IF (iprint GT 0) THEN PRINT,'Outside covered Q-w region'
			IF (iprint GT 0) THEN PRINT,'phi=',phi*180./!pi
			w_out(iQ,iEps)=0.
			e_out(iQ,iEps)=-1.
			GOTO, nextpoint
binned:
			IF (iprint GT 0) THEN PRINT,'phimin=',phimin,' phimax=',phimax
			IF (iprint GT 0) THEN PRINT,'measur=',phiminmeas,'        ',phimaxmeas
			p1=phimin>phiminmeas
			p2=phimax<phimaxmeas
			IF (p2-p1 LT (phimax-phimin)/2.) THEN BEGIN
				IF (iprint GT 0) THEN PRINT,'Point removed'
				w_out(iQ,iEps)=0.
				e_out(iQ,iEps)=-1.
			ENDIF ELSE IF (iprint GT 0) THEN PRINT,'Point kept'
nextpoint:
			IF (iprint GT 0) THEN PRINT,'*********************************************************'
		ENDFOR
	ENDFOR

	iprint=iprint0

	IF (iprint GT 0) THEN PRINT,'End of rebinning'

	IF (twice EQ 1) THEN BEGIN
		IF (iphi1 EQ 0) THEN BEGIN
			w_out1=w_out	& e_out1=e_out
			iphi1=iphi1next
			iphi2=iphi2next
			GOTO, start
		ENDIF ELSE BEGIN
			w_out2=w_out	& e_out2=e_out
			w_out(*,*)=0.	& e_out(*,*)=0.
			not1=WHERE(e_out1 LE 0.,n1)
			IF (n1 NE 0) THEN e_out1(not1)=1.
			not2=WHERE(e_out2 LE 0.,n2)
			IF (n2 NE 0) THEN e_out2(not2)=1.
			w_out=(w_out1/e_out1^2+w_out2/e_out2^2)/(1./e_out1^2+1./e_out2^2)
			e_out=1./SQRT(1./e_out1^2+1./e_out2^2)
			IF (n1 NE 0) THEN e_out1(not1)=-1.
			IF (n2 NE 0) THEN e_out2(not2)=-1.
			IF (n1 NE 0) THEN BEGIN
				w_out(not1)=w_out2(not1)
				e_out(not1)=e_out2(not1)
			ENDIF
			IF (n2 NE 0) THEN BEGIN
				w_out(not2)=w_out1(not2)
				e_out(not2)=e_out1(not2)
			ENDIF
		ENDELSE
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of rebinning section'

;-------------------------------------------------------------------------------------
;	Chop off superfluous bits

	i=WHERE(e_out GT -1.,n)
	IF(iprint GT 0) THEN PRINT,n,' non-zeroed points'

checkQ2:
	iw0=WHERE(w_out(nQ-1,*) EQ 0.,nw0) & ie0=WHERE(e_out(nQ-1,*) EQ -1.,ne0)
	IF (nw0 EQ nEps AND ne0 EQ nEps) THEN BEGIN
		nQ=nQ-1
		w_out=w_out(0:nQ-1,*) & e_out=e_out(0:nQ-1,*) & Q=Q(0:nQ-1)
		GOTO, checkQ2
	ENDIF

checkEps1:
	iw0=WHERE(w_out(*,0) EQ 0.,nw0) & ie0=WHERE(e_out(*,0) EQ -1.,ne0)
	IF (nw0 EQ nQ AND ne0 EQ nQ) THEN BEGIN
		nEps=nEps-1
		w_out=w_out(*,1:nEps) & e_out=e_out(*,1:nEps) & Eps=Eps(1:nEps)
		GOTO, checkEps1
	ENDIF

checkEps2:
	iw0=WHERE(w_out(*,nEps-1) EQ 0.,nw0) & ie0=WHERE(e_out(*,nEps-1) EQ -1.,ne0)
	IF (nw0 EQ nQ AND ne0 EQ nQ) THEN BEGIN
		nEps=nEps-1
		w_out=w_out(*,0:nEps-1) & e_out=e_out(*,0:nEps-1) & Eps=Eps(0:nEps-1)
		GOTO, checkEps2
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of chopping section'

;-------------------------------------------------------------------------------------
;	Return parameters and exit

	IF (swap_QE EQ 0) THEN BEGIN
		datp.y_tit=datp.x_tit
		datp.x_tit='Wavevector Transfer (A-1)'
		mod_datp, datp, "x", Q
		mod_datp, datp, "y", x_in(iEarr)
	ENDIF ELSE BEGIN
		w_out=TRANSPOSE(w_out)	& e_out=TRANSPOSE(e_out)
		datp.y_tit='Wavevector Transfer (A-1)'
		mod_datp, datp, "x", x_in(iEarr)
		mod_datp, datp, "y", Q
	ENDELSE

	mod_datp, datp, "e", e_out

	s=STRTRIM(STRING(FLOAT(dQ)),2)  & i=STRPOS(s,'.') & dQ=STRMID(s,0,i(0)+3)
	IF (Emin0 GT -9.E+09) THEN Emin=STRTRIM(STRING(FIX(Emin0)),2) ELSE Emin='0'
	s=' -sr('+dQ+','+Emin
	IF (inst EQ 'D7') THEN s=s+','+STRTRIM(STRING(ibank),2)+')' ELSE s=s+')'
	datp.other_tit=datp.other_tit+s

	PRINT, 'sqw_rebin: Rebinned to constant Q-w: dQ='+dQ+'A-1'

	give_datp, datp

finished:
	RETURN, w_out
	END


;
; Window with widgets for the call of SQW (gjk)
;
;This was originally written by Arne Dallmeyer Aug94
;
; Restructed (March95) for LAMP as installed (Feb95) gjk.
;
;Main difference is to get all common variables in lamp.cbk and
;make this a stand-alone interface. It eventually calls sqw.pro 
;must be in the standard-macro search-path for lamp. 
;
;Convention is all standard macros in ~kearley/lamp_macros

;**********************************************************;
pro window_creation
;
; Creates and realizes SQWWIN-Window
;
common sqwblock,maxws,maxE,maxQ,winsli,Esd,nang,nch,$
   lambd,pi,step,arb_factor,qmin,qmax,Q,fast,wsin_slider,$
   wsout_slider,Emin_slider,Estep_slider,Estep_label,$
   Qstep_slider,Qstep_label,Emin_label,Emax_slider,Emax_label,$
   Qmin_slider,Qmin_label,Qmax_slider,Qmax_label,message,base,$
   Emin,Emax,Esteps,p,error,wsin_sqw1,wsout_sqw1,Estep_sqw1,$
   Qstep_sqw1,Emin_sqw1,Emax_sqw1,Qmin_sqw1,Qmax_sqw1,Edim,Qdim,$
   dimtot,dim,Edimens,Qdimens,warn_label,i_do_it

@lamp.cbk

;
; Test if there is already a SQWWIN on the screen
i_test=xregistered('eventhandler_sqw')
if i_test ne 0 then widget_control,base,/destroy
  base=widget_base (space=5,/column,title='S(Qw) interpolation',resource_name='lampdon')
  buttons=widget_base (base, /row, space=350)
  warn_label=widget_label(FONT=ft_biggest,base, value=' ')

  si_tr=size(triang)
  if (si_tr(0) eq 2) and (si_tr(1) eq 3) then begin $
    farea=widget_base(base,/row,/frame,space=20)
;
    mess_left=widget_base(farea,/row,space=40)
    flabel1=widget_label(FONT=ft_biggest,mess_left,value='use previous triangulation ?');
    fab  =widget_base(mess_left,/column,/exclusive)
    fast_button  =widget_button(FONT=ft_biggest,fab,value='yes',uvalue='fast')
    nofast_button=widget_button(FONT=ft_biggest,fab,value='no',uvalue='slow')
    widget_control,nofast_button,/set_button
;
    mess_right=widget_base(farea,/row,space=40)
    tr_lab_1  =widget_label(FONT=ft_biggest,mess_right,value='destroy triangles ?')
    tria_but  =widget_base(mess_right,/column,/exclusive)
    tr_y_button=widget_button(FONT=ft_biggest,tria_but,value='yes',uvalue='destr')
    tr_n_button=widget_button(FONT=ft_biggest,tria_but,value='no',uvalue='keep')
    widget_control,tr_n_button,/set_button
  endif
  ;;;;;
  wspace =widget_base(base, /row, space=40, /frame)
  steps  =widget_base(base, /column, /frame)
  ostep  =widget_base(steps, /column)
  ustep  =widget_base(steps, /row)
  Estep  =widget_base(ustep, /column, /frame)
  Qstep  =widget_base(ustep, /column, /frame)
  ranges =widget_base(base, /row)
  Erange =widget_base(ranges, /column, /frame)
  Qrange =widget_base(ranges, /column, /frame)
  dimens =widget_base(base,/column)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  done_button =widget_button(FONT=ft_biggest,buttons,value='Do Interpolation',uvalue='done')
  abort_button=widget_button(FONT=ft_biggest,buttons,value='abort',uvalue='abort')
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  wsin_slider =widget_slider(FONT=ft_biggest,wspace,uvalue='wsin', $
    title='workspace #(in)',minimum=1,maximum=maxws)
  widget_control,wsin_slider,set_value=winsli
  wsout_slider=widget_slider(FONT=ft_biggest,wspace,uvalue='wsout', $
    title='workspace #(out)',minimum=1,maximum=maxws)
  if winsli eq maxws then $
    widget_control,wsout_slider,set_value=2 $
  else widget_control,wsout_slider,set_value=winsli+1
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  head_label=widget_label(FONT=ft_biggest,ostep,value='STEPWIDTH',/frame) 
  ;
  Estep_label =widget_label(FONT=ft_biggest,Estep,value='E-step=',uvalue='Estep')
  Estep_slider=widget_slider(FONT=ft_biggest,Estep,xsize=300,value='1',uvalue='Estep',$
    /suppress_value)
  Qstep_label =widget_label (FONT=ft_biggest,Qstep,value='Q-step=',uvalue='Qstep')
  Qstep_slider=widget_slider(FONT=ft_biggest,Qstep,xsize=300,value='1',uvalue='Qstep',$
    minimum=1,maximum=maxQ,/suppress_value)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  E_label=widget_label(FONT=ft_biggest,Erange, value='E-RANGE', /frame) 
  ;
  Emin_label =widget_label(FONT=ft_biggest,Erange,value='Emin=',uvalue='Eminl')
  Emin_slider=widget_slider(FONT=ft_biggest,Erange,xsize=305,uvalue='Emins', $
                            minimum=1,maximum=maxE,/suppress_value)
  Emax_label =widget_label(FONT=ft_biggest,Erange,value='Emax=',uvalue='Emaxl')
  Emax_slider=widget_slider(FONT=ft_biggest,Erange,xsize=305,uvalue='Emaxs', $
                            minimum=1,maximum=maxE,/suppress_value)
  Edim=widget_label(FONT=ft_biggest,Erange,/frame)
  ;;;;;;;;;;;;;;;;
  Q_label=widget_label(FONT=ft_biggest,Qrange, value='Q-RANGE', /frame)
  ;
  Qmin_label =widget_label (FONT=ft_biggest,Qrange,value='Qmin=',uvalue='Qminl')
  Qmin_slider=widget_slider(FONT=ft_biggest,Qrange,xsize=305,uvalue='Qmins', $
                            minimum=1,maximum=maxQ,/suppress_value)
  Qmax_label =widget_label (FONT=ft_biggest,Qrange,value='Qmax=',uvalue='Qmaxl')
  Qmax_slider=widget_slider(FONT=ft_biggest,Qrange,xsize=305,uvalue='Qmaxs', $
                            minimum=1,maximum=maxQ,/suppress_value)
  Qdim=widget_label(FONT=ft_biggest,Qrange,/frame)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  dimtot=widget_label(FONT=ft_biggest,dimens,/frame,value='   ',xsize=22)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  bid=sys_dep      ('DYNLAB',base,1)
  widget_control,base,group_leader=lamp_b1,/realize
  xmanager,'eventhandler_sqw',base,group_leader=group
end

;*********************************************************;
;
pro update2
;
; Updates slider and label values
;
common sqwblock
 
;##### mac.in should take care of all in lamp and dons.cbk ...gjk 2-3-95
@lamp.cbk
;@dons.cbk
  two=winsli
@mac.in
  i_check=size(p_in)
  if i_check(0) eq 0 then return
  nang   =fix(p_in(30))
  nch   =fix(p_in(19))
  lambd     =fix(p_in(21))
  Esteps=fltarr(maxE)
  Emax  =x_in(nch-1)
  pi        =3.1415927
  arb_factor=2.
;
;      Calculate ranges of the energy-sliders
;
  if (81.799/p_in(21)^2) gt (3*p_in(11)/11.6) then Emin=-81.799/p_in(21)^2 $
    else Emin=-3*p_in(11)/11.6
  if x_in(0) gt Emin then Emin=x_in(0)
  a=findgen(maxE)
  Esteps=Emin+a*(Emax-Emin)/(maxE-1)
  if nch-1 ge p_in(9) then $
    Esd=round((x_in(p_in(9)+1)-x_in(p_in(9)))*1000.)/1000. $
  else sd=0.01  
;
; Calculates ranges of the Q-sliders 
;
  numb_q=100
  qmin=4*pi*sin(min(y_in/2.)*pi/180.)/lambd
  qmax=arb_factor*4*pi*sin(max(y_in/2.)*pi/180.)/lambd
  a=findgen(numb_q)
  Q=qmin+a*(qmax-qmin)/(numb_q-1)
  stepmin=qmax/nang/arb_factor
  stepmax=qmax/arb_factor/2.
  a=findgen(numb_q)
  step=stepmin+a*(stepmax-stepmin)/(numb_q-1)
;
  if nang gt 50 then Qsd=qmax/50. $
    else Qsd=qmax/nang
  i=0
  repeat begin
    i=i+1
  endrep until (Qsd le step(i)) or (i eq (size(step))(1))
    Qsd=step(i)  
;
;      Set values of sliders and labels
;
  widget_control,Estep_slider, $
    set_value=round(maxE/6.)
  widget_control,Estep_slider,get_value=s
  Sdummy=(1./5.)*Esd+s*((5.*Esd-(1./5.)*Esd)/maxE)
  widget_control,Estep_label,set_value='Estep='+ $
    strtrim(string(Sdummy,format='(f10.4)'),2)
  widget_control,Qstep_slider,set_value=i
  widget_control,Qstep_label,set_value='Qstep='+ $
    strtrim(string(step(i),format='(f10.4)'),2)
  widget_control,Emin_slider,set_value=1
  widget_control,Emin_label,set_value='Emin='+ $
    strtrim(string(Emin,format='(f10.2)'),2)
  widget_control,Emax_slider,set_value=maxE
  widget_control,Emax_label,set_value='Emax='+ $
    strtrim(string(Emax,format='(f10.2)'),2)
  widget_control,Qmin_slider,set_value=1
  widget_control,Qmin_label,set_value='Qmin='+ $
    strtrim(string(qmin,format='(f10.2)'),2)
  widget_control,Qmax_slider,set_value=maxQ
  widget_control,Qmax_label,set_value='Qmax='+ $
    strtrim(string(qmax,format='(f10.2)'),2)
  dim_update
end


;*********************************************************;

pro dim_update
;
; Updates dimension-labels
;
common sqwblock
  joker=0
  read_out,joker
  if joker eq 0 then begin
    widget_control,Edim,set_value='E-dim=' +$
    strtrim(Edimens,2)
    widget_control,Qdim,set_value='Q-dim=' +$
    strtrim(Qdimens,2)
    widget_control,dimtot,set_value='number of points=' +$
    strtrim(Edimens*Qdimens,2)
  endif
end

;*************************************************************;

pro read_out,joker
;
; Reads out slider and label values; converts them into
; formatted strings; determines calculation steps
;
common sqwblock
@lamp.cbk
  joker=0
  widget_control,wsin_slider,get_value=wsin_sqw
	 iii=execute('w_test = w'+strtrim(string(wsin_sqw),2))
	 siz_test=size(w_test)
	 if(siz_test(0)) eq 0 then begin
	   i_do_it=-1
           P_MUS,'mus_cannon'
           joke_text='WORKSPACE EMPTY' 
           widget_control,warn_label,set_value=joke_text
           joker=1
           return
	 endif
  if (strpos(his(wsin_sqw),'t2e') lt 0) and $
     (strpos(his(wsin_sqw),'INX') lt 0) and $
     (strpos(his(wsin_sqw),'inx') lt 0) then begin
      P_MUS,'mus_cannon'
      joke_text='WORKSPACE NOT IN ENERGY'
      widget_control,warn_label,set_value=joke_text
      joker=1
      return
  endif

  if strpos(his(wsin_sqw),'sqw') gt 0 then begin
      P_MUS,'mus_cannon'
      joke_text='WORKSPACE ALREADY INTERPOLATED'
      widget_control,warn_label,set_value=joke_text
      joker=1
      return
  endif
  
  
  widget_control,wsin_slider,get_value=wsin_sqw
  widget_control,wsout_slider,get_value=wsout_sqw
 
  widget_control,Estep_label,get_value=Estep_sqw
  widget_control,Qstep_label,get_value=Qstep_sqw
  widget_control,Emin_label,get_value=Emin_sqw
  widget_control,Emax_label,get_value=Emax_sqw
  widget_control,Qmin_label,get_value=Qmin_sqw
  widget_control,Qmax_label,get_value=Qmax_sqw
;;;;;;;;;;;;;;;;;;;;;;;;
  wsin_sqw1 =strtrim(string(wsin_sqw),2)
  wsout_sqw1=strtrim(string(wsout_sqw),2)
  Estep_sqw1=strtrim(strmid(Estep_sqw,6,6),2)
  Qstep_sqw1=strtrim(strmid(Qstep_sqw,6,6),2)
  Emin_sqw1 =strtrim(strmid(Emin_sqw,5,6),2)
  Emax_sqw1 =strtrim(strmid(Emax_sqw,5,6),2)
  Qmin_sqw1 =strtrim(strmid(Qmin_sqw,5,6),2)
  Qmax_sqw1 =strtrim(strmid(Qmax_sqw,5,6),2)
  e1=float(Emax_sqw1)
  e2=float(Emin_sqw1)
  e3=float(Estep_sqw1)
  q1=float(Qmax_sqw1)
  q2=float(Qmin_sqw1)
  q3=float(Qstep_sqw1)
  Edimens=round((e1-e2)/e3)+1
  Qdimens=round((q1-q2)/q3)+1
  if wsin_sqw eq wsout_sqw then begin
     P_MUS,'mus_cannon'
     joke_text='INPUT AND OUTPUT WORKSPACES ARE THE SAME'
     widget_control,warn_label,set_value=joke_text
     joker=1
     return
  endif
 
end

;*******************************************************;

pro eventhandler_sqw_event, event
;
; Operations following widget events
;
common sqwblock
 
@lamp.cbk

  widget_control, event.id, get_uvalue=p
  joke_text=' '
  widget_control,warn_label,set_value=joke_text
  case p of 'done'  : begin
     joker=0
     read_out,joker
     if joker eq 0 then begin
     if Edimens*Qdimens ge 25000 then joke_text='TOO MANY POINTS GENERATED' $
     else begin
       sqw_output
       widget_control,base,/destroy
     endelse
     endif
     if joker eq 1 then begin 
        joke_text='SORRY - INVALID SELECTION OF WORKSPACES' 
        P_MUS,'mus_cannon'
        widget_control,warn_label,set_value=joke_text
     endif
   end
;
  'abort': widget_control,event.top,/destroy
;
  'fast' : fast=1
;
  'slow' : fast=-1
;
  'wsin' : begin
; 
;            Check whether input workspace has any data,
;            is in energy, or previously known to sqw
;
         widget_control,wsin_slider,get_value=winsli
	 iii=execute('w_test = w'+strtrim(string(winsli),2))
	 siz_test=size(w_test)
      if(siz_test(0)) eq 0 then begin
	  i_do_it=-1
          P_MUS,'mus_cannon'
          joke_text='WORKSPACE EMPTY' 
          widget_control,warn_label,set_value=joke_text
          joker=1
          return
      endif


      if (strpos(his(winsli),'t2e') lt 0) and $
         (strpos(his(winsli),'INX') lt 0) and $
         (strpos(his(winsli),'inx') lt 0) then begin
          P_MUS,'mus_cannon'
          joke_text='WORKSPACE NOT IN ENERGY'
          widget_control,warn_label,set_value=joke_text
          joker=1
          return
      endif
      
      if strpos(his(winsli),'sqw') gt 0 then begin
          P_MUS,'mus_cannon'
          joke_text='WORKSPACE ALREADY INTERPOLATED'
          widget_control,warn_label,set_value=joke_text
          joker=1
          return
      endif


           joke_text=' '
	   i_do_it=0 
           widget_control,warn_label,set_value=joke_text
            update2
         end
	 
  'wsout': widget_control,wsout_slider,get_value=o
;
  'Estep': begin 
;
;                Read out energy stepwidth
;                set label values
;
         widget_control,Estep_slider,get_value=Es
         dummy=(1./5.)*Esd+Es*((5.*Esd-(1./5.)*Esd)/maxE)
         widget_control,Estep_label,set_value='Estep='+ $
           strtrim(string(dummy,format='(f10.4)'),2)
         joker=0
         read_out,joker
         if joker eq 0 then dim_update
         end  
;
  'Qstep': begin 
;
;                Read out Q stepwidth
;                set label values
;   
         widget_control,Qstep_slider,get_value=Qs
	 q_test=size(step)
	 if q_test(0) gt 0 then begin
            widget_control,Qstep_label,set_value='Qstep='+ $
            strtrim(string(step(Qs-1),format='(f10.4)'),2)
            joker=0
            read_out,joker
            if joker eq 0 then dim_update
	 endif else begin
	      joke_text='NAUGHTY DATA (Q_STEPS)'
	      widget_control,warn_label,set_value=joke_text
         endelse
         end 
;
  'Emins': begin
;
;             Read out Emin, Emax; is Emin < Emax ?
;             set label values
;
         widget_control,Emin_slider,get_value=inE
         widget_control,Emax_slider,get_value=axE
	 e_test=size(Esteps)
	 if e_test(0) gt 0 then begin
            if inE ge axE then begin $
              widget_control,Emax_slider,set_value=maxE
              widget_control,Emax_label,set_value='Emax='+ $
              strtrim(string(Emax,format='(f10.2)'),2)
            endif
            widget_control,Emin_label,set_value='Emin='+ $
            strtrim(string(Esteps(inE-1),format='(f10.2)'),2)
            joker=0
            read_out,joker
            if joker eq 0 then dim_update
	 endif else begin
	      joke_text='NAUGHTY DATA (E_STEPS)'
	      widget_control,warn_label,set_value=joke_text
	 endelse
         end
;
  'Emaxs': begin
;
         widget_control,Emin_slider,get_value=inE
         widget_control,Emax_slider,get_value=axE
	 e_test=size(Esteps)
	 if e_test(0) gt 0 then begin
         if inE ge axE then begin $
           widget_control,Emax_slider,set_value=maxE
           widget_control,Emax_label,set_value='Emax='+ $
             strtrim(string(Emax,format='(f10.2)'),2)
         endif $
         else widget_control,Emax_label,set_value='Emax='+ $
           strtrim(string(Esteps(axE-1),format='(f10.2)'),2) 
         joker=0
         read_out,joker
         if joker eq 0 then dim_update
	 endif else begin
	      joke_text='NAUGHTY DATA (E_STEPS)'
	      widget_control,warn_label,set_value=joke_text
	 endelse
         end
;
  'Qmins': begin
;
;             Read out Qmin, Qmax; is Qmin < Qmax ?
;             set label values
;
         widget_control,Qmin_slider,get_value=inQ
         widget_control,Qmax_slider,get_value=axQ
	 q_test=size(Q)
	 if q_test(0) gt 0 then begin
         if inQ ge axQ then begin $
           widget_control,Qmax_slider,set_value=maxQ
           widget_control,Qmax_label, set_value='Qmax='+ $
             strtrim(string(qmax,format='(f10.2)'),2)
         endif
         widget_control,Qmin_label,set_value='Qmin='+ $
           strtrim(string(Q(inQ-1),format='(f10.2)'),1)
         joker=0
         read_out,joker
         if joker eq 0 then dim_update
	 endif else begin
	      joke_text='NAUGHTY DATA (Q_STEPS)'
	      widget_control,warn_label,set_value=joke_text
	 endelse
         end
;
  'Qmaxs': begin
         widget_control,Qmin_slider,get_value=inQ
         widget_control,Qmax_slider,get_value=axQ
	 q_test=size(Q)
	 if q_test(0) gt 0 then begin
         if inQ ge axQ then begin $
           widget_control,Qmax_slider,set_value=maxQ
           widget_control,Qmax_label,set_value='Qmax='+ $
             strtrim(string(qmax,format='(f10.2)'),2)
         endif $
         else widget_control,Qmax_label,set_value='Qmax='+ $
           strtrim(string(Q(axQ-1),format='(f10.2)'),2)
         dim_update
	 endif else begin
	      joke_text='NAUGHTY DATA (Q_STEPS)'
	      widget_control,warn_label,set_value=joke_text
	 endelse
         end
;
   'Yes' : begin
;
;               Keep many calculation steps
;
         widget_control,error,/destroy 
         widget_control,base,sensitive=1
         sqw_output
         widget_control,base,/destroy
         end
    'No' : begin
;
;               Change slider values
;
         widget_control,base,sensitive=1
         widget_control,error,/destroy
         end
;
  'destr': begin
;
;               Destroy triangles
;
         triang=0
         widget_control,base,/destroy
         window_creation
         end
;
  'keep' : dummy=1
  endcase
end

;**********************************************************;
;************************************************************;

pro sqw_output
;
 
@lamp.cbk
@dons.cbk
common sqwblock
;
; Execute SQW-call

  rhs2='sqw(w'+wsin_sqw1+','+Estep_sqw1+','+Qstep_sqw1+$
    ','+Emin_sqw1+','+Emax_sqw1+','+Qmin_sqw1+','+Qmax_sqw1
  if fast eq 1 then rhs2=rhs2+',/fast)'else rhs2=rhs2+')'
  lhs2='w'+wsout_sqw1+'='
  joke_text='THIS COULD TAKE A WHILE....'
  widget_control,warn_label,set_value=joke_text
  comy=strarr(1)
  comy(0)=lhs2+rhs2
  xicuter,comy(0)
  y_tit(fix(wsout_sqw1))='Q(A-1)'
end

pro sqwwin,ws=wsin
;
; Window with widgets for the call of SQW (gjk)
;
;This was originally written by Arne Dallmeyer Aug94
;
; Restructed (March95) for LAMP as installed (Feb95) gjk.
;
;Main difference is to get all common variables in lamp.cbk and
;make this a stand-alone interface. It eventually calls sqw.pro 
;must be in the standard-macro search-path for lamp. 
;
;Convention is all standard macros in ~kearley/lamp_macros
;
;
common sqwblock
 
@lamp.cbk
  maxws=20
  maxE=100.
  maxQ=100.
  fast=-1
  i_do_it=0
  esd=0 & step=0 & arb_factor=0 & qmin=0 & qmax=0 & Q=0
  emax=0 & emin=0 & esteps=0
  P_MUS,'mus_harp'
    
;
;        Keyword check
;
  if keyword_set(wsin) then begin
    two=wsin
    winsli=wsin 
  endif else begin
    two=maxws
    winsli=1
  endelse
      two=winsli
      window_creation
end
;pro startmono


PRO mon,lam,qmin,qmax,dan0,sw0,fac,slit,pol,polfac,mt,$
a,b,c,d,db,dbtime,filey,totalp,totalt,totalh,totalm,con





slitmax=4.

; formula for counting times  t=a(b+cq^d)

con=' t'
if (mt eq 1)then con=' t'
if (mt eq 0)then con=' m'

lres=0.04
ss=3440.
san=fltarr(1000)
dan=fltarr(1000)
s2=fltarr(1000)
s3=fltarr(1000)
q=fltarr(1000)
sw=fltarr(1000)
dq=fltarr(1000)
t=fltarr(1000)

thmin=180.*asin(lam*qmin/(4*!pi))/!pi
thmax=180.*asin(lam*qmax/(4*!pi))/!pi

print,' thmin= ',thmin,' thmax= ',thmax
print,' dth/th= ',((sw0/ss)*180/!pi)/thmin
dtth=((sw0/ss)*180/!pi)/thmin

i=0
qq=0
san(0)=thmin
q(0)=qmin
sw(0)=sw0

close,3
close,10
path='/users/d17/'
openw,3,path+filey+'.cmd'
print,'opening....',path+filey+'.cmd'
printf,3,'!',lam,qmin,qmax,fac,dan0,sw0
printf,3,' att 0'
printf,3,' s2w 0'
printf,3,' s3w 0'

openw,10,path+filey+'_db.cmd'
print,'opening....',path+filey+'_db.cmd'
printf,10,'!',lam,qmin,qmax,fac,dan0,sw0
printf,10,'! direct beam calibration runs'
printf,10,'dan ',dan0
printf,10,'trs 10'
printf,10,' s2w 0'
printf,10,' s3w 0'
printf,10,'san 0'



while (qq le qmax) do begin

  i=i+1  
  dq(i)=q(i-1)*sqrt(lres^2+dtth^2)  
  q(i)=q(i-1)+dq(i)/fac
  qq=q(i)
  san(i)=(180/!pi)*asin(lam*q(i)/(4*!pi)) 
  dan(i)=2.*san(i)+dan0
  sw(i)=(san(i)/san(0))*sw0
  if (sw(i) gt slitmax) then sw(i)=slitmax
  t(i)=a*(b+c*q(i)^d)
;  print,san(i),dan(i),sw(i),q(i),dq(i)

   printf,3,'par sub q=',q(i)   
   printf,3,'dan ',dan(i)
   printf,3,'san ',san(i)
   printf,3,'dan ',dan(i)
if (slit eq 1)then begin
   printf,3,'s2w ',sw(i)
   printf,3,'s3w ',sw(i)
endif
   printf,3,'run ',t(i),con

if (pol eq 1) then begin
   printf,3,'par sub q=',q(i),' Flipper on'
   printf,3,'b1 on'
   printf,3,'b2 on'
   printf,3,'run ',t(i)*polfac,con
   printf,3,'b1 off'
   printf,3,'b2 off'
endif



   sws=sw(i)*sw(i)
; attenuators for direct beam run

   if (sws lt 0.03) then begin
     printf,10,'att 0'
      printf,10,'par sub att 0 db q=',q(i)
   endif 
   if (sws ge 0.03 and sws lt 0.078) then begin
     printf,10,'att 1'
     printf,10,'par sub att 1 db q=',q(i)
   endif
   if (sws ge 0.078 and sws lt 0.18) then begin
     printf,10,'att 2'
     printf,10,'par sub att 2 db q=',q(i)
   endif
   if (sws ge 0.18 and sws lt 0.46) then begin
     printf,10,'att 3'
     printf,10,'par sub att 3 db q=',q(i)
   endif
   if (sws ge 0.46 and sws lt 1.21) then begin
     printf,10,'att 4'
     printf,10,'par sub att 4 db q=',q(i)
   endif
   if (sws ge 1.21 and sws lt 2.89) then begin
     printf,10,'att 5'
     printf,10,'par sub att 5 db q=',q(i)
   endif
   if (sws ge 2.89 and sws lt 7.84) then begin
     printf,10,'att 6'
     printf,10,'par sub att 6 db q=',q(i)
   endif
   if (sws ge 7.84 and sws lt 25.) then begin
     printf,10,'att 7'
     printf,10,'par sub att 7 db q=',q(i)
   endif
   if (sws ge 25.) then begin
     printf,10,'ose in'
   endif
   printf,10,'sol in'
   printf,10,'fl1 in'

   
  
   printf,10,'s2w ',sw(i)
   printf,10,'s3w ',sw(i)
   printf,10,'run ',dbtime,' t'


endwhile
qq=q(1:i)
s=sw(1:i)
printf,10,'s2w 0'
printf,10,'s3w 0'
printf,10,'att 0'
printf,3,'s2w 0'
printf,3,'s3w 0'
printf,3,'att 0'



print,'number of points in the scan = ',i
print,'number of lines in the file = ',i*6
print,'total reflection time = ',total(t)/3600.,' hours'
if (pol eq 1) then begin 
 print,'plus flipper time of: ',total(t)*polfac/3600.,' hours'
 print,'gives a grand total of: ',(total(t)*polfac/3600)+(total(t)/3600)
endif
if (db eq 1)then print,'total direct beam time = ',(dbtime*i)/3600.,' hours'
totalt=pol*(total(t)*polfac/3600.)+(total(t)/3600.)+db*(dbtime*i)/3600.

totalh=floor(totalt)
totalm=floor((totalt-floor(totalt))*60.)
print,totalt,totalh,totalm
totalp=i
close,3
close,10
print,!stime

end

pro startmono_event,event
;** ************
;**
	COMMON local,nparams,whatwid
	con='x'
	par1=fltarr(6)
        par2=intarr(10)
	par3=strarr(1)
      	wWidget =  Event.top

        WIDGET_CONTROL,event.id,get_uvalue=gv

        if(gv eq 'quit')then widget_control,event.top,/destroy

        if(gv eq 'do')then begin
	FOR i=0,nparams-1 DO BEGIN
          Widget_Control, whatwid(i), GET_VALUE=gv
;	  print,i,gv
	  if(i lt 6) then  par1(i)=STRTRIM(gv,2)
	  if(i ge 6 and i lt 16) then par2(i-6)=STRTRIM(gv,2)
	  if(i eq 16) then par3(i-16)=STRTRIM(gv,2)
        ENDFOR
;	print,par1,par2,par3

	mon,par1(0),par1(1),par1(2),par1(3),par1(4),par1(5)$
,par2(0),par2(1),par2(2),par2(3),par2(4),par2(5),par2(6),par2(7),par2(8)$
,par2(9),par3(0),totalp,totalt,totalh,totalm,con

	
	Widget_Control, whatwid(nparams-2), SET_VALUE=strtrim(string(totalp),2)
	
	if (par2(3) eq 0)then begin
	  Widget_Control, whatwid(nparams-1), SET_VALUE=strtrim(string(floor(totalt*3600.)),2)
	endif
	
	if (par2(3) eq 1)then begin
	  Widget_Control, whatwid(nparams-1), SET_VALUE=strtrim(string(totalh),2)+' h'$
	  +strtrim(string(totalm),2)+' m'
	endif
	
endif	
end


pro send_command,event,i
;** ************
;**
	Widget_Control, event.id, GET_VALUE=gv
	gv=STRTRIM(gv,2)
	command=fix(gv)
;	  
;	print, gv
;
end

PRO startmono
COMMON local,nparams,whatwid
nparams=19
whatwid=intarr(nparams)
result='xxx'
param=strarr(nparams)
                param_text=STRARR(nparams)
		param_text(0) ='Wavelength (A)'
		param_text(1) ='q min (A^-1)'
		param_text(2) ='q max (A^-1)'
		param_text(3) ='Detector position (deg)'
		param_text(4) ='Starting value for s2w & s3w (mm)'
		param_text(5) ='Points inside dq'
		
		param_text(6) ='Open slits? 0/1'
		param_text(7) ='Polarized neutrons? 0/1'
		param_text(8) ='Extra counting factor for I-'
		param_text(9) ='Count on monitor (0) or time (1)?'
		param_text(10) ='Counting formula a(b+cq^d) a='
		param_text(11) ='Counting formula a(b+cq^d) b='
		param_text(12) ='Counting formula a(b+cq^d) c='
		param_text(13) ='Counting formula a(b+cq^d) d='
		param_text(14) ='Make direct beam calibration? 0/1'
		param_text(15) ='Direct beam counting'
		
		param_text(16) ='Output filename (no extention)'
		
		param_text(17) ='Calculated number of points in q'
		param_text(18) ='Calculated total duration monitor or time'
		
		
;               defaults
                		
		param(0)='5.0'
		param(1)='0.008'
		param(2)='0.2'
		param(3)='2.2'
		param(4)='0.1'
		param(5)='2.0'
		param(6)='1'
		param(7)='0'
		param(8)='3'
		param(9)='1'
		param(10)='1'
		param(11)='20'
		param(12)='20000'
		param(13)='2'
		param(14)='1'
		param(15)='60'
		param(16)='xxx'
		param(17)='-------'
		param(18)='-------'
		
		
		
		
                D17S_BASE_4=Widget_Base(UNAME='D17S_BASE_4',TITLE="Enter Values" $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
		D17S_BASE_0=Widget_Base(D17S_BASE_4,UNAME='D17S_BASE_0' $
			,SPACE=3,XPAD=3,YPAD=3,/ROW)
		D17S_BASE_1=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_1' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)




		D17S_BASE_2=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_2' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)
		D17S_BASE_3=Widget_Base(D17S_BASE_0,UNAME='D17S_BASE_3' $
			,SPACE=3,XPAD=3,YPAD=3,/COLUMN)

                gbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='gbutton' $
			, value='Do it',uvalue='do')
		fbutton = WIDGET_BUTTON(D17S_BASE_0,UNAME='fbutton' $
			, value='Quit',uvalue='quit')
			
		
				
			
		FOR i=0,nparams-1 DO BEGIN 
  			name= 'D17S_LABEL_'+STRTRIM(STRING(i+1),2) 
  			dummy = Widget_Label(D17S_BASE_2, UNAME=name,XOFFSET=3   $ 
     	 		,YOFFSET=3, SCR_YSIZE=33,/ALIGN_LEFT ,VALUE=param_text(i) $
			,FONT=ft_smaller)
  	  	ENDFOR
		

		
		FOR i=0,nparams-1 DO BEGIN 
  			name='D17S_VALUE_'+STRTRIM(STRING(i+1),2) 
  			 whatwid(i)= Widget_Text(D17S_BASE_3, UNAME=name ,FRAME=1  $ 
     			,XOFFSET=3 ,YOFFSET=3 ,SCR_XSIZE=100 ,SCR_YSIZE=29 $
			,/EDITABLE ,VALUE=STRTRIM(STRING(param(i)),2) $
			,FONT=ft_smaller) 
  	  	ENDFOR


		Widget_Control,/REALIZE,D17S_BASE_3
		loadct, 5
		XMANAGER, 'startmono',D17S_BASE_0,/JUST_REG

end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION sumbank, w_in, dQ=dQ, qb
;
; For IN4, IN5 and IN6 data.
;
;ARGUMENTS
; dQ:	Q-spacing with which to sum detectors. If dQ is not specified, nothing
;	is done for IN5 data. For IN6, adds data in centre, upper and lower
;	detector banks by default.
;
;DIMENSIONS
; w_in=w_out(nchannels,nspectra)
;
;COMMAND SYNTAX
; w2=sumbank(w1,dQ=<dQ>)
;
;							KHA,JRS 8/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	COMMON c_lamp_access, inst

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start sumbank:'

	take_datp, datp
	IF(N_ELEMENTS(qb) GT 0) THEN dQ=qb

;-------------------------------------------------------------------------------
;Set up input workspace

	par=datp.p

	y_in=datp.y
	e_in=datp.e

	sw=size(w_in)
	nchannels=sw(1)
	IF (sw(0) EQ 1) THEN nspectra=1     ELSE $
	IF (sw(0) EQ 2) THEN nspectra=sw(2) ELSE return,w_in
	npts=nchannels

	se=size(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1) OR se(2) NE sw(2)) THEN e_in=SQRT(w_in)

	IF (N_ELEMENTS(dQ) EQ 0) THEN dQ=0
	lambda=par(21)

	IF (iprint GT 0) THEN PRINT,'npts=',npts,' nspectra=',nspectra
	IF (iprint GT 0) THEN PRINT,'End of input setup section'

;-------------------------------------------------------------------------------
;add IN6 detectors together

	y_out=y_in
	w_out=w_in	& e_out=e_in

	IF (inst EQ 'IN6') THEN BEGIN
		angle=0.
		iangle=-1
		FOR ispec=0,nspectra-1 DO BEGIN
			IF (y_in(ispec) NE angle) THEN BEGIN
				iangle=iangle+1
				angle=y_in(ispec)
				y_out(iangle)=angle
				w_out(*,iangle)=w_in(*,ispec)
				e_out(*,iangle)=e_in(*,ispec)^2
			ENDIF ELSE BEGIN
				w_out(*,iangle)=w_out(*,iangle)+w_in(*,ispec)
				e_out(*,iangle)=e_out(*,iangle)+e_in(*,ispec)^2
			ENDELSE
		ENDFOR
		w_out=w_out(*,0:iangle)
		e_out=SQRT(e_out(*,0:iangle))
		y_out=y_out(0:iangle)
		nspectra=iangle+1
		IF (iprint GT 0) THEN PRINT,'IN6: nspectra=',nspectra
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of IN6 detector-adding section'

;-------------------------------------------------------------------------------
;add detectors together with dQ spacing

	k=2.*!pi/lambda
	Qarr=2.*k*SIN(y_out*!pi/360.)	; convert scattering angle to Q

	Qmin=-1.
	iout=-1
	FOR ispec=0,nspectra-1 DO BEGIN
		Q=Qarr(ispec)
		IF ((Q-Qmin) GT dQ) THEN BEGIN
			IF (ispec NE 0) THEN y_out(iout)=y_out(iout)/nout
			Qmin=Q	& iout=iout+1	& nout=1
			y_out(iout)=y_out(ispec)
			w_out(*,iout)=w_out(*,ispec)
			e_out(*,iout)=e_out(*,ispec)^2
		ENDIF ELSE BEGIN
			nout=nout+1
			y_out(iout)=y_out(iout)+y_out(ispec)
			w_out(*,iout)=w_out(*,iout)+w_out(*,ispec)
			e_out(*,iout)=e_out(*,iout)+e_out(*,ispec)^2
		ENDELSE
	ENDFOR

	y_out(iout)=y_out(iout)/nout

	y_out=y_out(0:iout)
	w_out=w_out(*,0:iout)
	e_out=SQRT(e_out(*,0:iout))
	nspectra=iout+1

	IF (iprint GT 0) THEN PRINT,'End of other detector-adding section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	IF (dQ EQ 0.) THEN dQ='0' ELSE BEGIN
		s=STRTRIM(STRING(dQ),2) & i=RSTRPOS(s,'.') & dQ=STRMID(s,0,i+3)
	ENDELSE
	Qstring='dQ='+dQ+'A-1'
	IF (inst EQ 'IN6') THEN Qstring='added centre, upper and lower detector bank data, '+Qstring
	PRINT,'sumbank: '+Qstring

	datp.other_tit=datp.other_tit+' -sb('+dQ+')

	give_datp, datp

finished:
	RETURN, w_out

	END
Function sumd20,wn1,wn2

common C_LAMP_INFO 

IF N_ELEMENTS(wn2) GT 1 THEN BEGIN
  n2=three
ENDIF
IF N_ELEMENTS(wn1) GT 1 THEN BEGIN
  n1=two
ENDIF
IF N_ELEMENTS(wn1) EQ 1 THEN n1=wn1
IF N_ELEMENTS(wn2) EQ 1 THEN n2=wn2
IF N_ELEMENTS(n1) EQ 1 THEN BEGIN
IF N_ELEMENTS(n2) EQ 1 THEN BEGIN
take_w,w1,w=n1
take_w,w2,w=n2
IF N_ELEMENTS(w1(0,*)) LE 1 THEN BEGIN
 IF N_ELEMENTS(w2(0,*)) LE 1 THEN BEGIN
  take_datp,d1,w=n1
  take_datp,d2,w=n2
  e1=d1.e
  e2=d2.e
  IF d1.n(0) NE d2.n(0) THEN BEGIN
    norm=(d1.n(0) + d2.n(0))/2.
    PRINT, 'Normalisation to ', norm, ' (before : ',d1.n(0), d2.n(0),')'
    w1=w1/d1.n(0)*norm
    e1=e1/d1.n(0)*norm
    w2=w2/d2.n(0)*norm
    e2=e2/d2.n(0)*norm
  ENDIF ELSE norm=d1.n(0)
  dx1=FLOOR(d1.x*10)/10.
  dx2=FLOOR(d2.x*10)/10.
  delta=((d1.x(0)+d2.x(0))-(dx1(0)+dx2(0)))/2
  x1=delta+dx1
  x2=delta+dx2
  i1=INTERPOL(w1,d1.x,x1)
  e1=INTERPOL(e1,d1.x,x1)
  i2=INTERPOL(w2,d2.x,x2)
  e2=INTERPOL(e2,d2.x,x2)
  dx1=ROUND(10.*dx1)
  dx2=ROUND(10.*dx2)
  start=min(dx1)<min(dx2)
  stop =max(dx1)>max(dx2)
  array=[dx1,dx2]
  array=array(SORT(array))
  array=array(UNIQ(array))
  x=FLOAT(array/10.)+delta
  points=N_ELEMENTS(array)
  w=FLTARR(points)
  e=FLTARR(points)
  For i= 0,points-1 DO BEGIN
    f1=where(dx1 EQ array(i),c1)
    f2=where(dx2 EQ array(i),c2)
    f1=f1(0)
    f2=f2(0)
    IF c1 GT 0 THEN BEGIN
      IF c2 GT 0 THEN BEGIN
        w(i)=(i1(f1)+i2(f2))/2.
        e(i)=w(i)/SQRT(i1(f1)^2/e1(f1)^2+i2(f2)^2/e2(f2)^2)
      ENDIF ELSE BEGIN
        w(i)=i1(f1)
        e(i)=e1(f1)
      ENDELSE
    ENDIF ELSE BEGIN
      w(i)=i2(f2)
      e(i)=e2(f2)
    ENDELSE  
  ENDFOR
  d=d1
  mod_datp,d,'x',x
  mod_datp,d,'e',e
  d.n(0)=norm
  d.w_tit=d.w_tit+' - Average W'+STRCOMPRESS(n1,/RE)+'+W'+STRCOMPRESS(n2,/RE)
  give_datp,d
  RETURN,w
 ENDIF ELSE PRINT,'2nd WorkSpace should not be pluri-dimensional'
ENDIF ELSE PRINT,'1st WorkSpace should not be pluri-dimensional'
ENDIF ELSE PRINT,'2nd WorkSpace Number missing'
ENDIF ELSE PRINT,'WorkSpace Numbers missing'
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO summary, numor1, numor2

; Assume that data format is new (i.e. same as September 1996)

;							KHA,JRS 25/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

@read_d7.cbk

	compressed=0
;	inpath='/usr/illdata/973/d7/'
	inpath='/hosts/d7/users/data/'
;	inpath='/usr/illdata/data-1/d7/'


	outpath='~lambda/SUMMARY/'

	IF (N_ELEMENTS(numor2) EQ 0) THEN numor2=numor1

	scan=0	& samerun=0
	olduser=''	& old_title=''	& oldtime1=-10.	& old_run_time=0
	old_pol_mode=''	& old_time_mode=''	& old_sub_title=''
	force=0

	num1=LONG(numor1)
        num2=LONG(numor2)

	FOR numor=num1, num2 DO BEGIN
		IF (numor GE 10000) THEN file='0'+STRTRIM(STRING(numor),2) $
			ELSE file='00'+STRTRIM(STRING(numor),2)
		IF (compressed EQ 1) THEN BEGIN
			command='cp '+inpath+file+'.Z '+outpath
			SPAWN, command
			command='uncompress '+outpath+file+'.Z'
			SPAWN, command
			file=outpath+file
		ENDIF ELSE file=inpath+file
		read_d7sum, file
;		print, run_time
		IF (compressed EQ 1) THEN BEGIN
			command='rm -f '+file
			SPAWN, command
		ENDIF
		run_time=LONG(run_time/60.)	; get it in minutes
		IF (scan EQ 1 AND ((scan_type NE '         ' AND npmes EQ 1) OR $
			(scan_type EQ '         '))) THEN BEGIN
			IF (numor-oldnumor GE 2) THEN PRINT, $
				FORMAT='("     ... ",A," scan up to #",I5)', STRTRIM(oldscan_type,2), numor-1
			scan=0
			samerun=0
		ENDIF ELSE IF (scan_type EQ '         ') THEN BEGIN
			IF (run_time EQ old_run_time AND pol_mode EQ old_pol_mode AND $
				time_mode EQ old_time_mode AND sub_title EQ old_sub_title AND $
				user EQ olduser AND main_title EQ old_title) THEN BEGIN
				samerun=1
			ENDIF ELSE IF (samerun EQ 1) THEN BEGIN
				IF (numor-oldnumor GE 2) THEN PRINT, $
					FORMAT='("     ... identical runs up to #",I5)', numor-1
				samerun=0
			ENDIF
		ENDIF
		IF (numor EQ numor1) THEN BEGIN
			PRINT
			PRINT,'****************************************************************'
			PRINT, FORMAT='("Numors",I6," to",I6)', numor1, numor2
			PRINT, 'Path: ',inpath
			PRINT,'----------------------------------------------------------------'
			PRINT
			PRINT, FORMAT='("User: ",A8,"   Local Contact: ",A8)', user, local_contact
			PRINT, FORMAT='("Experiment Title: ",A)', main_title
			PRINT
			PRINT, 'Numor  Start Time      Minutes Pol TOF   Title'
		ENDIF ELSE IF (user NE olduser) OR (main_title NE old_title) THEN BEGIN
			PRINT,'----------------------------------------------------------------'
			PRINT
			PRINT, FORMAT='("User: ",A8,"   Local Contact: ",A8)', user, local_contact
			PRINT, FORMAT='("Experiment Title: ",A)', main_title
			PRINT
			PRINT, 'Numor  Start Time      Minutes Pol TOF   Title'
		ENDIF
		IF (scan EQ 0 AND samerun EQ 0) THEN BEGIN
			PRINT, FORMAT='(I5,1X,A18,I5,A5,A6,1X,A)', $
				numor, start_time, run_time, pol_mode, Time_mode, sub_title
			oldnumor=numor
			oldscan_type=scan_type
		ENDIF ELSE IF (numor EQ numor2) THEN BEGIN
			IF (scan_type NE '         ' AND npmes NE 1) THEN $
				PRINT, FORMAT='("     ... ",A," scan up to #",I5)', $
					STRTRIM(scan_type,2), numor
			IF (scan_type EQ '         ' AND $
				run_time EQ old_run_time AND pol_mode EQ old_pol_mode AND $
				time_mode EQ old_time_mode AND sub_title EQ old_sub_title AND $
				user EQ olduser AND main_title EQ old_title) THEN PRINT, $
				FORMAT='("     ... identical runs up to #",I5)', numor
		ENDIF
		IF (scan_type NE '         ') THEN scan=1
		olduser=user
		old_title=main_title
		old_run_time=run_time
		old_pol_mode=pol_mode
		old_time_mode=time_mode
		old_sub_title=sub_title
	ENDFOR

	RETURN
	END
Function sumscan,wn1
;+
; Merge twotheta scan of two steps
; W1 = sumscan (2)
; Function
; Parameters
;   Number of workspace to be merged
; Output
;   Workspace containing merged diagram
;-
common C_LAMP_INFO 

;help,n1
IF N_ELEMENTS(wn1) GT 1 THEN BEGIN
  n1=two
ENDIF
IF N_ELEMENTS(wn1) EQ 1 THEN n1=wn1
;help,n1
IF N_ELEMENTS(n1) EQ 1 THEN BEGIN
 take_w,w1,w=n1
; help,w1
 print,N_ELEMENTS(w1(0,*))
 IF N_ELEMENTS(w1(0,*)) EQ 2 THEN BEGIN
  take_datp,d1,w=n1
  e1=d1.e(*,0)
  e2=d1.e(*,1)
  w2=w1(*,1)
  w1=w1(*,0)
  IF d1.n(0,0,0) NE d1.n(0,0,1) THEN BEGIN
    norm=(d1.n(0,0,0) + d1.n(0,0,1))/2.
    PRINT, 'Normalisation to ', norm, ' (before : ',d1.n(0,0,0), d1.n(0,0,1),')'
    w1=w1/d1.n(0,0,0)*norm
    e1=e1/d1.n(0,0,0)*norm
    w2=w2/d1.n(0,0,1)*norm
    e2=e2/d1.n(0,0,1)*norm
    d1.n(0,*,0)=d1.n(0,*,0)*norm/d1(0,0,0)
    d1.n(0,*,1)=d1.n(0,*,1)*norm/d1(0,0,1)
  ENDIF ELSE norm=d1.n(0)
  dx1=ROUND(d1.x(*,0)*10)/10.
  dx2=ROUND(d1.x(*,1<(N_ELEMENTS(d1.x(0,*))-1))*10)/10.
;  print,d1.x(0,0),d1.x(0,1)
;  print,dx1(0),dx2(0)
  delta=((d1.x(0,0)+d1.x(0,1<(N_ELEMENTS(d1.x(0,*))-1)))-(dx1(0)+dx2(0)))/2
; help,delta
  x1=delta+dx1
  x2=delta+dx2
;  print,x1(0),x2(0)
; help,d1.x(0,*)
; print,N_ELEMENTS(d1.x(0,*))-1
; print,1<(N_ELEMENTS(d1.x(0,*))-1)
; help,w1,d1.x(*,0),x1,e1,w2,d1.x(*,1<(N_ELEMENTS(d1.x(0,*))-1)),x2,e2
  i1=INTERPOL(w1,d1.x(*,0),x1)
  e1=INTERPOL(e1,d1.x(*,0),x1)
;plot,x1,i1
  i2=INTERPOL(w2,d1.x(*,1<(N_ELEMENTS(d1.x(0,*))-1)),x2)
  e2=INTERPOL(e2,d1.x(*,1<(N_ELEMENTS(d1.x(0,*))-1)),x2)
;oplot,x2,i2
  dx1=ROUND(10.*dx1)
  dx2=ROUND(10.*dx2)
  start=min(dx1)<min(dx2)
  stop =max(dx1)>max(dx2)
  array=[dx1,dx2]
  array=array(SORT(array))
  array=array(UNIQ(array))
  x=FLOAT(array/10.)+delta
  points=N_ELEMENTS(array)
  w=FLTARR(points)
  e=FLTARR(points)
  For i= 0,points-1 DO BEGIN
    f1=where(dx1 EQ array(i),c1)
    f2=where(dx2 EQ array(i),c2)
    f1=f1(0)
    f2=f2(0)
    IF c1 GT 0 THEN BEGIN
      IF c2 GT 0 THEN BEGIN
        w(i)=(i1(f1)+i2(f2))/2.
        e(i)=w(i)/SQRT(i1(f1)^2/e1(f1)^2+i2(f2)^2/e2(f2)^2)
      ;  IF (i1(f1)-3*e1(f1) GE i2(f2)+3*e2(f2)) THEN BEGIN
      ;    print,'Problem Cells : ',ROUND((x1(f1)-x1(0))*10),'>',ROUND((x2(f2)-x2(0))*10)
      ;  ENDIF ELSE IF (i1(f1)+3*e1(f1) LE i2(f2)-3*e2(f2)) THEN BEGIN
      ;    print,'Problem Cells : ',ROUND((x1(f1)-x1(0))*10),'<',ROUND((x2(f2)-x2(0))*10)
      ;  ENDIF
      ENDIF ELSE BEGIN
        w(i)=i1(f1)
        e(i)=e1(f1)
      ENDELSE
    ENDIF ELSE BEGIN
      w(i)=i2(f2)
      e(i)=e2(f2)
    ENDELSE  
  ENDFOR
  d=d1
  mod_datp,d,'x',x
  mod_datp,d,'e',e
  mod_datp,n,'n',[norm,(d1.n(0,1,0)+d1.n(0,1,1))/2.,(d1.n(0,2,0)+d1.n(0,2,1))/2.]
  d.w_tit=d.w_tit+' - sum of 2 pattern'
  give_datp,d
  RETURN,w
 ENDIF ELSE PRINT,'WorkSpace should be a 2theta scan of 2 steps'
ENDIF ELSE PRINT,'WorkSpace Numbers missing'
END
function sys_dep, a,b,c  & return,1 & end
function rdrun, a,b,c,datp=datp  & return,1 & end

pro p_did_calod,p1,p2,p3 & end
pro p_lambda, a,b,c & end
pro see, a,b,c & end
pro give_w, a,b,c & end
pro give_datp, a,b,c & end
pro take_datp, a,b,c & end
pro take_w, a,b,c & end
pro mod_datp, a,b,c & end
pro xicute, str & end
pro calibration,a,b,c & end
pro rdset,a,b,c & end
pro BUILD_MACFILELISTFROMARRAY,a,b,c & end
pro BUILD_TOOLSERVERFILELISTFROMSTRING,a,b,c & end
pro DYNLABEL_CALL,a,b,c & end
pro LAMP_RESOURCE,a,b,c & end
pro PUT_LOGO,a,b,c & end
pro RESIZEBUTTON_CALL,a,b,c & end
pro SET_TOLERANCE,a,b,c & end
pro P_MUS,a,b,c & end
pro DO_APPLE_SCRIPT, a,b,c & end
	pro surf4, plx,ply,dm,vsz,ni,ah,nc,lev,flg,bg,tare,erey,sbox
;...	---------- -----
;...
	bh=0. & dt =0. & ff=0. & hd=0. & hk=0. & kd=0. & ke=0. & kp=0.
	ks=0. & ni1=0. & np=0. & ns=0. & pv=0.
;	implicit  integer*4 (a-z)
;	tare=intarr(plx/(ni+1) , dm , vsz)
;	erey=intarr(plx	    , ply)
;	sbox=lonarr(  4	    ,  3 )
	xare=intarr(plx  	,  3 )
	z   =0B

	catch,stat & if stat ne 0 then begin print,!err_string & return & endif

;...Prepare the loop
;...------- --- ----
	dm1=dm-1
	dlx=plx /(ni+1)
	bh =float( ply)    /dm   * ah  /90.
        ho =fix  ( ply-1 -  dm1  * bh)
	ho1= ho
	if  (ho gt ply/2) then ho1=3*ply/4 - ho/2
	hd = float(ho1)  /  nc
;	dpl= ply1 - (ply/4) * (float(90-ah)/90)
	ff = float(ho)   /  dm1
	fi = fix  (ff)
	ic =nc
	ic1=ic-1
;
	iv =3
	nd =nc/iv
	dt =float(nc-nd)/nc
;
	nd =nd-1
	nv =nd/2 +1
	nw =nv*5/4
	nw1=nv*3/2
	t  =nv*4/5
	t1 =t+1
	if (hd gt 0) then begin
			  np=2./(3.*hd)
			  ns=1./(3.*hd)
		     endif else begin
			  hd=0.001
			  np=0.
			  ns=0.
		     endelse
	ply1= ply-1
	dlx1= dlx-1
	ni1 = ni+1.
	ho2 = ho/2
	ho3 = ho/3
;...	First line
;...	----- ----
	if (bg ne 0) then begin
	    di= 0
	    p = ply1
	    od= 1
	    dz= 0
	    if ((flg eq 6) or (bg eq 1)) then od=0
	    if  (flg eq 6) then dz= vsz-1
	    FOR dx=0,dlx1 do begin
		dj=dm1
		v =0
		while ((dj gt 0) and (v eq 0)) do begin
		   v =tare(dx,dj,dz)
		   dj=dj-1
		endwhile
		if (dj eq 0) then begin
				dv=ply1
				v =1
			     endif else begin
				if (lev lt 0)	then     $
						 dj=dj+1 $
						else     $
						 FOR cg=0,vsz-1 do $
						 tare(dx,dj+1,cg)= 0
				v =tare (dx, dj, 0)
				kd=(dm1- dj)
				l =fix(ply1-(kd* bh))
				if (od eq 1) then begin
				    hk=(1. - kd/(kd+dm1)) * hd
				    dv= l  -(v * hk)
				endif else $
				    dv= l  -(v * hd)
				v =nd
				if (p eq ply1) then v=1
			     endelse
		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    d =fix(dv -(cg*pv))>0
		    xare(di,2) = d
		    erey(di,d) = v
		    di=di+1
		ENDFOR
		p=d
	    ENDFOR
	endif else begin
;		FOR di=0,plx-1 do begin
;		    xare(di,2)=ply1
;		    erey(di,ply1)=1
;	        ENDFOR
		xare(*,2)=ply1
		erey(*,ply1)=1
	endelse
	kd=0.
	od=0
	ke=1.
	vsz1= vsz-1
;...
;...	Surfaces.
;...	--------
	if (flg eq 6) then begin
	cs =nd*2/vsz
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1 - (kd*bh))>0
	 FOR dz= 0 , vsz1 do begin
	    v = tare(0,  dj ,dz)
	    p = fix(l-(v*hd))>0
	    di= 0
	    z = (dz eq vsz1)
	    cz= nd + cs*(dz+1)
	    FOR dx=0,dlx1 do begin
		v = tare(dx,dj,dz)
		dv= l - (v *hd)
		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    dd=fix(dv -(cg*pv))>0
		    d =dd
		    if (z) then $
			    if  (d gt 0) then d=d-1
		    if (xare(di,2) gt d) then begin
		         if ((erey(di,d) lt nw) and (d lt l)) then begin
				if (z)   then $
					 erey(di,d)=nw $
				else $
					 erey(di,d)=nw1
				e=d +1
				while (e le l) do begin
				  if     (erey(di,e) lt nw) then begin
				   if    ((e lt p)  and z)  then $
					  erey(di,e )=nw $
					else $
					  erey(di,e )=cz
				   e=e+1
				  endif else $
				   e=l+1
				endwhile
			 endif
		    endif
		    if ((d-1 gt p) and (p lt xare(di,2))) then begin
		    e=p+1
		    while ((erey(di,e) lt nw) and (e lt d)) do begin
			       erey(di,e )=nw
			       e=e+1
		    endwhile
		    endif
		    p =dd
		    di=di+1
		ENDFOR
	    ENDFOR
	 ENDFOR
	 kd=kd + 1.
	ENDFOR
	endif
;...
;...	4D Surface.
;...	----------
	if (flg eq 8) then begin
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1 - (kd*bh))>0
	    if (bg ne 1) then ke= 1. -kd/(kd+dm1)
	    hk= hd  *ke
	    kp= np  /ke
	    ks= ns  /ke
	    v = tare(0,  dj, 0)
	    p = fix(l-(v*hk))>0
	    di= 0
	    hi= fix(ho-(dj*ff))
	    hj= hi+ fi
	    FOR dx=0,dlx1 do begin
		va= v
		v = tare(dx,dj,0)
		vh= v/iv -2
		dv= l - (v *hk)
		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    d =fix(dv -(cg*pv))>0
		    od=-od+4
		    if (xare(di,2) gt d)  then begin
			if ((erey(di,d) lt nd) and (d lt l)) then begin
			        erey(di,d)= nd
				e=d +1
				t1=tare(dx,dj,1)*dt
				t =0
				while (e le l) do begin
				  if     (erey(di,e) lt nd) then begin
				   if    (e lt p)   then $
					  erey(di,e )=nd $
					else begin
					  v=t1-t + nd-od
					  if (v lt nd) then v=nd
					  erey(di,e) = v
					endelse
				   t=t+1
				   e=e+1
				  endif else $
				   e=l+1
				endwhile
			endif
		    endif else begin
			if ((v gt 0) and (va gt 0) and $
					 (xare(di,2) lt d)) then begin
			    t1=tare(dx,dj,1)/iv
			    t =0
			    e =d
			    while (erey(di,e) eq 0) do begin
				      v=t1+t + od
				      if (v ge nd) then v=nd-1
				      erey(di,e)=  v
				      t=t+1
				      e=e-1
			    endwhile
                        endif
		    endelse
		    if ((d-1 gt p) and (p lt xare(di,2))) then begin
		      e= p+1
		      while  ((erey(di,e) lt nd) and (e lt d)) do begin
				  erey(di,e ) = nd
				  e=e+1
		      endwhile
		    endif
		    if (bg eq 2) then begin
                    FOR oz=hi,hj  do  begin
		        if (erey(di,oz) lt vh) then $
			if (xare(di,2)  gt oz) then erey(di,oz)=vh
		    ENDFOR
		    endif
		    p =d
		    di=di+1
		ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif

	return
	end








	pro surf,  plx,ply,dm,vsz,ni,ah,nc,lev,flg,bg,tare,erey,sbox
;...	---------- -----
;...
	bh=0. & dt =0. & ff=0. & hd=0. & hk=0. & kd=0. & ke=0. & kp=0.
	ks=0. & ni1=0. & np=0. & ns=0. & pv=0.
;	implicite integer*4 (a-z)
;	tare=intarr(plx/(ni+1) , dm )
;	erey=intarr(plx	    , ply)
;	sbox=lonarr(  4	    ,  3 )
	xare=intarr(plx	    ,  3 )
	z=0B & z2=0B

	catch,stat & if stat ne 0 then begin print,!err_string & return & endif

;...Prepare the loop
;...------- --- ----
	dm1=dm-1
	dlx=plx /(ni+1)
	bh =float( ply)  /  dm   * ah  /90.
	ho =fix  ( ply-1 -  dm1  * bh)
	ho1= ho
	if  (ho gt ply/2) then ho1=3*ply/4 - ho/2
	hd = float(ho1)  /  nc
;	dpl= ply1 - (ply/4) * (float(90-ah)/90)
;	ho = ho- (ply1-dpl)
	ff = float(ho)   /  dm1
	fi = fix  (ff)
	ic =nc
	ic1=ic-1

	iv =3
	if (flg eq 7) then iv=5
	nd =nc/iv
	dt =float(nc-nd)/nc

	nd =nd -1
	nv =nd/2 +1
	nw =nv*5/4
	nw1=nv*3/2
	t  =nv*4/5
	t1 =t+1
	if (hd gt 0) then begin
			  np=2./(3.*hd)
			  ns=1./(3.*hd)
	endif else begin
			  hd=0.001
			  np=0.
			  ns=0.
	endelse
	ply1= ply-1
	dlx1= dlx-1
	ni1 = ni+1.
	ho2 = ho/2
	ho3 = ho/3
	if (vsz gt 1)   then begin
	    surf4,plx,ply,dm,vsz,ni,ah,nc,lev,flg,bg,tare,erey,sbox
	endif else begin

;...First line
;...----- ----
	if ((flg ne 4) and (flg ne 10) and (flg ne 11)) then begin
	 if (bg  ne 0) then begin
	    di= 0
	    p = ply1
	    od= 1
	    if ((flg eq 0) or (flg eq 3) or (bg eq 1))  then od=0
		FOR  dx=0,dlx1 do begin
		dj=dm1
		v =0
		while ((dj gt 0) and (v eq 0)) do begin
		   v =tare(dx , dj)
		   dj=dj-1
		endwhile
		if (dj eq 0) then begin
				dv=ply1
				v =1
		endif else begin
				if (lev lt 0)	then begin
						dj = dj+2
		    				if  (dj gt dm1) then dj=dm1 $
						else        tare(dx,dj+1)=0
				endif
				v =tare (dx, dj)
				kd=(dm1- dj)
				l =ply1-(kd* bh)
				if (od eq 1) then begin
				    hk=(1. - kd/(kd+dm1)) * hd
				    dv= l  -(v * hk)
				endif else $
				    dv= l  -(v * hd)
				v =nd
				if (p eq ply1) then v=1
		endelse
		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    d =fix(dv -(cg*pv))>0
		    xare(di,2) = d
		    erey(di,d) = v
		    di=di+1
		ENDFOR
		p=d
	    ENDFOR
	 endif else begin
		xare(*,2)   =ply1
		erey(*,ply1)=1
		;FOR di=0,plx-1 do begin
		;    xare(di,2)=ply1
		;    erey(di,ply1)=1
		;ENDFOR
	 endelse
	endif
	kd=0.
	od=0
	ke=1.
;...
;...	Filled vectors loop.
;...	------ ------- ----
	if (flg eq 1) then begin
	l=ply1
	FOR dj= dm1 ,0,-1 do begin
	    lp= l
	    l = fix(ply1 -  (kd*bh))>0
	    ld= lp-l
	    if (bg ne 1) then ke= 1. -kd/(kd+dm1)
	    hk= hd  *ke
	    kp= np  /ke
	    ks= ns  /ke
	    v = tare(0,  dj)
	    p = fix(l-(v*hk))>0
	    di= 0
	    hi= ho-fix(dj*ff)
	    hj= hi+ fi
	    FOR dx=0,dlx1 do begin
		 va= v
		 v = tare(dx,dj)
		 vh= v/iv -2
		 dv= l - (v *hk)
		 pv=(dv-p) /ni1
		 FOR cg=ni,0,-1 do begin
		    d =fix(dv -(cg*pv))>0
		    od=-od+4
		    if (xare(di,2) gt d)  then begin
			if ((erey(di,d) lt nd) and (d lt l)) then begin
			     erey(di,d)  = nd
			     e=d +1
			     while (e lt lp) do begin
				  if     (erey(di,e) lt nd) then begin
				   if    (e lt p)  then $
					   erey(di,e )=nd   $
				   else begin
					  if (e-d  lt  ld) then   $
					   erey(di,e )=(l-d)*kp +nd  $
					  else $
					   erey(di,e )=(l-e)*kp +nd-od
				   endelse
				   e=e +1
				  endif else $
				   e=lp+1
			     endwhile
			endif
		    endif else begin
			if ((v gt 0) and (va gt 0) and $
					 (xare(di,2) lt d)) then begin
			    e =d
			    while (erey(di,e) eq 0) do begin
				      erey(di,e)=  (l-e)*ks +1 + od
				      e=e-1
			    endwhile
               endif
		    endelse
		    if ((d-1 gt p) and (p lt xare(di,2))) then begin
		      e= p+1
		      while  ((erey(di,e) lt nd) and (e lt d)) do begin
				  erey(di,e ) = nd
				  e=e+1
		      endwhile
		    endif
		    if (bg eq 2) then begin
                  FOR oz=hi,hj  do begin
		            if (erey(di,oz) lt vh) then $
			       if (xare(di,2)  gt oz) then erey(di,oz)=vh
		        ENDFOR
		    endif
		    p =d
		    di=di+1
		 ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif
;...
;...	Filled Loop.
;...	------ ----
	if (flg eq 5) then begin
	l=ply1
	FOR dj= dm1 ,0,-1 do begin
	    ld= l
	    l = fix(ply1 -  (kd*bh))>0
	    ld= ld-l
	    if (bg ne 1) then ke= 1. -kd/(kd+dm1)
	    hk= hd  *ke
	    kp= np  /ke
	    ks= ns  /ke
	    v = tare(0,  dj)
	    p = fix(l-(v*hk))>0
	    di= 0
	    hi= ho-fix(dj*ff)
	    hj= hi+ fi
	    FOR dx=0,dlx1 do begin
		va= v
		v = tare(dx,dj)
		vh= v/iv -2
		dv= l - (v *hk)
		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    d =fix(dv -(cg*pv))>0
		    od=-od+4
		    if (xare(di,2) gt d)  then begin
			if ((erey(di,d) lt nd) and (d lt l)) then begin
				e=d
				while (e le l) do begin
				  if     (erey(di,e) lt nd)  then begin
					  if (e-d  lt  ld) then $
 					    erey(di,e)=(l-d)  *kp+nd $
 					  else $
					    erey(di,e)=(l-e-1)*kp+nd-od
 					  e=e+1
				  endif else $
					  e=l+1
				endwhile
			endif
		    endif else begin
			   if ((v gt 0) and (va gt 0) and $
					 (xare(di,2) lt d)) then begin
			          e =d
			          while (erey(di,e) eq 0) do begin
				       erey(di,e)=  (l-e)*ks +1 + od
				       e=e-1
			          endwhile
               endif
		    endelse
		    if (bg eq 2) then begin
                    FOR oz=hi,hj do begin
		             if (erey(di,oz) lt vh) then $
			         if (xare(di, 2) gt oz) then erey(di,oz)=vh
		            ENDFOR
		    endif
		    p =d
		    di=di+1
		ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif
;...
;...	Shaded Loop.
;...	------ ----
	if (flg eq 7) then begin
;	FOR dx=0,plx-1  do begin
;	    xare(dx,0)=0
;	    xare(dx,1)=nd
;	ENDFOR
    xare(*,0)=0
    xare(*,1)=nd
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1 -  (kd*bh))>0
	    if (bg ne 1) then ke= 1. -kd/(kd+dm1)
	    hk= hd  *ke
	    kp= np  /ke
	    v = tare(0,  dj)
	    p = fix(l-(v*hk))>0
	    di= 0
	    hi= ho-fix(dj*ff)
	    hj= hi+ fi
	    FOR dx=0,dlx1 do begin
		va= v
		v = tare(dx,dj)
		vh= v/iv -2
		dv= l - (v *hk)
		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    d =fix(dv -(cg*pv))>0
;...
		    ks=xare(di,0)-d-1
		    xare(di,0)=d
		    v1=xare(di,1)
		    if (ks le 0.)  then ks=0.
		    v2=ic1-(ks*ks/hk)
		    if (v2 lt nd)  then v2=nd
		    xare(di,1)=v2
		    if (ks gt 0.)  then ks=(v1-v2)/ks
;...
		    if (xare(di,2) gt d)  then begin
			if ((erey(di,d) lt nd) and (d lt l)) then begin
				e =d
				v1=0
				while (e le l) do begin
				  if     (erey(di,e) lt nd) then begin
					  erey(di,e)=v2 + (v1*ks)
					  e =e +1
					  v1=v1+1
				  endif else $
					  e=l+1
				endwhile
			endif
		    endif else begin
			if ((v gt 0) and (va gt 0) and $
					 (xare(di,2) lt d)) then begin
			     e =d
			     v1=0
			     while (erey(di,e) eq 0) do begin
				       erey(di,e)=v1*ks
				       e =e -1
				       v1=v1+1
			     endwhile
                        endif
		    endelse
		    if (bg eq 2) then begin
                    FOR oz=hi,hj do begin
		        if (erey(di,oz) lt vh) then $
			if (xare(di,2)  gt oz) then erey(di,oz)=vh
		    ENDFOR
		    endif
		    p =d
		    di=di+1
		ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif
;...
;...	Simple Loop
;...	------ ----
	if (flg eq 0) then begin
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1  -(kd *bh))>0
	    v = tare(0 ,dj)
	    p = fix(l - (v *hd))>0
	    di= 0
	    FOR dx=0,dlx1 do begin
		v =tare (dx,dj)
		dv= l - (v *hd)
    		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    d =fix(dv - (cg*pv))>0
		    if (xare(di,2) gt d)  then begin
			if ((erey(di,d) lt nw) and (d lt l)) then begin
				erey(di,d)=nw
				e=d +1
				while (e le l) do begin
				  if   (erey(di,e) lt nw) then begin
				   if  (e lt p) then $
						erey(di,e)=nw $
						else $
						erey(di,e)=(l-e)*np+nd
				   e=e+1
				  endif else $
				   e=l+1
				endwhile
			endif
		    endif
		    if ((d-1 gt p) and (p lt xare(di,2))) then begin
		      e= p+1
		      while  ((erey(di,e) lt nw) and (e lt d)) do begin
				  erey(di,e ) = nw
				  e=e+1
		      endwhile
		    endif
		    p =d
		    di=di+1
		ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif
;...
;...	Vectors loop
;...	------- ----
	if (flg eq 3) then begin
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1  -(kd *bh))>0
	    v = tare(0 ,dj)
	    p = fix(l - (v *hd))>0
	    di= 0
	    FOR dx=0,dlx1 do begin
		va= v
		v = tare(dx,dj)
		dv= l - (v *hd)
    		pv=(dv-p) /ni1
		FOR cg=ni,0,-1 do begin
		    d =fix(dv - (cg*pv))>0
		    if (xare(di,2) gt d) then begin
			 if (d lt l)	 then begin
			    if (erey(di,d) eq 0 )  then begin
				erey(di,d)=(l-d)*np +nd
				e=d +1
				while (e le l) do begin
				  if   (erey(di,e) eq 0 ) then begin
				   if  (e lt p) then $
						erey(di,e)=(l-e)*np+nd  $
						else $
						if (cg eq 2) then $
						 erey(di,e)=(l-e)*np+nd $
						 else $
						 erey(di,e)=t1
				   e=e+1
				  endif else $
				   e=l+1
				endwhile
                endif
			    if ((xare(di,2) lt p) and (va gt 0)) then begin
				e=p-1
				while (erey(di,e) eq 0) do begin
					  erey(di,e)=(l-e)*ns +1
					  e=e-1
				endwhile
			    endif
		     endif
		    endif else begin
			if ((v gt 0) and (va gt 0)) then begin
			     e=d
			     if (d lt p) then e=p-1
			     if (xare(di,2) lt e) then begin
			      while (erey(di,e) eq 0) do begin
				    if (e ge d) then $
					erey(di,e)=(l-e)*ns +1 $
				    else $
					erey(di,e)=t1
				    e=e-1
			      endwhile
			     endif
			endif
		    endelse
		    e=d-1
		    if  ((e gt p) and (v gt 0)) then begin
		      if (e gt xare(di,2)) then begin
			    while (erey(di,e) eq 0) do begin
				  erey(di,e )=(l-e)*ns +1
				  e=e-1
			    endwhile
		      endif
		      e=p+1
		      while  ((erey(di,e) eq 0) and (e lt d)) do begin
				  erey(di,e )=(l-e)*np +nd
				  e=e+1
		      endwhile
		    endif
		    p =d
		    di=di+1
		ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif
;...
;...	Solid
;...	-----
	if (flg eq 4) then begin
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1 -  (kd*bh))>0
	    if (bg ne 1) then ke= 1. -kd/(kd+dm1)
	    hk= hd  *ke
	    kp= np  /ke
	    v = tare(0,  dj)
	    p = fix(l-(v*hk))>0
	    di= 0
	    FOR dx=0,dlx1 do begin
		  v = tare(dx,dj)
		  dv= l - (v *hk)
		  pv=(dv-p) /ni1
		  FOR cg=ni,0,-1 do begin
		    d =fix(dv -(cg*pv))>0
		    od=4-od
		    f =(l-d+1)/2
		    if (f gt 0) then begin
				e=l-ho2-f
				f=(l-ho2+f)<ply1
				g=(f-e-1)*kp +nd-od
				while (e le f) do begin
				   if (erey(di,e) eq 0) then erey(di,e)=g
				   e=e+1
				endwhile
		    endif
		    p =d
		    di=di+1
		  ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif
;...
;...	Levels:filled
;...	------ ------
	if (flg eq 10) then begin
	ic =(ic - nd +1)/lev
	ic1= ic / 3
	if  (ic lt 1) then ic=1
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1  -(kd *bh))>0
	    di= 0
	    FOR dx=0,dlx1 do begin
		v = fix(tare(dx,dj) *dt)
		if (v gt ic1)  then begin
			 v = (v/ic)*ic
			 d = fix(l - (v*hd))>0
			 v =  v +  nd
		endif else begin
			 v =  1
			 d =  l
		endelse
		FOR cg=ni,0,-1 do begin
		    if  (erey(di,d) lt 1) then begin
				if (di gt 0) then $
				  if (erey(di-1,d) ne v) then $
				  if (erey(di-1,d) ne 0) then $
						erey(di-1,d)=nw
				erey(di,d)=v
				e=d +1
				while  (e lt ply) do begin
				  if (erey(di,e) lt 1) then begin
				      if  (di    gt 0) then $
				  	 if  (erey(di-1,e) ne v) then $
					 if  (erey(di-1,e) ne 0) then $
						 erey(di-1,e)=nw
				      erey(di,e)=v
				      e=e+1
				  endif else begin
				      if  (erey(di,e) ne v)  then begin
				       if (erey(di,e) ne nw) then begin
					   erey(di,e-1) =nw
					   if (erey(di,e) lt v) then $
						 erey(di,e)=nw
				       endif
				      endif
				      e=ply
				  endelse
				endwhile
		    endif
		    di=di+1
		ENDFOR
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif
;...
;...	Levels:lines
;...	------ -----
	if (flg eq 11) then begin
;	FOR dx=0,dlx1 do begin
;	    xare(dx,0)=0
;	ENDFOR
	xare(*,0)=0
        ic =(ic - nd +1)/lev
	ic1= ic / 3
	if  (ic lt 1) then ic=1
	FOR dj= dm1 ,0,-1 do begin
	    l = fix(ply1  -(kd *bh))>0
	    di= 0
	    z2= 0
	    FOR dx=0,dlx1 do begin
		v = fix(tare(dx,dj) *dt)
		if (v gt ic1)  then begin
			 v = (v/ic)*ic
			 d =  fix(l - (v *hd))>0
			 v =  v +  nd
		endif else begin
			 v =  1
			 d =  l
		endelse
		z =(xare(dx,0) ne v)
		if (dx gt 0) then z2=(xare(dx-1,0) ne v)
		FOR cg=ni,0,-1 do begin
		    if  (erey(di,d) lt 1) then begin
				if (z2)   then begin
					  erey(di  ,d)=v
					  erey(di-1,d)=xare(dx-1,0)
				endif else $
					  erey(di,d)=1
				e=d +1
				while (e lt ply) do begin
				  if     (erey(di,e) lt 1) then begin
				      if (z2)  then begin
					    erey(di  ,e)=v
					    erey(di-1,e)=xare(dx-1,0)
				      endif else $
					    erey(di,e)=1
				      e=e+1
				  endif else begin
				   if (z) then begin
					  erey(di,e-1)=v
					  erey(di,e)  =xare(dx,0)
				   endif
				   e=ply
				  endelse
				endwhile
		    endif
		    di=di+1
		ENDFOR
	        xare(dx,0)=v
	    ENDFOR
	    kd=kd + 1.
	ENDFOR
	endif

	endelse

;...Horizon
;...*******
	if ((bg eq 2) and (ho gt 2) and (flg ne 4)) then begin
	     plx1 =plx -1
;	     g    =nv*4/5
	     ke   =float(nv-nv/3)/(ho+1)
		 FOR dj=0,ho  ,2 do begin
		 g =nv - dj*ke
		 FOR dx=0,plx1,2 do begin
		   if(erey(dx,dj) eq 0) then erey(dx,dj)=g
		 ENDFOR
		 ENDFOR
;...
;	     g    =nv*2/3
	     ke   =float(nv-nv/3)/(ply1-ho)
	     FOR dj=ho+1,ply1,2  do begin
		 g =nv -(ply1-dj)*ke
		 FOR dx=0   ,plx1,2  do begin
		   if(erey(dx,dj) le 1) then erey(dx,dj)=g
		 ENDFOR
		 ENDFOR
	endif
;...Deep
;...****
	if ((bg eq 2) and (ho gt 0) and (flg eq 4)) then begin
	     plx1 =plx -1
	     g    =nv
	     dx2  =plx1/2
	     dy2  =ply1/2
	     ke   =float(g)/(dx2+dy2)
	     FOR dj=0,ply1,2 do begin
		 l =dj-dy2
		 if(l lt 0) then l=-l
		 FOR dx=0,plx1,2 do begin
		   if(erey(dx,dj) eq 0) then begin
		      e=dx-dx2
		      if(e lt 0) then e=-e
		      erey(dx,dj) =(e+l)*ke
		   endif
		 ENDFOR
		 ENDFOR
	endif
;...Box a b
;...*** e c
	if ((bg eq 1) and (sbox(0,2) ge 0) and (ho1 gt 0)) then begin
	     ax   =sbox(sbox(0,2),0)
	     ay   =sbox(sbox(0,2),1)
	     bx   =sbox(sbox(1,2),0)
	     by   =sbox(sbox(1,2),1)
	     cx   =sbox(sbox(2,2),0)
	     cy   =sbox(sbox(2,2),1)
	     ex   =sbox(sbox(3,2),0)
	     ey   =sbox(sbox(3,2),1)
	     ho2  =(ply1-ey)/2
;...
	    if (ax lt bx) then begin
;...a -> b
		dt=float(ay-by)/(bx-ax)
		dy2=(ay-ho1)
		   FOR dj=dy2 , ay do begin
			erey(ax,dj)=nw
		   ENDFOR
		kd=dt
		FOR dx=ax+1,bx-1,3 do begin
		   FOR dj=dy2-kd , ay-kd,3 do begin
			if (erey(dx,dj) le 1) then erey(dx,dj)=nv
		   ENDFOR
		   kd =kd+3*dt
		ENDFOR
		   FOR dj=(dy2-kd)>0 , ay-kd do begin
			if (erey(bx,dj) le 1) then erey(bx,dj)=nw
		   ENDFOR
;...e -> c
		dt=float(ey-cy)/(cx-ex)
		kd=0.
		dy2=ey+ho2
		FOR dx=ex,cx,3 do begin
		   FOR dj=ey-kd , dy2-kd,3 do begin
			erey(dx,dj)=nv
		   ENDFOR
		   kd =kd+3*dt
		ENDFOR
	    endif

	    if (bx lt cx) then begin
;...b -> c
		dt=float(by-cy)/(cx-bx)
		kd=0.
		dy2=by-ho1
		FOR dx=bx,cx,3 do begin
		   FOR dj=dy2-kd , by-kd,3 do begin
			if (erey(dx,dj) le 1) then erey(dx,dj)=nv
		   ENDFOR
		   kd =kd+3*dt
		ENDFOR
;...a -> e
		dt=float(ay-ey+1)/(ex-ax+1)
		kd=0.
		dy2=ay+ho2
		FOR dx=ax,ex,3 do begin
		   FOR dj=ay-kd , dy2-kd,3 do begin
			erey(dx,dj)=nv
		   ENDFOR
		   kd =kd+3*dt
		ENDFOR

	    endif else begin

		FOR dj=by,cy do begin
			erey(ax,dj)=nv
			erey(bx,dj)=nv
		ENDFOR
		endelse
	endif
return
end

;-------------------------------------------------------------------------------
;*******************************************************************************
;
;     FUNCTION t2e, w_in, in5multi = idet, ken = abs, id
;
;For IN4, IN5, IN6, HET and D7 data. Calls Don Kearley's old t2e for other instruments.
;
;Converts tof data in w_in to energy transfer in w_out. Includes the
;factor of ki/kf.
;
;KEYWORDS:
; /in5multi	: use data in IN5 multidetector
;		- otherwise use IN5 high angle detectors (default)
; /ken		: use Ken's expression for dEdt in t2e_tof.pro (not recommended)
;
; (id is obsolete and should not be used)
;
;DIMENSIONS:
; w_in(nchannels,nspectra) -> w_out(nE,spectra)
;
;COMMAND SYNTAX
; w10=t2e(w9[,/in5multi][,/norm])
;                                         KHA, JRS 16/7/02
;
;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION t2e_tof, w_in, idet, ken

	COMMON c_lamp_access, inst
	COMMON printing, iprint, outstring
	COMMON constants, const1, const2, const3, const4

	IF iprint THEN PRINT,'Start t2e_tof:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace and energy parameters

	par = datp.p

; ** One case to perform the transformation for MiBeMol data
; ** S. Rols 11/01 srols@anl.gov
; ** *****************************************************

	CASE inst OF
	'DCSasc':BEGIN
		lambda = FLOAT(par(8))
		print,'lambda=',lambda
      		chw    = FLOAT(par(14))
      		print,'ch_width=',chw
      		chel   = FLOAT(par(10))
      		print,'el. channel=',chel
      		L2     = FLOAT(par(6))*1.        ; sample-detector distance (mm)
      		print,'SD distance (mm)=',L2
		END
	ELSE:BEGIN
		lambda = par(21)
      		chw    = par(18)
      		chel   = par(9)
      		L2     = par(27)*1000.        ; sample-detector distance (mm)
		END
	ENDCASE

	det = 1
	IF N_ELEMENTS(idet) NE 0 THEN det=idet
	IF det EQ 0 THEN BEGIN
		IF inst NE 'IN5' THEN BEGIN
			s = 't2e: Error - "/in5multi" can only be used for IN5 data'
			j = DIALOG_MESSAGE(s, /ERROR)
  			GOTO, finished
		ENDIF
		L2 = L2 - 300.
	ENDIF
	IF inst EQ 'IN6' THEN L2 = 2470.

	IF iprint THEN PRINT,'lambda=',lambda,'A, chw=',chw,'mcs, chel=',chel
	IF iprint THEN PRINT,' L2=',L2,'mm'

	sw = SIZE(w_in)
	nchannels = sw(1)
	IF sw(0) EQ 1 THEN nspectra = 1 ELSE nspectra = sw(2)

	IF iprint THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	x_in = datp.x
	y_in = datp.y
	e_in = datp.e

	se = SIZE(e_in)
	IF (se(0) NE sw(0)) OR (se(1) NE sw(1)) THEN e_in = SQRT(w_in)

	IF iprint THEN PRINT, 't2e: End of check dimensions, etc. section'

;-------------------------------------------------------------------------------------
;     Set constants and prepare output arrays

	IF (inst EQ 'IN5') AND (nspectra GT 1) THEN BEGIN
		IF det EQ 0 THEN i = WHERE(y_in LT 10.,nspectra) $
			ELSE i = WHERE(y_in GT 10.,nspectra)
 		w_buf = w_in(*,i)
 		e_buf = e_in(*,i)
 		y_out=y_in(i)
	ENDIF ELSE BEGIN
		w_buf = w_in
		e_buf = e_in
		y_out = y_in
	ENDELSE

	Ei   = const4/lambda^2
	Vi   = SQRT(Ei/const1)
	Tel  = L2/Vi
	time = chw*FLOAT(x_in - chel) + Tel
	Ef   = const1*(L2/time)^2
	Eps  = Ei - Ef

;-------------------------------------------------------------------------------------
;     Transform to energy transfer

	IF N_ELEMENTS(ken) EQ 0 THEN dtdE = SQRT(const1/(4.*Ef^3)) $
		ELSE dtdE = SQRT(const1/Ef^3)/SQRT(const1/Ei^3)	;Ken's expression (!?)
	kikf = SQRT(Ei/Ef)

	IF iprint THEN BEGIN
            PRINT,'channel    time    Eps       dtdE      kikf'
            FOR i=0,nchannels-1 DO PRINT, FORMAT='(I4,2F10.3,6F10.6)', $
                  i+1, time(i), Eps(i), dtdE(i), kikf(i)
	ENDIF

	fact=(dtdE*kikf) # (FLTARR(1,nspectra) + 1.)

	x_out = Eps
	w_out = w_buf*fact
	e_out = e_buf*fact

	IF iprint THEN PRINT,'t2e: End of t2e-ing section'

;-------------------------------------------------------------------------------------
; Prepare data and return

	s = STRTRIM(STRING(Ei),2) & i = RSTRPOS(s,'.') & Ei = STRMID(s,0,i + 3)
	outstring = 'Ei=' + Ei + 'meV'
	IF inst EQ 'IN5' THEN BEGIN
  		IF det EQ 0 THEN dstring = 'multidetector data' $
			ELSE dstring = 'high-angle detector data'
		outstring = outstring + ', ' + dstring
	ENDIF

	bit=' -t2e(Ei='+Ei
	IF inst EQ 'IN5' THEN bit = bit + ',' + STRTRIM(STRING(det),2) + ')' $
		ELSE bit = bit + ')'
	datp.other_tit = datp.other_tit + bit
	datp.x_tit = 'Energy Transfer (meV)'

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out
	IF inst EQ 'IN5' THEN mod_datp, datp, "y", y_out
	give_datp, datp

finished:
      RETURN, w_out
      END


;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION t2e_d7, w_in, abs

	COMMON printing, iprint, outstring
	COMMON constants, const1, const2, const3, const4

	IF iprint THEN PRINT,'Start t2e_d7:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace and energy parameters

	par    = datp.p
	lambda = par(4)
	chw    = par(7)
	chel   = par(9)

	IF iprint THEN PRINT,'lambda=',lambda,'A, chw=',chw,'mcs, chel=',chel

	TOF = FIX(par(8))
	IF NOT TOF THEN BEGIN
            j = DIALOG_MESSAGE(' t2e: Error - workspace data is not in TOF', /ERROR)
            GOTO, finished
	ENDIF

	nspectra  = FIX(par(1))
	nphases   = FIX(par(2))
	nchannels = FIX(par(6))
	nspectra  = nspectra*nphases
	sw        = SIZE(w_in)

	IF iprint THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	y_in = datp.y
	e_in = datp.e
	se = SIZE(e_in)
	IF (se(0) NE sw(0)) OR (se(1) NE sw(1)) THEN BEGIN
		j = DIALOG_MESSAGE('t2e: no error bars defined', /ERROR)
		GOTO, finished
	ENDIF

	IF iprint THEN PRINT, 't2e: End of check workspaces, etc. section'

;-------------------------------------------------------------------------------------
;     Set constants and prepare output arrays

	w_out = w_in
	e_out = e_in
	x_out = FLTARR(nchannels)
	y_out = datp.y

	L2 = 1500.0         ; sample-detector distance (mm)

	Ei = const4/lambda^2
	Vi = SQRT(Ei/const1)
	Tel = L2/Vi

;-------------------------------------------------------------------------------------
;     Transform to energy transfer and correct data

	time  = chw*FLOAT(INDGEN(nchannels) - chel) + Tel
	Ef    = const1*(L2/time)^2
	Eps   = Ei - Ef
	dtdE  = time/(2.*Ef)
	kikf  = SQRT(Ei/Ef)
	x_out = Eps

	IF iprint  THEN BEGIN
		PRINT,'channel    time    Eps       dtdE      kikf'
 		FOR i=0,nchannels-1 DO $
			PRINT, FORMAT='(I4,2F10.3,6F10.6)', i, time(i), $
			Eps(i), dtdE(i), kikf(i)
	ENDIF

	fact=(dtdE*kikf) # (FLTARR(1,nspectra) + 1.)
	w_out = w_in*fact
	e_out = e_in*fact

	zeroed = WHERE(e_in LT -0.9,nz)
	IF nz NE 0 THEN BEGIN
		w_out(zeroed) = 0.
		e_out(zeroed) = -1.
	ENDIF

	IF iprint THEN PRINT, 't2e: End of t2e-ing section'

;------------------------------------------------------------------------------------
; Prepare output arrays and return

	s = STRTRIM(STRING(Ei),2) & i = RSTRPOS(s,'.') & Ei = STRMID(s,0,i+3)
	outstring = 'Ei=' + Ei + 'meV'
	datp.x_tit = 'Energy Transfer (meV)'
	IF datp.z_tit EQ 'X-section (b/ster/f.u./mcs)' THEN $
		datp.z_tit='S(omega,E)'
	datp.other_tit=datp.other_tit+' -t2e(Ei='+Ei+')'

	mod_datp, datp, "x", x_out
	datp.e = e_out

	give_datp, datp

finished:
	RETURN, w_out
	END

;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION t2e_HET, w_in

	COMMON printing, iprint, outstring
	COMMON constants, const1, const2, const3, const4

	IF iprint THEN PRINT,'Start t2e_HET:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input workspace and energy parameters

	par = datp.p

	lambda = par(21)
	tel2p5 = par(9)
	tel4   = par(8)
	L2     = datp.z*1000.       ; sample-detector distance (mm)

	IF iprint THEN PRINT,'A, tel(2.5m)=',tel2p5,'mcs, tel(4m)=',tel4

	sw = SIZE(w_in)
	nchannels = sw(1)
	IF sw(0) EQ 1 THEN nspectra = 1 ELSE nspectra = sw(2)

	IF iprint THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	x_in = datp.x
	y_in = datp.y
	e_in = datp.e

	se = SIZE(e_in)
	IF (se(0) NE sw(0)) OR (se(1) NE sw(1)) THEN e_in = SQRT(w_in)

	IF iprint THEN PRINT, 't2e: End of check workspaces, etc. section'

;-------------------------------------------------------------------------------------
;     Set constants and prepare output arrays

	Ei   = const4/lambda^2
	Vi   = SQRT (Ei/const1)
	Tel  = L2/Vi
	time = x_in

	Ef = FLTARR(nchannels,nspectra)

	i = WHERE(L2 GT 2300 AND L2 LT 2700, ni)	; 2,5m bank
	FOR ii = 0, ni - 1 DO $
		Ef[*,i[ii]] = const1*(L2[i[ii]]/(time - tel2p5 + Tel[i[ii]]))^2
	i = WHERE(L2 GT 3800 AND L2 LT 4200, ni)	; 4m bank
	FOR ii = 0, ni - 1 DO $
		Ef[*,i[ii]] = const1*(L2[i[ii]]/(time - tel4 + Tel[i[ii]]))^2
	Eps = Ei - Ef
	p = MAX(TOTAL(Ef,2),imax)			;find t = 0 channel

	x_out =  Eps[imax+1:nchannels-1,*]
	Ef    =   Ef[imax+1:nchannels-1,*]
	w_buf = w_in[imax+1:nchannels-1,*]
	e_buf = e_in[imax+1:nchannels-1,*]

;-------------------------------------------------------------------------------------
; Transform to energy transfer

	dtdE = SQRT(const1/(4.*Ef^3))
	kikf = SQRT(Ei/Ef)
	fact = (dtdE*kikf)

	w_out = w_buf*fact
	e_out = e_buf*fact

	IF iprint GT 0 THEN PRINT,'End of t2e-ing section'

;-------------------------------------------------------------------------------------
; Prepare data and return

	s = STRTRIM(STRING(Ei),2) & i = RSTRPOS(s,'.') & Ei = STRMID(s,0,i+3)
	outstring = 'Ei=' + Ei + 'meV'

	bit=' -t2e(Ei='+ Ei + ')'
	datp.other_tit = datp.other_tit + bit
	datp.x_tit = 'Energy Transfer (meV)'

	mod_datp, datp, "x", x_out
	mod_datp, datp, "e", e_out

	give_datp, datp

finished:
	RETURN, w_out
	END


;-------------------------------------------------------------------------------
;*******************************************************************************

function t2e_don,in_wk
;
;converts array w_in  to energy in w_out.....GJK 1994
;
;Example call: w2=t2e(w1)
;         convert tof spectrum in w1 to energy and output in w2

;
; Sets up and copies work-space stuff into simple arrays
@lamp.cbk
      nwk=''
      x=0.0
      y=0.0
      w=0.0
      if one ne 0 then out_wk=one
      if two ne 0 then begin
        n_wk=strtrim(string(two),2)
        iii=execute('w_in = w' +n_wk)
        iii=execute('n_in = n' +n_wk)
        iii=execute('pv_in= pv'+n_wk)
        iii=execute('p_in = p' +n_wk)
        iii=execute('x_in = x' +n_wk)
        iii=execute('y_in = y' +n_wk)
        iii=execute('z_in = z' +n_wk)

;       set defaults
        n_out =n_in
        p_out =p_in
        pv_out=pv_in
        x_out =x_in
        y_out =y_in
        z_out =z_in
        endif
;
;done @mac.in

my_check=size(in_wk)

  if my_check(0) lt 1 then  begin
     P_MUS,'mus_cannon'
     mess='Workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
   endif

  if strpos(his(two),'t2e') gt 0 then begin
     P_MUS,'mus_cannon'
     mess='Workspace already in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
  endif

  P_MUS,'mus_shot'
  nch=my_check(1)
  if my_check(0) gt 1 then nang=my_check(2) else nang=1
;
; stof or bs
  if (inst_value eq 'IN10') or (inst_value eq 'IN16') then begin
       x_in     = INDGEN(nch)+1
       t2efac   = 1.234
       if (inst_value eq 'IN16') then t2efac=1.036
  x_out=x_in*2.0*t2efac*p_in(2)/max(x_in)
  x_out=x_out-0.5*max(x_out)

  x_tit(one)='Energy Transfer (ueV)'
; Copies work-space stuff from simple arrays back to main LAMP arrays
      n_wk=string(out_wk)
      n_wk=strtrim(n_wk,2)

      jjj=execute('p' +n_wk+'=p_out' )
      jjj=execute('pv'+n_wk+'=pv_out')
      jjj=execute('x' +n_wk+'=x_out' )
      jjj=execute('y' +n_wk+'=y_out' )
      jjj=execute('z' +n_wk+'=z_out' )
;
;done @mac.out

return,in_wk
  endif

      coef=fltarr(nch)
      x_out=fltarr(nch)
        w_out=fltarr(nch,nang)
        w_buf=fltarr(nch,nang)
;
      y_out=y_in

  ;
; Convert to Energy
      eelast=81.799/p_in(21)^2                  ; Ei in meV
      telast=p_in(27)*p_in(21)/3956.0           ; TOF in sec
      cwidth=p_in(18)*1e-6                      ;chw in sec
        epp=p_in(9)

  ;
; Any channels to shift?
        norg=nch
        nxtra=0
        elimit=1000.0
        tlimit=p_in(27)*sqrt(81.8/elimit)/3956.0
        for j=0,nch-1 do begin
        time_diff=(p_in(9)-j)*cwidth
        flt_time=telast-time_diff
        if flt_time le tlimit then begin
        epp=epp-1
        w_buf(nxtra,*)=in_wk(j,*)
        nxtra=nxtra+1
        norg=norg-1
        endif
        endfor

        if nxtra gt 0 then begin
        w_out(0:norg-1,*)=in_wk(nxtra:nch-1,*)
        w_out(norg:nch-1,*)=w_buf(0:nxtra-1,*)
        endif
        if nxtra le 0 then w_out=in_wk


        bodge=1.0e6/telast
      for j=0,nch-1 do begin
          time_diff=(epp-j)*cwidth
          flt_time=telast-time_diff
          lam=flt_time*3956.0/p_in(27)
          x_out(j)=eelast-(81.8/lam^2)
          w_out(j,*)=w_out(j,*)*flt_time^4*bodge
          endfor
      p_out=p_in
      x_tit(one)='Energy Transfer (meV)'
; Copies work-space stuff from simple arrays back to main LAMP arrays
      n_wk=string(out_wk)
      n_wk=strtrim(n_wk,2)

      jjj=execute('p' +n_wk+'=p_out' )
      jjj=execute('pv'+n_wk+'=pv_out')
      jjj=execute('x' +n_wk+'=x_out' )
      jjj=execute('y' +n_wk+'=y_out' )
      jjj=execute('z' +n_wk+'=z_out' )
;
;done @mac.out
      return,w_out
      end

;-------------------------------------------------------------------------------
;*******************************************************************************

	FUNCTION t2e, w_in, in5multi = idet, ken = abs, id

	COMMON c_lamp_access, inst
	COMMON printing, iprint, outstring
	COMMON constants, const1, const2, const3, const4

	iprint = 0    ; if iprint>0, show debugging messages

	const1 = 5.22697          ; E(meV)=const1*V(m/ms)^2 for neutron
	const2 = 2.07193571       ; E(meV)=const2*k(A^-1)^2 for neutron
	const3 = 3.956076         ; V(m/ms)=const3/lambda(A) for neutron
	const4 = 81.8066          ; E(meV)=const4/lambda(A)^2 for neutron

	IF iprint THEN PRINT,'Start t2e:'

	IF KEYWORD_SET(in5multi) THEN idet=0
	IF N_ELEMENTS(id) GT 0 THEN idet=id

;-------------------------------------------------------------------------------
;Check instrument name and call appropriate function

	IF (inst EQ 'IN4') OR (inst EQ 'IN5') OR (inst EQ 'IN6') OR $
	   (inst EQ 'MiBeMol') OR (inst EQ 'DCSasc') THEN $
		w_out = t2e_tof(w_in, idet, abs) $
	ELSE IF inst EQ 'D7' THEN $
		w_out = t2e_d7(w_in) $
	ELSE IF inst EQ 'HET' THEN $
		w_out = t2e_HET(w_in) $
	ELSE w_out = t2e_don(w_in)

;-------------------------------------------------------------------------------
;Return parameters and exit

	IF N_ELEMENTS(outstring) GT 0 THEN PRINT,'t2e: '+outstring

	RETURN, w_out
	END


	FUNCTION t2l, w_in

;converts from cts/TOF to cts/lambda
;
; input=output format: w(128,nspectra)
;							KHA, 30/10/96


	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start t2l:'

	take_datp, datp

;-------------------------------------------------------------------------------
;Set up input file and energy parameters

	par=datp.p

	lambda=par(3)
	freq=par(4)
	chw=par(6)
	chel=par(8)

	IF (iprint GT 0) THEN PRINT,'lambda=',lambda,' chel=',chel
	IF (iprint GT 0) THEN PRINT,'freq=',freq,'rpm   chw=',chw,'mcs'

	TOF=FIX(par(7))
	IF (TOF NE 1) THEN BEGIN
		PRINT,' Corr_tof: Error - workspace data is not in TOF'
		GOTO, finished
	ENDIF

	nchannels=FIX(par(5))
	nphases=FIX(par(1))

	sw=SIZE(w_in)
	IF (iprint GT 0) THEN PRINT,'SIZE(w_in)=',sw
	IF (sw(0) EQ 1) THEN nspectra=1 $
			ELSE nspectra=sw(2)

	IF (iprint GT 0) THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra
	y_in=datp.y
	e_in=datp.e

	se=SIZE(e_in)
	IF (se(0) NE sw(0) OR se(1) NE sw(1)) THEN BEGIN
		PRINT,'Error - SIZE(w_in)=',sw
		PRINT,'        SIZE(e_in)=',se
		PRINT,'      - must be the same size'
		GOTO, finished
	ENDIF

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------------
;	Set constants and prepare arrays

	eff=FLTARR(nchannels)
	wave=FLTARR(nchannels)

	const1=5.22697		; E(meV)=const1*V(m/ms)^2 for neutron
	const2=2.07193571	; E(meV)=const2*Q(A^-1)^2 for neutron
	const3=3.956076		; V(m/ms)=const3/lambda(A) for neutron
	const4=81.8066		; E(meV)=const4/lambda(A)^2 for neutron

	L2=1500.0		; sample-detector distance (mm)

	Ei=const4/lambda^2
	Vi=SQRT(Ei/const1)
	Tel=L2/Vi

	time=chw*FLOAT(INDGEN(nchannels)-chel)+Tel
	Ef=const1*(L2/time)^2
	wave=SQRT(const4/Ef)
	x_out=wave
	w_out=w_in

	datp.x=x_out
	datp.x_tit='Neutron Wavelength (A)'
	
finished:
	IF (iprint GT 0) THEN PRINT,'End t2l:'

	give_datp, datp

	RETURN, w_out
	END
pro tagfile, file, TAG=tag, GET=valg ,SET=vals
;** *******
;**
;** Manu's rich idea .....
;** Procedure which sets and retrieves values from an INI file.
;** File is composed by twin elements such as "tag = value" (no comments at this time).
;** Use: tagfile,"filename" ,TAG=["TOTO","TITI"] ,SET=[valueTOTO,valueTITI]
;**      tagfile,"filename" ,TAG=["toto","titi"] ,GET= returnedStringValues

IF n_elements(tag)      eq 0 then RETURN
IF n_elements(vals)     gt 0 then IF n_elements(vals) ne n_elements(tag) then RETURN
IF n_elements(file)     ne 1 then file="default"
IF strpos(strlowcase(file),'.ini')  lt 0 then file= file+".ini"

ON_IOERROR,misget & u=-1 & line='' & ftag=[''] & fval=[''] & valg=''

;READ FILE.INI
;-------------
OPENR,u,file,/GET_LUN
	WHILE (not eof(u)) do begin
		READF,u,line
		idx=strpos(line,'=')
		IF idx gt 0 then begin
			ftag=[ftag,strtrim(strupcase(strmid(line,0    ,idx)),2)]
			fval=[fval,strtrim(         (strmid(line,idx+1,100)),2)]
		ENDIF
	ENDWHILE
MISGET: IF u gt 0 then FREE_LUN,u else print,!err_string

utag=strupcase(strtrim(tag,2))

;DO SET OR GET
;-------------
FOR i=0,n_elements(utag)-1 do begin miss=1 & jj=n_elements(ftag)

	WHILE (miss) and (jj gt 0) do begin
		jj=jj-1
		IF ftag(jj) eq utag(i) then miss=0
	ENDWHILE
	IF n_elements(vals) gt 0 then begin
		IF not miss then fval(jj)  =string(vals(i))  $
		ELSE	   begin fval=[fval,string(vals(i))]
			         ftag=[ftag,utag(i)] & ENDELSE				 
	ENDIF   ELSE $
		IF jj ge 0 then  valg=[valg,fval(jj)]  ELSE valg=[valg,'']
ENDFOR

nn  = n_elements(ftag)-1
IF nn eq 0  then RETURN

;RETURN IF GET
;-------------
IF n_elements(vals) eq 0 then begin
	IF n_elements(valg) gt 1 then valg=valg(1:n_elements(valg)-1)
	IF n_elements(valg) eq 1 then valg=valg(0)
	RETURN
ENDIF

ON_IOERROR,misput & u=-1

;WRITE FILE.INI IF SET
;---------------------
idx=SORT(ftag) & ftag=ftag(idx) & fval=fval(idx)

OPENW,u,file,/GET_LUN
	FOR i=1,nn do  PRINTF,u,ftag(i)+' = '+fval(i)

MISPUT: IF u gt 0 then FREE_LUN,u else print,!err_string

end
function tee,in_wk
;
;converts array w_in  to energy in w_out.....GJK 1994
;
;Example call: w2=t2e(w1)
;         convert tof spectrum in w1 to energy and output in w2

;
; Sets up and copies work-space stuff into simple arrays
@lamp.cbk
      nwk=''
      x=0.0
      y=0.0
      w=0.0
      if one ne 0 then out_wk=one
      if two ne 0 then begin
        n_wk=strtrim(string(two),2)
        iii=execute('w_in = w' +n_wk)      
        iii=execute('n_in = n' +n_wk)
        iii=execute('pv_in= pv'+n_wk)       
        iii=execute('p_in = p' +n_wk)       
        iii=execute('x_in = x' +n_wk)
        iii=execute('y_in = y' +n_wk)
        iii=execute('z_in = z' +n_wk)
        iii=execute('e_in = e' +n_wk)
        
;       set defaults            
        n_out =n_in
        p_out =p_in
        pv_out=pv_in
        x_out =x_in
        y_out =y_in
        z_out =z_in
        e_out =e_in
        endif
;
;done @mac.in

my_check=size(in_wk)

  if my_check(0) lt 1 then  begin
     P_MUS,'mus_cannon'
     mess='Workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
   endif

  if strpos(his(two),'t2e') gt 0 then begin
     P_MUS,'mus_cannon'
     mess='Workspace already in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
  endif

  P_MUS,'mus_shot'
  nch=my_check(1)
  if my_check(0) gt 1 then nang=my_check(2) else nang=1
;
; stof or bs
  if (inst_value eq 'IN10') or (inst_value eq 'IN16') then begin
       x_in     = INDGEN(nch)+1
       t2efac   = 1.234
       if (inst_value eq 'IN16') then t2efac=1.036
  x_out=x_in*2.0*t2efac*p_in(2)/max(x_in)
  x_out=x_out-0.5*max(x_out)

  x_tit(one)='Energy Transfer (ueV)'
; Copies work-space stuff from simple arrays back to main LAMP arrays
      n_wk=string(out_wk)
      n_wk=strtrim(n_wk,2)

      jjj=execute('p' +n_wk+'=p_out' )
      jjj=execute('pv'+n_wk+'=pv_out')
      jjj=execute('x' +n_wk+'=x_out' )
      jjj=execute('y' +n_wk+'=y_out' )
      jjj=execute('z' +n_wk+'=z_out' )
      jjj=execute('e' +n_wk+'=e_out' )
;
;done @mac.out
return,in_wk
  endif

  	coef=fltarr(nch)
	x_out=fltarr(nch)
        w_out=fltarr(nch,nang)
        w_buf=fltarr(nch,nang)
	if n_elements(e_in)  ne n_elements(w_in) then e_out=0
	if n_elements(e_out) gt 1 then e_buf=w_buf
;
	y_out=y_in

  ;
; Convert to Energy
	eelast=81.799/p_in(21)^2                  ; Ei in meV
	telast=p_in(27)*p_in(21)/3956.0           ; TOF in sec
	cwidth=p_in(18)*1e-6                      ;chw in sec
        epp=p_in(9)

  ;
; Any channels to shift?
        norg=nch
        nxtra=0
        elimit=1000.0
        tlimit=p_in(27)*sqrt(81.8/elimit)/3956.0
        for j=0,nch-1 do begin
         time_diff=(p_in(9)-j)*cwidth        
         flt_time=telast-time_diff
         if flt_time le tlimit then begin
          epp=epp-1
          w_buf(nxtra,*)=in_wk(j,*)
	  if n_elements(e_out) gt 1 then e_buf(nxtra,*)=e_in(j,*)
          nxtra=nxtra+1
          norg=norg-1
         endif
        endfor

        if nxtra gt 0 then begin
           w_out(0:norg-1,*)  =in_wk(nxtra:nch-1,*)
           w_out(norg:nch-1,*)=w_buf(0:nxtra-1,*)
	  if n_elements(e_out) gt 1  then begin
           e_out(0:norg-1,*)  =e_in (nxtra:nch-1,*)
           e_out(norg:nch-1,*)=e_buf(0:nxtra-1,*)
	  endif
        endif
        if nxtra le 0 then w_out=in_wk

  
        bodge=1.0e6/telast
	for j=0,nch-1 do begin
	    time_diff=(epp-j)*cwidth
	    flt_time=telast-time_diff
	    lam=flt_time*3956.0/p_in(27)
	    x_out(j)=eelast-(81.8/lam^2)
	    w_out(j,*)=w_out(j,*)*flt_time^4*bodge
	    if n_elements(e_out) gt 1 then e_out(j,*)=e_out(j,*)*flt_time^4*bodge
	    endfor
	p_out=p_in
	x_tit(one)='Energy Transfer (meV)'
; Copies work-space stuff from simple arrays back to main LAMP arrays
      n_wk=string(out_wk)
      n_wk=strtrim(n_wk,2)

      jjj=execute('p' +n_wk+'=p_out' )
      jjj=execute('pv'+n_wk+'=pv_out')
      jjj=execute('x' +n_wk+'=x_out' )
      jjj=execute('y' +n_wk+'=y_out' )
      jjj=execute('z' +n_wk+'=z_out' )
      jjj=execute('e' +n_wk+'=e_out' )
;
;done @mac.out
	return,w_out
	end
FUNCTION tempcat,num1,num2,DDMMYY=DDMMYY,HHMMSS=HHMMSS,reg=reg,t_min=t_min,T_K=T_K

;+
; EXAMPLE :
;   w2=tempcat(76575,78589,DDMMYY=200798,HHMMSS='0',t_min=x1,T_K=w1)
;-

@lamp.cbk
take_datp,datp,w=one
filnam=STRCOMPRESS(num1,/RE)+'_'+STRCOMPRESS(num2,/RE)+'.temp'
shortnam=STRCOMPRESS(num1,/RE)+'_'+STRCOMPRESS(num2,/RE)+'.dat'
OPENW,temp,filnam,/GET_LUN
OPENW,short,shortnam,/GET_LUN
PRINTF,temp,'# TEMPeratureCATalogue : ',num1, ' to ', num2
PRINTF,short,'# TEMPeratureCATalogue : ',num1, ' to ', num2
  DD=0
  MON=0
  YY=0
  HH=0
  MM=0
  SS=0
refday=LONG(0)
IF KEYWORD_SET(DDMMYY) THEN BEGIN
  DDMMYY=STRCOMPRESS(STRING(1000000+(LONG(DDMMYY)<1000000)),/RE)
  day=STRMID(DDMMYY,1,2)
  READS,day,DD
  month=STRMID(DDMMYY,3,2)
  READS,month,MM
  year=STRMID(DDMMYY,5,2)
  READS,year,YY
  PRINTF,temp,'# Starting day for time scale :',DD,MM,YY
  PRINTF,short,'# Starting day for time scale :',DD,MM,YY
  PRINT,'# Starting day for time scale :',DD,MM,YY
  DDMMYY=JULDAY(MM,DD,YY)
ENDIF
IF KEYWORD_SET(HHMMSS) THEN BEGIN
    HHMMSS=STRCOMPRESS(STRING(1000000+(LONG(HHMMSS)<1000000)),/RE)
    hour=STRMID(HHMMSS,1,2)
    READS,hour,HH
    min= STRMID(HHMMSS,3,2)
    READS,min,MM
    sec= STRMID(HHMMSS,5,2)
    READS,sec,SS
    PRINTF,temp,'# Starting hour for time scale :',HH,MM,SS
    PRINTF,short,'# Starting hour for time scale :',HH,MM,SS
    PRINT,'# Starting hour for time scale :',HH,MM,SS
    HHMMSS=HH*60.+MM+SS/60.
ENDIF ELSE HHMMSS=-1.
IF KEYWORD_SET(t_min) AND KEYWORD_SET(T_K) THEN PRINTF,temp,'# Sample Temperature from interpolated worklspace'
IF KEYWORD_SET(t_min) AND KEYWORD_SET(T_K) THEN PRINTF,short,'# Sample Temperature from interpolated worklspace'
PRINTF,short, '# Numor Minutes  SetPoint  Regul.   Sample  Total  Monitor'
PRINTF,temp, '# Numor Minutes  SetPoint  Regul.   Sample  Date    Time     Title'
PRINT,       '# Numor Minutes  SetPoint  Regul.   Sample  Date    Time     Title'
FOR num=num1,num2 DO BEGIN
  w=RDRUN(num,DATP=datp)
  day      = strmid(datp.other_tit,4,2)
		READS,day,DD
  month    = strmid(datp.other_tit,7,3)
  year     = strmid(datp.other_tit,11,2)
		READS,year,YY
  hour     = strmid(datp.other_tit,14,2)
		READS,hour,HH
  min      = strmid(datp.other_tit,17,2)
		READS,min,MM
  sec      = strmid(datp.other_tit,20,2)
		READS,sec,SS
  CASE month OF
     'Jan':  MON=1
     'Feb':  MON=2
     'Mar':  MON=3
     'Apr':  MON=4
     'May':  MON=5
     'Jun':  MON=6
     'Jul':  MON=7
     'Aug':  MON=8
     'Sep':  MON=9
     'Oct':  MON=10
     'Nov':  MON=11
     'Dec':  MON=12
  ENDCASE					
  IF refday EQ 0. THEN BEGIN
    IF HHMMSS GE 0 THEN BEGIN
      refmin=HHMMSS
    ENDIF ELSE refmin=HH*60.+MM+SS/60.
    IF KEYWORD_SET(DDMMYY) THEN BEGIN
        refday=DDMMYY
    ENDIF ELSE refday=FLOAT(JULDAY(MON,DD,YY))
  ENDIF
  day=JULDAY(MON,DD,YY)-refday
  min=day*24.*60.+HH*60.+MM+SS/60.-refmin
  IF KEYWORD_SET(t_min) AND KEYWORD_SET(T_K) THEN BEGIN
    datp.p(12)=INTERPOL(T_K,t_min,min)
  ENDIF
  PRINT,$
        FORMAT="(I6,F12.2,3F9.3,2F15.0)",$
        num,min,$
        datp.p(10:12), TOTAL(w(*,0)), datp.n(0)
  PRINTF,temp,$
        FORMAT="(I6,F12.2,3F9.3,A19,A57)",$
        num,min,$
        datp.p(10:12),$
        strmid(datp.other_tit,3,19),$
        STRMID(STRCOMPRESS(datp.w_tit,REMOVE_ALL=RA),0,57)
  PRINTF,short,$
        FORMAT="(I6,F12.2,3F9.3,2F15.0)",$
        num,min,$
        datp.p(10:12), TOTAL(w(*,0)), datp.n(0)
  IF KEYWORD_SET(reg) THEN Kelvin=datp.p(11) ELSE Kelvin=datp.p(12) 
  IF N_ELEMENTS(result) EQ 0 THEN BEGIN
    result=Kelvin 
    xx=min
  ENDIF ELSE BEGIN
    result=[result,Kelvin]
    xx=[xx,min]
  ENDELSE
ENDFOR
FREE_LUN,temp
FREE_LUN,short
  MOD_DATP,datp,'x',xx
  MOD_DATP,datp,'x_tit','Minutes'
  MOD_DATP,datp,'y_tit','Temperature'
  MOD_DATP,datp,'other_tit',STRCOMPRESS(num1)+' to'+STRCOMPRESS(num2)
  GIVE_datp,datp
RETURN,result
END
PRO th2th,sani,nsan,dsan,time

;sani = initial value
;nsan = no. data point
;dsan = step size
;time = counting time

co,1,' t n'
co,1,' t n'
d0=1.5
mv,'dan',d0-0.5

for i=0,nsan-1 do begin
	mv,'san',sani+i*dsan
        mv,'dan',(sani+i*dsan)*2.+d0
        mv,'dan',(sani+i*dsan)*2.+d0
	co,time,' t'
endfor
end
;**********D2B => Paolo RADAELLI *********************************

; ********************* TO CORRECT FOR THERMAL EXPANSION **********

pro thermal, coeff=coeff,  b=b, w=ws

take_w, ww, w=ws
take_datp, datp, w=ws
x=datp.x
e=datp.e
xn=360/!pi*asin(sin(x*!pi/360)*coeff)
G=(x-xn)/.1+findgen(n_elements(x))
wn=(interpolate(ww,g)-16000)*exp(-b*sin(x*!pi/360)^2/1.30^2)+16000
datp.x=x
give_datp, datp, w=ws
give_w, wn, w=ws
end

; ********************* TO CORRECT MULTIPLE DATA SETS FOR THERMAL EXPANSION **********

pro multherm, coeff=coeff, b=b, scale=s, wem=we, wmul=wm

take_w, wempty, w=we
take_w, wmult, w=wm
take_datp, datpe, w=we
take_datp, datpm, w=wm
xe=datpe.x
ee=datpe.e
xm=datpm.x
em=datpm.e
y=datpm.y
y=(y-27402)*4.7+400.
datpm.y=y
for i=0,n_elements(wmult)/1600-1 do begin
   t=y(i)
   xn=360/!pi*asin(sin(xe*!pi/360)/(1+coeff*T))
   g=(xe-xn)/.1+findgen(n_elements(xe))
   wn=(interpolate(wempty*s,g)-16000)*exp(-b*T*sin(xe*!pi/360)^2/1.30^2)+16000
   for j=0,1599 do wmult(j,i)=wmult(j,i)-wn(j)
endfor
give_datp, datpm, w=wm
give_datp, datpe, w=we
give_w, wmult, w=wm
give_w, wempty, w=we
end

;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION theta_scan, w_in, all_angles=all_angles, $
		 pos_angles=pos_angles, neg_angles=neg_angles, coder=coder, $
		 detector=detector,ib,ic

;For D7 data only
;
;Puts all detector angles onto a common x-axis. 
;Removes zeroed data points. 
;
;ARGUMENTS:
; detector	:optional argument specifying an individual detector to use
;
;KEYWORDS:
; /neg_angles	:only use data with negative angles
; /pos_angles	:only use data with positive angles
; /all_angles	:use all detector banks (default)
; /coder	:only used if an individual detector is specified
;		 If set:
;		 	use coder angle as x-axis, 
;		 otherwise:
;			use calculated detector angle as x-axis
; 
;
;DIMENSIONS:
;input format: w(nspectra,nphases,nruns)	- unless nphases or nruns is 1
;output:       w(nruns*nspectra,nphases)	- unless nphases is 1
;
;COMMAND SYNTAX:
; w10=theta_scan(w9[,/all_angles][,/pos_angles][,/neg_angles][detector=<det>][,/coder])
;
;							KHA,JRS 21/8/00
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start theta_scan:'

	w_in0=w_in

	take_datp, datp

	ibank=2
	icoder=0

	IF(N_ELEMENTS(ib) GT 0) THEN ibank=ib
	IF(N_ELEMENTS(ic) GT 0) THEN icoder=ic

	IF KEYWORD_SET(all_angles) THEN ibank=2
	IF KEYWORD_SET(neg_angles) THEN ibank=0
	IF KEYWORD_SET(pos_angles) THEN ibank=1
	IF KEYWORD_SET(coder) THEN icoder=1

	IF(N_ELEMENTS(detector) GT 0) THEN ibank=-detector

;-------------------------------------------------------------------------------
;Check arguments and dimensions of w_in
	
	par=datp.p
	e_in0=datp.e
	
	IF (iprint GT 0) THEN BEGIN
		PRINT,'w_in0: '
		HELP, w_in0
		PRINT,'e_in0: '
		HELP, e_in0
		PRINT,'par: '
		HELP, par
	ENDIF

	sw=SIZE(w_in0)
	se=SIZE(e_in0)
	IF(sw(1) EQ 32) THEN ana=1 ELSE ana=0	;define whether analysers are in
	IF (se(0) EQ 0) THEN BEGIN
		PRINT,'theta_scan: Error - no error bars; normalise must be called first'
		GOTO, finished
	ENDIF

	nchannels=FIX(par(6))
	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nruns=FIX(par(3))
	tof=FIX(par(8))
	
	IF (tof EQ 1) THEN BEGIN
		nchannels=sw(1)
		w_in0=REFORM(w_in0,nchannels,nspectra,nphases,nruns)
		e_in0=REFORM(e_in0,nchannels,nspectra,nphases,nruns)
	ENDIF
	
	IF (nruns EQ 1 AND icoder EQ 1) THEN BEGIN
		PRINT,'theta_scan: Error - can`t use coder angles for only 1 run'
		GOTO, finished
	ENDIF
	IF (nphases EQ 1 AND tof EQ 0) THEN BEGIN
		w_in1=FLTARR(nspectra,1,nruns)	& e_in1=w_in1
		w_in1(*,0,*)=w_in0(*,*)
		e_in1(*,0,*)=e_in0(*,*)
	ENDIF ELSE BEGIN
		w_in1=w_in0	& e_in1=e_in0
	ENDELSE

	IF (nruns EQ 1 AND tof EQ 0) THEN x_in1=datp.x 
        IF (nruns EQ 1 AND tof EQ 1) THEN x_in1=datp.y
	IF (nruns GT 1) THEN x_in1=datp.z

	IF (iprint GT 0) THEN PRINT,' nphases=',nphases,'nruns=',nruns,' size(w_in)=',sw

	IF (iprint GT 0) THEN PRINT,'End of "check arguments and dimensions" section'

;-------------------------------------------------------------------------------
;Set up parameters relating to ibank and output arrays

	IF (nruns EQ 1) THEN BEGIN
		i=WHERE(x_in1 LT 0.,count)

		IF (ibank EQ 0) THEN BEGIN
			istart=0
			nspectra=count
		ENDIF ELSE IF (ibank EQ 1) THEN BEGIN
			istart=count
			nspectra=nspectra-count
		ENDIF ELSE IF (ibank EQ 2) THEN BEGIN
			istart=0
		ENDIF ELSE IF (ibank GE -64 AND ibank LE -1) THEN BEGIN
			nspectra=1
			IF(ana EQ 0) THEN istart=-ibank-1 ELSE istart=-(ibank/2)-1
		ENDIF ELSE BEGIN
			PRINT,'Error - ibank=',ibank
			GOTO, finished
		ENDELSE
	
		IF (tof EQ 0) THEN BEGIN
			x_buf=FLTARR(nspectra)	& x_out=x_buf	& y_out=INDGEN(nphases)
			w_buf=FLTARR(nspectra,nphases)	& w_out=w_buf
			e_buf=FLTARR(nspectra,nphases)	& e_out=e_buf
		ENDIF ELSE BEGIN
			y_buf=FLTARR(nspectra)	& y_out=y_buf	& x_out=INDGEN(nchannels)
			w_buf=FLTARR(nchannels,nspectra,nphases)	& w_out=w_buf
			e_buf=FLTARR(nchannels,nspectra,nphases)	& e_out=e_buf
		ENDELSE

		nspect=INTARR(1)	& istar=nspect
		nspect(0)=nspectra
		istar(0)=istart

	ENDIF ELSE BEGIN
		nspect=INTARR(nruns)	& istar=nspect
		FOR irun=0,nruns-1 DO BEGIN	
			i=WHERE(x_in1(*,irun) LT 0.,count)

			IF (ibank EQ 0) THEN BEGIN
				istar(irun)=0
				nspect(irun)=count
			ENDIF ELSE IF (ibank EQ 1) THEN BEGIN
				istar(irun)=count
				nspect(irun)=nspectra-count
			ENDIF ELSE IF (ibank EQ 2) THEN BEGIN
				istar(irun)=0
				nspect(irun)=nspectra
			ENDIF ELSE IF (ibank GE -64 AND ibank LE -1) THEN BEGIN
				nspect(irun)=1
				IF (ana EQ 0) THEN istar(irun)=-ibank-1 ELSE  istar(irun)=-(ibank/2)-1
			ENDIF ELSE BEGIN
				PRINT,'Error - ibank=',ibank
				GOTO, finished
			ENDELSE
		ENDFOR

		IF (tof EQ 0) THEN BEGIN
			x_buf=FLTARR(TOTAL(nspect))	& x_out=x_buf	& y_out=INDGEN(nphases)
			w_buf=FLTARR(TOTAL(nspect),nphases)	& w_out=w_buf
			e_buf=FLTARR(TOTAL(nspect),nphases)	& e_out=e_buf
		ENDIF ELSE BEGIN
			y_buf=FLTARR(TOTAL(nspect))	& y_out=y_buf	& x_out=INDGEN(nchannels)
			w_buf=FLTARR(nchannels,TOTAL(nspect),nphases)	& w_out=w_buf
			e_buf=FLTARR(nchannels,TOTAL(nspect),nphases)	& e_out=e_buf
		ENDELSE
	ENDELSE

	coder=0

	IF (N_ELEMENTS(icoder) NE 0) THEN coder=icoder
	IF (coder EQ 1) THEN BEGIN
		IF (istar(0) LT 16/(ana+1)) THEN x_buf=datp.pv(16,*) $
		ELSE IF (istar(0) LT 32/(ana+1)) THEN x_buf=datp.pv(17,*) $
		ELSE IF (istar(0) LT 48/(ana+1)) THEN x_buf=datp.pv(18,*) $
					 ELSE x_buf=datp.pv(19,*)
	ENDIF
		
	IF (iprint GT 0) THEN PRINT,'End of "ibank and iPA setup" section'

;-------------------------------------------------------------------------------
;Rearrange w_in into w_buf

	FOR irun=0,nruns-1 DO BEGIN
		IF (irun EQ 0) THEN BEGIN
			is1=0
			is2=nspect(irun)-1
		ENDIF ELSE BEGIN
			is1=is2+1
			is2=is1+nspect(irun)-1
		ENDELSE
		FOR iphase=0,nphases-1 DO BEGIN
			IF (iprint GT 0) THEN BEGIN 
				PRINT,'irun=',irun,': Putting w_in(',istar(irun),':',istar(irun)+nspect(irun)-1,',',iphase,',',irun,')
				PRINT,'                 into w_buf(',is1,':',is2,',',iphase,')'
			ENDIF
			IF (tof EQ 0) THEN BEGIN
				w_buf(is1:is2,iphase)=w_in1(istar(irun):istar(irun)+nspect(irun)-1,iphase,irun)
				e_buf(is1:is2,iphase)=e_in1(istar(irun):istar(irun)+nspect(irun)-1,iphase,irun)
			ENDIF ELSE BEGIN
				w_buf(*,is1:is2,iphase)=w_in1(*,istar(irun):istar(irun)+nspect(irun)-1,iphase,irun)
				e_buf(*,is1:is2,iphase)=e_in1(*,istar(irun):istar(irun)+nspect(irun)-1,iphase,irun)
			ENDELSE
		ENDFOR
		IF (coder EQ 0) THEN BEGIN
			IF (tof EQ 0) THEN BEGIN
				x_buf(is1:is2)=ABS(x_in1(istar(irun):istar(irun)+nspect(irun)-1,irun))
			ENDIF ELSE BEGIN
				y_buf(is1:is2)=ABS(x_in1(istar(irun):istar(irun)+nspect(irun)-1,irun))
			ENDELSE
		ENDIF

	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of "rearrange w_in into w_buf" section'

;-------------------------------------------------------------------------------
;Rearrange w_buf into w_out

	IF (tof EQ 0) THEN BEGIN
		i=SORT(x_buf)
		x_out=x_buf(i)
        	xlim=SIZE(x_buf)
	ENDIF ELSE BEGIN
		i=SORT(y_buf)
		y_out=y_buf(i)
        	xlim=SIZE(y_buf)
	ENDELSE

	w_out=w_buf
	e_out=e_buf

	FOR inc=0,xlim(1)-1 DO BEGIN
	   	FOR iphase=0,nphases-1 DO BEGIN
			IF (tof EQ 0) THEN BEGIN
				w_out(inc,iphase)=w_buf(i(inc),iphase)
				e_out(inc,iphase)=e_buf(i(inc),iphase)
			ENDIF ELSE BEGIN
				w_out(*,inc,iphase)=w_buf(*,i(inc),iphase)
				e_out(*,inc,iphase)=e_buf(*,i(inc),iphase)
			ENDELSE
		ENDFOR
	ENDFOR

	IF (iprint GT 0) THEN PRINT,'End of "rearrange w_buf into w_out" section'

;-------------------------------------------------------------------------------
;Remove zeroed spectra

	IF (tof EQ 0) THEN x_buf=x_out ELSE y_buf=y_out
	w_buf=w_out
	e_buf=e_out

	IF (tof EQ 0) THEN BEGIN
		i=WHERE(w_out(*,0) NE 0. OR e_out GE 0.,count)
	ENDIF ELSE BEGIN
		i=WHERE(w_out(0,*,0) NE 0. OR e_out GE 0.,count)
	ENDELSE
	
	nspectra=count
	
	IF (tof EQ 0) THEN BEGIN
		x_out=FLTARR(nspectra)		& x_out=x_buf(i)
		w_out=FLTARR(nspectra,nphases)	& w_out=w_buf(i,*)
		e_out=FLTARR(nspectra,nphases)	& e_out=e_buf(i,*)
	ENDIF ELSE BEGIN
		y_out=FLTARR(nspectra*nphases)		& y_out=y_buf(i)
		w_out=FLTARR(nchannels,nspectra,nphases)	& w_out=w_buf(*,i,*)
		e_out=FLTARR(nchannels,nspectra,nphases)	& e_out=e_buf(*,i,*)
		w_out=REFORM(w_out,nchannels,nspectra*nphases)
		e_out=REFORM(e_out,nchannels,nspectra*nphases)
		IF (nphases EQ 2) THEN y_out=[y_out,y_out]
		IF (nphases EQ 3) THEN y_out=[y_out,y_out,y_out]
		IF (nphases EQ 6) THEN y_out=[y_out,y_out,y_out,y_out,y_out,y_out]		
	ENDELSE
	
	IF (iprint GT 0) THEN PRINT,'End of "remove zeroed spectra" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "x", x_out
	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	datp.p(1)=nspectra
	datp.p(3)=1

	datp.x_tit='Scattering Angle'
	IF (coder EQ 1) THEN datp.x_tit='Bank Angle'
	IF (tof EQ 1) THEN datp.x_tit='Time channel'
	datp.y_tit=datp.z_tit
	IF (tof EQ 1) THEN datp.y_tit='Scattering Angle'

	IF (ibank EQ 0) THEN s='negative angle detectors' $
	ELSE IF (ibank EQ 1) THEN s='positive angle detectors' $
	ELSE IF (ibank EQ 2) THEN s='all detectors' $
	ELSE BEGIN
		s='detector number '+STRTRIM(STRING(-ibank))
		IF (coder EQ 0) THEN s=s+' with detector angle as x-axis' $
				 ELSE s=s+' with coder angle as x-axis'
	ENDELSE
	PRINT,'Theta_scan: keep '+s

	datp.other_tit=datp.other_tit+' -ts('+STRTRIM(STRING(ibank),2)+')'
finished:

	IF (iprint GT 0) THEN PRINT,'End theta_scan:'

	give_datp, datp

	RETURN, w_out
	END
; Program/procedure for D20 PSD threshold calculation
; Programm "regseu3", 24.3.93 by Anton OED and Pierre CONVERT (BASIC)
; Modified 6.5.96 by Anton OED
; Procedure re-written for IDL/LAMP in February 1997 by Thomas HANSEN

PRO thresh, a,	thresh, boucle,$ ; a = counting rates, thresh = threshold values
              	fit=fit,tmin=tmin,tmax=tmax,marg=marg,start=start,sensibility=sens,$
              	x1=x1,w1=w1,x2=x2,w2=w2,flag=flag,printer=printer,$
              	noprint=noprint,$
              	var1=var1,var2=var2,damp=damp,prev=prev,p2=p2,p3=p3,$
		boxmean=boxmean, cellmean=cellmean,firstbox=firstbox,lastbox=lastbox
IF NOT KEYWORD_SET(marg)  THEN marg=10.
IF KEYWORD_SET(boxmean) AND KEYWORD_SET(marg) THEN BEGIN
	boxmarg=marg
	marg=0
ENDIF
IF NOT KEYWORD_SET(damp) THEN damp=1
a      = a(*,0)
olda=a
oldt=thresh
IF NOT KEYWORD_SET(prev) THEN prev=oldt 
IF NOT KEYWORD_SET(p2) THEN p2=prev 
IF NOT KEYWORD_SET(p3) THEN p3=p2 
ncan   = n_elements(a)                                ; number of detector cells
IF NOT KEYWORD_SET(start) THEN start=0
IF NOT KEYWORD_SET(sens)  THEN sens=fltarr(ncan+2)+1. ; sensibility, not yet implemented
IF NOT KEYWORD_SET(tmin)  THEN tmin=300.
IF NOT KEYWORD_SET(tmax)  THEN tmax=900.
IF N_ELEMENTS(boucle) eq 0  THEN boucle = 10          ; number of iterations0
IF N_ELEMENTS(flag) NE ncan THEN flag=intarr(ncan)
;------ corrections (detector borders etc.) -----------------------------------
a(0)            = 0
a(ncan-1)       = 0
sum1            = total(a(where(a,counts)))
moyen           = sum1 / counts
IF (N_ELEMENTS(fit) NE ncan) THEN a(where(a eq 0)) = moyen
sum1   = total(a)
abw    = SQRT (sum1 / ncan)   ; or square ?
mplus  = moyen + abw
mminus = moyen - abw

;-------------- max and min ---------------------------
min = min(a)
max = max(a)

;-------------- calculation ---------------------------
IF NOT KEYWORD_SET(var1) THEN var1=.0009                         ; as explained below  (changed 29. 8.96)
IF NOT KEYWORD_SET(var2) THEN var2=var1*0.32 ELSE var2=var1*var2 ; empirical values!!
a     = [moyen, a, moyen]     ; counting rates plus border dummy countings
thresh= [0.,thresh,0.]
IF (N_ELEMENTS(fit) EQ ncan) THEN fit = [0.,fit,0.]
mV    = a*0.0                 ; threshold variation in each loop
B     = a*0.0                 ; new neutron counting rate
ngain     = a*0.0             ; gain of neutron counting rate 
redis     = a*0.0             ; gain of neutron counting rate 
MV2   = a*0.0                 ; total threshold variation
FOR k = 1, boucle DO BEGIN
   FOR i = 2, ncan, 2 DO IF flag(i-1) NE -1 THEN BEGIN                          ;caneaux impair
        IF (N_ELEMENTS(fit) EQ ncan+2) THEN moyen = fit(i) 
        mV(i) = -(moyen - a(i)) / (var1 * a(i))
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          mV(i)=(thresh(i)+MV2(i))/interpol(x1,w1,a(i)/moyen)-(thresh(i)+MV2(i))
          ideal=mV(i)
          var1=-(interpol(w1,x1,1)-interpol(w1,x1,(thresh(i)+MV2(i))/(thresh(i)+MV2(i)+ideal)))/(interpol(x1,w1,moyen)-interpol(x1,w1,a(i)/moyen))
        ENDIF
        IF ((thresh(i)+MV2(i)+mV(i)) GE tmax) THEN mV(i) =  tmax - (thresh(i)+MV2(i))
        IF ((thresh(i)+MV2(i)+mV(i)) LE tmin) THEN mV(i) = -(thresh(i)+MV2(i) - tmin)
        IF ((thresh(i)+MV2(i)+mV(i)) LE thresh(i)+marg) AND ((thresh(i)+MV2(i)+mV(i)) GE thresh(i)-marg) THEN mV(i) = -MV2(i)
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          B(i)=moyen*interpol(w1,x1,(thresh(i)+MV2(i)+mV(i))/(thresh(i)+MV2(i)+ideal))
        ENDIF ELSE BEGIN
          B(i) = a(i) * (1- mV(i)*var1)                      ;stockage du can. i
        ENDELSE
        var2bak=var2
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) AND KEYWORD_SET(x2) AND KEYWORD_SET(w2) THEN BEGIN
          var2=    -interpol(x1,w1,a(i)/moyen)
          var2=var2+interpol(x2,w2,a(i)/moyen)$
                   +interpol(x1,w1,B(i)/moyen)$
                   -interpol(x2,w2,B(i)/moyen)
          var2=var2/2.
          var2=var2(0)
          var2=var2*(B(i)-a(i))/(B(i)+a(i))*2
        ENDIF ELSE var2=mV(i)*var2 
        ;IF mV(i) NE 0 THEN print,start+i,mV(i),var2,var2/mV(i),mV(i),var2/mV(i)/var1
        B(i-1) = a(i-1)+var2 * a(i - 1)
        redis(i-1)=redis (i-1)+B(i-1) -a(i-1)
        redis(i+1)=redis (i+1)+a(i+1)
        a(i+1) = a(i+1)+var2 * a(i + 1)  
        redis(i+1)=redis (i+1)-a(i+1)
        var2=var2bak
   ENDIF
   a(1:i-2) = B(1:i-2)                                  ;nouvelles val.
   FOR i = 1, ncan, 2 DO  IF flag(i-1) NE -1 THEN BEGIN                          ;caneaux pair
        IF (N_ELEMENTS(fit) EQ ncan+2) THEN moyen = fit(i) 
        mV(i) = -(moyen - a(i)) / (var1 * a(i))
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          mV(i)=(thresh(i)+MV2(i))/interpol(x1,w1,a(i)/moyen)-(thresh(i)+MV2(i))
          ideal=mV(i)
          var1=-(interpol(w1,x1,1)-interpol(w1,x1,(thresh(i)+MV2(i))/(thresh(i)+MV2(i)+ideal)))/(interpol(x1,w1,moyen)-interpol(x1,w1,a(i)/moyen))
        ENDIF
        IF ((thresh(i)+MV2(i)+mV(i)) GE tmax) THEN mV(i) =  tmax - (thresh(i)+MV2(i))
        IF ((thresh(i)+MV2(i)+mV(i)) LE tmin) THEN mV(i) = -(thresh(i)+MV2(i) - tmin)
        IF ((thresh(i)+MV2(i)+mV(i)) LE thresh(i)+marg) AND ((thresh(i)+MV2(i)+mV(i)) GE thresh(i)-marg) THEN mV(i) = -MV2(i)
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          B(i)=moyen*interpol(w1,x1,(thresh(i)+MV2(i)+mV(i))/(thresh(i)+MV2(i)+ideal))
        ENDIF ELSE BEGIN
          B(i) = a(i) * (1- mV(i)*var1)                      ;stockage du can. i
        ENDELSE
        var2bak=var2
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) AND KEYWORD_SET(x2) AND KEYWORD_SET(w2) THEN BEGIN
          var2=    -interpol(x1,w1,a(i)/moyen)
          var2=var2+interpol(x2,w2,a(i)/moyen)$
                   +interpol(x1,w1,B(i)/moyen)$
                   -interpol(x2,w2,B(i)/moyen)
          var2=var2/2.
          var2=var2(0)
          var2=var2*(B(i)-a(i))/(B(i)+a(i))*2
        ENDIF ELSE var2=mV(i)*var2 
        ;IF mV(i) NE 0 THEN print,start+i,mV(i),var2,var2/mV(i),mV(i),var2/mV(i)/var1
        B(i-1) = a(i-1)+var2 * a(i - 1)
        redis(i-1)=redis (i-1)+B(i-1) -a(i-1)
        redis(i+1)=redis (i+1)+a(i+1)
        a(i+1) = a(i+1)+var2 * a(i + 1)  
        redis(i+1)=redis (i+1)-a(i+1)
        var2=var2bak
   ENDIF
   a(0:i-2) = B(0:i-2)                                  ;nouvelles val.
   MV2 = MV2 + mV                                       ;sum des variations
   ;plot,MV2(1:ncan)
ENDFOR
sum2 = total(a(1:ncan))
mmax = max (ABS(MV2(1:ncan)))
PRINT,"New total counting and maximal threshold shift: ", sum2,mmax

;---- presentation du spectre effectuer par la changement des seuils
a      = a(1:ncan)            ; new counting rates minus dummy cells
ngain  = ngain(1:ncan)
tgain  =a-olda
ngain  =tgain-redis
thresh = thresh(1:ncan)
IF (N_ELEMENTS(fit) EQ ncan+2) THEN fit=fit(1:ncan)

;------- presentation de la variation des seuils ------------------
MV2 = MV2(1:ncan)         ; total threshold variation in mV minus dummy values
;plot,MV2
thresh = thresh + MV2/damp     ; new threshold values (optional output)

;------- output for printer ------------------
OPENW,out,'threshold.out',/get_lun
IF NOT KEYWORD_SET(firstbox) THEN firstbox=1
IF NOT KEYWORD_SET(lastbox)  THEN lastbox =1
IF KEYWORD_SET(boxmean) THEN BEGIN
	marg=boxmarg
	FOR i=0,ncan/32-1 DO BEGIN
		thresh(i*32:i*32+31)=thresh(i*32:i*32+31)/mean(thresh(i*32:i*32+31))*boxmean
	ENDFOR
ENDIF
IF KEYWORD_SET(cellmean) THEN BEGIN
	marg=boxmarg
	meancell=fltarr(32)
	FOR i=firstbox*32,lastbox*32+31 DO BEGIN
		meancell(i mod 32)=meancell(i mod 32)+thresh(i)
	ENDFOR
	FOR i=0,15 DO BEGIN
		meancell(i)=meancell(i)+meancell(31-i)
	ENDFOR
	FOR i=0,15 DO BEGIN
		meancell(31-i)=meancell(i)
	ENDFOR
	meancell=meancell/(lastbox-firstbox+1)/2
	FOR i=0,ncan-1 DO BEGIN
		thresh(i)=thresh(i)/meancell(i mod 32)*cellmean
	ENDFOR
ENDIF
IF KEYWORD_SET(cellmean) OR KEYWORD_SET(boxmean) THEN BEGIN
	FOR i=0,ncan-1 DO BEGIN
		IF ABS(thresh(i)-oldt(i)) LE marg THEN BEGIN
			thresh(i)=oldt(i)
		ENDIF
	ENDFOR
	FOR i=0,ncan-1 DO MV2(i)=thresh(i)-oldt(i)
ENDIF
cellstotouch=0
FOR j=0,ncan-1 DO BEGIN
   IF round(thresh(j)) NE round(oldt(j)) THEN cellstotouch=cellstotouch+1
   i=start+j
   format='("??",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") Err",F8.3," (",F8.3,")")'
   IF MV2(j) GT 0 THEN format='("**",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") +++",F8.3," (",F8.3,")")'
   IF MV2(j) LT 0 THEN format='("**",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") ---",F8.3," (",F8.3,")")'
   IF round(thresh(j)) GE ROUND(tmax)    THEN format='("++",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") max",F8.3," (",F8.3,")")'
   IF round(thresh(j)) LE ROUND(tmin)    THEN format='("--",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") min",F8.3," (",F8.3,")")'
   IF round(thresh(j)) EQ ROUND(oldt(j)) THEN format='("  ",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,")    ",F8.3," (",F8.3,")")'
   IF (i MOD 32) EQ 0 THEN BEGIN
	printf,out
	printf,out
	print
	print,'Box:',j/32,': ','average:',mean(thresh(j:j+31)),' mV'
	printf,out,'Box',j/32,': average ',mean(thresh(j:j+31)),' mV'
   ENDIF
   IF (i MOD 64) EQ 0 THEN BEGIN
	;printf,out
   ENDIF
   IF (i MOD 32) EQ 0 THEN BEGIN
	printf,out,"  cell bx no  new   old prev   p1  p2     new count  old count"
   ENDIF
   IF ((i/32) MOD 2) EQ 0 THEN BEGIN
    printf,out,FORMAT=format,i,i/32,31-(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDIF ELSE BEGIN
    printf,out,FORMAT=format,i,i/32,(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDELSE
   IF ((i/32) MOD 2) EQ 0 THEN BEGIN
    print,     FORMAT=format,i,i/32,31-(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDIF ELSE BEGIN
    print,     FORMAT=format,i,i/32,(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDELSE
ENDFOR
CLOSE,out
FREE_LUN,out

thresh=round(thresh)

IF NOT KEYWORD_SET(printer) THEN line='$lp threshold.out' ELSE line='$lp -d'+printer+' threshold.out'
if NOT keyword_set(noprint) THEN  XICUTE,line 

IF KEYWORD_SET(cellmean) THEN BEGIN
	;FOR i=0,31 DO BEGIN
	;	PRINT,i,meancell(i)
	;ENDFOR
	;FOR i=firstbox*32,lastbox*32+31 DO BEGIN
	;	PRINT,i, thresh(i)
	;ENDFOR
ENDIF
print,cellstotouch,' cells to be adjusted'
END
 ;w8=w6&w9=w7&thresh,w8,w9,/noprint,var1=0.0009,var2=0.05,start=400
;Lamp> w12=w1
;w12: Float   dim = 1600 min=0.00000 max=305575.
;Lamp> w13=w2
;w13: Float   dim = 1600 min=300.000 max=900.000
;Lamp> w3=w1&w4=w2&thresh,w3,w4,50,fit=w5,flag=w14,marg=25,tmin=300,tmax=1000,/noprint
; Program/procedure for D20 PSD threshold calculation
; Programm "regseu3", 24.3.93 by Anton OED and Pierre CONVERT (BASIC)
; Modified 6.5.96 by Anton OED
; Procedure re-written for IDL/LAMP in February 1997 by Thomas HANSEN

PRO threshold, a, thresh, boucle            ; a = counting rates, thresh = threshold values

a      = a(*,0)
ncan   = n_elements(a)                       ; number of detector cells
IF N_ELEMENTS(boucle) eq 0 THEN boucle = 50                                              ; number of iterations0
PRINT, "Procedure for threshold adjustment of D20's PSD"
PRINT, "DO NOT effectuate 'pretreat' before!"
PRINT, "Each zero-counting cell is considered as 'parasited' and will be set"
PRINT, "to the mean value for the counting rate which is calculated by all"
PRINT, "non-zero counting cells. You may mark any parasite-affected cell as"
PRINT, "zero counting (e.g. W6(234)=0 for cell 234 parasite-affected)."
PRINT, "After this 'correction' the counting rates of the border cells are set"
PRINT, "to the mean value, and two additional dummy cells are added on the border"
PRINT, "with the same counting rate."
PRINT, "Parameters: counting rates, old thresholds (optional) : will be changed!"
PRINT, "            number of loops (optional) : not to be changed"

;------ corrections (detector borders etc.) -----------------------------------
a(0)            = 0
a(ncan-1)       = 0
sum1            = total(a(where(a,counts)))
moyen           = sum1 / counts
a(where(a eq 0)) = moyen
sum1   = total(a)
abw    = SQRT (sum1 / ncan)   ; or square ?
mplus  = moyen + abw
mminus = moyen - abw

;-------------- max and min ---------------------------
min = min(a)
max = max(a)

;-------------- calculation ---------------------------
var1 = .0011                  ; as explained below  (changed 29. 8.96)
var2 = var1 / 5               ; empirical values!!
a     = [moyen, a, moyen]     ; counting rates plus border dummy countings
mV    = a*0.0                 ; threshold variation in each loop
B     = a*0.0                 ; new neutron counting rate
MV2   = a*0.0                 ; total threshold variation
FOR k = 1, boucle DO BEGIN
   FOR i = 2, ncan, 2 DO BEGIN                          ;caneaux impair
        mV(i) = -(moyen - a(i)) / (var1 * a(i))         ;apres [ 1 ]
        B(i) = moyen                                    ;stockage du can. i
        B(i - 1) = a(i - 1) + (var2) * a(i - 1) * mV(i) ;apres [ 2 ] can i-1
        a(i + 1) = a(i + 1) + (var2) * a(i + 1) * mV(i) ;apres [ 2 ] can i+1
   ENDFOR
   a(1:i-2) = B(1:i-2)                                  ;nouvelles val.
   FOR i = 1, ncan, 2 DO BEGIN                          ;caneaux pair
        mV(i) = -(moyen - a(i)) / (var1 * a(i))
        B(i) = moyen
        B(i - 1) = a(i - 1) + (var2) * a(i - 1) * mV(i) ;apres [ 2 ] can i-1
        a(i + 1) = a(i + 1) + (var2) * a(i + 1) * mV(i) ;apres [ 2 ] can i+1
   ENDFOR
   a(0:i-2) = B(0:i-2)                                  ;nouvelles val.
   MV2 = MV2 + mV                                       ;sum des variations
   plot,MV2(1:ncan)
ENDFOR
sum2 = total(a(1:ncan))
mmax = max (ABS(MV2(1:ncan)))
PRINT,"New total counting and maximal threshold shift: ", sum2,mmax

;---- presentation du spectre effectuer par la changement des seuils
a = a(1:ncan)            ; new counting rates minus dummy cells

;------- presentation de la variation des seuils ------------------
MV2 = MV2(1:ncan)         ; total threshold variation in mV minus dummy values
plot,MV2
thresh = thresh + MV2     ; new threshold values (optional output)

END

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;Soubrotines
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; calcul: pour regler les seuils d'un detecteur pour recevoir une
;         reponse egale pour chaque canal.
;         Voraussetzung:
;         Le detecteur soit illuminer uniform
;         les valeurs des seuils et le comptage de chaque canal sont connue.
;         Cettes valeurs doivent disponible dans deux fichier
; Soit:
; Va = contenue actuell mesure d'un canal et
; Vs = continue du meme canal apres une changemente du seuil de dx mV
; Apres Taylor le nouveau comptage est une premier ordre:
;
;                   Vs= Va- var1* Va * dx     [ 1 ]
;
; avec la constante var1  [1/mV]
; Cette constante var1 est a determiner par une calibrage:
; en changant le seuil d'un  canal et enregister les different comptage.
; apres [ 1 ] la constante de variation est  donne par:
;
;                     var1 = -(Vs - Va) / (dx * Va) [ 2 ]
;
;------------------
; A cause de cette de variation de comptage, des caneaux voisins devoient
; aussi changes. Leurs nouveaux comptages Vs soient proportionelle au
; comptage Va avant cette changement et partiellement proportionelle au
; constante var1. Avec la methode des elements finis le calcul prend d'abord
; en compte les caneaux pairs et apres dans un deuxieme pas les caneaux unpairs
; Le constante soit alors : var2 = var1 /4.
; Le comptage des caneaux voisines est:
;
;            ===>  Vs=Va+ var2*Va * dx    [ 3 ]
;
; Apres une certaine nombre des boucles de cet calcul les valeurs de comptage ce
; stabilisees au valeur moyen de comptage, qui est connue.
;
; Les resultats, pour mesuree dans chaque canal le comptage moyen,
; les nouveaux valeurs des seuils seront imprimer,
; et en meme temps stocker dans en fichier, pour repeter cette procedure
; plus tard.
;--------------------------------------------------
; Pour le proto type de D20 avec 3,1 b He(3) + 0,9 bar CF4
; avec les tensions: Uac= 940 V; Uc = 400 V et Ud = 620 V
; la variation var1 etait mesure avec le canal Nr. 48 = pos1 ampli 15
;         seuils en mV      comptage/min
;                600            2086
;                800            1823
;               1000            1707
;               1200            1616
;               1400            1445
;
;apres [ 2 ] la constante de variation est  donne par
;                     var1 = -(Vs - Va) / (dx * Va)
;et pour les valeur mesures pour le proto type cette constante a
;le valeur moyen de
;                     var1= 3,85 E-4
;-----------------------------------------------------------------

; Program/procedure for D20 PSD threshold calculation
; Programm "regseu3", 24.3.93 by Anton OED and Pierre CONVERT (BASIC)
; Modified 6.5.96 by Anton OED
; Procedure re-written for IDL/LAMP in February 1997 by Thomas HANSEN

PRO thresh, a,	thresh, boucle,$ ; a = counting rates, thresh = threshold values
              	fit=fit,tmin=tmin,tmax=tmax,marg=marg,start=start,sensibility=sens,$
              	x1=x1,w1=w1,x2=x2,w2=w2,flag=flag,printer=printer,$
              	noprint=noprint,$
              	var1=var1,var2=var2,damp=damp,prev=prev,p2=p2,p3=p3,$
		boxmean=boxmean, cellmean=cellmean,firstbox=firstbox,lastbox=lastbox
IF NOT KEYWORD_SET(marg)  THEN marg=10.
IF KEYWORD_SET(boxmean) AND KEYWORD_SET(marg) THEN BEGIN
	boxmarg=marg
	marg=0
ENDIF
IF NOT KEYWORD_SET(damp) THEN damp=1
a      = a(*,0)
olda=a
oldt=thresh
IF NOT KEYWORD_SET(prev) THEN prev=oldt 
IF NOT KEYWORD_SET(p2) THEN p2=prev 
IF NOT KEYWORD_SET(p3) THEN p3=p2 
ncan   = n_elements(a)                                ; number of detector cells
IF NOT KEYWORD_SET(start) THEN start=0
IF NOT KEYWORD_SET(sens)  THEN sens=fltarr(ncan+2)+1. ; sensibility, not yet implemented
IF NOT KEYWORD_SET(tmin)  THEN tmin=300.
IF NOT KEYWORD_SET(tmax)  THEN tmax=900.
IF N_ELEMENTS(boucle) eq 0  THEN boucle = 10          ; number of iterations0
IF N_ELEMENTS(flag) NE ncan THEN flag=intarr(ncan)
;------ corrections (detector borders etc.) -----------------------------------
a(0)            = 0
a(ncan-1)       = 0
sum1            = total(a(where(a,counts)))
moyen           = sum1 / counts
IF (N_ELEMENTS(fit) NE ncan) THEN a(where(a eq 0)) = moyen
sum1   = total(a)
abw    = SQRT (sum1 / ncan)   ; or square ?
mplus  = moyen + abw
mminus = moyen - abw

;-------------- max and min ---------------------------
min = min(a)
max = max(a)

;-------------- calculation ---------------------------
IF NOT KEYWORD_SET(var1) THEN var1=.0009                         ; as explained below  (changed 29. 8.96)
IF NOT KEYWORD_SET(var2) THEN var2=var1*0.32 ELSE var2=var1*var2 ; empirical values!!
a     = [moyen, a, moyen]     ; counting rates plus border dummy countings
thresh= [0.,thresh,0.]
IF (N_ELEMENTS(fit) EQ ncan) THEN fit = [0.,fit,0.]
mV    = a*0.0                 ; threshold variation in each loop
B     = a*0.0                 ; new neutron counting rate
ngain     = a*0.0             ; gain of neutron counting rate 
redis     = a*0.0             ; gain of neutron counting rate 
MV2   = a*0.0                 ; total threshold variation
FOR k = 1, boucle DO BEGIN
   FOR i = 2, ncan, 2 DO IF flag(i-1) NE -1 THEN BEGIN                          ;caneaux impair
        IF (N_ELEMENTS(fit) EQ ncan+2) THEN moyen = fit(i) 
        mV(i) = -(moyen - a(i)) / (var1 * a(i))
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          mV(i)=(thresh(i)+MV2(i))/interpol(x1,w1,a(i)/moyen)-(thresh(i)+MV2(i))
          ideal=mV(i)
          var1=-(interpol(w1,x1,1)-interpol(w1,x1,(thresh(i)+MV2(i))/(thresh(i)+MV2(i)+ideal)))/(interpol(x1,w1,moyen)-interpol(x1,w1,a(i)/moyen))
        ENDIF
        IF ((thresh(i)+MV2(i)+mV(i)) GE tmax) THEN mV(i) =  tmax - (thresh(i)+MV2(i))
        IF ((thresh(i)+MV2(i)+mV(i)) LE tmin) THEN mV(i) = -(thresh(i)+MV2(i) - tmin)
        IF ((thresh(i)+MV2(i)+mV(i)) LE thresh(i)+marg) AND ((thresh(i)+MV2(i)+mV(i)) GE thresh(i)-marg) THEN mV(i) = -MV2(i)
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          B(i)=moyen*interpol(w1,x1,(thresh(i)+MV2(i)+mV(i))/(thresh(i)+MV2(i)+ideal))
        ENDIF ELSE BEGIN
          B(i) = a(i) * (1- mV(i)*var1)                      ;stockage du can. i
        ENDELSE
        var2bak=var2
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) AND KEYWORD_SET(x2) AND KEYWORD_SET(w2) THEN BEGIN
          var2=    -interpol(x1,w1,a(i)/moyen)
          var2=var2+interpol(x2,w2,a(i)/moyen)$
                   +interpol(x1,w1,B(i)/moyen)$
                   -interpol(x2,w2,B(i)/moyen)
          var2=var2/2.
          var2=var2(0)
          var2=var2*(B(i)-a(i))/(B(i)+a(i))*2
        ENDIF ELSE var2=mV(i)*var2 
        ;IF mV(i) NE 0 THEN print,start+i,mV(i),var2,var2/mV(i),mV(i),var2/mV(i)/var1
        B(i-1) = a(i-1)+var2 * a(i - 1)
        redis(i-1)=redis (i-1)+B(i-1) -a(i-1)
        redis(i+1)=redis (i+1)+a(i+1)
        a(i+1) = a(i+1)+var2 * a(i + 1)  
        redis(i+1)=redis (i+1)-a(i+1)
        var2=var2bak
   ENDIF
   a(1:i-2) = B(1:i-2)                                  ;nouvelles val.
   FOR i = 1, ncan, 2 DO  IF flag(i-1) NE -1 THEN BEGIN                          ;caneaux pair
        IF (N_ELEMENTS(fit) EQ ncan+2) THEN moyen = fit(i) 
        mV(i) = -(moyen - a(i)) / (var1 * a(i))
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          mV(i)=(thresh(i)+MV2(i))/interpol(x1,w1,a(i)/moyen)-(thresh(i)+MV2(i))
          ideal=mV(i)
          var1=-(interpol(w1,x1,1)-interpol(w1,x1,(thresh(i)+MV2(i))/(thresh(i)+MV2(i)+ideal)))/(interpol(x1,w1,moyen)-interpol(x1,w1,a(i)/moyen))
        ENDIF
        IF ((thresh(i)+MV2(i)+mV(i)) GE tmax) THEN mV(i) =  tmax - (thresh(i)+MV2(i))
        IF ((thresh(i)+MV2(i)+mV(i)) LE tmin) THEN mV(i) = -(thresh(i)+MV2(i) - tmin)
        IF ((thresh(i)+MV2(i)+mV(i)) LE thresh(i)+marg) AND ((thresh(i)+MV2(i)+mV(i)) GE thresh(i)-marg) THEN mV(i) = -MV2(i)
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) THEN BEGIN
          B(i)=moyen*interpol(w1,x1,(thresh(i)+MV2(i)+mV(i))/(thresh(i)+MV2(i)+ideal))
        ENDIF ELSE BEGIN
          B(i) = a(i) * (1- mV(i)*var1)                      ;stockage du can. i
        ENDELSE
        var2bak=var2
        IF KEYWORD_SET(x1) AND KEYWORD_SET(w1) AND KEYWORD_SET(x2) AND KEYWORD_SET(w2) THEN BEGIN
          var2=    -interpol(x1,w1,a(i)/moyen)
          var2=var2+interpol(x2,w2,a(i)/moyen)$
                   +interpol(x1,w1,B(i)/moyen)$
                   -interpol(x2,w2,B(i)/moyen)
          var2=var2/2.
          var2=var2(0)
          var2=var2*(B(i)-a(i))/(B(i)+a(i))*2
        ENDIF ELSE var2=mV(i)*var2 
        ;IF mV(i) NE 0 THEN print,start+i,mV(i),var2,var2/mV(i),mV(i),var2/mV(i)/var1
        B(i-1) = a(i-1)+var2 * a(i - 1)
        redis(i-1)=redis (i-1)+B(i-1) -a(i-1)
        redis(i+1)=redis (i+1)+a(i+1)
        a(i+1) = a(i+1)+var2 * a(i + 1)  
        redis(i+1)=redis (i+1)-a(i+1)
        var2=var2bak
   ENDIF
   a(0:i-2) = B(0:i-2)                                  ;nouvelles val.
   MV2 = MV2 + mV                                       ;sum des variations
   ;plot,MV2(1:ncan)
ENDFOR
sum2 = total(a(1:ncan))
mmax = max (ABS(MV2(1:ncan)))
PRINT,"New total counting and maximal threshold shift: ", sum2,mmax

;---- presentation du spectre effectuer par la changement des seuils
a      = a(1:ncan)            ; new counting rates minus dummy cells
ngain  = ngain(1:ncan)
tgain  =a-olda
ngain  =tgain-redis
thresh = thresh(1:ncan)
IF (N_ELEMENTS(fit) EQ ncan+2) THEN fit=fit(1:ncan)

;------- presentation de la variation des seuils ------------------
MV2 = MV2(1:ncan)         ; total threshold variation in mV minus dummy values
;plot,MV2
thresh = thresh + MV2/damp     ; new threshold values (optional output)

;------- output for printer ------------------
OPENW,out,'threshold.out',/get_lun
IF NOT KEYWORD_SET(firstbox) THEN firstbox=1
IF NOT KEYWORD_SET(lastbox)  THEN lastbox =1
IF KEYWORD_SET(boxmean) THEN BEGIN
	marg=boxmarg
	FOR i=0,ncan/32-1 DO BEGIN
		thresh(i*32:i*32+31)=thresh(i*32:i*32+31)/mean(thresh(i*32:i*32+31))*boxmean
	ENDFOR
ENDIF
IF KEYWORD_SET(cellmean) THEN BEGIN
	marg=boxmarg
	meancell=fltarr(32)
	FOR i=firstbox*32,lastbox*32+31 DO BEGIN
		meancell(i mod 32)=meancell(i mod 32)+thresh(i)
	ENDFOR
	FOR i=0,15 DO BEGIN
		meancell(i)=meancell(i)+meancell(31-i)
	ENDFOR
	FOR i=0,15 DO BEGIN
		meancell(31-i)=meancell(i)
	ENDFOR
	meancell=meancell/(lastbox-firstbox+1)/2
	FOR i=0,ncan-1 DO BEGIN
		thresh(i)=thresh(i)/meancell(i mod 32)*cellmean
	ENDFOR
ENDIF
IF KEYWORD_SET(cellmean) OR KEYWORD_SET(boxmean) THEN BEGIN
	FOR i=0,ncan-1 DO BEGIN
		IF ABS(thresh(i)-oldt(i)) LE marg THEN BEGIN
			thresh(i)=oldt(i)
		ENDIF
	ENDFOR
	FOR i=0,ncan-1 DO MV2(i)=thresh(i)-oldt(i)
ENDIF
cellstotouch=0
FOR j=0,ncan-1 DO BEGIN
   IF round(thresh(j)) NE round(oldt(j)) THEN cellstotouch=cellstotouch+1
   i=start+j
   format='("??",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") Err",F8.3," (",F8.3,")")'
   IF MV2(j) GT 0 THEN format='("**",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") +++",F8.3," (",F8.3,")")'
   IF MV2(j) LT 0 THEN format='("**",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") ---",F8.3," (",F8.3,")")'
   IF round(thresh(j)) GE ROUND(tmax)    THEN format='("++",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") max",F8.3," (",F8.3,")")'
   IF round(thresh(j)) LE ROUND(tmin)    THEN format='("--",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,") min",F8.3," (",F8.3,")")'
   IF round(thresh(j)) EQ ROUND(oldt(j)) THEN format='("  ",I4,I3,I3,I5," (",I4,",",I4,",",I4,",",I4,")    ",F8.3," (",F8.3,")")'
   IF (i MOD 32) EQ 0 THEN BEGIN
	printf,out
	printf,out
	print
	print,'Box:',j/32,': ','average:',mean(thresh(j:j+31)),' mV'
	printf,out,'Box',j/32,': average ',mean(thresh(j:j+31)),' mV'
   ENDIF
   IF (i MOD 64) EQ 0 THEN BEGIN
	;printf,out
   ENDIF
   IF (i MOD 32) EQ 0 THEN BEGIN
	printf,out,"  cell bx no  new   old prev   p1  p2     new count  old count"
   ENDIF
   IF ((i/32) MOD 2) EQ 0 THEN BEGIN
    printf,out,FORMAT=format,i,i/32,31-(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDIF ELSE BEGIN
    printf,out,FORMAT=format,i,i/32,(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDELSE
   IF ((i/32) MOD 2) EQ 0 THEN BEGIN
    print,     FORMAT=format,i,i/32,31-(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDIF ELSE BEGIN
    print,     FORMAT=format,i,i/32,(i MOD 32),round(thresh(j)),round(oldt(j)),round(prev(j)),round(p2(j)),round(p3(j)),a(j),olda(j) 
   ENDELSE
ENDFOR
CLOSE,out
FREE_LUN,out

thresh=round(thresh)

IF NOT KEYWORD_SET(printer) THEN line='$lp threshold.out' ELSE line='$lp -d'+printer+' threshold.out'
if NOT keyword_set(noprint) THEN  XICUTE,line 

IF KEYWORD_SET(cellmean) THEN BEGIN
	;FOR i=0,31 DO BEGIN
	;	PRINT,i,meancell(i)
	;ENDFOR
	;FOR i=firstbox*32,lastbox*32+31 DO BEGIN
	;	PRINT,i, thresh(i)
	;ENDFOR
ENDIF
print,cellstotouch,' cells to be adjusted'
END
 ;w8=w6&w9=w7&thresh,w8,w9,/noprint,var1=0.0009,var2=0.05,start=400
;Lamp> w12=w1
;w12: Float   dim = 1600 min=0.00000 max=305575.
;Lamp> w13=w2
;w13: Float   dim = 1600 min=300.000 max=900.000
;Lamp> w3=w1&w4=w2&thresh,w3,w4,50,fit=w5,flag=w14,marg=25,tmin=300,tmax=1000,/noprint
FUNCTION tif2charge,tif,r=r,g=g,b=b

IF NOT KEYWORD_SET(r) THEN r=1./255.
IF NOT KEYWORD_SET(b) THEN b=-1./255.
IF NOT KEYWORD_SET(g) THEN g=-r-b
image=tif
xdim=N_ELEMENTS(image[0,*,0])
ydim=N_ELEMENTS(image[0,0,*])
dim=xdim*ydim

image=REFORM(image[0,*,*]*r,xdim,ydim)+REFORM(image[1,*,*]*g,xdim,ydim)+REFORM(image[2,*,*]*b,xdim,ydim)
charge=LONARR(4,dim)
charge[3,*]=ROUND(REFORM(image,dim))
charge[2,*]=0L
image=LINDGEN(dim)
charge[0,*]=image mod xdim
charge[1,*]=image  /  xdim
return,charge 

END
; A Library of time functions

; Mark McCrum


FUNCTION sec2time, secs		;This function converts a time in seconds to
;**********************		;one in days hours minutes and seconds. The
				;return format is [days, hours, mins, secs]
	mins=LONG(secs/60)
	secs=secs MOD 60
	hours=LONG(mins/60)
	mins=mins MOD 60
	days=LONG(hours/24)
	hours=hours MOD 24

	time=[days, hours,mins,secs]
RETURN, time
END

FUNCTION addTime, t1, t2	;Adds two times in the format [days, mins,hours,secs]	
;***********************	;returns in the same format

	ss=t1(3)+t2(3)
	sm=t1(2)+t2(2)
	sh=t1(1)+t2(1)
	sd=t1(0)+t2(0)

	IF ss GE 60 THEN BEGIN 	
			  ss=ss-60  
			  sm=sm+1
			 END
	IF sm GE 60 THEN BEGIN  
			  sm=sm-60
			  sh=sh+1
			 END

	IF sh GE 24 THEN BEGIN 
			  sh=sh-24
			  sd=sd+1
			 END
	RETURN, [sd,sh,sm,ss]
END

FUNCTION timeAfter, start, duration	;start is a time in format returned by the IDL
;********************************** 	 BIN_DATE function. Duration is some time in
					;the format [days,hours,mins,secs]. timeAfter
					;returns what the time will be 'duration' after
				        ; 'start'. Return format is same as for start
					; parameter

	;calculate julian day at start
	julianStart=julday(start(1),start(2),start(0))	
	
	;do the addition using the julian day instead of day of
	;month (makes life much easier)
	timeSum=addTime([julianStart,[start(3:5)]], duration)

	;Now work out the resulting calendar date by converting the julian day
	caldat, timeSum(0), month, day, year

	RETURN, [year, month, day, timeSum(1), timeSum(2), timeSum(3)]

END

FUNCTION now		;Returns the system time and date in BIN_DATE format
;************
	RETURN, bin_date(systime(0))
END 

FUNCTION time2string, time	;Coverts date in BIN_DATE format back to a 
;*************************	;string

	monthYear=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov', $
		   'Dec']
	month=monthYear(time(1)-1)
	text=month+STRING(time(2))+STRING(time(3))+':'+$
			STRING(time(4))+':'+STRING(time(5))
	text=STRCOMPRESS(text)
RETURN, text
END

PRO time
	PRINT, 'time.pro: library loaded'
END
PRO titcat,num0,num1
datp=1
OPENW,tit,'titl_'+strcompress(num0,/re)+'_'+strcompress(num1,/re)+'.cat',/get_lun
OPENW,tem,'temp_'+strcompress(num0,/re)+'_'+strcompress(num1,/re)+'.cat',/get_lun
printf,tem,'# Numor     T(s.p.)/K    T(reg.)/K  T(sample)/K     Monitor  time/(s/100) total cnts.'
printf,tem,'# Numor  T(s.p.)  T(reg.) T(sample) Monitor time/(s/100) total cnts.'
for num=num0, num1 do begin
    w=rdrun(num,datp=datp)
    printf,tit,strcompress(num),' ',datp.w_tit
    printf,tit,'       ',datp.other_tit,strcompress([datp.p(5:7),datp.n(0:1),total(w)])
    printf,tem,FORMAT = '(1i7,3f9.2,3i12)',num,datp.p(5:7),datp.n(0:1),total(w)
    print,strcompress(num),' ',datp.w_tit
    print,'       ',datp.other_tit,strcompress([datp.p(5:7),datp.n(0:1),total(w)])
    print,FORMAT = '(1i7,3f9.2,3i12)',num,datp.p(5:7),datp.n(0:1),total(w)
endfor
free_lun,tit
free_lun,tem
end
pro titles,maxi=maxi,list=final,high=high,low=low

common C_LAMP_ACCESS
common C_LAMP

IF NOT KEYWORD_SET(maxi) THEN maxi=100
IF NOT KEYWORD_SET(maxi) THEN maxi=100
inst=STRLOWCASE(INST_VALUE)
length=STRLEN(PATH_FOR_ONLINE+inst+'_'+LAMP_DVD)+1
PRINT,PATH_FOR_ONLINE
IF N_ELEMENTS(final) LT 1 THEN FOR i=0,9 DO BEGIN
 FOR j=100,199 DO BEGIN
  list=FINDFILE(PATH_FOR_ONLINE+inst+'_'+STRCOMPRESS(i,/REMOVE)+LAMP_DVD+'??'+STRMID(STRCOMPRESS(j,/REMOVE),1,2)+'??',count=count)
  IF count GT 0 THEN BEGIN
    list=STRCOMPRESS(STRMID(list,length,6),/remove)
    IF N_ELEMENTS(final) GE 1 THEN final=[final,list] ELSE final=list
  ENDIF
 ENDFOR
 PRINT,i,N_ELEMENTS(final)
ENDFOR
IF N_ELEMENTS(final) LE 0 THEN  FOR j=100,199 DO BEGIN
  final=FINDFILE(PATH_FOR_ONLINE+inst+'_'+STRCOMPRESS(i,/REMOVE)+LAMP_DVD+'??'+STRMID(STRCOMPRESS(j,/REMOVE),1,2)+'??',count=count)
ENDFOR
datp=1
list=final
IF KEYWORD_SET(high) THEN list=list(WHERE(LONG(list) LE high)) 
IF KEYWORD_SET(low)  THEN list=list(WHERE(LONG(list) GE low)) 
FOR i=N_ELEMENTS(list)-1,(N_ELEMENTS(list)-maxi)>0,-1 DO BEGIN
  w=rdrun(LONG(list(i)),datp=datp)
  PRINT,list(i),' ',datp.other_tit,datp.w_tit
ENDFOR
END
;*******************
pro TOF_EVENT, event

    WIDGET_CONTROL,event.top,GET_UVALUE= P
    WIDGET_CONTROL,event.id ,GET_VALUE = scale
    TOF_PLOT ,P.W , P.X,P.Y , P.ID , P.MIN , P.MAX*scale/100.
RETURN
END

;***********************************************
pro TOF_PLOT, wksp , x,y , draw_id , mini , maxi

    old_id =!D.WINDOW
    WSET   , draw_id
    SURFACE, wksp,x,y,ZRANGE =[mini,maxi],/HORIZONTAL,AX=55.,AZ=0.,ZSTYLE=4,$
    		      XMARGIN=[2,2],YMARGIN =[2,2],BACKGROUND=255 ,COLOR =0,$
    		      XTICKLEN=1.,XGRIDSTYLE=1
    WSET   , old_id
RETURN
END

;***************************
pro TOF, win , group , width

    s = SIZE(win)
    IF  s(0) EQ 2 THEN BEGIN
	IF  N_ELEMENTS(group) EQ 0 THEN group= 6
	IF  N_ELEMENTS(width) EQ 0 THEN width= 40
	wksp = LINEUP (win,elas)
	a1   = (elas-width)>0
	a2   = (elas+width)<(s(1)-1)
	wksp = SMOOTH (CONGRID(wksp(a1:a2,*), width*2+1,group<s(2) ),3)
	maxi = MAX    (wksp , MIN=mini)
	x    = INDGEN (width*2+1)-width
	y    = INDGEN (group) +1
	
	base = WIDGET_BASE  (TITLE='Lamp TOF lineup & group',/ROW)
	draw = WIDGET_DRAW  (base , XSIZE=512, YSIZE=400)
	slid = WIDGET_SLIDER(base ,/VERTICAL , VALUE=100,/SUPPRESS_VALUE,/DRAG)
	
	WIDGET_CONTROL,base,/REALIZE
	WIDGET_CONTROL,draw, GET_VALUE = draw_id
	WIDGET_CONTROL,base, SET_UVALUE={ID:draw_id,MIN:mini,MAX:maxi,W:wksp,X:x,Y:y}
	XMANAGER,'TOF'+STRING(base) ,base, EVENT_HANDLER='TOF_EVENT' , /JUST_REG
	
	TOF_PLOT, wksp , x,y , draw_id , mini , maxi
    ENDIF
RETURN
END
function rec_tom, data,angles ,DISTANCE=dist ,OUT_SIN=dataf ,TRACE=widg  ,CENTER=cent,$
                               PIXSIZE=pxsz  ,STRIPES =stri ,FILTER=filt ,FILPAR=filp,$
                               DIVERGENCE=divg ,MODCENTER=mcen, AIR=air  ,FILSIZ=filk
;******* *******
;**
sw=SIZE(data) & sa=SIZE(angles) & sz=1 & sx=sw(1) & sy=sw(2) & trc=0 & sxv=sx
wout=0
if (sw(0) lt 2) or (sw(0) gt 3) then begin print,'Data dimensions incorrect !!!'  & return,0 & endif
if (sy ne sa(1))                then begin print,'Angle dimension incorrect !!!'  & return,0 & endif
if (n_elements(widg) eq 6)      then if widg(0)*widg(1)*widg(3)*widg(4) gt 0 then trc=1
if (n_elements(stri) ne 1)      then stri=0
if (n_elements(cent) ne 1)      then cent=0
if (n_elements(filt) ne 1)      then filt=0
if (n_elements(dist) ne 1)      then dist=0
if (n_elements(pxsz) ne 1)      then pxsz=0
if (n_elements(divg) ne 1)      then divg=0
if (n_elements(air)  ne 1)      then air =0
if (n_elements(filp) ne 1)      then filp=1.
if (n_elements(filk) ne 1)      then filk=32
if (sw(0) eq 3)                 then begin sz=sw(3) & wout=fltarr(sx,sy,sz) & endif

Cx   =sx/2 & if Cx*2 eq sx then Cx=Cx-0.5 & kpCX=Cx
if mcen eq 3 then Cx=cent  else cent=Cx
Anglr=angles*!Pi/180.
Rei  =fltarr (sx,sx)
rho  =findgen(sx)

if dist*pxsz*divg ne 0   then begin divb=1
				 np=rho-Cx
				 db=ATAN(np*pxsz/dist/10000.)*180./!Pi
			 endif else divb=0

if mcen eq 1  then begin ling=rho+1
                         grav=fltarr (sy) & weight=fltarr(sy)+1.   & endif
if filt gt 0  then begin
                         filk=filk>3<(sx/3) & half = fix(filk)/2   & zfil=2*half+1 
                         x  = findgen(zfil) - half & filp=filp>0.1 & filter=[1.0]
                         x(half) = .01
                         tmp= fltarr (sx+2*zfil)                   & endif

FOR j=0,sz-1  do  begin
   ;FILTERS
   ;*******
   	dataf=fltarr(sx,sy)
	if sz   gt 1 then dataf(0,0)=data(*,*,j) else dataf(0,0)=data

	;LINEARITY SLICES
	;********* ******
	if air gt 0 then begin
		tat =reform(total(dataf(0:air-1,*),1)+total(dataf(sx-air:sx-1,*),1))/(2.*air)
		avg =tat/(total(tat)/sy)
		FOR i=0,sy-1 DO dataf(0,i)=dataf(*,i)/avg(i)
	endif

	;LINEARITY DETECTOR
	;********* ********
	if air gt 0  then begin
		totL = total(dataf(0:air-1    ,*)) / (sy*air)
		totR = total(dataf(sx-air:sx-1,*)) / (sy*air)
		incr =(totR-totL)/(sx-air)
		airN = totL-incr*(air/2.) + rho*incr + 1
		airF = total(airN)/sx/airN
		FOR i=0,sy-1 do dataf(0,i)=dataf(*,i)*airF
	endif

	;STRIPES
	;*******
	if stri ge 3 then begin
		tot =total(dataf,2)/sy & if !Version.release lt '4.1' then edg='' else edg=',/edge'
		ii  =execute('smo=smooth(tot,stri'+edg+')') & dif=(tot-smo)>0
		for i=0,sy-1 do dataf(0,i)=dataf(*,i)-dif
	endif

	;CENTER
	;******
	if mcen eq 1 then begin
		FOR i=0,sy-1 do begin temp=dataf(*,i)
			grav(i) = total(temp*ling)/total(temp)
		ENDFOR
		mxx=max(grav,min=mii)
		A=[Cx,(mxx-mii)/2.,0.] ;estimate center,amplitude,phase
		fit=curvefit(Anglr, grav, weight, A, sigm, function_name='wavoid')
		Cx = a(0)-1.5 & Cent=Cx
	endif
		kpCX=fix(kpCX-Cx)

	;DIVERGENCE
	;**********
	if divb ne 0 then begin
		for i=0,sx-1 do dataf(i,*)=INTERPOL(reform(dataf(i,*)),angles,angles-db(i))
	endif

	;CONVOLUTION
	;***********
	if filt gt 0 then begin
	   if filt eq 1 then begin a=0.5
		filtrA=-sin(!pi*x/2)^2 / (!pi^2 * x^2 * filp)           ; *** Gen-Hamming ***
		filtrA(half)  = 1./(4.*filp)                            ; *** Gen-Hamming ***
		filtrB=-sin(!pi*(x-1.)/2)^2 / (!pi^2 * (x-1.)^2 * filp) ; *** Gen-Hamming ***
		filtrB(half+1)= 1./(4.*filp)                            ; *** Gen-Hamming ***
		filtrC=-sin(!pi*(x+1.)/2)^2 / (!pi^2 * (x+1.)^2 * filp) ; *** Gen-Hamming ***
		filtrC(half-1)= 1./(4.*filp)                            ; *** Gen-Hamming ***
		filter= a * filtrA + ((1.-a)/2) * (filtrB+filtrC)       ; *** Gen-Hamming ***
	   endif
	   if filt eq 2 then begin
		d = !pi^2 * filp * (1.-4.*x^2)                          ; *** Shepp_Logan ***
		filter=2./d                                             ; *** Shepp_Logan ***
	   endif
	   if filt eq 3 then begin
		filter=-sin(!pi*x/2)^2 / (!pi^2 * x^2 * filp)           ; ***    Ramlak   ***
		filter(half)  = 1./(4.*filp)                            ; ***    Ramlak   ***
	   endif
	   if filt eq 4 then begin
		filtrA=-sin(!pi*(x-.5)/2)^2 / (!pi^2 * (x-.5)^2 * filp) ; ***  lp-cosine  ***
		filtrB=-sin(!pi*(x+.5)/2)^2 / (!pi^2 * (x+.5)^2 * filp) ; ***  lp-cosine  ***
		filter=0.5*(filtrA+filtrB)                              ; ***  lp-cosine  ***
	   endif
	   FOR i=0, sy-1 do begin
		tmp(0 :zfil-1) = dataf(0,i)
		tmp   (zfil)   = dataf(*,i)
		tmp(sx+zfil-1 :sx+2*zfil-1) = dataf(sx-1,i)
		tmp = convol(tmp,filter)
		dataf(0,i) = tmp(zfil : zfil+sx-1)
	   ENDFOR
	endif

   ;SHOW SINOGRAM
   ;**** ********
	if trc then begin Vei=dataf
			if air gt 0 then begin mxx=max(Vei,min=mii) & mxi=mii+(mxx-mii)/3.
				Vei(0:air-1    ,*)=Vei(0:air-1    ,*) + mxi
				Vei(sx-air:sx-1,*)=Vei(sx-air:sx-1,*) + mxi & endif
			wset,widg(0) & tvscl,congrid(Vei,widg(3),widg(4)) & endif

   ;RECONSTRUCTION
   ;**************
	if sys_dep('VERSION') ge 5.4 then begin rho=rho-cx
	     ii=execute('Rei=RADON (transpose(dataf),theta=anglr,/BACKPROJECT,nx=sx,ny=sx,/LINEAR,rho=rho)')
	endif else $
	if sys_dep('VERSION') lt 4.0 then begin if kpCX ne 0 then dataf=shift(dataf,kpCX)
	   for i=0,sy-1 do RIEMANN, dataf, Rei, anglr(i), /BACKPROJECT, ROW=i, /BILINEAR
	endif else $
	   for i=0,sy-1 do RIEMANN, dataf, Rei, anglr(i), /BACKPROJECT, ROW=i, /BILINEAR, CENTER=Cx

   ;AFTER FILTER
   ;**** *******
	if filt gt 0 then begin
	endif
	if sz gt 1  then  wout(0,0,j)=Rei else wout=Rei

   ;SHOW RESULT
   ;**** ******
	if trc then begin wset,widg(1) & tvscl,congrid(Rei ,widg(3),widg(3))
			if (sz eq 1) and (widg(5) gt 0) then jj=widg(5) else jj=j
			widget_control,widg(2),bad_id=ii,set_value=jj & endif
ENDFOR
return,wout
end

pro wavoid, xx, a, fy, pder
;** ******
;** by Mark Rivers.(Chicago)
;** a(0) = rotation center  ; a(1) = amplitude  ; a(2) = phase
	fy = a(0) + a(1)*sin(xx + a(2))
	pder = fltarr(n_elements(xx), n_elements(a))
	pder(*,0) = 1.
	pder(*,1) = sin(xx + a(2))
	pder(*,2) = a(1)*cos(xx + a(2))
end

function strst,st & return,strtrim(string(st),2) & end
;******* *****

function Wuval,uv1, FIX=fix
;******* *****
val=0.
	widget_control,bad_id=ii, uv1, get_value = sval
	on_ioerror,misval & val=float(sval(0))   & misval:
	if keyword_set(fix) then  val=fix(val)
	widget_control,bad_id=ii, uv1, set_value = strst(val)
return, val
end

pro tomo_event_parser, ev,uv
;** *****************
;**
@lamp.cbk
common cw_tomo, b_tom, b_sinr, b_slir, b_sinf, b_rcon, b_slic, b_siz , b_all ,$
                w_idx, w_ang,  w_numr, w_numf, w_numc, w_sinr, w_sinf, w_rcon, w_all, $
                f_dis, f_psiz, f_cent, f_stri, f_filt, f_filp, f_air , f_linr, f_trans, $
                f_div, f_stp , f_logc, f_filk, f_fils

case uv(2) of
1:	begin	kp_w=!D.window & wset ,b_rcon & erase
		if uv(4) ge 0 then begin
		  widget_control,uv(3),get_value=wnum  & wnum=wnum(0)        ;Load Sinogram
		  i =strpos (wnum,'W') & w_numr=strtrim(strmid(wnum,i+1,4),2);*************
		  ii=execute('w_sinr=float(w'+w_numr+')') & sw=SIZE(w_sinr)
		  ii=execute('w_ang =float(y'+w_numr+')') & sy=SIZE(w_ang)
		endif else begin
		  n =101L & m =101L & nv=101 & k =ceil(sqrt(n^2+m^2))        ;Load a square test
		  w_rcon = FLTARR(N, M) & w_rcon(N/2:N/2+25,M/2:M/2+25)= 10. ;******************
		  w_rcon(N/2-15:N/2-10, M/2-15:M/2-10)=11.
		  w_sinr = FLTARR(K, nv)       & sw=SIZE(w_sinr)
		  w_ang  = findgen(nv)*180/nv  & sy=SIZE(w_ang)
		  r_rand = randomu(s,nv) +0.5
		  r_linr = findgen(k)/(k-1) +0.5
		  
		  if sys_dep('VERSION') ge 5.4 then begin    w_ang=w_ang*!Pi/180.
	             ii=execute('w_sinr=RADON (w_rcon, nrho=K, theta=w_ang, /LINEAR)')
		         w_sinr=transpose(w_sinr)   &        w_ang=w_ang/!Pi*180.
		  endif else $
		  FOR I=0, nv-1   DO  RIEMANN, w_sinr, w_rcon, w_ang(i)*!Pi/180., ROW=i

		  w_sinr=shift(w_sinr,5,0) +1.
		  FOR I=0, k-1,10 DO w_sinr(i,*)  =w_sinr(i,*)+50.
		  FOR I=0, nv-1   DO w_sinr(0,i)  =w_sinr(*,i)*r_linr
		  FOR I=0, nv-1   DO w_sinr(0,i)  =w_sinr(*,i)*r_rand(i)
		  tvscl,congrid(w_rcon,b_siz(0),b_siz(0))
		endelse
		if (sw(0) lt 2) or (sw(0) gt 3) then begin w_sinr=dist(32) & sw=SIZE(w_sinr) & endif
		if (sw(2) ne sy(1)) then w_ang=findgen(sw(2))/(sw(2)-1)*180.
		if (sw(0) eq 3)     then begin w_idx=w_idx<(sw(3)-1)
				widget_control,bad_id=ii,b_slir,set_slider_max=sw(3)-1
				widget_control,bad_id=ii,b_slic,set_slider_max=sw(3)-1
				widget_control,bad_id=ii,b_slir,set_value=w_idx,sensitive=1
				widget_control,bad_id=ii,b_slic,set_value=w_idx,sensitive=1
				widget_control,bad_id=ii,b_all ,                sensitive=1
				w_sinf=w_sinr(*,*,w_idx) & w_rcon=fltarr(sw(1),sw(2),sw(3))
		endif	else	begin  w_idx=0
				widget_control,bad_id=ii,b_slir,sensitive=0
				widget_control,bad_id=ii,b_slic,sensitive=0
				widget_control,bad_id=ii,b_all ,sensitive=0
				w_sinf=w_sinr            & if uv(4) ge 0 then w_rcon=fltarr(sw(1),sw(2))
				endelse
		wset ,b_sinr
		tvscl,congrid(w_sinr(*,*,w_idx),b_siz(0),b_siz(1))
		if kp_w gt 0 then wset ,kp_w
	end
2:	begin
		widget_control,uv(3),get_value=wnum  & wnum=wnum(0)      ;Write Reconstruction
		i=strpos(wnum,'W') & w_numc=strtrim(strmid(wnum,i+1,4),2);********************
		XICUTER,'w'+w_numc+'=get_tom(w'+w_numr+',/back_pro)'
	end
3:	begin
		widget_control,uv(3),get_value=wnum  & wnum=wnum(0)      ;Write Filtered Signal
		i=strpos(wnum,'W') & w_numf=strtrim(strmid(wnum,i+1,4),2);*********************
		XICUTER,'w'+w_numf+'=get_tom(w'+w_numr+',/out_sin)'
	end
4:	begin	f_dis = Wuval(uv(3))                                     ;Do the work ......
		                                                         ;******************
		f_psiz= Wuval(uv(4))

		f_stp = Wuval(uv(5),/fix) & if f_stri then f_ker=f_stp else f_ker=0

		r_cent= Wuval(uv(6))

		f_air = Wuval(uv(7),/fix) & if f_linr then f_are=f_air else f_are=0

		f_filk= Wuval(uv(8),/fix)

		f_filp= Wuval(uv(9))

		kp_w=!D.window    & trace=[b_sinf,b_rcon,b_slic,b_siz,w_idx]

		if ((SIZE(w_sinr))(0) eq 3) and (not w_all) $
		 then w_rcon(w_idx)=REC_TOM(w_sinr(*,*,w_idx),w_ang, DIV=f_div, TRACE=trace, OUT=w_sinf,$
		                      CENTER =r_cent, STRIP=f_ker, FILTER=f_filt, FILPAR=f_filp,FILSIZ=f_filk ,$
					    PIXSIZE=f_psiz, DISTANCE=f_dis, MODCENTER=f_cent, AIR=f_are)      $
		 else w_rcon       =REC_TOM(w_sinr           ,w_ang, DIV=f_div, TRACE=trace, OUT=w_sinf,$
		                      CENTER =r_cent, STRIP=f_ker, FILTER=f_filt, FILPAR=f_filp,FILSIZ=f_filk ,$
					    PIXSIZE=f_psiz, DISTANCE=f_dis, MODCENTER=f_cent, AIR=f_are)
					    
		widget_control,uv(6),set_value=strst(r_cent)
		if kp_w gt 0 then wset ,kp_w
	end
5:	begin w_sinr=0 & w_sinf=0 & w_rcon=0 & widget_control,ev.top,/destroy
	end
6:	begin w_all=ev.select                                          ;for all
	end                                                            ;*******
7:	begin widget_control,b_slir,get_value=w_idx                    ;sinogram index
		kp_w=!D.window  & wset ,b_sinr                         ;**************
		tvscl,congrid(w_sinr(*,*,w_idx),b_siz(0),b_siz(1))
		if kp_w gt 0 then wset ,kp_w
	end
8:	begin widget_control,b_slic,get_value=rc_idx                   ;reconstruction index
		kp_w=!D.window  & wset ,b_rcon                         ;********************
		tvscl,congrid(w_rcon(*,*,rc_idx),b_siz(0),b_siz(0))
		if kp_w gt 0 then wset ,kp_w
	end
9:	begin f_cent=uv(3)                                             ;for center
	end                                                            ;**********
10:	begin f_stri=ev.select                                         ;for stripes
	end                                                            ;***********
11:	begin f_filt=uv(3)                                             ;for filter
	      widget_control,ev.id,get_value=sval                      ;**********
	      widget_control,uv(4),set_value=sval
	end
12:	begin f_div =ev.select                                         ;for divergence
	end                                                            ;**************
13:	begin f_linr=ev.select                                         ;for linearity
	      widget_control,uv(3),sensitive=f_linr                    ;*************
	end
14:	begin f_log =ev.select                                         ;for log convertion
	end                                                            ;******************
else:
endcase
end

function get_tom, W,  out_sin=out_sin  ,back_pro=back_pro
;******* *******
;**
@lamp.cbk
common cw_tomo
	s=SIZE(W)
	if keyword_set(back_pro) then begin id=fix(w_numc)
		other_tit(id)='BACK PROJECTION'
		  x_tit(id)  ='X direction (angle '+string(w_ang(0))
		  y_tit(id)  ='Y'
		ii=execute('x'+w_numc+'=indgen(s(1))+1')
		ii=execute('y'+w_numc+'=indgen(s(2))+1')
		return,w_rcon
	endif else begin                    id=fix(w_numf)
		other_tit(id)='FILTERED SINOGRAM'
		ii=execute('x'+w_numf+'=indgen(s(1))+1')
		ii=execute('y'+w_numf+'=w_ang')
		return,w_sinf
	endelse
end

pro tomography, NW=nw
;** **********
;**
@lamp.cbk
common cw_tomo

if keyword_set(nw) then return

i=xregistered('Tomogra')
if i le 0 then begin

 if n_elements(b_tom) eq 0 then begin             ;** SET FIXED PARAMETERS
	w_idx =0  & w_rcon=0 & w_numr='1'  & w_numf='3' & w_numc='2' & b_siz=[256,360]
	w_sinr=dist(32) &  w_sinf=w_sinr  & w_rcon=findgen(32,32)   & w_ang=findgen(32)/31*180.
	w_all =0  & f_dis=720. & f_cent=0 & f_stri=0 & f_filt=0 & f_filp=1. & f_air=12 & f_linr=0
	f_trans=0 & f_psiz=360 & f_div =0 & f_stp=9  & f_logc=0 & f_filk=40
	f_fils=[" no-filter ","Gen-Hamming","Shepp-Logan","Ramlak","LP_Cosine"]
 endif
 if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0
 b_tom =widget_base  (title='Tomography... V1.02',/row,group_leader=lamp_b1,resource_name="lamp")
 bas1  =widget_base  (b_tom ,/column)
 bas2  =widget_base  (b_tom ,/column)
 bas3  =widget_base  (b_tom ,/column)
 basx  =[bas1,bas2,bas3]
 labx  =["Sinogram","Re-construct","Filtered Signal",$
         "load W "+w_numr,"write W "+w_numc,"write W "+w_numf]
 For j =0,2 do begin
	b_r0  =widget_base (basx(j),/row)
	lab  =Widget_label (b_r0   ,font=ft_b_normal,value=labx(j))
	b_r0l=widget_button(b_r0   ,font=ft_smaller ,value='<-')
	b_r0m=widget_button(b_r0   ,font=ft_propor  ,value=labx(j+3))
	b_r0r=widget_button(b_r0   ,font=ft_smaller,value='->')
	widget_control,b_r0l,set_uvalue=[-88,310    ,b_r0m,1]
	widget_control,b_r0m,set_uvalue=[-88,359,j+1,b_r0m,0]
	widget_control,b_r0r,set_uvalue=[-88,311    ,b_r0m,1]
 ENDFOR
 b_sinr=widget_draw  (bas1  ,xsize=b_siz(0) ,ysize=b_siz(1))
 b_slir=widget_slider(bas1  ,xsize=b_siz(0) ,Font=ft_b_normal,title=''  ,uvalue=[-88,359,7])
 bid   =widget_label (bas1  ,value='Input has a background subtracted'      ,Font=ft_b_normal)
 bid   =widget_label (bas1  ,value='and is calibrated by the white signal.' ,Font=ft_b_normal)
  bido  =widget_base (bas1  ,/row)
  bid   =widget_label(bido  ,value='Source -> Detector (Cm)'           ,Font=ft_b_normal)
  b_dis =widget_text (bido  ,value=strst(f_dis) ,xsize=6+cap,/editable ,Font=ft_propor)
  bido  =widget_base (bas1  ,/row)
  bid   =widget_label(bido  ,value='Detect. pixel size (Micron)'       ,Font=ft_b_normal)
  b_psz =widget_text (bido  ,value=strst(f_psiz),xsize=6+cap,/editable ,Font=ft_propor)

  b_11 =widget_base  (bas1  ,/row) & put_logo,b_11
  bid  =widget_button(b_11  ,value='Test',Font=ft_b_normal,uvalue=[-88,359,1,0L,-1])
  bid  =widget_button(b_11  ,value='Done',Font=ft_b_normal,uvalue=[-88,359,5])

 b_rcon=widget_draw  (bas2  ,xsize=b_siz(0) ,ysize=b_siz(0))
 b_slic=widget_slider(bas2  ,xsize=b_siz(0) ,Font=ft_b_normal,title=''  ,uvalue=[-88,359,8])
 bas22 =widget_base  (bas2  ,/column,frame=2)
  lab  =widget_label (bas22 ,value='... Filters ...' ,Font=ft_b_bigger)
  b_21 =widget_base  (bas22 ,/row)
  b_2b =widget_button(widget_base(b_21,/nonexclusive),value="linearity using air values->",Font=ft_b_normal,uvalue=[-88,359,13])
  b_air=widget_text  (b_21  ,value=strst(f_air),xsize=2+cap ,Font=ft_propor,/editable)
  widget_control,b_2b,set_button=f_linr ,set_uvalue=[-88,359,13,b_air]
  if not f_linr then widget_control,b_air,sensitive=0

  b_22 =widget_base  (bas22 ,/row,/nonexclusive)
   but0=widget_button(b_22  ,value='Intensities -log(transmit$/air)',Font=ft_b_normal,uvalue=[-88,359,14])
   widget_control,b_22,set_button=f_logc,sensitive=0
 
  b_23 =widget_base  (bas22 ,/row)
  b_231=widget_base  (b_23 ,/nonexclusive)
   but1=widget_button(b_231 ,value='remove Stripes. Kern='   ,Font=ft_b_normal  ,uvalue=[-88,359,10])
  b_stp=widget_text  (b_23  ,value=strst(f_stp),xsize=3+cap,Font=ft_propor,/editable)

  b_23 =widget_base  (bas22 ,/row)
   bid =widget_label (b_23  ,value='Cx'         ,Font=ft_b_normal)
  b_231=widget_base  (b_23  ,/row,/exclusive)
   bct1=widget_button(b_231 ,value='find'       ,Font=ft_b_normal  ,uvalue=[-88,359,9,1])
   bct2=widget_button(b_231 ,value='mid'        ,Font=ft_b_normal  ,uvalue=[-88,359,9,2])
   bct3=widget_button(b_231 ,value='set'        ,Font=ft_b_normal  ,uvalue=[-88,359,9,3])
  b_cen=widget_text  (b_23  ,value=' 0 ',xsize=4+cap,Font=ft_propor,/editable)
   if f_cent eq 1 then widget_control,bct1 ,set_button=1 else $
   if f_cent eq 3 then widget_control,bct3 ,set_button=1      $
                  else widget_control,bct2 ,set_button=1
 
  b_24 =widget_base  (bas22 ,/row,/nonexclusive)
  b_div=widget_button(b_24  ,value='divergent Beam'   ,Font=ft_b_normal  ,uvalue=[-88,359,12])

  b_25 =widget_base  (bas22 ,/row)
  b_25m=widget_button(b_25  ,value=f_fils(f_filt) ,Font=ft_b_normal  ,menu=2)
   FOR i=0,n_elements(f_fils)-1 do $
   bid =widget_button(b_25m ,value=f_fils(i)      ,Font=ft_b_normal  ,uvalue=[-88,359,11,i,b_25m])
   bid =widget_label (b_25  ,value='Kern:'        ,Font=ft_b_normal)
  b_fik=widget_text  (b_25  ,value=strst(f_filk)  ,Font=ft_propor,xsize=2+cap,/editable)
   bid =widget_label (b_25  ,value='Step:'       ,Font=ft_b_normal)
  b_fip=widget_text  (b_25  ,value=strst(f_filp)  ,Font=ft_propor,xsize=3+cap,/editable)

 b_sinf=widget_draw  (bas3  ,xsize=b_siz(0),ysize=b_siz(1))
 bas32 =widget_base  (bas3  ,/row)
 bid   =widget_button(bas32 ,value='... Proceed ...',Font=ft_b_normal,$
                            uvalue=[-88,359,4,b_dis,b_psz,b_stp,b_cen,b_air,b_fik,b_fip])
 b_all =widget_button(widget_base(bas32,/nonexclusive),value='for all'  ,Font=ft_b_normal,uvalue=[-88,359,6])

 widget_control,b_slir,sensitive=0 
 widget_control,b_slic,sensitive=0 
 widget_control,b_all ,sensitive=0 , set_button=w_all
 widget_control,but0 ,set_button=f_trans
 widget_control,but1 ,set_button=f_stri
 widget_control,b_div,set_button=f_div
 widget_control,b_tom ,/realize    & put_logo
 widget_control,b_sinr,get_value=j & b_sinr=j
 widget_control,b_sinf,get_value=j & b_sinf=j
 widget_control,b_rcon,get_value=j & b_rcon=j

Xmanager,'Tomogra',b_tom,event_handler='LAMP_EVENT_PARSER',/just_reg

endif else widget_control,bad_id=i,b_tom,map=1
end
;
;		********************
;		***  ROMS  ************
;		****************************************
;		an IDL routines library file
;		Written by JOUFFREY Romuald 1996
;
;
;
; nb2str			Convert a number to its string form
;
;+
; NAME:
;       WACCU
;
; PURPOSE:
;       This function add two spectra, using 
;       
;
; CATEGORY:
;       .
;
; CALLING SEQUENCE:
;       ??? waccu, xa, za, ea, na, OPER='+', xs, zs, es, ns
;
; INPUTS:
;       XA:      X data.
;       WA:      Y data.
;       EA:      Error data.
;       NA:      Normalisation vector.
;
;       WB:      An N-element vector of type: float, or double.
;
; KEYWORD PARAMETERS:
;       OPER: 	If set to a non-zero value, computations are done in
;               double precision arithmetic.
;
;
; EXAMPLE:
;       Define an accumulator (a).
;         a = [ 2.0,  1.0,  1.0]
;
;       And operande (b).
;         b = [3.0, 10.0, -5.0]
;
;       Compute  a = a + b.
;
; PROCEDURE:
;       WACCU.PRO uses data and 
;       to calculate a new scan
;
; REFERENCE:
;       Filing (Alain Bouvet)
;
;
; MODIFICATION HISTORY:
;-


;**************************************************************************************
PRO combine_accu, 	x_a, w_a, e_a, n_a, $
			x_tolerance, file_factor, global_monitor, combine, $
			x_s, w_s, e_s, n_s ;***
;**************************************************************************************
; Apply file_factor on accu and data within the tolerance
; Thanks to Alain Bouvet

x_out = [0.0] ; first value will will be discarded before return
w_out = [0.0]
e_out = [0.0]
n_out = [0.0]
index_out = 0

nb_elem_a =  N_ELEMENTS(x_a)
nb_elem_s =  N_ELEMENTS(x_s)
index_a = 0
index_s = 0

WHILE (index_a LT nb_elem_a) OR (index_s LT nb_elem_s) DO BEGIN		
    IF (index_a GE nb_elem_a) THEN BEGIN
	x_diff = x_tolerance + 1	; force copy s in out
    ENDIF ELSE IF (index_s GE nb_elem_s) THEN BEGIN
	x_diff = x_tolerance - 1	; force copy a in out
    ENDIF ELSE $
	x_diff = x_a(index_a) - x_s(index_s)	; combine
    IF (x_diff LT -x_tolerance) THEN BEGIN
	IF NOT(combine) THEN BEGIN
	    ; point from a is included in the out data
	    x_out = [x_out, x_a(index_a)]
	    w_out = [w_out, w_a(index_a)]
	    e_out = [e_out, e_a(index_a)]
	    n_out = [n_out, n_a(index_a)]	
	    index_out = index_out + 1
	ENDIF ELSE BEGIN
	    ; point from a is discarded
	ENDELSE		
	index_a = index_a + 1			
    ENDIF ELSE IF (x_diff GT x_tolerance) THEN BEGIN		
	IF NOT(combine) THEN BEGIN
		; point from a is included in the out data
		x_out = [x_out, x_s(index_s)]
		w_out = [w_out, w_s(index_s)]
		e_out = [e_out, e_s(index_s)]
		n_out = [n_out, n_s(index_s)]
		index_out = index_out + 1
	END ELSE BEGIN
		; Do nothing (point from s is discarded)
	ENDELSE
	index_s=index_s+1
    ENDIF ELSE BEGIN
	; x_a and x_s current point are combined
	x_out = [x_out,(x_a(index_a)+x_s(index_s))/2]
	index_out = index_out + 1
	IF NOT(combine) THEN BEGIN	    ; ADD
	    ; -------------------- add wa and ws
	    new_w = w_a(index_a) +  w_s(index_s)
	    w_out = [w_out, new_w]
	    ; -------------------- compute new error
	    e_out = [e_out, SQRT(new_w)]
	    ; -------------------- compute new monitor
	    n_out = [n_out, n_a(index_a)+n_s(index_s)]
	END ELSE BEGIN		   ; COMBINE
	    ; -------------------- apply file_factor
	    new_w=((w_a(index_a)/n_a(index_a))+ $
		    (file_factor*w_s(index_s))/ $
		    n_s(index_s))*global_monitor
	    w_out=[w_out, new_w]
	    ; -------------------- compute new error
	    e_out = [e_out, SQRT( $
		     ((e_a(index_a)*e_a(index_a))/ $
		     (n_a(index_a)*n_a(index_a)))+ $
		     ABS(file_factor)* $
		     ((e_s(index_s)*e_s(index_s))/ $
		     (n_s(index_s)*n_s(index_s)))) $
		     *global_monitor]

	    ; -------------------- compute new monitor
	    n_out=[n_out, global_monitor]
	ENDELSE
	index_a=index_a+1
	index_s=index_s+1
    ENDELSE
ENDWHILE

; return results in accumulator
; We must discard the first elememt because of our trick on IDL array
IF index_out GE 1 THEN BEGIN
	x_a = x_out(1:*)
	w_a = w_out(1:*)
	e_a = e_out(1:*)
	n_a = n_out(1:*)
END ;
END ; do_cl_on_accu

;******************************************************************************
FUNCTION nb2str, number; *************************************************
;******************************************************************************
; This function return the string of a number expression
; Leading and/or trailing spaces are removed.

RETURN, STRTRIM(STRING(number),2)
END

;
;		********************
;		***  PickFile  ************
;		****************************************
;		a ...
;		Written by JOUFFREY Romuald and Yannick Raoul
;		January 1996
;		(Hoping this Help...)
;
; V1.0b 05/02/96

;****************************** Procedures
; pick_fil_event		Handles pickfile events
; pick_fil			Create the pickfile base

;******************************************************************************
FUNCTION pick_fil_event, event ;***********************************************
;******************************************************************************
; This procedure parses the pick_fil events
; IN : the event generated by pick_fil interface
; OUT : Event are redistributed to tripx event (Search next Event_Func)

WIDGET_CONTROL, bad_id=i, event.id, Get_Uvalue=uv
CASE uv(3) OF
    1 : BEGIN			    ; Update File List
	WIDGET_CONTROL, bad_id=i, uv(8), Get_UValue=file_list
	WIDGET_CONTROL, bad_id=i, uv(4), Get_Value=path
	WIDGET_CONTROL, bad_id=i, uv(5), Get_Value=filter, HourGlass=1
	WIDGET_CONTROL, bad_id=i, uv(6), Set_Value=['','',' Searching ...']
	WIDGET_CONTROL, bad_id=i, uv(7), Set_Value=''
	path=STRTRIM(path(0),2)
	cd, current=mee
	IF path EQ '' THEN path=mee
	WIDGET_CONTROL, bad_id=i, uv(4), Set_Value=path, Set_Text_Select=[STRLEN(path), 0]
	n_files=0
	stat=0 & catch,stat
	IF stat ne 0 THEN BEGIN catch,/cancel     & cd,mee
				print,!err_string & n_files=0
	ENDIF ELSE BEGIN
	  pp=strpos(path,'::')       & pth=''
	  if pp lt 0 then cd,path else pth=path
	  filter=STRTRIM(filter(0),2)
	  IF STRLEN(filter) gt 0 THEN file_string=filter ELSE file_string=''
	  file_list=FINDFILE(pth+file_string,Count=n_files)
	  if pp lt 0 then cd,mee,current=path else path=strupcase(path)
	 ;Put a slash to the end of the path if its not there
	  sep=sys_dep('DIVIDER')
	  IF STRPOS(path,sep,STRLEN(path)-1) lt 0 THEN path=path+sep
	  lenpath=STRLEN(path)
	ENDELSE
	IF n_files GT 0 THEN BEGIN
	    pos= STRPOS(file_list(0), path)
	    IF pos GE 0 THEN file_list=STRMID(file_list,lenpath+pos,50)
	    WIDGET_CONTROL, bad_id=i, uv(6), Set_Value=file_list
	    nn=N_ELEMENTS(file_list)-5 & IF nn LT 0 THEN nn=0
	    WIDGET_CONTROL, bad_id=i, uv(6), Set_List_Top=nn, Set_List_Select=nn
	    WIDGET_CONTROL, bad_id=i, uv(7), Set_Value=file_list(nn)
	ENDIF ELSE $
	WIDGET_CONTROL, bad_id=i, uv(6), Set_Value= $
	    ['Sorry : No file found', '   Change path','  and try again'] 	
	WIDGET_CONTROL, bad_id=i, uv(8), Set_UValue=file_list
	RETURN, {ID: event.id, TOP: event.top, HANDLER:0L, DATA: 'path', PFO: path}
	END
    2 : BEGIN			    ; Get files
    	WIDGET_CONTROL, bad_id=i, uv(5), Get_UValue=file_list
	filename=file_list(event.index)
	WIDGET_CONTROL, bad_id=i, uv(4), Set_Value=filename
	IF event.clicks eq 2 THEN ret_value=filename(0) ELSE ret_value=''
	RETURN, {ID: event.id, TOP: event.top, HANDLER:0L, DATA: ret_value,PFO: ''}	    
	END
    3 : BEGIN			    ; Get files
	WIDGET_CONTROL, bad_id=i, event.id,Get_Value=filename
	WIDGET_CONTROL, bad_id=i, uv(4),Get_Value=path
	path=STRTRIM(path(0),2)
	cd,current=mee
	IF path EQ '' THEN path=mee
        ret_value=''
	stat=0 & catch,stat
	IF stat ne 0 THEN BEGIN catch,/cancel     & cd,mee
				print,!err_string & nf=0
	ENDIF ELSE BEGIN
	  pp=strpos(path,'::')       & pth=''
	  if pp lt 0 then cd,path else pth=path
	  name=filename(0)
	  res=FINDFILE(pth+name, Count=nf)
	  if pp lt 0 then cd,mee,current=path else path=strupcase(path)
	  sep=sys_dep('DIVIDER')
	  IF STRPOS(path,sep,STRLEN(path)-1) lt 0 THEN path=path+sep
	  IF nf GT 0 THEN BEGIN
	    	pos= STRPOS(res(0), path)
	    	IF pos GE 0 THEN res(0)=STRMID(res(0),STRLEN(path)+pos,50)
		ret_value=res(0)
	  ENDIF
	ENDELSE
	RETURN, {ID: event.id, TOP: event.top, HANDLER:0L, DATA: ret_value,PFO: path} 
	END
    ELSE : see, 'Erreur dans le parsing de pick_fil_event'
    ENDCASE
END

;******************************************************************************
PRO pick_fil, pickbase, path, filter, file_list, file, owner, pfw_upd_but ;****
;******************************************************************************
; This procedure creates the pick_fil interface
; The parameters are defaults values,  owner is the WID of father interface
; Other variables are self_explanatory

@lamp.cbk
widebase    = WIDGET_BASE   (pickbase, /Column, /Frame) 
pfw_path    = WIDGET_TEXT   (widebase, Font=ft_propor, Value=path, /Edit, XSize=25) 
filtbase    = WIDGET_BASE   (pickbase, /Row) 
filtlbl	    = WIDGET_LABEL  (filtbase, Font=ft_propor, Value= "filter:") 
pfw_filter  = WIDGET_TEXT   (filtbase, Font=ft_propor, Value= filter, /edit, xs = 10) 
pfw_upd_but = WIDGET_BUTTON (filtbase, Font=ft_propor, Value= "Update")
selections  = WIDGET_BASE   (pickbase, /Row, /Frame) 
fls	    = WIDGET_BASE   (selections, /Column, /Frame)
pfw_list    = WIDGET_LIST   (fls     , Font=ft_propor, Value=file_list, XSize =20, YSize = 6)
pfw_txt	    = WIDGET_TEXT   (fls     , Font=ft_propor, Value=file, XSize=25,/Edit, $
			     UValue=[-88, owner, 2, 3]) 

WIDGET_CONTROL, bad_id=i, pfw_path,   SET_Uvalue=[-88, owner, 2, 1, $
				pfw_path, pfw_filter, pfw_list, pfw_txt, pickbase]
WIDGET_CONTROL, bad_id=i, pfw_filter, SET_Uvalue=[-88, owner, 2, 1, $
				pfw_path, pfw_filter, pfw_list, pfw_txt, pickbase]
WIDGET_CONTROL, bad_id=i, pfw_upd_but,SET_Uvalue=[-88, owner, 2, 1, $
				pfw_path, pfw_filter, pfw_list, pfw_txt, pickbase]
WIDGET_CONTROL, bad_id=i, pfw_list,   SET_Uvalue=[-88, owner, 2, 2, pfw_txt, pickbase, pfw_path]
WIDGET_CONTROL, bad_id=i, pfw_txt ,   SET_Uvalue=[-88, owner, 2, 3, pfw_path, pickbase], $
			    Set_Text_Select=[1,STRLEN(file)]
WIDGET_CONTROL, bad_id=i, pfw_path, Set_Text_Select=[STRLEN(path), 0]

	; The line below make pick_fil events handled locally
WIDGET_CONTROL, bad_id=i, pickbase, Event_Func='pick_fil_event'
	; The line below stores the file list into pickbase UValue
WIDGET_CONTROL, bad_id=i, pickbase, Set_UValue=file_list
RETURN
END

;******************************************************************************
PRO see, par1,par2,par3,par4,par5,par6,par7,par8,par9 ;************************
;******************************************************************************
;+
; NAME:
;       see
;
; PURPOSE:
;       To print parameters
;
; CATEGORY:
;       .
;
; CALLING SEQUENCE:
;	see, p1, p2, ....., p9
; INPUTS:
;	None
;
; KEYWORD PARAMETERS:
;	None
;
; EXAMPLE:
;	See, 'x=',x,'y=',y
;
; PROCEDURE:
;       None 
;
; REFERENCE:
;       None
;
; MODIFICATION HISTORY:
;-

i=N_PARAMS() & str=''
IF i le 0 or i gt 9 THEN BEGIN
    par1='Incorrect number of parameters in see'
    par2=STRING(7B) & i=2
ENDIF
FOR j=1,i DO BEGIN
    str=str+',par'+STRTRIM(STRING(j),2)
ENDFOR
str='print'+str
res=EXECUTE(str)
END

;******************************************************************************
PRO waccu, xa, wa, ea, na, oper, xs, ws, es, ns, x_tol, n_factor, monitor
;******************************************************************************
; The calculation factor used in tripx
; x|w|e|n followed by a are accumulator values 
; x|w|e|n followed by s are loaded spectrum values
; oper is operator code,  x_tol is the x_tolerance value
; n_factor is the factor value (used for combine operation only)
; monitor is the user defined value

;Check for consistencies
IF N_ELEMENTS(oper) LE 0 THEN RETURN
s=SIZE(xs)		    ; Eventualy make a x vector
IF s(0) EQ 0 THEN ns = MAKE_ARRAY(N_ELEMENTS(xs), Value=ns, /Float)

; xa and xs must have the same ordering
; We suppose xa (accumulator) already in ascending order and
; we do a sort on ws

sorted_xs = sort(xs)
xs = xs(sorted_xs)
ws = ws(sorted_xs)
es = es(sorted_xs)
ns = ns(sorted_xs)

IF oper EQ 's' THEN BEGIN	; If operator eq 'S' THEN store xs into xa
    xa  =	xs
    wa  =	ws
    ea  =	es
    na  =	ns
ENDIF ELSE BEGIN
    s=SIZE(na)		    ; Eventualy make a normalisation vector
    IF s(0) EQ 0 THEN na = MAKE_ARRAY(N_ELEMENTS(xa), Value=na, /Float)
    
    ; Operation
    CASE oper OF
	'+'	:   BEGIN
		    combine=0
		END
	'c'	:   BEGIN
		    combine=1
		END
	ELSE:   BEGIN
		END
    ENDCASE
    combine_accu,   xa, wa, ea, na, $
		    x_tol, n_factor, monitor, combine, $
		    xs, ws, es, ns
ENDELSE
END


;
;		********************
;		***  Tripx_face  ************
;		****************************************
;		a specifically designed tool for 3-axis group at ILL
;		Written by JOUFFREY Romuald and Yannick Raoul
;		Based upon tripx_face.pro 12/22/95 version
;		written by Don Kearley (ILL)
;		January 1996
;		(Hoping this Help...)
;
; V0.01b 05/02/96
;
; ************ Because Tripx use LAMP variables and functions ***********
; **************       It cannot be run alone		      ***********
;
;****************************** Tripx common definition procedure
; tx_commons			defines tripx common(s)
;****************************** Non tripx dependent procedure
; see				print procedure
;****************************** Functions
; tx_bufferize			To bufferize accumulators
; tx_calculate			perform calculation
; tx_extract			extract
; tx_get_buffer			To get a bufferized accu
; tx_read			gets tripple axis scan
;****************************** Procedures
; tx_accumulate			Called when an accu has to be bufferized
; tx_build_but			Buttons construction procedure
; tx_build_par			Parameters construction procedure
; tx_calculate_ranges		perform ranges calculation
; tx_data_process		preprocess data before plotting
; tx_end			called when quitting (save history)
; tx_export			Export procedure (to another w or a file)
; tx_grant_w			Fetch W values
; tx_help			define tripx help text
; tx_initialize			Variables initialisation
; tx_plot			Plot procedure
; tx_remove_points		Remove points from a W
; tx_reset_buffers		Called to initalize accumulator
; tx_save			Saving to a file routine
; tx_send_msg			Send a message in relevant widget label
; tx_send_err_msg		Beep + send_msg (Error)
; tx_store_parameters		Keep parameters for future saving
; tx_unscript			
; tx_update_w
; tx_update_ranges		Update values of ranges widgets
; tripx_event			Parsing procedure for tripx_face events
; ***************************** Widgets Creating Procedure
; tripx				Create tripx Interface
; ***************************** Little explanation on variables
; - Local variables are normaly named  			(ex. idx)
; - Each tripx shared variable begins with tx_ 		(ex. tx_parameters)
; - txw_ stands for tripx Widgets identifier variables	(ex. txw_base)
;
; Variables are ALWAYS lowercase, IDL Instructions are ALWAYS uppercase
; Keywords in IDL instructions are ALWAYS Capitalized.
; If you try this, you keep it ... very helpfull in reading ...
;
;******************************************************************************
PRO tx_commons ;***************************************************************
;******************************************************************************
; This procedure was created to define all common blocks for the
; tripx program.

COMMON txc_main,    txw_base	, $	; Widget id of tripx
		    txw_base1	, $	; Widget id of right tripx base
		    txw_but_0   , $	; Widget id of buttons interface top
		    txw_but_base, $	; Widget id of buttons interface base
		    txw_dp_txt	, $	; Widget id for general purpose text dump
		    txw_filttxt	, $	; Text widget id of file filter text
		    txw_pathtxt	, $	; Text widget id of file path text
		    txw_filelist, $	; Text widget id of filelist text
		    txw_xbut	, $	; Widget id array of X buttons
		    txw_wbut	, $	; Widget id array of Z buttons
		    txw_msg	, $	; Widget id of tripx message label
		    txw_pickbase, $	; Widget id of pickfile base
		    txw_ltslider, $	; Widget id of left slider
		    txw_rtslider, $	; Widget id of right slider
		    txw_slid_lab, $	; Widget id of slider label
		    txw_history	, $	; Widget id of history text
		    txw_degree	, $	; Widget id of temperature value
		    txw_unit_mev, $	; Widget id of mev unit button
		    txw_unit_thz, $	; Widget id of thz unit button
		    txw_rg_but	, $	; Widget id of range button
		    txw_basec	, $	; Widget id of calculation fcts
		    txw_xtol	, $	; Widget id of x tolerance field
		    txw_mon_txt	, $	; Widget id of monitor parameter
		    tx_rg_uv	, $	; UV of range button
		    tx_path	, $	; path to read files
		    tx_rwnb	, $	; number of workspace to read data
		    tx_awnb	, $	; number of accumulator workspace
		    tx_old_codes, $	; String for old data labels
		    tx_codes	, $	; String array for data labels
		    tx_old_eg_txt,$	; String for old eg labels
		    tx_eg_txt	, $	; String array for eg labels
		    tx_xsiz	, $	; Float array for x size saving
		    tx_ysiz	, $	; Float array for y size saving
		    tx_wsiz	, $	; Float array for w size saving
		    tx_nsiz	, $	; Float array for n size saving
		    tx_files	, $	; String array for filenames
		    tx_ytit	, $	; String y title
		    tx_wk_s	, $	; Workspace number in string format
		    tx_xsel	, $	; Number of selected for x axis
		    tx_ysel	, $	; Number of selected for y axis
		    tx_wsel	, $	; Flag set if a data is selected
		    tx_nsel	, $	; Flag set if amonitor is selected
		    tx_numor	, $	; String array for numor
		    tx_history	, $	; String array for history
		    tx_cur_buf	, $	; Number of current displayed buffer
		    tx_loaded	, $	; Boolean (correct data has been loaded)
		    tx_unit	, $	; String for current unit 
		    tx_xtol	, $	; X tolerance value (%)
		    tx_xrange	, $	; Xrange Array 
		    tx_yrange	, $	; YRange Array
		    tx_monitor	, $	; monitor value
		    tx_factor	, $	; factor value
		    tx_par_str	, $	; parameter structure
		    tx_par_txt	, $	; parameter text
		    tx_small_history	; compiled history
		    
COMMON txc_buffer,  tx_last_buffer, $	; Last bufferized accus
		    tx_buffers		; Array of Handle storing structures

COMMON txc_wd_id,   txw_d2	,$	; Widget id of plot left area
		    txw_d1		; Widget id of plot left area

COMMON txc_pb,	    tx_data	, $	; 
		    tx_old_data		;

RETURN
END

;******************************************************************************
FUNCTION tx_bufferize, position, x, y, w, n, e, p ;****************************
;******************************************************************************
COMMON txc_buffer			; Retrieve buffers common block 
; Store dataset (x, y, w, n, e, p) in buffer number 'position'
; Discard any data already stored after nb

CASE 1 OF
    (position LE 0)		    : RETURN, -1 ; Wrong position
    (position GT tx_last_buffer+1)  : RETURN, -2
ELSE				    : BEGIN & END
ENDCASE

IF (position LE tx_last_buffer) THEN BEGIN			
    FOR index=position, tx_last_buffer DO BEGIN	; Forget data stored after this position
	buffer_handle=tx_buffers(index)
	IF (buffer_handle NE 0) THEN $
	    Handle_Free, tx_buffers(index)
    ENDFOR
    tx_buffers=tx_buffers(0:position-1)
    tx_last_buffer=position-1
ENDIF

buffer = {X:x, Y:y, W:w, N:n, E:e, PAR:p}
buffer_handle=HANDLE_CREATE(VALUE=buffer, /NO_COPY)
tx_buffers = [tx_buffers, buffer_handle]
tx_last_buffer = position
RETURN, 0
END

;******************************************************************************
FUNCTION tx_calculate, accu_nb, oper, read_nb, $    ;**************************
	 x_tol, str, txw_basec, factor, monitor	    ;**************************
;******************************************************************************
; All purpose calculation function
; return 0 if no error occured
; return -1 if no data available

tx_grant_w, accu_nb, xa, ya, wa, na, ea, tit, xtit, ytit, SubTit
tx_grant_w, read_nb, xs, ys, ws, ns, es, tit, xtit, ytit, SubTit

IF N_ELEMENTS(xs) GE 2 THEN BEGIN
    steps=xs(1:*)-xs(0:(N_ELEMENTS(xs)-2))		    ; Differences x vector
    xtol=FLOAT(TOTAL(steps)/N_ELEMENTS(steps)*x_tol/100) ; Calculate diff average
    xtol=xtol(0)
ENDIF ELSE xtol=0.0
waccu, xa, wa, ea, na, oper, xs, ws, es, ns, xtol, factor, monitor
IF oper EQ 'c' THEN WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=0
tx_update_w, accu_nb, xa, ya, wa, na, ea
tx_accumulate, accu_nb, str
RETURN, 0
END

;******************************************************************************
FUNCTION tx_extract, partxt, line_tag, var_tag, value ;************************
;******************************************************************************
; partxt is an array of lines
;

result = -1 ; line_tag not found
nb_line = N_ELEMENTS(partxt)

line_tag = line_tag + ':'
current_line = 0
Done = 0
REPEAT BEGIN
    line = partxt(current_line)	
    line_tag_pos = STRPOS(line, line_tag)	
    IF (line_tag_pos GT -1) THEN BEGIN
	result = -2 ; line_tag found (looking for var_tag)
	IF (var_tag NE '') THEN BEGIN		
	    var_tag_pos = STRPOS(line, var_tag, line_tag_pos+6)			
	    IF (var_tag_pos GT -1) THEN BEGIN
		result = 0
		Done = 1
		value_begin = STRPOS(line, '=', var_tag_pos+1) + 1			
		value_end = STRPOS(line, ',', value_begin)
		IF (value_end EQ -1) THEN BEGIN
			value_end = strlen(line)
		ENDIF
		value = STRMID(line, value_begin, value_end-value_begin )
	    ENDIF	
	END ELSE BEGIN
		result = 0
		Done = 1
		value = STRMID(line, line_tag_pos+7, strlen(line)-line_tag_pos+7)
	ENDELSE
    ENDIF	
    
    current_line = current_line+1 ; look farther 
    IF (current_line EQ nb_line) THEN Done=1	
ENDREP UNTIL Done
; remove trailing = if exists
IF STRMID(value, STRLEN(value)-1, 1) EQ '=' THEN $
    value=STRMID(value, 0, STRLEN(value)-1)
RETURN, result
END

;******************************************************************************
FUNCTION tx_get_buffer, position, accu_nb ;************************************
;******************************************************************************
COMMON txc_buffer		    ; Retrieve buffers common block 

; Buffer are numbered from 1 to tx_last_buffer
IF (position LE tx_last_buffer) THEN $
    buffer_handle=tx_buffers(position)  ; get handle index nb
CASE 1 OF
(position GT tx_last_buffer)	: RETURN, -1
(buffer_handle EQ 0)		: RETURN, -2
ELSE				: BEGIN & END
ENDCASE
 
Handle_Value, buffer_handle, buffer ; Get data from handle
x=buffer.X			    ; Get data from buffer
y=buffer.Y
w=buffer.W
n=buffer.N
e=buffer.E
p=buffer.PAR
tx_update_w, accu_nb, x, y, w, n, e
RETURN, 0
END

;******************************************************************************
FUNCTION tx_get_step, partxt, Step_Name_Array, Step_Value_Array, Best_Step_Index
;******************************************************************************
; partxt is an array of line
;

result = -1 ; line_tag not found
Step_Name_Array = ['']
Step_Value_Array = [0.0]
Best_Step_Index = -1

nb_line = n_elements(partxt)

line_tag = 'STEPS:'
current_line = 0
Done = 0
REPEAT BEGIN
    line = partxt(current_line)
    line_tag_pos = STRPOS(line, line_tag)	
    IF (line_tag_pos GT -1) THEN BEGIN
	result = -2 ; line_tag found (looking for DXX variables)
	StepDone = 0
	StepIndex = 0
	var_tag_pos = line_tag_pos+6
	REPEAT BEGIN
	    var_tag_pos = STRPOS(line, ' D', var_tag_pos)			
	    IF (var_tag_pos EQ -1) THEN StepDone = 1 $
	    ELSE BEGIN
		result = 0	; found a DQx
		egal_pos = STRPOS(line, '=', var_tag_pos+1)
		VarName = STRTRIM(STRMID(line, var_tag_pos+1, egal_pos-var_tag_pos-1),2)					
		value_begin = egal_pos + 1
		value_end = STRPOS(line, ',', value_begin)
		IF (value_end EQ -1) THEN value_end = strlen(line)
		VarValue = Float(STRMID(line, value_begin, value_end-value_begin ))
		Step_Name_Array = [Step_Name_Array, VarName]
		Step_Value_Array = [Step_Value_Array, VarValue]
		StepIndex = StepIndex + 1
		var_tag_pos = value_end
	    ENDELSE
	ENDREP UNTIL StepDone
    ENDIF

    current_line = current_line+1 ; look further
    IF (current_line EQ nb_line) THEN Done=1
ENDREP UNTIL Done

; Strip first unused entry
IF (StepIndex GT 0) THEN BEGIN
    Step_Name_Array = Step_Name_Array(1:*)
    Step_Value_Array = Step_Value_Array(1:*)
    
    ; Find best guess for x-axis
    Best_Step_Index = WHERE(Step_Value_Array, count)
    IF count GT 0 THEN $
	Best_Step_Index = Best_Step_Index(0) $
    ELSE $
	result = -3 ; Error : All steps have null value
    
ENDIF
RETURN, result
END

;******************************************************************************
FUNCTION tx_monitor_changed, tx_nsel, monitor, tx_codes ;**********************
;******************************************************************************

IF tx_nsel GE  0 THEN label=STRTRIM(tx_codes(tx_nsel), 2)
IF tx_nsel EQ -1 THEN label='None'
IF tx_nsel EQ -2 THEN BEGIN
    label=nb2str(monitor)
ENDIF
IF tx_nsel EQ -3 THEN label='None'
RETURN, label(0)
END

;******************************************************************************
FUNCTION tx_read, run, typ ;***********************************************
;******************************************************************************
; gets tripple axis scan in order gjk

@lamp.cbk			    ; call lamp.cbk common block
COMMON txc_main			    ; call back tripx_face common

tx_wk_s	=nb2str(tx_rwnb)	    ; Construct w strings for reading
path_f_o_k  =path_for_online
path_for_online	=tx_path		    ; Assign correct values for rdrun
status		=0

IF typ EQ 0 THEN BEGIN
    str='w'+tx_wk_s+'=rdrun('+nb2str(run)+', status)'
    tx_send_msg, txw_msg, 'Reading '+nb2str(run)+'...'
    xicute,str			    ; Read Datas
ENDIF ELSE BEGIN
    one=tx_rwnb
    p_did_getfil, run, tx_rwnb, status
ENDELSE
path_for_online=path_f_o_k
tx_send_msg, txw_msg, 'Checking '+nb2str(run)+'...'
iii=EXECUTE('tx_pv=pv'+tx_wk_s)
my_check=SIZE(tx_pv)
IF my_check(0) lt 1 THEN BEGIN
    tx_send_err_msg, txw_msg, 'Bum data'
    RETURN,0
ENDIF
mycheck=0			    ; Decode data fields from par_txt
last_line=N_ELEMENTS(par_txt(one, *))-1
WHILE mycheck lt 2 DO BEGIN
    code_string=STRTRIM(STRCOMPRESS(par_txt(one,last_line)),2)+' '
    mycheck    =STRLEN(code_string)    ; check that there is something there
    last_line  =last_line-1
    IF last_line lt 1 THEN RETURN,0
ENDWHILE
IF STRPOS(code_string, '=') GE 0 THEN $
	code_string=STRMID(code_string, 0, STRPOS(code_string, '='))
code_string=code_string+' '
tx_old_codes=tx_codes
tx_codes=code_string
l=STRLEN(code_string) & j=0 & code_buf=''
FOR i=0,l-1 DO IF STRMID(code_string,i,1) eq ' ' THEN BEGIN
    code_buf=[code_buf,STRMID(code_string,j,i-j)]
    j=i+1
ENDIF
code_buf=code_buf(1:*)
;	code_buf=chop(code_string,' ')
tx_send_msg, txw_msg,"got"+" "+nb2str(run)
size_codes =SIZE(code_buf)
tx_old_eg_txt=tx_eg_txt
tx_eg_txt=STRARR(size_codes(1))
tx_codes=code_buf(0:(size_codes(1)-1))
pv_size=SIZE(tx_pv)
FOR icode=0,size_codes(1)-1 DO BEGIN
    tx_eg_txt(icode)=""
    IF my_check(2) gt 2 THEN BEGIN
	; Put the first few lines of data into ex_txt (a la Kaleida)
	lim=MIN([pv_size(2)-1,2])
	IF pv_size(0) EQ 1 THEN lim=0
	FOR ifld=0,lim DO BEGIN
	    tx_buf=nb2str(tx_pv(icode,ifld))
	    IF STRLEN(tx_buf) gt 5 THEN $
	    tx_buf=STRMID(tx_buf,0,5)
	    tx_eg_txt(icode)=tx_eg_txt(icode)+tx_buf+" "
	ENDFOR
	IF lim GT 0 THEN BEGIN
	    tx_buf=nb2str(tx_pv(icode,pv_size(2)-1))
	    tx_eg_txt(icode)=tx_eg_txt(icode)+' ...'+tx_buf
	ENDIF
    ENDIF
    space_nb=MAX([0, 4-STRLEN(tx_codes(icode))])
    IF space_nb GT 0 THEN space=STRING(REPLICATE(32B, space_nb)) else space=''
    tx_codes(icode)=tx_codes(icode)+space
ENDFOR
tx_update_w, tx_rwnb, [0], [0], [0], [0], [0]
tx_xsel=-1
tx_wsel=-1
tx_ysel=-1
tx_nsel=-1
RETURN, tx_pv
END

;******************************************************************************
FUNCTION tx_script, tx_numor, y_txt, x_txt, monitor_txt ;**********************
;******************************************************************************
; This Function return a compiled string which describe a tripx set of data

msg=tx_numor+' '+y_txt+'='+x_txt+'/'+monitor_txt
RETURN, msg
END

;******************************************************************************
;*************** END OF FUNCTION ********** BEGINNING OF PROCEDURE ************
;******************************************************************************

;******************************************************************************
PRO tx_accumulate, accu_nb, str ;**********************************************
;******************************************************************************
; Tx_Last_buffer is updated by bufferize function

COMMON txc_buffer			; Retrieve buffers common block 
COMMON txc_main				; call back tripx_face common

tx_grant_w, accu_nb, x, y, w, n, e, tit, xtit, ytit, SubTit
p=0 ; ???
IF tx_cur_buf EQ -1 THEN BEGIN
    WIDGET_CONTROL, bad_id=i, txw_rtslider, /Sensitive
    tx_cur_buf=0
ENDIF
y=0
res=tx_bufferize(tx_cur_buf+1, x, y, w, n, e, p)
IF res LT 0 THEN $
    tx_send_err_msg, txw_msg, 'Error '+nb2str(res)+' in bufferize' $
ELSE BEGIN
					; *** History stuff
    tx_history =    [tx_history(0:tx_last_buffer-1), str]
    tx_send_msg, txw_history, str
					; *** Slider stuff
    WIDGET_CONTROL, bad_id=i, txw_rtslider, Set_Slider_Max=tx_last_buffer
    WIDGET_CONTROL, bad_id=i, txw_rtslider, Set_Value=tx_last_buffer
    tx_cur_buf =    tx_last_buffer
					; *** Frame stuff
    WIDGET_CONTROL, bad_id=i, txw_slid_lab, Set_Value='Frame #'+nb2str(tx_cur_buf)
ENDELSE
RETURN
END

;******************************************************************************
PRO tx_build_but,   base, base_id, tx_codes, tx_eg_txt, $   ;******************
		    txw_xbut, txw_wbut			    ;******************
;******************************************************************************
; This procedure built the widget buttons to select y, x axis and monitor

@lamp.cbk				    ; call lamp.cbk common block
Display_Y=0	; set if you want that an Y axis column button be created

siz=size(tx_codes)
WIDGET_CONTROL, bad_id=i, base_id, /Destroy	; clear old base
base_id  = WIDGET_BASE(base)
WIDGET_CONTROL, bad_id=i, base_id, /HourGlass
map=sys_dep('MAP')
IF map EQ 1 THEN WIDGET_CONTROL, bad_id=i, base_id, Map=0
IF map EQ 2 THEN WIDGET_CONTROL, bad_id=i, base_id, Update=0
base_id1	=   WIDGET_BASE(base_id,  /Map, /Frame)
base_id11	=   WIDGET_BASE(base_id1, /Column, $
		    X_Scroll_Size=525, $
		    Y_Scroll_Size=280)
IF siz(0) EQ 1 THEN IF siz(1) GT 0 THEN BEGIN	; if number of codes gt 0
    baset	=   WIDGET_BASE(base_id11, /Row,resource_name='mic')
    base_id2	=   WIDGET_BASE(base_id11, /Row,resource_name='mic',Frame=2)
        ; ---------------------------------------- Make array for cw_bgroup
    txw_monitor=INTARR(1)
    xtxt=tx_codes & xtxt(*)='   '+xtxt & ztxt='  -> '+tx_eg_txt
    basex	=   WIDGET_BASE(base_id2,  /Row)
    txw_xbut	=   CW_BGROUP(basex, xtxt, /Column, /Exclusive,  $
				UValue=[-88, 357, 3, 1], Font=ft_propor) 
    IF Display_Y THEN BEGIN
	basey	=   WIDGET_BASE(base_id2,  /Column)
	txw_ybut=   CW_BGROUP(basey, xtxt, /Column, /Exclusive, $
			    Label_Top='Y Axis', UValue=[-88, 357, 3, 2]) 
    ENDIF
    basez	=   WIDGET_BASE(base_id2,  /Column)
    txw_wbut	=   CW_BGROUP(basez, ztxt, /Column, /Exclusive,  $
				UValue=[-88, 357, 3, 3], Font=ft_propor) 

    tit		=   WIDGET_LABEL(baset, Font=ft_b_bigger, $
		    Value='X axis      Y axis      Monitor:')
    txw_mon_but	=   WIDGET_BUTTON(baset, /Menu, Value='None')
    ii=0 & mn=-1
    txw_monitor(0)= WIDGET_BUTTON(txw_mon_but, Value='None')	
    WIDGET_CONTROL, bad_id=i, txw_monitor(0), $
		Set_UValue=[-88, 357, 3, 4, -2, txw_monitor(0),txw_mon_but]
    FOR i=1, N_ELEMENTS(tx_codes)-1 DO BEGIN
	IF (tx_codes(i-1) EQ 'M1  ' OR $
	    tx_codes(i-1) EQ 'TIME') THEN BEGIN
	    ii=ii+1
	    IF tx_codes(i-1) EQ 'M1  ' THEN mn=i-1
	    txw_monitor=[txw_monitor,0]
	    txw_monitor(ii)=WIDGET_BUTTON(txw_mon_but, Value=tx_codes(i-1))
	    ; Set correct UValues for those widget Identifiers
	    WIDGET_CONTROL, bad_id=iii, txw_monitor(ii), Set_UValue= $
			    [-88, 357, 3, 4, i, txw_monitor(ii), txw_mon_but]
	ENDIF
    ENDFOR
    IF mn NE -1 THEN $
    WIDGET_CONTROL, bad_id=i, txw_mon_but, Set_Value=tx_codes(mn)
ENDIF
tx_build_par, base_id11
bid=sys_dep('DYNLAB',base_id,1)
IF map EQ 1 THEN WIDGET_CONTROL, bad_id=i, base_id, Map=1
IF map EQ 2 THEN WIDGET_CONTROL, bad_id=i, base_id, Update=1
END

;******************************************************************************
PRO tx_build_par, base ;*******************************************************
;******************************************************************************
; This procedure built the parameters widget

@lamp.cbk				    ; call lamp.cbk common block
COMMON txc_main				    ; call back tripx_face common

base_id	    =	WIDGET_BASE (base, /Column, Frame=2,resource_name='did')
label_base  =	WIDGET_BASE (base_id, /Row)
label	    =	WIDGET_LABEL(label_base, Font=ft_b_bigger, $
		Value='Tolerance Values')
label	    =	WIDGET_LABEL(label_base, Font=ft_smaller, $
		Value='In percentage of the corresponding value.')

base_row1   =	WIDGET_BASE (base, /Row, /Frame,resource_name='don')
unit_l	    =	WIDGET_LABEL(base_row1, Font=ft_propor, Value='Unit :')
unit_base   =	WIDGET_BASE (base_row1, /Exclusive, /Row)
txw_unit_mev=	WIDGET_BUTTON(unit_base, Value='MeV', Font=ft_propor, $
		UValue=[-88, 357, 6, 4])
txw_unit_thz=	WIDGET_BUTTON(unit_base, Value='THz', Font=ft_propor, $
		UValue=[-88, 357, 6, 5])
WIDGET_CONTROL, bad_id=i, txw_unit_mev, /Set_Button
label	    =	WIDGET_LABEL(base_row1, Font=ft_propor, Value='Monitor ref:')
txw_mon_txt =   WIDGET_TEXT (base_row1, Value='?????', XSize=7, $
			     /Edit, UValue=[-88, 357, 6, 7])

base_row2   =	WIDGET_BASE (base_id, /Row)
label	    =	WIDGET_LABEL(base_row2, Font=ft_propor, Value='Abscissa:')
txw_xtol    =	WIDGET_TEXT (base_row2, Font=ft_normal, /Edit, Value='', $
			     UValue=[-88, 357, 6, 1], XSize=5)
;label	    =	WIDGET_LABEL(base_row2, Font=ft_propor, Value='Temp. :')
;txw_degree  =	WIDGET_TEXT (base_row2, Font=ft_normal, /Edit, Value='10.0', $
;			     UValue=[-88, 357, 6, 2], XSize=5)


base_row3   =	WIDGET_BASE (base, /Row, /Frame,resource_name='don')
base_row31  =	WIDGET_BASE (base_row3, /NonExclusive)
label	    =	WIDGET_LABEL(base_row3, Font=ft_normal, $
		Value='X Range')
txw_xmin    =	WIDGET_TEXT (base_row3, Font=ft_propor, /Edit, $
			     Value='', XSize=7, UValue=[-88, 357, 6, 6])
txw_xmax    =	WIDGET_TEXT (base_row3, Font=ft_propor, /Edit, $
			     Value='', XSize=7, UValue=[-88, 357, 6, 6])
label	    =	WIDGET_LABEL(base_row3, Font=ft_normal, $
		Value='Y Range')
txw_ymin    =	WIDGET_TEXT (base_row3, Font=ft_propor, /Edit, $
			     Value='', XSize=7, UValue=[-88, 357, 6, 6])
txw_ymax    =	WIDGET_TEXT (base_row3, Font=ft_propor, /Edit, $
			     Value='', XSize=7, UValue=[-88, 357, 6, 6])	
tx_rg_uv=[-88, 357, 6, 3, txw_xmin, txw_xmax, txw_ymin, txw_ymax]
WIDGET_CONTROL, bad_id=i, txw_xmin, Set_UValue=[-88, 357, 6, 6, $
				    txw_xmin, txw_xmax, txw_ymin, txw_ymax]
WIDGET_CONTROL, bad_id=i, txw_xmax, Set_UValue=[-88, 357, 6, 6, $
				    txw_xmin, txw_xmax, txw_ymin, txw_ymax]
WIDGET_CONTROL, bad_id=i, txw_ymin, Set_UValue=[-88, 357, 6, 6, $
				    txw_xmin, txw_xmax, txw_ymin, txw_ymax]
WIDGET_CONTROL, bad_id=i, txw_ymax, Set_UValue=[-88, 357, 6, 6, $
				    txw_xmin, txw_xmax, txw_ymin, txw_ymax]

base_row4   =	WIDGET_BASE (base, /Row, /Frame,resource_name='ben')
txw_vp_but  =	WIDGET_BUTTON(base_row4, Value='View parameters', $
			      UValue=[-88, 357, 6, 8])

RETURN
END

;******************************************************************************
PRO tx_calculate_ranges, which ;***********************************************
;******************************************************************************
; Which is optionnal
; it can be 0, 1 or 2
;	0 : ranges are calculated using read and accu spectra
;	1 : ranges are calculated using read spectra only
;	2 : ranges are calculated using accu spectra only
;			  

COMMON txc_main
IF N_PARAMS() EQ 0 THEN which=0

CASE which OF
    0 : BEGIN
	    tx_grant_w, tx_rwnb, x, y, w, n, e, tit, xtit, ytit, SubTit
	    tx_grant_w, tx_awnb, xa, ya, wa, na, ea, tit, xtit, ytit, SubTit
	END
    1 : BEGIN
	    tx_grant_w, tx_rwnb, x, y, w, n, e, tit, xtit, ytit, SubTit
	    tx_grant_w, tx_rwnb, xa, ya, wa, na, ea, tit, xtit, ytit, SubTit
	END
    2 : BEGIN
	    tx_grant_w, tx_awnb, x, y, w, n, e, tit, xtit, ytit, SubTit
	    tx_grant_w, tx_awnb, xa, ya, wa, na, ea, tit, xtit, ytit, SubTit
	END
    ELSE :
ENDCASE
tx_xrange=[MIN([x, xa]), MAX([x, xa])]
tx_yrange=[MIN([w, wa]), MAX([w, wa])]
RETURN
END

;******************************************************************************
PRO tx_data_process ;**********************************************************
;******************************************************************************
; Process data to be plotted

@lamp.cbk				    ; call lamp.cbk common block
COMMON txc_main				    ; call back tripx_face common
COMMON txc_wd_id			    ; call back plot area common block
COMMON txc_pb				    ; call back problem common block

flag=0
IF N_ELEMENTS(tx_old_eg_txt) NE N_ELEMENTS(tx_eg_txt) THEN flag=1 $
ELSE BEGIN
    FOR iii=0, N_ELEMENTS(tx_eg_txt)-1 DO $
	IF tx_old_eg_txt(iii) NE tx_eg_txt(iii) THEN flag=1
ENDELSE
IF flag EQ 1 THEN BEGIN
    tx_old_eg_txt=tx_eg_txt
    tx_send_msg, txw_msg, 'Creating Axis buttons'
    tx_build_but, txw_but_0, txw_but_base, $    ; rebuilt ...
	tx_codes ,tx_eg_txt, txw_xbut, txw_wbut
    WIDGET_CONTROL, bad_id=i, txw_xtol, Set_Value=nb2str(tx_xtol)
    WIDGET_CONTROL, bad_id=i, txw_mon_txt, Set_Value=nb2str(tx_monitor)
    WIDGET_CONTROL, bad_id=i, txw_rg_but, Set_UValue=tx_rg_uv
ENDIF
siz_codes=SIZE(tx_codes)
IF siz_codes(0) EQ 0 THEN flag=2 ELSE BEGIN
    pidx=WHERE(tx_codes EQ 'PNT ')	    ; Try to find points (PNT)
    xidx=WHERE(tx_codes EQ 'EN  ')	    ; Try to find default X (EN)
    yidx=WHERE(tx_codes EQ 'XXXX')	    ; Try to find nothing
    widx=WHERE(tx_codes EQ 'CNTS')	    ; Try to find counts (CNTS)
    nidx=WHERE(tx_codes EQ 'M1  ')	    ; Try to find monitor (M1)
    eidx=WHERE(tx_codes EQ 'DELT')	    ; Try to find error (DELT)
    qhidx=WHERE(tx_codes EQ 'QH  ')	    ; Try to find points (QH)
    qkidx=WHERE(tx_codes EQ 'QK  ')	    ; Try to find points (QK)
    qlidx=WHERE(tx_codes EQ 'QL  ')	    ; Try to find points (QL)
    
					; Get X array number
    res = tx_get_step(par_txt(tx_rwnb,*), Step_Name_Array, Step_Value_Array, Best_Step_Index)
    IF (res EQ 0) THEN BEGIN
	best_X_axis=Step_Name_Array(Best_Step_Index)
	best_X_axis=STRMID(best_X_axis, 1, STRLEN(best_X_axis))
	xidx=WHERE(STRTRIM(tx_codes,2) EQ best_X_axis)
    ENDIF
    res=tx_extract(par_txt(tx_rwnb,*), 'FILE_', '', tx_numor)
    IF res LT 0 THEN tx_numor=''
    tx_numor=STRTRIM(tx_numor, 2)	    ; removed extra spaces
    res=tx_extract(par_txt(tx_rwnb,*), 'POSQE', 'UN', tx_unit)
    IF res LT 0 THEN tx_unit=''
    
    IF STRUPCASE(tx_unit) EQ 'MEV' THEN $
	WIDGET_CONTROL, bad_id=i, txw_unit_mev, /Set_Button
    IF STRUPCASE(tx_unit) EQ 'THZ' THEN $
	WIDGET_CONTROL, bad_id=i, txw_unit_thz, /Set_Button
    
    IF (pidx(0) NE -1) THEN tx_psel=pidx(0) ; store selected points
    IF (xidx(0) NE -1) AND (tx_xsel EQ -1) THEN tx_xsel=xidx(0) ; store selected x
    IF (yidx(0) NE -1) AND (tx_ysel EQ -1) THEN tx_ysel=yidx(0) ; store selected y
    IF (widx(0) NE -1) AND (tx_wsel EQ -1) THEN tx_wsel=widx(0) ; store selected w
    IF (nidx(0) NE -1) AND (tx_nsel EQ -1) THEN tx_nsel=nidx(0) ; store selected n
    tx_esel=-1
    tx_qhsel=-1
    tx_qksel=-1
    tx_qlsel=-1
    IF (eidx(0) NE -1)  THEN tx_esel =eidx(0)  ; store selected qh
    IF (qhidx(0) NE -1) THEN tx_qhsel=qhidx(0) ; store selected qh
    IF (qkidx(0) NE -1) THEN tx_qksel=qkidx(0) ; store selected qk
    IF (qlidx(0) NE -1) THEN tx_qlsel=qlidx(0) ; store selected ql
    IF tx_qksel NE -1 THEN tx_qk=tx_data(tx_qksel,*)
    IF tx_qhsel NE -1 THEN tx_qh=tx_data(tx_qhsel,*)
    IF tx_qlsel NE -1 THEN tx_ql=tx_data(tx_qlsel,*)
    IF tx_xsel GE 0 THEN $
    WIDGET_CONTROL, bad_id=i, txw_xbut, Set_Value=tx_xsel	    ; Refresh CW_Bgroup
    IF tx_wsel NE -1 THEN $
    WIDGET_CONTROL, bad_id=i, txw_wbut, Set_Value=tx_wsel	    ; Refresh CW_Bgroup
    IF tx_xsel NE -1 THEN x =tx_data(tx_xsel,*)	; Retrieve x data
    IF tx_ysel NE -1 THEN y =tx_data(tx_ysel,*)	; Retrieve y data
    IF tx_wsel NE -1 THEN w =tx_data(tx_wsel,*)	; Retrieve w data
    
    IF tx_nsel GE  0 THEN n=tx_data(tx_nsel,*)
    IF tx_nsel EQ -1 THEN n=1 ELSE $
    IF tx_nsel EQ -2 THEN n=FLOAT(tx_monitor)
    IF tx_nsel EQ -3 THEN n=1
    tx_xsiz=fix(N_ELEMENTS(x)) & IF tx_xsiz gt 1 THEN x=REFORM(x,tx_xsiz)
    tx_ysiz=fix(N_ELEMENTS(y)) & IF tx_ysiz gt 1 THEN y=REFORM(y,tx_ysiz)
    tx_wsiz=fix(N_ELEMENTS(w)) & IF tx_wsiz gt 1 THEN w=REFORM(w,tx_wsiz)
    tx_nsiz=fix(N_ELEMENTS(n)) & IF tx_nsiz gt 1 THEN n=REFORM(n,tx_nsiz)
    IF tx_esel NE -1 THEN e=tx_data(tx_esel,*) ELSE e=SQRT(w)   ; Calculate error vector
    IF tx_psel  NE -1 THEN BEGIN
	tx_pnt=tx_data(tx_psel,*)
	IF FLOOR(tx_pnt(0)) NE tx_pnt(0) THEN BEGIN
	    str_pnt=nb2str(tx_pnt)
	    FOR i=0, N_ELEMENTS(str_pnt)-1 DO BEGIN
		str_pnt(i)=STRMID(str_pnt(i), STRPOS(str_pnt(i), '.')+1, 10)
		j=STRLEN(str_pnt(i))-1
		WHILE (STRMID(str_pnt(i),j, 1) EQ '0') DO BEGIN
		 j=j-1
		 str_pnt(i)=STRMID(str_pnt(i),0, j+1)
		ENDWHILE
	    ENDFOR
	    nb_pol=MAX(FIX(str_pnt))
	    tx_send_msg, txw_msg, nb2str(nb_pol)+' Polarizations file'
	    WIDGET_CONTROL, bad_id=i,txw_ltslider, Sensitive=1
	    WIDGET_CONTROL, bad_id=i,txw_ltslider, Set_Slider_Max=nb_pol
	    WIDGET_CONTROL, bad_id=i,txw_ltslider, Set_Value=1
	ENDIF ELSE BEGIN
	    WIDGET_CONTROL, bad_id=i, txw_ltslider, Sensitive=0
	ENDELSE
    ENDIF
ENDELSE
IF N_ELEMENTS(n) LE 0 THEN n=1
IF (N_ELEMENTS(w) LE 0) OR (N_ELEMENTS(x) LE 0) THEN BEGIN
    tx_send_err_msg, txw_msg, 'No valid data to plot'
    tx_loaded = 0		    ; no data available
ENDIF ELSE BEGIN
    WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=1
    y=[0]			    ; Y is not yet used
    tx_update_w, tx_rwnb, x, y, w, n, e
				    ; Titles Stuff
    head_tit(tx_rwnb,0)=tx_numor
    x_tit(tx_rwnb)	=STRTRIM(tx_codes(tx_xsel), 2)
    IF x_tit(tx_rwnb) EQ 'EN' THEN x_tit(tx_rwnb)=x_tit(tx_rwnb)+'('+tx_unit+')'
    y_tit(tx_rwnb)	=STRTRIM(tx_codes(tx_wsel), 2)
    mon_txt=tx_monitor_changed(tx_nsel, tx_monitor, tx_codes)
    msg='Plot of '+tx_script(tx_numor, y_tit(tx_rwnb), x_tit(tx_rwnb), mon_txt)
    tx_send_msg, txw_msg, msg
    IF tx_cur_buf NE -1 THEN BEGIN
	IF tx_xrange(0) EQ -1 AND tx_yrange(0) EQ -1 THEN $
	    tx_calculate_ranges ELSE WIDGET_CONTROL, bad_id=i, txw_rg_but, /Set_button
	IF tx_loaded THEN tx_update_ranges
    ENDIF ELSE BEGIN
        tx_xrange=[0]
        tx_yrange=[0]
    ENDELSE
    tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
    IF tx_loaded THEN tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
    tx_loaded = 1		    ; data are now available
ENDELSE
RETURN
END

;******************************************************************************
PRO tx_end, wid ;**************************************************************
;******************************************************************************
; tx_end is invoked when tripx is interrupted
@lamp.cbk				    ; call lamp.cbk common block
COMMON txc_main				    ; call back tripx_face common

DON_WRITE_PROG_MAC ,1
;DID_WRITE_JOURNAL
	
IF tx_cur_buf NE -1 THEN BEGIN
    n=N_ELEMENTS(tx_history)
    lun=0 & on_ioerror,mis_his
    OPENW, lun, 'tripx.his', /Get_Lun,/APPEND
    PRINTF, lun, n, ' ***** ',!stime
    FOR i=0, n-1 DO $
    PRINTF, lun, tx_history(i)
    mis_his:FREE_LUN, lun
ENDIF
RETURN
END

;******************************************************************************
PRO tx_export, workspace_number, OWN=own ;*************************
;******************************************************************************
; Export to Workspace defined into text widget the workspace "workspace_number"

@lamp.cbk				    ; call lamp.cbk common block
COMMON txc_main				    ; call back tripx_face common

i_will=0				    ; Start tests for valid workspace
IF KEYWORD_SET(OWN) THEN export_str='W'+nb2str(own) ELSE BEGIN
    WIDGET_CONTROL, bad_id=i, txw_dp_txt, Get_Value=export_str
    export_str=STRTRIM(export_str(0),2)
ENDELSE
expstrln=STRLEN(export_str)
pos_w=STRPOS(STRUPCASE(export_str),'W')        
IF (pos_w eq 0) and (expstrln le 3) and (expstrln gt 1)  THEN BEGIN
    IF expstrln eq 3 THEN fig=STRMID(export_str,1,2) $
	    ELSE fig=STRMID(export_str,1,1)
    ON_IOERROR, no_fix1
    owk=fix(fig)
    IF owk LT 1 OR owk GT 23 THEN i_will=2 $
    ELSE BEGIN
	wnstr=nb2str(workspace_number)
	out_txt='w'+nb2str(owk)+'=w'+wnstr+'/n'+wnstr+$
		    '*total(n'+wnstr+')/N_ELEMENTS(n'+wnstr+')'
	xicute,out_txt
	i_will=1
    ENDELSE
ENDIF
no_fix1:
    IF i_will eq 0 THEN tx_save, export_str	; Save accumulator
    if i_will EQ 1 THEN BEGIN
	IF workspace_number EQ tx_awnb THEN str='accumulator' $
	ELSE str=tx_numor
	tx_send_msg, txw_msg,'Wrote '+str+' to w'+nb2str(owk)       
    ENDIF
    if i_will EQ 2 THEN $
    	tx_send_err_msg, txw_msg, 'W must be within 1-20'
END

;******************************************************************************
PRO tx_grant_w, wnb, x, y, w, n, e, tit, xtit, ytit, SubTit ;******************
;******************************************************************************
@lamp.cbk			    ; call lamp.cbk common block

iii=EXECUTE('x=x'+nb2str(wnb))  ; Fetch x data
iii=EXECUTE('y=y'+nb2str(wnb))  ; Fetch y data
iii=EXECUTE('w=w'+nb2str(wnb))  ; Fetch w data
iii=EXECUTE('n=n'+nb2str(wnb))  ; Fetch n data
iii=EXECUTE('e=e'+nb2str(wnb))  ; Fetch e data

iii=EXECUTE('tit=head_tit('+nb2str(wnb)+', 0)')	    ; Fetch Title
iii=EXECUTE('xtit=x_tit('+nb2str(wnb)+')')	    ; Fetch Xtitle
iii=EXECUTE('ytit=y_tit('+nb2str(wnb)+')')	    ; Fetch Ytitle
iii=EXECUTE('SubTit=other_tit('+nb2str(wnb)+', 0)') ; Fetch SubTitle

RETURN
END

;===============================================================================
PRO tx_help	, dummy, formu, formt
;===============================================================================

formu=''
formt='                                      By Yannick Raoul and Romuald Jouffrey.'
formu=[formu,'']
formt=[formt,'']
formu=[formu,'General principles :']
formt=[formt,'']
formu=[formu,'']
formt=[formt,'Left Draw is used to display loaded dataset, right one displays current accu']
formu=[formu,'']
formt=[formt,'Right/up : The axis selector and general parameters(move vertical slider)']
formu=[formu,'']
formt=[formt,'Bottom/center : calculation facilities']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'File selector :']
formt=[formt,'Select the correct path and choose the file you want to load (double click or return)']
formu=[formu,'']
formt=[formt,'Data are loaded and X and Y scales are detected (Counts versus Energy)']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Zoom :']
formt=[formt,'Enter zoom ranges or use left mouse button to select zoom area']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Remove point :']
formt=[formt,'Middle mouse button to select point(s) to be removed']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Add :']
formt=[formt,'Create a new accu with old accu and current loaded dataset (copy if accu was empty)']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Combine :']
formt=[formt,'Use factor to perform calculation : new_accu = old_accu+factor*dataset']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Reset and New Button :']
formt=[formt,'Reset erase all accumulators, new create a new empty accumulator']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'FIT :']
formt=[formt,'Run fit interface with current data or accumulator (left or right)']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Right slider :']
formt=[formt,'allows to go back to older accumulator']
RETURN
END

;******************************************************************************
PRO tx_initialize ;************************************************************
;******************************************************************************

COMMON txc_main			    ; call back tripx common block
COMMON txc_wd_id	    	    ; call back plot area common block
COMMON txc_buffer		    ; call back buffers common block

tx_cur_buf   =-1		    ; No buffer has been stored
tx_history   =['Empty accumulator'] ; 
tx_rwnb	    =21			    ; number of workspace to read data (21)
tx_awnb	    =22			    ; number of accumulator workspace (22)
tx_data	    =0			    ; Work to store tripx datas
tx_update_w, tx_awnb, [0], [0], [0], [0], [0] ; Clear accumulator workspace
tx_old_data =0			    ; ??? temporary buffer for w
tx_small_history=''		    ; Clear compiled history
tx_reset_buffers		    ; Clear & Initialize buffers
RETURN
END

;******************************************************************************
PRO tx_save, export_str ;******************************************************
;******************************************************************************


@lamp.cbk				    ; call lamp.cbk common block
COMMON txc_main				    ; call back tripx_face common

IF export_str NE '' AND tx_cur_buf NE -1 THEN BEGIN
tx_grant_w, tx_awnb, x, y, w, n, e, tit, xtit, ytit, SubTit
    lun=0 & on_ioerror,mis_sav
    OPENW,  lun, export_str, /Get_Lun
    PRINTF, lun, STRING(REPLICATE(82B, 80))
    PRINTF, lun, tx_small_history+'      1      0'
    PRINTF, lun, 'Tripx exported file : '+export_str
    PRINTF, lun, STRING(REPLICATE(65B, 80))    
    PRINTF, lun, '      80      0'
    PRINTF, lun, ''
    PRINTF, lun, STRING(REPLICATE(86B, 80))
    PRINTF, lun, 'INSTR: '+tx_par_str.instr
    PRINTF, lun, 'EXPNO: '+tx_par_str.expno
    PRINTF, lun, 'USER_: '+tx_par_str.user
    PRINTF, lun, 'LOCAL: '+tx_par_str.local
    PRINTF, lun, 'FILE_: '+export_str                                                                                                                                           
    PRINTF, lun, 'DATE_: '
    PRINTF, lun, 'TITLE: '+other_tit(tx_awnb, 0)
    PRINTF, lun, 'COMND: '+tx_par_str.comnd
    PRINTF, lun, 'COMM_: '
    PRINTF, lun, 'POLAN: '
    PRINTF, lun, 'POSQE: UN='+tx_unit
    PRINTF, lun, 'STEPS: '+tx_par_str.steps
    PRINTF, lun, 'PARAM:'                                                                                                                                                                                           
    PRINTF, lun, 'FORMT: (F8.3,2X,F8.3,2X,F8.3,2X,F8.3,2X,G10.3)'
    PRINTF, lun, 'DATA_:'
    str='PNT       '+tx_codes(tx_xsel)+'     '+tx_codes(tx_wsel)+$
	'         DELT       '+tx_codes(tx_nsel)
    PRINTF, lun, str
    FOR i=0, N_ELEMENTS(x)-1 do BEGIN
    PRINTF, lun,      STRING(   i+1, FORMAT='(I3)'), $
		 ' ', STRING(x(i), FORMAT='(TR2, F8.3)'), $
		 ' ', STRING(w(i), FORMAT='(TR2, F8.3)'), $
		 ' ', STRING(e(i), FORMAT='(TR2, F8.3)'), $
		 ' ', STRING(n(i), FORMAT='(TR2, G10.3)')
    ENDFOR
    tx_send_msg, txw_msg, 'Accu has been saved in '+export_str
    mis_sav:FREE_LUN, lun
ENDIF
RETURN
END

;******************************************************************************
PRO tx_see_buffers ;***********************************************************
;******************************************************************************
; To view buffer content

COMMON txc_buffer			; Retrieve buffers common block 

buffer_in_stock = N_ELEMENTS(tx_buffers)
FOR index=0, buffer_in_stock-1 DO BEGIN
	Print, 'Value of buffer ', index
	buffer_handle=tx_buffers(index)	; get handle
	IF buffer_handle NE 0 THEN BEGIN	
		Handle_Value, buffer_handle, buffer ; Get data from handle
	END
ENDFOR
RETURN
END

;******************************************************************************
PRO tx_plot, wid, wnb, x_range, y_range, type, PS=ps ;*************************
;******************************************************************************
; The unique plotting procedure for the whole tripx project (by JR)
; x_tit , y_tit , z_tit , w_tit , other_tit , head_tit

IF N_PARAMS() EQ 4 THEN type=0
tx_grant_w, wnb, x, y, w, n, e, tit, xtit, ytit, SubTit
IF  (N_ELEMENTS(x_range) EQ 1) AND (N_ELEMENTS(y_range) EQ 1) THEN norange=1 $
ELSE norange=0
avg=TOTAL(n)/(N_ELEMENTS(n))>1
m  =avg/(n>1)
IF NOT(KEYWORD_SET(PS)) THEN WSET,wid
yp=w*m
IF N_ELEMENTS(yp) GT 1 THEN BEGIN
    IF type EQ 0 THEN BEGIN
	IF norange THEN $
	PLOT, x, yp, $
	      Title=Tit, XTitle=XTit, YTitle=YTit, SubTitle=SubTit, LineStyle=0 $
	ELSE $
	PLOT, x, yp, XRange=x_range, YRange=y_range, $
	      Title=Tit, XTitle=XTit, YTitle=YTit, SubTitle=SubTit, LineStyle=0
	IF (N_ELEMENTS(x) GT 0) THEN OPLOTERR,x,yp,e*m
    ENDIF ELSE BEGIN
	OPLOT, x, yp, LineStyle=type
    ENDELSE
ENDIF
RETURN
END

;******************************************************************************
PRO tx_remove_points, wnb, removing_window		; *********************
;******************************************************************************

xx=[0.0] & ww=[0.0] & yy=[0.0] & ee=[0.0] & nn=[0.0]
tx_grant_w, wnb, x, y, w, n, e, tit, xtit, ytit, SubTit
IF N_ELEMENTS(x) GT 1 THEN BEGIN
    pnt_removed=0
    FOR i=0, N_ELEMENTS(x)-1 DO BEGIN
	IF  (x(i) GE removing_window(0) AND $
	     x(i) LE removing_window(1)) AND $
	    (w(i) GE removing_window(2) AND $
	     w(i) LE removing_window(3)) THEN BEGIN
	    pnt_removed=1
	ENDIF ELSE BEGIN
	    xx=[xx, x(i)]
	    ww=[ww, w(i)]
	    ;yy=[yy, y(i)]
	    nn=[nn, n(i)]
	    ee=[ee, e(i)]
	ENDELSE
    ENDFOR
    IF pnt_removed THEN BEGIN
	x=xx(1:*) & w=ww(1:*) & e=ee(1:*) & n=nn(1:*)
	tx_update_w, wnb, x, y, w, n, e
    ENDIF
ENDIF		
RETURN
END

;******************************************************************************
PRO tx_reset_buffers ;*********************************************************
;******************************************************************************
COMMON txc_buffer		; Retrieve buffers common block 

buffer_in_stock = N_ELEMENTS(tx_buffers)
FOR index=0,buffer_in_stock-1 DO BEGIN
	buffer_handle = tx_buffers(index)
	IF buffer_handle NE 0 THEN $
		Handle_Free, buffer_handle
END

tx_buffers = [0L]
tx_last_buffer = 0
END ; tx_reset_buffers

;******************************************************************************
PRO tx_send_msg, wid, txt_msg ;************************************************
;******************************************************************************
; Send a message into the relevant widget label

space_nb=MAX([0, (35-STRLEN(txt_msg))/2])
IF space_nb GT 0 THEN space=STRING(REPLICATE(32B, space_nb)) else space=''
txt_msg=space+txt_msg
WIDGET_CONTROL, bad_id=i, wid, Set_Value=txt_msg
RETURN
END

;******************************************************************************
PRO tx_send_err_msg, wid, txt_msg ;********************************************
;******************************************************************************
; beep and send a message into the relevant widget label (using tx_send_msg)

print, STRING(7B)
tx_send_msg, wid, txt_msg
RETURN
END

;******************************************************************************
PRO tx_store_parameters ;******************************************************
;******************************************************************************
@lamp.cbk			    ; call lamp.cbk common block
COMMON txc_main			    ; call back tripx_face common

; DATE
; TITRE
; COMND
; POSQE
; Nombre de donnees
; PARAMS et VARIABLES

res=tx_extract(par_txt(tx_rwnb,*), 'INSTR', '', instr)
IF res LT 0 THEN instr='error'
res=tx_extract(par_txt(tx_rwnb,*), 'EXPNO', '', expno)
IF res LT 0 THEN expno='error'
res=tx_extract(par_txt(tx_rwnb,*), 'USER_', '', user)
IF res LT 0 THEN user='error'
res=tx_extract(par_txt(tx_rwnb,*), 'LOCAL', '', local)
IF res LT 0 THEN local='error'
res=tx_extract(par_txt(tx_rwnb,*), 'FILE_', '', file)
IF res LT 0 THEN file='error'
res=tx_extract(par_txt(tx_rwnb,*), 'DATE_', '', date)
IF res LT 0 THEN date='error'
res=tx_extract(par_txt(tx_rwnb,*), 'TITLE', '', title)
IF res LT 0 THEN title='error'
res=tx_extract(par_txt(tx_rwnb,*), 'COMND', '', comnd)
IF res LT 0 THEN title='error'
res=tx_extract(par_txt(tx_rwnb,*), 'POSQE', '', posqe)
IF res LT 0 THEN posqe='error'
res=tx_extract(par_txt(tx_rwnb,*), 'STEPS', '', steps)
IF res LT 0 THEN steps='error'

tx_par_str={	instr:	instr	, expno:expno	, $
		user:	user	, local:local	, $
		file:	file	, date:date	, $
		title:	title	, comnd:comnd	, $
		posqe:	posqe	, steps:steps}

tx_par_txt=[			      $
	'Description	  :'	    , $
	'  Instrument	  : '+instr , $
	'  Exp. number	  : '+expno , $
	'  User		  : '+user  , $
	'  Local	  : '+local , $
	'  File           : '+file  , $
	'  Date           : '+date  , $
	'  Title	  : '+title , $
	'  Command	  : '+comnd , $
	'  PosQE	  : '+posqe , $
	'  steps	  : '+steps , $
	''	    , $
	'Historique       : '	    , $
	'Original dataset : '+file  , $
	''			    , $
	'Number of data   :'	    , $
	''			    , $
	'Header Info :']
v=par_txt(tx_rwnb,*)
FOR i=0, N_ELEMENTS(v)-1 DO BEGIN
    IF STRMID(v(i), 0, 5) EQ 'VARIA' OR STRMID(v(i), 0, 5) EQ 'PARAM' THEN BEGIN
	tx_par_txt=[tx_par_txt, v(i)]
    ENDIF
ENDFOR
RETURN
END

;******************************************************************************
PRO tx_unscript, txt, tx_numor, y_txt, x_txt, monitor_txt ;********************
;******************************************************************************
w_txt=txt

space=STRPOS(w_txt, ' ')
tx_numor=STRMID(w_txt, 0, space)
w_txt=STRMID(w_txt, space+1, STRLEN(w_txt)-space+1)

equal=STRPOS(w_txt, '=')
y_txt=STRMID(w_txt, 0, equal)
w_txt=STRMID(w_txt, equal+3, STRLEN(w_txt)-equal+1)

parenthesis=STRPOS(w_txt, '/')
x_txt=STRMID(w_txt, 0, parenthesis)
w_txt=STRMID(w_txt, parenthesis+2, STRLEN(w_txt)-parenthesis+1)

space=STRPOS(w_txt, ' ')
monitor_txt=w_txt
RETURN
END

;******************************************************************************
PRO tx_update_ranges ;*********************************************************
;******************************************************************************
COMMON txc_main

WIDGET_CONTROL, bad_id=i, txw_rg_but, Get_UValue=UV
IF N_ELEMENTS(tx_xrange) EQ 0 AND  N_ELEMENTS(tx_yrange) THEN BEGIN
    WIDGET_CONTROL, bad_id=i, UV(4), Set_Value=''
    WIDGET_CONTROL, bad_id=i, UV(5), Set_Value=''
    WIDGET_CONTROL, bad_id=i, UV(6), Set_Value=''
    WIDGET_CONTROL, bad_id=i, UV(7), Set_Value=''
ENDIF ELSE BEGIN
    WIDGET_CONTROL, bad_id=i, UV(4), Set_Value=nb2str(tx_xrange(0))
    WIDGET_CONTROL, bad_id=i, UV(5), Set_Value=nb2str(tx_xrange(1))
    WIDGET_CONTROL, bad_id=i, UV(6), Set_Value=nb2str(tx_yrange(0))
    WIDGET_CONTROL, bad_id=i, UV(7), Set_Value=nb2str(tx_yrange(1))
ENDELSE
RETURN
END

;******************************************************************************
PRO tx_update_w, wnb, x, y, w, n, e ;******************************************
;******************************************************************************
@lamp.cbk			    ; call lamp.cbk common block

iii=EXECUTE('x'+nb2str(wnb)+'=x')	; Update x data
iii=EXECUTE('y'+nb2str(wnb)+'=y')	; Update y data
iii=EXECUTE('w'+nb2str(wnb)+'=w')	; Update w data
iii=EXECUTE('n'+nb2str(wnb)+'=n')	; Update n data
iii=EXECUTE('e'+nb2str(wnb)+'=e')	; Update e data
RETURN
END

;******************************************************************************
PRO tripx_event, Event ;*******************************************************
;******************************************************************************
; ???

@lamp.cbk			    ; call lamp.cbk common block
COMMON txc_main			    ; call back tripx_face common
COMMON txc_wd_id		    ; call back plot area common block
COMMON txc_pb			    ; call back problem common block

wplot=!D.NAME
stat=0 & catch,stat
IF stat ne 0 THEN BEGIN catch,/cancel & print,string(7b),!err_string & SET_PLOT,wplot & return & ENDIF

WIDGET_CONTROL, bad_id=i,Event.Id,Get_UValue=uv,/Hourglass

uv1=uv(2)				; Get UValue code
IF N_ELEMENTS(uv) GT 3 then uv2=uv(3)	; and other optionnal code
IF N_ELEMENTS(uv) GT 4 then uv3=uv(4)
IF N_ELEMENTS(uv) GT 5 then uv4=uv(5)
IF N_ELEMENTS(uv) GT 6 then uv5=uv(6)
IF N_ELEMENTS(uv) GT 7 then uv6=uv(7)
IF N_ELEMENTS(uv) GT 8 then uv7=uv(8)
CASE uv1 OF
    -1	:  BEGIN & END				; *********** No event generated
     1	:  BEGIN				; *********** Tripx general events
	    CASE uv2 OF
	0 : BEGIN				; Print Button Event
		SET_PLOT, 'PS'
		tx_grant_w, tx_awnb, xa, ya, wa, na, ea, tit, xtit, ytit, SubTit 
		short_side = 18.0
		small_offset=0.5
		long_side = 13.0
		big_offset=14.0
		fn = 'idl.ps'
		DEVICE, bits=8, /color, xsize=short_side, ysize=long_side, $
		xoffset=small_offset, yoffset=big_offset, $
		/portrait, /isolatin1, filename=fn
		tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange, /PS
		FOR i=0, N_ELEMENTS(tx_par_txt)-1 DO BEGIN
		    IF tx_par_txt(i) EQ 'Number of data   :' THEN $
			tx_par_txt(i)=tx_par_txt(i)+' '+NB2STR(N_ELEMENTS(xa))
		    XYOUTS, 100, -360.-(i-1)*300., tx_par_txt(i), Size=0.8, /Device
		ENDFOR
		DEVICE, /close_file
		SET_PLOT,wplot
		tx_send_msg, txw_msg, 'Accu printed in idl.ps'
	    END
	1 : BEGIN				; Done Button Event
	    tx_end, txw_base			; Save tripx history
	    WIDGET_CONTROL, bad_id=i, txw_base, /Destroy
	    IF txw_base EQ lamp_b1 THEN WIDGET_CONTROL,/reset
	    END
	2 : BEGIN				; TOUCH BASE Button Event
	    TOUCH_B, 331, inst_value
	    END
	3 : BEGIN				; Help Button Event
	    show_helps, [-88, 593]
	    END
	4 : BEGIN				; formula DO event
		WIDGET_CONTROL, bad_id=i, uv3, Get_Value=str
		str=str(0)
		tx_send_msg, txw_msg, 'Executing '+str
		xicute, str
		tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange		
		tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
	    END
	5 : BEGIN				; export event
		IF tx_cur_buf GT -1 THEN BEGIN
		    IF tx_history(tx_cur_buf) EQ 'Empty accumulator' THEN $
			tx_export, tx_rwnb ELSE tx_export, tx_awnb
		ENDIF ELSE tx_export, tx_rwnb
	    END
	6 : BEGIN				; Left fit button
		IF tx_loaded THEN BEGIN
		    tx_export, tx_rwnb, OWN=23
		    gfit, Group=txw_base, /Tripx, tx_par_txt
		ENDIF ELSE tx_send_err_msg, txw_msg, 'Load data first'
	    END	    
	7 : BEGIN				; Right fit button
		IF tx_cur_buf GT -1 THEN BEGIN
		    IF tx_history(tx_cur_buf) EQ 'Empty accumulator' THEN BEGIN
			tx_send_err_msg, txw_msg, 'Accumulator is empty'
		    ENDIF ELSE BEGIN
			tx_export, tx_awnb, OWN=23
			gfit, Group=txw_base, /Tripx, tx_par_txt
		    ENDELSE
		ENDIF ELSE tx_send_err_msg, txw_msg, 'Accumulator is empty'
	    END
	8 : BEGIN				; Free event 
		IF txw_rg_but LT 0 THEN $
		    tx_send_err_msg, txw_msg, 'Load Data first ...' $
		ELSE BEGIN
		    
		ENDELSE	    
	    END
	ELSE: tx_send_err_msg, txw_msg, 'erreur dans le parsing de 1, x !'
	ENDCASE
	END
     2	: BEGIN				; *********** Parse pickfile events  
	    result=event.data		; filename from pickfile
	    flag=-1
	    IF result EQ 'path' THEN tx_path=event.PFO ELSE BEGIN
		IF result NE '' THEN BEGIN	; A valid filename has been given
		    flag=1
		    IF event.PFO ne '' then tx_path=event.PFO
		    ON_IOERROR, nofix2
		    r_number=FLOAT(result)
		    r_number=FIX(r_number)
		    tx_data=tx_read(r_number, 0)
		    IF N_ELEMENTS(tx_data) GT 1 THEN tx_data_process ELSE $
		    tx_send_err_msg, txw_msg, 'File input Error'
		    flag=0
		ENDIF
		nofix2 : IF flag EQ 1 THEN BEGIN
		    tx_data=tx_read(result, 1)
		    ;IF N_ELEMENTS(tx_data) GT 1 THEN tx_data_process ELSE $
		    ;tx_send_err_msg, txw_msg, 'File input Error'
		    tx_data_process
		ENDIF
	    ENDELSE
	  END
     3	:   BEGIN				; *********** Axis & monitor selection
	    WIDGET_CONTROL, bad_id=i, Event.id, Get_Value=selected
	    CASE uv2 OF
	    1 : BEGIN			    ; X axis selected
		    tx_xsel=selected
		    msg='X-axis now '+tx_codes(tx_xsel)
		    tx_send_msg, txw_msg, msg
		END
	    2 : BEGIN			    ; Y axis selected
		    tx_ysel=selected
		END
	    3 : BEGIN			    ; W axis selected
		    tx_wsel=selected
		    tx_send_msg, txw_msg, 'Intensity-axis now '+tx_codes(tx_wsel)
		END
	    4 : BEGIN			    ; N axis selected
		    WIDGET_CONTROL, bad_id=i, uv4, Get_Value=v
		    tx_nsel=uv3-1
		    mon_txt=tx_monitor_changed(tx_nsel, tx_monitor, tx_codes)
		    WIDGET_CONTROL, bad_id=i, uv5, Set_Value=mon_txt
		    tx_send_msg, txw_msg, 'Monitor now '+mon_txt
		END
	    ELSE: tx_send_err_msg, txw_msg, 'erreur dans le parsing de 2, x !'
	    ENDCASE
	    tx_data_process			; do data process
	    END
     4	:   BEGIN				; *********** Calculation events
	    CASE uv2 OF
	    1 : BEGIN				; combine event
		IF NOT(tx_loaded) THEN BEGIN
		    tx_send_err_msg, txw_history, 'No Data to combine !!!'
		ENDIF ELSE BEGIN
		    oper='c'
		    IF tx_cur_buf EQ -1 THEN oper='s' ELSE $
		    IF tx_history(tx_cur_buf) EQ 'Empty accumulator' THEN oper='s'
		    mon_txt=tx_monitor_changed(tx_nsel, tx_monitor, tx_codes)
		    msg=tx_script(tx_numor, y_tit(tx_rwnb), x_tit(tx_rwnb), mon_txt)
		    IF oper EQ 's' THEN BEGIN
			tx_store_parameters
			msg=msg+' stored'
		    ENDIF ELSE msg=msg+' combined'
		    res=tx_calculate(tx_awnb, oper, tx_rwnb, tx_xtol, $
				     msg, txw_basec, tx_factor, tx_monitor)
		    IF res GE 0 THEN BEGIN
			IF oper EQ 's' THEN tx_small_history=head_tit(tx_rwnb, 0) ELSE $
			tx_small_history=tx_small_history+oper+head_tit(tx_rwnb, 0)
			other_tit(tx_awnb)=tx_small_history
			strl=STRLEN(tx_small_history)
			IF strl GT 60 THEN $
			    other_tit(tx_awnb)=STRMID(tx_small_history, 0, 30)+'...'+$
					       STRMID(tx_small_history, strl-30, strl)
			tx_calculate_ranges
			tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
			tx_calculate_ranges, 2
			tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
		    ENDIF
		ENDELSE
	    END
	    2 : BEGIN				; Add event
		IF NOT(tx_loaded) THEN BEGIN
		    tx_send_err_msg, txw_history, 'No Data to add !!!'
		ENDIF ELSE BEGIN
		    oper='+'
		    IF tx_cur_buf EQ -1 THEN oper='s' ELSE $
		    IF tx_history(tx_cur_buf) EQ 'Empty accumulator' THEN oper='s'
		    mon_txt=tx_monitor_changed(tx_nsel, tx_monitor, tx_codes)
		    msg=tx_script(tx_numor, y_tit(tx_rwnb), x_tit(tx_rwnb), mon_txt)
		    IF oper EQ 's' THEN BEGIN
			tx_store_parameters
			msg=msg+' stored'
		    ENDIF ELSE msg=msg+' added'
		    res=tx_calculate(tx_awnb, oper, tx_rwnb, tx_xtol, $
				     msg, txw_basec, tx_factor, tx_monitor)
		    IF res GE 0 THEN BEGIN
			IF oper EQ 's' THEN tx_small_history=head_tit(tx_rwnb, 0) ELSE $
			tx_small_history=tx_small_history+oper+head_tit(tx_rwnb, 0)
			other_tit(tx_awnb)=tx_small_history
			strl=STRLEN(tx_small_history)
			IF strl GT 60 THEN $
			    other_tit(tx_awnb)=STRMID(tx_small_history, 0, 30)+'...'+$
					       STRMID(tx_small_history, strl-30, strl)
			tx_calculate_ranges
			tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
			tx_calculate_ranges, 2
			tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
		    ENDIF
		ENDELSE
	    END
	    3 : BEGIN			; calculation factor event
		    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=v
		    ON_IOERROR, no_fix4
		    tx_factor=FLOAT(v)
		    tx_send_msg, txw_msg, 'Factor is '+v+' now'
		    no_fix4 : BEGIN & END
		END
	    4 : BEGIN				; Reset Button event
		tx_initialize
		tx_send_msg, txw_history, tx_history(0)
		WIDGET_CONTROL, bad_id=i, txw_rtslider, Set_Value=0
		WIDGET_CONTROL, bad_id=i, txw_slid_lab, Set_Value='Frame #0'
		WIDGET_CONTROL, bad_id=i, txw_rtslider, Sensitive=0
		WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=1
		WSET, txw_d2 & ERASE
		XYOUTS, 110, 100, 'Empty accumulator', /Device
	    END
	    5 : BEGIN				; New Button event
	    IF tx_cur_buf NE -1 THEN $		; only if current isn't empty
		IF tx_history(tx_cur_buf) NE 'Empty accumulator' THEN BEGIN
		tx_update_w, tx_awnb, [0], [0], [0], [0], [0]
		WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=1
		WSET, txw_d2 & ERASE
		tx_small_history=''
		XYOUTS, 110, 100, 'Empty accumulator', /Device
		tx_accumulate, tx_awnb, 'Empty accumulator'
	    ENDIF
	    END
	ELSE : see, 'error de uvalue 4, x'   
	ENDCASE
	END
     5	:  BEGIN				; *********** Draw & slider events
	    CASE uv2 OF
	1 : BEGIN			; Widget Plot Area 1 Event
	    IF tx_loaded EQ 1 AND event.type EQ 0 THEN BEGIN
		    wset,txw_d1
		    CURSOR,xg,yg, /NoWait, /Data		    
		    res=sl_zoom(event.x,event.y,xd,yd)
		    CURSOR,xh,yh, /NoWait, /Data
		    IF res EQ 0 THEN BEGIN ; No zoom range, write coodinates
			txstr=nb2str(xh)+','+nb2str(yh)
			XYOUTS,xh,yh,txstr,/Noclip
		    ENDIF
		    IF res EQ 1 THEN BEGIN
			tx_xrange=[MIN([xg, xh]), MAX([xg, xh])]
			tx_yrange=[MIN([yg, yh]), MAX([yg, yh])]
			tx_update_ranges
			WIDGET_CONTROL, bad_id=i, txw_rg_but, /Set_button
			tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
		    ENDIF
		    IF res EQ -2 THEN BEGIN	; Remove point(s)
			removing_window=[MIN([xg, xh]), MAX([xg, xh]), $
					 MIN([yg, yh]), MAX([yg, yh])]
			tx_remove_points, tx_rwnb, removing_window
			tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
		    ENDIF
		    IF res EQ -3 THEN BEGIN	; Free event
		    ENDIF
	    ENDIF ELSE tx_send_msg, txw_msg, 'You must load data first'
	    END
	2 : BEGIN			; Widget Plot Area 2 Event
	    IF tx_cur_buf EQ -1 THEN $
		tx_send_msg, txw_msg, 'Accu must not be empty' $
	    ELSE IF tx_history(tx_cur_buf) EQ 'Empty accumulator' THEN $
		tx_send_msg, txw_msg, 'Accu must not be empty'	    
	    IF tx_loaded EQ 0 THEN $
		tx_send_msg, txw_msg, 'You must load data first'
	    IF tx_loaded EQ 1 AND event.type EQ 0 AND tx_cur_buf NE -1 THEN $
		 IF tx_history(tx_cur_buf) NE 'Empty accumulator' THEN BEGIN
		    wset,txw_d2
		    CURSOR,xg,yg, /NoWait, /Data		    
		    res=sl_zoom(event.x,event.y,xd,yd)
		    CURSOR,xh,yh, /NoWait, /Data
		    IF res EQ 0 THEN BEGIN ; No zoom range, write coodinates
			txstr=nb2str(xh)+','+nb2str(yh)
			XYOUTS,xh,yh,txstr,/Noclip
		    ENDIF
		    IF res EQ 1 THEN BEGIN
			tx_xrange=[MIN([xg, xh]), MAX([xg, xh])]
			tx_yrange=[MIN([yg, yh]), MAX([yg, yh])]
			tx_update_ranges
			WIDGET_CONTROL, bad_id=i, txw_rg_but, /Set_button
			tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
		    ENDIF
		    IF res EQ -2 THEN BEGIN	; Remove point(s)
			removing_window=[MIN([xg, xh]), MAX([xg, xh]), $
					 MIN([yg, yh]), MAX([yg, yh])]
			tx_remove_points, tx_awnb, removing_window
			tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
			tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
		    ENDIF
		    IF res EQ -3 THEN BEGIN	; free event
		    ENDIF
	    ENDIF
	    END
	3 : BEGIN				; Left Slider event 
		WIDGET_CONTROL, bad_id=i, event.id, Get_Value=V
		tx_send_msg, txw_msg, 'Polarization #'+nb2str(V)+' selected'
	    END
	4 : BEGIN				; Right slider event
	    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=nb		
	    IF (nb GT 0) AND (tx_cur_buf EQ -1) THEN BEGIN
		nb=0 & WIDGET_CONTROL, bad_id=i, event.id, Set_Value=0	    
	    ENDIF
	    IF (tx_cur_buf NE nb) THEN BEGIN
		tx_cur_buf=nb
		tx_send_msg, txw_history, tx_history(nb)
		WIDGET_CONTROL, bad_id=i, txw_slid_lab, Set_Value='Frame #'+nb2str(nb)
		IF (nb EQ 0) OR (tx_history(nb) EQ 'Empty accumulator') THEN BEGIN
		    WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=1
		    WSET, txw_d2 & ERASE
		    XYOUTS, 110, 100, 'Empty accumulator', /Device
		ENDIF ELSE BEGIN
		    res=tx_get_buffer(nb, tx_awnb)
		    IF STRPOS(tx_history(nb), 'combined') GE 0 THEN BEGIN
			WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=0
		    ENDIF ELSE BEGIN
			WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=1
		    ENDELSE
		    iii=nb
		    WHILE (tx_history(iii) NE 'Empty accumulator') DO iii=iii-1
		    iii=iii+1
		    WHILE  (iii NE nb+1) DO BEGIN
			IF (tx_history(iii) NE 'Empty accumulator') THEN BEGIN
			IF (STRPOS(tx_history(iii), 'stored')) GE 0 THEN oper='s'
			IF (STRPOS(tx_history(iii), 'added')) GE 0 THEN oper='+'
			IF (STRPOS(tx_history(iii), 'combined')) GE 0 THEN oper='c'
			tx_unscript, tx_history(iii), name, p2, p3, p4
			IF oper EQ 's' THEN tx_small_history=name ELSE $
			tx_small_history=tx_small_history+oper+name
			iii=iii+1
			ENDIF
		    ENDWHILE
		    other_tit(tx_awnb)=tx_small_history
		    strl=STRLEN(tx_small_history)
		    IF strl GT 60 THEN $
		    other_tit(tx_awnb)=STRMID(tx_small_history, 0, 30)+'...'+$
				       STRMID(tx_small_history, strl-30, strl)
		    tx_calculate_ranges, 2
		    tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
		ENDELSE
	    ENDIF
	    END
	5 : BEGIN				; ... event 
		see, 'free event 5, 5'
	    END
	6 : BEGIN				; ... event 
		see, 'free event 5, 6'
	    END
	ELSE : see, 'error de uvalue 5, x'
	ENDCASE
	END
     6	:  BEGIN				; *********** Parameters events
	   CASE uv2 OF
	1 : BEGIN			; Tolerance value modif.
		flag=0
		WIDGET_CONTROL, bad_id=i, event.id, Get_Value=v
		ON_IOERROR, nofix1
		tx_xtol=FLOAT(v)
		flag=1
		tx_send_msg, txw_msg, 'New X tolerance : '+v+'%'
	    	nofix1 : BEGIN
		IF flag EQ 0 THEN $
		    tx_send_err_msg, txw_msg, 'Cannot convert to float'
		END
	    END
	2 : BEGIN			; Temperature value modif.
	    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=v
	    tx_send_msg, tx_msg, v+' is new Temperature'
	    END
	3 : BEGIN			; Toggle for Range
	    flag=0
	    IF event.Select EQ 1 THEN BEGIN
		WIDGET_CONTROL, bad_id=i, uv3, Get_Value=xminstr
		WIDGET_CONTROL, bad_id=i, uv4, Get_Value=xmaxstr
		WIDGET_CONTROL, bad_id=i, uv5, Get_Value=yminstr
		WIDGET_CONTROL, bad_id=i, uv6, Get_Value=ymaxstr
		tx_grant_w, tx_rwnb, x, y, w, n, e, tit, xtit, ytit, SubTit
		tx_grant_w, tx_awnb, xa, ya, wa, na, ea, tit, xtit, ytit, SubTit
		ON_IOERROR, nofix3
		IF xminstr(0) EQ '' THEN xmin=MIN([x, xa]) ELSE xmin=FLOAT(xminstr(0))
		IF xmaxstr(0) EQ '' THEN xmax=MAX([x, xa]) ELSE xmax=FLOAT(xmaxstr(0))
		IF yminstr(0) EQ '' THEN ymin=MIN([w, wa]) ELSE ymin=FLOAT(yminstr(0))
		IF ymaxstr(0) EQ '' THEN ymax=MAX([w, wa]) ELSE ymax=FLOAT(ymaxstr(0))
		flag=1
		tx_xrange=[xmin, xmax]
		tx_yrange=[ymin, ymax]
		tx_send_msg, txw_msg, 'Using selected ranges'
	    ENDIF ELSE BEGIN
		flag=1
		tx_calculate_ranges
		tx_send_msg, txw_msg, 'No range'
	    ENDELSE
	    nofix3 : BEGIN
		IF flag EQ 0 THEN $
		    tx_send_err_msg, txw_msg, 'Cannot convert to float'
		END
		tx_plot, txw_d2, tx_awnb, tx_xrange, tx_yrange
		tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
		tx_plot, txw_d1, tx_awnb, tx_xrange, tx_yrange, 1
	    END
	4 : BEGIN			; Unit MeV button event
	    IF tx_codes(tx_xsel) EQ 'EN  ' THEN BEGIN
		IF STRUPCASE(tx_unit) EQ 'THZ' THEN BEGIN
		    tx_grant_w, tx_rwnb, x, y, w, n, e, tit, xtit, ytit, SubTit
		    x=x*4.13547
		    x_tit(tx_rwnb)=tx_numor+' (meV)'
		    tx_update_w, tx_rwnb, x, y, w, n, e
		    tx_send_msg, txw_msg, 'Unit changed to meV'
		    tx_unit='meV'
		    tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
		ENDIF ELSE tx_send_msg, txw_msg, "Current unit isn't THz"
	    ENDIF
	    END
	5 : BEGIN			; Unit Thz button event
	    IF tx_codes(tx_xsel) EQ 'EN  ' THEN BEGIN
		IF STRUPCASE(tx_unit) EQ 'MEV' THEN BEGIN
		    tx_grant_w, tx_rwnb, x, y, w, n, e, tit, xtit, ytit, SubTit
		    x=x/4.13547
		    x_tit(tx_rwnb)=tx_numor+' (THz)'
		    tx_update_w, tx_rwnb, x, y, w, n, e
		    tx_send_msg, txw_msg, 'Unit changed to THz'
		    tx_unit='THz'
		    tx_plot, txw_d1, tx_rwnb, tx_xrange, tx_yrange
		ENDIF ELSE tx_send_msg, txw_msg, "Current unit isn't meV"
	    ENDIF
	    END
	6 : BEGIN			; Range is on
	    WIDGET_CONTROL, bad_id=i, txw_rg_but, /Set_button
	    ; Simulate range button set
	    tripx_event, {ID: txw_rg_but, TOP : txw_base, Handle: 0L, Select : 1}
	    END
	7 : BEGIN			; Unit field event
		ON_IOERROR, nofix4
		WIDGET_CONTROL, bad_id=i, event.id, Get_Value=v
		tx_monitor=FLOAT(v)
		nofix4 : BEGIN & END
	    END
	8 : BEGIN			; view parameters event
		par_base    =WIDGET_BASE(Title=tx_numor+' parameters')
		txt=par_txt(tx_rwnb, *)
		FOR i=0, N_ELEMENTS(txt)-1 DO BEGIN
		    IF STRMID(txt(i), STRLEN(txt(i))-1, 1) EQ '=' THEN $
			txt(i)=STRMID(txt(i), 0, STRLEN(txt(i))-1)
		ENDFOR
		par_text    =WIDGET_TEXT(par_base, Xsize=50, YSize=15, $
					 Value=txt, Font=ft_propor, $
					 /Scroll, Editable=0)
		WIDGET_CONTROL, bad_id=i, par_base, Group_Leader=txw_base, /Realize
	    END
	ELSE : see, 'error de uvalue 6, x'
	ENDCASE
	END
    ELSE : see, 'error de uvalue x, x'
    ENDCASE	
END

;******************************************************************************
PRO tripx, Three_Axis=three_axis ;*********************************************
;******************************************************************************
; Create the main Tripx Interface,  do initialisations and register tripx
; to Xmanager. This procedure generated widgets, their events are handled by
; the tripx_event procedure,  just above (I presume ;-)

@lamp.cbk			    ; call lamp.cbk common block
COMMON txc_main			    ; call back tripx common block
COMMON txc_wd_id		    ; call back plot area common block
COMMON txc_pb			    ; call back problem common block

IF XREGISTERED('tripx') le 0 THEN BEGIN	; if tripx isn't registered yet
    stradd=0				; Screen size dependent adjustement
    IF lamp_siz GT 900 THEN BEGIN
	xs=450
	ys=300
	strs=34
    ENDIF ELSE BEGIN
	IF lamp_siz GE 800 THEN BEGIN
	    xs=410
	    ys=280
	    strs=27
	ENDIF ELSE BEGIN
	    xs=350
	    ys=250    
	    strs=30
	    stradd=8
	ENDELSE
    ENDELSE
    tx_initialize			    ; Do initialisations
    tx_xsel	    =-1			    ; No x data axis is selected
    tx_ysel	    =-1			    ; No y data axis is selected
    tx_wsel	    =-1			    ; No w data axis is selected
    tx_nsel	    =-1	   		    ; No monitor axis is selected
    tx_xrange	    =[-1]		    ; Xrange is undefined
    tx_yrange	    =[-1]		    ; Yrange is undefined
    tx_update_w, tx_rwnb, [0], [0], [0], [0], [0]  ; Clear current workspace
    tx_old_codes=''
    tx_codes    =' '
    tx_eg_txt   =[-1]
    tx_old_eg_txt=[0]			    ;
    tx_monitor	=10000.0		    ; Default monitor value
    tx_numor    =''			    ; No file has been read
    tx_loaded   =0			    ; No file has been correctly loaded
    tx_factor	=1.0
    tx_xtol	=10.0
    txw_rg_but	=-1			    ; build buttons has not been done
    x_tit(tx_rwnb)=''			    ; Title initialize
    x_tit(tx_awnb)=''
    y_tit(tx_rwnb)=''	
    y_tit(tx_awnb)=''
    head_tit(tx_rwnb,0)=''
    head_tit(tx_awnb,0)='ACCUMULATOR'

    junk   = { CW_PDMENU_S, flags:0, name:'' }
    txw_base	=   WIDGET_BASE(/Column, $
		Title='Tripx_Face : The 3-axes LAMP interface 05/02/96', /Frame, $
		Resource_Name='lamp', /Map)
		
    filter =   ''
    IF KEYWORD_SET(Three_Axis) THEN BEGIN
	lamp_b1=txw_base
        tx_path=lamp_dvd+'hosts'+lamp_dvd+'serdon'+lamp_dvd+'illdata/data'+lamp_dvd
	path_for_online=tx_path
        IF lamp_dvd EQ ''  THEN begin tx_path=getenv('DI1')
    				      filter = '*.SCN;0'
				      ENDIF
    ENDIF ELSE BEGIN
        tx_path=path_for_online
    ENDELSE

;***    
    txw_base1	=   WIDGET_BASE(txw_base, /Row)
    base3x_0	=   WIDGET_BASE	    (txw_base1, /Column, /Frame,Resource_Name='mic')
    base3x_00	=   WIDGET_BASE	    (base3x_0, /Row, /Map)
    txw_done_but=   WIDGET_BUTTON   (base3x_00, Value='DONE', $
				     Font=ft_b_bigger, UValue=[-88, 357, 1, 1])   
    txw_tb_but	=   WIDGET_BUTTON   (base3x_00, Value='Touch', $
				     Font=ft_b_bigger,UValue=[-88, 357, 1, 2])
    txw_prt_but	=   WIDGET_BUTTON   (base3x_00, Value='Print', $
				     Font=ft_b_bigger,UValue=[-88, 357, 1, 0])
    txw_help_but=   WIDGET_BUTTON   (base3x_00, Value='HELP', $
				     Font=ft_b_bigger,UValue=[-88, 357, 1, 3])

    txw_pickbase=   WIDGET_BASE	    (base3x_0, /Column)
    ; ****************************** Widgets for file selection
    tx_files	=   ['No File']
    file	=   ''
    pick_fil, txw_pickbase, tx_path, filter, tx_files, file, 357, pfw_upd_but
;***
    ; ****************************** Widget base for axis selections
    bidon	=   WIDGET_LABEL    (txw_base1,Font=ft_propor,value='          ')
    txw_but_b   =   WIDGET_BASE	    (txw_base1,/column)
    txw_but_0   =   WIDGET_BASE	    (txw_but_b)
    txw_but_base=   WIDGET_DRAW	    (txw_but_0,xsize=525,ysize=280)
;   txw_but_base=   WIDGET_BASE	    (txw_but_0, /Map)
    IF stradd eq 0  THEN $
    bidon	=   WIDGET_LABEL    (txw_but_b,value='... 3-AXES GROUP ...',Font=ft_biggest)
    ; Set up a base for each row of buttons with data description and example
;***
    ; ****************************** The Label Widget to display messages
    midbase	=   WIDGET_BASE	    (txw_base, /Row,Resource_Name='did')
    txw_msg	=   WIDGET_TEXT	    (midbase, Frame=1, Font=ft_propor, $
				     Scroll=0, XSize=35+stradd, YSize=1)
    formula_base=   WIDGET_BASE	    (midbase, /Row, /Frame)
    txw_form_txt=   WIDGET_TEXT	    (formula_base, Font=ft_propor, /Edit, $
				     Value='Formula Entry field', XSize=strs+stradd)
    txw_do_form =   WIDGET_BUTTON   (formula_base, Font=ft_propor, Value='DO')
    WIDGET_CONTROL, bad_id=i, txw_form_txt, Set_UValue=[-88, 357, 1, 4, txw_form_txt]
    WIDGET_CONTROL, bad_id=i, txw_do_form,  Set_UValue=[-88, 357, 1, 4, txw_form_txt]
    txw_history	=   WIDGET_TEXT	    (midbase, Frame=1, Font=ft_propor, $
				     Value='', XSize=35+stradd, YSize=1)

    ; ****************************** The base for the two plotting fields
    base_3x_draw=   WIDGET_BASE	    (txw_base, /Row, /Map, UValue='',Resource_Name='don')

    ; ****************************** The first Widget Draw ...
    tx_d1_base	=   WIDGET_BASE	    (base_3x_draw, /Column,  Frame=2)
    tripx_draw1	=   WIDGET_DRAW	    (tx_d1_base, XSize=xs, YSize=ys, $
				     Button_Events=1,Retain=2,Frame=1, $
				     UValue=[-88, 357, 5, 1])
    txw_ltslider=   WIDGET_SLIDER   (tx_d1_base, XSize=xs, YSize=20, /Suppress_value, $
				     Value=1, Min=1, Max=2, UValue=[-88, 357, 5, 3])

    ; ****************************** Widgets for calculations
    control_base=   WIDGET_BASE	    (base_3x_draw, /Column)
    frame_base	=   WIDGET_BASE	    (control_base, /Column, /Frame)
    frame_bfct	=   WIDGET_BASE     (frame_base,   /row)
    txw_a_lab   =   WIDGET_LABEL    (frame_bfct, Font=ft_b_normal, Value='Factor')
    txw_afct_txt=   WIDGET_TEXT	    (frame_bfct, Font=ft_propor, /Edit, XSize=4, $
				     Value='1.0', UValue=[-88, 357, 4, 3])
    comb	=   WIDGET_BUTTON   (frame_base,Font=ft_b_normal, $
				     UValue=[-88, 357, 4, 1],Value = " Combine ")
    add		=   WIDGET_BUTTON   (control_base,Font=ft_b_normal, $
				     UValue=[-88, 357, 4, 2],Value = " add ")
    frame_base	=   WIDGET_BASE	    (control_base, /Column, /Frame)
    c_base	=   WIDGET_BASE	    (frame_base, /Row)
    txw_call_but=   WIDGET_BUTTON   (c_base, Font=ft_b_normal, Value='Reset', $
				     UValue=[-88, 357, 4, 4])   
    clear	=   WIDGET_BUTTON   (c_base, Font=ft_b_normal, Value=' New ', $
				     UValue=[-88, 357, 4, 5]) 
    frame_base	=   WIDGET_BASE	    (control_base, /Column, /Frame)
    txw_gf_base =   WIDGET_BASE	    (frame_base, /Row)
    txw_left_gk =   WIDGET_BUTTON   (txw_gf_base, Font=ft_b_normal, Value=' <-Fit',$
				     UValue=[-88, 357, 1, 6])
    txw_right_gk=   WIDGET_BUTTON   (txw_gf_base, Font=ft_b_normal, Value='Fit-> ',$
				     UValue=[-88, 357, 1, 7])
    dump_lab	=   WIDGET_LABEL    (control_base,Value="Save Accu in", Font=ft_b_normal)
    txw_dp_txt	=   WIDGET_TEXT	    (control_base,UValue=[-88, 357, 1, 5], $
				     Value='w1', /Edit, xs = 10)
    txw_slid_lab=   WIDGET_LABEL    (control_base, Font=ft_propor, Value="Frame #0")
    ne_base	=   WIDGET_BASE	    (control_base, /NonExclusive)
    txw_rg_but	=   WIDGET_BUTTON   (ne_base, Font=ft_b_normal, Value='Zoom')
    ; ****************************** End of widgets for calculations

    ; ****************************** ... The second Widget Draw.
    tx_d2_base	=   WIDGET_BASE	    (base_3x_draw, /Column,  Frame=2)    
    tripx_draw2	=   WIDGET_DRAW	    (tx_d2_base,XSize=xs,YSize=ys, $
				     Button_Events=1,Retain=2,Frame=1, $
				     UValue=[-88, 357, 5, 2])
    txw_rtslider=   WIDGET_SLIDER   (tx_d2_base, XSize=xs, YSize=20, /Drag, /Suppress_value, $
				     Value=0, Max=1, UValue=[-88, 357, 5, 4])
    bid=sys_dep('DYNLAB',txw_base,1)

    ; ****************************** Create tripx interface ...
    WIDGET_CONTROL, bad_id=i, txw_base, Group_Leader=lamp_b1, /Realize
    ; ****************************** ... and make post initialisations

    p_after_realize_did, 0, 0, 0

	   pixmap=0 & LOGO,pixmap
	   WIDGET_CONTROL, bad_id=i,txw_but_base,get_value=idw
	   !order=1 & wset,idw
	   if n_elements(pixmap) eq 1 then $
	   if lamp_siz  ge 800 then device,copy=[0,0,512,256,    0  ,  0  ,pixmap] $
		else device,copy=[0,0,300,150,(525-300)/2,(280-150)/2,pixmap]
	   !order=0
;
    IF KEYWORD_SET(Three_Axis) THEN IF inst_group NE '3Axes' THEN BEGIN
        inst_group='3Axes'
        inst_value='IN8'
    ENDIF
    tx_send_msg, txw_history, tx_history(0)
    
   ;WIDGET_CONTROL, bad_id=i, control_base, Sensitive=0
    WIDGET_CONTROL, bad_id=i, txw_ltslider, Sensitive=0
    WIDGET_CONTROL, bad_id=i, txw_rtslider, Sensitive=0
    txw_basec=comb
    WIDGET_CONTROL, bad_id=i, txw_basec, Sensitive=0
    ; Get drawable window indexes
    WIDGET_CONTROL, bad_id=i, tripx_draw1, GET_VALUE=txw_d1
    WIDGET_CONTROL, bad_id=i, tripx_draw2, GET_VALUE=txw_d2
    WSET, txw_d1 & ERASE
    XYOUTS, 140, 110, 'No data ...', /Device
    XYOUTS, 10,  40, 'W'+nb2str(tx_rwnb)+ $
	    ' is used here.', /Device
    XYOUTS, 10,  20, 'Use formula entry to store it into a LAMP W. ie : w1=w'+nb2str(tx_rwnb), /Device
    WSET, txw_d2 & ERASE
    XYOUTS, 110, 100, 'Empty accumulator', /Device
    XYOUTS, 10,  40, 'W'+nb2str(tx_awnb)+ $
	    ' is used here.', /Device
    XYOUTS, 10,  20, 'It can be automatically saved as W# set in "save as"',  /Device
    dummy=pick_fil_event({ID: pfw_upd_but, TOP : txw_base, Handle: 0L,  Select : 1}) 
    
    XMANAGER, 'TRIPX', txw_base, /Just_Reg, Cleanup='tx_end'
ENDIF ELSE BEGIN
    WIDGET_CONTROL, bad_id=i, txw_base, /Map    ; Show existing Tripx	
ENDELSE
END
PRO tscan,count 

w=900
;tstart=20
;tstop=60
;tstep=20
;count=1


co,2,'t n'
wait,.5

t=[8,20,50,80,110,130,150,170,210,250,280,300]
points=12

;for i=tstart,tstop,tstep do begin
;d17mad,'pte '+strtrim(string(i),2)

for i=0,points-1 do begin
d17mad,'pte '+strtrim(string(t(i)),2)
wait,w

d17mad,'temp'
mv,'trs',0
mv,'san',0

dial_autoalign,20.,0.4

setup

d17mad,'par sub 0T '+strtrim(string(t(i)),2)+' K'
wait,.5
co,2,'t n'
wait,.5
co,2,'t n'
wait,.5
d17mad,'temp'
co,count,' t'
d17mad,'temp'

endfor

end
FUNCTION tt2d,w,lambda=wl,zeroshift=z
 ; 2qtrue = 2qexp.-ZER (FULLPROF)

IF NOT KEYWORD_SET(z) THEN z=0
take_datp,datp
IF NOT KEYWORD_SET(wl) THEN wl=datp.p(33)
tt=datp.x(*,0)-z
e=datp.e
range=where(tt gt 1)
tt=tt(range)
wout=w(range,*)
IF N_ELEMENTS(E) EQ N_ELEMENTS(w) THEN e=e(range,*)
if n_elements(wl) eq 0 then if n_elements(datp.p) gt 9 then if datp.p(9) NE 0.0 THEN wl =datp.p(9) 
if n_elements(wl) eq 1 THEN BEGIN
  d=wl/(2.*sin(!pi/360.*tt))
  idx=sort(d)
  mod_datp,datp,'x',d(idx)
  IF N_ELEMENTS(E) EQ N_ELEMENTS(wout) THEN BEGIN
    mod_datp, datp, 'E', e(idx,*)
  ENDIF ELSE mod_datp, datp, 'E',0
  mod_datp,datp,'x_tit','d/Angstrom'
  wout=wout(idx,*)
  give_datp,datp
  return,wout
ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
ENDELSE
END
FUNCTION tt2q,w,wavelength=wl,ZEROSHIFT=z,printer=printer
ww=w
take_datp,datp
IF NOT KEYWORD_SET(z) THEN z=0
IF NOT KEYWORD_SET(wl) THEN wl=datp.p(33)
x=datp.x-z
e=datp.e
range=where(x gt 0)
x=x(range)
ww=ww(range,*)
e=e(range,*)
IF max(x) GE 170 OR datp.x_tit NE '2*Theta' THEN BEGIN
  IF max(x) GE 170 THEN PRINT,'Attention, your 2Theta is too large!' ELSE PRINT,'Attention, your x_tit is not 2*Theta!'
ENDIF ELSE BEGIN
 if n_elements(wl) eq 0 then if n_elements(datp.p) gt 9 then if datp.p(9) NE 0.0 THEN wl =datp.p(9) 
 if n_elements(wl) eq 1 THEN BEGIN
  q=2.*!pi*(2.*sin(!pi/360.*x))/wl
  IF KEYWORD_SET(printer) THEN FOR i=0,N_ELEMENTS(range)-1,printer DO PRINT,x(i),q(i)
  idx=sort(q)
  mod_datp,datp,'x',q(idx)
  IF N_ELEMENTS(datp.e) EQ N_ELEMENTS(w) THEN mod_datp, datp, 'E', e(idx,*)
  mod_datp,datp,'x_tit','Q/Ang^-1'
  ww=ww(idx,*)
  give_datp,datp
  return,ww
 ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
 ENDELSE
ENDELSE
END
FUNCTION tt2sin2t,w,lambda=wl,zeroshift=z
 ; 2qtrue = 2qexp.-ZER (FULLPROF)

IF NOT KEYWORD_SET(z) THEN z=0
take_datp,datp
IF NOT KEYWORD_SET(wl) THEN wl=datp.p(33)
tt=datp.x(*,0)-z
e=datp.e
range=where(tt gt 1)
tt=tt(range)
wout=w(range,*)
IF N_ELEMENTS(E) EQ N_ELEMENTS(W) THEN e=e(range,*)
if n_elements(wl) eq 0 then if n_elements(datp.p) gt 9 then if datp.p(9) NE 0.0 THEN wl =datp.p(9) 
if n_elements(wl) eq 1 THEN BEGIN
  sin2t=sin(!pi/360.*tt)
  idx=sort(sin2t)
  mod_datp,datp,'x',sin2t(idx)
  IF N_ELEMENTS(E) EQ N_ELEMENTS(wout) THEN BEGIN
    mod_datp, datp, 'E', e(idx,*)
  ENDIF ELSE mod_datp, datp, 'E',0
  mod_datp,datp,'x_tit','sin(theta)**2'
  wout=wout(idx,*)
  give_datp,datp
  return,wout
ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
ENDELSE
END
FUNCTION tt2tt,w,wl2,l2=l2,z1=z1,l1=wl1,z2=z2
 ; 2qtrue = 2qexp.-ZER (FULLPROF)

IF NOT KEYWORD_SET(z1) THEN z1=0
IF NOT KEYWORD_SET(z2) THEN z2=0
take_datp,datp
IF NOT KEYWORD_SET(wl1) THEN wl1=datp.p(33)
IF KEYWORD_SET(l2) THEN wl2=l2
tt1=datp.x(*,0)-z1
e=datp.e
range=where(tt1 gt 1)
tt1=tt1(range)
wout=w(range,*)
IF N_ELEMENTS(E) EQ N_ELEMENTS(w) THEN e=e(range,*)
if n_elements(wl1) eq 0 then if n_elements(datp.p) gt 9 then if datp.p(9) NE 0.0 THEN wl1 =datp.p(9) 
if n_elements(wl1) eq 1 THEN BEGIN
  d=wl1/(2.*sin(!pi/360.*tt1))
  range=WHERE(d gt 0 AND  wl2/2./d LT 1)
  d=d(range)
  IF N_ELEMENTS(E) EQ N_ELEMENTS(wout) THEN BEGIN
    mod_datp, datp, 'E', e(range,*)
  ENDIF ELSE mod_datp, datp, 'E',0
  wout=wout(range,*)
  tt2=asin(wl2/2./d)*360./!pi
  datp.p(9)=wl2
  mod_datp,datp,'x',tt2+z2
  give_datp,datp
  return,wout
ENDIF ELSE BEGIN
  print,'Attention, no wavelength given for original workspace (P(9))!'
  return,0
ENDELSE
END
pro tth,n1,n2

data_read,n1,w1,mon,y,m,q,th,san,d0,det,nx


data_read,n2,w2,mon,y,m,q,th,san,dr,det,nx


a=max(total(w1,2),p0)

b=max(total(w2,2),pr)

step=5

k=0.
kk=0.
print,'com direct :',p0-step,p0+step
for i=p0-step,p0+step do begin
  k=k+total(w1(i,*),2)
  kk=kk+total(w1(i,*),2)*float(i)

endfor

pp0=kk/k


l=0.
ll=0.
for i=pr-step,pr+step do begin
  l=l+total(w2(i,*),2)
  ll=ll+total(w2(i,*),2)*i
endfor
ppr=ll/l


dpr=180./!pi

pcen=135.79/nx
mmpp=1.04*nx

print,'det: ',det,' X grouping: ',nx
print,'detector centre: ',pcen,' mmpp: ',mmpp
print,'reflection dan: ',dr,' direct beam dan: ',d0
print,'reflection pixel:',ppr,' direct pixel:',pp0

print,'ref th= ',(dr+dpr*atan((pcen-ppr)*mmpp/det))/2-(d0+dpr*atan((pcen-pp0)*mmpp/det))/2

return
end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION unfold, w_in

;Copies one quadrant of the Qx-Qy plane (from fold.pro or qrebin.pro) into 
;all four quadrants
;
;DIMENSIONS:
; w_in(nQ,nQ) -> w_out(2*nQ,2*nQ)
;
;COMMAND SYNTAX:
; w10=unfold(w9)
;
;						KHA, 15/7/98
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	take_datp, datp

	sw=SIZE(w_in)

	nx=sw(1)
	ny=sw(2)
	IF (nx NE ny) THEN BEGIN
		PRINT,'Unfold: Error - x and y dimensions must be equal'
		GOTO, finished
	ENDIF
	n=nx

	x_in=datp.x
	y_in=datp.y
	e_in=datp.e

	x_out=[-REVERSE(x_in),x_in(1:n-1)]
	y_out=[-REVERSE(y_in),y_in(1:n-1)]

	w_out=FLTARR(2*n-1,2*n-1)	& e_out=FLTARR(2*n-1,2*n-1)
	n1=n-1
	n2=2*n-2

;	help, w_out(n1:n2,n1:n2)
;	help, w_in
	w_out(n1:n2,n1:n2)=w_in
	e_out(n1:n2,n1:n2)=e_in

	w_out(n1:n2,0:n1)=REVERSE(w_in,2)
	e_out(n1:n2,0:n1)=REVERSE(e_in,2)

	w_out(0:n1,0:n2)=REVERSE(w_out(n1:n2,0:n2),1)
	e_out(0:n1,0:n2)=REVERSE(e_out(n1:n2,0:n2),1)

	mod_datp, datp, "x", x_out
	mod_datp, datp, "y", y_out
	mod_datp, datp, "e", e_out

	PRINT,'Unfold: one quadrant unfolded into four'
	datp.other_tit=datp.other_tit+' -uf'

finished:
	give_datp, datp

	RETURN, w_out
	END
FUNCTION unic,w,STEP=step
;
; Started by Thomas HANSEN
; Macro to transform D20's 2Theta Scans into one one-dimensional Workspace
; that can be treated by Rietveld (after EXRIET,W) 
; PRETREAT,W, CALIB,W and NORM,W can be run before,
; EXRIET,W can be run afterwards
; Calling by W_new=UNIC(W_old[,STEP=0.1]) with W_old 2-dim., W_new 1-dim.
; Last modified 21-Nov-96 by Thomas HANSEN
;
take_datp,datp
x=datp.x
e=(datp.e)^2
tmpw=reform(w,n_elements(w))
x=reform(x,n_elements(w))
e=reform(e,n_elements(w))
IF NOT KEYWORD_SET(step) THEN BEGIN
  step=0.1
  IF datp.p(10) EQ 3.0 THEN step=(0.1+datp.p(25)) mod 0.1
ENDIF
datp.p(25)=step
x=round(x/step)*step
unix = UNIQ (x,sort(x))
neww = fltarr(n_elements(unix))
newx = fltarr(n_elements(unix))
newe = fltarr(n_elements(unix))
FOR i=0,n_elements(unix)-1 DO BEGIN
  index=WHERE(x EQ x(unix(i)), count)
  count=float(count)
  neww(i)=TOTAL(tmpw(index)/count)
  newx(i)=x(unix(i))
  newe(i)=SQRT(TOTAL(e(index)))/count
ENDFOR

mod_datp,datp,'e',newe
mod_datp,datp,'x',newx
give_datp,datp
RETURN,neww
END
FUNCTION user
;+
; PURPOSE:
;  This function without input gives the name of the user using IDL/LAMP.
;-
if (sys_dep('MACHINE') eq 'mac') then BEGIN
   u='root'
ENDIF ELSE BEGIN
  SPAWN, 'who am i',u
ENDELSE
RETURN, u
END
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION vanadium, w_in, nosave=nosave, sk

;For D7 data only
;
;Takes 2-D or 3-D workspace containing one or more normalised non-tof z-PA 
;or xyz-PA background-subtracted vanadium runs.  For quartz and multiple 
;scattering corrections, data should be run through corr_xyz first. Vanadium.pro
;adds the flip and non-flip intensities and puts the sums into w_out and also 
;into the file 'vanadium_<numor>.dat'
;
;KEYWORDS:
; /nosave	:Don't save in file format
; (sk is obsolete and should not be used)
;
;DIMENSIONS:
; input format: w_in(32,nphases,nruns)
; output format: w_out(32,nruns) (saved in <nrun> individual files)
;
;COMMAND SYNTAX:
; w5=vanadium(w4[,/nosave])
; (optional keyword shown in square brackets)
;
;							KHA,JRS 18/4/02
;-------------------------------------------------------------------------------
;*******************************************************************************
	COMMON c_lamp
        
	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start vanadium:'

	ON_IOERROR, finished

	take_datp, datp

	IF(N_ELEMENTS(sk) GT 0) THEN skip=sk
	IF KEYWORD_SET(nosave) THEN skip=1

;-------------------------------------------------------------------------------
;Check dimensions of input workspaces

	x_in=datp.x
	e_in=datp.e
	par=datp.p

	TOF=FIX(par(8))
	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nruns=FIX(par(3))
	sw=SIZE(w_in)

	IF (TOF EQ 1) AND (sw(1) EQ 128) THEN BEGIN
		PRINT,'Vanadium: Error - TOF data must be integrated before calling vanadium.pro'
		GOTO, finished
	ENDIF

	IF (nspectra NE 32 AND nspectra NE 64) THEN BEGIN
		PRINT,'Vanadium: Error - nspectra=',nspectra,' sw=',sw
		GOTO, finished
	ENDIF

	IF (N_ELEMENTS(skip) EQ 0) THEN skip=0

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Add up vanadium counts

	IF (nruns EQ 1) THEN x_out=x_in ELSE x_out=datp.z

	IF (iprint GT 0) THEN PRINT,'nphases=',nphases

	IF (nspectra EQ 32) THEN ispec=INDGEN(32)*2+2 ELSE ispec=INDGEN(64)+1

	IF (nphases EQ 1) THEN BEGIN
		w_out=w_in
		e_out=e_in
	ENDIF ELSE BEGIN
		rnorm=FLOAT(nphases/2)
		w_out=TOTAL(w_in,2)/rnorm
		e_out=SQRT(TOTAL(e_in^2,2))/rnorm
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'End of "Sum V counts" section'

;-------------------------------------------------------------------------------
;Write vanadium intensities to 'vanadium_file'

	numor=STRTRIM(STRING(LONG(datp.p(0))),2)
	title='Vanadium Intensities from #'+numor

	IF (skip NE 0) THEN GOTO, dontsave

	FOR irun=0,nruns-1 DO BEGIN
		IF (nruns NE 1) THEN BEGIN
			numor=STRTRIM(STRING(LONG(datp.pv(0,irun))),2)
			title='Vanadium Intensities from #'+numor
		ENDIF
		out_file='vanadium_'+numor+'.dat'
		IF (iprint GT 0) THEN PRINT,'out_file=',out_file
		OPENW, 1, out_file
		PRINTF, 1, title
		PRINTF, 1, 'Spectrum     Angle     Vana       dVana'
		FOR i=0,nspectra-1 DO PRINTF, 1, FORMAT='(I7,F11.3,2F11.6)', $
					ispec(i), x_out(i,irun), w_out(i,irun), e_out(i,irun)
		CLOSE, 1
                IF(lamp_host EQ 'd7' OR lamp_host EQ 'd7sgi' OR lamp_host EQ 'd7lin') THEN $
		   spawn, 'cp '+out_file+' /home/vis/d7/lambda/VANFILES/'
	ENDFOR

dontsave:
	IF (iprint GT 0) THEN PRINT,'End of "Write to vanadium_file" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	datp.p(2)=1.

	mod_datp, datp, "e", e_out

	datp.w_tit=title
	datp.other_tit=datp.other_tit+' -va'
	datp.y_tit='Intensity'

finished:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'End vanadium:'

	give_datp, datp

	RETURN, w_out
	END
pro vana,w7,steps,start,stop,zero=zero,twotheta=x10,result=w10,error=e10,eff=w12,cell=x12,gain=w14,box=x14

steps=float(steps)
w8=fltarr(steps)
e8=fltarr(steps)
w9=fltarr(steps)
w10=fltarr(1600)*0.
e10=fltarr(1600)*0.
w11=fltarr(1600)*0.
w12=fltarr(1600)*0.
w14=fltarr(1600)*0.
x10=findgen(1600)*0.1+zero
x12=indgen(1600)
for j=0,steps-1 do w9(j)=w7(start-1,j)
for i=start,stop do begin
  for j=0,steps-1 do w8(j)=w7(i,j)
  e8=w8/sqrt(1.+w8)
  w12(i)=float(total(w8(0:steps-2)/w9(1:steps-1)))/(steps-1.)
  ;print,i,w12(i)
  w8=w8/w12(i)
  e8=e8/w12(i)
  w9=w8
  w10(i-steps+1:i)=w10(i-steps+1:i)+w8(0:steps-1)
  e10(i-steps+1:i)=e10(i-steps+1:i)+e8(0:steps-1)
  w11(i-steps+1:i)=0.+1.
  ;plot,x10,w10,xrange=[start*.1,stop*.1]
endfor
w10=w10/w11
e10=e10/w11
w13=fltarr(50)
for i=start,stop do w13(i/32)= w13(i/32)+w12(i)
w13=float(w13)/32.
x14=fltarr(1600)
for i=start,stop do w14(i)=w13(i/32)
for i=start,stop do x14(i)=float(i)/32.
w14=w14(start:stop)
x14=x14(start:stop)
w10=w10(start:stop)
e10=e10(start:stop)
x10=x10(start:stop)
w12=w12(start:stop)
x12=x12(start:stop)
plot,x10,w10,xrange=[zero+start*.1,zero+stop*.1]
end
pro vanarev,w7,x10,w10,e10,x12,w12,e12,x14,w14,e14,stop=stop ; 2theta scan, powder difractogram, efficiency, gain per box, box number
;result=w10,eff=w12,gain=w14,box=x14

take_datp,p7

;steps,start,stop,zero
steps=N_ELEMENTS(w7(0,*))
start=steps-1
IF NOT KEYWORD_SET(stop) THEN stop=N_ELEMENTS(w7(*,0))-1
zero=p7.x(0,0)

print,'start at ',zero, ' deg, cells ',start,' to ',stop

steps=float(steps)
w8=fltarr(steps)
e8=fltarr(steps)
w9=fltarr(steps)
w10=fltarr(1600)*0.
e10=fltarr(1600)*0.
w11=fltarr(1600)*0.
w12=fltarr(1600)*0.
w14=fltarr(1600)*0.
x10=findgen(1600)*0.1+zero
x12=indgen(1600)
;**** start reference *******************
FOR j=0,steps-1 DO BEGIN
  w9(j)=w7(start-1,j)
  e9(j)=p7.e(start-1,j)
ENDFOR
FOR i=start,stop DO begin
  FOR j=0,steps-1 DO BEGIN
    w8(j)=w7(i,j)
    e8(j)=p7.e(i,j)
  ENDFOR
  ;**** relative efficiency *******************
  w12(i)=float(TOTAL(w8(0:steps-2)/w9(1:steps-1))) /(steps-1.)
  e12(i)=float(TOTAL((e8(0:steps-2)*w9(1:steps-1)+w8(0:steps-2)*w9(1:steps-1))/w9(1:steps-1)/w9(1:steps-1)))/(steps-1.)/((steps-1.)/sqrt(steps))
print,i,w12(i),e12(i)
  w8=w8/w12(i)
  e8=e8*w12(i)+w8*e12(i)/w12(i)/w12(i)
  w9=w8
  e9=e8
  w10(i-steps+1:i)=w10(i-steps+1:i)+w8(0:steps-1)
  e10(i-steps+1:i)=e10(i-steps+1:i)+e8(0:steps-1)
  w11(i-steps+1:i)=0.+1.
;plot,x10,w10,xrange=[start*.1,stop*.1]
endfor
w10=w10/w11
e10=e10/w11/(w11/(sqrt(w11)+1.))
w13=fltarr(50)
e13=fltarr(50)
for i=start,stop DO BEGIN
 w13(i/32)= w13(i/32)+w12(i)
 e13(i/32)= e13(i/32)+e12(i)
ENDFOR
w13=float(w13)/32.
e13=float(e13)/32./(32./sqrt(33.))
x14=fltarr(1600)
for i=start,stop DO BEGIN
  w14(i)=w13(i/32)
  x14(i)=float(i)/32.
  e14(i)=e13(i/32)
ENDFOR
w14=w14(start:stop-steps)
x14=x14(start:stop-steps)
e14=e14(start:stop-steps)
w10=w10(start:stop-steps)
e10=e10(start:stop-steps)
x10=x10(start:stop-steps)
w12=w12(start:stop-steps)
x12=x12(start:stop-steps)
e12=e12(start:stop-steps)
help,w10,e10
plot,x10,w10,xrange=[zero+start*.1,zero+stop*.1]

;twotheta=x10,error=e10,cell=x12
give_datp,p7
end
FUNCTION vanasum, w,a
;********
;**
;** The call is w6=vanasum(...)
	take_datp,d
	x=d.x
	s=FLTARR(N_ELEMENTS(w(*,0)))
	a=s
	e=s
	print,median(w)
	FOR i=32,N_ELEMENTS(w(*,0))-1-32 DO BEGIN
		ind=WHERE(	(x(i,*) LE -9.1 OR x(i,*) GE  5.1) $
			AND 	(x(i,*) LE  62 OR x(i,*) GE  65) $
			AND 	(x(i,*) LE 129 OR x(i,*) GE 131), cnt)
		;tmp=WHERE(w(i,ind) LT median(w)/2,tmpcnt)
		;FOR j=0,tmpcnt-1 DO BEGIN
		;	PRINT,i,ind(tmp(j)),x(i,ind(tmp(j))),w(i,ind(tmp(j)))
		;ENDFOR
		IF cnt GT 1 THEN s(i)=MEAN(w(i,ind)) ELSE s(i)=0
		IF cnt GT 1 THEN e(i)=STDDEV(w(i,ind)) ELSE e(i)=0
		a(i)=cnt
	ENDFOR
	mod_datp,d,'x',indgen(N_ELEMENTS(w(*,0)))
	mod_datp,d,'z',a
	mod_datp,d,'e',e
	give_datp,d
	RETURN,s
END
function vanorm, w_in, w_van, ch1,ch2
;******* ******
;**
;** Normalize W_in with Vanadium elastic peak from channel ch1 to ch2.

;** Check for consistancies
    w_out=w_in
    s_in=size(w_in) & s_vn=size(w_van) & c1=n_elements(ch1) & c2=n_elements(ch2)
    if (c1 le 0) then ch1=1
    if (c2 le 0) then ch2=s_vn(1)

    if (s_in(0) eq 2) and (s_vn(0) eq 2)   then begin
	if (s_in(2) eq s_vn(2))		   then begin
	    if (ch1 le ch2) and (ch1 gt 0) and (ch2 le s_vn(1)) then begin

		TAKE_DATP,P
		w0=total(w_van(ch1-1:ch2-1,*),1) >1
		w0=max(w0)/w0

		for i=0,s_in(2)-1 do w_out(*,i)=w_in(*,i)*w0(i)
		
		IF n_elements(P.e) eq n_elements(w_in) then $
		for i=0,s_in(2)-1 do P.e(*,i)  =P.e(*,i) *w0(i)

		P.x_tit=P.x_tit+' vanorm used'
		GIVE_DATP,P

    	    endif else print, string(7b)+' Inconsistant channels ......' 
    	endif     else print, string(7b)+' Inconsistant angles ......'
     endif        else print, string(7b)+' Inconsistant Workspace dimensions ......'

return,w_out
end
FUNCTION variance,n1,n2,s=s,w=w

take_datp,datp
IF n2 LE n1 THEN RETURN,0
s = rdsum (n1, n2)  ;/ (n2 - n1 + 1)
calib,s
;PRINT, (n2 - n1 + 1)
v = s * 0.

FOR i = n1, n2 DO BEGIN
  w = rdrun (i)
  calib,w
  v = v + (w - s)^2
ENDFOR
mod_datp,datp,'x',INDGEN (N_ELEMENTS(s))
give_datp,datp
RETURN,v
END

;**************************************VENUS***************************************************
;Simple fitting program by Ross McKeown and Paolo Radaelli



;the first part of this program defines the functions needed for curve_fit 
; a gaussian function with gamma=FWHM

function gauss, x,x0,gamma

sigma=gamma/sqrt(8.*alog(2.))
y=1/sqrt(2.*!pi*sigma^2.0)*exp(-((x-x0)^2.0/2.0/sigma^2.0))

return, y

end

; the derivative of a gaussian function with gamma=FWHM with respect to x0

function dgaussdx0,x,x0,gamma

sigma=gamma/sqrt(8.*alog(2.))
y=gauss(x,x0,gamma)/sigma^2.0*(x-x0)

return, y

end

; the derivative of a gaussian function with gamma=FWHM with respect to gamma

function dgaussdgamma, x,x0,gamma

sigma=gamma/sqrt(8.*alog(2.))
y=gauss(x,x0,gamma)*((x-x0)^2/sigma^3.0-1.0/sigma)/sqrt(8.*alog(2.))

return, y

end
; a lorentzian function with gamma=FWHM

function lorentz, x,x0,gamma

y=gamma/2./!pi/((gamma/2.)^2+(x-x0)^2)


return, y

end

; the derivative of a lorentzian function with respect to x0

function dlorentzdx0, x, x0, gamma

y=lorentz(x,x0,gamma)*2*(x-x0)/((gamma/2.)^2+(x-x0)^2)

return, y

end

; the derivative of a lorentzian function with respect to gamma

function dlorentzdgamma, x, x0, gamma

y=lorentz(x,x0,gamma)*(1/gamma-gamma/2/((gamma/2.)^2+(x-x0)^2))

return, y

end
; a pseudovoigt function

function psvoigt, x,x0,gamma,eta

y=eta*lorentz(x,x0,gamma)+(1-eta)*gauss(x,x0,gamma)


return, y

end

; its derivative with respect to x0

function dpsvoigtdx0,x,x0,gamma,eta

y=eta*dlorentzdx0(x,x0,gamma)+(1-eta)*dgaussdx0(x,x0,gamma)

return, y

end

; its derivative with respect to gamma

function dpsvoigtdgamma,x,x0,gamma,eta

y=eta*dlorentzdgamma(x,x0,gamma)+(1-eta)*dgaussdgamma(x,x0,gamma)

return, y

end

; its derivative with respect to eta

function dpsvoigtdeta, x, x0, gamma, eta

y=lorentz(x,x0,gamma)-gauss(x,x0,gamma)

return, y

end

;this procedure constructs the functions and their derivatives from the
;expressions given above, for any number of peaks. The function created here
;will be entered into the curve_fit procedure. 


pro zfunct, x, a, f, pder
  n = n_elements(a)
  m=(n-4)/2
  f = a(0) + a(1)*x
  pder= [[x*0. +1.0],[x]]
  dg=x*0.
  de=x*0.

  for i =0,(m-1) do begin
     dg = dg+ a(2*i+4)*dpsvoigtdgamma(x,a(2*i+5),a(2),a(3))
     de = de+ a(2*i+4)*dpsvoigtdeta(x,a(2*i+5),a(2),a(3))
  endfor
  pder=[[pder],[dg],[de]]
 for i = 0,(m-1) do begin
  f = f +a(2*i+4)*psvoigt(x,a(2*i+5),a(2),a(3))
   di=psvoigt(x,a(2*i+5),a(2),a(3))
   dx0=a(2*i+4)*dpsvoigtdx0(x,a(2*i+5),a(2),a(3))
   pder=[[pder],[di],[dx0]]
   
 endfor

end



 
 
pro windb_event, event


;this is the event handler for the events that occur in the  base widget
;named bad
 
common block1,x,y,w,index,px,py, status, xarr,yarr,menu5,range,a,value,$
   menu4,row1,row2, $
   menu3,yfit,eta_input,gamma_input,sigmaa,b,l1,win_num,dat,$
   write, files,text, base,chi_new,f, convstr

common block, pr,prin, prindex

;this list explains the variables in the common block above,
;x:x values
;y:y values
;w:instrumental weighting for the values in the curve_fit procedure
;index:the variable which deals with the case statement for plotting and peak 
;      assignment
;px,py:x and y arrays containing the coordinates for the zoom window 
;status:variable which defines whether a zoom or an assignment procedure is activated
;xarr,yarr:the arrays containing the arrays of the x and y points selected
;menu5:widget which is desensitised/sensitised during the program
;range:defines the range of x and y coordinates
;a:the array which contains all the values necessary for curve_fit
;value:variable which controls whether a zoom or a peak assignment assignment button is selected
;men4,row1,row2:widget which is desensitised/sensitised during the program
;               widget which is desensitised/sensitised during the program
;               widget which is desensitised/sensitised during the program
;menu3:This widget id is stored so that its buttons can be changed non-interactively
;yfit:the array containing the y values of the fitted curve
;eta_input:id of  the widget which inputs an eta value into a array
;gamma_input:id of the widget which inputs an gamma value into a array


;sigmaa:The array containing the the errors of the a array values
;b: A string array containing the information which is  used for the screen and  printer output.
;l1:A string which contains the preliminary information for print out on screen
;win_num: Contains the window number of the draw widget 
;dat: widget id of the cw_field widget. The  file name is entered through 
;this widget.
;write:This  variable for the needed for sensitising/desensitising routine and for the widget_control call
;files:The value of the widget named above(write) which sets the criteria as to whether the file is appended or not 
;text:widget id if the text widget. It is called to widget_control to input the text of the data which is displayed on
; screen
;base:Base widget containing the widgets which output the data to the screen. They are sensitised after peaks  
;   have been  assigned.
;chi_new:The chi squared value of the fitted points.
;f : String array containing the parameter names. Used in the print out to the screen.
;convstr:The string containing the message which tells the user whether convergence  has been completed

;the first case statement looks for the name of the event produced 
;the routine below either performs the zoom  procedure
;
  
name=tag_names(event,/structure_name)


	   case name of
 'WIDGET_DRAW': begin
 		;Tells the program which window to look at.
  		wset,win_num
 		;converting the x and y values in pixels to coordinates
                d=convert_coord(event.x,event.y,/device,/to_data)
                case status of
                   'z': begin
                          if event.type eq 0 then begin
                     	    px(index)=d(0)
            		    py(index)=d(1)
            			 case index of 
               			    0:begin
				      index=1
				      device, cursor_standard=78
				      end
               			    1:begin
                		      index=0
				      device, cursor_standard=76
                		      ;assigns the size of the zoom region from px, py(arrays containing the x and y 
                		      ;points which are selected by the user.)
                                      range=where(x ge min([px(0),px(1)]) and x le max([px(0),px(1)]))
                                      if range(0) ne -1 then plot,x(range),y(range),/ynoz $
                                       ,xtitle='2*theta (degrees)',ytitle='Intensity (counts)'
                                       ;overplotting the peak assignments as crosses. This statement occurs here in
                                       ;case the zoom procedure is activated after peak assignment.
                                      oplot,xarr,yarr,psym = 1,symsize = 3  
                                      end
            			 endcase
           		  endif
                        end
                         
 		   'p': begin
                          ;this procedure plots the  points which are selected and  describes         
               	          ;them crosses, the coordinates are entered into the appropriate array: xarr
         	          ;or yarr,the arrays always contain a '0' at the beginning which is
         	          ;ignored whenever the values are taken from the array
         	          ;event.type eq 0 specifies that an event is only created when the button is pushed
         	          if event.type eq 0   then begin
              	               
         	          ;In case the range array is empty. The zeroth element always contains -1 in this case.
         	          if range(0) eq -1  then begin
         	            mess13=widget_message('range too small',title='assignment error')
         	            endif else begin
         	              ;only assigns peak coordinates to the xarr and yarr if they are selected in the correct range.i.e. within the 
         	              ;axis boundaries                                        
                              oplot, [d(0)], [d(1)], psym=1,symsize=3  
                              if d(0) ge min(x(range)) and d(0) le max(x(range)) $
                                 and d(1) ge min(y(range))$
            	                 and d(1) le max(y(range)+y(range)*.2)  then begin 
             		         xarr=[xarr,d(0)]               
                       	         yarr=[yarr,d(1)]
          	              endif 
           	              ;conversion of the y coordinates into intensities, these intensities 
           	              ;are needed as parameters in the zfunct.procedure
                              i =d(1)/(a(3)*(2/(!pi*a(2)))+((1-a(3))*sqrt(8*alog(2))$
             	              /(a(2)*sqrt(2*!pi))))             	            
             	             ;incrementing the a array with x and intensity values
                             a=[a,i]
                             a=[a,d(0)]
                             sigmaa=a*0.
                             ;sensitising the widgets below                                           	             
                             widget_control,menu5,sensitive=1
                             widget_control,eta_input,sensitive=1
                             widget_control,gamma_input,sensitive=1
                           endelse     
                         endif
                     end
                  endcase
         
          
               end
               
       ; The case  when an event is generated by the droplist widget.        
       'WIDGET_DROPLIST':begin
       
	     common block, pr,prin, prindex
             prindex=event.index
             		
             end  
               
    ;the third kind of event ,'', is handled here           
               
   '': begin

;this case statement  links the selected button to a specific routine. The event values returned are the names of the buttons 

     case event.value of
        'done':begin
		device, cursor_standard=34  ;	reset the cursor
		widget_control,event.top,/destroy 
	       end
        'replot':begin
        	;This case resets all the values but keeps the same range.
        	;The statement below checks if the range contains some values(see common block1'explanation of variables)
        	if range(0) ne -1  then begin
        	  ;resets the window to display one plot only.
                  !p.multi = 0
      	          yfit=dblarr(1)
                  plot,  x(range),y(range),/ynoz $
     		  ,xtitle='2*theta (degrees)',ytitle='Intensity (counts)'	        
 	          a=[2,4,0.2,0.0]
 	          sigmaa=a*0.
                  yarr=dblarr(1)
                  xarr=dblarr(1)
                  ;sensitises the following widgets.
                  widget_control,menu5,sensitive=0
                  widget_control,eta_input,sensitive =0                                        
                  widget_control,gamma_input,sensitive =0
                  widget_control,base,sensitive=0
      		 endif 
		 if status eq 'z' then begin
;		   *** reset the zoom
		   index=0 
	           device, cursor_standard=76
		 endif
 	       end
 	 'unzoom 20%':begin
 	 	    if range(0) ne -1  then begin
 	 	      !p.multi = 0 
 	 	      ;This case defines min(x), max(x) in terms of the range, increases the range by 20% and then resizes the
 	 	      ;the plot. 
 	 	      g=min(x(range))
 	 	      h=max(x(range))
 	 	      half=(h-g)/2
 	 	      cen= (h+g)/2
 	 	      d=(h-g) 	 	     
 	 	      if  range(0) ne -1 then plot,x(range),y(range),/ynoz 
 	 	      ;This if  statement deals with the case when 
 	 	      ;min(x) or max(x) are equal to nought. 	     
 	 	      if g eq 0 or h eq 0 then begin 	 	 	 	     
 	 	         g = g - .2*(h-g)
 	 	         h=h+.2*(h-g)	 	     
 	 	      endif
 	 	      en=(abs(h-g))*1.2
 	  	      range = where(x ge (cen -(en)/2) and x le $
 	  	      ((cen +(en)/2))) 	  	      	  	   
 	  	      plot,x(range),y(range),/ynoz $
 	  	      ,xtitle='2*theta (degrees)',ytitle='Intensity (counts)'
 	  	      if n_elements(xarr) ge 2 then begin
 	  	         oplot,xarr(1:*),yarr(1:*),psym = 1
 	  	      endif
		      if status eq 'z' then begin
;		        *** reset the zoom
		        index=0 
	                device, cursor_standard=76
		      endif

 	  	    endif  
               end
        'next range': begin
        	      if range(0) ne -1  then begin
                        !p.multi=0
                        yfit=dblarr(1)
         	        g=min(x(range))
 	 	        h=max(x(range))
 	 	        ;oldrange created here so that the original range can be used in case the range is empty 
 	 	        oldrange=range
 	 	        ;redefines the range.
 	 	        range=where(x gt h and x le 2*h-g)
 	 	        if range(0) ne -1 then begin
 	 	            ;resets and sensitises the values and widgets below
 	                    plot,x(range),y(range),/ynoz
  	                    a=[2,4,0.2,0.0]
 	                    sigmaa=a*0.
                            yarr=dblarr(1)
                            xarr=dblarr(1) 
                            widget_control,menu5,sensitive=0
                            widget_control,eta_input,sensitive =0                                        
                            widget_control,gamma_input,sensitive =0
      		            widget_control,base,sensitive=0
                       endif else begin
                         range=oldrange
                         plot,x(range),y(range),/ynoz $
                         ,xtitle='2*theta (degrees)',ytitle='Intensity (counts)'
                      endelse
		      if status eq 'z' then begin
;		        *** reset the zoom
		        index=0 
	                device, cursor_standard=76
		      endif

		      endif
                      end
          
       'peak assignment': begin
	                  status='p';referring the program to case statement above.(See events created by widget_draw)
			  device, cursor_standard=34
	                  end
       'zoom': begin
	       status='z';referring the program to case statement above.
	       device, cursor_standard=76
	       end
       'reset':begin
       	       ;resets all the values and the plot and then sensitises all the widgets which were active at the beginning 
               !p.multi = 0
               yfit=dblarr(1)
               a=[2,4,0.2,0.0]
               sigmaa=a*0.
               yarr=dblarr(1)
               xarr=dblarr(1)
      	       plot,x,y,/ynoz
               status = 'z'
;		reset the zoom
		index=0 
	        device, cursor_standard=76
              range = where(x ge min(x) and x le max(x))
               widget_control,menu4,/set_value
               value = 1
               widget_control,menu5,sensitive=0
               widget_control,eta_input,sensitive =0                                        
               widget_control,gamma_input,sensitive =0
               widget_control,base,sensitive=0      		    
               end
               
     ;this button, as the name suggests performs the curve fitting procedure
       'fitit': begin
       		;checks if there are enough points to fit.
       	        widget_control,base,sensitive=1    
       		; set the cursor to a watch
		device, cursor_standard=150
                if n_elements(y(range)) ge 7 then begin	
                     ;sets the values of eta and gamma from the input window.              		
                     widget_control,eta_input, get_value =eta
                     ;resets eta if the value is too large or too small.
                     if eta ge -2 and eta le 2 then a(3) = eta                   
                     widget_control,gamma_input, get_value =gamma
                     if gamma ge -2 and gamma le 2 then a(2) = gamma 
                     ;if the curve _fit procedure is called for the first time then chi_old is not calculated.
                     ;The points are always fitted twice when they are fitted for the first time.                    
                     if n_elements(yfit) eq 1 then begin                           			
                         ; the calling procedure for the curve_fit procedure
                         yfit=curvefit(x(range),y(range),w(range),a,sigmaa,$
                         function_name='zfunct')
                         ;reassigns the value of eta if the curve_fit  procedure produces a value which 
 	     	         ;is unacceptable
 	     	         if a(3) lt 0 then a(3) = 0
 	    	         if a(3) gt 2 then a(3) = 1

                    endif
                    ;chi squared values for the values before the curve_fit is executed for the second time.
                    chi_old = total(w(range)*(y(range)-yfit)^2)/$
 	     	    (n_elements(x(range))-n_elements(a))                  
        	    ; the calling procedure for the curve_fit procedure
                    yfit=curvefit(x(range),y(range),w(range),a,sigmaa,$
                    function_name='zfunct') 
                    ;chi squared values for the fitted points               	            		       		 	                      	     		
 	     	    chi_new = total(w(range)*(y(range)-yfit)^2)/$
 	     	    (n_elements(x(range))-n_elements(a))	     	    
 	     	    ;error statement in case the curves are not converging. Convergence is tested solely on the  change in chi
 	     	    ;squared values 	
 	     	    if chi_new lt (1.001*chi_old)  and chi_new gt $ 
 	     	    (chi_old -0.001*chi_old)  $
 	     	    ;string which is entered into the output window stating whether convergence is achieved
 	     	    then begin	     	    
 	     	       convstr='Convergence was achieved'
 	     	    endif else begin 	     	    
 	     	        convstr='Convergence was not achieved' 	     	     
 	     	    endelse 	     	
 	    	    xarr=dblarr(1)
 	            yarr=dblarr(1)
 	            a_num = n_elements(a)	            
 	            x_num = (a_num-4)/2
 	            ;redraws the cross position from the values created from curve_fit
 	            for i=0,x_num-1 do begin
 	              xarr = [xarr,a(2*i+5)]
 	              yarr = [yarr,a(2*i+4)*(a(3)*(2/(!pi*a(2)))+((1-a(3))*sqrt(8*alog(2))$
             	           /(a(2)*sqrt(2*!pi))))+a(0)+a(2*i+5)*a(1)]
 	            endfor
 	            ;resets the window to display one plot only.	           
                    !p.multi = 0 
                    ;plots all the results 	           		 
                    plot,x(range),y(range),psym = 1,$
                    yrange=[min(y(range)-yfit)+min(y(range))-0.1*(max(y(range))-min(y(range)))$
                    ,max(y(range))],xtitle='2*theta (degrees)',ytitle='Intensity (counts)'
                    oplot,xarr(1:*),yarr(1:*), psym=1,symsize =3
                    oplot, x(range), yfit
                    oplot,x(range),(y(range)-yfit)+min(y(range))-0.1*(max(y(range))-min(y(range)))                                         
                  endif else begin
                     ;error message widget.
                     mess12=widget_message('not enough data points',title='fit error')
                  endelse
                  
                  ;    the following block displays the results
                  ;f, l1 and b are explained above in the common block explanations
                  ;These string arrays are created here with carriage returns and tabs in place.
		  chi_new=string(chi_new)
		  f=strarr(n_elements(a))					
  	          f(0)='bk1'+string(9b)+string(9b)
  	          f(1)='bk2'+string(9b)+string(9b)
  	          f(2)='FWHM'+string(9b)+string(9b)
  	          f(3)='eta'+string(9b)+string(9b)
  	          if n_elements(a) gt 4 then begin
  	              ;for loop creating the parameter words for the peaks.
  	              for i=0, ((n_elements(a)-4)/2)-1  do begin
  	                  f(2*i+4)='peak '+ string(format='(I2)',(i+1))+' Int'+string(9b)
  	                  f(2*i+5)='peak '+ string(format='(I2)',(i+1))+' Pos'+string(9b)
  	              endfor
  	          endif
  	          b=f+string(format='(f10.4)',(a))+string(9b)+string(format='(f10.6)',(sigmaa))     
  	          l1='chi squared value:  '+chi_new +string(10b)+string(10b)+convstr $
  	          +string(10b)+string(10b)+'parameter'+string(9b)+'value'$
           	  +string(9b)+string(9b)+'error'+string(10b)
           	  ;sets the initial value of the text widget to l1
           	  ;The for loop then appends the text widget with the b array              
  	          widget_control,text,set_value = l1		
 	          if n_elements(a) ge 4 then begin  	                  	  	           	  	          	  	           	  	          	  	         
 	  	      for i=0, n_elements(a)-1 do $
  	  	      widget_control, text, set_value=b(i), /append 	  	        
	           endif
	           ;returns the cursor to the top of the page once all the data has been copied into the text widget 
	           widget_control,text,set_text_select=[0]
	           ;only sensitises the input widget when a file name has been entered
	           if files(n_elements(files)-1) eq '' then widget_control, write, sensitive=0 
  	  	   widget_control,base,/realize
  	  	   ;Event manager for the base widget base.     
  	  	   xmanager,'windb',base 
		   ; returns the cursor to a crosshair
		   device, cursor_standard=34
  	  	   end
                        
                   
                         ;the buttons below enable different perspectives of the plotted results  
       'split screen':begin
                     ;This line creates a window in which two plots can be displayed.
                     !p.multi= [0,1,2]
            
              
     	              plot,      x(range),y(range),psym = 1,/ynoz,xtitle='2*theta (degrees)',ytitle='Intensity (counts)'
     	             
 	       	      oplot,xarr(1:*),yarr(1:*), psym=1,symsize =3
              	      oplot, x(range), yfit
              	      oplot,x(range),(y(range)-yfit)
               	      plot, x(range),(y(range)-yfit)
             	      title ='observed minus expected'
             		
                      end
           'single screen':begin
           		
                    !p.multi = 0 
                    plot,x(range),y(range),psym = 1,$
                    yrange=[min(y(range)-yfit)+min(y(range))-0.1*(max(y(range))-min(y(range)))$
                    ,max(y(range))],xtitle='2*theta (degrees)',ytitle='Intensity (counts)'
                    oplot,xarr(1:*),yarr(1:*), psym=1,symsize =3
                    oplot, x(range), yfit
                    oplot,x(range),(y(range)-yfit)+min(y(range))-0.1*(max(y(range))-min(y(range)))
              	    end
         
         'print':begin	
          	 ;records th name of the present device.          	    
	         mydevice=!d.name
	         ;sets the device to postscript
	         set_plot,'PS'
	         ;performs the plot 	    	    	    	    	    	    
	         plot,x(range),y(range),psym = 1,$
                 yrange=[min(y(range)-yfit)+min(y(range))-0.1*(max(y(range))-min(y(range)))$
                 ,max(y(range))],xtitle='2*theta (degrees)',ytitle='Intensity (counts)'                 
                 ;+.1*max(y)+.01*(n_elements(xarr))
                 oplot,xarr(1:*),yarr(1:*), psym=1,symsize =3
                 oplot, x(range), yfit
                 oplot,x(range),(y(range)-yfit)+min(y(range))-0.1*(max(y(range))-min(y(range)))
                 ;creates string array fo numbering peaks
                 peak=indgen(n_elements(xarr))
                 peaks=string(format='(I2)',(peak)) 
                 ;xyouts outputs data  onto the screen. The statement here assigns numbers to the peaks 		            
                 xyouts,xarr(1:*),yarr(1:*)*1.1,peaks(1:*)          
                 l2='chi squared value'+chi_new
                 l3=convstr
                 ;the xyouts below put the data onto the plot to be printed out.
                 ;this ouput function can be called more than once, as is observed.
                 xyouts, 0.1, -0.1, l2, /norm,charsize=0.5
                 xyouts, 0.1, -0.125, l3, /norm,charsize=0.5
                 xyouts, 0.1, -0.175, 'parameter', /norm,charsize=0.5
                 xyouts, 0.3, -0.175, 'value', /norm,charsize=0.5
                 xyouts, 0.4, -0.175, 'error', /norm,charsize=0.5
                 xyouts,xarr(1:*),yarr(1:*)*1.1,peaks(1:*)
                 xposi=findgen(n_elements(b))*0.+0.1
                 yposi=-0.225-findgen(n_elements(b))*.025
             	;transforming the a and sigmaa arrays into string arrays.
                 astr=string(format='(f10.4)',a)
                 sigmaastr=string(format='(f10.4)',sigmaa)
		;This if statement deals with the formating of the data if there are a large number of peaks. In this case two 
		;columns are created to display the data.
                if n_elements(a) le 20 then begin
             
                   xyouts, xposi, yposi, f, /norm,charsize=0.5
                   xyouts, xposi+0.2, yposi, astr,/norm,charsize=0.5
                   xyouts, xposi+0.3, yposi, sigmaastr,/norm,charsize=0.5
            
               endif else begin
              
                 xyouts, 0.6, -0.175, 'parameter', /norm,charsize=0.5
                 xyouts, 0.8, -0.175, 'value', /norm,charsize=0.5
                 xyouts, 0.9, -0.175, 'error', /norm,charsize=0.5
                 xyouts, xposi(0:19), yposi(0:19), f(0:19), /norm,charsize=0.5
                 xyouts, xposi(0:19)+0.2, yposi(0:19), astr(0:19),/norm,charsize=0.5
                 xyouts, xposi(0:19)+0.3, yposi(0:19), sigmaastr(0:19),/norm,charsize=0.5
   
                 xyouts, xposi(20:*)+0.5, yposi(20:*)+0.5, f(20:*), /norm,charsize=0.5
                 xyouts, xposi(20:*)+0.7, yposi(20:*)+0.5, astr(20:*),/norm,charsize=0.5
                 xyouts, xposi(20:*)+0.8, yposi(20:*)+0.5, sigmaastr(20:*),/norm,charsize=0.5
               
              endelse
	    ;closes the current graphics file.
	    DEVICE,/close
	    ;build a default output file name by using the idl name for the current device(!d.name).Strlowcase converts the name 
	    ;to the lower case.
	    file='idl.'+strlowcase(!d.name)

	    cmd = 'lp -d'+pr(prindex)+' '+file
	    print,cmd
	   ;function which sends a command
	    spawn,cmd
	    ;resets the device.
	    set_plot ,  mydevice

	     
  	   end
         
         
       
         
  	    'write to a file':begin
  	    		    
			     ;this command puts the name of the file into dat_file
  	    		     widget_control,dat,get_value = dat_file

  	    		     dat_file=dat_file(0)
  	    		     place=where(files eq dat_file)
  	    		     ;if dat_file is empty then the first part of the if statement is performed
  	    		     ;otherwise the file is appended
  	    		     
   	    		     if dat_file ne '' then begin 
   	    		     
   	    		       
   	    		       headers="   position"+'  '+'    ESD'+'   '+'   Intensity'+'  '+'    ESD'+'   '+$
   	    		       '     FWHM'+string(10b)
 	    		       chi_new=string(chi_new)
 	    		       
 	    		       ;place is equal to -1 if it is empty
  	    		       case place(0) of
  	    		     
  	    		         -1: begin
  	    		     
  	    		             c=string(9b)+string(9b)+string(9b)+'***** FIT RESULTS *****'+$
  	                             string(10b)+string(10b)+'chi squared value'+chi_new+string(10b)
  	                             ;finds a file unit which is not being used
  	    		             get_lun,u
  	    		             openw,u,dat_file
  	    		             info= [c,headers]
  	    		             ;printing to a file.
 	                             printf,u,info

  	    		             mess=widget_message('Data written to new file '+ dat_file ,title=$
  	    		            'file out')

  	    		             end
  	    		         
  	    		       else: begin
  	    		             ;finds a file unit which is not being used
  	    		       	     get_lun,u
  	    		             openu,u,dat_file, /append
  	                             mess=widget_message('Data appended to old file '+ dat_file ,title=$
  	                             'file out')
  	    		             end
  	    		      endcase
   	    		      for i=0, ((n_elements(a)-4)/2)-1  do begin
   	    		      ;formating of the a and sigmaa arrrays.
			         printf,u, format='(2X,2(F10.6,2X),2(F10.4,2X),F10.6)', a(2*i+5),sigmaa(2*i+5),a(2*i+4),sigmaa(2*i+4),a(2)
			      endfor
			      ;frees the file unit that was used.
  	                      free_lun,u
  	                      ;adds files to the beginning of the dat_file
  	                      files=[files, dat_file]
  	                       
  	                     endif
  	                     
  	                   end
  	                     
  	          else  : begin
  	               ;sensitises the input widget only if a filename is entered
  	               if event.value ne '' then widget_control, write, sensitive=1 else $
  	                 widget_control, write, sensitive=0
  	                 
   	                    end      
		
       endcase
   end

endcase

end



 pro venus,x1,y1,group = group

; This is the main program which creates a window, a  menu of buttons and the
;plot. The events generated by this program are dealt with by an event manager  
;called xmanager 


;compound widget used  to obtain the menu of buttons
;draw widget created in which the plot is drawn, the buttons_events
;keyword enables events to be created as result of clicking in the draw window 	
;for explanation of the common block see above	      
	 
    common block1,x,y,w,index,px,py,status,xarr,yarr,menu5,range,a,$
    value  ,menu4,row1,row2  $
    ,menu3,yfit,eta_input,gamma_input,sigmaa,b,l1,win_num,dat,$
    write, files,text,base,chi_new,f, convstr
    
    
    common block, pr,prin, prindex
	   ;initial assignments
           x=x1 
           
           y=y1
           yfit=dblarr(1)
	   px=fltarr(2)
           py=fltarr(2)
           w=1./(y+1.)
           status='z'
	   device, cursor_standard=76
           index=0
           xarr=dblarr(1)
           yarr=dblarr(1)
           a=dblarr(4)           
           a=[min(y),0.0,0.2,0.0]
           sigmaa=a*0.         
           range = where(x ge min(x) and x le max(x))
           files=['']
           ;this widget heirarchy is constructed so widgets are aligned in rows and columns
           ;offsets are avoided 
           
	   bad=widget_base(title='VENUS',tlb_frame_attr=1)
	   ;tlb_frame_attr=1 stated so that the bad base widget cannot be resized 
	   ro =widget_base(bad,/row)
	  
	  
	  row3 = widget_base(ro,/column)
	 ro3= widget_base(ro,/column)
	   menu2=cw_bgroup(row3,['done','reset']$
	   ,/column,/return_name,/frame)
	   ;eturn name returns the name of the button as the event value
	   
	   menu3 = cw_bgroup(row3,['replot','unzoom 20%', $
	  'next range'],/return_name,/frame,/column)
	   
	   menu4=cw_bgroup(row3,['peak assignment','zoom'$
	   ],/column,/return_name,/exclusive,/frame)
	    
	   
	   
	   menu5=cw_bgroup(row3,['fitit','split screen','single screen'],/column,$
	   /return_name,/frame)
	   
	   
	   
	   draw=widget_draw(ro3, button_events=1,$
	   uvalue='graph',retain=2,xsize=950, ysize=500)
	   ;retain, to make sure window is redrawn when covered
	  lab = widget_label(row3,value='initial values:',yoffset = 400)
	  
	   ;these widgets deal with input of values from the user
	   gamma_input=cw_field(row3,value=0.2, $
	     title='FWHM :',/frame,/floating,xsize=10)
	  
	   
	   eta_input = cw_field(row3,title='  eta :',value=0.0, $
	   /frame,/floating,xsize=10)
	   base = widget_base(ro3,title = 'data output',/column,/align_left)
	   text = widget_text(base,/wrap,xsize=45,ysize=10,$
  	  	         value=(''), /scroll)
  	   ;command to obtain all the printers available
           spawn, 'lpstat -a', st, count=c 	 	   
           pr=strarr(c)	  
           for i=0, c-1 do begin
	     ;string separator	
             st1=str_sep(st(i), ' ')
             pr(i)=st1(0)
          
           endfor
                        	  	         
  	  base1= widget_base(base,/row)
  	  
          write = cw_bgroup(base1,['write to a file' $
	  ],/return_name,/frame,/row)
	  dat=cw_field(base1,title = 'enter filename:',/frame $
	  ,/return_events, value=files(n_elements(files)-1))         
  	  	         
  	  writ2=cw_bgroup(base1,['print'],/return_name,/frame)							
  	  prin = widget_droplist(base1,value=pr)	         
  	  prindex=pr(0)	         
  	  	         
  	  ;desensitises the widgets below and sets the zoom button to be set initially	         
  	  	         	   
	   
	    widget_control,menu5,sensitive =0
	   
	    widget_control,gamma_input,sensitive =0
	    widget_control,eta_input,sensitive =0
	    widget_control,base,sensitive=0
	    
	   
	   widget_control,bad,/realize
	   ;sets the zoom button to be initially pressed.
	   widget_control,menu4,/set_value
	   value =1
	 !p.multi = 0
	
	   plot, x,y,/ynozero,xtitle='2*theta (degrees)',ytitle='Intensity (counts)'
 
	   
	 ;obtain the window number.  
	 widget_control,draw,get_value = win_num

	  
	  ;event manager for the bad base widget. 
          xmanager,'windb',bad,group_leader = group
        
 
end




  
pro view

;program to display an array of any size

;variables

;global variables
common vars,x1,y1,x2,y2,xsize,ysize,grpx,grpy,wid,data,ref1,ref2,xsizez,$
ysizez,grpxz,grpyz,graph,xz,yz,flag_log,bdata,ldata

;SIZE OF ARRAY
xx=51
yy=51



;controls the plotting of the graph
;0 is normal
;1 is log
flag_log=0

;stores the information for the graphics windows
;graph(0)=current graph
;grpah(1)=max number of graphs
a=500.
graph=intarr(a)
graph=long(graph)
graph(0)=2.
graph(1)=a

;x size of graphic array
xsize=xx-1
xsizez=xsize
xz=0
;y size of graphic array
ysize=yy-1
ysizez=ysize
yz=0


;x1 and y1 are the first coors of the zoom area
;x2 and y2 are the second coors of the zoom area
;xz and yz stores the array position for the grp window
x1=0
x2=xsizez-1
y1=0
y2=ysizez-1


;contains the array to be shown
;data=randomn(seed,xsize,ysize,normal=1)
data=indgen(xsize+1,ysize+1)
data=cos(data)
location=where(data lt 0)
data(location)=-data(location)
;openw,3,'test.dat'
;data=fltarr(128,128)
;readf,3,data
data=data*100

;set up the data variable
bdata=data

a=.1
tmp=where(data lt a)
if(tmp ne -1) then begin
  data(tmp)=a
endif
ldata=alog10(data)


;set up data window as a GUI

;creates the base
base=widget_base(title='VIEW',uvalue='base')

;wid stores all the widget address in it
wid=intarr(30)
;creates the draw window widget
wid(0)=widget_draw(base,xsize=500,ysize=500,xoffset=0,yoffset=30,/button_events,uvalue=0,retain=2)
;zoom button
wid(1)=widget_button(base,value=' ZOOM ',xoffset=507,yoffset=0,uvalue=1)
;cancel button
wid(2)=widget_button(base,value='CANCEL',xoffset=507,yoffset=30,uvalue=2)
;quit button
wid(3)=widget_button(base,value=' QUIT ',xoffset=507,yoffset=635,uvalue=3)
;reset zoom button
wid(4)=widget_button(base,value='UNZOOM',xoffset=507,yoffset=60,uvalue=4)
;label saying x from
wid(5)=widget_label(base,value='X FROM',xoffset=0,yoffset=550,uvalue=5)
;label box 
wid(6)=widget_text(base,value=string(x1),xoffset=120,yoffset=550,uvalue=6,/editable,xsize=12)
;label saying to
wid(7)=widget_label(base,value='TO',xoffset=280,yoffset=555,uvalue=7)
;label box
wid(8)=widget_text(base,value=string(x2),xoffset=330,yoffset=550,uvalue=8,/editable,xsize=12)
;label saying y from
wid(9)=widget_label(base,value='Y FROM',xoffset=0,yoffset=605,uvalue=9)
;label box 
wid(10)=widget_text(base,value=string(y1),xoffset=120,yoffset=600,uvalue=10,/editable,xsize=12)
;label saying to
wid(11)=widget_label(base,value='TO',xoffset=280,yoffset=600,uvalue=11)
;label box
wid(12)=widget_text(base,value=string(y2),xoffset=330,yoffset=600,uvalue=12,/editable,xsize=12)
;the x button to plot the axis picture
wid(13)=widget_button(base,value='  X   ',xoffset=507,yoffset=90,uvalue=13)
;the y button to plot the axis picture
wid(14)=widget_button(base,value='  y   ',xoffset=507,yoffset=120,uvalue=14)
;intensity rating
wid(15)=widget_label(base,value='Intensity :',xoffset=0,yoffset=645,uvalue=15)
wid(16)=widget_label(base,value=string(data(0,0)),xoffset=120,yoffset=645,uvalue=16)
;log button
wid(17)=widget_label(base,value=' Axis ',xoffset=507,yoffset=200,uvalue=17)
wid(18)=widget_label(base,value=' Style ',xoffset=507,yoffset=230,uvalue=18)
wid(19)=widget_button(base,value=' LOG  ',xoffset=507,yoffset=260,uvalue=19)
;button to actevate the xpalette function
wid(20)=widget_button(base,value='COLOUR',xoffset=507,yoffset=340,uvalue=20)
;title of graph
wid(21)=widget_label(base,value='Normal Plot Of Intensities',uvalue=21)
;centre of intensity display
wid(22)=widget_label(base,value='Center Of Intensity  X:',xoffset=0,yoffset=680)
wid(23)=widget_label(base,value='000.000',xoffset=300,yoffset=680)
wid(24)=widget_label(base,value='Y:',xoffset=400,yoffset=680)
wid(25)=widget_label(base,value='000.000',xoffset=450,yoffset=680)

;show the widgets on the screen
widget_control,base,/realize

;blank out widgets not used yet
;widget_control,wid(1),sensitive=0
widget_control,wid(2),sensitive=0


;draw the graph
redraw_graph

;set some parameters for the plot
;contains the coordinates of the lower left hand corner
ref1=[120,48]
;contains the coordinates of the upper right hand corner
ref2=[458,467]

;set width and height of graphical display
grpx=ref2(0)-ref1(0)
grpy=ref2(1)-ref1(1)
grpxz=grpx
grpyz=grpy

center2d

;call xmanager to govern events
xmanager,'main',base

end


;---------------------------------------------------------------
;procedures

;this procedure is called when a widget is interacted with
pro main_event,event
common vars

;get infomation on the widget that has been interacted with
widget_control,event.id,get_uvalue=ev,get_value=val

;if the quit button is pressed
if(ev eq 3) then begin
  widget_control,/reset
endif

;if the mouse button is pressed on the graphic display
if(ev eq 0) then begin

  type=event.type
  x=event.x
  y=event.y
  if(type eq 0) then begin
    x1=x
    y1=y
    ;update coordinates for zoom area
    x1=fix(float(xsizez)/float(grpxz)*float(x1-ref1(0)))
    y1=fix(float(ysizez)/float(grpyz)*float(y1-ref1(1)))
   
    ;check to bounds
    if(x1 lt 0) then x1=0
    if(x1 gt xsizez-1) then x1=xsizez-1
    if(y1 lt 0) then y1=0
    if(y1 gt ysizez-1) then y1=ysizez-1
   
    x1=x1+xz
    y1=y1+yz

    ;display the coors
    widget_control,wid(6),set_value=string(x1)
    widget_control,wid(10),set_value=string(y1)
  endif

  if(type eq 1) then begin
    x2=x
    y2=y
    ;active the zoom and cancel buttons and x and y
    widget_control,wid(1),sensitive=1
    ;widget_control,wid(2),sensitive=1
    ;update coordinates for zoom area
    x2=fix(float(xsizez)/float(grpxz)*float(x2-ref1(0)))
    y2=fix(float(ysizez)/float(grpyz)*float(y2-ref1(1)))

    ;check to bounds
    if(x2 lt 0) then x2=0
    if(x2 gt xsizez-1) then x2=xsizez-1
    if(y2 lt 0) then y2=0
    if(y2 gt ysizez-1) then y2=ysizez-1
    
    x2=x2+xz
    y2=y2+yz
 
    ;display the coors
    widget_control,wid(8),set_value=string(x2)
    widget_control,wid(12),set_value=string(y2)  

    ;diplay the intensity
    widget_control,wid(16),set_value=string(bdata(x1,y1))
  
  endif  


   ;error check one
   diff=(x1>x2)-(x1<x2)
   diff1=(y1>y2)-(y1<y2)
  if((diff lt 2) or (diff1 lt 2)) then begin
    widget_control,wid(1),sensitive=0
  endif else begin
    widget_control,wid(1),sensitive=1
  endelse

;print,'mouse coors',x1,x2,y1,y2

endif

;if the zoom button is pressed
if(ev eq 1) then begin
  zoom
endif



;if the UNZOOM button is pressed then reset the zoom level
if(ev eq 4) then begin
  ;dataz=data
  xsizez=xsize
  ysizez=ysize

  xz=0
  yz=0

  x1=0
  x2=xsizez-1
  y1=0
  y2=ysizez-1

  ;set the coors correctly
  widget_control,wid(6),set_value=string(x1)
  widget_control,wid(8),set_value=string(x2)
  widget_control,wid(10),set_value=string(y1) 
  widget_control,wid(12),set_value=string(y2)

  redraw_graph

  center2d
  
endif


;if the x axis button is pressed
if(ev eq 13) then begin
  axis_plot,1
endif

;if the y axis button is pressed
if(ev eq 14) then begin
  axis_plot,2
endif


;if text was entered into the x and y positions
if((ev eq 6)or(ev eq 8)or(ev eq 10)or(ev eq 12)) then begin
  if(ev eq 6) then begin
    x1=fix(val)
    x1=x1(0)
  endif
  if(ev eq 8) then begin
    x2=fix(val)
    x2=x2(0)
  endif
  if(ev eq 10) then begin
    y1=fix(val)
    y1=y1(0)
  endif
  if(ev eq 12) then begin
    y2=fix(val)
    y2=y2(0)
  endif

  ;error checking
  diff=(x1>x2)-(x1<x2)
  diff1=(y1>y2)-(y1<y2)
  if((diff lt 2) or (diff1 lt 2)) then begin
    widget_control,wid(1),sensitive=0
  endif else begin
    widget_control,wid(1),sensitive=1
  endelse
    
endif


;if the log button is pressed
if(ev eq 19) then begin
  flag_log=1-flag_log
  if(flag_log eq 0) then begin
    widget_control,wid(19),set_value=' LOG '
    widget_control,wid(21),set_value='Normal Plot Of Intensities'
    data=bdata
    sx1=x1
    sx2=x2
    sy1=y1
    sy2=y2
    x1=xz
    x2=xz+xsizez
    y1=yz
    y2=yz+ysizez
    zoom
    x1=sx1
    x2=sx2
    y1=sy1
    y2=sy2
  endif
  if(flag_log eq 1) then begin
    widget_control,wid(19),set_value='NORMAL' 
    widget_control,wid(21),set_value='LOG Plot Of Intensities'
    data=ldata
    sx1=x1
    sx2=x2
    sy1=y1
    sy2=y2
    x1=xz
    x2=xz+xsizez
    y1=yz
    y2=yz+ysizez
    zoom
    x1=sx1
    x2=sx2
    y1=sy1
    y2=sy2
  endif
endif

;the button 'colour' was pressed
if(ev eq 20) then begin
  xloadct
endif

end

;redraws the graphical display with new array coors
pro redraw_graph
common vars

;setup up colours for the plot
m1=max(data)
m2=min(data)
m3=total(data)

;set up lighting for contour plot
m=9
l1=m2+indgen(m)*(float(m1-m2)/float(m+1))

;set current graphics window
widget_control,wid(0),get_value=gval
wset,gval

;loadct,5
;tvscl,dist(300)
;stretch,0,70

;tek_color

;draw the plot
;print,'graph stuff:',xz,xz+xsizez,yz,yz+ysizez
contour,data(xz:xz+xsizez,yz:yz+ysizez),levels=l1,c_colors=indgen(10)*25,$
xstyle=5,ystyle=5

dumb=[[0,0],[0,0]]
contour,dumb,/noerase,xrange=[xz,xz+xsizez],yrange=[yz,yz+ysizez],/xstyle,/ystyle

return
end


;draw a plot if either the x or y buttons are pressed
;bop
pro axis_plot,type
common vars

;if type=1 its a y style
;if type=2 its a y style
if(type eq 1) then string='X'
if(type eq 2) then string='Y'

graph(0)=graph(0)+1

if(graph(0) gt graph(1)) then graph(0)=2
graph(graph(0))=widget_base(title='OUTPUT'+string(graph(0)-2)+'         Type: '+string)

;make the draw window
draw=widget_draw(graph(graph(0)),xsize=600,ysize=400,retain=2)
;put a quit button on the axis_plots
quit=widget_button(graph(graph(0)),xoffset=0,yoffset=460,xsize=600,value='QUIT',$
uvalue=1000+graph(0))
peak=widget_label(graph(graph(0)),xoffset=5,yoffset=400,value='',xsize=600,ysize=30)
centerr=widget_label(graph(graph(0)),xoffset=0,yoffset=430,value='',xsize=600,ysize=30)

widget_control,/realize,graph(graph(0))

xmanager,'axis_plot',graph(graph(0))

;--------------------------------------for x plot
;for the x axis
if(type eq 1) then begin
;plot the graph
;print,xsizez,xz,yz,y1
xaxis=indgen(xsizez+1)
xaxis=xaxis+xz

yaxis=fltarr(xsizez+1)

yaxislog=fltarr(xsizez+1)

for u=xz,xz+xsizez do begin
  tmp=0.
  tmplog=0.
  for i=yz,yz+ysizez do begin
    tmp=tmp+data(u,i)
    tmplog=tmplog+bdata(u,i)
  endfor
  tmp=tmp/ysizez
  tmplog=tmplog/ysizez
  yaxis(u-xz)=tmp
  yaxislog(u-xz)=tmplog
endfor    

plot,xaxis,yaxis,/xstyle,/ystyle,$
title='Type: '+strtrim(string,2)+'  x1:'+strtrim(xz,2)+'  y1:'+strtrim(yz,2)+'  x2:'+strtrim(xz+xsizez,2)+'   y2:'+strtrim(yz+ysizez,2),$
xtitle='X Pixel',ytitle='Mean Intensity Over Y Range'

;calculate the centre of mass
err=fltarr(xsizez+1)
tmp=0.
tmp1=0.
for u=xz,xz+xsizez do begin
  tmp=tmp+u*yaxis(u-xz)
  tmp1=tmp1+yaxis(u-xz)
  if(flag_log eq 0) then begin
    err(u-xz)=1/sqrt(yaxis(u-xz))*yaxis(u-xz)/ysizez
  endif else begin
    err(u-xz)=1/sqrt(yaxislog(u-xz))*yaxislog(u-xz)/ysizez
  endelse
endfor
center=tmp/tmp1
;print,'X Center=',center
oplot,[center,center],[min(yaxis),max(yaxis)],thick=3

if(flag_log eq 1) then begin
  below=yaxislog-(err/2)
  above=yaxislog+(err/2)
  below=alog10(below)
  above=alog10(above)
  yaxislog=alog10(yaxislog)
endif

;plot error bars
if(flag_log eq 0) then begin
  err=err/2
  errplot,xaxis,yaxis-err,yaxis+err
endif else begin
  lenabove=above-yaxislog
  lenbelow=yaxislog-below
  errplot,xaxis,yaxis-lenbelow,yaxis+lenabove
endelse

;peak intensity
max=max(yaxis)
location=where(yaxis eq max)
location=location(0)+xz
widget_control,peak,set_value='The Peak Intensity is '+strtrim(string(max),2)+' at '+strtrim(string(location),2)

;display cetre of intensity
widget_control,centerr,set_value='The Centre Of Intensity is at  '+strtrim(string(center),2)

endif


;--------------------------------------------for y plot
;for the y axis
if(type eq 2) then begin
;plot the graph
xaxis=indgen(ysizez+1)
xaxis=xaxis+yz

yaxis=fltarr(ysizez+1)

yaxislog=fltarr(ysizez+1)

for u=yz,yz+ysizez do begin
  tmp=0.
  tmplog=0.
  for i=xz,xz+xsizez do begin
    tmp=tmp+data(i,u)
    tmplog=tmplog+bdata(i,u)
  endfor
  tmp=tmp/xsizez
  tmplog=tmplog/xsizez
  yaxis(u-yz)=tmp
  yaxislog(u-yz)=tmplog
endfor    

plot,xaxis,yaxis,/xstyle,/ystyle,$
title='Type: '+strtrim(string,2)+'  x1:'+strtrim(xz,2)+'  y2:'+strtrim(yz,2)+'  x2:'+strtrim(xz+xsizez,2)+'   y2:'+strtrim(yz+ysizez,2),$
xtitle='Y Pixel',ytitle='Mean Intensity Over X Range'

;calculate the centre of mass
err=fltarr(ysizez+1)
tmp=0.
tmp1=0.
for u=yz,yz+ysizez do begin
  tmp=tmp+u*yaxis(u-yz)
  tmp1=tmp1+yaxis(u-yz)
  if(flag_log eq 0) then begin
    err(u-yz)=1/sqrt(yaxis(u-yz))*yaxis(u-yz)/xsizez
  endif else begin
    err(u-yz)=1/sqrt(yaxislog(u-yz))*yaxislog(u-yz)/xsizez
  endelse
endfor  
center=tmp/tmp1
;print,'Y Center=',center
oplot,[center,center],[min(yaxis),max(yaxis)],thick=3

if(flag_log eq 1) then begin
  below=yaxislog-(err/2)
  above=yaxislog+(err/2)
  below=alog10(below)
  above=alog10(above)
  yaxislog=alog10(yaxislog)
endif

;plot errorbars
if(flag_log eq 0) then begin
  err=err/2
  errplot,xaxis,yaxis-err,yaxis+err
endif else begin
  lenabove=above-yaxislog
  lenbelow=yaxislog-below
  errplot,xaxis,yaxis-lenbelow,yaxis+lenabove
endelse

;peak intensity
max=max(yaxis)
location=where(yaxis eq max)
location=location(0)+yz
widget_control,peak,set_value='The Peak Intensity is '+strtrim(string(max),2)+' at '+strtrim(string(location),2)

;display cetre of intensity
widget_control,centerr,set_value='The Centre Of Intensity is at  '+strtrim(string(center),2)

endif


;xmanager,'axis_plot',graph(graph(0))

return
end

;procedure to deal with events in from the axis_plot window
pro axis_plot_event,event

common vars

widget_control,event.id,get_uvalue=ev

widget_control,graph(ev-1000),/destroy

return
end


; calculates the centre of mass in the 2d contour plot
pro center2d
common vars

;works with data, and the limits are given by xz,yz, and xsizez, ysizez

;find the x mean position
x=0.
print,'zx,zy',xz,yz
for u=0,ysizez do begin
  tmp=0.
  tmp1=0.
  for i=0,xsizez do begin
    tmp=tmp+i*data(i+xz,u+yz)
    tmp1=tmp1+data(i+xz,u+yz)
  endfor
  x=x+(tmp/tmp1)
endfor
x=x/ysizez
;print,'x mean =',x+xz
widget_control,wid(23),set_value=string(x+xz)

;find the y mean position
y=0.
for u=0,xsizez do begin
  tmp=0.
  tmp1=0.
  for i=0,ysizez do begin
    tmp=tmp+i*data(u+xz,i+yz)
    tmp1=tmp1+data(u+xz,i+yz)
  endfor
  y=y+(tmp/tmp1)
endfor
y=y/xsizez
;print,'y mean =',y+yz     
widget_control,wid(25),set_value=string(y+yz)  


;plot the centre of mass

;set the correct graph
widget_control,wid(0),get_value=gval
wset,gval

;convert array coors to screen coors
;if((xsizez eq xsize)and(ysizez eq ysize)) then begin
;  x=float(x)*float(grpxz)/float(xsizez)+float(ref1(0))
;  y=float(y)*float(grpyz)/float(ysizez)+float(ref1(1))

;  xyouts,x/500,y/500,'O',/normal

;endif

return
end



;zoom procedure
pro zoom

  common vars

  ;print,'coors',x1,x2,y1,y2

  ;find new array coordinates
  smallx=(x1<x2)
  bigx=(x1>x2)
  smally=(y1<y2)
  bigy=(y1>y2)
  ;xa=fix(float(xsizez)/float(grpxz)*float(smallx-ref1(0)))
  ;ya=fix(float(ysizez)/float(grpyz)*float(smally-ref1(1)))
  ;xb=fix(float(xsizez)/float(grpxz)*float(bigx-ref1(0)))
  ;yb=fix(float(ysizez)/float(grpyz)*float(bigy-ref1(1)))
  xa=smallx
  xb=bigx
  ya=smally
  yb=bigy

  ;dataz=data(xa:xb,ya:yb)

  xsizez=xb-xa
  ysizez=yb-ya

  xz=smallx
  yz=smally

  redraw_graph

  widget_control,wid(1),sensitive=0
  widget_control,wid(2),sensitive=0
  widget_control,wid(2),sensitive=0

  center2d

  

;print,'zoom corrs',xz,yz,xsizez,ysizez

return
end
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION vnorm, w_in, w_van0, min=ch1, max=ch2, tv=tv, Ns=Ns, $
		 ts=ts, cb1, cb2, ierr=ierr

;For IN4, IN5, IN6 and D7 data
;
; Normalises data in w_in vanadium data in w_van0 integrated between given limits.
;
;ARGUMENTS
; min	: lower time channel limit of integration over vanadium elastic peak
; max	: upper time channel limit
; tv	: thickness of vanadium sample
; Ns	: number density of sample (*10^22 per cm^3)
; ts	: effective sample thickness
; (cb1 and cb2 are obsolete and kept for backwards compatability)
;
;DIMENSIONS
; w_in=w_out(nchannels, nspectra)
;
;COMMAND SYNTAX
; w8=vnorm(w7,w20,min=<min>,max=<max>[,tv=<tv>,Ns=<Ns>,ts=<ts>])
;      - normalises data in w7 to vanadium data in w20,
; (optional arguments shown in square brackets)
;
;							JRS,KHA  15/7/02
;
;LAST MODIFICATION
; Modified by S. Rols 14/03/02 to perform vanadium normalisation of MiBeMol
; (LLB-CEA SACLAY), DCS (NIST USA) and QENS (IPNS USA) data.
;-------------------------------------------------------------------------------
;*******************************************************************************

	COMMON c_lamp_access, inst

	iprint = 0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start vnorm:'

	take_datp, datp
	take_datp, datvan, /third
	IF N_ELEMENTS(cb1) GT 0 THEN ch1 = cb1
	IF N_ELEMENTS(cb2) GT 0 THEN ch2 = cb2
;-------------------------------------------------------------------------------
;Check workspace sizes

	sw=SIZE(w_in)
	IF iprint THEN PRINT,'SIZE(w_in)=',sw
	nchannels=sw(1)
	IF sw(0) EQ 1 THEN nspectra = 1 ELSE nspectra = sw(2)

; Part added by SR on 14/03/02
; ** Decide if include the vanadium error or not (default=included)
; *****************************************************************

	ierrtype = 1
	IF N_ELEMENTS(ierr) GT 0 THEN ierrtype = 2
	CASE inst OF
		'QENS_raw':BEGIN
			   w_out = vnorm_qens(w_in, w_van0, ch1, ch2)
			   GOTO, finished
			   END
		'QENS':BEGIN
			   w_out = vnorm_qens(w_in, w_van0, ch1, ch2)
			   GOTO, finished0
			   END
		'MiBeMol':BEGIN
				par  = datp.p
				e_in = datp.e
				se   = SIZE(e_in)
				chw  = FLOAT(par(7))
				L2   = 3.58*1000.
			   END
		'DCSasc':BEGIN
				par  = datp.p
				e_in = datp.e
				se   = SIZE(e_in)
				chw  = FLOAT(par(14))
				L2   = FLOAT(par(6))
			   END
		ELSE:BEGIN
			 par  = datp.p
			 e_in = datp.e
			 se   = SIZE(e_in)
			 chw  = par(18)
			 L2   = par(27)*1000.
			 END
	ENDCASE
;-------------------------------------------------------------------------------


	IF inst EQ 'D7' THEN nphases = par(2)

	se = SIZE(e_in)
	IF iprint THEN PRINT,'SIZE(e_in) = ',se
	IF (se(0) NE sw(0)) OR (se(1) NE sw(1)) OR (se(2) NE sw(2)) THEN e_in = SQRT(w_in)

	w_van = w_van0	& sv = SIZE(w_van)

	e_van = datvan.e
	se = SIZE(e_van)
	IF (se(0) NE sv(0)) OR (se(1) NE sv(1)) OR (se(2) NE sv(2)) THEN e_van = SQRT(w_van)

	IF inst EQ 'D7' THEN BEGIN
		nvs = sv(2)
		IF iprint THEN PRINT,'D7: nspectra=',nspectra,' nvs=',nvs
		IF nspectra EQ 2*nvs THEN BEGIN
			w_van=[[w_van],[w_van]]
			e_van=[[e_van],[e_van]]
		ENDIF ELSE IF nspectra EQ 6*nvs THEN BEGIN
			w_van=[[w_van],[w_van],[w_van],[w_van],[w_van],[w_van]]
			e_van=[[e_van],[e_van],[e_van],[e_van],[e_van],[e_van]]
		ENDIF ELSE IF nvs NE nspectra THEN BEGIN
			s = 'vnorm: Error - no. of V spectra must be 1,2 or 6 times no. of w_in spectra'
			i = WIDGET_MESSAGE(s, /ERROR)
			GOTO, fin
		ENDIF
		zeroed = WHERE(e_in LE -1.,nz) ; zeroed spectrum numbers
		IF iprint THEN PRINT,nz/nchannels,' zeroed spectra
	ENDIF ELSE IF (sv(0) NE sw(0)) OR (sv(1) NE sw(1)) OR (sv(2) NE sw(2)) THEN BEGIN
		s = 'vnorm: Error - w_in and V data not same format'
		i = WIDGET_MESSAGE(s, /ERROR)
		GOTO, fin
	ENDIF

	IF iprint THEN PRINT,'nchannels=',nchannels,' nspectra=',nspectra

;-------------------------------------------------------------------------------------
;	Perform normalisation


;	FOR D7: reform vanadium into (nchannels, nspectra, nphases)
;	and sum over phases before normalisation

        IF inst EQ 'D7' THEN BEGIN
		wv_buf = REFORM(w_van,nchannels,nspectra/nphases,nphases)
		ev_buf = REFORM(e_van,nchannels,nspectra/nphases,nphases)
		V_buf  = TOTAL(wv_buf(ch1-1:ch2-1,*,*),1)
		dV_buf = SQRT(TOTAL(ev_buf(ch1-1:ch2-1,*,*)^2,1))
		V1  = TOTAL(V_buf,2)
		dV1 = SQRT(TOTAL(dV_buf^2,2))
		IF iprint THEN PRINT, 'nphases = ',nphases
		IF nphases EQ 6 THEN BEGIN
			V  = [V1,V1,V1,V1,V1,V1]
			dV = [dV1,dV1,dV1,dV1,dV1,dV1]
		ENDIF ELSE IF nphases EQ 2  THEN BEGIN
			V  = [V1,V1]
			dV = [dV1,dV1]
		ENDIF
	ENDIF ELSE BEGIN
		V  = TOTAL(w_van(ch1-1:ch2-1,*),1)
		dV = SQRT(TOTAL(e_van(ch1-1:ch2-1,*)^2,1))
	ENDELSE

	w_buf=FLTARR(nchannels,nspectra)
	e_buf=FLTARR(nchannels,nspectra)

	IF nspectra GT 1 THEN BEGIN
		V  = REFORM(V,1,nspectra)
		dV = REFORM(dV,1,nspectra)
		V  = (FLTARR(nchannels)+1.) # V
		dV = (FLTARR(nchannels)+1.) # dV

		nz=WHERE(V GT 0)
		w_buf(nz) = w_in(nz)/V(nz)
		IF ierrtype EQ 1 THEN $
			e_buf(nz) = SQRT((e_in(nz)/V(nz))^2 + (w_in(nz)*dV(nz)/V(nz)^2)^2) $
		ELSE BEGIN
			e_buf(nz) = e_in(nz)/V(nz)
			PRINT, 'vnorm:  Absolute errors not calcuated'
		ENDELSE
	ENDIF ELSE BEGIN
		w_buf = w_in/V
		IF ierrtype EQ 1 THEN $
			e_buf = SQRT((e_in/V)^2 + (w_in*dV/V^2)^2) $
		ELSE BEGIN
			e_buf = e_in/V
			PRINT, 'vnorm:  Absolute errors not calcuated'
		ENDELSE
	ENDELSE

	w_buf = REFORM(w_buf,nchannels,nspectra)
	e_buf = REFORM(e_buf,nchannels,nspectra)

	IF(N_ELEMENTS(Ns) GT 0) THEN BEGIN
		Ns = Ns*1.E22
		Nv = 7.197E22
		tv = FLOAT(tv)
		Ns = FLOAT(Ns)
		ts = FLOAT(ts)
                IF iprint THEN BEGIN
			PRINT, 'Absoulte Normalisation:'
			PRINT, 'Ns = ',Ns
			PRINT, 'Nv = ',Nv
			PRINT, 'ts = ',ts
			PRINT, 'tv = ',tv
		ENDIF
		w_out = ((Nv*tv)/(Ns*ts))*w_buf*5.08*L2/(4*!pi*chw)
		e_out = ((Nv*tv)/(Ns*ts))*e_buf*5.08*L2/(4*!pi*chw)
	ENDIF ELSE BEGIN
		w_out = w_buf
		e_out = e_buf
	ENDELSE

	novan = WHERE(V LE 0., n)
	IF n GE 1 THEN BEGIN
		V(novan)=1.
		w_out(novan) = 0.
		e_out(novan) = -1.
	ENDIF

	IF inst EQ 'D7' THEN BEGIN
		IF N_ELEMENTS(zeroed) GT 2 THEN BEGIN
			w_out(zeroed) = 0.
			e_out(zeroed) = -1.
		ENDIF
	ENDIF

	IF iprint THEN PRINT,'End of main section'
;-------------------------------------------------------------------------------------

	if n_elements(datp.e) eq n_elements(e_out) then datp.e=e_out

finished0:
	PRINT,'vnorm: normalised to V data, channels',ch1,' to',ch2

	title=datvan.other_tit
	IF (inst EQ 'D7') THEN i=3 ELSE i=4
	IF (STRMID(title,i,1) EQ '#') THEN BEGIN
		n=STRLEN(title)		& title=STRMID(title,i+1,n-i-1)
		i=STRPOS(title,' ')	& numor=STRMID(title,0,i)
	ENDIF ELSE BEGIN
		i=RSTRPOS(title,' ')	& n=STRLEN(title)
		numor=STRMID(title,i+1,n)
		IF (STRPOS(numor,'>') EQ -1) THEN $
			numor=STRTRIM(STRING(LONG(datvan.p(10))),2)
	ENDELSE
	numor = '#'+numor
	IF (N_ELEMENTS(Ns) EQ 0) THEN BEGIN
		s=' -vn('+numor+','+STRTRIM(STRING(ch1),2)+','+STRTRIM(STRING(ch2),2)+')'
	ENDIF ELSE BEGIN
		tvs=STRTRIM(STRING(tv),2)	& n=STRPOS(tvs,'.')+3	& tvs=STRMID(tvs,0,n)
		Nss=STRTRIM(STRING(Ns),2)	& n=STRPOS(Nss,'.')+3	& Nss=STRMID(Nss,0,n)
		tss=STRTRIM(STRING(ts),2)	& n=STRPOS(tss,'.')+3	& tss=STRMID(tss,0,n)
		abss=tvs+','+Nss+','+tss
		s=' -vn('+numor+','+STRTRIM(STRING(ch1),2)+','+STRTRIM(STRING(ch2),2)+','+abss+')'
	ENDELSE

	datp.other_tit=datp.other_tit+s

	give_datp, datp

finished:
	RETURN, w_out
fin:
	END


PRO volvis,e,level,maxlevel,frames=frames,levels=levels,ax=ax,az=az,sceleton=wire,u=u,v=v,w=w,$
                   arrowsize=arrowsize,catvertex=catv, catpoly=catp,anvertex=anv, anpoly=anp,ps=ps,$
                   scale=scale,file=file,notv=notv,noclose=noclose

;+
;y=INDGEN((600-540)/10+1)*10+540
;x=INDGEN((129-44)/1+1)*1+44
;vol=fltarr(86,7,15)
;restore,'field09.sav'
;FOR i=0,6 do for j=0,85 do vol(j,i,0)=reduced(3,WHERE (reduced(0,*) EQ x(j) AND reduced(1,*) EQ y(i)))
;shade_volume,vol,-10,vcat,pcat
;shade_volume,vol,10,van,pan
;vcat(0,*)=vcat(0,*)/5.
;van(0,*)=van(0,*)/5.
;restore,'field10.sav'
;volvis,e,340,fra=1,/scel,u=u,v=v,w=w,ax=10,az=10,arr=0.01,catp=pcat,catv=vcat,anp=pan,anv=van,scale=[85.,60.,1.4],/notv,/ps,fil='test.ps'
;-

IF KEYWORD_SET(ps) THEN BEGIN
  SET_PLOT, 'PS'
  IF NOT KEYWORD_SET(file) THEN file='volvis.ps'
  DEVICE, FILE=file, /COLOR
  TVLCT, [0,255,0,0], [0,0,255,0], [0,0,0,255]
ENDIF
IF NOT KEYWORD_SET(arrowsize) THEN arrowsize=0.05
IF N_PARAMS() LT 2 THEN level=(MIN(e)+MAX(e))/2.
IF NOT KEYWORD_SET(frames) THEN frames=20
step=0
IF NOT KEYWORD_SET(ax) THEN ax=0
IF NOT KEYWORD_SET(az) THEN az=45
IF NOT KEYWORD_SET(levels) THEN levels=0 ELSE BEGIN
  level=MIN(e)
  step=(MAX(e)-level)/(levels+2)
  IF NOT KEYWORD_SET(frames) THEN frames=1
  IF N_PARAMS() GE 2 THEN level=level 
  IF N_PARAMS() GE 3 THEN step=(MAXlevel-level)/(levels+2)
ENDELSE
j=0
;sizx=600 & sizy=600
;XINTERANIMATE, SET=[sizx, sizy, frames]
WHILE j LE levels DO BEGIN
  level=level+step
  level=level<max(E)
  level=level>min(E)
  j=j+1
  PRINT,'Level = ',level
  SHADE_VOLUME,e,level,vox,pol
  color=pol*0+2
  IF KEYWORD_SET(anp) THEN BEGIN
      ap=anp
      av=anv
      k=0
      WHILE k LT N_ELEMENTS(ap) DO BEGIN
        ap(k+1:k+ap(k))=ap(k+1:k+ap(k))+N_ELEMENTS(vox(0,*))
        k=k+1+ap(k)
      ENDWHILE
      vox=[[vox],[av]]
      pol=[ pol , ap ]
      ;help,vox,pol
      color=[color,ap*0+1]
  ENDIF
  IF KEYWORD_SET(catp) THEN BEGIN
      cp=catp
      cv=catv
      k=0
      WHILE k LT N_ELEMENTS(cp) DO BEGIN
        cp(k+1:k+cp(k))=cp(k+1:k+cp(k))+N_ELEMENTS(vox(0,*))
        k=k+1+cp(k)
      ENDWHILE
      vox=[[vox],[cv]]
      pol=[ pol , cp ]
      color=[color,cp*0+3]
  ENDIF
  ;IF NOT KEYWORD_SET(ps) THEN color=color*0
  siz=SIZE(e)
  IF KEYWORD_SET(scale) THEN BEGIN
    siz=FLOAT(siz)
    scale=(1./scale)/MIN(1./FLOAT(scale))*siz(1:3)
    siz(1:3)=scale
  ENDIF
  SCALE3,XR=[0,siz(1)],YR=[0,siz(2)],ZR=[0,siz(3)],AX=ax,AZ=az
  FOR i=0,frames-1 DO BEGIN
    T3D,TR=[-.5,-.5,-.5],ROT=[0,360./frames,0]
    T3D,TR=[.5,.5,.5]
    IF NOT KEYWORD_SET(notv) THEN TV,POLYSHADE(vox,pol,/T3D)
    IF KEYWORD_SET(wire) THEN BEGIN
      k=0
      IF KEYWORD_SET(ps) THEN WHILE k LT N_ELEMENTS(pol) DO BEGIN
        n=pol(k)
        plots,vox(*,pol(k+1)),/T3D,COLOR=color(k)
        FOR l=1,n-1 DO plots,vox(*,pol(k+1+l)),/CONTINUE,/T3D,COLOR=color(k)
        plots,vox(*,pol(k+1)),/T3D,/CONTINUE,COLOR=color(k)
        k=k+1+n
      ENDWHILE
      IF NOT KEYWORD_SET(ps) THEN WHILE k LT N_ELEMENTS(pol) DO BEGIN
        n=pol(k)
        plots,vox(*,pol(k+1)),/T3D
        FOR l=1,n-1 DO plots,vox(*,pol(k+1+l)),/CONTINUE,/T3D
        plots,vox(*,pol(k+1)),/T3D,/CONTINUE
        k=k+1+n
      ENDWHILE
    ENDIF 
    ;XINTERANIMATE, FRAME=i, WINDOW=!D.WINDOW & $
    IF KEYWORD_SET(u) AND  KEYWORD_SET(v) AND  KEYWORD_SET(w) THEN BEGIN
      FLOW3,u,v,w,ARROWSIZE=arrowsize
    ENDIF
  ENDFOR
ENDWHILE
IF KEYWORD_SET(ps) AND NOT KEYWORD_SET(noclose) THEN DEVICE, /CLOSE
;XANIMATE
END
	FUNCTION water, w_in0, skip

;
;takes 2-D workspace containing normalised background-subtracted water run.
;Save water integrals in file 
;
; if skip NE 0, Don't save in file
;
; input format: w_in(ndet,ndet)
; output format: w_out(ndet,ndet)
;							JRS 10/9/99




	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start water:'

	ON_IOERROR, finished

	take_datp, datp

;-------------------------------------------------------------------------------
;Check dimensions of input workspace

	x_in0=datp.x
	y_in0=datp.y
	z_in0=datp.z
	e_in0=datp.e
	par=datp.p
	parv=datp.pv
	se=SIZE(e_in0)
	sw=SIZE(w_in0)

	IF (sw(0) EQ 3) THEN nruns=sw(3) ELSE nruns=1
	IF (nruns EQ 1) THEN parv=par
	nspectra=sw(1)

	IF (N_ELEMENTS(skip) EQ 0) THEN skip=0

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'


;-------------------------------------------------------------------------------
;Write vanadium intensities to 'vanadium_file'

	w_out=w_in0
	x_out=x_in0
	y_out=y_in0
	e_out=e_in0

	ispec=INDGEN(nspectra^2)+1

	numor=STRTRIM(STRING(LONG(datp.p(26))),2)
	title='Water Intensities from #'+numor

	IF (skip NE 0) THEN GOTO, dontsave

	out_file='water_'+numor+'.dat'
	PRINT,'Writing water file: ',out_file
	OPENW, 1, out_file
	PRINTF, 1, title
	PRINTF, 1, 'Spectrum     X	Y     Vana       dVana'
	FOR i=0,nspectra-1 DO BEGIN
		FOR j=0,nspectra-1 DO BEGIN
			PRINTF, 1, FORMAT='(I7,1X,F5.1,1X,F5.1,2F12.6)', $
				ispec((j+1)+(i*nspectra)-1), x_out(i), y_out(j), w_out(i,j), e_out(i,j)
		ENDFOR
	ENDFOR
	CLOSE, 1


dontsave:
	IF (iprint GT 0) THEN PRINT,'End of "Write to water_file" section'

;-------------------------------------------------------------------------------
;Return parameters and exit

	mod_datp, datp, "e", e_out

	datp.w_tit=title
	datp.other_tit=datp.other_tit+' -wa'

finished:
	CLOSE, 1

	IF (iprint GT 0) THEN PRINT,'End water:'

	give_datp, datp

	RETURN, w_out
	END
pro wave,n,w1,x1
data_read,n,dat,m,l

rr=7
dbtot=total(dat,1)
w1=dbtot
x1=l
dbtotm=max(dbtot,dbm)
print,'direct beam peak at: ',dbm
f1=dbm-(rr-1)/2
f2=dbm+(rr-1)/2
print,'sum ranges for db: ',f1,f2
;COM for db
numersum=0.
denomsum=0.
for i=f1,f2 do begin
	numer=dbtot(i)*float(i)
	denom=dbtot(i)
	numersum=numer+numersum
	denomsum=denom+denomsum
endfor
print,'db stuff:', numersum,denomsum
dbcom=numersum/denomsum
print,'fitted db peak at: ',(dbcom)

;print,l

a=floor(dbcom)
diff=dbcom-a
print,a
dwdc=l(a+1)-l(a)

wav=l(a)+dwdc*diff

print,'wavelength = ',wav
end
function Unroll, w
;******* ******
;**
@lamp.cbk
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah
common destop , wit
common dexxl  , xxl1,xxl2

	wi=fix(b_ww) & wj=fix(b_wl) & s=size(b_arel)
	sd=(s(1)-1.)/2.

	if squar ne 0 then  begin ii=execute('x'+b_ww+'=(findgen(s(1))-sd)/sd * 3.1416')
			    ii=execute('x'+b_ww+'=x'+b_ww+'(xxl1:xxl2)')
	endif    else       ii=execute('x'+b_ww+'=(findgen(s(1))-sd)/sd * 3.1416*rr2')
	ii=execute('y'+b_ww+'= indgen (s(2))+rr1>1')
	if squar ne 0 then x_tit(wi)   ='UNROLLED RINGS. X axis: -Pi<--->Pi  ('+x_tit(wj)+')'  $
		      else x_tit(wi)   ='UNROLLED RINGS. X axis: -Pi*R<--->Pi*R  ('+x_tit(wj)+')'
	y_tit(wi)   ='RADIUS in pixels'
	
if squar ne 0 then return,b_arel(xxl1:xxl2,*) else return,b_arel
end

function Diagram, w
;******* *******
;**
@lamp.cbk
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah

        wi=fix(b_ww) & wj=fix(b_wl) & s=size(b_arel)
	ii=execute('x'+b_ww+'=b_xdia')
	x_tit(wi)   ='DIAGRAM 2*Theta ('+x_tit(wj)+')'
	y_tit(wi)   ='MEAN VALUES'
return,b_diam
end

pro wdiag_event, event,uv
;** ***********
;**
@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah

if (uv(2) eq 1) or $
  ((b_chg ne b_on3) and ((uv(2) eq 3) or (uv(2) eq 4) or (uv(2) eq 5))) then begin
    b_chg =  b_on3
        if uv(2) eq 1 then begin
           widget_control,uv(3),get_value=wnum  & wnum=wnum(0)      ;Load
           i =strpos(wnum,'W') & b_wl=strtrim(strmid(wnum,i+1,4),2)
           wsdiag & endif
        s =0 & ii=execute('s=size(w'+b_wl+')')
        if s(0) eq 2 then begin
           sw=b_z(0) & pi=1. & pj=1.
           if PIXH lt PIXV then pi=PIXH/PIXV else pj=PIXV/PIXH
           b_p  =[1+ ((PIXV/PIXH)-1)/2. , 1+ ((PIXH/PIXV)-1)/2.]

           b_f1 =float(sw)/(s(1)) & b_f2=float(sw)/(s(2))
           if b_f1 lt b_f2 then b_f2=b_f1 else b_f1=b_f2
           b_f1=b_f1*pi  & b_f2=b_f2*pj
           si=round(s(1)*b_f1) & sj=round(s(2)*b_f2)
           ii=execute ('b_area=congrid(w'+b_wl+',si,sj)')
           if b_on3 then b_area=alog((temporary(b_area)>0)+1)
           b_area=bytscl(temporary(b_area))
        endif
    if uv(2) eq 1 then begin b_new=1 & uv(2)=3
    endif else if (size(b_arel))(0) eq 2 then begin
           b_areu=congrid( b_arel,b_z(0),b_z(0))
           if b_on3 then b_areu=alog((temporary(b_areu)>0)+1)
           b_areu=bytscl(temporary(b_areu))
    endif
endif

if uv(2) eq 11 then if (event.type eq 0) and (b_show eq 1) then begin;Mouse for Center & Ray
   if event.press eq 1 then begin                                    ;Center
	cti=event.X / b_f1  + 0.5
	ctj=event.Y / b_f2  + 0.5
	if (cti gt long(cti)+ 0.25) and (cti lt long(cti)+ 0.75) then cti=long(cti)+0.5 else cti=round(cti)
	if (ctj gt long(ctj)+ 0.25) and (ctj lt long(ctj)+ 0.75) then ctj=long(ctj)+0.5 else ctj=round(ctj)
	widget_control,b_t(0),set_value=strtrim(string(cti),2)
	widget_control,b_t(1),set_value=strtrim(string(ctj),2)
   endif else begin                                                  ;Ray
	nn1=event.X / (b_f1+b_f2) *2.
	nn2=event.Y / (b_f1+b_f2) *2.
	rr2=round(sqrt((abs(nn1-cti)+1)^2 + (abs(nn2-ctj)+1)^2))
	widget_control,b_t(6),set_value=strtrim(string(rr2),2)
   endelse
   uv(2)=3 & b_new=1
endif

case uv(2) of
2: begin widget_control,event.id,get_value=wnum  & wnum=wnum(0)      ;Write
        i =strpos(wnum,'W') & b_ww=strtrim(strmid(wnum,i+1,4),2)
        if b_show eq 2 then XICUTER,'w'+b_ww+'=Unroll (w'+b_wl+')'
        if b_show eq 3 then XICUTER,'w'+b_ww+'=Diagram(w'+b_wl+')'
   end
3: begin wsdiag  & wset,b_win(2) & erase,255 & tvscl,b_area & b_show=1 ;input Data
        sw=b_z(0) & sh=b_z(1) & sw1=sw-1
        ctx=cti-0.5 & cty=ctj-0.5
        ccx=ctx*b_f1 & ccy=cty*b_f2 & nn1=rr1*(b_f1+b_f2)/2 & nn2=rr2*(b_f1+b_f2)/2

        tx1=round([ccx-nn2,ccx+nn2])>0<sw1 & ty1=round([ccy,ccy])>0<sw1
        tx2=round([ccx,ccx])>0<sw1         & ty2=round([ccy-nn2,ccy+nn2])>0<sw1
        tx3=round([ccx-nn1,ccx+nn1])>0<sw1 & ty3=round([ccy,ccy])>0<sw1
        tx4=round([ccx,ccx])>0<sw1         & ty4=round([ccy-nn1,ccy+nn1])>0<sw1
        plots,tx2,ty2,/device,color=255   & plots,tx1,ty1,/device,color=255
        plots,tx3,ty3,/device,color=0     & plots,tx4,ty4,/device,color=0

        plots,tx1,ty1-1,/device,color=0   & plots,tx1,ty1+1,/device,color=0
        plots,tx2-1,ty2,/device,color=0   & plots,tx2+1,ty2,/device,color=0
        plots,tx3,ty3-1,/device,color=255 & plots,tx3,ty3+1,/device,color=255
        plots,tx4-1,ty4,/device,color=255 & plots,tx4+1,ty4,/device,color=255

	nn2 = nn2-1 & n = round(nn2 * 100./256.)>20
	ceri=(findgen(n)-(n-1)/2.) / ((n-1)/2.) * !pi
	cery=(sin(ceri)*nn2 + ccy) >0<sw1 & cerx=(cos(ceri)*nn2 + ccx) >0<sw1
	plots,cerx,cery,/device,color=0
	nn2 = nn2+1 & n = round(nn2 * 100./256.)>20
	ceri=(findgen(n)-(n-1)/2.) / ((n-1)/2.) * !pi
	cery=(sin(ceri)*nn2 + ccy) >0<sw1 & cerx=(cos(ceri)*nn2 + ccx) >0<sw1
	plots,cerx,cery,/device,color=255

	n = round(nn1 * 100./256.)>20
	ceri=(findgen(n)-(n-1)/2.) / ((n-1)/2.) * !pi
	cery=(sin(ceri)*nn1 + ccy) >0<sw1 & cerx=(cos(ceri)*nn1 + ccx) >0<sw1
	plots,cerx,cery,/device,color=0

	if b_new then begin s=0
	   ii=execute('s =size(w'+b_wl+')')    & td=0    & tr=b_z(1)/10
	   nn2=rr2*b_p(0)
	   si=(cti+nn2-5)>0<(s(1)-1) & sj=(cti+nn2+4)>0<(s(1)-1)
	   ii=execute('td=w'+b_wl+'(si:sj,*)') & wset,b_win(4) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),sd(1)*tr,round(sd(2)*b_f2))
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,0,0
	      tp1=[0,((ctx+nn2-si)>0<(s(1)-1))*tr]
	      plots,tp1,ty1  ,/device,color=255 & plots,tp1,ty1+1,/device,color=0
	      plots,tp1,ty1-1,/device,color=0
	      endif
	   si=(cti-nn2+5)>0<(s(1)-1) & sj=(cti-nn2-4)>0<(s(1)-1)
	   ii=execute('td=w'+b_wl+'(sj:si,*)') & wset,b_win(0) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),sd(1)*tr,round(sd(2)*b_f2))
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,b_z(1)-sd(1)*tr,0
	      tp1=[-((si-ctx+nn2)>0<(s(1)-1))*tr,0]+b_z(1)-1
	      plots,tp1,ty1  ,/device,color=255 & plots,tp1,ty1+1,/device,color=0
	      plots,tp1,ty1-1,/device,color=0
	      endif
	   nn2=rr2*b_p(1)
	   si=(ctj+nn2-5)>0<(s(2)-1) & sj=(ctj+nn2+4)>0<(s(2)-1)
	   ii=execute('td=w'+b_wl+'(*,si:sj)') & wset,b_win(1) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),round(sd(1)*b_f1),sd(2)*tr)
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,0,0
	      tp1=[0,((cty+nn2-si)>0<(s(2)-1))*tr]
	      plots,tx2  ,tp1,/device,color=255 & plots,tx2+1,tp1,/device,color=0
	      plots,tx2-1,tp1,/device,color=0
	      endif
	   si=(ctj-nn2+5)>0<(s(2)-1) & sj=(ctj-nn2-4)>0<(s(2)-1)
	   ii=execute('td=w'+b_wl+'(*,sj:si)') & wset,b_win(3) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),round(sd(1)*b_f1),sd(2)*tr)
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,0,b_z(1)-sd(2)*tr
	      tp1=[0,-((si-cty+nn2)>0<(s(2)-1))*tr]+b_z(1)-1
	      plots,tx2  ,tp1,/device,color=255 & plots,tx2+1,tp1,/device,color=0
	      plots,tx2-1,tp1,/device,color=0
	      endif
	endif
   end
4: begin wsdiag  & if b_new then begin tAV=AV & tAH=AH & ii=execute( $
       'depli, w'+b_wl+',rr1,rr2, b_arel,b_diam,b_xdia,b_red,tAV,tAH')       ;diagram
                  endif
        b_new=0 & wset,b_win(2) & b_show=3
        titx ='DIAGRAM 2*Theta'
        if b_on3 then tity ='MEAN (Log)' else tity='MEAN'
        trap_current=!D.window
        if b_on3 then $
           plot,b_xdia,alog(b_diam>.5),xtitle=titx,ytitle=tity,background=255,color=0 else $
           plot,b_xdia,     b_diam    ,xtitle=titx,ytitle=tity,background=255,color=0
   end
5: begin wsdiag  & if b_new then begin tAV=AV & tAH=AH & ii=execute( $
                 'depli, w'+b_wl+',rr1,rr2, b_arel,b_diam,b_xdia,b_red,tAV,tAH')       ;unroll
		  yf=(size(b_arel))(2)
		  if yf le b_z(0)/4 then yf=yf*4   else $
		  if yf le b_z(0)/3 then yf=yf*3   else $
		  if yf le b_z(0)/2 then yf=yf*2 & yf=yf<b_z(0)
                  b_areu=congrid( b_arel,b_z(0),yf)
                  if b_on3  then  b_areu=alog((temporary(b_areu)>0)+1)
                  b_areu=bytscl(temporary(b_areu))
		endif else yf= (size(b_areu))(2)
        b_new=0 & wset,b_win(2) & erase,255 & tvscl,b_areu,0,(b_z(0)-yf)/2 & b_show=2
        if b_win(5) gt 0 then begin
           nic  =n_elements(b_diam)
           mind =min(b_diam)
           b_dia=b_diam(2:nic-3)
           idx  =where(b_dia ne 0)
           if idx(0) ge 0 then b_dia=b_dia(idx) else b_dia=[0]
           mine =total(b_dia)/n_elements(b_dia)

           indi1=((b_diam - shift(b_diam, 2)))
           indi2=((b_diam - shift(b_diam,-2)))
           indil= (indi1<0) * (indi2<0)
           indih= (indi1>0) * (indi2>0)
           indil(0:1)=0 & indil(nic-2:*)=0
           indih(0:1)=0 & indih(nic-2:*)=0

           idx  =where(indil>0)
           if idx(0) ge 0 then indil=b_diam(idx) else indil=mine
           idx  =where(indih>0)
           if idx(0) ge 0 then indih=b_diam(idx) else indih=mine
           indih=(total(indih)/n_elements(indih))
           indil=(total(indil)/n_elements(indil))
           indid=1./((indih-indil)>0.01)
           tit="Value to be minimized: "+strtrim(string(indid),2)
           wset,b_win(5)
           trap_current=!D.window
           plot,b_xdia,b_diam,color=0,xstyle=5,ystyle=5,subtitle="",title=tit,background=255,$
                xmargin=[0,0],ymargin=[0,2],charsize=1.5,charthick=2,font=-1,/nodata
           polyfill,[b_xdia(0),b_xdia,b_xdia(nic-1)],[mind,b_diam,mind],color=100,/data
           oplot,b_xdia,b_diam,color=0
        endif
   end
6: begin b_on1=event.select & widget_control,b_t(21),map=b_on1       ;Distortion
   end
7: begin b_on2=event.select & widget_control,b_t(22),map=b_on2       ;Plate angle
   end
8: begin b_on3=event.select                                          ;Log
   end
9: begin b_arel=0 & b_area=0 & b_areu=0 & b_diam=0 & b_xdia=0        ;destroy
         widget_control,event.top,/destroy
   end
10:begin b_red=event.select & b_new=1                                ;Reduce
   end
12:begin                                                             ;Mouse Stop
   end
13:begin shape=uv(3)        & b_new=1                                ;Shapes
   end
14:begin squar=0 & b_new=1  & end                                    ;Raw
15:begin squar=1 & b_new=1  & end                                    ;Squared (keep total intensity)
16:begin squar=2 & b_new=1  & end                                    ;Square  (keep pixel intensity)

else:
endcase

end

pro wgdiag, idx
;** ******
;**
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar

tmp='0' & widget_control,bad_id=ii,b_t(idx),get_value=tmp & tmp=tmp(0)
flg= 1  & on_ioerror,misflt & val=0. & val=float(tmp) & flg=0 & misflt:
if idx eq 2  then val=val>0.1
if idx ge 3  then val=val>0.
if idx eq 6  then val=val>1.
b_v(idx)=val
b_s(idx)=strtrim(string(b_v(idx)),2)
if flg then widget_control,bad_id=ii,b_t(idx),set_value=b_s(idx)
end

pro wsdiag
;** ******
;**
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah

for idx=0,n_elements(b_t)-3 do wgdiag, (idx)

if (not b_new) then  $
if (b_v(0)  ne cti)  or (b_v(1)  ne ctj)  or (b_v(2)  ne DIS)  or (b_v(3)  ne PIXV) or (b_v(4)  ne PIXH) or $
   (b_v(5)  ne rr1)  or (b_v(6)  ne rr2)  or (b_v(7)  ne a1 )  or (b_v(8)  ne a2 )  or (b_v(9)  ne FQ )  or $
                                             (b_v(14) ne PHI)  then b_new=1
if (b_on1)  then     if (b_v(12) ne dxt)  or (b_v(13) ne dyt)  or $
                        (b_v(10) ne FCTX) or (b_v(11) ne FCTY) then b_new=1
if (b_on2)  then     if (b_v(15) ne av )  or (b_v(16) ne ah)   or (b_v(17) ne lhl)  or (b_v(18) ne lhr)  or $
                        (b_v(19) ne lvu)  or (b_v(20) ne lvd)  then b_new=1

	cti =b_v(0)   &  ctj =b_v(1)
	lvu =b_v(19)  &  lvd =b_v(20)
	lhl =b_v(17)  &  lhr =b_v(18)
	PIXH=b_v(3)   &  PIXV=b_v(4)
	FCTX=b_v(10)  &  FCTY=b_v(11) ;** Spacial distortion center %.

	dxt =b_v(12)  &  dyt =b_v(13) ;** Spacial distortion factors.
	a1  =b_v(7)   &  a2  =b_v(8)  ;** Sector to analyse.
	DIS =b_v(2)                   ;** Sample to Detector distance in Cm.
	FQ  =b_v(9)                   ;** Spacial distortion parameters.
	PHI =b_v(14)

	rr1  =b_v(5)  &  rr2  =b_v(6) & av=b_v(15) & ah=b_v(16)

	if (not b_on1) then begin dxt=0 & dyt=0 & endif
	if (dxt eq 0)  and (dyt eq 0) then begin  FCTX=-1. & FCTY=-1.  & endif
	if (not b_on2) then begin lvu=0 & lvd=0 & lhl=0 & lhr=0 & av=0 & ah=0 & endif
end

;pro DECOR, cti_,ctj_,a1_,a2_,DIS_,PIXV_,PIXH_,shap,squa, LVu_,LVd_,LHl_,LHr_,FQ_,PHI_,DXT_,DYT_,FCTX_,FCTY_
;;** *****
;;**
;common depli,cti,ctj, a1,a2, DIS,PIXV,PIXH, shape,squar, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
;
;	cti=cti_ & ctj=ctj_ & a1=a1_   & a2=a2_       & DIS=DIS_   & PIXV=PIXV_ & PIXH=PIXH_
;	LVu=LVu_ & LVd=LVd_ & LHl=LHl_ & LHr=LHr_     & FQ=FQ_     & PHI=PHI_
;	DXT=DXT_ & DYT=DYT_ & FCTX=FCTX_ & FCTY=FCTY_ & shape=shap & squar=squa
;WDIAG, /nw
;end

pro DEPLI,  area, ry1,ry2 ,arel,diam,xdiam,b_red, AV,AH
;** *****
;** INPUT
;** Image plate                 ->	area
;** Radius limits               ->	ry1 ,ry2	(pixels)
;** Known plate angles (else 0) ->	AV,AH		(0  ,0 )

;** OUTPUT
;** Pyramid & diagram & x coord.-> 	arel,diam,xdiam
;** Calculated plate angles     -> 	AV,AH

;** Vertical   decal	LVu ,LVd
;** Horizontal decal	LHl ,LHr
;** Vert. pixel resol.  PIXV
;** Hori. pixel resol.  PIXH
;** Distortion center   FCTX,FCTY
;** Distance sample(cm)	DIS
;** Center		cti ,ctj
;** Sector limits	a1  ,a2
;** Spacial distortion parameters FQ,PHI
;** Spacial distortion factors  DXT,DYT

common depli,cti,ctj,aa1,aa2,DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common destop , wit
common dexxl  , xxl1,xxl2
common rad_tmp, i1,i2,it,j1,j2,jt,nz,r,ta,tt,ra1,ra2,ii1,ii2,ii3,ii4,$
                jj1,jj2,jj3,jj4,ki,kj
;**
;float jt,r,ra1,ra2
;
vsiz =size(area)
if vsiz(0) eq 2 then begin
	cx   =cti
	cy   =ctj
	ci   =float(cti-1)
	cj   =float(ctj-1)

;**	Allocate memory
;**	-------- ------
	r1   =ry1 & if r1 le 0  then r1= 1
	r2   =ry2 & if r2 lt r1 then r2=r1
	pii  =!pi
	dpi  =pii/2
	pf   =round (r2/2000 + 1)
	if n_elements(b_red) eq 1 then pf=pf*(b_red+1)
	if n_elements(AV)    ne 1 then AV=0
	if n_elements(AH)    ne 1 then AH=0
	sx   =long (pii*r2*2/pf)+ 3
	sx1  =sx-1
	sy   =round(r2-r1+1)
	sy1  =sy-1
	arel =fltarr(sx,sy)
	arec =fltarr(sx,sy)
	diam =fltarr(sy)
	xdiam=fltarr(sy)
	
	rad_6	 = 6.2832
	rad_57	 = 57.2956

	a1=aa1 & a2=aa2
	if ((a1 eq 0.)    and (a2 eq 360.)) or $
	   ((a1 eq 1.)    and (a2 eq 360.)) or $
	   ((a1 eq -180.) and (a2 eq 180.)) or $
	    (a1 eq a2)    then ta=0 else ta=1

;**	Calculate limit index
;**	--------- ----- -----
	ra1=a1*pii/180.
	ra2=a2*pii/180.
	csa1=cos(ra1)
	csa2=cos(ra2)
	sna1=sin(ra1)
	sna2=sin(ra2)
;
	ii1=ci+csa1*r1
	ii2=ci+csa1*r2
	ii3=ci+csa2*r1
	ii4=ci+csa2*r2
	same=1-ta & if a1 ge a2 then if (a1/90 eq a2/90) then same=1

	if ((sna1 gt 0) and (sna2 lt 0)) or (same eq 1) then i1 =long (ci-r2) $
					else i1 =long (min([ii1,ii2,ii3,ii4]))
	if ((sna1 lt 0) and (sna2 gt 0)) or (same eq 1) then i2 =round(ci+r2) $
					else i2 =round(max([ii1,ii2,ii3,ii4]))
	if i1 lt 0       then i1=long(0)
	if i2 ge vsiz(1) then i2=vsiz(1)-1
	i1=long(i1)
;
	jj1=cj-sna1*r1
	jj2=cj-sna1*r2
	jj3=cj-sna2*r1
	jj4=cj-sna2*r2
	if ((csa1 gt 0) and (csa2 lt 0)) or (same eq 1) then j1 =long (cj-r2) $
					else j1 =long (min([jj1,jj2,jj3,jj4]))
	if ((csa1 lt 0) and (csa2 gt 0)) or (same eq 1) then j2 =round(cj+r2) $
					else j2 =round(max([jj1,jj2,jj3,jj4]))

	if j1 lt 0       then j1=long(0)
	if j2 ge vsiz(2) then j2=vsiz(2)-1
	j1=long(j1)

;**	Initialise all correctors
;**	---------- --- ----------
	ra1=-0.01+a1
	ra2= 0.01+a2

;	Correctors for pixel resolution
;	********** *** ***** **********
	DPIX= 1+ ((PIXV/PIXH)-1)/2.
	DPIY= 1+ ((PIXH/PIXV)-1)/2.

;	Correctors for scanner spacial distortion
;	********** *** ******* ******* **********
	cpx  =(vsiz(1)-1)*FCTX			& cpy  =(vsiz(2)-1)*FCTY
	if (FCTX eq -1) and (FCTY eq -1) then begin cpx=ci & cpy=cj & endif
	pci  =ci  -cpx				& pcj  =cpy -  cj

	if pcj ne 0 then ang  =atan(pcj,pci) else ang=0.

	nci  =pci* (1+ DXT*cos(FQ* ang +PHI))	& ncj  =pcj* (1+ DYT*cos(FQ* ang +PHI))

	p_u  =cpy -(cj-LVu) 			& p_d  =cpy -((vsiz(2)-1) - (cj+LVd))
	p_l  =cpx -(ci-LHl) 			& p_r  =cpx -((vsiz(1)-1) - (ci+LHr))

	if p_u ne 0 then angu =atan (p_u,pci)	  else angu=0.
	if p_d ne 0 then angd =atan (p_d,pci)	  else angd=0.
	puj  =p_u* (1+ DYT*cos(FQ*angu +PHI))	& pdj  =p_d* (1+ DYT*cos(FQ*angd +PHI))
	if pcj ne 0 then angl =atan (pcj,p_l)     else angl=0.
	if pcj ne 0 then angr =atan (pcj,p_r)     else angr=0.
	pli  =p_l* (1+ DXT*cos(FQ*angl +PHI))	& pri  =p_r* (1+ DXT*cos(FQ*angr +PHI))
	
	IF LVu gt 0 then begin
	LVu  =sqrt ((LVu + p_u - puj)^2 + (pci-nci)^2)
	LVd  =sqrt ((LVd + p_d - pdj)^2 + (pci-nci)^2)
	LHl  =sqrt ((LHl + p_l - pli)^2 + (pcj-ncj)^2)
	LHr  =sqrt ((LHr + p_r - pri)^2 + (pcj-ncj)^2)
	endif else begin
	LVu=1. & LVd=1. & LHl=1. & LHr=1. & endelse

;	Correctors for plate angle
;	********** *** ***** *****
	P=1.        ;& if vsiz(1) gt 2000 then P=2.
	DISV= 10000.*DIS/PIXV/P			& DISH= 10000.*DIS/PIXH/P   & DISM=(DISV+DISH)/2
	if (AV eq 0) and (AH eq 0) then begin
	 DV  = float (LVd-LVu)			& DH  = float (LHr-LHl)
	 AV  = 1.5   & CSAV=0.07 & SNAV=0.99	& AH  = 1.5   & CSAH=0.07 & SNAH=0.99
	 SNAV= (DISV * DV) / (2  * LVu *LVd  )	& SNAH= (DISH * DH) / (2  * LHl *LHr  )
	 if (SNAV le 1)   and (SNAV ge -1) then   AV  = asin(SNAV)
	 if (SNAH le 1)   and (SNAH ge -1) then   AH  = asin(SNAH)
	endif else begin
	     SNAV=sin(av)
	     SNAH=sin(ah)
	endelse

	if (AV   lt 1.5) then CSAV=cos(AV)
	if (AH   lt 1.5) then CSAH=cos(AH)
	DCSV=  DISV * CSAV			& DCSH=  DISH * CSAH
;
;MAIN LOOP: PYRAMID CONSTRUCTION
;*********
	ci2=round(ci*2) & r2b=r2+.5
	ci1=ci-1
	ab =1
	mid=(sx)/2. -1
	ofx=cx-long(cx) & ofy=cy-long(cy)
	pox=cpx-ofx     & poy=cpy+ofy
	j3 =j2+sy1      & if shape eq 1 then j3=j3+sy1

	FOR j =j1,j2 DO BEGIN
	    pj= poy-j

	    for i=i1,i2 do begin
		pi = i-pox

;	        Scanner distortion
;		------- ----------
		if pj ne 0 then ang=atan(pj,pi) else ang=0.
		tcs=cos(FQ*ang+PHI)

		ki =pi * (1+ DXT*tcs) - nci
		kj =pj * (1+ DYT*tcs) - ncj

;	    	Horizontal,Vertical Correction angle
;		------------------- ---------- -----
	    	ki=DCSH * ki / (DISH+ki*SNAH)
		kj=DCSV * kj / (DISV-kj*SNAV)

;		Pixel size correction
;		----- ---- ----------
		ki=ki*DPIX
		kj=kj*DPIY
;		Shape detector correction (not used)
;		----- -------- ----------

;		Intensity  correction (not used)
;		---------  ----------
		r =sqrt(kj^2 + ki^2)
		
		it=round(r)
		if  (it ge r1)  then begin
		 if (it le r2b) then begin
		     if kj ne 0 then ang=atan(kj,ki) else ang=0.
		     if  ta  eq 1 then begin
		         if ang lt 0 then vtm= (rad_6 + ang)*rad_57 else vtm= ang*rad_57
		         if a2 ge a1 then begin
		           if (vtm ge ra1) and (vtm le ra2) then ab=1 else ab=0
		         endif else $
		           if (vtm ge ra1) or  (vtm le ra2) then ab=1 else ab=0
		     endif
		     if ab eq 1 then begin
		       val=area(i,j)
		       if val ge 0 then begin
			cir=abs(r-r1)
			if ang le dpi	then xir=(it*(ang+dpi    )/pf +mid) $
					else xir=(it*(ang-dpi-pii)/pf +mid)   
			xil=long(xir) & xid=(xil+1)<sx1
			cil=long(cir) & cid=(cil+1)<sy1

			fcx=1.-(xir-xil) & fcy=1.-(cir-cil)

			fc =fcx*fcy
			arel(xil,cil)=arel(xil,cil)+val*fc & arec(xil,cil)=arec(xil,cil)+fc
			fc =(1.-fcx)*(1.-fcy)
			arel(xid,cid)=arel(xid,cid)+val*fc & arec(xid,cid)=arec(xid,cid)+fc
			fc =(1.-fcx)*(fcy)
			arel(xid,cil)=arel(xid,cil)+val*fc & arec(xid,cil)=arec(xid,cil)+fc
			fc =(fcx)*(1.-fcy)
			arel(xil,cid)=arel(xil,cid)+val*fc & arec(xil,cid)=arec(xil,cid)+fc
		       endif
		     endif
		 endif  else if i ge ci  then i=i2+ 1 $
		 	else if i eq i1  then begin if kj ne 0 then ang=atan(kj,ki) else ang=0.
						    i=i1+ (long((r2-it)/cos(ang))-1)>0 & endif
		endif   else if i lt ci1 then i=ci2-i-1

	    endfor 
	    if n_elements(wit) ge 1 then $
	    if RDSTOP(j1,j3,(j),win=wit) then begin j=j2+1 & j3=0 & endif
	ENDFOR

;**	DIAGRAM
;**	*******
	arel =temporary(arel)/(arec>.0001)
	diam =reform (total ( (arec)/(arec>.0001),1))

;		         Pi*d       *             theta/360              /   pixelsize(mm)
;		ii= (!pi*DIS*2*10.) * (atan((i+r1)/DISM)*180/!pi) / 360. / ((PIXV+PIXH)/2./1000)
;		ii=      DIS*2*10.  *  atan((i+r1)/DISM)*180      / 360. /  (PIXV+PIXH)*2.*1000
;		ii=      DIS*2      *  atan((i+r1)/DISM)/2. /  (PIXV+PIXH)*2.*10000.
;		ii=      DIS*2      *  atan((i+r1)/DISM)    /  (PIXV+PIXH)   *10000.

	if shape eq 1 then begin
	   arc  =     DIS*2    / (PIXV+PIXH) *10000.
	   nip  =     arc      * (atan(     r1 /DISM)) 
	   ni   =     arc      * (atan((sy1+r1)/DISM)) - nip
	   fdiam= fltarr(sy)
	   endif

	arex=total(arec,2) & idx=where(arex gt 0)
	xxl1=idx(0)>0 & xxl2=idx(n_elements(idx)-1)>0

	sr1=pii*2./pf & sr2 =sr1*r2
	aret=arel(*,0)
	arev=aret
	mi1=long(mid) & mi2=round(mid)

	if j3 gt 0 then $
	for i =sy1 ,0,-1 do begin 
	    if squar ne 0 then  begin sr=sr2/(sr1*(i+r1)) & srd=(sr-1.)/2.
	                        aret=aret*0. & arev=arev*0. & endif
	    j=mi1
	    while (j gt 0) and (arec(j,i) eq 0) do j=j-1
	    while  j gt 0 do begin
	        if arec(j,i) eq 0 then if (arec(j-1,i) ne 0) and (arec(j+1,i) ne 0) $
	                          then begin arel(j,i)=(arel(j-1,i)+arel(j+1,i) )  / 2.
	                                     diam(i)=diam(i)+1
	                          endif
	        if squar ne 0 then begin
			nwi=mid-(mid-j)*sr
			nw1=round(nwi-srd)>xxl1 & nw2=round(nwi+srd)<xxl2
			for k=nw1,nw2 do begin aret(k)=aret(k)+arel(j,i)
			                       arev(k)=arev(k)+sr & endfor
	        endif
	        j=j-1
	    endwhile

	    j=mi2
	    while (j lt sx1) and (arec(j,i) eq 0) do j=j+1
	    while  j lt sx1 do begin
	        if arec(j,i) eq 0 then if (arec(j-1,i) ne 0) and (arec(j+1,i) ne 0) $
	                          then begin arel(j,i)=(arel(j-1,i)+arel(j+1,i) )  / 2.
	                                     diam(i)=diam(i)+1
	                          endif
	        if squar ne 0 then begin
			nwi=mid+(j-mid)*sr
			nw1=round(nwi-srd)>xxl1 & nw2=round(nwi+srd)<xxl2
			for k=nw1,nw2 do begin aret(k)=aret(k)+arel(j,i)
			                       arev(k)=arev(k)+sr & endfor
	        endif
	        j=j+1
	    endwhile

	    if diam(i) gt 0 then  diam(i)=total(arel(*,i))/diam(i)

	    if squar ne 0 then  begin aret=aret/(arev>1) & totl=total(arel(*,i))
	    			if squar eq 2 then aret=aret*sr
	    			arel(*,i)=aret & from=xxl1 & to=xxl2>xxl1
	                        idx=where(aret(from:to) eq 0)
	                        if idx(0) ge 0 then $
	                        for k=n_elements(idx)-1,0,-1 do begin kd=idx(k)+from
				    if kd gt from then ia=aret(kd-1) else ia=0
				    if kd lt to   then ib=aret(kd+1) else ib=0
				    if ia eq 0 then arel(kd,i)=ib else if ib ne 0 then arel(kd,i)=(ia+ib)/2. else arel(kd,i)=ia
	                            ;  print,'trou=',i,kd
	                        endfor
				if squar eq 1 then begin
					tott=total(arel(*,i)) & arel(*,i)=arel(*,i) * (totl/tott) & endif
	    		  endif

	   ;if squar ne 0 then begin idx=where(arev gt sr) & if idx(0) ge 0 then print,'coli=',i,sr,idx & endif

	    theta=atan((i+r1)/DISM)

	    if shape eq 1 then fdiam(i)= arc * theta -nip

;	    if diam(i) gt 0 then  diam(i)=total(arel(*,i))/diam(i)
	    xdiam(i)=theta
	    if n_elements(wit) ge 1 then $
	    if RDSTOP(j1,j3,(j2+sy1-i),win=wit) then begin i=i-sy1 & j3=0 & endif
	endfor

;	Shape detector correction
;	----- -------- ----------
	if j3    gt 0  then $
	if shape eq 1  then begin
	   arec =arec *0.
	   diat =diam *0.
	   xdiat=xdiam*0. & xdiot=xdiat
	   for i=0,sy1 do begin
		i1=long(fdiam(i)) & i2=(i1+1)<sy1 & b1=1.-(fdiam(i)-i1)
		                                    b2=1.-b1
		arec(*,i1)=arel (*,i)*b1 +  arec (*,i1)
		arec(*,i2)=arel (*,i)*b2 +  arec (*,i2)
		diat(  i1)=diam (  i)*b1 +  diat (  i1)
		diat(  i2)=diam (  i)*b2 +  diat (  i2)
		xdiat( i1)=xdiam(  i)*b1 +  xdiat(  i1) & xdiot(i1)=xdiot(i1)+b1
		xdiat( i2)=xdiam(  i)*b2 +  xdiat(  i2) & xdiot(i2)=xdiot(i2)+b2

	       if n_elements(wit) ge 1 then $
	       if RDSTOP(j1,j3,(j2+sy1+i),win=wit) then begin i=i+sy1 & j3=0 & endif
	   endfor
	   ni=long(ni)
	   arel=arec(*,1:ni) & diam=diat(1:ni) & xdiam=xdiat(1:ni)/(xdiot(1:ni)>.0001)
	   arec=0            & diat=0          & xdiat=0   & xdiot=0   & fdiam=0
	endif
;	-------------------------
	xdiam=xdiam*180/pii * 2.
	if pf ne 1 then arel=temporary(arel)*pf
	if squar ne 0 then begin arex=total(arel,2) & idx=where(arex gt 0)
				 xxl1=idx(0)>0 & xxl2=idx(n_elements(idx)-1)>0 & endif
endif
;
return
end

pro wdiag, NW=nw
;** *****
;**
@lamp.cbk
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common destop , wit

if keyword_set(nw) then return

i=xregistered('Unroll')
if i le 0 then begin

 if n_elements(b_rol) eq 0 then begin             ;** SET FIXED PARAMETERS
 ;** Position of beam center                   -> centx,centy [first value in the file is at (1,1)]
 ;** For a ring: constated radius at angle  90 -> rVu	[0]
 ;               constated radius at angle -90 -> rVd	[0]
 ;** For a ring: constated radius at angle   0 -> rHr	[0]
 ;               constated radius at angle 180 -> rVl	[0]
 ;** Vertical    pixel resolution (micron)     -> pixsv  [150 or 75]
 ;** Horizontal  pixel resolution (micron)     -> pixsh  [150 or 75]
 ;** Horizontal  distortion center factor      -> tcx    [ .5]
 ;** Vertical    distortion center factor      -> tcy    [ .5]

	b_win  =lonarr(8) & b_t=lonarr(23) & b_v=float(b_t)
	b_v(2) =100       & b_v(3) =150    & b_v(4) =150
	b_v(5) =1         & b_v(6) =10     & b_v(7) =0        & b_v(8) =360
	b_v(9) =4         & b_v(10)=0.5    & b_v(11)=0.5
	b_s    =strtrim(string(b_v),2)
	b_wl   ='1'       & b_ww   ='2'    & b_new  =1        & b_area=[[0,0],[0,0]]
	b_areu =b_area    & b_show = 0     & b_z    =[512,30] & b_on1 =0 & b_on2=0
	b_on3  =0         & b_chg  =b_on3  & b_red  =0        & shape =0 & squar=0
 endif
 
 if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0
 b_rol=widget_base  (title='Unrolling...',/row,group_leader=lamp_b1,resource_name="lamp")
 sw=b_z(0) & sh=b_z(1)
 b_l0 =widget_base  (b_rol,/column)
 b_l  =widget_base  (b_l0 ,/row)
 b_r  =widget_base  (b_rol,/column)
 b_l1 =widget_base  (b_l  ,/column)
     bmp0    =widget_base(b_l1,map=0)
     bmap    =widget_draw(bmp0,xsize=sh,ysize=sh)
     bmap    =widget_base(b_l1)
     b_win(0)=widget_draw(bmap,xsize=sh,ysize=sw)
     bmp1    =widget_base(b_l1,map=0)
     bmap    =widget_draw(bmp1,xsize=sh,ysize=sh)
 b_l2 =widget_base  (b_l  ,/column)
     bmap    =widget_base(b_l2)
     b_win(1)=widget_draw(bmap,xsize=sw,ysize=sh)
     bmap    =widget_base(b_l2)
     b_win(2)=widget_draw(bmap,xsize=sw,ysize=sw,/button_events,uvalue=[-88,378,11])
     bmap    =widget_base(b_l2)
     b_win(3)=widget_draw(bmap,xsize=sw,ysize=sh)
 b_l3 =widget_base  (b_l  ,/column)
     bmp2    =widget_base(b_l3,map=0)
     bmap    =widget_draw(bmp2,xsize=sh,ysize=sh)
     bmap    =widget_base(b_l3)
     b_win(4)=widget_draw(bmap,xsize=sh,ysize=sw)
     bmp3    =widget_base(b_l3,map=0)
     bmap    =widget_draw(bmp3,xsize=sh,ysize=sh)

 if lamp_siz gt 750 then b_win(5) =widget_draw(b_l0,xsize=595,ysize=160,/button_events,uvalue=[-88,378,12]) $
 else begin bil     =widget_base(title="Diagram",group_leader=b_rol)
            b_win(5)=widget_draw(bil,xsize=595,ysize=160,/button_events,uvalue=[-88,378,12])
            widget_control,bil,/realize & endelse

 b_r0 =widget_base  (b_r  ,/row)
	b_r0l=widget_button(b_r0  ,font=ft_smaller ,value='<-')
	b_r0m=widget_button(b_r0  ,font=ft_propor  ,value='load W ' +b_wl)
	b_r0r=widget_button(b_r0  ,font=ft_smaller,value='->')
	widget_control,bad_id=i,b_r0l,set_uvalue=[-88,310  ,b_r0m,1]
	widget_control,bad_id=i,b_r0m,set_uvalue=[-88,378,1,b_r0m  ]
	widget_control,bad_id=i,b_r0r,set_uvalue=[-88,311  ,b_r0m,1]

	b_don=widget_button(b_r0  ,font=ft_b_normal,value="Done"         ,uvalue=[-88,378,9])

	b_r9l=widget_button(b_r0  ,font=ft_smaller ,value='<-')
	b_r9m=widget_button(b_r0  ,font=ft_propor  ,value='write W '+b_ww,uvalue=[-88,378,2])
	b_r9r=widget_button(b_r0  ,font=ft_smaller,value='->')
	widget_control,bad_id=i,b_r9l,set_uvalue=[-88,310,b_r9m,1]
	widget_control,bad_id=i,b_r9r,set_uvalue=[-88,311,b_r9m,1]

 b_r1 =widget_base  (b_r  ,/column,/frame,resource_name="mic")
     blab    =widget_label (widget_base(b_r1,/row),value="CONSTANTS",font=ft_b_normal)
     bid     =widget_base  (b_r1 ,/row)
     blab    =widget_label (bid  ,value="Cx"                    ,font=ft_propor)
     b_t(0)  =widget_text  (bid  ,value=b_s(0),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="Cy"                    ,font=ft_propor)
     b_t(1)  =widget_text  (bid  ,value=b_s(1),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="Center in pixel"       ,font=ft_b_normal)
     bid     =widget_base  (b_r1 ,/row)
     blab    =widget_label (bid  ,value="Sd"                    ,font=ft_propor)
     b_t(2)  =widget_text  (bid  ,value=b_s(2),xsize=7+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Sample to Detector distance in Cm.",font=ft_b_normal)
     bid     =widget_base  (b_r1 ,/row)
     blab    =widget_label (bid  ,value="Px"                    ,font=ft_propor)
     b_t(3)  =widget_text  (bid  ,value=b_s(3),xsize=7+cap,/editable,uvalue=[-88,378,1,b_r0m],font=ft_propor)
     blab    =widget_label (bid  ,value="Py"                    ,font=ft_propor)
     b_t(4)  =widget_text  (bid  ,value=b_s(4),xsize=7+cap,/editable,uvalue=[-88,378,1,b_r0m],font=ft_propor)
     blab    =widget_label (bid  ,value="Pixel size in micron"  ,font=ft_b_normal)

 b_r2 =widget_base  (b_r  ,/column,/frame,resource_name="did")
     blab    =widget_label (widget_base(b_r2,/row),value="REPRESENTATION",font=ft_b_normal)
     bid     =widget_base  (b_r2 ,/row)
     blab    =widget_label (bid  ,value="Ra"                    ,font=ft_propor)
     b_t(5)  =widget_text  (bid  ,value=b_s(5),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="Rb"                    ,font=ft_propor)
     b_t(6)  =widget_text  (bid  ,value=b_s(6),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="in,out Radius in pixel",font=ft_b_normal)
     bid     =widget_base  (b_r2 ,/row)
     blab    =widget_label (bid  ,value="Sa"                    ,font=ft_propor)    ;    270
     b_t(7)  =widget_text  (bid  ,value=b_s(7),xsize=7+cap,/editable,font=ft_propor);180     0,360
     blab    =widget_label (bid  ,value="Sb"                    ,font=ft_propor)    ;     90
     b_t(8)  =widget_text  (bid  ,value=b_s(8),xsize=7+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="deg. Sector"           ,font=ft_b_normal)
     widget_control,b_t(7),sensitive =0,set_value='0.'
     widget_control,b_t(8),sensitive =0,set_value='360.'
     bido   =widget_base   (b_r2 ,/row)
     bid     =widget_button(bido ,value="input data"    ,font=ft_b_normal,uvalue=[-88,378,3])
     bid     =widget_button(bido ,value="diagram"       ,font=ft_b_normal,uvalue=[-88,378,4])
     blab    =widget_label (bido ,value="   ",font=ft_b_normal) & put_logo,bido
     lilu    =widget_base  (bido,/nonexclusive,/row)
     bidu    =widget_button(lilu ,value="log"    ,uvalue=[-88,378,8] ,font=ft_b_normal)
     bid     =widget_button(lilu ,value="reduce" ,uvalue=[-88,378,10],font=ft_b_normal)
     bido    =widget_base  (b_r2 ,/row)
     bid     =widget_button(bido ,value="show unrolled rings",font=ft_b_normal,uvalue=[-88,378,5])
     blab    =widget_label (bido ,value="   ",font=ft_b_normal)
     lilu    =widget_base  (bido,/exclusive,/row)
     bid1    =widget_button(lilu ,value="raw"     ,uvalue=[-88,378,14],font=ft_b_normal,/no_release)
     bid2    =widget_button(lilu ,value="dilated" ,uvalue=[-88,378,15],font=ft_b_normal,/no_release)
     bid3    =widget_button(lilu ,value="squared"  ,uvalue=[-88,378,16],font=ft_b_normal,/no_release) & bid123=[bid1,bid2,bid3]
     widget_control,bidu         ,set_button=b_on3
     widget_control,bid123(squar),set_button=1

 b_r3 =widget_base  (b_r  ,/column,/frame,resource_name="don")
     blab    =widget_label (widget_base(b_r3,/row),value="DETECTOR SHAPE",font=ft_b_normal)
     bid     =widget_base  (b_r3  ,/row,/exclusive)
     bidu    =widget_button(bid   ,value="sphere"               ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,0])
     bid1    =widget_button(bid   ,value="plate"                ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,1])
     bida    =widget_button(bid   ,value="y cylinder"           ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,2])
     bidb    =widget_button(bid   ,value="x cyl."               ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,3])
     widget_control,bidu,set_button=1
     widget_control,bida,sensitive =0
     widget_control,bidb,sensitive =0
 b_r4 =widget_base  (b_r  ,/column,/frame)
     bid     =widget_base  (b_r4 ,/row)
     blab    =widget_label (bid  ,value="SCANNER DISTORTION",font=ft_b_normal)
     bid1    =widget_button(widget_base(bid,/nonexclusive),value="on/off",font=ft_b_normal,$
                                                          uvalue=[-88,378,6])
     blab    =widget_button(bid  ,value="!",font=ft_smaller)
     b_r44   =widget_base  (b_r4 ,/column,resource_name="ben")
     bid     =widget_base  (b_r44,/row)
     blab    =widget_label (bid  ,value="Tx"                    ,font=ft_propor)
     b_t(10) =widget_text  (bid  ,value=b_s(10),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Ty"                    ,font=ft_propor)
     b_t(11) =widget_text  (bid  ,value=b_s(11),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Frequ"                 ,font=ft_propor)
     b_t(9)  =widget_text  (bid  ,value=b_s(9) ,xsize=3+cap,/editable,font=ft_propor)
     bid     =widget_base  (b_r44,/row)
     blab    =widget_label (bid  ,value="Fx"                    ,font=ft_propor)
     b_t(12) =widget_text  (bid  ,value=b_s(12),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Fy"                    ,font=ft_propor)
     b_t(13) =widget_text  (bid  ,value=b_s(13),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Phase"                 ,font=ft_propor)
     b_t(14) =widget_text  (bid  ,value=b_s(14),xsize=3+cap,/editable,font=ft_propor)
     widget_control,b_r44,map=0

 b_r5 =widget_base  (b_r  ,/column,/frame)
     bid     =widget_base  (b_r5 ,/row)
     blab    =widget_label (bid  ,value="PLATE DELTA ANGLE",font=ft_b_normal)
     bid1    =widget_button(widget_base(bid,/nonexclusive),value="on/off",font=ft_b_normal,$
                                                          uvalue=[-88,378,7])
     blab    =widget_button(bid  ,value="!",font=ft_smaller)
     b_r55   =widget_base  (b_r5 ,/column,resource_name="ben")
     bid     =widget_base  (b_r55,/row)
     blab    =widget_label (bid  ,value="Av"                    ,font=ft_propor)
     b_t(15) =widget_text  (bid  ,value=b_s(15),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Ah"                    ,font=ft_propor)
     b_t(16) =widget_text  (bid  ,value=b_s(16),xsize=4+cap,/editable,font=ft_propor)
     bid     =widget_base  (b_r55,/row)
     blab    =widget_label (bid  ,value="Lr"                    ,font=ft_propor)
     b_t(17) =widget_text  (bid  ,value=b_s(17),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Rr"                    ,font=ft_propor)
     b_t(18) =widget_text  (bid  ,value=b_s(18),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Ur"                    ,font=ft_propor)
     b_t(19) =widget_text  (bid  ,value=b_s(19),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Dr"                    ,font=ft_propor)
     b_t(20) =widget_text  (bid  ,value=b_s(20),xsize=4+cap,/editable,font=ft_propor)
     widget_control,b_r55,map=0
 
 b_t(21)=b_r44 & b_t(22)=b_r55
 widget_control,b_rol,/realize & put_logo
 wsdiag
 b_win(6)=b_win(2)
 b_win(7)=b_win(5)
 for  i=0,4       do   begin widget_control,b_win(i),get_value=j & b_win(i)=j & endfor
 if b_win(5) gt 0 then begin widget_control,b_win(5),get_value=j & b_win(5)=j & endif

 wit=[b_win(7),b_win(5),592,160]

 Xmanager,'Unroll',b_rol,event_handler='LAMP_EVENT_PARSER',/just_reg

endif else widget_control,bad_id=i,b_rol,map=1
end
FUNCTION without_borders,w,modulo,i
take_datp,datp
i=indgen(1600)
maxmod=max(i mod modulo)
wnew=w(where(((i mod modulo) ne 0) and ((i mod modulo) ne maxmod)))
x=datp.x(where(((i mod modulo) ne 0) and ((i mod modulo) ne maxmod)))
e=datp.e(where(((i mod modulo) ne 0) and ((i mod modulo) ne maxmod)))
mod_datp,datp,'x',x
mod_datp,datp,'e',e
give_datp,datp
RETURN,wnew
END
pro workspaces
print,'***************** What is a Workspace? ************************'
print,' '
print,'The so-called workspace is th major conception of LAMP.'
print,'Twenty workspaces W1 to W20 are disponible. '
print,'In each you may read your data, so generally neutron counting rates '
print,' '
print,'Each workspace, e.g. W6 (1D, 2D or even 3D ), goes together with further data'
print,'that have been read out from the raw data (numors).  '
print,' '
print,'In the case of a powder diffractometer you will store the twotheta values '
print,'for each detector cell in the array X6 - LAMP does it for you during  '
print,'reading in your numor(s). '
print,' '
print,'If you read in several numors or one numor containing several acquisitions  '
print,'(a scan or a multi-stroboscopic acquisition) there will be an array Y6 '
print,'containing e.g. the motor value for a motor scan  '
print,' '
print,'Even an array Z6 has been foreseen ... '
print,' '
print,'General parameters are stored in an 1D-array P6'
print,' '
print,'Variable parameters (several numors or acquisitions) are stored in PV6; '
print,'if W6 is two-dimensional (e.g. a scan), PV6 will be 2D as well and will'
print,'contain some variable parameters for each step of a scan (temperature, motors)'
print,' '
print,'N6 contains monitor information. For D20 it is already two-dimensional fo a   '
print,'single acquisition and 3D for a scan. N6(0,0,*) contains the monitor counting '
print,'rate eventually changed by a normalisation factor, N6(0,1,*) contains the '
print,'counting time in seconds, not changed, and N6(0,2,*) contains an optional '
print,'second monitor, eventually changed due to normalisation. Some operations '
print,'(substraction) are refused by LAMP, if the monitor of the two workspaces to '
print,'be compared are not equal. N7(0) has to be equal N6(0) before performing '
print,'W8=W7-W6 '
print,' '
print,'E6 contains the error (sigma) of counting rate. LAMP detects arithmetic '
print,'operations to workspaces and let the errors correctly follow up. However, not '
print,'all operations a user may imagine have been imagined by the auythors of LAMP, '
print,'so if you note a bug in error calculation, please inform the Computing for '
print,'Science!  '
print,' '
print,'W_TIT(6), OTHER_TIT(6), X_TIT(6), Y_TIT(6), Z_TIT(6), PAR_TXT(6,*) contain'
print,'title strings, axis labels and explainations to the fixed parameters of W6'
print,' '
end
pro write_hdf, FileName , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
;** *********
                               , PR=p, PV=pv, P_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot, SRC=src, HIST=hist $
			       , PAR_TXT_ALL=pa_txt, LIM=lim, MACH=mach $
                               , DOE=doe, SNAP=snap, DATE=date, FIFI=fifi
;**
;**	Call for data-write HDF NeXus (called by LAMP).

;**	FileName: name of the output file (file.hdf)
;**	Data    : the data of any dimension.
;**	Keywords:		  
;**		  XC       = vector of x coordinates.
;**		  YC       = vector of y coordinates.
;**		  ZC       = vector of z coordinates (or scalar).
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors (or scalar).
;**		  PR       = vector of float parameter values (or scalar).
;**		  P_TXT    = string array of text associated to PR (same size).
;**		  PV       = an array of any dimensions containing other parameter values (or 0).
;**		  E        = the errors associated to DATA (same size or 0).
;**		  SRC      = Instrument name.
;**		  HIST     = An history of the Data (string).
;**	Other Keywords:
;**		  PAR_TXT_ALL(unnecessary) p_txt + '=' + string(p) (if "" write_hdf will do for you)
;**		  LIM      = (unnecessary)
;**		  MACH     = (unused)
;**		  DOE      = (unused)
;**		  SNAP     = (optional) a 192*192 bytarea image snapshot of the Data.
;**		  DATE     = (optional) date of experiment (string).
;**		  FIFI     = (unused)

fid=0 & sdid=0
if !version.release lt '4.0' then begin print,string(7b)+"IDL version is too low !!!"   & return & endif
CATCH,stat &   IF stat ne 0  then begin print,!err_string & if sdid gt 0 then HDF_SD_END,sdid & if fid gt 0 then HDF_CLOSE,fid & return & endif
ON_IOERROR,mis

;******************
;**For Tests only**
;******************
if n_elements(p) eq 0 then begin
   s=size(Data) & x=indgen(s(1)) & if s(0) gt 1 then y=indgen(s(2)) else y=0
   z=0 & e=findgen(s(1)) & n=[1,2,3] & p=[1.,2.] & p_txt=['a','b'] & pv=findgen(2,3,4)
   wt='W' & xt='X' & yt='Y' & zt='Z' & ot='O' & src='Test'   & hist='Histoire'
   lim='This is limtx' & mach='win'  & snap=bytscl(dist(15)) & date=systime()
   endif
;*****************
;**Preliminaries**
;*****************
if wt eq '' then wt='W' & if xt eq '' then xt='X' & if yt  eq '' then yt='Y'
if zt eq '' then zt='Z' & if ot eq '' then ot='s' & if src eq '' then src='?'
if n_elements(date)   ne 1 then date=''
if n_elements(pa_txt) lt n_elements(p) then pa_txt=p_txt + '=' + string(p)
sdtag=720
myRG =[max(Data,min=mini),mini]

sx=n_elements(X) & sy=n_elements(Y) & sz=n_elements(Z)
S =size(Data)
xd=S(1) & if S(0) gt 1 then yd=s(2) else yd=0
          if S(0) gt 2 then begin zd=s(3)
                            if sz lt zd then Z=findgen(zd)+1 & sz=n_elements(Z)
          endif else zd=0

SV=[S(1:S(0))]

tiip=['ud','byte','short','long','float','double','double','string','ud','ud','ud','ud','uint','ulong','ud','ud']
ntip=[ 0L ,  21L ,  22L  ,  24L ,  5L   ,   6L   ,   6L   ,   3L   , 0L , 0L , 0L , 0L ,  23L ,  25L  , 0L , 0L ]
tip =tiip(s(s(0)+1))
nip =ntip(s(s(0)+1))
ymj =bin_date(systime()) & day=string(ymj(0),format='(I4,"-")')+string(ymj(1),format='(I2,"-")')+ $
                               string(ymj(2),format='(I2," ")')+string(ymj(3),format='(I2,":")')+ $
                               string(ymj(4),format='(I2,":")')+string(ymj(5),format='(I2)')
mon =float(N(*,0))
moni=1D/(total(mon)>1)
CAL={ Cal:moni, Cal_Err:0.0D, Offset:0.0D, Offset_Err:0.0D, Num_Type:nip }

;*******************
;**Create HDF file**
;*******************
fid  = HDF_OPEN     (FileName, /CREATE)
;*     ********
if fid gt 0 then begin

 sdid = HDF_SD_START (FileName, /RDWR)
;*      ************

 HDF_SD_ATTRSET, sdid, 'Written_by_LAMP','Lamp & Idl'+!version.release+' on '+!version.os+' '+!version.os_family, /STRING
 HDF_SD_ATTRSET, sdid, 'file_name'      , FileName    , /STRING
 HDF_SD_ATTRSET, sdid, 'file_time'      , day         , /STRING
 HDF_SD_ATTRSET, sdid, 'user'           , src+' '+date, /STRING

 vdid = HDF_VG_ATTACH(fid,-1,/WRITE) & HDF_VG_SETINFO,vdid, name ='entry1', class ='NXentry'
 vdat = HDF_VG_ATTACH(fid,-1,/WRITE) & HDF_VG_SETINFO,vdat, name ='data1' , class ='NXdata'
        HDF_VG_INSERT,vdid  , vdat

 if n_elements(src)   eq 1 then $
 HDF_SD_ATTRSET, sdid, 'SOURCE'        , src , /STRING
;**************
 if n_elements(hist)  eq 1 then $
 HDF_SD_ATTRSET, sdid, 'HISTORY'       , hist, /STRING
;**************
 HDF_SD_ATTRSET, sdid, 'TITLES'        , wt  , /STRING
;**************
 HDF_SD_ATTRSET, sdid, 'OTHER'         , ot  , /STRING
;**************
 if n_elements(lim)   eq 1 then $
 HDF_SD_ATTRSET, sdid, 'MIN_MAX_VALUES', lim , /STRING
;**************
;if n_elements(p)     eq 1 then $
 HDF_SD_ATTRSET, sdid, 'PARAMETERS'    , P   , n_elements(P)    , /FLOAT
;**************
;if n_elements(mach)  eq 1 then $
;HDF_SD_ATTRSET, sdid, 'MACHINE'       ,mach , /STRING
;**************

 np=n_elements(p)
 if np gt 1 then if n_elements(pa_txt) ge np then begin
    lf=string(10b) & para=''
    for i=0,np-1 do para=para+pa_txt(i)+' '+lf+' '
    sd0id= HDF_SD_CREATE   (sdid,'PARAMETERS',[strlen(para)] ,/STRING)
           HDF_SD_ADDDATA  ,sd0id,para & ref= HDF_SD_IDTOREF  (sd0id)
           HDF_SD_ENDACCESS,sd0id      &      HDF_VG_ADDTR,vdat,sdtag,ref
;*         ****************
 endif

 sdsid= 0 & ii=execute('sdsid= HDF_SD_CREATE(sdid,"DATA",SV,/'+tip+')' )
;*                             *************
 HDF_SD_SETINFO, sdsid, FORMAT=tip, LABEL=WT, CALDATA=cal, RANGE=myRG
;**************
 HDF_SD_ATTRSET, sdsid, 'signal'  , 1      ,1, /LONG
 HDF_SD_ATTRSET, sdsid, 'units'   , wt       , /STRING
 if n_elements(mon) eq 1 then HDF_SD_ATTRSET, sdsid, 'MONITORS',mon     ,1, /FLOAT
 if sy              eq 1 then HDF_SD_ATTRSET, sdsid, 'Y_VALUE' ,float(y),1, /FLOAT
 if sz              eq 1 then HDF_SD_ATTRSET, sdsid, 'Z_VALUE' ,float(z),1, /FLOAT

 if (s(0) gt 1) or (sy eq 1) then begin sdxid=HDF_SD_DIMGETID(sdsid,0)
   HDF_SD_DIMSET,sdxid,NAME='X_COORDINATES',LABEL=XT,SCALE=float(X),/BW_INCOMP & endif
;* *************

 if (s(0) gt 1) then begin              sdyid=HDF_SD_DIMGETID(sdsid,1)
   HDF_SD_DIMSET,sdyid,NAME='Y_COORDINATES',LABEL=YT,SCALE=float(Y),/BW_INCOMP & endif
;* *************

 if (s(0) gt 2) then begin              sdzid=HDF_SD_DIMGETID(sdsid,2)
   HDF_SD_DIMSET,sdzid,NAME='Z_COORDINATES',LABEL=ZT,SCALE=float(Z),/BW_INCOMP & endif
;* *************

 if (s(0) eq 1) and (sy gt 1) then $
   HDF_SD_ATTRSET, sdsid, 'X_SPACE', float(x), n_elements(x)  , /FLOAT
 if (s(0) eq 1) and (sy gt 1) then $
   HDF_SD_ATTRSET, sdsid, 'Y_SPACE', float(y), n_elements(y)  , /FLOAT
 if (s(0) eq 1) and (sz gt 1) then $
   HDF_SD_ATTRSET, sdsid, 'Z_SPACE', float(z), n_elements(z)  , /FLOAT

 if !version.release ge '5.2.1' then if strpos(strlowcase(FileName),'_c' ) ge 0 then begin cps=0
                                     if strpos(strlowcase(FileName),'_c1') ge 0 then       cps=1
                                     if strpos(strlowcase(FileName),'_c2') ge 0 then       cps=4
                                     if strpos(strlowcase(FileName),'_c3') ge 0 then       cps=3
                                     if strpos(strlowcase(FileName),'_c4') ge 0 then       cps=4
                                     if cps gt 0 then HDF_SD_SETCOMPRESS,sdsid,cps
                                     endif
 HDF_SD_ADDDATA, sdsid, Data  & ref= HDF_SD_IDTOREF   (sdsid)
;**************
 HDF_SD_ENDACCESS, sdsid      &      HDF_VG_ADDTR,vdat ,sdtag,ref
;****************

;*****For NEXUS compatibility*****
 if sx gt 1 then begin sxc=size(x)  & SC=[sxc(1:sxc(0))] 
    sdxid= HDF_SD_CREATE   (sdid ,'X',SC ,/FLOAT)
           HDF_SD_ATTRSET  ,sdxid,'axis',1,1,/LONG & HDF_SD_ATTRSET,sdxid,'units',XT,/STRING 
           HDF_SD_ADDDATA  ,sdxid,float(x)  &  ref = HDF_SD_IDTOREF(sdxid)
           HDF_SD_ENDACCESS,sdxid           &        HDF_VG_ADDTR  ,vdat,sdtag,ref & endif

 if sy gt 1 then begin syc=size(y)  & SC=[syc(1:syc(0))]
    sdyid= HDF_SD_CREATE   (sdid ,'Y',SC ,/FLOAT)
           HDF_SD_ATTRSET  ,sdyid,'axis',2,1,/LONG & HDF_SD_ATTRSET,sdyid,'units',YT,/STRING 
           HDF_SD_ADDDATA  ,sdyid,float(y)  &  ref = HDF_SD_IDTOREF(sdyid)
           HDF_SD_ENDACCESS,sdyid           &        HDF_VG_ADDTR  ,vdat,sdtag,ref & endif

 if sz gt 1 then begin szc=size(z)  & SC=[szc(1:szc(0))] 
    sdzid= HDF_SD_CREATE   (sdid ,'Z',SC ,/FLOAT)
           HDF_SD_ATTRSET  ,sdzid,'axis',3,1,/LONG & HDF_SD_ATTRSET,sdzid,'units',ZT,/STRING 
           HDF_SD_ADDDATA  ,sdzid,float(z)  &  ref = HDF_SD_IDTOREF(sdzid)
           HDF_SD_ENDACCESS,sdzid           &        HDF_VG_ADDTR  ,vdat,sdtag,ref & endif
;*****End NEXUS compatibility*****

 if n_elements(PV)   gt 1 then begin npv=size(PV)   & SP=[npv(1:npv(0))] 
    sd2id= HDF_SD_CREATE   (sdid,'VAR_PARAMS',SP ,/FLOAT)
           HDF_SD_ADDDATA  ,sd2id, PV & ref= HDF_SD_IDTOREF  (sd2id)
           HDF_SD_ENDACCESS,sd2id     &      HDF_VG_ADDTR,vdat,sdtag,ref & endif

 if n_elements(E)    gt 1 then begin nee=size(E)    & SE=[nee(1:nee(0))] 
    sd3id= HDF_SD_CREATE   (sdid,'errors'    ,SE ,/FLOAT)
           HDF_SD_ADDDATA  ,sd3id,  E & ref= HDF_SD_IDTOREF  (sd3id)
           HDF_SD_ENDACCESS,sd3id     &      HDF_VG_ADDTR,vdat,sdtag,ref & endif

 if n_elements(SNAP) gt 1 then begin snp=size(SNAP) & SN=[snp(1:snp(0))] 
    sd4id= HDF_SD_CREATE   (sdid,'SNAPSHOT'  ,SN ,/BYTE)
           HDF_SD_ADDDATA  ,sd4id,SNAP &  & ref= HDF_SD_IDTOREF  (sd4id)
           HDF_SD_ENDACCESS,sd4id         &      HDF_VG_ADDTR,vdat,sdtag,ref
;*         ****************
 endif

 HDF_VG_DETACH, vdat
;*************
 if (size(N))(1) eq  S(1) then mon=float(N(*,0)) else mon=float(N)
 if n_elements(mon)  gt 1 then begin smo=size(mon)  & SM=[smo(1:smo(0))]
 vmon = HDF_VG_ATTACH(fid,-1,/WRITE) & HDF_VG_SETINFO, vmon, name ='monitors' , class ='NXmonitor'
        HDF_VG_INSERT,vdid  , vmon
 sdmon= HDF_SD_CREATE(sdid,'MONITOR1',SM     , /float)
        HDF_SD_ATTRSET  ,sdmon,'signal', 0,1 , /BYTE
        HDF_SD_ADDDATA  ,sdmon, mon & ref= HDF_SD_IDTOREF  (sdmon)
        HDF_SD_ENDACCESS,sdmon      &      HDF_VG_ADDTR,vmon,sdtag,ref
        HDF_VG_DETACH   ,vmon	      & endif
;*      ****************

 HDF_VG_DETACH, vdid	

 HDF_SD_END   , sdid
 HDF_CLOSE    , fid
endif	
return
mis:	print,!err_string & if fid gt 0 then HDF_CLOSE, fid
end
pro write_inx, o_file,w_buf ,XC=x_buf, YC=y_buf, PR=pmt_buf, E=e_buf ,$
                             ZC=z_buf,  N=n_buf, PV=pv,PAR_TXT=p_txt ,$
                             W_tit=wt  , X_tit=xt , Y_TIT=yt         ,$
                             Z_tit=zt  , OTHER_TIT=ot
;** *********
;**
; Dumps an INX file - parameters may be a bit odd

pi=3.1416

; Prepare zones
   nzone=intarr(7)
   nzone(1)=1
   nzone(2)=2
   nzone(3:6)=0

   my_check=size(w_buf)

;
; What dimensions for the data?
      case my_check(0) of
         0: return
         1: begin
               nchans=my_check(1)
               nspecs=1
            end
         2: begin
               nchans=my_check(1)
               nspecs=my_check(2)
            end
	 else: return
      endcase
   
   if n_elements(w_buf) ne n_elements(e_buf) then e_buf=w_buf*0.
   if (size(y_buf))(0) eq 2 then y_buf=reform(y_buf(0,*))
   sx=(size(x_buf))(0)
   
; Get the parameters
      temp	=pmt_buf(11) 
      einc	=81.799/pmt_buf(21)/pmt_buf(21) 
      qinc	=2*pi/pmt_buf(21) 
      amass	=1.0
      nlines	=nchans+3
      deltatau	=pmt_buf(18)
      deltaen	=0.0
      deltak	=0.0
      isym	=0
      dumme	=0.0

      on_ioerror,pb_wrt  
      get_lun,ifile
      openw,ifile,o_file
				frmv='(5x,f10.5,e13.5,e12.4)'
       if max(y_buf) ge 10 then frmt='(x,f6.2,f8.3,f8.4,f9.3,f6.1,i2)' $
			   else frmt='(x,f6.4,f8.3,f8.4,f9.3,f6.1,i2)'
       for i=0,nspecs-1 do begin
	 printf ,ifile,nlines,nzone(1:6),nchans          ,format='(8i5)'
	 printf ,ifile,wt
	 printf ,ifile,y_buf(i),einc,qinc,temp,amass,isym,format=frmt
	 printf ,ifile,deltaen,deltatau,deltak           ,format='(16x,3f8.4)'
	 if sx eq 1 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j)  ,w_buf(j,i),e_buf(j,i)  ,format=frmv

	 if sx eq 2 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j,i),w_buf(j,i),e_buf(j,i)  ,format=frmv

       endfor
       pb_wrt:free_lun,ifile
    return
    end	    
      
function write_tag, lev , tag , attr , str ,opn
;******* *********
ctrT=' '
for i=1,lev do ctrT=ctrT+' '
if tag  gt '' then if opn gt 0 then ctrT=ctrT+'<'+tag else ctrT=ctrT+'</'+tag
if attr gt '' then ctrT=ctrT+' '+attr+'> '  else if tag  gt '' then ctrT=ctrT+'> '
if str  gt '' then ctrT=ctrT+str
if opn  eq 2  then ctrT=ctrT+'</'+tag+'>'
return, ctrT
end

pro write_xml, FileName , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
;** *********
                               , PR=p, PV=pv, PAR_TXT=p_txt       $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot, PAR_TXT_ALL=pa_txt $
                               , SRC=src, HIST=hist, LIM=lim, MACH=mach $
                               , DOE=doe, SNAP=snap, DATE=date, FIFI=fifi
;**
;**	Keywords:
;**		  XC       = vector of x coordinates.
;**		  YC       = vector of y coordinates.
;**		  ZC       = vector of z coordinates.
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size)
fid=0
CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
ON_IOERROR,mis

;******************
;**For Tests only**
;******************
if n_elements(p) eq 0 then begin s=size(Data)
   e=findgen(s(1)) & p=[1.,2.] & p_txt=['a','b'] & pv=findgen(2,3,4) & fifi=FileName
   n=[1,2,3]       & x=indgen(s(1))  & if s(0) gt 1 then y=indgen(s(2)) else y=4.5
   pa_txt=p_txt+ ' = '+string(p)     & if s(0) gt 2 then z=indgen(s(3)) else z=6.4
   wt='W' & xt='X' & yt='Y' & zt='Z' & ot='O' & src='Test'   & hist='Histoire'
   lim='This is limtx' & mach='win'  & snap=bytscl(dist(15)) & date=systime()
   endif
;*****************
;**Preliminaries**
;*****************
if wt eq '' then wt='W' & if xt eq '' then xt='X' & if yt  eq '' then yt='Y'
if zt eq '' then zt='Z' & if ot eq '' then ot='s' & if src eq '' then src='?'
myRG =[max(Data,min=mini),mini]

fileN=FileName & i=rstrpos(fileN,'.') & if i gt 0 then fileN=strmid(fileN,0,i)
fileG=fileN                           & i=strpos(FileName,fifi)>0   & lan=0
fileZ=strmid(fileG,i,60)              & fileF=fileZ+'.xml' & fileG=fileZ+'-1.png'
codx='txt' & codz='.gz'
if !version.release lt '5.3' then begin codx='xdr' & codz="" & endif

sx=n_elements(X) & sy=n_elements(Y) & sz=n_elements(Z)
S =size(Data)
xd=S(1) & dim=strtrim(string(xd),2)
	if S(0) gt 1 then begin yd=s(2) & dim=dim+','+strtrim(string(yd),2) & endif else yd=0
      if S(0) gt 2 then begin zd=s(3) & dim=dim+','+strtrim(string(zd),2)
		if sz lt zd then   Z=findgen(zd)+1 & sz=n_elements(Z)         & endif else zd=0

tiip=['ud','byte','int','long','float','double','double','string','ud','ud','ud','ud','uint','ulong','ud','ud']
tip =tiip(s(s(0)+1))
ymj =bin_date(systime()) & day=string(ymj(0),format='(I4,"-")')+string(ymj(1),format='(I2,"-")')+ $
                               string(ymj(2),format='(I2," ")')+string(ymj(3),format='(I2,":")')+ $
                               string(ymj(4),format='(I2,":")')+string(ymj(5),format='(I2)')
mon =float(N(*,0))

;*******************
;**Create XML file**
;*******************
OPENW,fid, FileN+'.xml', /get_lun
;*    ***
 str ='Written_by_LAMP: Lamp + Idl'+!version.release+' on '+!version.os   ;+' '+!version.os_family
 attr=      'file_name="'+FileF+'"'
 attr=attr+' file_time="'+day+'"'
 attr=attr+     ' user="'+src+' '+date+'"'
 PRINTF, fid, write_tag(0 , 'NXmlfile' , attr , str ,1) & PRINTF,fid,''

  if n_elements(hist) eq 1 then str=hist else str=''
  PRINTF, fid, write_tag(1 , 'NXentry'  , 'name="entry1"' , str  ,1) & PRINTF,fid,''

   attr='title="'+wt+'" sub_title="'+ot+'"'
   if n_elements(src)   eq 1 then attr=attr+' source="'+src +'"'
   if n_elements(p)     eq 1 then attr=attr+ ' param="'+strtrim(string(p(0)),2)+'"'
   PRINTF, fid, write_tag(2 , 'NXdata'  , attr  , lim  ,1) & PRINTF,fid,''

     np=n_elements(p)
     if np gt 1 then begin
      PRINTF, fid, write_tag(3 , 'Parameters' , 'lines="'+strtrim(string(np),2)+'"' ,'',1)
      for i=0,np-1 do PRINTF, fid, write_tag(4 ,'','', pa_txt(i) ,0)
      PRINTF, fid, write_tag(3 , 'Parameters'  , '' , '' , 0) & PRINTF,fid,''
     endif

     if n_elements(snap) gt 1 then begin WRITE_KIF,FileG,snap,transparent=[0] ;ii=sys_dep('GIFTRANS',FileG)
      if strpos(FileG,'.png') gt 0 then giff='type="png"'
      if strpos(FileG,'.jpg') gt 0 then giff='type="jpeg"'
      if strpos(FileG,'.gif') gt 0 then giff='type="gif"'
      attr=giff+' size="[192,192]" file_name="'+FileG+'"'
      PRINTF, fid, write_tag(3 , 'Snapshot'  , attr  , ''  ,2) & PRINTF,fid,''
     endif

     if sx gt 1 then begin sxc=size(x)  & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	attr='axis="1" type="float" dims="['+SC+']" units="" label="'+xt+'"'
	PRINTF, fid, write_tag(3 , 'X_coord'  , attr  , ''  ,1)
	PRINTF, fid, float(x)
	PRINTF, fid, write_tag(3 , 'X_coord'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif
     if sy gt 1 then begin sxc=size(y)  & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	attr='axis="2" type="float" dims="['+SC+']" units="" label="'+yt+'"
	PRINTF, fid, write_tag(3 , 'Y_coord'  , attr  , ''  ,1)
	PRINTF, fid, float(y)
	PRINTF, fid, write_tag(3 , 'Y_coord'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif
     if sz gt 1 then begin sxc=size(z)  & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	attr='axis="3" type="float" dims="['+SC+']" units="" label="'+zt+'"'
	PRINTF, fid, write_tag(3 , 'Z_coord'  , attr  , ''  ,1)
	PRINTF, fid, float(z)
	PRINTF, fid, write_tag(3 , 'Z_coord'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif

     if n_elements(PV) gt 1 then begin sxc=size(PV) & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	if sxc(0) gt 2 then SC=SC+','+strtrim(string(sxc(3)),2)
	if sxc(0) gt 3 then SC=SC+','+strtrim(string(sxc(4)),2)
	attr='type="float" dims="['+SC+']"'
	PRINTF, fid, write_tag(3 , 'Var_params'  , attr  , ''  ,1)
	PRINTF, fid, PV
	PRINTF, fid, write_tag(3 , 'Var_params'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif

     if n_elements(Data) gt 128*512. then FO=1 else FO=0
     attr='signal="1" type="'+tip+'" dims="['+dim+']"'
     if FO then attr=attr+' file_name="'+fileZ+'.'+codx+codz+'" code="'+codx+'"'
     attr=attr+' min="'+strtrim(string(myRG(1)),2)+'" max="'+strtrim(string(myRG(0)),2)+'"'
     attr=attr+' units="count"'
     if n_elements(mon) eq 1 then attr=attr+' monitors="'+strtrim(string(mon(0)),2)+'"'
     if sy              eq 1 then attr=attr+ ' y_value="'+strtrim(string(  y(0)),2)+'"'
     if sz              eq 1 then attr=attr+ ' z_value="'+strtrim(string(  z(0)),2)+'"'
     PRINTF, fid, write_tag(3 , 'Data' ,attr , '' ,1)
     if not FO then PRINTF, fid, Data $
	 else begin  ON_IOERROR,mio
	             if codx eq 'xdr' then begin OPENW ,lan,fileN+'.'+codx      ,/get_lun,/XDR
	                                         WRITEU,lan,Data
	             endif            else begin OPENW ,lan,fileN+'.'+codx+codz,/get_lun,/compress
	                                         PRINTF,lan,Data        & endelse
	             mio:if lan gt 0 then FREE_LUN,lan & ON_IOERROR,mis & endelse
     PRINTF, fid, write_tag(3 , 'Data'  ,  ''   , ''  ,0) & PRINTF,fid,''

     if n_elements(E)  gt 1 then begin sxc=size(E)  & SC=strtrim(string(sxc(1)),2)
	 if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
     if n_elements(E) gt 128*512. then FO=1 else FO=0
	 attr='type="float" dims="['+SC+']"'
     if FO then attr=attr+' file_name="'+fileZ+'.err'+codz+'" code="'+codx+'"'
	 PRINTF, fid, write_tag(3 , 'Errors'  , attr  , ''  ,1)
	 if not FO then PRINTF, fid, E $
	 else begin  ON_IOERROR,mie
	             if codx eq 'xdr' then begin OPENW ,lan,fileN+'.err'     ,/get_lun,/XDR
	                                         WRITEU,lan,E
	             endif            else begin OPENW ,lan,fileN+'.err'+codz,/get_lun,/compress
	                                         PRINTF,lan,Data        & endelse
	             mie:if lan gt 0 then FREE_LUN,lan & ON_IOERROR,mis & endelse
	 PRINTF, fid, write_tag(3 , 'Errors'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif

   PRINTF, fid, write_tag(2 , 'NXdata'  , '' , ''  ,0) & PRINTF,fid,''

   if (size(N))(1) eq  S(1) then mon=float(N(*,0)) else mon=float(N)
   if n_elements(mon)  gt 1 then begin sxc=size(mon) & SC=strtrim(string(sxc(1)),2)
   PRINTF, fid, write_tag(2 , 'NXmonitor'  , ''  , ''  ,1)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	if sxc(0) gt 2 then SC=SC+','+strtrim(string(sxc(3)),2)
	attr='type="float" dims="['+SC+']"'
	PRINTF, fid, write_tag(3 , 'Monitors'  , attr  , ''  ,1)
	PRINTF, fid, mon
	PRINTF, fid, write_tag(3 , 'Monitors'  ,  ''   , ''  ,0)
   PRINTF, fid, write_tag(2 , 'NXmonitor'  , ''  , ''  ,0) & PRINTF,fid,''
   endif

  PRINTF, fid, write_tag(1 , 'NXentry'  , '' , ''  ,0)
 PRINTF, fid, write_tag(0 , 'NXmlfile' , '' , '' ,0)
 FREE_LUN,fid
return
mis:	print,!err_string & if fid gt 0 then free_lun, fid
end
pro xannounce,a,b
;** *********

ii=execute("print,a,b") ;Missing in IDL-4 versions !!!

end
PRO xbu_scan_om_xy ,ty_1,ty_n,ty_step,tx_1,tx_n,tx_step,om_1,om_o,om_step,sec
;***
;**
;** The call is mymacro,...

print,!stime
openw,u,"courtois01.xbu",/get_lun
for ty=ty_1,ty_n,ty_step do begin
	printf,u,"pty",ty
	for tx=tx_1,tx_n,tx_step do begin
		printf,u,"ptx",tx
  		printf,u,"som",om_1,om_o,om_step,sec," 1 1 1"
	endfor
endfor
free_lun,u
end
; $Id: xvaredit.pro,v 1.1 1993/04/02 19:54:08 idl Exp $

;
; Copyright (c) 1991-1993, Research Systems, Inc.  All rights reserved.
;	Unauthorized reproduction prohibited.
;+
; NAME:
;	XVAREDIT
; PURPOSE:
;	This routine provides an editor for any IDL variable.
; CATEGORY:
;	Widgets
; CALLING SEQUENCE:
;	XVAREDIT, VAR
; INPUTS:
;	VAR = The variable that is to be edited.
; KEYWORD PARAMETERS:
;	NAME = The NAME of the variable.  This keyword is overwritten with the
;		structure name if the variable is a structure.
;	GROUP = The widget ID of the widget that calls XVarEdit.  When this
;		ID is specified, a death of the caller results in a death of
;		XVarEdit.
; OUTPUTS:
;	VAR= The variable that has been edited, or the original when the user
;		selects the "Cancel" button in the editor.
; COMMON BLOCKS:
;	Xvarcom - stores the state of the variable that is being edited.
; SIDE EFFECTS:
;	Initiates the XManager if it is not already running.
; RESTRICTIONS:
;	If the variable is exceedingly large such as a giant structure or
;	huge array, the editor will not fit on the screen and may not be able
;	to create enough widget components to edit the whole variable.
; PROCEDURE:
;	Create and register the widget and then exit.
;	If the user selects "accept", the values in the editor are written
;	to the variable passed in, otherwise, they are ignored.
; MODIFICATION HISTORY:
;	Written by: Steve Richards,	February, 1991
;-


;------------------------------------------------------------------------------
;	procedure XVarEdit_ev
;------------------------------------------------------------------------------
; This procedure processes the events being sent by the XManager.
;------------------------------------------------------------------------------
PRO XVarEdit_ev, event

COMMON Xvarcom, thevar, initialvar, entries

WIDGET_CONTROL, event.id, GET_UVALUE = eventval		;find the user value
							;of the widget where
							;the event occured
CASE eventval OF

  "DONT": BEGIN						;the user chose the 
	    thevar = initialvar				;cancel button so just
	    WIDGET_CONTROL, event.top, /DESTROY		;return the initial
	  END						;variable

  "DO": BEGIN						;the user chose accept
          i = 0						;so go ahead and modify
 	  WHILE(i LT N_ELEMENTS(entries))DO BEGIN	;the user's variable to
	    IF(entries(i).type NE 6)THEN BEGIN		;reflect his or her 
	      WIDGET_CONTROL, entries(i).widid, $	;choice
			GET_VALUE = newval
	      error = EXECUTE(entries(i).name  + $
			"= newval(0)")
	    ENDIF ELSE BEGIN				;when the user's 
	      WIDGET_CONTROL, entries(i).widid, $	;variable has a complex
			GET_VALUE = realval		;value, the real and
	      i = i + 1					;imaginary components
	      WIDGET_CONTROL, entries(i).widid, $	;must be reassembled
			GET_VALUE = imagval		;from its respective
	      error = EXECUTE(entries(i).name  + $	;editable widget
				"= complex(" + $	;components
				string(realval(0)) + $
				"," + $
				string(imagval(0)) + $
				")")
	    ENDELSE
	    i = i + 1
	  ENDWHILE
	  WIDGET_CONTROL, event.top, /DESTROY		;once the variables 
	END						;have been retrieved, 
							;the widget heiarchy
  ELSE: 						;can be destroyed

ENDCASE

END ;============= end of XVarEdit event handling routine task =============


;------------------------------------------------------------------------------
;	procedure AddEditEntry
;------------------------------------------------------------------------------
; This procedure adds an entry to the list that contains the variables names
; and the widget id for the edit field corresponding to the variable name.
;------------------------------------------------------------------------------

PRO AddEditEntry, thename, thetype, thewidid

COMMON Xvarcom, thevar, initialvar, entries

IF N_ELEMENTS(thewidid) EQ 0 THEN thewidid = 0L
newelt = {entstr, name:thename, $			;first create a record
		  widid:thewidid, $			;and then 
		  type:thetype}				;just create a list
numents = N_ELEMENTS(entries)				;with one more element
IF(NOT(KEYWORD_SET(entries)))THEN ENTRIES = newelt $	;and replace the old 
ELSE BEGIN						;one
  newentries = REPLICATE(newelt, numents + 1)
  newentries(0:numents - 1) = entries
  newentries(numents) = newelt
  entries = newentries
ENDELSE
END ;============== end of XVarEdit event handling routine task ===============


;------------------------------------------------------------------------------
;	procedure XvarEditField
;------------------------------------------------------------------------------
;  This routine is used to create the widget or widgets needed for a given 
;  variable type.  It could call itself recursively if the variable was itself
;  a structure comprised of other IDL variables.
;------------------------------------------------------------------------------

FUNCTION XvarEditField, base, type, val, NAME = NAME	;this is a dummy 
RETURN,0						;declaration so that
END							;this routine can call
							;itself recursively
FUNCTION XvarEditField, base, val, NAME = NAME, $
		RECNAME = RECNAME

dimarr = [18, 4, 7, 10, 12, 16, 12, 20]			;an array of lengths of
							;each type

typarr = ["Undefined", "Byte", "Integer", $		;an array of names of 
	  "Longword Integer", "Floating Point", $	;each type
	  "Double Precision Floating", $
	  "Complex Floating Point", $
	  "String", "Structure"]

varsize = size(val)					;determine the size and
vardims = N_ELEMENTS(varsize) - 2			;type of the variable
type = varsize(vardims)
numelements = varsize(vardims + 1)

IF(numelements GE 5) THEN $				;if the array is larger
  scrollval = 1$					;than 5 elements, use
ELSE scrollval = 0					;a scrolling base to
							;conserve screen space

abase = WIDGET_BASE(base, $				;create a base for the
		/FRAME, $				;variable to live in
		/COLUMN, XSIZE=800,YSIZE=800,$
		XPAD = 8, $
		YPAD = 8, $
		SCROLL = scrollval)

IF(numelements GT 1) THEN BEGIN				;if the variable is an
  suffix = " Array("					;array, then say so and
  FOR j = 1, varsize(0) DO BEGIN			;show the array
    suffix = suffix + strtrim(varsize(j), 2)		;dimensions.
    IF j NE varsize(0) THEN suffix = suffix + ", "
  ENDFOR
  suffix = suffix + ")"
ENDIF ELSE suffix = ""


IF(type EQ 8) THEN NAME = TAG_NAMES(val, /STRUCTURE)	;if the variable is a 
							;structure, use its 
							;name

IF(KEYWORD_SET(NAME)) THEN $				;build up the name of
  lbl = WIDGET_LABEL(abase, $				;variable with the 
		VALUE = NAME + $			;type in parenthesese
			" (" + $
			typarr(type) + $
			suffix + $
			")") $
ELSE lbl = WIDGET_LABEL(abase, $
		value = typarr(type) + suffix)


IF(NOT(KEYWORD_SET(RECNAME))) THEN RECNAME = "thevar"	;establish the name
							;if not being called 
							;recursively

IF(varsize(0) GT 1) THEN BEGIN
  moduli = LONARR(varsize(0)-1) + 1
  FOR i = varsize(0), 2,-1 DO BEGIN
    FOR j = 1,i-1 DO $
      moduli(i - 2) = moduli(i - 2) * varsize(j)
  ENDFOR
ENDIF

FOR element = 0, numelements - 1 DO BEGIN		;for each array element

  IF(numelements NE 1) THEN BEGIN			;use array subscripting
    indexname = "("					;if variable is an
    indexname = indexname + $
		strtrim(element mod varsize(1),2)
    IF(varsize(0) GT 1) THEN BEGIN
      indexarr = lonarr(varsize(0) - 1)
      flatindex = element
      FOR i = varsize(0) - 2, 0, -1 DO BEGIN
	indexarr(i) = flatindex / moduli(i)
	flatindex = flatindex mod moduli(i)
      ENDFOR
      FOR i = 0, varsize(0) - 2 DO $
	indexname = indexname + ", " + $
		strtrim(indexarr(i), 2)
    ENDIF
    indexname = indexname + ")"
    thename = RECNAME + indexname			;build up the name from
    thebase = WIDGET_BASE(abase, $			;any previous recursive
		/FRAME, $				;names
		/ROW)
    alabel = WIDGET_LABEL(thebase, $
		VALUE = indexname + ": ")
    FRAMESETTING = 0
  ENDIF ELSE BEGIN
    FRAMESETTING = 1
    thename = RECNAME
    thebase = abase
  ENDELSE

  CASE type OF						;depending on the type,
							;build a string 
							;variable with proper
							;formatting

    0: thevalue = "Undefined Variable"			;Undefined

    1: thevalue = string(val(element), $		;Byte
		FORMAT = '(I3)')

    6: BEGIN						;Complex Float
	 rowbase = WIDGET_BASE(thebase, $		;here the variable must
		/ROW)					;be displayed in two
	 lable = WIDGET_LABEL(rowbase, $		;separate widgets for
		VALUE = "Real: ")			;its real and imaginary
	 id = WIDGET_TEXT(rowbase, $			;components
		VALUE = STRING(FLOAT(val(element))), $
		FRAME = FRAMESETTING, $
		YSIZE = 1, $
		XSIZE = dimarr(type), $
		/EDITABLE, $
		UVALUE = ' ')
	 AddEditEntry, thename, type, id
	 lable = WIDGET_LABEL(rowbase, $
		VALUE = "Imaginary: ")
	 id = WIDGET_TEXT(rowbase, $
		VALUE = STRING(IMAGINARY(val(element))), $
		FRAME = FRAMESETTING, $
		YSIZE = 1, $
		XSIZE = dimarr(type), $
		/EDITABLE, $
		UVALUE = ' ')
	AddEditEntry, thename, type, id
      END
    
    7: thevalue = val(element)				;String

    8: BEGIN						;Structure
	 tags = TAG_NAMES(val(element))
	 FOR i = 0, N_ELEMENTS(tags) - 1 DO BEGIN
	   error = EXECUTE("fieldvalue = val(element)." + tags(i))
	   fldsize = size(fieldvalue)
	   flddims = N_ELEMENTS(fldsize) - 2
	   id = XvarEditField(thebase, $
		fieldvalue, $
		NAME = tags(i), $
		RECNAME = thename + "." + tags(i))
	 ENDFOR
	END

    ELSE: thevalue = strtrim(val(element), 2)
  ENDCASE

  IF((type NE 6) AND (type NE 8)) THEN BEGIN		;here the actual widget
    id = WIDGET_TEXT(thebase, $				;is created if it was
		value = thevalue, $			;neither a structure or
		FRAME = FRAMESETTING, $			;a complex value
		YSIZE = 1, $
		XSIZE = dimarr(type), $
		/EDITABLE, $
		UVALUE = ' ')
    AddEditEntry, thename, type, id
  END

ENDFOR

return,id

END ;============= end of XVarEdit event handling routine task =============


;------------------------------------------------------------------------------
;	procedure XVarEdit
;------------------------------------------------------------------------------
; this is the actual routine that is called.  It builds up the variable editing
; fields by calling other support routines and then registers the widget 
; heiarchy with the XManager.  Notice that the widget is registered as a MODAL
; widget so it will desensitize all other current widgets until it is done.
;------------------------------------------------------------------------------
PRO XVarEdit, var, GROUP = GROUP, NAME = NAME

COMMON Xvarcom, thevar, initialvar, entries

if(n_params() ne 1) THEN $
  MESSAGE, "Must have one parameter"

IF(XRegistered("XVarEdit")) THEN RETURN			;only one instance of
							;the XVarEdit widget
							;is allowed.  If it is
							;already managed, do
							;nothing and return

XVarEditbase = WIDGET_BASE(TITLE = "XVarEdit", $	;create the main base
		/COLUMN,XSIZE=800,YSIZE=800)

XPdMenu, [	'"Cancel"		DONT',	$	;create the menu 
 		'"Accept"		DO'	$	;selections
	],					$
	 XVarEditbase

initialvar = var
thevar = var
varsize = size(var)
vardims = N_ELEMENTS(varsize) - 2

ids = XvarEditField(XVarEditbase, var, NAME = NAME)

WIDGET_CONTROL, XVarEditbase, /REALIZE			;create the widgets
							;that are defined

XManager, "XVarEdit", XVarEditbase, $			;register the widgets
		EVENT_HANDLER = "XVarEdit_ev", $	;with the XManager
		GROUP_LEADER = GROUP, $			;and pass through the
		/MODAL					;group leader if this
							;routine is to be 
							;called from some group
							;leader.

entries = 0
var = thevar

END ;================== end of XVarEdit main routine =======================


PRO xyzrange,xr,yr,zr,x3d,y3d,z3d,x1d,y1d,z1d

x1d=FINDGEN((xr(1)-xr(0))/xr(2)+1)*xr(2)+xr(0)
y1d=FINDGEN((yr(1)-yr(0))/yr(2)+1)*yr(2)+yr(0)
z1d=FINDGEN((zr(1)-zr(0))/zr(2)+1)*zr(2)+zr(0)

nx=N_ELEMENTS(x1d)
ny=N_ELEMENTS(y1d)
nz=N_ELEMENTS(z1d)

x3d=FLTARR(nx,ny,nz)
y3d=FLTARR(nx,ny,nz)
z3d=FLTARR(nx,ny,nz)

FOR iy=0,ny-1 DO BEGIN
    FOR iz=0,nz-1 DO BEGIN

      x3d(*,iy,iz)=x1d

    ENDFOR
ENDFOR

FOR ix=0,nx-1 DO BEGIN
    FOR iz=0,nz-1 DO BEGIN

      y3d(ix,*,iz)=y1d

    ENDFOR
ENDFOR

FOR ix=0,nx-1 DO BEGIN
  FOR iy=0,ny-1 DO BEGIN

      z3d(ix,iy,*)=z1d

  ENDFOR
ENDFOR

ENDPRO y2p,w,p ;** The call is Y2P,Wn[,m]
if N_ELEMENTS(p) LT 1 THEN p=12 ; default: sample temperature for D20
take_datp,d
IF N_ELEMENTS(d.pv(0,*)) EQ N_ELEMENTS(W(0,*)) THEN BEGIN
  IF N_ELEMENTS(d.pv(*,0)) GT p THEN BEGIN
    d.y=d.pv(p,*)
    d.y_tit=STRMID(d.par_txt(p),0,STRPOS(d.par_txt(p),' ('))
  ENDIF ELSE print,'variable parameter no.',p,' does not exist!'
ENDIF ELSE print,'variable parameter array does not extend over whole y-range'
give_datp,d
end


pro zelle,s,no,_extra=extra

window,2,title='zelle'+STRCOMPRESS(no)
plot,indgen(291),s(no,*),_extra=extra

end
PRO zerocharge,charge
sum=TOTAL(charge(3,*))/FLOAT(N_ELEMENTS(charge(3,*)))
minus=WHERE(charge(3,*) LT sum,neg)
plus= WHERE(charge(3,*) GT sum,pos)
charge=FLOAT(charge)
charge(3,minus)=-1.
charge(3,plus) =FLOAT(neg)/FLOAT(pos)
PRINT,TOTAL(charge(3,*))
END;-------------------------------------------------------------------------------
;*******************************************************************************
;
	FUNCTION zero_detectors, w_in0, bad1, bad2, bad3, bad4, bad5, angle=angle

;For D7 polarization analysis data only
;Zeroes non-contributing spectra or angular regions - (I=0, dI=-1)
;Data should already have every other detector removed (i.e. must have
;been put through normalise).
; 
;ARGUMENTS:
; bad1, bad2, ...	:Can either be
;			 a) detector numbers (must be even and between 2 and 64)
;			 b) ranges in scattering angle
;KEYWORD:
; /angle		:specifies that angular ranges are used
;
;DIMENSIONS
; w_in=w_out(nspectra,nphases,nruns)
;
;COMMAND SYNTAX:
; e.g.
; a) w2=zero_detectors(w1,[28,40])
;		-zeroes spectra 28 and 40
;
; b) w2=zero_detectors(w1,[29.5,44.2],/angle)
;		-zeroes spectra with scattering angles between 29.5 and 44.2 
;		 degrees. This alternative format is specified by the additional
;		 "1" after the square brackets. 
;
;						KHA,JRS 11/3/99
;
;-------------------------------------------------------------------------------
;*******************************************************************************

	iprint=0	; if iprint>0, show debugging messages

	IF (iprint GT 0) THEN PRINT,'Start zero_detectors:'

	take_datp, datp

	np=N_PARAMS()
	angflg=0
	IF KEYWORD_SET(angle) THEN BEGIN
		IF(N_PARAMS() EQ 2) THEN bad2=1
		IF(N_PARAMS() EQ 3) THEN bad3=1
		IF(N_PARAMS() EQ 4) THEN bad4=1
		IF(N_PARAMS() EQ 5) THEN bad5=1
		np=np+1
	ENDIF
;-------------------------------------------------------------------------------
;Check dimensions of input workspace and setup output workspace

	sw=SIZE(w_in)
	par=datp.p

	TOF=FIX(par(8))
	nchannels=FIX(par(6))
	nspectra=FIX(par(1))
	nphases=FIX(par(2))
	nruns=FIX(par(3))

	e_in0=datp.e
	IF (TOF EQ 0 AND nphases EQ 1) THEN BEGIN
		w_in=reform(w_in0,nspectra,nphases,nruns)
		e_in=reform(e_in0,nspectra,nphases,nruns)
	ENDIF ELSE BEGIN
		w_in=w_in0
		e_in=e_in0
	ENDELSE

	w_out=w_in
	e_out=e_in
	x_in=datp.x
	z_in=datp.z

	nothing=0
	IF (np EQ 1) THEN BEGIN
		nothing=1
		GOTO, finished
	ENDIF ELSE IF (np EQ 2) THEN BEGIN
		range=0
		bad=bad1
		nbad=N_ELEMENTS(bad)
	ENDIF ELSE BEGIN
		range=1
		IF (np EQ 3 AND N_ELEMENTS(bad2) EQ 1) THEN BEGIN
			IF (N_ELEMENTS(bad1) EQ 2 AND bad2 EQ 1) THEN bad=bad1 $
			ELSE GOTO, argerror
		ENDIF ELSE IF (np EQ 4 AND N_ELEMENTS(bad3) EQ 1) THEN BEGIN
			IF (N_ELEMENTS(bad1) EQ 2 AND N_ELEMENTS(bad2) EQ 2 $
				AND bad3 EQ 1) THEN bad=[[bad1],[bad2]] $
			ELSE GOTO, argerror
		ENDIF ELSE IF (np EQ 5 AND N_ELEMENTS(bad4) EQ 1) THEN BEGIN
			IF (N_ELEMENTS(bad1) EQ 2 AND N_ELEMENTS(bad2) EQ 2 AND N_ELEMENTS(bad3) EQ 2 $
				AND bad4 EQ 1) THEN bad=[[bad1],[bad2],[bad3]] $
			ELSE GOTO, argerror
		ENDIF ELSE IF (np EQ 6 AND N_ELEMENTS(bad5) EQ 1) THEN BEGIN
			IF (N_ELEMENTS(bad1) EQ 2 AND N_ELEMENTS(bad2) EQ 2 AND N_ELEMENTS(bad3) EQ 2 AND N_ELEMENTS(bad4) EQ 2 $
				AND bad5 EQ 1) THEN bad=[[bad1],[bad2],[bad3],[bad4]] $
			ELSE GOTO, argerror
		ENDIF
		s=size(bad)
		IF (s(0) EQ 1) THEN nbad=1 ELSE nbad=s(2)
	ENDELSE
	GOTO, noargerror
argerror:
	PRINT,'zero_detectors: Error in argument format'
	GOTO, finished
noargerror:
		
	IF (iprint GT 0) THEN BEGIN
		PRINT,'size(w_in)=',sw
		PRINT,'TOF=',TOF
		PRINT,'nchannels=',nchannels
		PRINT,'nspectra=',nspectra
		PRINT,'nphases=',nphases
		PRINT,'nruns=',nruns
		PRINT,'nbad=',nbad
		IF (nbad NE 0) THEN PRINT,'bad=',bad
	ENDIF

	IF (range EQ 0) THEN PRINT,'Zero_detectors: zeroing detectors',bad $
	ELSE BEGIN
		phimin=bad(0,*)	& phimax=bad(1,*)
		FOR i=0,nbad-1 DO PRINT, $
			FORMAT='("Zero_detectors: zeroing in range",F7.2," < phi <",F7.2," deg")', $
			phimin(i), phimax(i)
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'End of "w_in dimensions check etc." section'

;-------------------------------------------------------------------------------
;Zero bad spectra

	IF (iprint GT 0) THEN PRINT,'range=',range

	IF (TOF EQ 0) THEN BEGIN
		IF (range EQ 0) THEN BEGIN
			IF (iprint GT 0) THEN PRINT,'zeroing spectrum',bad
			IF (nspectra EQ 32) THEN BEGIN
				w_out(bad/2-1,*,*)=0.
				e_out(bad/2-1,*,*)=-1.
			ENDIF ELSE BEGIN
				w_out(bad-1,*,*)=0.
				e_out(bad-1,*,*)=-1.
			ENDELSE
		ENDIF ELSE BEGIN
			IF (nruns EQ 1) THEN BEGIN
				FOR i=0,nbad-1 DO BEGIN
					bad=WHERE(x_in GT phimin(i) AND x_in LT phimax(i),n)
					IF (n GE 1) THEN BEGIN
						w_out(bad,*,*)=0.
						e_out(bad,*,*)=-1.
					ENDIF
				ENDFOR
			ENDIF ELSE BEGIN
				FOR irun=0,nruns-1 DO BEGIN
					x=z_in(*,irun)
					FOR i=0,nbad-1 DO BEGIN
						bad=WHERE(x GT phimin(i) AND x LT phimax(i),n)
						IF (n GE 1) THEN BEGIN
							w_out(bad,*,irun)=0.
							e_out(bad,*,irun)=-1.
						ENDIF
					ENDFOR
				ENDFOR
			ENDELSE
		ENDELSE
	ENDIF ELSE BEGIN
		IF (range EQ 0) THEN BEGIN
			FOR i=0,nbad-1 DO BEGIN
				IF (iprint GT 0) THEN PRINT,'zeroing spectrum',bad(i)
				IF (nspectra EQ 32) THEN ispec=bad(i)/2-1
				IF (nspectra EQ 64) THEN ispec=bad(i)-1
				FOR iphase=0,nphases-1 DO BEGIN
					w_out(*,iphase*32+ispec)=0.
					e_out(*,iphase*32+ispec)=-1.
				ENDFOR
			ENDFOR
		ENDIF ELSE BEGIN
			FOR i=0,nbad-1 DO BEGIN
				bad=WHERE(phimin(i) LT x_in AND x_in LT phimax(i),n)
				IF (n GE 1) THEN BEGIN
					w_out(*,bad)=0.
					e_out(*,bad)=-1.
				ENDIF
			ENDFOR
		ENDELSE
	ENDELSE

	IF (iprint GT 0) THEN PRINT,'End of "Zero bad spectra" section'

;-------------------------------------------------------------------------------
;Return parameters and exit


finished:

	IF (TOF EQ 0 AND nphases EQ 1) THEN BEGIN
		w_out=reform(w_out,nspectra,nruns)
		e_out=reform(e_out,nspectra,nruns)
	ENDIF

	IF (nothing EQ 1) THEN s='0' $
	ELSE IF (range EQ 0) THEN BEGIN
		s=STRTRIM(STRING(bad(0)),2)
		IF (nbad GT 1) THEN FOR i=1,nbad-1 DO s=s+','+STRTRIM(STRING(bad(i)),2)
	ENDIF ELSE BEGIN
		s1=STRTRIM(STRING(phimin(0)),2)	& s2=STRTRIM(STRING(phimax(0)),2)
		n=STRPOS(s1,'.')>0+3	& s1=STRMID(s1,0,n)
		n=STRPOS(s2,'.')>0+3	& s2=STRMID(s2,0,n)
		s=s1+'>'+s2
		IF (nbad GT 1) THEN FOR i=1,nbad-1 DO BEGIN
			s1=STRTRIM(STRING(phimin(i)),2)	& s2=STRTRIM(STRING(phimax(i)),2)
			n=STRPOS(s1,'.')>0+3	& s1=STRMID(s1,0,n)
			n=STRPOS(s2,'.')>0+3	& s2=STRMID(s2,0,n)
			s=s+','+s1+'>'+s2
		ENDFOR
	ENDELSE
			
	datp.other_tit=datp.other_tit+' -zd('+s+')'

	IF (iprint GT 0) THEN PRINT,'End zero_detectors:'

	datp.e=e_out

	give_datp, datp

	IF (iprint GT 0) THEN BEGIN
		PRINT,' irun    ispec     phi     w_in(ispec,0,irun)  w_out(ispec,0,irun)'
		FOR irun=0,nruns-1 DO BEGIN
			FOR ispec=0,nspectra-1 DO $
				PRINT, irun, ispec, z_in(ispec,irun), w_in(ispec,0,irun), w_out(ispec,0,irun)
		ENDFOR
	ENDIF

	RETURN, w_out
	END

pro Show_Version, wid, version, bil
;** ************
;**
@lamp.cbk
	version='07 Aug 2003 for idl 3.6.1 -> 5.6'

	if wid gt 0 then begin
	 bil=widget_base (wid,/row)
	 bid	=widget_label (bil  ,value='Version '+version            ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab1'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab2'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab3'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab4'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab5'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab6'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab7'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab8'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab9'   ,font=ft_smaller)
	endif
end

;*			******************
;*			**              **
			  PRO LAMP_,just
;*			**              **
;*			******************


;**		LARGE ARRAY MANIPULATION PROGRAM
;**		----- ----- ------------ -------

;**	This module manages the LAMP application.
;**	It is written at ILL Grenoble (France ill.fr) by M. Ferrand  for data integrity
;**							 G. Kearley  for users  integrity
;**							 D. Richard  for project  integrity
;**							 B. Vettier  for excellent functions
;**							 R. Jouffrey for wonderfull superplot

;**	The LAMP package is distributed as "Shareware". If you find this application
;**	useful, you may register your copy simply by sending an electronic mail
;**	message to lamp@ill.fr. We would gratefully appreciate any feedback on the
;**	LAMP application.

;** Is LAMP already managed ...
;** -- ---- ------- -------
@lamp.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

  if n_elements(just)    le 0 then just=''
  if (!D.name eq 'TEK') and (just ne 'just')              then LAMP_B
  if n_elements(lamp_focus) eq 1 then if lamp_focus eq -1 then LAMP_B

  if n_elements(lamp_b1) gt 0 then ii=xregistered('LAMP') else ii=0
  if ii eq 0 then                  ii=xregistered('TOUCH')
  if ii eq 0 then                  ii=xregistered('TRIPX')
  if ii gt 0 then if just ne 'just' then ii=widget_info(lamp_b1,/realize)
  if ii gt 0 then begin if sys_dep('VERSION') le 5.0 then XMANAGER
  endif else begin

;***************************************
	if !D.name ne 'TEK' then ii=sys_dep('PSEUDO')
;***************************************
	!quiet=1
	p_screen
        if n_elements(lamp_dir) eq 0 then lamp_dir=sys_dep('GETENV','LAMP_DIR')

;** Workspaces
;** ----------
;** Wi	    = input data and manipulated data
;** wtb(i)  = 0 each time the contents of Wi is modified and set to 1 on display
;** wintb(i)= used by Scan

    w1 =0 & w2 =0 & w3 =0 & w4 =0 & w5 =0 & w6 =0 & w7 =0 & w8 =0 & w9 =0 & w10=0
    w11=0 & w12=0 & w13=0 & w14=0 & w15=0 & w16=0 & w17=0 & w18=0 & w19=0 & w20=0
    w21=0 & w22=0 & w23=0 & w24=0 & w25=0 & w26=0 & w27=0 & w28=0 & w29=0 & w30=0
    w31=0 & w32=0 & w33=0 & w34=0 & w35=0 & w36=0 & w37=0 & w38=0 & w39=0 & w40=0
    w41=0 & w42=0 & w43=0
    w_in =0 & w_out=0 & w_buf=0

    lamp_sys=40 ;Number of workspaces for the user. (check didline,gfit,inx,bens,touch_b,tripx for the future)
    wn      =lamp_sys+3+1

    wtb  =bytarr(wn) & wtb  (*)= 0
    wintb=intarr(wn) & wintb(*)=-1

    w_min  =fltarr(wn)
    w_max  =fltarr(wn)
    w_numor=strarr(wn) & w_numor(0)='lamp.ps'

;** Titles
;** ------
    x_tit    =strarr(wn)
    y_tit    =strarr(wn)
    z_tit    =strarr(wn)
    w_tit    =strarr(wn)
    other_tit=strarr(wn)
    head_tit =strarr(wn,10)

;** Pi	   = set of scalars used in interactive commands (data parameters)
;** --
    p0 =0 & p1 =0 & p2 =0 & p3 =0 & p4 =0 & p5 =0 & p6 =0 & p7 =0 & p8 =0 & p9 =0 & p10=0
    p11=0 & p12=0 & p13=0 & p14=0 & p15=0 & p16=0 & p17=0 & p18=0 & p19=0 & p20=0
    p21=0 & p22=0 & p23=0 & p24=0 & p25=0 & p26=0 & p27=0 & p28=0 & p29=0 & p30=0
    p31=0 & p32=0 & p33=0 & p34=0 & p35=0 & p36=0 & p37=0 & p38=0 & p39=0 & p40=0
    p41=0 & p42=0 & p43=0
    p_in =0 & p_out=0 & p_buf=0

    pv0 =0 & pv1 =0 & pv2 =0 & pv3 =0 & pv4 =0 & pv5 =0 & pv6 =0 & pv7 =0 & pv8 =0 & pv9 =0 & pv10=0
    pv11=0 & pv12=0 & pv13=0 & pv14=0 & pv15=0 & pv16=0 & pv17=0 & pv18=0 & pv19=0 & pv20=0
    pv21=0 & pv22=0 & pv23=0 & pv24=0 & pv25=0 & pv26=0 & pv27=0 & pv28=0 & pv29=0 & pv30=0
    pv31=0 & pv32=0 & pv33=0 & pv34=0 & pv35=0 & pv36=0 & pv37=0 & pv38=0 & pv39=0 & pv40=0
    pv41=0 & pv42=0 & pv43=0
    pv_in =0 & pv_out=0 & pv_buf=0

    if  n_elements(npars) eq 0 then npars=40
    par_txt=strarr(wn ,npars)
    par_txt_all=strarr(npars)

;** Motif
;** -----

    p_set_font,0

;   Stuff for data transformations
;** ----- --- ---- ---------------
    x0 =0 & x1 =0 & x2 =0 & x3 =0 & x4 =0 & x5 =0 & x6 =0 & x7 =0 & x8 =0 & x9 =0
    x10=0 & x11=0 & x12=0 & x13=0 & x14=0 & x15=0 & x16=0 & x17=0 & x18=0
    x19=0 & x20=0 & x21=0 & x22=0 & x23=0 & x24=0 & x25=0 & x26=0 & x27=0 & x28=0 & x29=0 & x30=0
    x31=0 & x32=0 & x33=0 & x34=0 & x35=0 & x36=0 & x37=0 & x38=0 & x39=0 & x40=0
    x41=0 & x42=0 & x43=0
    x_in =0 & x_out=0 & x_buf=0

    y0 =0 & y1 =0 & y2 =0 & y3 =0 & y4 =0 & y5 =0 & y6 =0 & y7 =0 & y8 =0 & y9 =0
    y10=0 & y11=0 & y12=0 & y13=0 & y14=0 & y15=0 & y16=0 & y17=0 & y18=0
    y19=0 & y20=0 & y21=0 & y22=0 & y23=0 & y24=0 & y25=0 & y26=0 & y27=0 & y28=0 & y29=0 & y30=0
    y31=0 & y32=0 & y33=0 & y34=0 & y35=0 & y36=0 & y37=0 & y38=0 & y39=0 & y40=0
    y41=0 & y42=0 & y43=0
    y_in =0 & y_out=0 & y_buf=0

    z0 =0 & z1 =0 & z2 =0 & z3 =0 & z4 =0 & z5 =0 & z6 =0 & z7 =0 & z8 =0 & z9 =0
    z10=0 & z11=0 & z12=0 & z13=0 & z14=0 & z15=0 & z16=0 & z17=0 & z18=0
    z19=0 & z20=0 & z21=0 & z22=0 & z23=0 & z24=0 & z25=0 & z26=0 & z27=0 & z28=0 & z29=0 & z30=0
    z31=0 & z32=0 & z33=0 & z34=0 & z35=0 & z36=0 & z37=0 & z38=0 & z39=0 & z40=0
    z41=0 & z42=0 & z43=0
    z_in =0 & z_out=0 & z_buf=0

    e0 =0 & e1 =0 & e2 =0 & e3 =0 & e4 =0 & e5 =0 & e6 =0 & e7 =0 & e8 =0 & e9 =0
    e10=0 & e11=0 & e12=0 & e13=0 & e14=0 & e15=0 & e16=0 & e17=0 & e18=0
    e19=0 & e20=0 & e21=0 & e22=0 & e23=0 & e24=0 & e25=0 & e26=0 & e27=0 & e28=0 & e29=0 & e30=0
    e31=0 & e32=0 & e33=0 & e34=0 & e35=0 & e36=0 & e37=0 & e38=0 & e39=0 & e40=0
    e41=0 & e42=0 & e43=0
    e_in =0 & e_out=0 & e_buf=0

    n0 =0 & n1 =0 & n2 =0 & n3 =0 & n4 =0 & n5 =0 & n6 =0 & n7 =0 & n8 =0 & n9 =0
    n10=0 & n11=0 & n12=0 & n13=0 & n14=0 & n15=0 & n16=0 & n17=0 & n18=0
    n19=0 & n20=0 & n21=0 & n22=0 & n23=0 & n24=0 & n25=0 & n26=0 & n27=0 & n28=0 & n29=0 & n30=0
    n31=0 & n32=0 & n33=0 & n34=0 & n35=0 & n36=0 & n37=0 & n38=0 & n39=0 & n40=0
    n41=0 & n42=0 & n43=0
    n_in =0 & n_out=0 & n_buf=0

    par1 =0 & par2 =0 & par3 =0 & par4 =0 & par5 =0 & par6 =0 & par7 =0 & par8 =0
    par9 =0 & par10=0 & par11=0 & par12=0 & par13=0 & par14=0 & par15=0 & par16=0
    par17=0 & par18=0 & par19=0 & par20=0 & par21=0 & par22=0 & par23=0 & par24=0
    par25=0 & par26=0 & par27=0 & par28=0 & par29=0 & par30=0 & par31=0 & par32=0
    par33=0 & par34=0 & par35=0 & par36=0 & par37=0 & par38=0 & par39=0 & par40=0
    par41=0 & par42=0 & par43=0

    Sna0 =0 & Sna1 =0 & Sna2 =0 & Sna3 =0 & Sna4 =0 & Sna5 =0 & Sna6 =0 & Sna7 =0 & Sna8 =0
    Sna9 =0 & Sna10=0 & Sna11=0 & Sna12=0 & Sna13=0 & Sna14=0 & Sna15=0 & Sna16=0 & Sna17=0
    Sna18=0 & Sna19=0 & Sna20=0 & Sna21=0 & Sna22=0 & Sna23=0 & Sna24=0 & Sna25=0 & Sna26=0
    Sna27=0 & Sna28=0 & Sna29=0 & Sna30=0 & Sna31=0 & Sna32=0 & Sna33=0 & Sna34=0 & Sna35=0
    Sna36=0 & Sna37=0 & Sna38=0 & Sna39=0 & Sna40=0

;   Stuff for DIALS
;** ----- --- -----
    d0 =0 & d1 =0 & d2 =0 & d3 =0 & d4 =0 & d5 =0 & d6 =0 & d7 =0 & d8 =0 & d9 =0
    d10=0 & d11=0 & d12=0 & d13=0 & d14=0 & d15=0 & d16=0 & d17=0 & d18=0
    d19=0 & d20=0 & d21=0 & d22=0 & d23=0
    dial_ini=0
    duduch1 =0
    duduch2 =0
    duduch3 =''
    proxcod =''
    if  n_elements(GEORGE) eq 0 then GEORGE=0

;   W info's
;** --------
    lamp_devps=''
    lamp_dvd  =sys_dep      ('DIVIDER')
    ihis      =0
    his_info  =0
    his       =strarr(wn+1) & his (*) =' ' & his (wn)='.'
    lims      =strarr(wn+1) & lims(*) =' ' & lims(wn)='.'
    histxt    =strarr(1)
    limtxt    =strarr(1)
    tolerance =0. & toler=0. & monimon=-1
    inst_value='    '
    inst_group=''
    cycle     ='  ????  '
    one=1 & two=0 & three=0 & alone=0

    if (just ne 'just') then begin

;** User Directory
;** ---- ---------
@dons.cbk
      basem=widget_base (title='Lamp',/column,resource_name='lamp')
      bidon=widget_label(basem,value='LARGE ARRAY MANIPULATION PROGRAM',font=ft_biggest)
      Show_Version,basem
      w0=2
      LOGO,w0 & pax1=size(w0)
      bidon=widget_base (basem,/row)
      bicon=widget_draw (bidon,retain=2,xsize=pax1(1),ysize=pax1(2)    ,colors=-30)
      bidon=widget_label(basem,value='                               ' ,font=ft_normal)
      basm1=widget_base (basem,       /column)
      basm2=widget_base (basem,       /column)
      basm3=widget_label(basem,value='______________________________________' ,font=ft_biggest)
      bid=sys_dep      ('DYNLAB',basem,1)
      widget_control,bad_id=ii  ,basem,/realize
      widget_control,bad_id=ii  ,bicon,get_value=pax4 & wset,pax4
      tvscl,w0,0,0 & pax2=0   &  pax3=pax1(1)

      lamp_user =''  & lamp_user =STRLOWCASE(sys_dep ('GETENV','USER'))
           host =''  &      host =STRLOWCASE(sys_dep ('GETENV','HOST'))
      cd,current=mee & sl=strlen(host)+1
      path='lambda'  & sp=strlen(path)+1
;           ******
      if (lamp_user eq path) or (rstrpos(mee,path) ge strlen(mee)-sp) or ((rstrpos(mee,host) ge (strlen(mee)-sl)>0 ) and (sl gt 2)) then begin
	mess=widget_label (basm1,value='Your name is the way to define your own directory',font=ft_bigger)
	namm=widget_text  (basm1,xsize=15,ysize=1,font=ft_biggest,/editable)
	rbut=widget_base  (basm1,/frame,/row)
	if sys_dep('MAP') ne -1 then $
	okbt=widget_button(rbut,value='OK',font=ft_bigger,resource_name='discret') else $
	okbt=widget_button(rbut,value='OK',font=ft_bigger)
 	print,string(7b)
	name='' & ii=0
	while (name eq '') and (ii eq 0) do begin
		widget_control,bad_id=ii,namm,/input_focus
		even=widget_event (basm1,bad_id=ii)
	        widget_control,bad_id=ii,namm,get_value=name
	        name=strupcase(strcompress(name(0),/remove_all))
	endwhile
	widget_control,bad_id=ii,basm1,sensitive=0
	if (name ne '') and (ii eq 0) then begin
		pwd=sys_dep      ('NEWDIR',lamp_user,name)
	   	stat=0 & ii=0
	   	catch,stat
	   	if (stat ne 0) and (ii eq 0) then begin
	   			  ii=1
	   			  bid=sys_dep      ('MKDIR',pwd)
	   			  catch,stat & if stat eq 0 then cd,pwd
	   	endif
	   	if stat eq 0 then cd,pwd & catch,/cancel
	endif
;	device,copy=[pax2,0,pax1(1),pax1(2),pax2+pax3,0,pax4] & pax2=pax2+pax3
      endif

;** Restore last session
;** ------- ---- -------
      fil=findfile('lamp.ses',count=true)
      if (true lt 1) then fil=findfile('lamp.ses.Z',count=true) else true=100
      if (true gt 0) and (ii eq 0) then begin
	mess =widget_label (basm2,value='Previous Session lamp.ses exists !!',font=ft_biggest)
	but  =widget_base  (basm2,/row)
	r_rm =widget_button(but ,value='Restore & Remove',font=ft_b_normal)
	r_kp =widget_button(but ,value='Restore & Keep'  ,font=ft_b_normal)
	rm   =widget_button(but ,value='Remove'          ,font=ft_b_normal)
	ign  =widget_button(but ,value='Ignore'          ,font=ft_b_normal)
 	print,string(7b)
        bid=sys_dep      ('DYNLAB',basm2,0)
	widget_control,bad_id=ii  ,basm2,/realize
	even=widget_event (basm2  ,bad_id=ok)
	widget_control,bad_id=ii  ,basm2,sensitive=0
	if ok eq 0 then begin
		if (even.id eq r_rm) or (even.id eq r_kp) then begin
        		widget_control,bad_id=ii,basm3,set_value='RESTORING lamp.ses ...'
			if true ne 100 then bid=sys_dep      ('UN_Z','lamp.ses.Z',lamp_dir)
						kpGEORGE=GEORGE
			catch,stat
	   		if stat eq 0 then begin RESTORE, 'lamp.ses'  &  GEORGE=kpGEORGE
						AFTER_RESTORE
			endif else print,"Bad version for file lamp.ses !!!" & catch,/cancel
    		endif
		if (even.id eq r_rm) or (even.id eq rm)   then $
	   		bid=sys_dep      ('DELET','lamp.ses')
	endif
;	device,copy=[pax2,0,pax1(1),pax1(2),pax2+pax3,0,pax4] & pax2=pax2+pax3
      endif else begin
		w1=shift(sin (dist(64)/15),-12,-12)*30    & w_tit(1)='w1=shift(sin (dist(64)/15),-12,-12)*30'
		x1=long (alog(findgen(64)+1.)*20) & y1=x1 & x_tit(1)='x1=long (alog(findgen(64)+1.)*20)'
		y_tit(1)='Y axis' & z_tit(1)='Counts' & other_tit(1)='Just an example'
      endelse

      if (lamp_siz ge 800) and (sys_dep('MACHINE') eq 'win' or $
				sys_dep('MACHINE') eq 'mac') then $
			SL_RESTSCAN,lamp_dir+lamp_dvd+'scan.exe' ,cnt
    endif

;** Developers
;** ----------
    lamp_b1    =0L
    lamp_act   =0
    lamp_focus =0
    lamp_entry =['',' ']
    l_message  =0L
    b_labins   =lonarr(9) & b_labins(*)=0
    jou_c      =['*******','SESSION','*******'] & jou_w=[' ',!stime,' ']
    last_form  =''
    path       =''
    my_path    =[path,'','',!D.NAME]

;** Data base directories
;** --------- -----------
    P_ENVI

;** Base Constitution
;** ---- ------------
    if (just ne 'just') then $
        widget_control,bad_id=ii,basm3,set_value='CREATING manipulation display TOOLS'

    if (just eq '') or (just eq 'lamp') then begin
	mbar=0L
	if sys_dep('VERSION') lt 4.0 then mkbar=0 else mkbar=1 ;& mkbar=0 ;;;for tests
	tit='LAMP '
	mmp =1
	if lamp_siz ge 600  then  if mkbar     then  mmp=0
	if sys_dep('MACHINE') eq 'mac'         then  mmp=1
	if sys_dep('MATLAB')  or (GEORGE eq 0) then  mmp=1
	if GEORGE eq 3 then begin GEORGE=2       &   mmp=1 & endif
	if GEORGE eq 1 then begin tit='GEORGE '  &   mmp=1 & endif

	if GEORGE eq 2 then tit='LAMP'
	tit      =tit+' ftp.ill.fr/pub/cs/lamp... (email:lamp@ill.fr)'
	tit      =tit+'     powered by Idl'
	if sys_dep('EMBEDDED') then tit=tit+' from Research Systems(www.rsinc.com)'
	if lamp_siz lt 600 then $
	 if not mkbar then $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column,$
				 x_scroll=590,y_scroll=lamp_siz-50) else $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column,$
				 x_scroll=590,y_scroll=lamp_siz-50,MBAR=mbar,rname_mbar='lampben')
	if lamp_siz ge 600 then $
	 if not mkbar then $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column) else $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column,MBAR=mbar,rname_mbar='lampben')

	lamp_tmp1=widget_base  (lamp_b1  ,/row)
;don
	lamp_don   =lonarr(5)
	lamp_don(0)=widget_base (lamp_b1  ,/frame,resource_name='don',map=mmp)

	lamp_tmp2  =widget_base (lamp_tmp1,/column)

;ben
	lamp_ben   =lonarr(17)
	if GEORGE eq 2 then begin lamp_ben(0) =widget_base (lamp_tmp1   ,map=mmp)
				  lamp_ben(7) =widget_base (lamp_ben(0) ,/column,map=1)   & bas_ben=lamp_ben(7)
				  lamp_ben(8) =widget_base (lamp_ben(0) ,/column,map=0)   & endif

	if GEORGE ne 2 then begin lamp_ben(0) =widget_base (lamp_tmp1   ,map=mmp)
				  bas_ben     =widget_base (lamp_ben(0) ,/column)
				  lamp_ben(7) =bas_ben   &  lamp_ben(8) =bas_ben          & endif

	if mbar   gt 0 then begin
				  lamp_ben(10)=widget_base (lamp_ben(0) ,/column,map=0)
				  lamp_ben(11)=widget_base (lamp_ben(10),/column,/frame,resource_name='ben')
				  mllab       =widget_label(lamp_ben(11),value='..MACROS LIST..',font=ft_propor)
				  endif
	ben_f=1
	if GEORGE ne 1  then begin
	  lamp_ben(2)=widget_base  (bas_ben ,/frame,resource_name='ben')
	  lamp_ben(1)=widget_base  (bas_ben)
	  ben_f=0
	endif
	if GEORGE ne 0  then begin
	  if lamp_siz ge 900 then lab='..Other functions..' else lab='....Other functions....'
	  if sys_dep('MACHINE')   eq  'mac'                 then lab='..Functions..'
	  if GEORGE eq 1 then bas_geo2   =widget_button(lamp_ben(8),value=lab,font=ft_b_normal,menu=2)
	  if GEORGE eq 1 then lamp_ben(2)=bas_geo2
	endif else bas_geo2=0
;micmac
	lamp_mac =widget_base (lamp_tmp2,/frame,resource_name='mic')
	lamp_ben(9)=lamp_mac
;did
	lamp_did   =lonarr(10)
	if  lamp_siz ge 900 then $
	sepdid	   =widget_draw (lamp_tmp2,xsize=600,ysize=4) else sepdid=0
	lamp_did(0)=widget_base (lamp_tmp2,/frame,resource_name='did')

	lamp_don(2)=lamp_ben(2)
	lamp_don(3)=lamp_did(0)

	if  lamp_siz ge 900 then $
	sepdon	   =widget_draw (lamp_tmp2,xsize=600,ysize=4) else sepdon=0

	widget_control,bad_id=ii,lamp_b1,default_font=ft_normal

;** Run  Selector Unit Creation
;** ---- -------- ---- --------
	if lamp_asite eq 'mic' then MIC,1

;** Workspace Manipulation Unit Creation
;** --------- ------------ ---- --------
	P_DON_CREATE ,(lamp_don(0))

;** File Selector Unit Creation
;** ---- -------- ---- --------
	P_MAC_CREATE ,(lamp_mac+0) ,mbar ,wread ,b33 ,b1,cque

;** Main Display Unit Creation
;** ---- ------- ---- --------
	P_DID_CREATE ,(lamp_did(0))

;** Specific Display Unit Creation
;** -------- ------- ---- --------
	P_BEN_CREATE ,(lamp_ben(2)),ben_f

;** General Functions Unit Creation
;** ------- --------- ---- --------
	P_FCT_CREATE ,(bas_ben), bas_geo2

;** Menu-bar Creation
;** -------- --------
	lamp_ben(15)=wread(0)
	lamp_ben(16)=wread(1)

	IF mbar gt 0 then begin	IF b33 gt 0 then widget_control,bad_id=i,b33, get_uvalue=uvbuti
	if n_elements(uvbuti) eq 0 then uvbuti=0
	Show_version,0,lamp_version
	Mfile	=widget_button(mbar,font=ft_propor,/menu,value='File')
	Mcustom	=widget_button(mbar,font=ft_propor,/menu,value='Customize')
	Medit	=widget_button(mbar,font=ft_propor,/menu,value='Edit')
	Minfo	=widget_button(mbar,font=ft_propor,/menu,value='Info')
	Mtool	=widget_button(mbar,font=ft_propor,/menu,value='Tools')
	Mwind	=widget_button(mbar,font=ft_propor,/menu,value='Lamp/Layout')
	Mhelp	=widget_button(mbar,font=ft_propor,/menu,value='Help')

	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='EXPORT workspace'               ,uvalue=[-88,370,0,0,0,0])
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='IMPORT file & workspace'        ,uvalue=[-88,380,0,0,0,0])
	Mfiler	=widget_button(Mfile	,font=ft_b_normal,value='Multiple READ (Selector access)',uvalue=uvbuti)
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='BROWSE selected instrument path',uvalue=[-88,562,0,wread(0),wread(1),-2,-2,0])
	Mfilec	=widget_button(Mfile	,font=ft_b_normal,value='Instrument CALIBRATION files'   ,uvalue=[-88,307,11])
	Mfilet	=widget_button(Mfile	,font=ft_b_normal,value='CATALOG of data runs'           ,uvalue=[-88,331,0])
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfilem	=widget_button(Mfile	,font=ft_b_normal,value='MAKE a User MACRO'              ,uvalue=[-88,203,0,0])
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='Save all'                       ,uvalue=[-88,397,0])
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='Save and exit'                  ,uvalue=[-88,307,12])
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='Exit'                           ,uvalue=[-88,398,0])

	Mcustom1=widget_button(Mcustom	,font=ft_b_normal,value='COLORS table'                   ,uvalue=[-88,347,0])
	Mcustom1=widget_button(Mcustom	,font=ft_b_normal,value='PLOTTING preferences'           ,uvalue=[-88,360,0])
	Mcustom1=widget_button(Mcustom	,font=ft_b_normal,value='Default PRINTER (Unix)'         ,uvalue=[-88,360,0])
	Mcustom1=widget_button(Mcustom	,value='--------')     & widget_control,Mcustom1,sensitive=0
	Mcustomf=widget_button(Mcustom	,font=ft_b_normal,value='Update data FORMAT TABLE (instruments)'   ,uvalue=[-88,560,0,0,0,-1])
	Mcustomp=widget_button(Mcustom	,font=ft_b_normal,value='Update PATH for instruments data base'    ,uvalue=[-88,560,0,0,0,-1])
	Mcustomr=widget_button(Mcustom	,font=ft_b_normal,value='Template for READ IN procedures: read_tmp',uvalue=[-88,560,0,0,0,-1])
	Mcustomm=widget_button(Mcustom	,font=ft_b_normal,value='User macros LOCATION'           ,uvalue=[-88,560,0,0,0,-1])
	Mcustom1=widget_button(Mcustom	,value='--------')     & widget_control,Mcustom1,sensitive=0
	Mcustoms=widget_button(Mcustom	,font=ft_b_normal,value='How to implement "INSTRUMENT MACROS" layout',uvalue=[-88,596,0,0])

	Medit1	=widget_button(Medit	,font=ft_b_normal,value='COLORS table'                   ,uvalue=[-88,347,0])
	Medit1	=widget_button(Medit	,font=ft_b_normal,value='DATA PARAMETERS values'         ,uvalue=[-88,204,0,0])
	Meditc	=widget_button(Medit	,font=ft_b_normal,value='Instrument CALIBRATION'         ,uvalue=[-88,307,11])
	Medit1	=widget_button(Medit	,font=ft_b_normal,value='User batch files , MACROS'      ,uvalue=[-88,203,0,0])
	Medit1	=widget_button(Medit	,value='--------')     & widget_control,Medit1,sensitive=0
	Meditw1	=widget_button(Medit	,font=ft_b_normal,value='STORE  20 workspaces in   secondary memory' ,uvalue=[-88,572,0,1])
	Meditw2	=widget_button(Medit	,font=ft_b_normal,value='RESTORE   workspaces from secondary memory' ,uvalue=[-88,572,0,2])
	Meditw3	=widget_button(Medit	,font=ft_b_normal,value='EXCHANGE  workspaces with secondary memory' ,uvalue=[-88,572,0,3])
	Meditw4	=widget_button(Medit	,font=ft_b_normal,value='CLEAR all workspaces and  memories'         ,uvalue=[-88,572,0,4])

	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='JOURNAL of current session'     ,uvalue=[-88,396,0,0])
	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='DATA PARAMETERS'                ,uvalue=[-88,204,0,0])
	Minfo1	=widget_button(Minfo	,value='--------')     & widget_control,Minfo1,sensitive=0
	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='Internal ROUTINES (lamp)'       ,uvalue=[-88,203,0,1])
	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='Available User BATCH files'     ,uvalue=[-88,203,1,0])
	Minfo1	=widget_button(Minfo	,value='--------')     & widget_control,Minfo1,sensitive=0
	Minfor	=widget_button(Minfo	,font=ft_b_normal,value='Template for READ IN procedures',uvalue=[-88,560,0,0,0,-1])

	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='OVERPLOTTING (superplot)'       ,uvalue=[-88,352])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='SCROLL spectra within 2D,1D workspaces' ,uvalue=[-88,402,0])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='SECTOR integration (small 2D wksp)'  ,uvalue=[-88,401,0])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='RADIAL integration (small 2D wksp)'  ,uvalue=[-88,401,0])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='UNROLLING for integration (large 2D wksp)' ,uvalue=[-88,401,-1])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='TOMOGRAPHY'                          ,uvalue=[-88,401,-2])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='FITTING with GKfit (gauss,lorentz)'  ,uvalue=[-88,580,0,0])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='Qens_fit (gauss+lorentz+delta) for TOF '   ,uvalue=[-88,571,2])
								 widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='Spectra GROUPING for TOF'            ,uvalue=[-88,403,0])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='lampINX for TOF'                     ,uvalue=[-88,571,1])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
;	Mtoolo	=widget_button(Mtool	,font=ft_b_normal,value='CRON tasks (toggle)')
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='Multiple READ (Selector access)'     ,uvalue=uvbuti)
	Mtooln	=widget_button(Mtool	,font=ft_b_normal,value='Glory-Hole (scan)'                   ,uvalue=[-88,306,0,-1])

	Mwindf	=widget_button(Mwind	,font=ft_b_normal,value='Extend to classical Lamp')
	Mwindm	=widget_button(Mwind	,font=ft_b_normal,value='Light  configuration')
	Mwind1	=widget_button(Mwind	,value='--------')     & widget_control,Mwind1,sensitive=0
	Mwindl	=widget_button(Mwind	,font=ft_b_normal,value='LAMP   layout')
	Mwindg	=widget_button(Mwind	,font=ft_b_normal,value='GEORGE layout (dials)')
	Mwind1	=widget_button(Mwind	,value='--------')     & widget_control,Mwind1,sensitive=0
	Mwind1	=widget_button(Mwind	,font=ft_b_normal,value='DO input commands (...)'             ,uvalue=[-88,224])
	Mwindx	=widget_button(Mwind	,font=ft_b_normal,value='XBU input commands (...)'            ,uvalue=[-88,226])
	Mwind1	=widget_button(Mwind	,value='--------')     & widget_control,Mwind1,sensitive=0
	Mwinds	=widget_button(Mwind	,font=ft_b_normal,value='Help for INSTRUMENT MACROS',/menu)

	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='MANUAL  lamp/manual/front.html' ,uvalue=[-88,201,0,0])
	Mhelp1	=widget_button(Mhelp	,value='--------')     & widget_control,Minfo1,sensitive=0
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='List  of ROUTINES (Idl)'        ,uvalue=[-88,573,0,0])
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Language HELP (Idl)'            ,uvalue=[-88,573,0,0])
	Mhelp1	=widget_button(Mhelp	,value='--------')     & widget_control,Minfo1,sensitive=0
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Manipulation syntax overview'   ,uvalue=[-88,588,0,0])
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Reading into workspaces'        ,uvalue=[-88,586,0,0])
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Displaying workspaces'          ,uvalue=[-88,587,0,0])
	Mhelp1	=widget_button(Mhelp	,value='--------')     & widget_control,Minfo1,sensitive=0
	Mhelpc	=widget_button(Mhelp	,value='About Lamp',/menu)
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Start Lamp project: Apr 1994')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='This update: '+lamp_version)
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Kernel Design:')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Didier   Richard   (ILL scientific computing engineer)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Don      Kearley   (ILL scientist -->1999 DELFT)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Michel   Ferrand   (ILL scientist -->1998 CEA)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Scientific macros support:')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Ken      Andersen  (ISIS scientist -->2002 ILL)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Bob      Cubitt    (ILL  scientist    LSS)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Thomas   Hansen    (ILL  scientist    DIF)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Stephane Rols      (ANL  scientist -->2002 Montpellier Univ.)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        J.Ross   Stewart   (ILL  scientist    TOF)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Complementary development:')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Arne     Dallmeyer (Thesis   in 1994)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Benjamin Vettier   (Grenoble university in 1994)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Romuald  Jouffrey  (Grenoble university in 1995,96)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Philippe Cuerq     (Grenoble university in 1996)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Mail: lamp@ill.fr')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='http://www.ill.fr/data_treat/lamp/front.html (The Lamp Book)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='http://www.ill.fr/YellowBook/D7/home/D7_george_book (George on D7)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='http://barns.ill.fr         (The applications web server)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ftp://ftp.ill.fr/pub/cs    (Take-away sources & runtimes)')
	lamp_ben(12)=Mwindl
	lamp_ben(13)=Mwindg
	lamp_ben(14)=Mwindm
	if mmp                 then widget_control,Mwindf  ,sensitive=0
	if lamp_siz lt 600     then widget_control,Mwindf  ,sensitive=0
	if lamp_siz lt 600     then widget_control,Mwindm  ,sensitive=0
	if lamp_siz lt 800     then widget_control,Mtooln  ,sensitive=0
	if (sys_dep('EMBEDDED')  or sys_dep('RUNTIME')) then runt=1 else runt=0
	if runt                then widget_control,Mfilem  ,sensitive=0
	if runt                then widget_control,Mcustomr,sensitive=0
	if runt                then widget_control,Mcustomm,sensitive=0
	if runt                then widget_control,Minfor  ,sensitive=0
	if cque     eq 0       then widget_control,Mwindg  ,sensitive=0
	if cque     eq 0       then widget_control,Mwindl  ,sensitive=0
	if GEORGE   eq 2       then widget_control,Mwindl  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mwindg  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mfiler  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustomf,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustomp,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustoms,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustomr,sensitive=0
	if GEORGE   eq 1       then widget_control,Minfor  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mwinds  ,sensitive=0
	if GEORGE   eq 0       then widget_control,Mwindx  ,sensitive=0

	P_LAMBDA,pathmac
	pathcal =sys_dep('INSUB',pathmac,'CALIBRATION') & calfile =findfile(pathcal+'*',count=cnt)
	if cnt      eq 0       then widget_control,Mfilec  ,sensitive=0
	if cnt      eq 0       then widget_control,Meditc  ,sensitive=0

	toufile =findfile(lamp_touch+lamp_dvd+'*',count=cnt)
	if cnt      eq 0       then widget_control,Mfilet  ,sensitive=0

	widget_control,Meditw1,set_uvalue=[-88,572,0,1,Meditw2,Meditw3]
	widget_control,Meditw2,sensitive=0
	widget_control,Meditw3,sensitive=0
	empty & sby=0 & sp=0
	if sys_dep('MACHINE') eq 'win' then begin sby=30 & sp=1 & endif

	gml=widget_info(lamp_b1    ,/geometry) & sty=gml.scr_ysize+2*gml.margin + sby
	gmm=widget_info(lamp_don(0),/geometry) & ssy=gmm.scr_ysize+2*gmm.margin & ssy=sty-ssy

	if not mmp then widget_control,lamp_b1,scr_ysize=ssy
	if not mmp then b_labins(6)=1

	fullist=[''] & MAC_LIST,n_em,fullist,maclist,THISFILE='A_List_*.prox'
	widget_control,Mwinds,set_uvalue=fullist
	if fullist(0) gt ' ' then begin
	   idx=sort(maclist) & maclist=maclist(idx) & fullist=fullist(idx)
	   idx=uniq(maclist) & maclist=maclist(idx) & fullist=fullist(idx)
	   for i=0,n_elements(maclist)-1 do $
	       bid =widget_button (Mwinds,font=ft_b_normal,value=maclist(i),uvalue=[-88,570,0,Mwinds,Mwindl,Mwindg,Mwindm,i])
	            widget_control,Mwinds,set_uvalue=fullist
		    lamp_did(6:9)=[Mwinds,Mwindl,Mwindg,Mwindm]
	endif else  widget_control,Mwinds,sensitive =0
	endif
;** Event Loop
;** ----- ----

	P_MUS,''
	widget_control,bad_id=ii,basem	,/destroy
	P_MUS,'mus_shot'

	bid=sys_dep      ('DYNLAB',lamp_b1,1)
	widget_control,bad_id=ii  ,lamp_b1 ,/realize

	IF mbar gt 0 then begin
	   gml=widget_info(lamp_b1    ,/geometry) & stx=gml.scr_xsize+2*gml.margin
	   gmd=widget_info(lamp_ben(0),/geometry) & ssx=gmd.scr_xsize+2*gmd.margin & ssx=stx-ssx
	   widget_control,lamp_ben(10),set_uvalue=[-99,0L,mllab,stx]
	   widget_control,Mwindm      ,set_uvalue=[-88,307,62,ssx,ssy,stx,sty,Mwindf,Mwindm]
	   widget_control,Mwindf      ,set_uvalue=[-88,307,61,ssx,ssy,stx,sty,Mwindf,Mwindm]

	   widget_control,Mwindl,set_uvalue=[-88,557,0,b1,cque,-1,Mwindl,Mwindg,Mwindm,ssx,stx]
	   widget_control,Mwindg,set_uvalue=[-88,557,0,b1,cque, 1,Mwindl,Mwindg,Mwindm,ssx,stx]
;	   widget_control,Mtoolo,set_uvalue=[-88,557,0,b1,cque, 1,Mwindl,Mwindg,Mwindm,ssx,stx]
	endif
	if not mmp then begin	 widget_control,bad_id=ii,lamp_b1,scr_xsize=ssx
				 widget_control,bad_id=ii,Mwindm     ,sensitive=0
				 endif

	P_AFTER_REALIZE_DID,sepben,sepdon,sepdid

	if GEORGE ne 0 then GEORGEO,  /init $
	else if (lamp_siz lt 800) then put_logo, /TIO

	if sys_dep('VERSION') lt 5.0 then XMANAGER, 'LAMP' ,lamp_b1  ,event_handler='LAMP_EVENT_PARSER',CLEANUP='P_DYING' $
      	else begin XMANAGER, 'LAMP' ,lamp_b1  ,event_handler='LAMP_EVENT_PARSER',CLEANUP='P_DYING',/just_reg
	     if not runt then widget_control, lamp_b1, set_uvalue=[-85,700,1], TIMER=1.
	     ii=execute('XMANAGER,/NO_BLOCK')
	endelse
    endif else begin
    	if lamp_asite eq 'mic'   then MIC,1
	if just       eq 'touch' then begin
	   TOUCH_B,1,'','+'
	   P_MUS,'' & widget_control,bad_id=ii,basem,/destroy & XMANAGER
	   if lamp_b1 eq -100  then  LAMP
	endif else $
	if just       eq 'tripx' then begin
	   ii=execute('TRIPX, /three_axis')
	   P_MUS,'' & widget_control,bad_id=ii,basem,/destroy & XMANAGER
	   if lamp_b1 eq -100  then  LAMP
	endif
    endelse

  endelse
; -------
; if just ne 'just'  then bid=sys_dep      ('EXIT')
end

pro P_LAYOUT, flag ,prox=fiprox
;** ********
;**
@lamp.cbk
ev=0
ii=execute("ev={WIDGET_BUTTON,id:0L,top:lamp_b1,handler:0L,select:1}") ;PB IDL36 IDL4

if n_elements(flag) eq 1 then case strlowcase(flag) of
  'george': begin ev.id=lamp_ben(13)          & end
  'lamp':   begin ev.id=lamp_ben(12)          & end
  'light':  begin ev.id=lamp_ben(14)          & end
  'full':   begin widget_control,bad_id=ii,lamp_ben(14),get_uvalue=uv
		  if ii eq 0 then ev.id=uv(7) & end
  'hide':   if lamp_b1  gt 0 then widget_control,bad_id=ii,lamp_b1,iconify=1
  'show':   if lamp_b1  gt 0 then widget_control,bad_id=ii,lamp_b1,iconify=0
   else:    if strpos(strlowcase(flag),'list_') ge 0 then begin
	     if lamp_did(6) gt 0 then begin widget_control,lamp_did(6),get_uvalue=fullist
   	      if fullist(0) gt ' ' then begin
		  pos=strpos(strlowcase(fullist),strlowcase(flag)) & idx=where(pos ge 0) & idx=idx(0)
		  if idx ge 0 then P_MAC_EVENT,ev,[-88,570,0,lamp_did(6:9),idx]
   	      endif
   	     endif
   	    endif
endcase
if ev.id gt 0 then LAMP_EVENT_PARSER, ev

if n_elements(fiprox) gt 0 then don_do_cmd, prox=fiprox
end

pro AFTER_RESTORE
;** *************
;**
@lamp.cbk
    	lamp_sys  = n_elements(w_min)-3-1
	lamp_b1   = 0L & p_screen	& p_set_font, 0
	lamp_act  = 0L & lamp_focus =0	& l_message  =0L
	b_labins  = lonarr(9)		& b_labins(*)=0L

	jou_c     =['*******','SESSION','*******'] & jou_w=[' ',!stime,' ']
	last_form =''
	path      ='' & my_path   =[path,'','',!D.NAME]
end

pro P_ENVI ,cust
;** ******
;**
;** Track environments and custome variables.
@lamp.cbk
    p_screen

    lamp_user ='' & lamp_user =STRLOWCASE(sys_dep      ('GETENV','USER'))
    lamp_dir  ='' & lamp_dir  =sys_dep      ('GETENV','LAMP_DIR' ) & lamp_dir=strtrim(lamp_dir,2)
    lamp_exec ='' & lamp_exec =sys_dep      ('GETENV','LAMP_EXEC')
    lamp_host ='' & lamp_host =sys_dep      ('GETENV','HOST')
    		 if lamp_host eq '' then lamp_host=getenv('SYS$NODE')
    		 if lamp_dir  eq '' then cd,current=lamp_dir
    j=STRPOS (lamp_host, ':') & if j ge 0 then lamp_host=STRMID(lamp_host,0,j)
    lamp_host =STRLOWCASE(lamp_host)

    lamp_dvd  =sys_dep      ('DIVIDER')
    lamp_6    =6
    lamp_proxy=''

    lamp_ins  =['demo']
    lamp_wrti =[' '] & lamp_wrtp =[' ']
    lamp_grp  =[' ']
    lamp_ali  =['Current Path']
    lamp_path =['']
    lamp_asite= 'rdfilter'
    lamp_fsite= ' '

    lamp_proc    =strarr(n_elements(lamp_ins))
    lamp_proc(*) ='rdid'
    lamp_proc(0) ='read_tmp'
    lamp_touch   ='demo/TOUCH_BASE'
    lamp_macro   ='~lambda/macros'

    lamp_data = lamp_path(0)
    lamp_cyc  = [0L,0L]
    cycle     =lamp_ali(lamp_cyc(0))
    path_for_online=lamp_path(lamp_cyc(0))

    nld=strlen(lamp_dir)
    if (lamp_dir ne '')   then begin
     if strmid (lamp_dir,nld-1,1) eq lamp_dvd then lamp_dir=strmid(lamp_dir,0,nld-1)
     bid=sys_dep      ('IDLPATH',lamp_dir,nld)
    endif

    if n_elements(cust) eq 0 then P_NEWCUST

;   if sys_dep('MACHINE') eq 'vms' then lamp_touch=' '

    idx =reverse(sort(lamp_grp))
    lamp_grp =lamp_grp (idx)
    lamp_ins =lamp_ins (idx)
    lamp_proc=lamp_proc(idx)

    if n_elements(lamp_ins) eq 2 then begin inst_value=lamp_ins(0) & inst_group=lamp_grp(0)
    endif else  for i=0,n_elements(lamp_ins)-1 do begin
    		    if strpos(strlowcase(lamp_ins(i)),lamp_host) ge 0 then begin
    		       inst_value=lamp_ins(i) & inst_group=lamp_grp(i)  &  endif
    		endfor

    if  strpos(!path,"home") lt 0 then  begin	ta=findfile('home') & l_me=''
					;if n_elements(ta) ge 1 then   l_me=expand_path('+home')
					;if n_elements(ta) ge 1 then   l_me=expand_path( 'home')
					 if l_me ne '' then bid=sys_dep ('ADDPATH',l_me)
					endif
    meed=sys_dep ('NEWSUB',sys_dep ('HOME'),'../DIALS')

    if  strpos(!path,"DIAL") lt 0 then  begin	ta=findfile(meed)   & l_me=''
					if n_elements(ta) gt 1 then   l_me=expand_path('+'+meed)
					if l_me ne '' then bid=sys_dep ('ADDPATH',l_me)
					endif
    lamp_macro=expand_path(lamp_macro)
    if (lamp_macro gt ' ') then  begin      ta=findfile(lamp_macro+lamp_dvd+'*') & l_me=''
					if n_elements(ta) gt 1 then   l_me=expand_path('+'+lamp_macro)
					if l_me ne '' then bid=sys_dep ('ADDPATH',l_me)
					                   bid=sys_dep ('ADDPATH',lamp_macro)
    endif
;** Local or Remote
;** ----- -- ------
        lamp_loc  =0
	disp  ='' &      disp =sys_dep      ('GETENV','DISPLAY')
	if disp			  eq '' then lamp_loc=1 else $
	if strpos(disp,':')       eq 0	then lamp_loc=1 else $
	if strpos(disp,lamp_host) eq 0  then lamp_loc=1
return
end

FUNCTION P_LAMBDAF, dummy
;******* ********
;**
@lamp.cbk

rst=lamp_macro
idx=strpos(lamp_macro,'macros')
if  idx gt 0 then begin rst= strmid(lamp_macro,0,idx-1) +lamp_dvd
			if   lamp_dvd eq "" then rst=rst+"]"
             endif else if   lamp_dvd ne "" then rst=rst+lamp_dvd

if rst gt ' ' then if strmid(rst,strlen(rst)-1,1) ne lamp_dvd then rst=rst+lamp_dvd
bid= findfile   (rst+'*',count=n)
if n eq 0 then rst=''
return, rst
end
PRO P_LAMBDA, rst
;** ********
;**
rst=P_LAMBDAF (dum)
end

function P_ONLYONE ,pth, lamp_dvd
;******* *********
;**
;** Choose path corresponding to the platform.
	npth=str_sep(pth,',')
	npdx=-1
	for k=0,n_elements(npth)-1 do begin npth(k)=strtrim(npth(k),2)
    		nld=strlen(npth(k))
		if (strpos(npth(k),lamp_dvd) ge 0) and (npdx lt 0) then npdx=k
     		if  strmid(npth(k),nld-1,1)  eq lamp_dvd then npth(k)=strmid(npth(k),0,nld-1)
	endfor
return, npth(npdx>0)
end

pro P_NEWCUST ,fromcust=fromcust
;** *********
;**
;** Update customisable tables.
@lamp.cbk

    datp      = ''    & init= 'init'
    stat=0 & catch,stat
    if stat  ne 0  then catch,/cancel else begin
			pth=sys_dep      ('NEWSUB',lamp_dir,'lamp_mac')
			t = findfile (pth + 'read_par.pro',count = exist)
			if (exist eq 0) then begin pth=!dir    +sys_dep("DIVIDER")
			t = findfile (pth + 'read_par.pro',count = exist) & endif
			if (exist eq 0) then begin status=23 & datp=0 & bid=0
			                ii=execute('bid=read_par("init","","",status,datp)')   & endif
			on_ioerror, mis_par & in=-1

			OPENR,in,pth+'read_par.pro',/get_lun
			on_ioerror, end_par
			      ligne=' '   & ttinst='' & ttproc ='' & ttgroup ='' & ttsymbol='' & ttpath=''
			      ttwall=''   & ttouch='' & ttmacro='' & ttaccess='' & ttsite  ='' & ttmagi='6'
			      ttpars='40'
			      WHILE not eof(in) DO begin
            		          readf,in,ligne
            		          IF (strpos(ligne,';exec') gt 0) THEN r=execute(ligne)
        		      ENDWHILE
        		end_par:  datp={a:ttinst,  b:ttproc,  c:ttgroup,  $
              				d:ttsymbol,e:ttpath,  f:ttouch,   $
              				g:ttmacro, h:ttaccess,i:ttsite,j:ttmagi,k:ttwall,l:ttpars}
			mis_par:if in gt 0 then FREE_LUN,in
		    endelse

    if n_tags(datp) gt 0 then  begin
    	    nins = datp.a
    	    nproc= datp.b
    	    ngrp = datp.c
	    lamp_wrti =[' '] & lamp_wrtp =[' ']
;**
    	    for i= 0,n_elements(nins)-1 do begin  pos=-1
	      if strpos(nins(i),'.') ne strlen(nins(i))-1 then begin
    	        for j=0,n_elements(lamp_ins)-1 do if lamp_ins(j) eq nins(i) then pos=j
    	    	if  pos ge 0 then begin
    	    	    lamp_proc(pos)=nproc(i)
    	    	    lamp_grp (pos)=ngrp (i)
    	    	endif else begin
    	    	    lamp_ins	  =[lamp_ins ,nins (i)]
    	    	    lamp_proc	  =[lamp_proc,nproc(i)]
    	    	    lamp_grp	  =[lamp_grp ,ngrp (i)]

    	    	    if n_elements(b_labins) gt 0 then if b_labins(0) gt 0 then begin
		       n  =n_elements(lamp_ins)-1
	               bid=widget_button(b_labins(0),font=ft_b_normal,value=lamp_ins(n),$
	               			 uvalue=[-88,560,0,b_labins(0) , b_labins(1),n,0,0])
		    endif
    	    	endelse
	      endif else begin lamp_wrti=[lamp_wrti,strmid(nins(i),0,strlen(nins(i))-1)]
	                       lamp_wrtp=[lamp_wrtp,nproc(i)] & endelse
    	    endfor
;**
    	    nali =datp.d
    	    npath=datp.e
    	    for i= 0,n_elements(nali)-1 do begin  pos=-1
    	        for j=0,n_elements(lamp_ali)-1 do if lamp_ali(j) eq nali(i) then pos=j
		npath(i)=P_ONLYONE(npath(i),lamp_dvd)
     	    	if  pos ge 0 then begin
    	    	    lamp_path(pos)=npath(i)
    	    	endif else begin
    	    	    lamp_ali	  =[lamp_ali ,nali (i)]
    	    	    lamp_path	  =[lamp_path,npath(i)]

    	    	    if n_elements(b_labins) gt 0 then if b_labins(1) gt 0 then begin
		       n  =n_elements(lamp_ali)-1
	               bid=widget_button(b_labins(1),font=ft_b_normal,value=lamp_ali(n),$
	               			 uvalue=[-88,561,0,b_labins(0) , b_labins(1),n,0,0])
		    endif
    	    	endelse
    	    endfor
;**
	    if keyword_set(fromcust) then RDSET,inst=inst_value
    	    lamp_touch=P_ONLYONE(datp.f,lamp_dvd)
    	    lamp_macro=P_ONLYONE(datp.g,lamp_dvd)
    	    lamp_asite=datp.h
    	    lamp_fsite=datp.i
    	    lamp_6    =datp.j
    	    lamp_proxy=datp.k
	    if strpos(strupcase(lamp_fsite),'GEORGE') ge 0 then begin
	                                     GEORGE=1 & lamp_fsite=""
					     if strpos(strupcase(lamp_fsite),'LAMP') ge 0 then GEORGE=2
					     endif
	    npp	      =long(datp.l)<10000
	    if n_elements(par_txt) eq 0 then npars=npp else $
	    if npp gt  npars then begin nw=(size(par_txt))(1) & nww=(size(par_txt))(2) & tmp=strarr(nw,npp)
					for i=0,nw-1 do   tmp(i,0:nww-1) =par_txt(i,*)   & par_txt    =tmp
    				tmp=strarr(npp) & tmp(0:nww-1)   =par_txt_all(*) & par_txt_all=tmp
					npars=npp & endif
    	    lamp_path(0)=''
    	    if n_elements(b_labins) gt 0 then if b_labins(2) gt 0 then $
    	    				 widget_control,bad_id=i,b_labins(2),set_value=lamp_fsite
    endif
return
end

pro P_SCREEN
;** ********
;**
@lamp.cbk
screen=[800,600]
if !D.name eq 'Z'    then screen=[1024,1280] else $
if !D.name ne 'TEK'  then device,get_screen_size=screen

   if (screen(0) ge 1024) then screen(1)=screen(1)>800
   if (screen(1) lt 800 ) and (screen(1) gt 750) then screen(1)=800
   if n_elements(lamp_ziz) eq 1 then screen(1)=min([screen(1),lamp_ziz])>480
   lamp_ziz=screen(1)
   lamp_siz=screen(1)

return
end

pro P_SET_FONT, n ,lamp_font
;** **********
;**
@lamp.cbk

    lamp_font = sys_dep('FONTS')
    fk=n
    if (lamp_ziz le 950 ) and (fk eq 0) then fk=1
    if (lamp_ziz lt 800 ) and (fk lt 2) then fk=2

    ft_propor    = lamp_font(0,fk)
    ft_biggest   = lamp_font(1,fk)
    ft_bigger    = lamp_font(2,fk)
    ft_b_bigger  = lamp_font(3,fk)
    ft_normal    = lamp_font(4,fk)
    ft_b_normal  = lamp_font(5,fk)
    ft_smaller   = lamp_font(6,fk)
    ft_smallest  = lamp_font(7,fk)


    if n_elements(lamp_b1) gt 0 then $
    if lamp_b1 gt 0 then widget_control,bad_id=ii,lamp_b1,default_font=ft_normal

    if n  eq 0 then lamp_siz=lamp_ziz else $
    if fk eq 1 then lamp_siz=900      else lamp_siz=780
return
end

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------



;*			******************************
;*			**                          **
			    PRO LAMP_EVENT_PARSER,ev
;*			**                          **
;*			******************************

;** User_Value for lamp's widgets having an event has the following structure:
;** [lampcode, sequence , 0 , 0 , 0 , 0 , 0 , 0 , 0]
;**     where:
;**  lampcode=-88  for widgets under lamp
;**          =-87  for widgets under scan
;**          =-86  for others  front windows
;**          =-85  lamp_b1 Timer
;**  sequence= 100 --> 199 for MIC   unit
;**	     = 200 --> 299 for DON   unit
;**	     = 300 --> 399 for DID   unit
;**	     = 400 --> 499 for BEN   unit
;**	     = 500 --> 599 for MAC   unit
;**	     = 600 --> 699 for GEO   unit
;**  others  = 7 free parameters

@lamp.cbk
	if ev.id gt 0 then begin  i=0
	   widget_control, ev.id ,bad_id=i, get_uvalue=uv

	   if i eq 0 then if n_elements(uv) gt 1 then begin

	         stat=0 & catch,stat
	         if stat  ne 0  then begin catch,/cancel
	         		catch,stat & if stat ne 0 then retall
				therror=strmid(!err_string,0,65)
	         		widget_control,bad_id=i,l_message,set_value=therror
	         		set_plot,my_path(3)
				P_MUS,'mus_cannon'
				if b_labins(6) then  if b_labins(7) gt 0 then $
				widget_control,bad_id=i,b_labins(7),set_value=therror
	         		return & endif

		 if  tag_names(ev,/structure_name) ne 'WIDGET_DRAW'  then  nodr=1 else nodr=0

		 if uv(0) eq -85  then begin if uv(2) ge 1 then widget_control,ev.id,TIMER=uv(2)
		    if uv(2) eq 1 then begin uv(2)=2  & widget_control,ev.id,set_uvalue=uv & retall & endif
		    if uv(2) eq 2 then begin uv(2)=0  & widget_control,ev.id,set_uvalue=uv
		    		print,'%Lamp successfully loaded' & print,''
		    		print,'Enter @lamp.cbk to define lamp variables at command line' & endif
		 endif else $
		 if uv(0) eq -87  then			       P_DID_EVENT,ev,uv  else $
		 if uv(0) eq -88  then  begin

		    if ( lamp_act eq 1) and (nodr)	     then P_DID_EVENT,ev,[-88,300]
		    if my_path(1) ne '' then if uv(1) ne 576 then P_SET_PATH

		    if (uv(1) ge 600)  and (uv(1) le 699) then P_GEO_EVENT,ev,uv $
		    else begin

		    if  nodr  then widget_control,/hourglass
		    if (uv(1) ge 100)  and (uv(1) le 199) then P_MIC_EVENT,ev,uv
		    if (uv(1) ge 200)  and (uv(1) le 299) then P_DON_EVENT,ev,uv
		    if (uv(1) ge 300)  and (uv(1) le 399) then P_DID_EVENT,ev,uv
		    if (uv(1) ge 400)  and (uv(1) le 499) then begin
		    					       P_BEN_EVENT,ev,uv
							       P_DID_SETWIN0
							       endif
		    if (uv(1) ge 500)  and (uv(1) le 599) then P_MAC_EVENT,ev,uv
		    if (uv(1) eq 222)  or  (uv(1) eq 342) or $
		    			   (uv(1) eq 422) then P_EXTEND   ,ev,uv

		    if lamp_b1 gt 0 then begin
			if (GEORGE eq 0) and (uv(1) ne 390) then that=lamp_b1 else that=long(lamp_don(0))
			evv=widget_event(that,/nowait,bad_id=i)
			widget_control,bad_id=i, that ,/clear_events
			if b_labins(8) gt 0 then begin
				evv=widget_event(b_labins(8),/nowait,bad_id=i)
				if i ne 0 then b_labins(8)=0 $
				          else widget_control,bad_id=i,b_labins(8),/clear_events
			endif
		    endif
		    endelse
		 endif
	   endif
	endif
return
end

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

pro	P_MAC_CREATE ,base ,mbar ,wread ,b33 ,b1,cque
;**	************
;**
@lamp.cbk
	b1   =	widget_base  (base,/column)
	b11  =  widget_base  (b1  ,/row)
;b11
	bid=' DATA COLLECTOR'
	btitl=	widget_label (b11 ,font=ft_biggest ,value=bid)
	bidon='' & CALL_PROCEDURE,'myhelp',bidon

	fhrt=findfile('myhelp.rt',count=nn) & if nn gt 0 then begin
          on_ioerror, mishlp & in=-1
	  OPENR,in,'myhelp.rt',/get_lun
	  line=''
	  WHILE not eof(in) DO begin readf,in,line & bidon=[bidon,'line'] & ENDWHILE
	  mishlp: if in gt 0 then FREE_LUN,in
	endif
	if n_elements(bidon) gt 1  then begin
	  bhelp=widget_button(b11 ,font=ft_b_normal  ,value='my HELP?')
	  bidon=widget_label (b11 ,font=ft_biggest ,value='   ')
	endif else begin
	  bhelp=widget_button(b11 ,font=ft_normal  ,value='?')
	  bidon=widget_label (b11 ,font=ft_biggest ,value='            ')
	endelse
	cd,current =path
        pwd_l=  widget_label (b11 ,font=ft_b_normal,value=' Working path:  ')
	pwd_t=  widget_text  (b11 ,value=path,font=ft_b_bigger,xsize=24,ysize=1,/editable,$
										/all_events)
	sel    =[strlen(path),0]
 	my_path=[path,'',string(pwd_t),!D.NAME]

	laber=l_message
	cque =0
;b33
	if (n_elements(lamp_ins) le 1) or (lamp_asite eq 'customiz')  then text='Customize' $
	      else if lamp_siz ge 800 then text='Data...' else text='Data...'

	if GEORGE ne 0 then begin
	   bgeo2= laber

	   if GEORGE eq 1 then begin txt='Data' & map1=1 & map2=0 & b_labins(5)=1
	   endif          else begin txt='Pad'  & map1=0 & map2=1 & b_labins(5)=0 & endelse

	   aque = widget_base  (b1,/row)

	   if mbar eq 0 then begin
		bque = widget_button(aque ,font=ft_b_normal,value=txt)
		if sys_dep('MACHINE') eq 'win'  then val='  ' else val=' '
		bid  = widget_label (aque ,font=ft_propor  ,value=  val ) & endif

	   aque = widget_base  (aque )
;	   cque = widget_base  (aque ,/row,resource_name="geo",map=map1,frame=3)
	   cque = widget_base  (aque ,/row,resource_name="geo",map=map1)

	;	STACKER DATA ACCESS MODEL
;		b1= widget_base  (aque ,map=map2,/column,frame=3)
		b1= widget_base  (aque ,map=map2,/column)

	;	BESIDE  DATA ACCESS MODEL
	;	ttl='DATA Access....'
	;	if sys_dep('VERSION') lt 4.0 then $
	;	       ii=execute('b1=widget_base(title=ttl,/column,map=0,resource_name="lampmic"') $
	;	else   ii=execute('b1=widget_base(title=ttl,/column,map=0,resource_name="lampmic",tlb_frame_attr=8+2)')
	;	bu   = widget_base (b1 ,/row)
	;	put_logo,bu
	;	laber= widget_label(bu ,font=ft_b_normal,value='                  	',xsize=(lamp_siz/2)<600>300)
	;	Widget_Control, b1 ,group_leader=lamp_b1,/Realize & put_logo
	;	Xmanager,'Daccess' , b1 ,Event_Handler='LAMP_EVENT_PARSER',/just_reg

	  if mbar eq 0 then  widget_control,bque,set_uvalue=[-88,557,0,b1,cque,0]

	   dque = widget_base  (cque ,/column)
	   eque = widget_base  (dque ,/row)
	   bid  = widget_label (eque ,font=ft_b_bigger,value='COMMAND Control PAD')
	   bid  = widget_button(eque ,font=ft_b_bigger,value='?',uvalue=[-88,595,laber,0])
	   eque = widget_base  (dque ,/row)
	   bido = widget_text  (eque ,font=ft_propor  ,xsize=20,ysize=1,/editable)
	   bidu = widget_button(eque ,font=ft_b_bigger,value='Send')

	   ii   = findfile('dial_pad_init.prox',count=nn)
	   if  nn gt 0 then COMMSI,'dial_pad_init.prox', /EXEC $
	   else begin par1=''
		Mach=strlowcase(getenv('HOST')) & id=strpos(Mach,'.')
		if id gt 0 then Mach=strmid(Mach,0,id)
		if Mach ne '' then begin
		   catch,stat
	   	   if stat eq 0 then ii=execute('par1=dial_pad_init_'+(Mach)+'(dummy)') else catch,/cancel
	   	endif
	   	sz=SIZE(par1)
		if  sz(0) lt 2 then ii=execute("par1=dial_pad_init()")
	   endelse
	   sz=SIZE(par1)
	   if (sz(0) ne 2) or (sz(1) ne 5) then begin par1=strarr(5,17) & par1(*,*)='0'
	                                              par1(0,0)='' & par1(3,0)='lamp'  & endif
	   widget_control,bido,set_value=par1(0,0)
	   PROX=par1(*,0)
	   GEORGEO, duduch=PROX
	   uvv =[-88,540,0,cque]
	   widget_control,cque,set_uvalue=par1
	   widget_control,bido,bad_id=i,set_uvalue=[uvv,0,PROX,bido,0]
	   widget_control,bidu,bad_id=i,set_uvalue=[uvv,0,PROX,bido,0]

	   i=1 & k=0 & n_e=n_elements(par1)/5
	   par1=[[par1],['','','','','']]
	   while i  lt n_e do begin
		val=par1(0,i)
		j=k/2 & if j*2 eq k then dque = widget_base  (cque ,/column)
		eque  = widget_base  (dque ,/row)
		k=k+1
;**	level1
		if par1(2,i) eq '-' then begin
		  bid1= widget_button(eque ,font=ft_b_bigger,value=val ,menu=2)
		  i=i+1
		  while strpos(par1(0,i),'-') eq 0 do begin
		   val =strmid(par1(0,i),1,15)
;**	level2
		   if par1(2,i) eq '-' then begin
			bid2=widget_button(bid1 ,font=ft_b_bigger,value=val ,menu=2)
			i=i+1
			while strpos(par1(0,i),'--') eq 0 do begin
			  val =strmid(par1(0,i),2,15)
;**	level3
			  if par1(2,i) eq '-' then begin
				bid3=widget_button(bid2 ,font=ft_b_bigger,value=val ,menu=2)
				i=i+1
				while strpos(par1(0,i),'---') eq 0 do begin
				  val =strmid(par1(0,i),3,15)
				  SetDuduch,"_send", par1(3,i), PROX
				  bid4=widget_button(bid3 ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
				  i=i+1
				endwhile
			  endif else begin
				SetDuduch,"_send", par1(3,i), PROX
				bid3=widget_button(bid2 ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
				i=i+1 & endelse
			endwhile
		   endif else begin
			SetDuduch,"_send", par1(3,i), PROX
			bid2=widget_button(bid1 ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
			i=i+1 & endelse
		  endwhile
		endif else begin
		  SetDuduch,"_send", par1(3,i), PROX
		  bid = widget_button(eque ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
		  i=i+1 & endelse
	   endwhile
	endif
;b22
	if (lamp_siz ge 800) or (GEORGE ne 0) then $
	    laber=  widget_label (b1 ,font=ft_b_normal,value='Click below to access data from experiments',xsize=(lamp_siz*2/3)<600>300)
	    b_labins(7)=laber
;	b77=  widget_base  (b1  ,map=0)
	b88=  widget_base  (b1  ,/row)
	bac=  widget_button(b88 ,font=ft_b_normal,value=text)
	b33=  widget_base  (b88 ,/row, map=0)
;b44
	IF mbar eq 0 then begin
	  b44  =  widget_base  (b1  ,/row)
	  if GEORGE ne 0 then bid='IMPORT FILES, Workspaces' $
			 else bid='IMPORT FILES  or  RESTORE Workspaces'
	  butl =  widget_button(b44 ,font=ft_b_normal,value=bid)
	  buts =  widget_button(b44 ,font=ft_b_normal,value='EXPORT')
	  if (lamp_touch gt ' ') and (lamp_siz ge 800) then $
	    if sys_dep('MAP') ne -1 then $
	       butt =  widget_button(b44 ,font=ft_b_normal,value='Catalog...',uvalue=[-88,331,0],$
								resource_name='discret')  else $
	       butt =  widget_button(b44 ,font=ft_b_normal,value='Catalog...',uvalue=[-88,331,0])
	  if   sys_dep('MAP') ne -1 then $
	       butb =  widget_button(b44 ,font=ft_b_normal,value='Browse...'    , $
								resource_name='discret') else $
	       butb =  widget_button(b44 ,font=ft_b_normal,value='Browse...')

	  widget_control,butl ,bad_id=i,set_uvalue=[-88,380,0    ,0,0,0,0,0,0]
	  widget_control,buts ,bad_id=i,set_uvalue=[-88,370,0    ,0,0,0,0,0,0]

	  bs1f =widget_base  (b44,/row,/frame)
	  if sys_dep('MAP') ne -1 then $
	  bs1b1=widget_button(bs1f,font=ft_smaller ,value='<-',resource_name='discret') else $
	  bs1b1=widget_button(bs1f,font=ft_smaller ,value='<-')
	  wread=widget_label (bs1f,font=ft_b_normal,value='W1 ',xsize=29)
	  if sys_dep('MAP') ne -1 then $
	  bs1b2=widget_button(bs1f,font=ft_smaller ,value='->',resource_name='discret') else $
	  bs1b2=widget_button(bs1f,font=ft_smaller ,value='->')

	  widget_control, bs1b1  ,bad_id=i,set_uvalue=[-88,310,wread,0   ,0,0,0,0,0]
	  widget_control, bs1b2  ,bad_id=i,set_uvalue=[-88,311,wread,0   ,0,0,0,0,0]
	  widget_control, butb   ,bad_id=i,set_uvalue=[-88,562,0,0,wread ,-2,-2,0]

	endif else begin butb=b88 & widget_control,butb,bad_id=i,set_uvalue=[-88,562,0,0,0 ,-1,-1,0] & endelse

	P_DATA_ACCESS, laber,b33,bac,butb,1

	if n_elements(lamp_wrd) ne 1 then lamp_wrd='W1'

	widget_control,butb ,bad_id=i,get_uvalue=uv & wread=[uv(3),uv(4)]
	widget_control,bhelp,bad_id=i,set_uvalue=[-88,586,laber,0,0,0,0,0,0]
	widget_control,pwd_t,bad_id=i,set_uvalue=[-88,576,laber,0,0,0,0,0,0],SET_TEXT_SELECT=sel

	widget_control,bac  ,bad_id=i,set_uvalue=[-88,558,laber,b33,bac,butb]
return
end

pro	P_MAC_EVENT  ,event ,uv
;**	************
@lamp.cbk

	if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value='                   '
	icoco=0

;**PAD  Control
	if uv(1) eq 540 then begin                              ;uv(3)=cque  uv(7)=widget_text
		widget_control,uv(3),get_uvalue=PadTab          ;uv(8)=idx in padtab
		ncomm=-1
		bito = 0
		if uv(4) le 0 then begin                        ;*Comes from input widget_text
			widget_control,uv(7),get_value =comm
			comm =comm(0) & ncomm=uv(8)             ;   will xecute the command
		endif else begin                                ;*Comes from button
		   if PadTab(2,uv(8)) eq "t" then begin         ;   Put command to widget_text
			widget_control,uv(7),set_value =PadTab(1,uv(8))
			widget_control,uv(7),get_uvalue=uvv & uvv(8)=uv(8)
			widget_control,uv(7),set_uvalue=uvv     ;   and put index in uv
		   endif else $
		   if (uv(4) ne 100) and $
		     (PadTab(2,uv(8)) eq "c") then begin k=uv(8);   Create a GUI-input command
		   	str8="PAD_" +strtrim  (string(k),2)
			if xregistered(str8) le 0 then begin
			   padr=str_sep    (PadTab(1,k),"<cr>")
			   padb=widget_base(title=PadTab(0,k),resource_name='lamp',/column)
			   for r=0,n_elements(padr)-1 do begin
			   	padt =str_sep      (Padr(r),"~")
			   	n    =n_elements   (padt)
			   	if (n/2)*2 ne n then padt=[padt,' ']
			   	n    =n_elements   (padt) & biti =lonarr(n)
			   	padg =widget_base  (padb,/row,resource_name='geo',/frame)
			   	for i=0,n-1,2 do begin
			     	  bid=widget_base  (padg,/column)
			     	  bil=widget_label (bid ,value=padt(i)  ,font=ft_b_bigger) & biti(i)=bil
			     	  bit=widget_text  (bid ,value=padt(i+1),font=ft_propor ,/editable,$
			     			    xsize=strlen(padt(i+1))+3) & biti(i+1)=bit
			   	endfor
			   if r eq 0 then bito=biti else bito=[bito,-1,-1,biti]
			   endfor
			   ivv  =uv & ivv(4)=100
			   padg =widget_base  (padb,/row,resource_name='geo') & put_logo,padg
			   bid  =widget_button(padg,value='SEND ->',font=ft_b_bigger,uvalue=ivv)
			   bid  =widget_button(padg,value=' CLOSE ',font=ft_b_bigger,uvalue=[-88,399,0])
			   err  =widget_label (padg,value='       ',font=ft_b_normal,xsize=250)
			   bito =[bito,err]
			   widget_control,padb,group_leader =lamp_b1,set_uvalue=bito,/realize & put_logo
			   XMANAGER, str8,padb,event_handler='LAMP_EVENT_PARSER',/just_reg
			endif
		   endif else begin
		   	ncomm=uv(8)				;   will execute the command from button
			if (uv(4) ne 100) then  comm =PadTab(1,uv(8)) $
			else begin    como='' & comm =[''] & r=0 & sep=''		;from GUI
				widget_control, event.top, get_uvalue=bito
				nbito= n_elements(bito)-1
				for j=1,nbito-1,2 do begin	 comi=''
		  		   if bito(j) gt 0 then begin
					widget_control,bad_id=ii,bito(j-1),get_value=labi
					widget_control,bad_id=ii,bito(j)  ,get_value=comu
					comi   = strtrim (comu(0),2)
					comm(r)= comm(r) +comi+' '
					if comi eq '' then ncomm=-1
					como   = como+sep+labi(0)+"~"+comi & sep="~"
		  		   endif else begin r=r+1  & sep=""
					comm   =[comm,'']  & como=como+"<cr>" & endelse
				endfor
				PadTab(1,uv(8))=como
				widget_control,uv(3)    ,set_uvalue=PadTab
				if ncomm lt 0 then txt='!!! Cmd is incomplete.' else txt='Sending ...'
				bito=bito(nbito)
				widget_control,bito,bad_id=ii,set_value =txt
			endelse
		   endelse
		endelse
		if ncomm ge 0 then begin                        ;*Executes the command
			d0={GENERIC:PadTab(3,ncomm),NAME:PadTab(0,ncomm),TYPE:'PAD',PROS:[uv(5),uv(6)]}
			on_ioerror, mischk & check=0. & check=float(PadTab(4,ncomm)) & mischk:
			R=0L & ii=execute('R = DialControl(comm,  d=0, check=check)')
			if (R lt 0) or (R gt 1) then txt="error-code "+string(R) else txt= '- Sent -'
			if bito gt 0 then widget_control,bito,set_value =txt     else print,txt+': '+comm
		endif
		endif

;**Lamp and George configuration
	if uv(1) eq 557 then begin widget_control,event.id,get_value=labbut
				   widget_control,bad_id=i,l_message,set_value=''
				   if n_elements(uv) gt 6 then idx=uv(5) else idx=0
				   if   idx eq 0 then begin
				    idx=strpos(strupcase(labbut),'PAD')
				    if  idx ge 0 then widget_control,event.id,set_value="Data" $
				                 else widget_control,event.id,set_value="Pad"
				   endif else begin
				    if  idx gt 0 then widget_control,uv(6),sensitive=1 else widget_control,uv(6),sensitive=0
				    if  GEORGE gt  0  then $
				    if  idx gt 0 then widget_control,uv(7),sensitive=0 else widget_control,uv(7),sensitive=1
				   endelse
				   if idx eq -1 then begin
					widget_control,bad_id=i,uv(4),map=0
					widget_control,bad_id=i,uv(3),map=1 & b_labins(5)=0
					if GEORGE       eq 2 then widget_control,bad_id=i,lamp_ben(8) , map=0
					                          widget_control,bad_id=i,lamp_ben(7) , map=1
					if lamp_ben(10) gt 0 then widget_control,bad_id=i,lamp_ben(10), map=0

					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_ben(0) , map=0
					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_b1     , scr_xsize=uv(9)
					if b_labins(6)  eq 1 then widget_control,bad_id=i,uv(8)       , sensitive=0

				   endif else begin
					widget_control,bad_id=i,uv(3),map=0
					widget_control,bad_id=i,uv(4),map=1 & b_labins(5)=1
					if GEORGE       eq 2 then widget_control,bad_id=i,lamp_ben(7) , map=0
					if GEORGE       eq 2 then widget_control,bad_id=i,lamp_ben(8) , map=1
					if lamp_ben(10) gt 0 then widget_control,bad_id=i,lamp_ben(10), map=0

					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_b1     , scr_xsize=uv(10)
					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_ben(0) , map=1
					if b_labins(6)  eq 1 then widget_control,bad_id=i,uv(8)       , sensitive=1
				   endelse
				   endif
;**Data Access Creation
	if uv(1) eq 558 then begin if n_elements(lamp_ins) le 1 then customiz,1
				   P_DATA_ACCESS, uv(2),uv(3),uv(4),uv(5),0
				   widget_control,bad_id=i,uv(3),map=1 & endif
	if uv(1) eq 559 then begin if n_elements(lamp_ins) le 1 then customiz,1
				   P_DATA_ACCESS, uv(2),uv(3),uv(4),uv(5),2
				   widget_control,bad_id=i,uv(3),map=1 & endif
;**Change Instrument Name
	if uv(1) eq 560 then begin
	   if uv(5) ge 0 then begin
		inst_old  =strlowcase(inst_value)
		inst_value=lamp_ins(uv(5))
		inst_group=lamp_grp(uv(5))
		idx =where(lamp_entry eq inst_group)
		if idx(0) lt 0 then begin lamp_entry=[lamp_entry,inst_group]
				;plug_in
				VV=strtrim(string(sys_dep('VERSION')),2)
				VV=strmid (VV,0,1)+strmid (VV,2,1)
				plugpth=sys_dep ('NEWSUB',lamp_dir,'plug_in')
				plugfil=findfile(plugpth+'*'+strlowcase(inst_group)+'*'+VV+'*.rt',count=nn)
				if nn gt 0 then for i=0,nn-1 do begin
				   idx =where(lamp_entry eq plugfil(i))
				   if idx(0) lt 0 then begin lamp_entry=[lamp_entry,plugfil(i)]
					P_RESTORE,plugfil(i) ,rflg
					PRINT    ,plugfil(i) +' plug_in loaded ...'
					to_don_history,-1,0,plugfil(i) +' plug_in loaded ...'
				   endif
				endfor
		endif
		if uv(3) gt 0 then widget_control,uv(3)	,bad_id=i,set_value=inst_value
		if uv(7) gt 0 then widget_control,uv(7)	,bad_id=i,set_value=inst_value
		if lamp_cyc(1)  eq 0 then cycle = lamp_ali(lamp_cyc(0))
		p_ath=lamp_path(lamp_cyc(0))
		if  cycle ne 'Current Path' then $
		 if strpos(strlowcase(cycle),'cycle') lt 0   then begin
		      path_for_online=p_ath+lamp_dvd
		      strp=strpos(path_for_online,'(inst)')
		      if strp gt 0 then path_for_online=strmid(path_for_online,0,strp)+strlowcase(inst_value)+strmid(path_for_online,strp+6,50)
		      if strp gt 0 then if strpos(cycle,'On_Line') eq 0  then cycle=inst_value
		 endif else begin
			if lamp_cyc(1) gt 0 then begin  p_ath=path_for_online & n=strlen(inst_old)
					pos1 =strpos(p_ath,inst_old)
					if pos1 gt 0 then p_ath=strmid(p_ath,0,pos1-1)+strmid(p_ath,pos1+n,10)
			endif else p_ath=p_ath+lamp_dvd
			path_for_online=sys_dep('INSUB',p_ath,strlowcase(inst_value))
		 endelse
		to_don_history,-1,0,'RDSET,inst="'+inst_value+'"'
	   endif else  customiz,1
	endif
;**Change Cycle
	if uv(1) eq 561 then begin
		lamp_cyc=[uv(5),uv(7)]
		if uv(7) gt 0 then begin YT=strtrim(string(uv(7)),2)
					 if strlen(YT) eq 1 then YT='0'+YT
					 if strlen(YT) eq 2 then YT='0'+YT & cycle='Cycle '+YT
		endif else cycle  =lamp_ali(lamp_cyc(0))
		tmps=''
		if uv(4) gt 0 then widget_control,uv(4)	,bad_id=i,set_value=cycle
		if uv(6) gt 0 then widget_control,uv(6)	,bad_id=i,set_value=cycle
		path_for_online=''
		if  cycle ne 'Current Path' then $
		 if strpos(strlowcase(cycle),'cycle') lt 0    then begin
		      path_for_online=lamp_path(lamp_cyc(0))+lamp_dvd
		      strp=strpos(path_for_online,'(inst)')
		      if strp gt 0 then path_for_online=strmid(path_for_online,0,strp)+strlowcase(inst_value)+strmid(path_for_online,strp+6,50)
		      if strp gt 0 then if strpos(cycle,'On_Line') eq 0  then cycle=inst_value
		 endif else begin
		      p_ath =  lamp_path(lamp_cyc(0))+lamp_dvd
		      bid   = 'Connecting '+p_ath+' ...' & n=0
		      if uv(2) gt 0 then widget_control,bad_id=i,uv(2) ,set_value=bid else print ,bid
		      if uv(7) gt 0 then begin tmps=',cycle='+YT
			 bid  =where(lamp_ali eq 'archive') & bid=bid(0)
			 if bid ge 0 then p_arc =lamp_path(bid) else p_arc= '?'
			 p_ath=sys_dep ('INSUB',p_ath,YT)
			 bid  =FINDFILE(p_ath,count=n)
			 if n le 0 then bid  =FINDFILE(p_ath+'*',count=n)
			 if n le 0 then begin	 ;Last chance !!!
					if p_arc ne '?' then begin p_ath=sys_dep ('INSUB',p_arc+lamp_dvd,YT)
					   bid =  'Connecting the archive system ...'
			 		   if uv(2) gt 0  then widget_control,bad_id=i,uv(2) ,set_value=bid else print,bid
			 		   bid =FINDFILE(p_ath,count=n)
					endif
			 endif
			 if n gt 0 then if strpos(p_ath,p_arc) ge 0 then bid =FINDFILE('/CDBOX',count=n)
		      endif else begin  catch,stat & if stat eq 0 then begin cd,p_ath,current=mee & cd,mee & n=1 & endif
		      endelse
		      if n le 0 then bid='Connection failed !!!' else bid =''
		      if uv(2) gt 0  then widget_control,bad_id=i,uv(2)   ,set_value=bid else print,bid
		      path_for_online=sys_dep('INSUB',p_ath,strlowcase(inst_value))
		 endelse
		to_don_history,-1,0,'RDSET,base="'+lamp_ali(lamp_cyc(0))+'"'+tmps
	endif
;**Browse
	if uv(1) eq 562 then begin
		lamp_man=findfile(path_for_online,count=n)
		if n eq 0 then lamp_man=findfile(path_for_online+'*',count=n)
		uvv=uv & uvv(1)=563
		if n gt 0 then begin cd,path_for_online,current=mee & cd,mee,current=p_f_o
				     if strmid(p_f_o,strlen(p_f_o)-1,1) ne lamp_dvd then p_f_o=p_f_o+lamp_dvd
				     ln=strpos(strupcase(lamp_man(0)),strupcase(p_f_o))
				     if ln ge 0 then lamp_man=strmid(lamp_man,ln+strlen(p_f_o),30)
		endif
		if uv(5) gt 0 then widget_control,bad_id=i,uv(5),/destroy
		base =widget_base  (title='Select File to Read',resource_name='lamptouch',/column)
		uv(5)=base
		bid  =widget_label (base,value="PATH="+path_for_online,font=ft_b_normal)
		lab  =widget_base  (base,/row)
		lub  =widget_list  (lab ,value=lamp_man,xsize=15,ysize=15,font=ft_propor)
		lab  =widget_base  (lab ,/column)
		lib  =widget_base  (lab,/row) & put_logo,lib
		bid  =widget_label (lib,value="sub",font=ft_b_normal)
		lyb  =widget_text  (lib,xsize=8,ysize=1,font=ft_propor,/editable,uvalue=[-88,564,lub])
		lob  =widget_draw  (lab ,retain=2  ,xsize=192,ysize=192)
		lib  =widget_base  (lab,/row)
		bid  =widget_button(lib,value='Done'   ,font=ft_b_normal,uvalue=[-88,399,0])
		bid  =widget_button(lib,value='Refresh',font=ft_b_normal,uvalue=uv)

		widget_control,bad_id=i,event.id,set_uvalue=uv
		widget_control,bad_id=i,base,group_leader=lamp_b1,set_uvalue=uv(1),/realize & put_logo
		widget_control,bad_id=i,lob,get_value = loob
		uvv(6)=loob & uvv(7)=lyb
		widget_control,bad_id=i,lub,set_uvalue= uvv
		XMANAGER, 'BROWS' ,base ,event_handler='LAMP_EVENT_PARSER',/just_reg
	endif
	if uv(1) eq 563 then begin
		runtxt=lamp_man(event.index)  & uv(1)=577
		if strpos(runtxt,strlowcase(inst_value)+'_') eq 0 then begin ;(Sub dir)
		  uv(1)=564
		  uv(2)=event.id
		  event.id=uv(7)
		  widget_control,bad_id=i,uv(7),set_value=runtxt
		endif else begin
		  icoco =1
		  idx   =strpos(runtxt,'.Z')    & if idx gt 0 then runtxt=strmid(runtxt,0,idx)
		  widget_control,bad_id=i,uv(3),set_value=runtxt
		endelse
	endif
	if uv(1) eq 564 then begin
		widget_control,bad_id=i,event.id,get_value=newsub   &   newsub=strcompress(newsub(0),/remove_all)
		if newsub ne '' then begin l_man=findfile(sys_dep('INSUB',path_for_online,newsub)    ,count=n)
		      if n eq 0 then	   l_man=findfile(sys_dep('INSUB',path_for_online,newsub)+'*',count=n)
		      if n gt 2 then begin lamp_man=l_man
					   poth=path_for_online+newsub & ln=strpos(strupcase(lamp_man(0)),strupcase(poth))
					   if ln lt 0 then begin poth=path_for_online & ln=strpos(strupcase(lamp_man(0)),strupcase(poth)) & endif
					   if ln ge 0 then lamp_man=strmid(lamp_man,ln+strlen(poth),30)
					   surp=strmid(lamp_man(0),0,1) & if surp eq lamp_dvd then lamp_man=strmid(lamp_man,1,30)
					   widget_control,bad_id=i,uv(2),set_value=lamp_man
		      endif
		endif
	endif

;**Browse URL
	if uv(1) eq 567 then begin widget_control,uv(3),bad_id=ii,get_uvalue=url
	                           bid=sys_dep('BROWSE',url) & endif

;**More for Instrument specific
	if uv(1) eq 568 then begin widget_control,uv(3),bad_id=ii,get_uvalue=stuc
	if (xregistered('A_'+stuc.macro)) eq 0 then begin
		bas  =widget_base  (title=stuc.macro,/column,resource_name='lampmic')
		llg  =widget_base  (bas,/row) & put_logo,llg
		bid  =widget_label (llg,value=stuc.macro   ,font=ft_biggest)
		bid  =widget_label (llg,value=stuc.author  ,font=ft_b_normal)
		if stuc.link gt ' ' then begin
		  bod=widget_button(llg,value='Url'        ,font=ft_b_normal,/menu)
		  widget_control,bod,bad_id=ii,set_uvalue = stuc.link
		  bid=widget_button(bod,value=stuc.link    ,font=ft_b_normal,uvalue=[-88,567,0,bod])
		endif
		bid  =widget_label (bas,value=stuc.purpose ,font=ft_b_bigger)
		for i=1,n_elements(stuc.more)-1 do $
		bid  =widget_label (bas,value=stuc.more(i) ,font=ft_b_normal)
		bss  =widget_base  (bas,/row)
		txt  =widget_text  (bss,value=stuc.call    ,font=ft_propor,/editable,xsize=50,ysize=1)
		bid  =widget_button(bss,value='Do'         ,font=ft_b_normal,uvalue=[-88,214,20,txt,0])

		widget_control,bas,group_leader=lamp_b1,/realize
		if stuc.logo gt ' ' then put_logo, file=stuc.logo else put_logo
		XMANAGER,'A_'+stuc.macro,bas,event_handler='LAMP_EVENT_PARSER',/just_reg
	endif & endif

;**Run macro for Instrument specific
	if uv(1) eq 569 then begin
		CASE uv(3) of
		-1:  begin spec_wplot,event,runtxt
		     if runtxt gt '' then begin
			uv=[-88,579,b_labins(7),lamp_ben(15),lamp_ben(16)]
			widget_control,bad_id=i,uv(3),set_value=runtxt & endif
		     end
		ELSE:begin
		     catch,stat & ii=0
		     if  stat eq 0 then begin widget_control,uv(4),get_uvalue=run
		     			      idp=strpos(run,'.prox') & if idp gt 0 then run=strmid(run,0,idp)
		     			      if idp le 0 then ii=execute(run) else P_LAYOUT,prox=run & endif
		     catch,/cancel
		     if (stat ne 0) or (ii ne 1) then $
		     if (b_labins(6)) and (b_labins(7) gt 0 ) then widget_control,b_labins(7),bad_id=ii,set_value=!err_string $
		                                              else widget_control,l_message  ,bad_id=ii,set_value=!err_string
		     end
		ENDCASE
	endif

;**Instrument specific
	if uv(1) eq 570 then if n_elements(lamp_ben) ge 15 then $
	                        if lamp_ben(10) gt 0 then begin
		                    widget_control,bad_id=ii,lamp_ben(10), get_uvalue=bu
		                    widget_control,bad_id=ii,lamp_ben(7) , map=0
		if GEORGE eq 2 then widget_control,bad_id=ii,lamp_ben(8) , map=0
		                    widget_control,bad_id=ii,lamp_b1     , scr_xsize=bu(3)
		                    widget_control,bad_id=ii,lamp_ben(0) , map=1
		                    widget_control,bad_id=ii,lamp_ben(10), map=1
		if GEORGE eq 2 then widget_control,bad_id=ii,lamp_ben(13), sensitive=1
		                    widget_control,bad_id=ii,lamp_ben(14), sensitive=1
		                    widget_control,bad_id=ii,lamp_ben(12), sensitive=1
		if uv(3) gt 0 then uv7=uv(7) else uv7=uv(3)
		if (bu(0) ne uv7) or (uv7 lt 0) then begin
		   widget_control,bu(1),bad_id=ii,/destroy & bu(0) =uv7
		   bu(1)=widget_base(lamp_ben(11),/column,y_scroll =fix(lamp_siz/2.1)<435)
		   tmpbase=0 & P_messi,tmpbase,bu(1)
		   widget_control,lamp_ben(10),bad_id=ii,set_uvalue=bu
		   widget_control,bu(2) ,bad_id=ii, set_value='-------------'

		   CASE uv7 of
		   -1:	begin widget_control,bu(2) ,bad_id=ii, set_value='SPEC contents'
			spec_wlist,bu(1)
			end
		   ELSE:begin titl='MACROS LIST'
			if event.id gt 0 then widget_control,event.id    ,bad_id=ii, get_value=titl
			widget_control,bu(2)       ,bad_id=ii, set_value=strupcase(strmid(titl,0,15))
			widget_control,uv(3)       ,bad_id=ii,get_uvalue=fifis
			fifi=fifis(uv(7))
			topic='' & macr='' & purp='' & auth='' & coll='' & bmc=0 & more=[''] & icof='' & lnk=''
			on_ioerror,misfifi & lun=-1  & lin=''
			OPENR,lun,fifi,/get_lun
			while not eof(lun) do begin
			READF,lun,lin & lon=strlowcase(lin)

			if (strpos(lon,'topic:') ge 0) or (strpos(lon,'macro:') ge 0) then $
						   if n_elements(more) gt 1 then if bmc gt 0 then begin
						      widget_control,bmc,set_uvalue=$
						      {topic:topic,macro:macr,purpose:purp,author:auth,call:coll,more:more,logo:icof,link:lnk}
						      bid=widget_button(bmc  ,value='More...',font=ft_propor,uvalue=[-88,568,b_labins(7),bmc])
						      endif
			c=strpos(lon,'topic:')	 & if c ge 0 then begin topic=strmid(strtrim(strmid(lin,c+6,150),2),0,13)
						   if bmc gt 0 then $
						   bid  =widget_label (bu(1),value='---')
						   bid  =widget_label (bu(1),value=topic ,font=ft_b_normal)
						   macr='' & purp='' & auth='' & coll='' & bmc=0 & more=[''] & lnk='' & endif

			c=strpos(lon,'macro:')	 & if c ge 0 then begin
						   macr =strmid(strtrim(strmid(lin,c+6,150),2),0,13)
						   bmc  =widget_button(bu(1),value=macr  ,font=ft_b_normal,menu=2)
						   purp='' & auth='' & coll='' & more=[''] & lnk='' & endif

			c=strpos(lon,'purpose:') & if c ge 0 then begin purp =strmid(strtrim(strmid(lin,c+8,150),2),0,80)
						   if bmc gt 0 then  if purp gt ' ' then $
						   bid  =widget_button(bmc  ,value='Purpose: '+purp,font=ft_propor) & endif

			c=strpos(lon,'author:')	 & if c ge 0 then begin auth =strmid(strtrim(strmid(lin,c+7,150),2),0,80)
						   if bmc gt 0 then  if auth gt ' ' then $
						   bid  =widget_button(bmc  ,value='Author:  '+auth,font=ft_propor) & endif

			c=strpos(lon,'call:')	 & if c ge 0 then begin coll =strmid(strtrim(strmid(lin,c+5,150),2),0,80)
						   if bmc gt 0 then  if coll gt ' ' then $
						   bid  =widget_button(bmc  ,value='Call:    '+coll,font=ft_propor) & endif

			c=strpos(lon,'more:')	 & if c ge 0 then more=[more, strmid(strtrim(strmid(lin,c+5,150),2),0,80)]

			c=strpos(lon,'run:')	 & if c ge 0 then begin run  =strmid(strtrim(strmid(lin,c+4,150),2),0,150)
						   if bmc gt 0 then  if run gt ' ' then begin
						   widget_control,bmc,set_uvalue=run
						   bid  =widget_button(bmc  ,value='Run....',font=ft_propor,uvalue=[-88,569,b_labins(7),0,bmc])
						   endif & endif

			c=strpos(lon,'logo:')	 & if c ge 0 then begin icof =strmid(strtrim(strmid(lin,c+5,60 ),2),0,40)
						   p=strpos(strlowcase(fifi),'a_list') & cof =''
						   if p gt 0 then cof=strmid(fifi,0,p) & icof=cof+icof & endif

			c=strpos(lon,'link:')	 & if c ge 0 then lnk=strmid(strtrim(strmid(lin,c+5,150),2),0,150)

			endwhile
						   if n_elements(more) gt 1 then if bmc gt 0 then begin
						      widget_control,bmc,set_uvalue=$
						      {topic:topic,macro:macr,purpose:purp,author:auth,call:coll,more:more,logo:icof,link:lnk}
						      bid=widget_button(bmc  ,value='More...',font=ft_propor,uvalue=[-88,568,b_labins(7),bmc])
						   endif

			misfifi:if lun gt 0 then FREE_LUN,lun
			end
		   ENDCASE
		   P_messi, tmpbase,bu(1)
		endif
	endif
;**LampINX
	if uv(1) eq 571	then if uv(2) eq 1 then inx $
			else if uv(2) eq 2 then qens_fit

;**Workspace operations.
	if uv(1) eq 572 then case uv(3) of
		1: begin W_store   ,/ALL
			 widget_control,uv(4),bad_id=ii,sensitive=1
			 widget_control,uv(5),bad_id=ii,sensitive=1
		   end
		2:	 W_restore ,/ALL
		3:	 W_exchange,/ALL
		4:	 W_clear   ,/ALL
		else:
		endcase
;**Idl help
	if uv(1) eq 573 then language_help

;**Create display function site UI.
	if uv(1) eq 574 then $
		 if lamp_fsite gt ' ' then  iii=execute(lamp_fsite) $
		 else widget_control,bad_id=i,l_message,set_value=  $
		 		    'Well, indeed, so, good .. need to be customized!'
;**Create access site UI.
	if uv(1) eq 575 then $
		 if lamp_asite gt ' ' then  iii=execute(lamp_asite) $
		 else widget_control,bad_id=i,uv(2)    ,set_value=  $
		 		    'Well, indeed, so, good .. need to be customized!'

;**Change Path
	if uv(1) eq 576 then if event.type lt 3 then begin my_path(1)='1'
			     if event.type eq 0 then if event.ch eq byte(10) then P_SET_PATH
			     endif
;**Get Run
	if (uv(1) eq 577) or (uv(1) eq 578) or (uv(1) eq 579) then begin

		widget_control,bad_id=i,uv(4),get_value=wnumber
		i =strpos (wnumber(0),'W')
		ws=strtrim(strmid(wnumber(0),i+1,4),2)
		wi=fix(ws)

		widget_control,bad_id=i,uv(3),get_value=runtxt
		runtxt=strtrim(strcompress(runtxt(0)),2)
		i =-1
		k =strpos(runtxt,'+') + $
		   strpos(runtxt,'-') + $
		   strpos(runtxt,':') + $
		   strpos(runtxt,'>')
		if k eq -4 then begin
		 i=strpos(runtxt,'.htm')
		 if i lt 0 then       i=strpos(runtxt,'LAMP.hdf')
		 if i lt 0 then       i=strpos(runtxt,'LAMP.xml')
		 if i lt 0 then       i=strpos(runtxt,'.nxs')
		 if i lt 0 then begin i=strpos(runtxt,'.hdf')
		                           ;if i gt 0 then if strlowcase(inst_group) ne 'nexus' then i=-1
					    endif
		 if i lt 0 then begin i=strpos(runtxt,'.xml')    & endif
		 if i lt 0 then begin i=strpos(runtxt,'.xdr')
		                            if i gt 0 then runtxt=strmid(runtxt,0,i)+'.htm'  & endif
		 if i lt 0 then begin i=strpos(runtxt,'.zip')
		                            if i gt 0 then runtxt=strmid(runtxt,0,i)+'.htm'  & endif
		 if i lt 0 then begin i=strpos(runtxt,'_LAMP')
		                            if i gt 0 then begin
				                           runtxt=strmid(runtxt,0,i)+'_LAMP'
		                                           bid   =sys_dep('POT',runtxt)      & endif
		 endif
		endif
		if i gt 0 then begin
		    j = strpos(runtxt,'{')
		    if (j gt 0) and (uv(1) eq 578) then begin
		 	k=strpos(runtxt,'}')
			strun =strtrim(string(strmid(runtxt,j+1,k-j-1)+1),2)
			runtxt=strmid (runtxt,0,j+1)+strun+'}'
        	    endif
		    READ_LAMP,runtxt, w=wi, path=path_for_online
		    widget_control,bad_id=i,uv(3),set_value=runtxt
		    if (uv(1) gt 577) then P_DID_EVENT,0,[-88,301,0,wi,0]

		endif else begin  if (strpos(runtxt,'.gif') le 0) and $
		                     (strpos(runtxt,'.jpg') le 0) and $
		                     (strpos(runtxt,'.png') le 0) then GMY_run, uv,runtxt, wi $
		                  else READ_myGIF,path_for_online+runtxt,w=wi
		endelse
		if icoco eq 1 then begin wset,uv(6) & erase,255 & xx=1L & yy=1L & wr=1L
				   i=execute('xx = x' +ws) & i=execute('yy = y' +ws)
				   p_did_makeicon, ws,xx,yy, 192,192 ,0 ,wr ,'i'
		                  widget_control,bad_id=i,l_message,set_value='Read in W'+ws & endif
	endif
;**FIT
	if (uv(1) eq 580) then iii=execute('gfit')

;**Helps
	if (uv(1) ge 585) and (uv(1) le 598) then show_helps,uv
return
end

pro	GMY_run   ,uv ,runtxt ,wi
;**	*******
		 status=12
		 j = strpos(runtxt,'{')
		 if (j gt 0) and (uv(1) eq 578) then begin
		 	k=strpos(runtxt,'}')
			strun =strtrim(string(strmid(runtxt,j+1,k-j-1)+1),2)
			runtxt=strmid (runtxt,0,j+1)+strun+'}'
			widget_control,bad_id=i,uv(3),set_value=runtxt
        	 endif

		 i =rstrpos(runtxt,'.')
		 k = strpos(runtxt,'+') + $
		     strpos(runtxt,'-') + $
		     strpos(runtxt,':') + $
		     strpos(runtxt,'>')

		 on_ioerror,misrun
		 if (i lt 0) or ((j gt 0) and (k gt -4)) then begin
		    if k gt -4 then begin
		         P_DID_GET_IT,runtxt              ,wi,status,uv ,'opr'
			 if ((uv(1) gt 577) and (status eq 0)) then P_DID_EVENT,0,[-88,301,0,wi,0]
		         return
		    endif

		                         j =strpos(strupcase(runtxt),' SUMTO ')
		    if j lt 0 then begin j =strpos(runtxt,'>')
		       			 if j gt 0 then j=j+100 & endif
		    if j lt 0 then	 i =strpos(strupcase(runtxt), ' TO ')

		    if (i le 0) and (j le 0) then begin
		      k=0 & for i=0,strlen(runtxt)-1 do begin car   =strmid(runtxt,i,1)
		                if (car lt '0') or (car gt '9') then k=1   &  endfor
		      if k eq 0 then begin
		         run=float(runtxt)
		         run=long (run)
		         if (uv(1) eq 578) then begin
		 	     run   =run+1
		 	     runtxt=strtrim(string(run),2)
			     widget_control,bad_id=i,uv(3),set_value=runtxt
			     endif

		         status=1
		         P_DID_GET_IT,run              ,wi,status,uv ,'run'

			 if ((uv(1) gt 577) and (status eq 0)) then P_DID_EVENT,0,[-88,301,0,wi,0]
		         return
		      endif
		    endif else if (uv(1) lt 578) then begin
		       cmd='w'+strtrim(string(wi),2)
		       if i gt 0 then begin
		          run1=float(strtrim(strmid(runtxt,0  ,i     ),2)) & run1=long (run1)
		          run2=float(strtrim(strmid(runtxt,i+4,lamp_6),2)) & run2=long (run2)
		          cmd =cmd+'=RDAND('
		       endif     else begin
		          run1=float(strtrim(strmid(runtxt,0  ,j),2))        & run1=long (run1)
		          if j lt 100 then k=6 else begin k=1 & j=j-100      & endelse
		          run2=float(strtrim(strmid(runtxt,j+k,lamp_6+1),2)) & run2=long (run2)
		          cmd =cmd+'=RDSUM('
		       endelse
		       cmd =cmd+strtrim(string(run1),2)+','+strtrim(string(run2),2)+',z0)'
		       z0  =-1
		       xicuter ,cmd
		       if z0 gt 0 then begin prt='Missing '  +string(z0)
			  if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value=prt else print,prt
 		       endif
		       return
		    endif
		 endif
		 misrun:
		 P_DID_GET_IT,runtxt,wi,status,uv ,'fil'
		 if ((uv(1) gt 577) and (status eq 0)) then P_DID_EVENT,0,[-88,301,0,wi,0]
end

pro	SHOW_HELPS, uv
;**	**********
@lamp.cbk

	 if uv(1) eq 585 then widget_control,bad_id=i,lamp_hlp,map=0 $
	 else begin
           iii=xregistered('HELPS')
	   if (iii gt 0) then begin
	   	widget_control,bad_id=i,lamp_hlp,get_uvalue=uval
	   	if uval eq uv(1) then widget_control,bad_id=i,lamp_hlp,map=1
	   	if uval ne uv(1) then widget_control,bad_id=i,lamp_hlp,/destroy
	   	if uval ne uv(1) then iii=0
	   endif
	   if (iii le 0) then begin
	    formu='' & formt='' & ttl=''

	    if uv(1) eq 586 then begin
	    			 ttl='READING INTO WORKSPACES'
				 if (not sys_dep('RUNTIME')) and (not sys_dep('EMBEDDED'))   then begin
				    iii= execute('myhelp_'+strlowcase(inst_value)+',formu')     & endif
				 if n_elements(formu) le 1 then iii= execute('myhelp,formu')
				 if n_elements(formu) le 1 then p_did_help,uv(1),formu,formt $
				 else ttl='MYHELP.PRO'
	    endif
	    if uv(1) eq 587 then begin
	    			 ttl='DISPLAYING THE WORKSPACES'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 588 then begin
	    			 ttl='A few TIPS (See INTERNAL in User Macros?)'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 589 then begin
	    			 ttl='CALLING OTHER DISPLAY FACILITIES'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 590 then begin
	    			 ttl='GK_FIT FITTING FACILITY'
	    			 gfit_help ,uv(1),formu,formt
	    endif
	    if uv(1) eq 591 then begin
	    			 ttl='SUPERPLOT : The Multipurpose Superpose Plotting Tool for Lamp'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 592 then begin
	    			 ttl='SELECTING RUNS'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 593 then begin
	    			 ttl='3 AXES FACILITY'
	    			 ii=execute('tx_help,uv(1),formu,formt')
	    endif
	    if uv(1) eq 594 then begin
	    			 ttl='SELECTING RUNS'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 595 then begin
	    			 ttl='PAD for Command Control'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 596 then begin
	    			 ttl='HELP for Instrument macros'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) gt 596 then return

	    lamp_hlp=widget_base   (title='Lamp helps those who help themselves',$
	    			    resource_name='lamptouch',/column)
	    lamp_hls=widget_base   (lamp_hlp,/column)
	    lab	    =widget_base   (lamp_hls,/row)
		     put_logo	   ,lab
	    lab	    =widget_label  (lab     ,value=ttl,font=ft_biggest)

	    if n_elements(formu) ne n_elements(formt) then $
		blab=widget_text   (lamp_hls,value=formu,xsize=80,ysize=30,font=ft_b_normal,/scroll)$
	    else for i=0,n_elements(formu)-1 do begin
	         blab=widget_base   (lamp_hls,/row)
	         lab=widget_label  (blab    ,value=formu(i)    ,font=ft_b_bigger)
	         lab=widget_label  (blab    ,value=formt(i)    ,font=ft_normal)
	    endfor

	    base_wel=widget_button (lamp_hlp,value='Hide'      ,font=ft_b_normal ,$
	   			    uvalue=[-88,585,0])
   	    bid=sys_dep      ('DYNLAB',lamp_hlp,0)
	    widget_control,bad_id=i,lamp_hlp,group_leader=lamp_b1,set_uvalue=uv(1),/realize & put_logo
	    XMANAGER, 'HELPS' ,lamp_hlp ,event_handler='LAMP_EVENT_PARSER',/just_reg
	   endif
	 endelse
return
end

pro	P_SET_PATH,ppth
;**	**********
@lamp.cbk
	   my_path(1)=''

	   if n_elements(ppth) eq 1 then  path=[ppth] $
	   else widget_control,long(my_path(2)),bad_id=i,get_value=path
	   path=path(0)
	   stat=0
	   catch,stat
	   if stat ne 0 then begin
	        catch,/cancel
		P_MUS,'mus_cannon'
	   	path=path+'???'
		if n_elements(ppth) eq 0 then $
	        widget_control,long(my_path(2)),bad_id=i,set_value=path,SET_TEXT_SELECT=[strlen(path),0]
 	        print,string(7b)+path
	   	return
	   	endif

	   if n_elements(ppth) eq 0 then DON_WRITE_PROG_MAC ,0
	   cd,path
	   if n_elements(ppth) eq 1 then $
		widget_control,long(my_path(2)),bad_id=i,set_value=path,SET_TEXT_SELECT=[strlen(path),0]
	   my_path(0)=path
	   DON_INIT_INST_MACS ,1
	   DON_INIT_PROG_MAC  ,1
return
end

pro	P_FCT_CREATE ,base ,bas_geo2
;**	************
@lamp.cbk
	if GEORGE eq 1	then   base0      =lamp_ben(2) $
	else		begin  lamp_ben(4)=widget_base(base ,/frame,resource_name='ben')
			       base0      =widget_base(lamp_ben(4),/column)
	endelse
	base1=widget_button(base0,font=ft_normal   ,value=lamp_fsite          ,uvalue=[-88,574,0,0])
	b_labins(2) =base1
	base1=widget_button(base0,font=ft_normal   ,value=' Load new Colors  ',uvalue=[-88,347])
	base1=widget_button(base0,font=ft_normal   ,value='     GK_Fit       ',uvalue=[-88,580,0,0])
	lamp_don   =[lamp_don,base1]
	base1=widget_button(base0,font=ft_normal   ,value='    SuperPlot     ',uvalue=[-88,352])
	lamp_don   =[lamp_don,base1]

	if GEORGE eq 2 then begin
	  ;base1=widget_button(bas_geo2,font=ft_normal   ,value=' Load new Colors  ',uvalue=[-88,347])     ;removed for george=2
	  ;base1=widget_button(bas_geo2,font=ft_normal   ,value='     GK_Fit       ',uvalue=[-88,580,0,0]) ;removed for george=2
	  ;base1=widget_button(bas_geo2,font=ft_normal   ,value='    SuperPlot     ',uvalue=[-88,352])     ;removed for george=2
	endif

	if GEORGE eq 1 then begin
	  bid=widget_button(base0,font=ft_normal   ,value='      ------      ')
;	  bid=widget_button(base0,font=ft_normal   ,value='   Dial Macros?   ',uvalue=[-88,203,0,0])
;	  bid=widget_button(base0,font=ft_normal   ,value='   The Journal    ',uvalue=[-88,396,0,0])
	  bid=widget_button(base0,font=ft_normal   ,value='   Data Params    ',uvalue=[-88,204,0,0])
	  if sys_dep('VERSION') ge 4.0 then widget_control,base0,/destroy
	endif

	if (lamp_siz ge 800) and (GEORGE ne 1) then begin
	if abs(sys_dep('MAP')) ne 1 then baba=base0 else baba=base
	brow =widget_base  (baba ,/row)
	lamp_don   =[lamp_don,brow]
	bs1bs=widget_button(brow ,font=ft_normal   ,value='SCAN W 1'          ,uvalue=[-88,306,0,0])
	if sys_dep('MAP') ne -1 then $
	bs1b1=widget_button(brow ,font=ft_smallest ,value='<',resource_name='discret') else $
	bs1b1=widget_button(brow ,font=ft_smallest ,value='<')
	if sys_dep('MAP') ne -1 then $
	bs1b2=widget_button(brow ,font=ft_smallest ,value='>',resource_name='discret') else $
	bs1b2=widget_button(brow ,font=ft_smallest ,value='>')
	widget_control,bad_id=i,bs1b1,set_uvalue=[-88,310,bs1bs,3,0,0,0,0,0]
	widget_control,bad_id=i,bs1b2,set_uvalue=[-88,311,bs1bs,3,0,0,0,0,0]
	endif

	if GEORGE eq 1 then begin GEORGEO, CONSTRUCT=base   &   base0=base & endif
	if GEORGE eq 2 then       GEORGEO, CONSTRUCT=lamp_ben(8)

	if GEORGE ne 1 then begin
	   lamp_ben(5)=widget_base  (base ,/frame,resource_name='ben')
	   base0=widget_base  (lamp_ben(5),/column)
	   if  (lamp_siz gt 950) or $
	      ((lamp_siz ge 900) and (sys_dep('MACHINE') eq 'mac')) then begin
      		      w0=2 & LOGO,w0 & pax1=size(w0)
      		      lamp_ben(6)=widget_draw (base0,retain=2,xsize=pax1(1),ysize=pax1(2),/button_event)
	   endif else begin  lamp_ben(3)=widget_label(base ,font=ft_smallest,value=' ' )
			     if lamp_siz lt 800  then put_logo,base
	   endelse
	   base1=widget_button(base0,font=ft_normal,value='    The Manual    '     ,uvalue=[-88,201,0])
	endif

	  base1=widget_button(base0      ,font=ft_normal,value='SAVE this Session ',uvalue=[-88,397])
	  lamp_don   =[lamp_don,base1]
	  base1=widget_button(base0      ,font=ft_normal,value='  SWITCH  OFF    ' ,uvalue=[-88,398])
	if GEORGE eq 2 then begin
	  base1=widget_button(lamp_ben(8),font=ft_normal,value='SAVE this Session ',uvalue=[-88,397])
	  base1=widget_button(lamp_ben(8),font=ft_normal,value='  SWITCH  OFF    ' ,uvalue=[-88,398])
	endif
return
end

pro MIC ,nocre
;** ***
;**
@lamp.cbk
common okitis, yo

	if n_elements(yo)    eq 0 then begin
	        keep_p=path_for_online & keep_i=inst_value  & keep_c=cycle
	   	P_RESTORE,lamp_dir+lamp_dvd+'mics.exe' ,cnt & ii=execute("MICS")
	   	yo=1
		ii=execute("P_MIC_CREATE ,0 ,'just'")
	        path_for_online=keep_p & inst_value=keep_i & cycle=keep_c
	endif

	if n_elements(nocre) eq 0 then begin
           i=xregistered('MIC')
	   if i gt 0 then widget_control,bad_id=i,lamp_mic,map=1 $
	   else begin
	        lamp_mic =widget_base (title='LAMP Data Instrument Access',resource_name='lampmic')
	   	ii=execute("P_MIC_CREATE ,(lamp_mic+0)")
   		bid=sys_dep      ('DYNLAB',lamp_mic,1)
		widget_control,bad_id=i   ,lamp_mic,group_leader=lamp_b1,/realize
		XMANAGER, 'MIC' ,lamp_mic ,event_handler='LAMP_EVENT_PARSER',/just_reg
	   endelse
	endif
return
end

pro	P_MUS  ,file
;**	*****
;**
@lamp.cbk
common  c_mus  ,mus_driv,mus_id,mus_fils

        if n_elements(mus_driv) lt 1 then begin
	   mus_driv =  ''
	   mus_id   =  0
	   if lamp_loc eq 1 then begin
		mus_driv=sys_dep      ('PLAYER')
;		cd,lamp_dir,current=mee
;		mus_fils=findfile     ('mus_*')
;		cd,mee
	   endif
        endif

        if n_elements(b_labins) ge 4 then if b_labins(3) eq 2 then mus_driv=''
	if mus_driv ne '' then begin
	   if file  eq '' then begin if mus_id gt 0 then bid=sys_dep      ('PLAY_OF',0,0,0,mus_id)
	   			        mus_id =0
	   endif else bid=sys_dep      ('PLAY_ON',mus_driv,lamp_dir,file,mus_id)
	endif
	if strpos(file,'cannon') ge 0 then p_tremble
return
end

pro	MANUAL ,res
;**	******
;**
@lamp.cbk
	res=''
	if lamp_dir eq '' then man_dir=sys_dep('HOME') else man_dir=lamp_dir
	res=sys_dep      ('MANUAL',man_dir,lamp_macro)
	if l_message gt 0 then widget_control,bad_id=iii,l_message,set_value=$
			 'See '+res
end

pro	P_MESSI , base ,topb
;**	*******
;**
@lamp.cbk
map=abs(sys_dep('MAP'))
if map eq 0 then return

if map eq 1 then begin
   if base  le 0 then begin
	     base =widget_base  ( title='Lamp')
	     bid  =widget_label ( base,value='LAMP RECONSTRUCTION ...',font=ft_b_bigger)
	     widget_control,topb ,bad_id=i,map=0
	     widget_control,base ,group_leader=topb   ,bad_id=i,/realize
   endif   else  begin
	     widget_control,base ,bad_id=i,/destroy
	     widget_control,topb ,bad_id=i,map=1
   endelse
endif
if map eq 2 then begin
   if base  le 0 then begin
   	    base=1 &  widget_control,bad_id=i,topb,UPDATE=0
   endif else 	      widget_control,bad_id=i,topb,UPDATE=1
endif
return
end

pro 	dynlabel_call, w
;**	*************
        type = WIDGET_INFO(w, /TYPE)
;       IF ((type EQ 1) OR (type EQ 5)) THEN BEGIN
        IF ((type EQ 1))  THEN BEGIN
                WIDGET_CONTROL, /DYNAMIC_RESIZE, w
        ENDIF ELSE IF (type EQ 0) THEN BEGIN
                child = WIDGET_INFO(W, /CHILD)
                WHILE (child NE 0) DO BEGIN
                  DYNLABEL_CALL, CHILD
                  CHILD = WIDGET_INFO(CHILD, /SIBLING)
                ENDWHILE
        ENDIF
END

pro	resizeButton_call, w ,val
;**	*****************

        type = WIDGET_INFO(w, /TYPE)
        IF (type EQ 1) THEN BEGIN
            geo = WIDGET_INFO(w, /GEOMETRY)
            WIDGET_CONTROL, w, XSIZE=(geo.scr_xsize+val)>15

        ENDIF ELSE IF (type EQ 0) THEN BEGIN
            child = WIDGET_INFO(W, /CHILD)
            WHILE ( child NE 0 ) DO BEGIN
            	    resizeButton_call, child,val
            	    child = WIDGET_INFO(child, /SIBLING) & ENDWHILE
        ENDIF
END

pro	P_DYING,id
;**	*******
@lamp.cbk
	if l_message eq 0 then exok=1 else exok=0
	lamp_b1 =0 ;<---  IMPORTANT
	if GEORGE  ne 0 then WebOff
	P_MUS,'mus_cannon'
	DON_WRITE_PROG_MAC ,1
	DID_WRITE_JOURNAL
	wait,.3 & EMPTY
	if (sys_dep('EMBEDDED')  or sys_dep('RUNTIME')) then EXIT
	rout=[1L]
	if  sys_dep('VERSION') ge 5.1 then ii=execute('rout=widget_info(/managed)')
	if  rout(0)  gt 0 then exok=0 else exok=1
	if (sys_dep('MACHINE') eq 'unix') and (exok)    then EXIT
return
end

pro	P_LAMP_STOP
;**	***********
@lamp.cbk
@dons.cbk
	   stat=0
	   catch,stat
	   if stat eq 0 then widget_control,bad_id=i,lamp_b1,show=0
	   if stat eq 0 then bid=sys_dep('AFTES')
	   if stat eq 0 then print,string(7b),' Type RETALL & LAMP to continue'
	   if stat eq 0 then stop
return
end

pro	P_LAMP_INIT, lamp_ziz=lps, george=geo
;**	***********
@lamp.cbk
	if n_elements(lps) eq 1 then lamp_ziz =lps
	if n_elements(geo) eq 1 then george   =geo
return
end

pro	P_DO_THAT
;**	*********
;**
@lamp.cbk
 lamd_dir =           sys_dep('GETENV','LAMP_DIR' )
 lamd_wind=strlowcase(sys_dep('GETENV','LAMP_WIND'))

 while strpos(!path,'..') ge 0 do begin
    i1=strpos(!path,'..')
    if strpos(!path,'..\..') ge 0 then j1=5  else j1=2
    if strpos(!path,'../..') ge 0 then j1=5
    if i1 gt 0 then deb=strmid(!path,0,i1-1) else deb=''
    !path=deb+lamd_dir +strmid(!path,i1+j1,300)
 endwhile

 cd,current=mee
 if  strtrim  (!path,2)    eq '.'  then !path=mee else $
 while (strpos(!path,'.\') ge 0) or (strpos(!path,'./') ge 0) do begin
    i1= strpos(!path,'.\') & if i1 lt 0 then i1=strpos(!path,'./')
    if i1 gt 0 then deb=strmid(!path,0,i1-1) else deb=''
    !path=deb+ mee +strmid(!path,i1+1,300)
 endwhile

 if  strtrim  (!dir,2)     eq '.'  then !dir =mee

 catch,stat & if stat eq 0 then begin cd,!dir+sys_dep('DIVIDER')+".."         & cd,current=meelam
 				      cd,meelam+sys_dep('DIVIDER')+"lamp_mac" & cd,current=meemac
				      lamd_dir=meelam
				      bid=sys_dep("ADDPATH",meemac)
				      bid=sys_dep("ADDPATH",meelam) & lamp_dir=meelam
 				endif
 catch,stat & if stat eq 0 then begin pth=sys_dep("NEWSUB",lamd_dir,"work") & cd,pth & endif
 if sys_dep('MACHINE') eq 'unix' then cd,mee

 if strpos (!path,"lamp_mac") le 0 then begin
    pth  =sys_dep("NEWSUB" ,lamd_dir,"lamp_mac")
    bid  =sys_dep("ADDPATH",pth)
    endif

 if (!D.flags and 65536)   eq 0 then set_plot,'TEK' else $
 if strpos(lamd_wind,'nw') ge 0 then set_plot,'Z'
 if  sys_dep('STUDENT')                then lamp_ziz=600
 if (strpos(lamd_wind,'small'  ) ge 0) then lamp_ziz=480
 if (strpos(lamd_wind,'medium' ) ge 0) then lamp_ziz=600
 if (strpos(lamd_wind,'large'  ) ge 0) then lamp_ziz=800
 if (strpos(lamd_wind,'wide'   ) ge 0) then lamp_ziz=1024
 GEORGE=2
 if (strpos(lamd_wind,'lamp')    ge 0) then GEORGE  =0
 if (strpos(lamd_wind,'geo')     ge 0) then GEORGE  =1
 if (strpos(lamd_wind,'lampgeo') ge 0) then GEORGE  =2
 if (strpos(lamd_wind,'geolamp') ge 0) then GEORGE  =2
 if (strpos(lamd_wind,'full')    ge 0) then GEORGE  =3
end

pro     SL_RESTSCAN, file, cnt
;**     ***********
;**
@lamp.cbk
	P_RESTORE,file ,cnt
	if cnt eq 0  then  P_RESTORE,!dir+lamp_dvd+'lib'+lamp_dvd+'hook'+lamp_dvd+'scan.sav' ,cnt
	if cnt gt 0  then  begin
		   	sl_lampscan, 'test' ,did_scan,tso
		   	if did_scan ge 0 then ii=execute('scan,1') else cnt=0
      	endif
end
pro     SL_SCANLOAD, p1,p2
;**     ***********
;**
	if p1 eq -1 then begin
			   VV =strtrim(string(sys_dep('VERSION')),2)
			   VV =strmid (VV,0,1)+strmid (VV,2,1)
			   pth=sys_dep("NEWSUB" ,p2,"lamp_mac")
			   SL_RESTSCAN,pth+'scan'+VV+'.sav' ,cnt
			   if cnt le 0 then p1=-2 else p1=1
	endif
end
pro   LANGUAGE_HELP
;**   *************
	  if sys_dep('VERSION') ge 5.0 then ii=execute('online_help' ) $
	                               else ii=execute('man_proc,"?"')
end

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; Procedures for Mini-Lamp ****** END OF LAMP_UPD.PRO
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

pro	P_RESTORE,file,cnt	;******keep this side******
;**	*********

		cnt= 0
		i  = findfile(file,count=cnt)
		if cnt gt 0  then iii=EXECUTE('restore,file')
return
end

pro	P_DON_CREATE ,base
;**	************
@lamp.cbk
	base0=widget_base     (base ,/column)
	base1=widget_base     (base0,/row)
	btitl=widget_label    (base1,font=ft_biggest,value=' FORMULA ENTRY')
	bhelp=widget_button   (base1,font=ft_normal ,value='?'	      ,uvalue=[-88,201,0])
	bform=widget_text     (base1,font=ft_b_bigger,xsize=50,ysize=1,/editable,uvalue=[-88,200,0])
	bsav =widget_button   (base1,font=ft_normal ,value='Extend...',uvalue=[-88,222,0])
	l_message=widget_label(base0,font=ft_normal)
end

pro	P_DID_CREATE ,base
;**	************
@lamp.cbk
	bs0  =widget_base  (base ,/column)
	bs1  =widget_base  (bs0  ,/row) & base1=widget_base(bs1,/row)
	btitl=widget_label (base1,font=ft_biggest,value=' DISPLAY WORKSPACE')
	bhelp=widget_button(base1,font=ft_normal ,value='Extend...',uvalue=[-88,342,0])

	bsrow=widget_base  (bs0  ,/row)
	bsopt=widget_base  (bsrow,/column,/frame)
	baswb=widget_base  (bsrow)
	d_x  =512
	d_y  =256
	if lamp_siz gt  950 then d_y  =320
	if lamp_siz lt  800 then d_x  =300
	if lamp_siz lt  800 then d_y  =230
	bdraw=widget_draw  (baswb,xsize=d_x,ysize=d_y)
	lamp_wrd     =bdraw
	lamp_did(0:5)=[lamp_did(0),base1,bs1,bsrow,bsopt,bdraw]
end
pro	P_BEN_CREATE ,base,f
;**	************
@lamp.cbk
	base0=widget_base  (base ,/column)
	base1=widget_base  (base0,/row)
	btitl=widget_label (base1,font=ft_biggest,value=' DISPLAY')
	bhelp=widget_button(base1,font=ft_normal ,value='x',uvalue=[-88,422,0])
	btitl=widget_label (base0,font=ft_biggest,value=' FUNCTIONS')
end
pro	P_MIC_CREATE ,base,p2
;**	************
end
pro 	P_DID_PS_HEADER,p1,p2,p3
;**	***************
end
pro	P_AFTER_REALIZE_DID, s1,s2,s3
;**	*******************
@lamp.cbk
	widget_control,lamp_wrd,bad_id=i,get_value=did_win0 & lamp_wrd='?'
	wset,did_win0 & erase,100
end
pro	P_DATA_ACCESS, p1,p2,p3,p4,p5
;**	*************
end
pro	CLEARPAR, p1,p2
;**	********
end
pro	MOVEPAR, p1,p2,p3,p4
;**	*******
end
pro	SETDATP, p1
;**	*******
end
pro	GETDATP, p1
;**	*******
end
pro	SETCOL,  n
;**	******
	if (n ge 0) and (n lt 40) then loadct,n
end
pro	TO_DID_CUR, dummy
;**	**********
end
pro	P_DID_GETW_CUR,p1,p2
;**	**************
	p1=1 & p2='1'
end
pro 	P_DID_HELP, flg, formu,formt
;** 	**********
end
pro     DID_WRITE_JOURNAL
;**     *****************
end
pro     P_DID_SETWIN0
;**     *************
end
pro	PUT_LOGO       ,p1,TIO=p2 ,FILE=p3
;**     ********
end
pro     P_DID_GET_IT   ,p1,p2,p3,p4,p5
;**     ************
end
pro     P_MIC_GETRUN   ,p1,p2,status
;**     ************
	status=3
end
pro     P_MIC_SETRUN   ,p1,p2,p3,p4
;**     ************
end
pro     TO_DON_HISTORY ,p1,p2,p3
;**     **************
end
pro     MAC_LIST       ,p1,fl,p3,THISFILE=p4
;**     ********
	fl=[' ']
end
pro     SL_LAMPSCAN, flg,p1,p2,p3,p4,p5
;**     ***********
;**
	if flg eq 'test' then begin p1=-1 & p2=0 & endif
end
function SL_ZOOM, x,y,xd,yx
;******* *******
;** Scan function
return, -1
end
pro	P_ZOOM,  x,y,xd,yx,bb
;**	******
        bb=sl_zoom(x,y,xd,yx)
end
pro	P_MIC_EVENT  ,event ,uv
;**	************
end
pro	P_DON_EVENT  ,event ,uv
;**	************
@lamp.cbk
common  for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

	widget_control,bad_id=iii,l_message,set_value=' '
       ;if uv(1) eq 201 then if sys_dep('MAP') le 0 then man_proc,'' else online_help
	if uv(1) eq 200 then begin
           widget_control,event.id,get_value=formu & formu=strtrim(formu(0),2)
           wset,did_win0
	   stat=0 & ii=1
	   catch,stat
	   if  (stat eq 0)  and   (ii eq 1) then $
  		if strpos(formu,'$') eq 0  then spawn,strmid(formu,1,100) $
  		else begin 	        ii=execute(formu)
  				        widget_control,bad_id=iii,event.id ,set_value='' & endelse
	   if ii ne 1 or stat ne 0 then widget_control,bad_id=iii,l_message,set_value=!err_string
	endif
return
end

pro	P_DID_EVENT  ,event ,uv
;**	************
;**
@lamp.cbk

        CASE uv(1) of

	342:
;**	Load colors
;**	---- ------
	347:	begin
		i=xregistered('xloadct')
		if i lt 1 then xloadct,group=lamp_b1,/use_current
		end

;**	Multi_plot create
;**	---------- ------
	352:suprplot, 0

;**	Multi_plot event (353:slider_w_x_y 354:slider_range 355:keep etc. 356:buttons)
;**	---------- -----
	353:	p_rom_super_event, event,uv
	354:	p_rom_super_event, event,uv
	355:	p_rom_super_event, event,uv
	356:	p_rom_super_event, event,uv
;**	Exit
;**	----
	398:	widget_control,/reset
	else:	widget_control,l_message,set_value='!Not available from Mini_Lamp'
	ENDCASE
return
end
pro	P_BEN_EVENT  ,event ,uv
;**	************
@lamp.cbk
return
end
pro	P_EXTEND ,event ,uv
;**	********
@lamp.cbk
	if uv(1) eq 222 then begin
	   	P_RESTORE,lamp_dir+lamp_dvd+'dons.exe' ,cnt
		if cnt gt 0  then  begin
	           bastmp=0 & P_messi,bastmp,(lamp_b1+0)
	   	   widget_control,bad_id=i,lamp_don(0),/destroy
	   	   lamp_don(0) =widget_base  (lamp_b1 ,/frame,resource_name='don')
	   	   P_DON_CREATE ,(lamp_don(0))
   		   bid=sys_dep      ('DYNLAB',lamp_don(0),0)
	   	   P_messi,bastmp,(lamp_b1+0)
	   	endif
	endif	else $
	if uv(1) eq 342 then begin
	        P_RESTORE,lamp_dir+lamp_dvd+'dids.exe' ,cntd
	        if cntd gt 0  then begin
	           bastmp=0 & P_messi,bastmp,(lamp_b1+0)
	           widget_control,bad_id=i,lamp_did(1),/destroy
	           P_DID_CREATE ,lamp_did(0) ,lamp_did(2:5)
   		   bid=sys_dep      ('DYNLAB',lamp_did(0),1)
	   	   P_messi,bastmp,(lamp_b1+0)
	   	endif
		SL_RESTSCAN,lamp_dir+lamp_dvd+'scan.exe'    ,cnt
		P_RESTORE  ,lamp_dir+lamp_dvd+'touch_b.exe' ,cnt

		if cntd gt 0  then P_AFTER_REALIZE_DID ,0,0,0
	endif   else $
	if uv(1) eq 422 then begin
	   	P_RESTORE,lamp_dir+lamp_dvd+'bens.exe' ,cnt
	   	if cnt gt 0  then  begin
		   bastmp=0 & P_messi,bastmp,(lamp_b1+0)
	   	   widget_control,bad_id=i,lamp_ben(2),/destroy
	   	   P_BEN_CREATE ,(lamp_ben(1)),0
   		   bid=sys_dep      ('DYNLAB',lamp_ben(1),0)
	   	   P_messi,bastmp,(lamp_b1+0)
	   	endif
	endif
return
end
pro	DON_INIT_INST_MACS, flg
;**	******************
return
end
pro	DON_INIT_PROG_MAC , flg
;**	*****************
return
end
pro	DON_WRITE_PROG_MAC, flg
;**	******************
return
end
pro	XICUTER, cmd
;**	*******
return
end
pro	XICUTE , cmd
;**	******
return
end
pro	SET_HISTORY
;**	***********
return
end
pro	READ_DATA
;**	*********
return
end
pro	P_TREMBLE
;**	*********
return
end
pro	LOGO, w
;**	*****
w=congrid(dist(64),128,64)
return
end

;------------------------------------------------------------------------------
;                                    Upgrade LAMP
;------------------------------------------------------------------------------
pro upg_kill,id
;** ********
common desk,whatdo,b11
widget_control,bad_id=i,b11(0),map=1
end

pro upi,lodtx,out
;** ***
;**
k=0
p_set_font,k ,lamp_font
a0=widget_base  (title='Lamp Upgrade',/column,resource_name='lamp')
a1=widget_base  (a0,/row,resource_name='mic')
lb=widget_label (a1,value='If you are behind a FireWall, enter the FTP Proxy:',font=lamp_font(5,k))
px=widget_text  (a1,value=out,xsize=10,ysize=1,/editable,font=lamp_font(5,k))
a2=widget_base  (a0,/row)
bt=widget_base  (a2,/column,resource_name='did')
ct=widget_text  (a2,xsize=60,ysize=8,/scroll,resource_name='don',font=lamp_font(5,k))
uv=[lodtx(0:5),0,px,ct,a0] & uv(3)=10
uv(6)=1 & b1=widget_button(bt,value='Read last News',uvalue=uv,font=lamp_font(3,k))
uv(6)=2 & b2=widget_button(bt,value='Upgrade Lamp'  ,uvalue=uv,font=lamp_font(3,k))
uv(6)=3 & b3=widget_button(bt,value='Cancel'        ,uvalue=uv,font=lamp_font(3,k))

w0=2 & LOGO,w0 & pax1=size(w0)
b4=widget_draw  (widget_base(bt,/row),xsize=pax1(1),ysize=pax1(2),retain=2)

widget_control,bad_id=i,lodtx(5),map=0
widget_control,bad_id=i,a0,/realize
widget_control,bad_id=i,b4,get_value=jj & wset,jj & tvscl,w0,0,0

XMANAGER, 'LAMP_UPG',a0,event_handler='DESKTOP_EVENT',CLEANUP='UPG_KILL',/just_reg
end

function ulamp,p1,p2,p3
;******* *****
;**
;p1=1	--> res=-1	bad lamp_dir
;	    res=-2	write not allowed
;	    res=0	ok
;p1=2	--> res='?'	Problem with .netrc
;	    res='.'	Unable to get the file
;	    res=lampnews.txt
;p1=3	--> res='?'	Problem with .netrc
;	    res='.'	Unable to get the file
;	    res='ok'	Got lamp_light.tar.Z
;p1=4	--> res=-1	faile
;	    res=0	MAKE_LAMP.unix successful

;p2=''	    no firewall
;p2='fname' firewall internal name
;p3= lamp_dir

ON_IOERROR,mispriv

IF p1 eq 1 THEN BEGIN
   res=-1 & OPENR,lun,p3+'lamp.pro',/get_lun	      & FREE_LUN,lun
   res=-2 & OPENW,lun,p3+'wrtest'  ,/get_lun,/delete & FREE_LUN,lun & res=0

ENDIF ELSE IF (p1 eq 2) or (p1 eq 3) THEN BEGIN

   f=FINDFILE('~/.netrc',count=N1)
   IF N1 gt 0  then SPAWN, 'mv -f ~/.netrc ~/.netrc_lampsav'
   PAS=getenv('USER')+'@'+getenv('HOST')+'.lamp'
   ILL='ftp.ill.fr'

   IF p2 eq '' then TRG=ILL ELSE TRG=p2
   IF p2 eq '' then V1 ='machine '+ILL+' login anonymous'
   IF p2 ne '' then V1 ='machine '+p2 +' login anonymous@'+ILL
		    V1 = V1+' password '+PAS
   IF P1 eq 2  then V2 = 'lampnews.txt'
   IF P1 eq 3  then V2 = 'lamp_light.tar.Z'
   V3 =['get '+V2,'quit','','']
   VAR=[ V1 ,'macdef init','bin','cd pub/cs',V3]
;  VAR=[ V1 ,'macdef init','bin','cd to_ill/cs',V3]

   res='?' & OPENW ,lun,'~/.netrc',/get_lun
   FOR i=0,n_elements(VAR)-1 DO PRINTF,lun,VAR(i)  & FREE_LUN ,lun
   SPAWN, 'chmod 700 ~/.netrc'

   f=FINDFILE(V2,count=N3)
   if N3 gt 0 then   OPENR,lun,V2,/get_lun,/delete & FREE_LUN ,lun

   WIDGET_CONTROL,/hourglass
   SPAWN,'ftp '+TRG,unit=U  &  printf,U,'quit'
   ON_IOERROR,goon	    &  readf,U,res
   goon:free_lun,U

   if N1 gt 0  then spawn, 'mv -f ~/.netrc_lampsav ~/.netrc' else SPAWN, 'rm ~/.netrc'

   res='.' & f=FINDFILE (V2,count=N2)
   IF N2 gt 0 then BEGIN res='ok'
      IF P1 eq 2 then BEGIN
   	 SPAWN,'cat  '+V2+' ; rm '+V2  ,res
      ENDIF
      IF P1 eq 3 then BEGIN
   	 CD,current=mee
   	 SPAWN,'cd '+p3+' ; cp lamp_mac/read_par.pro lamp_mac/read_par.loc'
   	 SPAWN,'cd '+p3+' ; cp START_LAMP.unix START_LAMP.loc'
   	 SPAWN,'cd '+p3+' ; cd .. ; zcat '+mee+'/'+v2+' | tar xf - '
   	 SPAWN,'cd '+p3+' ; mv lamp_mac/read_par.loc lamp_mac/read_par.pro'
   	 SPAWN,'cd '+p3+' ; mv START_LAMP.loc START_LAMP.unix'
	 SPAWN,'rm '+V2
      ENDIF
   ENDIF
ENDIF ELSE IF p1 eq 4 THEN BEGIN res=0
   SPAWN,'cd '+p3+' ; source MAKE_LAMP.unix',res
   SPAWN,'echo "" > lamp.upg'
ENDIF

mispriv:return,res
end
;------------------------------------------------------------------------------
;                                      DESKTOP
;------------------------------------------------------------------------------

pro desktop_event, event
;** *************
;**
common desk,whatdo,b11

    stat=0 & catch,stat
    if stat  ne 0  then begin catch,/cancel & print,string(7b)+!err_string & return & endif

    lodtx=[0]
    widget_control,bad_id=i ,event.id,get_uvalue=lodtx
    if n_elements(lodtx) ge 5 then begin

	widget_control,bad_id=i ,lodtx(5),/clear_events
	widget_control,bad_id=i ,lodtx(4),set_value=' '
	widget_control,/hourglass

	CASE lodtx(3) OF

	1:   desktop_lamp,lodtx

	2:   begin desktop_tuch,tbas,lbas
		if (tbas gt ' ') then begin
		   maj_desktop, lodtx , ' Loading TOUCH BASE ...',0
	   	   P_RESTORE,lbas+'touch_b.exe' ,cnt
	   	   if cnt gt 0 then begin
	   	   	desktop_lamp,lodtx
	   	   endif else $
		   maj_desktop, lodtx , ' Sorry, TOUCH BASE is not available',0
		endif else $
		   maj_desktop, lodtx , ' Sorry, TOUCH BASE is not available',0
	     end
	3:   begin whatdo = lodtx(3)
		   MANUAL,res
		   if res eq '' then $
		      maj_desktop,lodtx, ' Sorry, no HTML BROWSER found in local/bin',0
	     end

	4:   begin whatdo = lodtx(3)  &  widget_control,bad_id=i,event.top,/destroy
		   			 widget_control,/reset & end

	5:   if whatdo ne -5 then begin
		 desktop_tuch,tbas,lbas
		 if (tbas gt ' ') then begin
		   maj_desktop, lodtx , ' Loading TOUCH UPDATE ...',0
		   lamp,'just'
		   maj_desktop, lodtx , ' TOUCH UPDATE running...',0
		   maj_desktop, lodtx , ' TOUCH UPDATE running...',0
		   whatdo = lodtx(3)
		   touch_u,1,lodtx(4),lodtx(1),lodtx(5)
		endif
	     endif

	6:   desktop_lamp,lodtx

	7:   begin whatdo = lodtx(3)
		   P_ENVI
		   desktop_tuch,tbas,lbas,lsiz,lins
		   TOUCH_X,lins,tbas,1
	     end

	8:   CUSTOMIZ,1

	9:   BEGIN desktop_tuch,tbas,lbas,lsiz,lins,out & UPI,lodtx,out & END

	10:  if lodtx(6) lt 3 then begin
		   desktop_tuch,tbas,lbas
		   out='' & widget_control,bad_id=i,lodtx(7),get_value=out
		   out=strtrim(out(0),2)
		   if lodtx(6) eq 1 then begin
			widget_control,bad_id=i,lodtx(8),set_value=['','Downloading the News ...']
			res=ulamp(2, out ,lbas)
			if n_elements(res) eq 1 then begin
			   if res eq '?' then res=['','!! Problem with .netrc file ...'] else $
			   if res eq '.' then res=['','!! Can"t download the news ...']
			endif else desktop_puch,out
			widget_control,bad_id=i,lodtx(8),set_value=res
		   endif
		   if lodtx(6) eq 2 then begin
			res=ulamp(1, out ,lbas)
			if res eq 0 then begin
			   widget_control,bad_id=i,lodtx(8),set_value=['','Downloading ...']
			   res=ulamp(3, out ,lbas)
			   if res eq 'ok' then begin
				desktop_puch,out
			        widget_control,bad_id=i,lodtx(8),set_value=['','Making LAMP ...']
				res=ulamp(4, out ,lbas)
				widget_control,/reset
			   endif else begin
			        if res eq '?' then res=['','!! Problem with .netrc file ...'] else $
			        if res eq '.' then res=['','!! Can"t download the upgrade ...']
				widget_control,bad_id=i,lodtx(8),set_value=res
			   endelse
			endif else begin
			   if res eq -1 then txt='!! Bad Lamp-directory '+lbas
			   if res eq -2 then txt='!! Your are not allowed to modify the lamp-directory ...'
			   widget_control,bad_id=i,lodtx(8),set_value=['',txt]
			endelse
		   endif
	     endif else widget_control,bad_id=i,lodtx(9),/destroy

	11:  desktop_lamp,lodtx

	-87: LAMP_EVENT_PARSER,event
	-88: LAMP_EVENT_PARSER,event
	else:
	endcase
    endif
return
end

pro desktop_tuch,tbas,lbas,lsiz,lins,out,geor
;** ************
;**
@lamp.cbk
tbas=lamp_touch+lamp_dvd
lbas=lamp_dir  +lamp_dvd
lsiz=lamp_ziz
lins=lamp_ins
out =lamp_proxy
if n_elements(GEORGE) eq 1 then geor=GEORGE else geor=2
end
pro desktop_puch,out, geo=geo
;** ************
;**
@lamp.cbk
if n_elements(geo) ne 1 then lamp_proxy=out else GEORGE=geo
end

pro desktop_lamp,lodtx
;** ************
;**
common desk,whatdo,b11
		if lodtx(2) gt 0 then begin
		   desktop_tuch,tbas,lbas,lsiz,lins,out,geor
		   if (lodtx(3) eq 11) then begin
		     desktop_puch,geo=1
		     lodtx(3)=1
		   endif else begin
		     maj_desktop, lodtx , ' Loading Image Processing modules ...',90
		     desktop_tuch,tbas,lbas
	   	     SL_RESTSCAN,lbas+'scan.exe' ,cnt
		     if cnt gt 0  then loadct,1
		     i= xregistered( 'TOUCH')
		     if (i gt 0) then TOUCH_DONE,0,0
		   endelse
		endif
		whatdo =lodtx(3) & widget_control,bad_id=i,b11(0),/destroy
return
end

pro desktop_kill, id
;** ************
;**
return
end

pro maj_desktop, lodtx , text , pcent
;** ***********
;**
common desk,whatdo,b11

if !D.name ne 'TEK' then begin

	if (pcent eq 70) then begin

	   desktop_tuch,tbas,lbas,lamp_siz
	   pixmap=0 & LOGO,pixmap
	   !order=1 & wset,lodtx(2)
	   if n_elements(pixmap) eq 1 then $
	   if lamp_siz  ge 800 then device,copy=[0,0,512,256,    0  ,  0  ,pixmap] $
		else device,copy=[0,0,300,150,(300-300)/2,(200-150)/2,pixmap]
	   !order=0
	endif

	widget_control,bad_id=ii,lodtx(1),set_value=text

	if ii ne 0 then exit

	wset,lodtx(0)
	if pcent le 100 then plots,[0,2*pcent-1],[9,9],color=120,/device,thick=5

	if pcent eq 100 then begin
	if b11(1) gt 0  then begin
	  whatdo=0
	  print,string(7b)
	  wset,lodtx(0) & erase
	  plots,indgen(200),sin(findgen(200)/10)*4+9,color=120,/device,thick=5
	  widget_control,bad_id=i ,b11(1)  ,sensitive=1
	  widget_control,bad_id=i ,lodtx(5),/clear_events
	  XMANAGER, 'LAMP_DESKTOP',lodtx(5),event_handler='DESKTOP_EVENT',CLEANUP='DESKTOP_KILL'
	  lodtx(0)=-whatdo


	  IF lodtx(0) EQ -1 THEN LAMP 		ELSE  $
	  IF lodtx(0) EQ -2 THEN LAMP,'touch'	ELSE  $
	  IF lodtx(0) EQ -6 THEN LAMP,'tripx'
	  bid=sys_dep      ('EXIT')
	endif else pcent=101
	endif

	if pcent eq 101 then begin
	   desktop_lamp,lodtx
	   lodtx(0)=-1
	   LAMP
	endif

endif else begin
	print,text & lodtx(0)=-1
endelse
return
end

pro desktop, lodtx ,menu=menu ,nomenu=nomenu
;** *******
;**
;**	 First window when LAMP is started.

common desk,whatdo,b11

if n_elements(lodtx) ne 6 then lodtx=lonarr(6)
if !D.name ne 'TEK' then begin

ii=xregistered('LAMP_DESKTOP')
if (ii le 0) or (lodtx(5) le 0) then begin

	P_ENVI
	P_MUS ,'mus_start'

	ii=sys_dep('PSEUDO')

	k=0
	p_set_font,k ,lamp_font
	ft_biggest  =lamp_font(1,k)
	ft_b_bigger =lamp_font(3,k)
	ft_normal   =lamp_font(4,k)
	ft_b_normal =lamp_font(5,k)
	ft_smaller  =lamp_font(6,k)
				      sizex=512   &   sizey=256
	desktop_tuch,tbas,lbas, lamp_siz
	if lamp_siz lt 800 then begin sizex=300   &   sizey=230 & endif

	b1	=widget_base  (title='Lamp Desktop',/column,resource_name='lamp',$
			     			    kill_notify='desktop_kill')
	row1=0L
	if keyword_set(menu) then begin
	row1	=widget_base  (b1   ,/row)
	but1	=widget_button(row1 ,value=' LAMP '		,font=ft_biggest)
	but6	=widget_button(row1 ,value=' GEORGE '		,font=ft_biggest)
	but2	=widget_button(row1 ,value=' TOUCH L. '		,font=ft_biggest)
;	but5	=widget_button(row1 ,value= 'INST'		,font=ft_biggest,menu=2)
	but5_4	=widget_button(row1 ,value= 'Customize'	,font=ft_b_bigger)
	but3	=widget_button(row1 ,value=' MANUAL '		,font=ft_b_bigger)
	but4	=widget_button(row1 ,value=' EXIT'		,font=ft_b_bigger)

;	but5_1  =widget_button(but5 ,value=' 3 AXES '		,font=ft_b_bigger)
;	but5_4  =widget_button(but5 ,value=' CUSTO Mize   '	,font=ft_b_bigger)
;	but5_3  =widget_button(but5 ,value=' TOUCH Manage '	,font=ft_b_bigger)
;	but5_2  =widget_button(but5 ,value=' TOUCH Update '	,font=ft_b_bigger)

	bid	=widget_label (b1   ,value=' '			,font=ft_biggest)
	endif

	row2	=widget_base  (b1   ,/row)

	lodtx(0)=widget_draw  (row2 ,xsize=200  ,ysize=20   ,retain=2,colors=-30)
	lodtx(1)=widget_label (row2 ,xsize=sizex-200,value=' '	,font=ft_b_normal)

	lodtx(4)=widget_label (b1   ,xsize=sizex    ,value=' '	,font=ft_b_normal)

	icon    =widget_draw  (b1   ,xsize=sizex,ysize=sizey,retain=2,/button_events)

	Show_Version,b1,version,bil

	but9	=widget_button(bil  ,value='NEWs !!!'		 ,font=ft_smaller)

	bid	=widget_label (b1   ,value='Didier RICHARD @ill.fr  -  Don KEARLEY @iri.nl  -  '+$
					   'Michel FERRAND @cea.fr' ,font=ft_smaller)
	bil	=widget_base  (b1   ,/row)
	bid	=widget_label (bil  ,value='ILL:'    			 ,font=ft_b_bigger)
	bid	=widget_label (bil  ,value='Institut-Laue-Langevin  Grenoble France'    $
							  		 ,font=ft_normal)
	bid	=widget_label (bil  ,value='(anonymous@ftp.ill.fr  /pub/cs/lamp...)'   $
							 		 ,font=ft_smaller)

   	bid=sys_dep('DYNLAB',b1,1)
	widget_control,bad_id=i   ,b1  ,/realize
	b11=[b1,row1]
	if row1 gt 0 then widget_control,bad_id=i   ,row1,sensitive=0
	widget_control,bad_id=i   ,lodtx(0),get_value =jj & lodtx(0)=jj & loadct,27
	widget_control,bad_id=i   ,icon    ,get_value =jj & lodtx(2)=jj
	bid=sys_dep('AFTER')
	if  sys_dep('MACHINE') ne 'unix' then $
	widget_control,bad_id=i,but9,sensitive=0
	lodtx(5)=b1
	lodtx(3)=0  &  widget_control,bad_id=i,icon  ,set_uvalue=lodtx

	if keyword_set(menu) then begin
	lodtx(3)=1  &  widget_control,bad_id=i,but1  ,set_uvalue=lodtx
	lodtx(3)=2  &  widget_control,bad_id=i,but2  ,set_uvalue=lodtx
	lodtx(3)=3  &  widget_control,bad_id=i,but3  ,set_uvalue=lodtx
	lodtx(3)=4  &  widget_control,bad_id=i,but4  ,set_uvalue=lodtx
;	lodtx(3)=5  &  widget_control,bad_id=i,but5_2,set_uvalue=lodtx
;	lodtx(3)=6  &  widget_control,bad_id=i,but5_1,set_uvalue=lodtx
;	lodtx(3)=7  &  widget_control,bad_id=i,but5_3,set_uvalue=lodtx
	lodtx(3)=8  &  widget_control,bad_id=i,but5_4,set_uvalue=lodtx
	lodtx(3)=11 &  widget_control,bad_id=i,but6  ,set_uvalue=lodtx
	endif
	lodtx(3)=9  &  widget_control,bad_id=i,but9  ,set_uvalue=lodtx
	lodtx(3)=1

	widget_control,/hourglass
endif
endif
return
end

;****************************** B.A.R.N.S interfaces **************************************
;****************************** B.A.R.N.S interfaces **************************************
;****************************** B.A.R.N.S interfaces **************************************
pro BARNS_R ,remove=rem
;** *******
@lamp.cbk
@dons.cbk
common  for_users
	fil=findfile('lamp.ses',count=true)
	if  true gt 0 then begin
			P_RESTORE, 'lamp.ses', cnt
			AFTER_RESTORE
			if keyword_set(rem) then bid=sys_dep('DELET','lamp.ses')
			print,'Previous Session is restored ....'
	endif
end
function BARNS_I	,val
;** **** *******
;**
common c_barns  ,wk_read ,wk_plot ,wk_year ,wk_raw ,wk_rot ,wk_repi ,wk_repc ,wk_reps $
		,wk_fu   ,wk_fil  ,wk_reg  ,wk_log ,wk_wr  ,wk_xr   ,wk_yr   ,wk_kef  $
		,wk_bx   ,wk_by   ,wk_bw   ,wk_fx  ,wk_fy  ,wk_fz   ,wk_px   ,wk_py   $
		,wk_pz   ,wk_save ,wk_fmt  ,wk_ins ,wk_cyc

eff=0
txt=strlowcase(val)
k  =strpos(txt,',	"')
if k gt 0 then begin
	if n_elements(wk_raw) eq 0 then begin
			 wk_raw =0		 & wk_fil ='Gif'	& wk_save= 1
			 wk_repi=''		 & wk_repc=''		& wk_plot='1'
			 wk_reps=''	 	 & wk_fu  =',/below'	& wk_fmt = 3
			 wk_reg =',regular=0'	 & wk_rot ='30'
			 wk_log =',log=0'        & wk_wr  = 0.
			 wk_xr	= [0.,0.]	 & wk_yr  = [0.,0.]	& wk_year=''
			 wk_bx  =  0		 & wk_by  =  0		& wk_bw  =0
			 wk_fx  =  0		 & wk_fy  =  0		& wk_fz  =0
			 wk_px  =  0		 & wk_py  =  0		& wk_pz  =0
			 wk_kef =  0		 & wk_ins = ''		& wk_cyc =''
			 endif
	eff=1
	txt=strmid(txt,0,k)	& cmd=strmid(val,k+2,100)
	ln =strlen(cmd)		& cmv=strmid(cmd,1,ln-2)

	CASE txt of
	"set_inst":if cmd ne wk_ins then begin XICUTER,'RDSET,inst='+cmd
			 wk_ins=cmd
			 cmv=strlowcase(cmv) & iii=EXECUTE('myinit_'+cmv)
			 hhh='' & iii=execute('myhelp_'+cmv+ ',hhh') & nn=n_elements(hhh)
			 if nn gt 1 then begin on_ioerror,misop      & u =0
					 openw ,u,'help_'+cmv+'.htm',/get_lun
					 printf,u,'<HTML><PRE>'
					 for i=0,nn-1 do printf,u,hhh(i)
					 printf,u,'</PRE></HTML>'
					 misop: if u gt 0 then free_lun,u & endif
	           endif
	"set_base":if wk_ins+wk_year+cmd ne wk_cyc then begin
			 wk_cyc =wk_ins +wk_year+cmd
			 IF strpos(cmd,'Cycle -') lt 0 then $
			 XICUTER	,'RDSET,base='+cmd else $
			 XICUTER	,'RDSET,base="C_Year '+wk_year+'",cycle='+strmid(wk_year,2,2)+strmid(cmv,7,1)
	           endif
	"set_year":	 wk_year	=	cmv
	;**********
	"do_filt" :begin on_ioerror,fsx_err  &  rdtmp=[0.,0.]	& reads	 , cmv+' 0 0',rdtmp
			 RDFILTER, xrange=rdtmp			& fsx_err:
			 if wk_fx eq 0 then RDFILTER,xrange=[0,0]
			 if wk_fy eq 0 then RDFILTER,yrange=[0,0]
			 if wk_fz eq 0 then RDFILTER,zrange=[0,0]
			 if wk_px eq 0 then RDFILTER,xproj = 0
			 if wk_py eq 0 then RDFILTER,yproj = 0
			 if wk_pz eq 0 then RDFILTER,zproj = 0
			 wk_kef=wk_fx + wk_fy + wk_fz + wk_px + wk_py + wk_pz
			 wk_fx =0 & wk_fy =0 & wk_fz =0 & wk_px =0 & wk_py =0 & wk_pz =0
			 end
	"r_scly"  :begin on_ioerror,fsy_err  &  rdtmp=[0.,0.]	& reads	 , cmv+' 0 0',rdtmp
			 RDFILTER, yrange=rdtmp			& fsy_err: & end
	"r_sclz"  :begin on_ioerror,fsz_err  &  rdtmp=[0.,0.]	& reads	 , cmv+' 0 0',rdtmp
			 RDFILTER, zrange=rdtmp			& fsz_err: & end
	"r_chkx"  :	 wk_fx = 1
	"r_chky"  :	 wk_fy = 1
	"r_chkz"  :	 wk_fz = 1
	"r_prjx"  :begin RDFILTER,/xproj & wk_px = 1 & end
	"r_prjy"  :begin RDFILTER,/yproj & wk_py = 1 & end
	"r_prjz"  :begin RDFILTER,/zproj & wk_pz = 1 & end
	;**********
	"do_read" :IF cmv gt " " then begin
			 IF wk_raw then RDSET,/raw else RDSET,/default
			 ffl=strpos(cmv,':')
			 if (wk_kef ge 1) or (ffl ge 1) then begin
						   if wk_raw then RDFILTER,monimod=2 $
			 				     else RDFILTER,monimod=1
			 		RDFILTER,selection=cmv,wksp=fix(wk_read)
			 endif else	GMY_run ,[0,0,0,0],cmv,     fix(wk_read)
			 wk_raw		=	0	 & wk_plot=wk_read  & ENDIF
	"r_raw"   :	 wk_raw		=	1
	"set_wks" :	 wk_read	=	cmv
	;**********
	"do_save" :	 WRITE_LAMP	,	cmv ,w=wk_save ,fmt=wk_fmt
	"s_wks"   :	 wk_save	=   fix(cmv)
	"s_fmt"   :	 wk_fmt		=   fix(cmv)
	;**********
	"do_plot" :begin wk_plot	=	cmv
			 if wk_bx eq 0 then wk_xr(*)=0. & if wk_by eq 0 then wk_yr(*)=0.
			 if wk_bw eq 0 then wk_wr   =0.
			 range=strcompress(',xrange=['+string(wk_xr(0))+','+string(wk_xr(1))+'],'+$
			 		    'yrange=['+string(wk_yr(0))+','+string(wk_yr(1))+'],'+$
			 		    'zlim='   +string(wk_wr),/remove_all)
			 cmd = 'SEEM, rot='+wk_rot +wk_reg +wk_fu +wk_log +range
			 XICUTER	,	cmd
			 if wk_fil eq 'Wrl'  then begin wk_reps=',/surface' & wk_repi='' & wk_repc=''
						  fil=',/vrml'  & endif else $
			 if wk_fil eq 'Ps'   then fil=',/pscript' else $
			 if wk_fil eq 'Java' then fil=',/htm'     else fil=''
			 cmd = 'SEE, w=' +wk_plot +wk_repi +wk_repc +wk_reps +fil
			 XICUTER	,	cmd
			 wk_repi	=	''		& wk_repc = ''
			 wk_reps	=	''		& wk_log  = ',log=0'
			 wk_reg		=	',regular=0'	& wk_wr   = 0.
			 wk_xr(*)	=	 0.		& wk_yr(*)= 0.
			 wk_bx		= 	 0		& wk_by   = 0	   & wk_bw = 0
		   end
	"d_fil"   :	 wk_fil		=	cmv
	"d_repi"  :	 wk_repi	=	',/image'
	"d_repc"  :	 wk_repc	=	',/contour'
	"d_reps"  :	 wk_reps	=	',/surface'
	"d_repr"  :	 wk_reg		=	',regular=1'
	"d_angl"  :begin on_ioerror,rot_err
			 wk_rot		=   	string(fix(cmv)) & rot_err: & end
	"d_befu"  :	 wk_fu		=	cmv
	"d_sclx"  :begin on_ioerror,chx_err
			 reads		,	cmv+' 0 0',wk_xr & chx_err: & end
	"d_scly"  :begin on_ioerror,chy_err
			 reads		,	cmv+' 0 0',wk_yr & chy_err: & end
	"d_sclw"  :begin on_ioerror,chw_err
			 reads		,	cmv+' 0 0',wk_wr & chw_err: & end
	"d_chkl"  :	 wk_log		=	',log=1'
	"d_chkx"  :	 wk_bx		=	1
	"d_chky"  :	 wk_by		=	1
	"d_chkw"  :	 wk_bw		=	1
	;**********
	"do_cmd"  :	 XICUTER	,	cmv
	"submit"  :CASE  cmv of
		   "The Journal": DID_WRITE_JOURNAL ,/htm
		   "Parameters" : DID_PARAM_HTM     ,wk_plot
		   "The Manual" :
		   else:
		   ENDCASE
	;**********
	"do_color":	 setcol		,   fix(cmv)
	;**********
	 else     :	 eff=0
	ENDCASE
endif
return,eff
end

PRO LAMP_B
;** ******
@lamp.cbk

if  b_labins(3) le 0 then begin
 if (strpos(strlowcase(sys_dep('GETENV','LAMP_WIND')),'nws') ge 0) or (!D.Name eq 'Z')  then begin
		  BARNS_R ,/remove & b_labins(3) = 2 & SET_PLOT,"Z"
 endif else begin BARNS_R	   & b_labins(3) = 1 & endelse
 P_DON_INIT_VAR
 P_DID_SETVAR
 P_DATA_IDOL
 RDFILTER
 GEORGEO,/nowin
 lamp_focus =-1
endif

if b_labins(3) eq 1 then begin
 print,' **********************'
 print,' * Remember INTERNALS *'
 print,' **********************'
 print,'Available Bases       : ',lamp_ali(*)+','
 print,''
 print,'To set your instrument : RDSET   ,inst="D20"'
 print,'To set your base       : RDSET   ,base="C_Year 1996" ,cycle=964'
 print,'To use tektro,Win,X,Mac: SET_PLOT,"TEK" or "WIN" or "X" or "MAC"'
 print,'Actual display is '+!D.Name+' , Instrument is '+inst_value+' , Base is '+path_for_online
 print,''
endif

CATCH,stat & if stat ne 0 then print,!err_string
text=''
	while (1) do begin
		ON_IOERROR,NO_MATTER
		READ,'Lamp> ',text    &  text=strtrim(text,2)
		NO_MATTER: IF text ne '' then begin ;if b_labins(3) eq 2  then print,'Barns-sent'
						     if not barns_i(text) then XICUTER,text
						    ;if b_labins(3) eq 2  then print,'Barns-done'
						     ENDIF
	endwhile
return
end

PRO RUNTIME
    pth=sys_dep('GETENV','LAMP_DIR')
    VV=strtrim(string(sys_dep('VERSION')),2)
    VV=strmid (VV,0,1)+strmid (VV,2,1)
    CD,current=mee
    dv=sys_dep('DIVIDER')
    if pth ne '' then begin if strlowcase(!dir) eq strlowcase(pth) then pth=pth+dv+'..'
    			    catch,stat & if stat eq 0 then CD,pth
			    cd,current=pth
                            catch,/cancel &  endif
    fl=findfile('update'+VV+'a.rt' ,count=cnt )
    if cnt eq 0 then begin  pth=!dir+dv+'..'+dv+'..'
			    fl=findfile(pth +dv+'update'+VV+'a.rt' ,count=cnt)
			    if cnt gt 0 then   CD, pth
			    cd,current=pth
    endif
    if cnt gt 0 then        bid=sys_dep('ADDPATH',pth)

;   RESTORE AVAILABLE COMPILED FILES.
;   --------------------------------
    NW=strpos(strlowcase(sys_dep('GETENV','LAMP_WIND')),'nw')
    fl=findfile('*'+VV+'a.rt' ,count=cnt )
    fs=findfile('*'+VV+'.sav' ,count=cnts)
    if cnts gt 0 then if cnt gt 0 then fl=[fl,fs] else fl=fs & cnt=cnt+cnts
    if cnt  gt 0 then begin
			CD,current=mpth
			ln=strpos(strupcase(fl(0)),strupcase(mpth))
			if ln ge 0 then ln=ln+strlen(mpth)
			for i=0,cnt-1 do begin
				if (strpos(strupcase(fl(i)),'LAMP'+VV) lt 0) then $
				if (NW lt 0) or ((strpos(strupcase(fl(i)),'SCAN'+VV) lt 0)  and  $
			                         (strpos(strupcase(fl(i)),'LIVE'+VV) lt 0)) then begin
			                          P_RESTORE,strmid(fl(i) ,ln,35) ,rflg
			                          PRINT    ,strmid(fl(i) ,ln,35) +' plug-in loaded ...'
			        endif
			endfor
    endif
    CD,mee
;   RUN SPECIFIC STARTUP.
;   --------------------
    P_DO_THAT
;   NO WINDOW OPTION.
;   ----------------
    if NW ge 0 then begin
       SET_PLOT,'TEK' & LAMP,'just' & LAMP_B
       endif    else    LAMP
    return
    end
PRO MAIN
    RUNTIME
    return
    end

PRO LAMP ,just ,NW=nw ,GEO=geo ,SMALL=small ,MEDIUM=medium ,LARGE=large ,WIDE=wide ,GEOLAMP=geolamp ,LAMPGEO=lampgeo ,ONLY=lamp ,FULL=full
;** ****
@lamp.cbk
    !quiet=1
    if  sys_dep ('VERSION') ge 7.1 then begin rout=['']
	ii=execute('rout=routine_info(/functions)') & dx=where(rout eq 'RLAMP')
	if dx(0) lt 0 then RESOLVE_ROUTINE,['dons','dids','bens','scan']
    endif    else  GEORGE=0
    if n_elements (GEORGE)  eq 0 then GEORGE  =2
    if keyword_set(LAMP)         then GEORGE  =0
    if keyword_set(GEO)          then GEORGE  =1
    if keyword_set(LAMPGEO)      then GEORGE  =2
    if keyword_set(GEOLAMP)      then GEORGE  =2
    if keyword_set(FULL)         then GEORGE  =3
    if  sys_dep   ('STUDENT')    then lamp_ziz=600
    if keyword_set(SMALL)        then lamp_ziz=480
    if keyword_set(MEDIUM)       then lamp_ziz=600
    if keyword_set(LARGE)        then lamp_ziz=800
    if keyword_set(WIDE)         then lamp_ziz=1024
    if (!D.flags and 65536) eq 0 then if (!D.Name ne 'Z') then set_plot,'TEK'
    if keyword_set(NW)           then LAMP_,   'just'
    if keyword_set(NW)           then LAMP_B    else   LAMP_,just
    return
    end

;;; ***************************************************************************
;;; ***			           SHARED FUNCTIONS			    ***
;;; ***************************************************************************

function NUMtSTR,x,y
;;;;; This function converts any number to a string, with `y' digits after
;;;;; the dot. `y' is always less than 7.
   temp=size(y)
   if ((temp(0) eq 0) and (temp(1) eq 1)) then y=4 $
   else y=max([0,min([y,6])])
   temp=size(x)
   res='0'
   if  (temp(0) eq 0) then $
   if ((temp(1) ge 2) and (temp(1) le 5)) then begin xx=long(x)

      if ((temp(1) eq 4) or (temp(1) eq 5)) then begin
	 temp=abs(round(10^y*(x-xx)))
	 xx  =xx+ float(temp)/10^y
	 xl  =long(xx)
	 temp=abs(round(10^y*(xx-xl)))
	 res =string(xl)
	 str =strcompress(('000000'+string(temp)),/remove_all)
	 leng=strlen(str)
	 str =strmid(str,leng-y,y)
	 if ((temp ge 1) and (str ne '')) then res=res+'.'+str
      endif else res=string(xx)
   endif
   return,strcompress(res,/remove_all)
end

function BEN_UNDEFINED,x
;;;;; Return ` if the variable `x' is undefined.
   temp=size(x)
   if (temp(0) ne 0) then return,0
   return,(temp(1) eq 0)
end

function BEN_READTEXT,widgetID
;;;;; This function reads the value of the widget_text `widgetID',
;;;;; and returns a float equal to this value.
   widget_control,bad_ID=bad,get_value=temp,widgetID
   if (bad ne 0) then return,0
   x=temp(0)
   if (strmid(x,0,1) eq '-') then begin
      sign=-1
      x=strmid(x,1,strlen(x)-1)
   end else sign=1
   return,(sign*float('0' + x))
end

function BEN_SELECTWID,base,i,n,labelID,wkn,comp
@lamp.cbk
;;;;; This function creates three widget_buttons, for workspace selection.
;;;;; The message ('Load', or 'Write') is determine by the parameter `n'.
;;;;; The user value of this widgets are 401, and (403+n). The '<-' and '->'
;;;;; buttons should call the BEN_CHANGE_WORKSPACE procedure, that will
;;;;; handle everything. Additionnal elements can be put in the user value
;;;;; of the center button by passing them in the `comp' parameter.
;;;;; The value returned by this function are the three buttons ID number.
   decr=widget_button(base,value="<-",font=ft_b_normal)
   load=widget_button(base,uvalue=[-88,(403+n),i,wkn,labelID,comp], $
      font=ft_b_normal)
   incr=widget_button(base,value="->",font=ft_b_normal)
   case n of
      0:    title="Load W"
      1:    title="Write to W"
      else: title="W"
   end
   if (wkn eq 0) then begin
      title=(' ' + title + ' ')
      widget_control,sensitive=0,load
   end else if (wkn ge 10) then title=(title + NUMtSTR(wkn,0)) $
   else title=(title + ' ' + NUMtSTR(wkn,0))
   widget_control,set_value=title,load
   widget_control,sensitive=(wkn gt 1),decr
   widget_control,sensitive=(wkn lt 20),incr
   widget_control,set_uvalue=[-88,401,i,0,load,decr,incr,n],decr
   widget_control,set_uvalue=[-88,401,i,1,load,decr,incr,n],incr
   return,[base,decr,load,incr]
end

function BEN_COMMANDS,base,i,masq,comp
@lamp.cbk
;;;;; This function creates the 'Done', workspace selection widgets, and
;;;;; 'help' buttons that are present at the top of the function windows.
;;;;; It also creates a widget_label. The `mask' parameter is an array
;;;;; used for preventing the function from creating the 'help' button,
;;;;; or the label. Those widget are created if the corresponding value
;;;;; (mask(0): help, mask(1): label) are set to 0. The default value is
;;;;; mask=[0,0]. The workspace selection widgets are created by calling
;;;;; the BEN_SELECTWID function.
;;;;; The returned value is an array of the widgets ID number.
   if BEN_UNDEFINED(masq) then masq=[0,0]
   if BEN_UNDEFINED(comp) then comp=[0]
   top=widget_base(base,/row)
   done=widget_button(top,value=" Done ",uvalue=[-88,400,i], $
      font=ft_b_normal)
   temp=widget_base(top,/row,/frame)
   if masq(0) then help=-1 $
   else help=widget_button(top,value='?',uvalue=[-88,402,1])
   if masq(1) then labelID=-1 $
   else labelID=widget_label(base,value="   You must load W ",font=ft_b_normal)
   if BEN_UNDEFINED(one) then wkn=0 else wkn=abs(one)
   slct=BEN_SELECTWID(temp,i,0,labelID,wkn,comp)
   return,[done,0,slct(0),slct(1),slct(2),slct(3),help,labelID]
end

pro BEN_CHANGE_WORKSPACE,uv
;;;;; This procedure should be called to handle the workspace selection
;;;;; widgets. Only the user value must be passed. Its form is:
;;;;; uv=[-88,4xx,x,{add/sub},{btn "Wxx"},{btn "<-"},{btn "->"},x]
;;;;; The currently selected workspace number is stored into the element
;;;;; number 3 of the center button.
   widget_control,get_uvalue=x,uv(4)
   if uv(3) then n=x(3)+1 $
   else n=x(3)-1
   widget_control,sensitive=(n ne 1),uv(5)
   widget_control,sensitive=(n ne 20),uv(6)
   x(3)=n
   widget_control,/sensitive,uv(4)
   case uv(7) of
      0:    str="Load W"
      1:    str="Write to W"
      else: str="W"
   end
   if ((n ge 1) and (n le 9)) then $
      widget_control,set_value=(str + " " + NUMtSTR(n,0)),set_uvalue=x,uv(4) $
   else if ((n ge 10) and (n le 20)) then $
      widget_control,set_value=(str + NUMtSTR(n,0)), set_uvalue=x,uv(4)
end

function BEN_WK_SIZE,x
;;;;; This function returns the size of the workspace Wx.
   common c_lamp_w,w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11, $
      w12,w13,w14,w15,w16,w17,w18,w19,w20
   wksize=0
   temp=execute("wksize=size(W" + NUMtSTR(x,0) + ")")
   return,wksize
end

pro BEN_READ_WK,x,work,wkx,wky,wkn,wkp,datpar
@lamp.cbk
;;;;; This procedure reads the LAMP workspace Wx, and all the linked data
;;;;; (eg Xx, Yx, PARx ...), and writes them in the parameter variables.
datpar=['','','']
   if ((x lt 0) or (x gt 20)) then return
   temp=execute("work=w"    + NUMtSTR(x,0))
   temp=execute("wkx=x"     + NUMtSTR(x,0))
   temp=execute("wky=y"     + NUMtSTR(x,0))
   temp=execute("wkn=n"     + NUMtSTR(x,0))
   temp=execute("wkp=p"     + NUMtSTR(x,0))
   temp=execute("datpar=par"+ NUMtSTR(x,0))
   datpar=[w_numor(x),string(x),his(x)]
end

pro BEN_WRITE_WK,x,work,wkx,wky,wkn,wkp,datpar
@lamp.cbk
;;;;; This procedure writes the parameters into LAMP variables,
;;;;; creating or replacing the workspace Wx and accompaying data.
   temp=execute("w" + NUMtSTR(x,0) + "=work")
   if BEN_UNDEFINED(wkx) then return
   temp=execute("x" + NUMtSTR(x,0) + "=wkx")
   if BEN_UNDEFINED(wky) then return
   temp=execute("y" + NUMtSTR(x,0) + "=wky")
   if BEN_UNDEFINED(wkn) then return
   temp=execute("n" + NUMtSTR(x,0) + "=wkn")
   if BEN_UNDEFINED(wkp) then return
   temp=execute("p" + NUMtSTR(x,0) + "=wkp")
   if BEN_UNDEFINED(datpar) then return
;  temp=execute("par" + NUMtSTR(x,0) + "=datpar")
   w_numor(x)=datpar(0)
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; DESKTOP EVENTS
;;; -+-+-+-+-+-+-+

function desk_name,i,test,string
;;;;; If (i lt 0), this function inits the commons, and returns the number
;;;;; of display function that it 'knows'. If (i ge 0), then this function
;;;;; returns, depending on the value of `test', the function `i' name, its
;;;;; event handler name...
   common c_ben,winList,maxWin,singleRun,topBase,regNames,winNames,winNum
   common ben_data,wk,benw,benx,beny,benn,benp,benpar
   if (i lt 0) then begin
      regNames=["desk","int","df","rgp"]
      winNames=["LAMP Desktop","Radial Integration ","Scroll Spectra", $
	 "Mask & Group"]
      maxWin=3
      temp=size(winNames)
      winNum=temp(1)
      winList=intarr(winNum,maxWin)
      singleRun=intarr(winNum)
      wk=0 & benw=0 & benx=0 & beny=0 & benn=0 & benp=0 & benpar=0
      return,winNum-1
   end
   if (i ge winNum) then return,"Unknown"
   case test of
      0:    return,("ben_" + regNames(i))
      1:    return,winNames(i)
      2:    return,(regNames(i) + "_event")
      3:    return,("ben_" + regNames(i) + "_create")
      4:    return,(regNames(i) + "_testModule('areYouHere')")
      else: return,regNames(i)
   end
end

function desk_winNum,str
;;; Given the ID string of a module (e.g. "df", "int"),
;;; returns the module number.
   common c_ben,winList,maxWin,singleRun,topBase,regNames
   temp=where(regNames eq str,count)
   if (count eq 0) then return,0 $
   else return,temp(0)
end

function desk_ismodule,x
;;;;; Calls the "testModule" function of the specified module, in order
;;;;; to check if the module really exists. The value returned by this
;;;;; function determines whether the display function `i' can only be
;;;;; run once, or not. Those values are stored in an array, for use
;;;;; by the desk_event procedure.
   common c_ben,winList,maxWin,singleRun
   on_error,3
   status=0
   catch,status
   if (status ne 0) then res=0
   test=0
   res=execute("test=" + desk_name(x,4))
   if (res eq 0) then print,("The '" + desk_name(x,1) + $
      "' function could not be found." + string(7b))
   singleRun(x)=test
   return,res
end

function desk_newWin,x
;;;;; This function `x' returns a number to open a new module `X'. It does
;;;;; NOT check if the function can be run several times or not.
;;;;; If the function `x' is not already running, the result is always 0.
   common c_ben,winList,maxWin
   i=xregistered(desk_name(x,0))
   if (i eq 0) then return,0
   for j=0,maxWin-1 do begin
      if (winList(x,j) eq 0) then return,j
      widget_control,bad_ID=bad,winList(x,j)
      if (bad ne 0) then return,j
   end
   return,maxWin
end

function desk_loadRequest,module,wkn,w,x,y,n,p,par
;;; This function is used by a module, to have another module
;;; load the data {w x y n p par} (wkn is the workspace number if needed).
;;; The function checks how many wanted modules are already opened;
;;; if all available modules (maxWin) are opened, the data are loaded
;;; in the first module.
   common ben_data,wk,benw,benx,beny,benn,benp,benpar
   common c_ben,winList,maxWin,singleRun,topBase
   success=1
   modNum=desk_winNum(module)
   m=desk_newWin(modNum)
   if ((m ge maxWin) or (singleRun(modNum) and (m gt 0))) then begin
      widget_control,bad_ID=bad,get_uvalue=vars,winList(modNum,0)
      if (bad ne 0) then return,0
      res=execute("success=" + module + "_loadRequest(vars,wkn,w,x,y,n,p,par)")
   end else begin
      wk=wkn & benw=w & benx=x & beny=y & benn=n & benp=p & benpar=par
      wind=0
      res=execute(desk_name(modNum,3) + ",topBase,modNum,m,wind,1")
      winList(modNum,m)=wind
   end
   if res then return,success
   return,-1
end

pro desk_event,ev,uv
;;;;; This procedure is called by the LAMP desktop display function buttons.
;;;;; It checks if the wanted function (uv(1)-400) is already running,
;;;;; via the desk_newWin function, and runs a new one, or unmap the running
;;;;; one, depending if it can be opened several times, and if the maximum
;;;;; windows are already opened.
   common c_ben,winList,maxWin,singleRun,topBase
   x=uv(1)-400
   if uv(2) eq -1 then WDIAG         else  $
   if uv(2) eq -2 then TOMOGRAPHY    else  $
   if (x eq 0)    then print,"HELP WANTED" $
   else begin
      m=desk_newWin(x)
      if ((m ge maxWin) or (singleRun(x) and (m gt 0))) $
      then widget_control,bad_ID=bad,/map,winList(x,0) $
      else begin
	 wind=0
	 temp=execute(desk_name(x,3) + ",topBase,x,m,wind,0")
	 winList(x,m)=wind
      end
   end
end

pro P_BEN_EVENT,ev,uv
;;;;; Executes a "xxx_event" procedure, where xxx is a function code.
   temp=execute(desk_name(uv(2)>0,2) + ",ev,uv")
end

pro P_BEN_CREATE,base,only
;;;;; Creation of the widget_buttons that call the display function.
;;;;; The procedure checks the presence of a function by calling the
;;;;; desk_ismodule function for every function. If a function appears
;;;;; to be absent, no button is created for it.
@lamp.cbk
   common c_ben,winList,maxWin,singleRun,topBase
   topBase=base
   if (not only) then begin
      desk=widget_base(base ,/column)
      header1=widget_base(desk,/row)
      header2=widget_base(desk,/row)
      title1=widget_label(header1,value=' DISPLAY',font=ft_biggest)
      title2=widget_label(header2,value=' FUNCTIONS',font=ft_biggest)
      help=widget_button(header1,value='?',uvalue=[-88,589,0])
   endif else desk=base
   btns=desk_name(-1)
   for i=1,btns do if desk_ismodule(i) then begin
      libel=desk_name(i,1)
      if strpos(libel,"Radial") ge 0 then begin
                 btn=widget_button(desk,value=libel,menu=2)
                 bid=widget_button(btn ,value="Using Sectors (up to [128,128] data)",uvalue=[-88,(400+i),0])
                 bid=widget_button(btn ,value="Unrolling Image (large data)",uvalue=[-88,(400+i),-1]) ;See WDIAG
                 bid=widget_button(btn ,value="Tomography",uvalue=[-88,(400+i),-2]) ;See TOMOGRAPHY
      endif else btn=widget_button(desk,value=libel,uvalue=[-88,(400+i),0])
      endif
end

;;; ***************************************************************************
;;; ***				  SCROLL SPECTRA			    ***
;;; ***************************************************************************


pro df_event,ev,uv
   widget_control,get_uvalue=varAccess,ev.top
   case uv(1) of
      400:  begin wait,.05 & widget_control,/destroy,ev.top & end
      401:  BEN_CHANGE_WORKSPACE,uv
      402:  df_help,ev.top
      403:  df_loadWorkspace,varAccess,uv(3),uv(4)
      406:  df_change_scale,varAccess,uv(3)
      407:  df_mini_event,varAccess,ev
      408:  df_slider_event,varAccess,ev.value
      409:  df_animate,varAccess,uv(3),ev.top
      410:  df_change_numb,varAccess,ev.value
      412:  df_psfile,varAccess,ev.top,uv(2)
      413:  df_select_sym,varAccess,uv(3),uv(4)
      414:  df_dialog_event,varAccess,ev,uv
      415:  df_toggle_load,varAccess,ev.select
      416:  df_draw_event,varAccess,ev
      417:  df_unzoom,varAccess,1,-1
      else: print,"DF_EVENT:",uv
   end
end

function df_testModule,x
;;;;; Returns 0, for `singleRun'. That means it can run several times.
   return,0
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; DEFILEMENT DE TOUS LES SPECTRES
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


pro df_animate,varAccess,x,base
;;;;; This procedure is called by the animation menu. Whether an animation
;;;;; is already running or not, it only changes the speed, or calls
;;;;; the df_animation_loop procedure.
   widget_control,get_uvalue=opt,varAccess.options
   opt.speed=x
   if (x lt 0) then opt.anim=1
   widget_control,set_uvalue=opt,varAccess.options
   if ((x ge 0) and opt.anim) then df_animation_loop,varAccess,base
end

pro df_animation_loop,varAccess,base
;;;;; This procedure contains the loop for the animation.
;;;;; This loop does several things: first, the user_value are read,
;;;;; so that the variables used for plotting are always updated.
;;;;; Then the plot is done; the number of curves shown on each
;;;;; images depends on the value of the 'number of plots' slider.
;;;;; At the end of the loop, another 'wait' loop is run, so the animation
;;;;; does not run too fast; the `speed' setting is used in this
;;;;; loop. The loop also contains a call to the widget_event procedure.
;;;;; So, during the animation, the user can change the speed, the xrange,
;;;;; the number or plots, or the displayed workspace. A test to check
;;;;; if the window has not been destroyed (eg, by using the 'Done' button)
;;;;; is done in the main loop.
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,/sensitive,IDs.stopMenu
   widget_control,sensitive=0,IDs.psBtn
   widget_control,sensitive=0,IDs.dfSlider
   opt.anim=0
   widget_control,set_uvalue=opt,varAccess.options
   wset,IDs.draw
   erase
   i=opt.disp
   window,0,xsize=cst.dimx,ysize=cst.dimx,/pixmap,retain=2
 ;DID!!^
   CATCH,stat
   IF stat eq 0 then begin
   repeat begin
      widget_control,get_uvalue=temp,varAccess.datAccess
      widget_control,get_uvalue=data,temp.w
      widget_control,get_uvalue=datx,temp.x
      widget_control,get_uvalue=daty,temp.y
      widget_control,get_uvalue=dims,temp.dims
      widget_control,get_uvalue=rgs,varAccess.ranges
      widget_control,get_uvalue=lmt,varAccess.limits
      i=(i+dims(1)+2) mod (dims(1)+1)
      if (opt.scale le 1) then begin
	 r=round(rgs.xspec)
	 if (r(0) eq r(1)) then r=fix([rgs.xspec(0)-1,rgs.xspec(1)+1])
	 yrg=[min(lmt.minsp(r(0):r(1))),max(lmt.maxsp(r(0):r(1)))]
      end $
      else yrg=rgs.yspec

      wset,0 & trap_current=0

      plot,rgs.dxspec,yrg,/nodata,/device, $
	 xstyle=9,ystyle=9,xtitle=("Spectrum # " + NUMtSTR(1+i,0) + $
	 " - Value " + NUMtSTR(daty(i),1)),charsize=1.2,font=0, $
	 pos=[cst.borders(0),cst.borders(0),cst.borders(1),cst.borders(1)], $
	 yticklen=1.,ygridstyle=1
;DID!!^
      for j=0,(opt.num-1) do begin
	 ind=j+i-opt.num/2
	 if ((ind ge 0) and (ind le dims(1))) then $
	    if (ind eq i) then oplot,datx,data(*,ind), $
	       color=(130+3*opt.num-(20-opt.num)*j),psym=opt.sym $
	    else oplot,datx,data(*,ind),lineStyle=1, $
	       color=(130+3*opt.num-(20-opt.num)*j),psym=opt.sym
      end
      df_set_slider,varAccess,i
      widget_control,bad_ID=bad,base
      if (bad ne 0) then return
      wset,IDs.draw
      device,copy=[0,0,cst.dimx,cst.dimx,0,0,0]
      j=0
      repeat begin
	 temp=widget_event(/nowait)
	 widget_control,bad_ID=bad,get_uvalue=opt,varAccess.options
	 if (bad ne 0) then opt.anim=1
	 if opt.anim then j=opt.speed $
	 else j=j+1
	 wait,.05
      endrep until (j ge opt.speed)
   endrep until opt.anim
   ENDIF  else  opt.anim=1
   widget_control,bad_ID=bad,set_uvalue=opt,varAccess.options
   widget_control,bad_ID=bad,sensitive=0,IDs.stopMenu
   widget_control,bad_ID=bad,/sensitive,IDs.psBtn
   widget_control,bad_ID=bad,/sensitive,IDs.dfSlider
   widget_control,bad_ID=bad,/clear_events,base
   if (bad eq 0) then df_display,varAccess,i,0,1,-1
end


;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; ZOOM, RANGES MODIFICATION
;;; -+-+-+-+-+-+-+-+-+-+-+-+-

pro df_zoom,varAccess,test,add,xrg,yrg,minPix
;;;;; This procedure zooms, with an xrange of xrg, and an yrange or yrg if
;;;;; the autoscale variable is set to <no autoscale>. If test is set to 0,
;;;;; the xrg and yrg are given in 'mini' window coordinates; otherwise,
;;;;; the parameters are given in the main 'scroll' window corrdinates.
;;;;; If `add' is set to 1, then the current ranges are added to the zooms
;;;;; list, by calling df_add_zoom.
;;;;; The `minPix' parameter is only to be passed to the df_display procedure.
;;;;; Its purpose is to avoid recalculating a picture when it is already
;;;;; known somewhere; it is used in loops, when a pixmap is created before
;;;;; the loop, and df_zoom called in the loop.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=cst,varAccess.constants
   if add then df_add_zoom,varAccess,rgs.Xmini,rgs.Ymini
   if (opt.scale le 1) then temp=(xrg(0) eq xrg(1)) $
   else temp=((xrg(0) eq xrg(1)) or (yrg(0) eq yrg(1)))
   if temp then return
   if test then begin
      newrg=xrg*(rgs.dxspec(1)-rgs.dxspec(0)) + rgs.dxspec(0)
      rgs.yspec=[min(yrg),max(yrg)]
   end else begin
      rgs.Xmini=[max([0,min(xrg)]),min([cst.dimx,max(xrg)])]
      if (opt.scale ne 2) then rgs.Ymini=[0,cst.dimy] $
      else rgs.Ymini=[max([0,min(yrg)]),min([cst.dimy,max(yrg)])]
      newrg=(rgs.Xmini*(rgs.dxmini(1)-rgs.dxmini(0)))/cst.dimx+rgs.dxmini(0)
      rgs.yspec=(rgs.Ymini*(rgs.range(1)-rgs.range(0)))/cst.dimy+rgs.range(0)
   end
   newrg=[min(newrg),max(newrg)]
   temp=where((datx ge newrg(0)) and (datx le newrg(1)),found)
   if (found ge 0) then begin
      rgs.dxspec=newrg
      rgs.xspec=[min(temp),max(temp)]
   end
   if test then begin
      rgs.Xmini=(cst.dimx*(newrg-rgs.dxmini(0)))/ $
	 (rgs.dxmini(1)-rgs.dxmini(0))
      if (opt.scale ne 2) then rgs.Ymini=[0,cst.dimy] $
      else rgs.Ymini=(cst.dimy*(rgs.yspec-rgs.range(0)))/ $
	 (rgs.range(1)-rgs.range(0))
   end
   widget_control,set_uvalue=rgs,varAccess.ranges
   df_autoscale,varAccess,1
   df_display,varAccess,opt.disp,1,1,minPix
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; GESTION DE LA LISTE DES ZOOMS (+ APPEL A 'DF_ZOOM')
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

pro df_unzoom,varAccess,test,minPix
;;;;; This procedure calls the df_zoom procedure with the top element
;;;;; of the zooms list (a 'Last In First Out' stack) if test is set to 0.
;;;;; Otherwise, df_zoom is called with the full ranges.
;;;;; If the zooms list is used, then the top element is removed from
;;;;; the stack.
   widget_control,get_uvalue=zooms,varAccess.zooms
   widget_control,get_uvalue=cst,varAccess.constants
   temp=size(zooms)
   xrg=[0,cst.dimx]
   yrg=[0,cst.dimy]
   if test then df_zoom,varAccess,0,1,xrg,yrg,minPix $
   else begin
      if (temp(0) gt 1) then begin
	 xrg=zooms(0:1,temp(2)-1)
	 yrg=zooms(2:3,temp(2)-1)
	 zooms=zooms(*,0:temp(2)-2)
	 widget_control,set_uvalue=zooms,varAccess.zooms
      end
      df_zoom,varAccess,0,0,xrg,yrg,minPix
   end
end

pro df_add_zoom,varAccess,valx,valy
;;;;; Adds [valx,valy] to the zooms list. The zoom list is a 'Last In First Out'
;;;;; stack, of a maximum size of 'varAccess.constants.zoom_max' elements.
   widget_control,get_uvalue=zooms,varAccess.zooms
   widget_control,get_uvalue=cst,varAccess.constants
   temp=size(zooms)
   if (temp(2) ge cst.zoom_max) then begin
      temp=zooms(0)
      zooms=shift(zooms,0,-1)
      zooms(*,0)=temp
      zooms(*,cst.zoom_max-1)=[valx,valy]
   end $
   else zooms=[[zooms],[[valx,valy]]]
   widget_control,set_uvalue=zooms,varAccess.zooms
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; MINI PICTURE UPDATE
;;; -+-+-+-+-+-+-+-+-+-

pro df_update_mini,varAccess,pixWin,test,xrg,yrg
;;;;; This procedure copies the current spectrum in the mini window,
;;;;; and draws over it the 'selection' rectangle, defined by the
;;;;; coordinates xrg and yrg, if test is set to 1, or by the saved
;;;;; coordinates otherwise. If `pixWin' is less than 1, then it is assumed
;;;;; that no pixmap window is containing the desired plot, so it is
;;;;; created by calling df_makePix. If `pixWin' is greater or equal to 1,
;;;;; then the window `pixWin' is copied into the mini window.
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=IDs,varAccess.IDs
   if (pixWin le 0) then begin
      pixWin=1
      df_makePix,varAccess,pixWin,0
   end
   widget_control,get_uvalue=rgs,varAccess.ranges
   x=rgs.Xmini
   y=rgs.Ymini
   if test then begin
      x=[max([0,min(xrg)]),min([cst.dimx,max(xrg)])]
      y=[max([0,min(yrg)]),min([cst.dimy,max(yrg)])]
   end
   window,0,xsize=cst.dimx,ysize=cst.dimy,/pixmap,retain=2
   device,copy=[0,0,cst.dimx,cst.dimy,0,0,pixWin]
;;;;; The graphics function number 10 (=> GXinvert) is used for
;;;;; drawing the selection rectangle.
   invert=sys_dep      ('INVERT')
   device,get_graphics_function=temp,set_graphics_function=invert
   polyfill,[x(0),x(1),x(1),x(0)],[y(0),y(0),y(1),y(1)],/device
   device,set_graphics_function=temp
   wset,IDs.mini
   device,copy=[0,0,cst.dimx,cst.dimy,0,0,0]
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; MODIFYING THE SETTINGS
;;; -+-+-+-+-+-+-+-+-+-+-+

pro df_change_numb,varAccess,n
;;;;; This procedure is called by the 'number of plots' slider. It updates
;;;;; the variables 'options.num', the 'pos' array, and the display.
   widget_control,get_uvalue=opt,varAccess.options
   if (n eq opt.num) then return
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=cst,varAccess.constants
   opt.num=n
   pos=cst.dimx*rotate(indgen(7*n),2)/(7.0*n)
   widget_control,set_uvalue=opt,varAccess.options
   widget_control,set_uvalue=pos,varAccess.pos
   df_display,varAccess,opt.disp,1,0,-1
end

pro df_slider_event,varAccess,x
;;;;; Event sent by the scrolling slider. The 'options.disp' variable is
;;;;; modified by calling 'df_display', which also updates the display.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   df_display,varAccess,(dims(1)-x)>0,0,1,-1
end

pro df_set_slider,varAccess,x
;;;;; This procedure is used to set the scrolling slider to a given value.
;;;;; It is used in the 'df_animation_loop' procedure, for example.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,bad_ID=temp,set_value=long(dims(1)-x)>0,IDs.dfslider
end

pro df_change_scale,varAccess,type
;;;;; Updates the yrange and the display when the autoscale type is changed.
   widget_control,get_uvalue=opt,varAccess.options
   if (type ne opt.scale) then begin
      opt.scale=type
      widget_control,set_uvalue=opt,varAccess.options
      df_autoscale,varAccess,1
      df_display,varAccess,opt.disp,1,1,-1
   end
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; AUTOSCALE
;;; -+-+-+-+-

pro df_autoscale,varAccess,test
;;;;; This procedure calculates the new yrange, according to the
;;;;; current xrange, and to the autoscale type. If the autoscale is set
;;;;; to <all plots>, then the new yrange is not calculated, unless
;;;;; the `test' parameter is set to 1.
   widget_control,get_uvalue=opt,varAccess.options
   if ((opt.scale ne 1) and ((opt.scale gt 1) or (test eq 0))) then return
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=lims,varAccess.limits
   temp=round(rgs.xspec)
   if (temp(0) eq temp(1)) then temp=fix([rgs.xspec(0)-1,rgs.xspec(1)+1])
   temp=[max([0,temp(0)]),min([dims(0),temp(1)])]
   if (opt.scale eq 1) then begin
      arr=data(temp(0):temp(1),max([0,opt.disp-opt.num/2]): $
	 min([dims(1),opt.disp+(opt.num-1)/2]))
      rgs.yspec=[min(arr),max(arr)]
   end $
   else rgs.yspec=[min(lims.minsp(temp(0):temp(1))), $
      max(lims.maxsp(temp(0):temp(1)))]
   temp=data(*,opt.disp)
   if (rgs.yspec(0) eq rgs.yspec(1)) then rgs.yspec(0)=rgs.yspec(0)-0.01
   widget_control,set_uvalue=rgs,varAccess.ranges
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; 'DF_DRAW_EVENT' SUBROUTINES
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-

function df_zone,varAccess,y
;;;;; This function returns the number of the 'zone' containing
;;;;; the points at (x,`y'). If the points is not in any 'zone', then
;;;;; the returned value is -1.
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   found=-1
   for i=0,opt.num-1 do $
      if ((y le pos(7*i)) and (y ge pos(7*i+4))) then found=i
   temp=found+opt.disp-opt.num/2
   if ((temp ge 0) and (temp le dims(1))) then return,found $
   else return,-1
end

function df_correct,varAccess,x
;;;;; This function returns a corrected value of x, so that when plotting
;;;;; the selection rectangle, it is included in the axis.
   widget_control,get_uvalue=cst,varAccess.constants
   return,1.0*min([cst.borders(1),max([cst.borders(0),x])])
end

function df_selecty,varAccess,y0,y1
;;;;; This function returns data used when dragging the mouse in the
;;;;; scroll window, to draw the selection rectangle. It returns two
;;;;; values, r0 and r1; the selection rect will be of the form
;;;;; {x0,(zone_bottom + `r0'),x1,(zone_top - `r1')}.
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=opt,varAccess.options
   r0=0
   r1=0
   if (opt.scale eq 2) then begin
      temp=df_zone(varAccess,y0)
      if (temp ge 0) then begin
	 r0=y0-pos(7*temp+4)
	 r1=max([0,pos(7*temp)-max([pos(7*temp+4),y1])])
      end $
      else begin
	 temp=df_zone(varAccess,y1)
	 if (temp ge 0) then $
	    if (y1 gt y0) then $
	    r1=pos(7*temp)-max([pos(7*temp+4),y1]) $
	    else r0=y1-pos(7*temp+4)
      end
   end
   return,[r0,r1]
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; SCROLL WINDOW EVENT
;;; -+-+-+-+-+-+-+-+-+-

pro df_draw_event,varAccess,ev
;;;;; This procedure exits immediatly if the event is a release event.
;;;;; If an animation is running, the clicking in this window just stops
;;;;; the animation. Pressing the right mouse button calls the df_unzoom
;;;;; procedure. Dragging the mouse with the left mouse button draws a
;;;;; selection rectangle; when the mouse button is released, the df_zoom
;;;;; procedure is called. For drawing the selection rectangle, a pixmap
;;;;; of the displayed plots is first created; then, a loop reads the mouse
;;;;; position, and copies the pixmap into the picmap ID 0, and plots over
;;;;; this pixmap the selection rectangles. Then, the pixmap ID 0, is
;;;;; copied to the scroll window.
   if (ev.type ne 0) then return
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=rgs,varAccess.ranges
   if (opt.anim eq 0) then begin
      opt.anim=1
      widget_control,set_uvalue=opt,varAccess.options
      return
   end
   if (ev.press eq 1) then begin
      p0=[df_correct(varAccess,ev.x),ev.y]
      window,0,xsize=cst.dimx,ysize=cst.dimx,/pixmap,retain=2
      thePix=1
      df_makePix,varAccess,thePix,1
      wset,IDs.draw
      repeat begin
	 cursor,x,y,/device,/nowait
	 if (x lt 0) then begin
	    if opt.anim then $
	       device,copy=[0,0,cst.dimx,cst.dimx,0,0,thePix]
	    return
	 end
	 x0=df_correct(varAccess,x)
	 x=[p0(0),x0,x0,p0(0)]
	 y=df_selecty(varAccess,p0(1),y)
	 wset,0
	 device,copy=[0,0,cst.dimx,cst.dimx,0,0,1]
   	 invert=sys_dep      ('INVERT')
	 device,get_graphics_function=temp,set_graphics_function=invert
	 for i=0,(opt.num-1) do begin
	    ind=i+opt.disp-opt.num/2
	    if ((ind ge 0) and (ind le dims(1))) then begin
	       temp1=pos(7*i+4)+y(0)
	       temp2=pos(7*i)-y(1)
	       polyfill,x,[temp1,temp1,temp2,temp2],/device
	    end
	 end
	 device,set_graphics_function=3
	 wset,IDs.draw
	 device,copy=[0,0,cst.dimx,cst.dimx,0,0,0]
	 device,set_graphics_function=temp
      end until ((!err mod 2) eq 0)
      xrg=([p0(0),x0]-cst.borders(0))/(cst.borders(1)-cst.borders(0))
      temp=[y(0),pos(0)-pos(4)-y(1)]/(pos(0)-pos(4))
      yrg=(rgs.yspec(1)-rgs.yspec(0))*temp+rgs.yspec(0)
      df_zoom,varAccess,1,1,xrg,yrg,-1
   end
   if (ev.press eq 4) then df_unzoom,varAccess,0,-1
   widget_control,/clear_events,ev.top
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; MINI WINDOW EVENT
;;; -+-+-+-+-+-+-+-+-

pro df_mini_event,varAccess,ev
;;;;; This procedure quits if the event is not a <button pressed>.
;;;;; If the button is the right one, then the df_unzoom is called. Otherwise,
;;;;; a pixmap with the currently displayed spectrum is created. It is used
;;;;; in the loops that read the cursor position. If the pressed button is
;;;;; the center one, then the loop draws a rectangle of a constant size
;;;;; in pixmap ID 0, where the previous pixmap has been copied, then pixmap
;;;;; ID 0 is copied to the mini window, and the df_zoom procedure is called,
;;;;; so that moving the selection rect is updated in real time. If the
;;;;; pressed button is the right one, then the loop just draws a new selection
;;;;; rect, with the same method as above. In both case, the loop exits when
;;;;; the mouse button is released. The events are cleared at the end of
;;;;; the procedure, so pressing several buttons generates only one event,
;;;;; for the first button pressed.
   thePix=1
   if (ev.type ne 0) then return
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=IDs,varAccess.IDs
   df_makePix,varAccess,thePix,0
   if (ev.press eq 1) then begin
      x0=ev.x
      y0=ev.y
      p0=[x0,y0]
      wset,IDs.mini
      repeat begin
	 cursor,x,y,/device,/nowait
	 if (x lt 0) then $
	    if (x0 ge p0(0)) then x0=cst.dimx $
	    else x0=0 $
	 else x0=x
	 if (y lt 0) then $
	    if (y0 ge p0(1)) then y0=cst.dimy $
	    else y0=0 $
	 else y0=y
	 if (opt.scale le 1) $
	 then df_update_mini,varAccess,thePix,1,[p0(0),x0],[0,cst.dimy] $
	 else df_update_mini,varAccess,thePix,1,[p0(0),x0],[p0(1),y0]
      end until ((!err mod 2) eq 0)
      df_zoom,varAccess,0,1,[p0(0),x0],[p0(1),y0],thePix
   end
   if (ev.press eq 2) then begin
      if ((ev.x lt rgs.Xmini(0)) or (ev.x gt rgs.Xmini(1)) or $
	 (ev.y lt rgs.Ymini(0)) or (ev.y gt rgs.Ymini(1))) then return
      p0=[ev.x,ev.y]
      x=ev.x
      y=ev.y
      used1=rgs.Xmini
      used2=rgs.Ymini
      repeat begin
	 if (opt.scale le 1) $
	 then df_zoom,varAccess,0,0,(used1-p0(0)+x),[0,cst.dimy],thePix $
	 else df_zoom,varAccess,0,0,(used1-p0(0)+x),(used2-p0(1)+y),thePix
	 cursor,x,y,/device,/nowait
      end until ((!err mod 4) lt 2)
   end
   if (ev.press eq 4) then df_unzoom,varAccess,0,thePix
   widget_control,/clear_events,ev.top
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PIXMAP PLOTTING, SCROLL WINDOW DISPLAY UPDATE
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro df_makePix,varAccess,x,y
;;;;; This procedure creates a pixamp ID `x', and draws inside the
;;;;; plots corresponding to the scroll window (`y' set to 1),
;;;;; or to the mini window (`y' set to 0), according to the settings.
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=daty,temp.y
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=cst,varAccess.constants
   window,x,xsize=cst.dimx,ysize=cst.dimx,/pixmap,retain=2 & trap_current=x
   if y then $
      for i=0,(opt.num-1) do begin
	 ind=i+opt.disp-opt.num/2
	 if ((ind ge 0) and (ind le dims(1))) then begin
	    plot,rgs.dxspec,rgs.yspec,/nodata,/device,/noerase, $
	       xtitle=("Spectrum # " + NUMtSTR(1+ind,0) + " - Value " + $
	       NUMtSTR(daty(ind),1)),yticks=1+5/sqrt(opt.num), $
	       pos=[cst.borders(0),pos(7*i+4),cst.borders(1),pos(7*i)], $
	       charsize=1.2,font=0,xstyle=9,ystyle=9, $
	       xticklen=1. ,yticklen=1.,xgridstyle=1,ygridstyle=1
;DID!!^
	    oplot,datx,data(*,ind),psym=opt.sym, $
	       color=(130+3*opt.num-(20-opt.num)*i)
	 end
      end $
   else begin
      rgs.range=[min(data(*,opt.disp)),max(data(*,opt.disp))]
      if (opt.scale ne 2) then rgs.Ymini=[0,cst.dimy] $
      else rgs.Ymini=(cst.dimy*(rgs.yspec-rgs.range(0)))/ $
	 (rgs.range(1)-rgs.range(0))
      plot,rgs.dxmini,rgs.range,/nodata,pos=[0,0,cst.dimx,cst.dimy], $
	 /device,xstyle=5,ystyle=5
      oplot,datx,data(*,opt.disp),color=120
      widget_control,set_uvalue=rgs,varAccess.ranges
   end
end

pro df_display,varAccess,x,y,z,minPix
;;;;; This procedure displays the spectrum `x', if the displayed one is
;;;;; not the `x' one, or if `y' is set to 1. It modifies the variable
;;;;; settings.disp and after that, calls df_makePix to create the new
;;;;; plots picture; the pixmap is then copied into the scroll window.
;;;;; If z is set to 1, the mini window is also updated, by calling
;;;;; the procedure df_update_mini.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=opt,varAccess.options
   if (((x eq opt.disp) and (y eq 0)) or (x gt dims(1))) then return
   opt.disp=x
   widget_control,set_uvalue=opt,varAccess.options
   df_autoscale,varAccess,0
   if opt.anim then begin
      df_makePix,varAccess,0,1
      widget_control,get_uvalue=cst,varAccess.constants
      widget_control,get_uvalue=IDs,varAccess.IDs
      wset,IDs.draw
      device,copy=[0,0,cst.dimx,cst.dimx,0,0,0]
   end
   if z then df_update_mini,varAccess,minPix,0
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; LECTURE DES WORKSPACES DE LAMP
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

pro df_loadRange,varAccess,test,r1,r2,r3,r4,r5,r6,r7
;;;;; This procedure writes the parameters into user value of
;;;;; the correct widget_label; which params, and which widget_label
;;;;; is determined by the `test' parameter: when set to 0, the seven
;;;;; parameters r1 to r7 are stored as ranges, when set to 1, r1 and r2
;;;;; only are stored into varAccess.limits.
   case test of
      0:    widget_control,varAccess.ranges, $
	       set_uvalue={dxmini:r1,dxspec:r2, $
	       xmini:r3,ymini:r4,range:r5,xspec:r6,yspec:r7}
      1:    widget_control,varAccess.limits, $
		  set_uvalue={minsp:r1,maxsp:r2}
      else: return
   end
end

pro df_loadData,varAccess,w,x,y,n,p,par,dims
;;;;; Writes the parameters into the data widget user values.
;;;;; The purpose of this procedure is only to avoid to type
;;;;; several times the same commands.
   widget_control,get_uvalue=data,varAccess.datAccess
   widget_control,set_uvalue=w,data.w
   widget_control,set_uvalue=x,data.x
   widget_control,set_uvalue=y,data.y
   widget_control,set_uvalue=n,data.n
   widget_control,set_uvalue=p,data.p
   widget_control,set_uvalue=par,data.par
   widget_control,set_uvalue=dims,data.dims
end

function df_loadRequest,varAccess,wkn,w,x,y,n,p,par
;;;;; This procedure modifies all variables for loading new data.
;;;;; All the needed data are passed as parameters. The returned value
;;;;; is 0 if `w' does not meet the size requirements (ie two-dimensional
;;;;; array), otherwise, the result is 1.
;;;;; When loading new data, the ranges, the limit values must be modified;
;;;;; the options.disp might need to be changed too, if the new data contains
;;;;; less spectra than the currently displayed spectrum.
   wkSize=size(w)
   if (wkSize(0) ne 2) then return,0
   temp=size(x)
   if (temp(0) ne 1) or (temp(1) ne wksize(1)) then x=indgen(wksize(1))
   temp=size(y)
   if (temp(0) ne 1) or ((temp(0) eq 1) and (temp(1) ne wksize(2))) then y=indgen(wksize(2))
   temp=size(p)
   if (temp(0) ne 1) or (temp(1) ne 31) then p=fltarr(31)
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=cst,varAccess.constants
   df_loadData,varAccess,w,x,y,n,p,par,[wkSize(1)-1,wkSize(2)-1]
   df_numor,varAccess
   opt.disp=min([opt.disp,wkSize(2)-1])
   rgs.dxmini=[min(x),max(x)]
   rgs.dxspec=rgs.dxmini
   maxs=fltarr(wkSize(1))
   mins=fltarr(wkSize(1))
   for i=0,wkSize(1)-1 do maxs(i)=max(w(i,*))
   for i=0,wkSize(1)-1 do mins(i)=min(w(i,*))
   df_loadRange,varAccess,1,mins,maxs
   widget_control,set_slider_min=0                ,IDs.dfslider
   widget_control,set_slider_max=long(wkSize(2)-1),IDs.dfslider
   widget_control,set_uvalue=[[0,cst.dimx,0,cst.dimy]],varAccess.zooms
   widget_control,set_uvalue=opt,varAccess.options
   widget_control,set_uvalue=rgs,varAccess.ranges
   if opt.anim then begin
      df_set_slider,varAccess,opt.disp
      df_update_mini,varAccess,-1,0
      if opt.surf then df_surf,varAccess
   end
   widget_control,get_uvalue=opt,varAccess.options
   temp=opt.anim
   opt.anim=(opt.surf eq 0)
   widget_control,set_uvalue=opt,varAccess.options
   df_zoom,varAccess,0,0,[0,cst.dimx],[0,cst.dimy],-1
   widget_control,get_uvalue=opt,varAccess.options
   opt.anim=temp
   widget_control,set_uvalue=opt,varAccess.options
   return,1
end

pro df_loadWorkspace,varAccess,x,labID
;;;;; This procedure reads all the data linked to the LAMP workspace Wx,
;;;;; and calls the df_loadRequest. It also prints messages about the
;;;;; current status ("loading", or "invalid workspace").
   wksize=BEN_WK_SIZE(x)
;DID!!
   if (wkSize(0) lt 1) or (wkSize(0) gt 2) then begin
      widget_control,set_value=("'W" + NUMtSTR(x,0) + "' is invalid."),labID
      print,string(7b)
      return
   end $
   else widget_control,set_value=("Loading 'W" + NUMtSTR(x,0) + "'."),labID
   BEN_READ_WK,x,data,datx,daty,datn,datp,datpar
;DID!!
   if (wkSize(0) eq 1) then begin
   	data  =[[data],[data]]
   	datay =[1,1]
   	wkSize=size(data)
   endif

   temp=df_loadRequest(varAccess,x,data,datx,daty,datn,datp,datpar)
   if (temp eq 0) then begin
      widget_control,set_value=("Failed !"),labID
      print,string(7b)
   end else widget_control,set_value=" ",labID
end

pro df_toggle_load,varAccess,x
;;;;; This procedure modifies the options.surface variable, that sets
;;;;; whether a surface is plotted or not, when loading a workspace.
   widget_control,get_uvalue=opt,varAccess.options
   opt.surf=x
   widget_control,set_uvalue=opt,varAccess.options
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PLOT SYMBOL SELECTION
;;; SURFACE PLOT WHEN LOADING
;;; -+-+-+-+-+-+-+-+-+-+-+-+-

pro df_select_sym,varAccess,test,sym
;;;;; This procedure modifies the variable that hold the current
;;;;; plot symbol; then, the display is updated.
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.sym=sym $
   else opt.lines=-opt.lines
   if (opt.sym lt 10) then opt.sym=opt.lines*abs(opt.sym) $
   else opt.sym=10
   widget_control,set_uvalue=opt,varAccess.options
   df_display,varAccess,opt.disp,1,0,-1
end

pro df_surf,varAccess
;;;;; Simply plots a surface, using Xi and Yi, in the scroll window.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=daty,temp.y
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   wset,IDs.draw
   m=64.0
   shade_surf,data,datx,daty,pos=[m,m,cst.dimx-m,cst.dimx-m],/device
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; HELP
;;; -+-+

pro df_help,base
   print,"HELP WANTED"
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; POSTSCRIPT FILE
;;; -+-+-+-+-+-+-+-

pro df_psfile,varAccess,base,n
;;;;; This procedure creates and displays a dialog window, to enter
;;;;; the PostScript file name. A 'Cancel' button destroy the new
;;;;; window. The creation of the PS file is done in the df_dialog_event
;;;;; procedure.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=datpar,temp.par
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=opt,varAccess.options
   if (datpar(0) eq '') then defName="Spectra#" $
   else defName=("N#" +      datpar(0)    + "_Spectra#")
;DID!!
;  else defName=("N#" + NUMtSTR(datpar,0) + "_Spectra#")
   if (opt.num eq 1) then defName=(defName + NUMtSTR(1+opt.disp ,0))  $
   else defName=(defName + NUMtSTR(1+max([0,opt.disp-opt.num/2]),0) + $
      "-" + NUMtSTR(1+min([dims(1),opt.disp+opt.num/2]),0))
   wind=widget_base(title="PS file name:",/column, $
      group_leader=base,uvalue=varAccess,resource_name="lampben")
   text=widget_text(wind,value=defName,/editable,xsize=32, $
      uvalue=[-88,414,n,0])
   subase=widget_base(wind,/row)
   label=widget_label(subase,value="'.ps' will be appended.   ")
   btn=widget_button(subase,value="Cancel",uvalue=[-88,414,n,2])
   btn=widget_button(subase,value=" OK ",uvalue=[-88,414,n,1,text])
   widget_control,/realize,wind
   widget_control,/input_focus,btn
   ;widget_control,/input_focus,text
   widget_control,set_text_select=[0,strlen(defName)],text
   xmanager,"ben_dfps",wind,event_handler="lamp_event_parser",/just_reg
end

pro df_dialog_event,varAccess,ev,uv
;;;;; This procedure is called by any widget of the PS file dialog, created
;;;;; by df_psfile. If the widget is the 'Cancel' button, then the window
;;;;; is simply destroyed. If it is the 'OK' button or the text widget,
;;;;; the content of the widget_text is read. If it is empty, then the
;;;;; procedure acts if the 'Cancel' button had been pressed. Otherwise,
;;;;; the plot is set to 'ps', and the file_name to it. The plot is done,
;;;;; and the file closed. After that, the previous plot device is restored.
;;;;; If an output error occurs, the current file is closed, and the device
;;;;; restored too, and an error string is displayed. In both case, the
;;;;; dialog window is destroyed.
   case uv(3) of
      0:    widget_control,get_value=psFile,ev.id
      1:    widget_control,get_value=psFile,uv(4)
      else: psFile=""
   end
   psFile=sys_dep      ('BLANKS',psFile(0))
   if (psFile eq '') then begin
      widget_control,/destroy,ev.top
      return
   end
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=daty,temp.y
   widget_control,get_uvalue=dims,temp.dims
;DID!!
   widget_control,get_uvalue=datpar,temp.par
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=rgs,varAccess.ranges
   psFile=psFile + '.ps'
   wplot=!D.name
   err=1
   on_ioerror,iferr
   wmulti=!P.multi
   set_plot,'ps'
   if opt.num eq 1 THEN $
   device,yoffset=11.,xoffset=.5,/inches,/landscape $
   ELSE $
   device,xsize=7.5,ysize=10.,yoffset=.75,xoffset=.5,/inches,/portrait
   device,bits_per_pixel=8,/color
   !P.multi=[0,1,opt.num,0,0]
   device,filename=psFile
   for i=0,(opt.num-1) do begin
      ind=i+opt.disp-opt.num/2
      if ((ind ge 0) and (ind le dims(1))) then begin
	 plot,rgs.dxspec,rgs.yspec,/nodata,xstyle=9,ystyle=9,charsize=1.6,font=0, $
	    xtitle=("Spectrum # " + NUMtSTR(1+ind,0) + " - Value " + $
	    NUMtSTR(daty(ind),1)),yticks=1+5/sqrt(opt.num), $
	    xticklen=1.,yticklen=1.,xgridstyle=1,ygridstyle=1,color=128
;DID!!
	 oplot,datx,data(*,ind),psym=opt.sym,color=128
      end
   end
;DID!!
   if n_elements(datpar) lt 2 then widx=0 else widx=fix(datpar(1))

   IF opt.num eq 1 THEN p=7. ELSE p=10.
   P_DID_PS_HEADER, p ,widx ,psFile
   err=0
iferr : $
   if err eq 1 then device,/close_file
   set_plot,wplot
   !P.multi=wmulti
   if uv(3) then tID=uv(4) $
   else tID=ev.id
   if err then widget_control,set_value=("ERROR:" + !ERR_STRING),tID $
   else widget_control,set_value=('PS file : ' + psFile),tID
   wait,.05
   widget_control,/destroy,ev.top
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; DATA INITIALIZATION
;;; -+-+-+-+-+-+-+-+-+-

pro df_numor,varAccess
;;;;; This procedure displays the number numor in a label.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=datpar,temp.par
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=IDs,varAccess.IDs
   if (datpar(0) eq '') then temp=' ' $
   else temp=("Numor # " +      datpar(0)   )
;DID!!
;  else temp=("Numor # " + NUMtSTR(datpar,0))
   if n_elements(datpar) gt 1 then if datpar(2) ne '' then temp=strmid(datpar(2),0,52)
   widget_control,set_value=temp,IDs.numLab
   if (temp eq ' ') then temp='' $
   else temp=('  (' + temp + ')')
   widget_control,tlb_set_title=(cst.title + temp),IDs.numLab
end

pro df_initData,varAccess,request
;;;;; Fill the data variables, according to `request'. If `request' is
;;;;; set to 1, the scroll spectra window was opened because of a
;;;;; request from the desk; the function must start with the
;;;;; requested data, stored in the common `ben_data'. So, if `request'
;;;;; is set to 1, those data are loaded; if it is set to 0, default
;;;;; data are loaded, by calling `df_defaultData'.
   widget_control,get_uvalue=cst,varAccess.constants
   common ben_data,wk,w,x,y,n,p,par
   if request then begin
      wkSize=size(w)
      if (wkSize(0) eq 2) then begin
	 temp=size(x)
	 if (temp(0) ne 1) or (temp(1) ne wkSize(1)) then $
	    x=indgen(wksize(1))
	 temp=size(y)
	 if (temp(0) ne 1) or (temp(1) ne wkSize(2)) then $
	    y=indgen(wksize(2))
	 temp=size(p)
	 if (temp(0) ne 1) or (temp(1) ne 31) then $
	    p=fltarr(31)
	 df_loadData,varAccess,w,x,y,n,p,par,(wkSize(1:2)-1)
	 maxsp=fltarr(wkSize(1))
	 minsp=fltarr(wkSize(1))
	 for i=0,wkSize(1)-1 do maxsp(i)=max(w(i,*))
	 for i=0,wkSize(1)-1 do minsp(i)=min(w(i,*))
	 dxRg=float([min(x),max(x)])
	 widget_control,get_uvalue=opt,varAccess.options
	 temp=w(*,opt.disp)
	 df_loadRange,varAccess,0,dxRg,dxRg,[0,cst.dimx], $
	    [0,cst.dimy],[min(temp),max(temp)], $
	    [0,wkSize(1)-1],[min(minsp),max(maxsp)]
	 df_loadRange,varAccess,1,minsp,maxsp
      end else df_defaultData,varAccess
   end else df_defaultData,varAccess
end

pro df_defaultData,varAccess
;;; Inits the data when 'Scroll Spectra' is not called via 'request'
   widget_control,get_uvalue=cst,varAccess.constants
   dimx=63L
   dimy=63L
   data=dist(dimx+1,dimy+1)
   datx=indgen(dimx+1)
   df_loadData,varAccess,data,datx,indgen(dimy+1), $
      0,fltarr(31),0,[dimx,dimy]
   maxsp=fltarr(dimx+1)
   minsp=fltarr(dimx+1)
   for i=0,dimx do maxsp(i)=max(data(i,*))
   for i=0,dimx do minsp(i)=min(data(i,*))
   dxRg=float([min(datx),max(datx)])
   widget_control,get_uvalue=opts,varAccess.options
      temp=data(*,opts.disp)
   df_loadRange,varAccess,0,dxRg,dxRg,[0,cst.dimx],[0,cst.dimy], $
      [min(temp),max(temp)],[0,dimx],[min(minsp),max(maxsp)]
   df_loadRange,varAccess,1,minsp,maxsp
end

function df_inits,test,x
;;;;; This function returns some default value for the parameter
;;;;; settings, or constants of the program.
@lamp.cbk
   if lamp_siz lt 800 then xxx=384.0 else xxx=512.0
   if lamp_siz lt 800 then yyy= 64.0 else yyy= 64.0
   num=1
   case test of
      0:    res={dimx:xxx,dimy:yyy,zoom_max:16, $
		 borders:[yyy,xxx-32.0],title:x}
      1:    res={disp:0,num:num,sym:0,lines:-1,scale:1,anim:1,speed:3,surf:0}
      2:    res=[[0,xxx,0,yyy]]
      3:    res=xxx*rotate(indgen(7*num),2)/(7.0*num)
      else: res=0
   end
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; WIDGET CREATION
;;; -+-+-+-+-+-+-+-

pro ben_df_create,lamp,n,m,base,request
@lamp.cbk
   if (m eq 0) then winTitle=desk_name(n,1) $
   else winTitle=(desk_name(n,1) + " " + NUMtSTR(1+m,0))
   if (lamp_siz lt 1000) then begin
      base=widget_base(title=winTitle,/row,group_leader=lamp, $
	   resource_name='lampben')
      bas1=widget_base(base,/column)
      bas2=widget_base(base,/column)
      test=1
   end else begin
      base=widget_base(title=winTitle,/column,group_leader=lamp, $
	   resource_name='lampben')
      bas1=base & bas2=base
      test=0
   end

   constants=df_inits(0,winTitle)
   options  =df_inits(1)

;;;;; Creation of the first button row.
   if test then begin
      comID   =BEN_COMMANDS(bas1,n,[0,0])
      surfBase=widget_base (bas1,/nonexclusive)
      hint    =widget_base (bas1,/column,/frame)
      vars    =widget_base (bas1,/row)
   end else begin
      temp    =widget_base (bas1,/row)
      left    =widget_base (temp,/column)
      vars    =widget_base (temp,/column)
      comID   =BEN_COMMANDS(left,n,[0,0])
      surfBase=widget_base (left,/nonexclusive)
      hint    =widget_base (vars,/column,/frame)
   end

   surfBtn=widget_button(surfBase,uvalue=[-88,415,n,comID(4)], $
      value="Plot surface when loading workspace")
   numLab=widget_label  (bas1,value=" ",xsize=constants.dimx/(test+1),font=ft_b_bigger)

;;;;; Creation of the widget_label containing in their user value the
;;;;; variables used by the Scroll spectra function. Their IDs are stored
;;;;; in the top_level base user value.
   datAccess=widget_base(vars,/row)
   data	 =widget_label(datAccess,value="")
   datx	 =widget_label(datAccess,value="")
   daty	 =widget_label(datAccess,value="")
   datn	 =widget_label(datAccess,value="")
   datp	 =widget_label(datAccess,value="")
   datppp=widget_label(datAccess,value="")
   dims	 =widget_label(datAccess,value="")
   dat={w:data,x:datx,y:daty,n:datn,p:datp,par:datppp,dims:dims}
   widget_control,set_uvalue=dat,datAccess

   vars=widget_base(vars,/row)
   const =widget_label(vars,value="",uvalue=constants)
   opts	 =widget_label(vars,value="",uvalue=options)
   ranges=widget_label(vars,value="")
   zooms =widget_label(vars,value="",uvalue=df_inits(2))
   pos	 =widget_label(vars,value="",uvalue=df_inits(3))
   lmt	 =widget_label(vars,value="")
   IDs	 =widget_label(vars,value="")
   varAccess={datAccess:datAccess,constants:const,options:opts, $
      ranges:ranges,zooms:zooms,pos:pos,limits:lmt,IDs:IDs}
   widget_control,set_uvalue=varAccess,base

;;;;; All the 'variable widgets' are now created. The data is initialized
;;;;; by calling the df_initData procedure.
   df_initData,varAccess,request
   widget_control,get_uvalue=dims,dat.dims

;;;;; Creation of the 'hint' labels.
   temp=widget_label(hint,value="left button zooms")
   temp=widget_label(hint,value="right button unzooms")
   temp=widget_label(hint,value="center button moves selection")

;;;;; Creation of the mini draw window, that will show a miniature of
;;;;; the displayed spectrum, and of the scrolling window, with its
;;;;; slider, used as a scroll bar.
   mini=widget_draw(widget_base(bas2,/row,/frame),/button_events, $
      xsize=constants.dimx,ysize=constants.dimy,retain=2,uvalue=[-88,407,n])
   picts=widget_base(bas2,/row,/frame)
   draw=widget_draw(picts,xsize=constants.dimx,ysize=constants.dimx, $
      retain=2,uvalue=[-88,416,n],/button_events)
   dfslider=widget_slider(picts,min=0,max=long(dims(1)),value=long(dims(1)), $
      /vertical,/suppress_value,/drag,uvalue=[-88,408,n],ysize=constants.dimx)

;;;;; Creation of the 'number of plots' slider, the 'draw lines' slider,
;;;;; and the 'plot symbol' menu. The 'draw lines' has effect only when a
;;;;; symbol is chosen, to determine whether the points should be connected
;;;;; or not; if no plot is chosen, there is always lines between points...
   if test then begin
      temp=widget_slider(bas1,title="Number of plots",min=1,max=8, $
	                 value=options.num,/drag,uvalue=[-88,410,n])
      controls=bas1
      b_logo   =widget_base  (controls,/row)
		put_logo     ,b_logo
      drawlines=widget_button(widget_base(b_logo,/nonexclusive), $
			      value="Draw lines",uvalue=[-88,413,n,0,0])
      menus=widget_base(controls,/row)
      psBase=controls
   end else begin
      controls=widget_base(bas1,/row,space=16)
      left=widget_base(controls,/column)
      temp=widget_slider(left,title="Number of plots",min=1,max=8, $
			 value=options.num,/drag,uvalue=[-88,410,n])
      b_logo   =widget_base  (left,/row)
		put_logo     ,b_logo
      drawlines=widget_button(widget_base(b_logo,/nonexclusive), $
			      value="Draw lines",uvalue=[-88,413,n,0,0])
      menus=widget_base(left,/row,space=32)
      psBase=menus
   end
   symbol=widget_button(menus,value="Plot symbol",menu=2)
   temp=widget_button(symbol,value="< None >",uvalue=[-88,413,n,1,0])
   temp=widget_button(symbol,value=" +",uvalue=[-88,413,n,1,1])
   temp=widget_button(symbol,value=" *",uvalue=[-88,413,n,1,2])
   temp=widget_button(symbol,value=" .",uvalue=[-88,413,n,1,3])
   temp=widget_button(symbol,value=" X",uvalue=[-88,413,n,1,7])
   temp=widget_button(symbol,value="Histogram",uvalue=[-88,413,n,1,10])
   sub=widget_button(symbol,value="Other",/menu)
   temp=widget_button(sub,value="Diamond",uvalue=[-88,413,n,1,4])
   temp=widget_button(sub,value="Triangle",uvalue=[-88,413,n,1,5])
   temp=widget_button(sub,value="Square",uvalue=[-88,413,n,1,6])

;;;;; Creation of the 'animate' menu, that starts the animation, or
;;;;; modifies its speed. It also contains a 'stop' menu item, that
;;;;; is sensitive only when an animation is running.
   anim=widget_button(menus,value="Animate",menu=2)
   stopMenu=widget_button(anim,value="Stop",font=ft_b_normal, $
      uvalue=[-88,409,n,-1])
   temp=widget_button(anim,value="Slow",uvalue=[-88,409,n,15])
   temp=widget_button(anim,value="Normal",uvalue=[-88,409,n,7])
   temp=widget_button(anim,value="Fast",uvalue=[-88,409,n,2])
   psBtn=widget_button(psBase,value="To PS file...",uvalue=[-88,412,n])

;;;;; Creation of the ranges buttons. The 'full range' button has nothing
;;;;; to do with autoscale, but simply makes a total unzoom of the spectra.
   right=widget_base(controls,/column)
   fscl=widget_button(right,value="Full range",uvalue=[-88,417,n])
   scl=widget_base(right,/column,/frame)
   temp=widget_label(scl,value="Autoscale using:",font=ft_b_normal)
   temp=widget_base(scl,/exclusive,/column)
   scl0=widget_button(temp,value="All plots",uvalue=[-88,406,n,0])
   scl1=widget_button(temp,value="Displayed plots",uvalue=[-88,406,n,1])
   scl2=widget_button(temp,value="No Autoscale",uvalue=[-88,406,n,2])

;;;;; All the widgets are declared. According to the startup options,
;;;;; the toggle button states are modified, and widget IDs are stored.
   if options.surf then widget_control,/set_button,surfBtn
   temp=execute("widget_control,/set_button,scl" + NUMtSTR(options.scale,0))
   if (options.lines le 0) then widget_control,/set_button,drawlines
   widget_control,sensitive=0,stopMenu
   bid=sys_dep      ('DYNLAB',base,1)
   widget_control,/realize,base & put_logo
   widget_control,get_value=drawID,draw
   widget_control,get_value=minID,mini
   IDlist={mini:minID,draw:drawID,dfSlider:dfSlider, $
      stopMenu:stopMenu,psBtn:psBtn,numLab:numLab}
   widget_control,set_uvalue=IDlist,varAccess.IDs
   df_numor,varAccess
   df_change_numb,varAccess,options.num
   df_display,varAccess,options.disp,1,1,-1
   xmanager,desk_name(n,0),base,event_handler="lamp_event_parser",/just_reg
end

;;; ***************************************************************************
;;; ***			      RADIAL INTEGRATION			    ***
;;; ***************************************************************************

pro int_event,ev,uv
   widget_control,get_uvalue=varAccess,ev.top
   case uv(1) of
      400:  begin wait,.05 & widget_control,/destroy,ev.top & end
      401:  BEN_CHANGE_WORKSPACE,uv
      402:  int_help,varAccess,ev.top
      403:  int_loadWorkspace,varAccess,uv(3),uv(4)
      405:  int_plotMenu,varAccess,uv
      406:  int_updateRay,varAccess,ev,uv(3)
      407:  int_changeZone,varAccess,ev,uv(3),uv(4)
      408:  int_miniPix,varAccess,1
      409:  int_changeCenter,varAccess
      410:  int_zonePlot,varAccess,ev.select
      411:  int_updateRes,varAccess,uv(3),uv(4),uv(5)
      412:  int_updateMini,varAccess,ev,uv
      else: print,"INT_EVENT:",varAccess,uv
   end
end

function int_testModule,x
   return,0
end

pro int_help,base
   print,"HELP WANTED"
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PROCEDURES FOR DRAWING THE SELECTION PICTURE
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

function int_middle,varAccess,x,y
;;;;; This function returns the middle angle of x and y.
   if (x lt 0) then x=360.0 + x
   if (x gt y) then return,(180.0+(x+y)/2.0) $
   else return,(x+y)/2.0
end

pro int_poly,a1,a2,a3,c,c_x,c_y,r1,r2,deg2rad,test
;;;;; Procedure 'int_poly' draws the section enclosed in angles
;;;;; a1 and a3, and radia r1 and r2, in the current window.
   a12=int_middle(varAccess,a1,a2)
   a23=int_middle(varAccess,a2,a3)
   temp1=[a1,a12,a2,a23,a3]*deg2rad
   temp2=[a3,a23,a2,a12,a1]*deg2rad
   x=[r1*cos(temp1),r2*cos(temp2),r1*cos(a1*deg2rad)]
   y=[r1*sin(temp1),r2*sin(temp2),r1*sin(a1*deg2rad)]
   oplot,c_x+x,c_y+y,color=c,thick=2,psym=0
   oplot,c_x-x,c_y-y,color=c,thick=2,psym=0,lineStyle=2*test
end

pro int_drawAxes,varAccess
;;;;; This procedure updates the mini widget_draw.
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=pix,varAccess.pixmap
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=col,varAccess.colors
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=opt,varAccess.options
   c_x=set.cx+0.5
   c_y=set.cy+0.5
   if (dims.dim eq dims.dimx) $
   then c_y=c_y+(dims.dim-dims.dimy)/2.0*(dims.dimx/dims.dim) $
   else c_x=c_x+(dims.dim-dims.dimx)/2.0*(dims.dimy/dims.dim)
   cur=set.alpha
   window,0,xsize=cst.minSize,ysize=cst.minSize,/pixmap,retain=2 & trap_current=0
   tvscl,pix.img,pix.xmarg,pix.ymarg,order=0
   if ((pix.xmarg ne 0) or (pix.ymarg ne 0)) then begin
      x=pix.xmarg*[1,1,-1,-1,1]+[-1,-1,cst.minSize,cst.minSize,-1]
      y=pix.ymarg*[1,-1,-1,1,1]+[-1,cst.minSize,cst.minSize,-1,-1]
      plot,x,y,xrange=[0,cst.minSize],yrange=[0,cst.minSize], $
	 /device,/noerase,pos=[0,0,cst.minSize,cst.minSize], $
	 lineStyle=1,xstyle=5,ystyle=5,psym=0
   end
   temp=[-dims.dim,dims.dim]*sqrt(2)
   plot,[0,dims.dim],[0,dims.dim],/nodata,/noerase,/device, $
      xstyle=5,ystyle=5,pos=[0,0,cst.minSize,cst.minSize],psym=0
   for i=0,(set.zones-1) do begin
      if set.zones le 8 then $
      oplot   , cos(cur*cst.deg2rad)*temp+c_x,sin(cur*cst.deg2rad)* $
	        temp+c_y,color=col(i),thick=2,psym=0
      int_poly,(cur-set.beta),cur,(cur+set.beta),col(i), $
	        c_x,c_y,set.r1,set.r2,cst.deg2rad,opt.plotZone
      cur=cur+set.gamma
   end
   polyfill,c_x+set.mx*[-1,-1,1,1],c_y+set.my*[1,-1,-1,1],color=0
   wset,IDs.mini
   device,copy=[0,0,cst.minSize,cst.minSize,0,0,0]
end

pro int_miniPix,varAccess,test
;;;;; This function calculates an array, according to the
;;;;; options, of the same size as the mini widget_draw.
;;;;; This array is stored, so that, when changing the
;;;;; mini widget_draw, it can be used for `tvscl'.
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.logAspect=(opt.logAspect ne 1)
   xmarg=0
   ymarg=0
   if opt.logAspect then img=alog(1.0+data) $
   else img=data
   if (dims.dimx eq dims.dimy) then $
      if (((cst.minSize mod dims.dim) eq 0) or $
	 ((dims.dim mod cst.minSize) eq 0)) $
           then miniPix=congrid(img,cst.minSize,cst.minSize) $
      else miniPix=congrid(img,cst.minSize,cst.minSize) $
   else begin
      dx=cst.minSize & dy=cst.minSize
      if (dims.dimx gt dims.dimy) $
      then dy=round(cst.minSize*(dims.dimy/dims.dimx)) $
      else dx=round(cst.minSize*(dims.dimx/dims.dimy))
      miniPix=congrid(img,dx,dy)
      xmarg=round((cst.minSize-dx)/2.0)
      ymarg=round((cst.minSize-dy)/2.0)
   end
   uv={img:miniPix,xmarg:xmarg,ymarg:ymarg}
   widget_control,set_uvalue=uv,varAccess.pixmap
   widget_control,set_uvalue=opt,varAccess.options
   int_drawAxes,varAccess
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; 'PLOT' MENU EVENTS
;;; -+-+-+-+-+-+-+-+-+

function int_radial,win
;******* **********
@lamp.cbk
common didmod,IDdid ,wbuf,xbuf,ybuf,titx,tity

x20=xbuf & y20=ybuf & x_tit(20)=titx & y_tit(20)=tity
return,reform(wbuf)
end

pro int_plotMenu,varAccess,uv
;** ************
;**

   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=opt,varAccess.options
   if (uv(3) eq 0) then begin
      widget_control,get_uvalue=prev,varAccess.plots(uv(4))
      range=[min([set.r1,set.r2,prev.r(0)]),max([set.r1,set.r2,prev.r(1)])]
      int_updateRes,varAccess,uv(5),uv(6),uv(7)
      widget_control,get_uvalue=new,varAccess.plots(0)
      maxVal=max([max(prev.res),max(new.res)])
      widget_control,set_value=("Plotting..."),uv(5)
      int_plot,varAccess, new.res,round(range),opt.plotZone,1,maxVal  ,'X',uv(6),0
      int_plot,varAccess,prev.res,round(range),opt.plotZone,0,maxVal ,'X',uv(6),0
      widget_control,set_value=("Ready."),uv(5)
   end $
   else if (uv(3) eq 1) then begin
      widget_control,get_uvalue=IDs,varAccess.IDs
      widget_control,get_uvalue=temp,varAccess.plots(0)
      widget_control,set_uvalue=temp,varAccess.plots(uv(4))
      widget_control,/sensitive,IDs.menu(uv(4))
      widget_control,/sensitive,IDs.menu(uv(4)+2)
   end $
   else if (uv(3) eq 2) then begin
      widget_control,get_uvalue=toplot,varAccess.plots(uv(4))
;DID!!
;     odat=0 & range=0
;     temp=execute("odat=p"+NUMtSTR(uv(4),0))
;     temp=execute("range=p" + NUMtSTR(uv(4),0) + "r")
;     int_plot,varAccess,toplot.res,round(toplot.r),opt.plotZone,1,max(odat)      ,'X',uv(6),0
      int_plot,varAccess,toplot.res,round(toplot.r),opt.plotZone,1,max(toplot.res),'X',uv(6),0
   end $
   else if (uv(3) eq 3) then begin
;DID!!
      widget_control,get_uvalue=toplot,varAccess.plots(0)

      widget_control,get_uvalue=datpar,varAccess.datAccess.par
      widx=0 & cfil=''
      if n_elements(datpar) gt 1 then begin cfil=strtrim(datpar(0),2)
      					    widx=fix(datpar(1)) & endif
      psFile='radial'+cfil+'.ps'
      wplot=!D.name
      err=1
      on_ioerror,iferr
      if uv(6) eq 0 then begin
      	set_plot,'ps'
      	device,xsize=7.5,ysize=10.,yoffset=.75,xoffset=.5,/inches,/portrait
      	device,filename=psFile
      	device,bits_per_pixel=8,/color
	endif
      int_plot,varAccess,toplot.res,round(toplot.r),opt.plotZone,1,max(toplot.res),'PS',uv(6),0

      if uv(6) eq 0 then P_DID_PS_HEADER, 10. ,widx , psFile $
		    else XICUTE,'w20=int_radial(w'+strtrim(fix(widx),2)+') ;'+datpar(0)
      err=0
      iferr: if err eq 1 then device,/close_file
      set_plot,wplot
   end
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; SUB-PROCEDURES CALLED DURING INTEGRATION
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

function int_area,varAccess,bet1,bet2
;;;;; This function returns the minimum rectangle containing
;;;;; the sector between bet1 and bet2, and r1 and r2.
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   deg2rad=!pi/180.0
   r1=min([set.r1,set.r2],max=r2)
   temp=cos([bet1,bet2]*deg2rad)
   projx=[r1*temp,r2*temp]
   temp=sin([bet1,bet2]*deg2rad)
   projy=[r1*temp,r2*temp]
   left=min(projx)-1
   right=max(projx)+1
   top=max(projy)+1
   bottom=min(projy)-1
   if (bet1 lt 180) and (bet2 gt 180) then left=-(r2+1) $
   else if (bet1 gt bet2) then right=r2+1
   if (bet1 lt 90) and (bet2 gt 90) then top=r2+1 $
   else if (bet1 lt 270) and (bet2 gt 270) then bottom=-(r2+1)
   temp=round([max([0,left+set.cx]),min([dims.dimx-1,right+set.cx]), $
      max([0,bottom+set.cy]),min([dims.dimy-1,top+set.cy])])
   return,temp
end

function int_inZone,varAccess,x,y,a1,a2,r1,r2,mx,my
;;;;; This function tests if the point (x,y) is in the zone
;;;;; defined by the angles a1 and a2, and the radia r1 adn r2.
;;;;; It also verifies that (x,y) is not within the mask mx,my.
;;;;; If the point is in the zone and not masked, then the function
;;;;; returns the radius it belongs to; else, it returns -1.
   if ((abs(x) le mx) and (abs(y) le my)) then return,-1
   ray=round(sqrt(x^2+y^2))
   if ((ray lt r1) or (ray gt r2)) then return,-1
   angle=180.0*atan(y,x)/!pi
   if (angle lt 0) then angle=angle + 360.0
   if (a1 gt a2) then test=((angle lt a1) and (angle gt a2)) $
   else test=((angle lt a1) or (angle gt a2))
   if test then return,-1 $
   else return,ray
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; RADIAL INTEGRATION AND RESULT PLOTTING
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro int_updateRes,varAccess,labelID, logID ,didID
;;;;; This procedure first calls `int_changeCenter', to read the
;;;;; widget_text, in case the user forgot to type return to validate.
;;;;; Then the integration is done. When the result is obtained, it
;;;;; is plotted by calling the `int_plot' procedure.
   int_changeCenter,varAccess
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=data,varAccess.datAccess.w
   r1=min([set.r1,set.r2],max=r2)
   if (r1 eq r2) then if (r2 eq 0) then r2=1 else r1=r1-1
;   print,("alpha=" + NUMtSTR(set.alpha,0) + ", beta=" + $
;      NUMtSTR(set.beta,0) + ", r1=" + NUMtSTR(r1,0) + $
;      ", r2=" + NUMtSTR(r2,0))
   res=fltarr(2*dims.dim,2*set.zones)
   cur=set.alpha
   startTime=systime(1)
   for k=0,(set.zones-1) do begin
      if (labelID gt 0) then $
	 widget_control,set_value=("Sector #" + NUMtSTR(k+1,0)),labelID
      for p=0,1 do begin
	 numb=intarr(2*dims.dim)
	 sum=fltarr(2*dims.dim)
	 bet1=(cur-set.beta+360.0+p*180.0) mod 360
	 bet2=(cur+set.beta+p*180.0) mod 360
	 rect=int_area(varAccess,bet1,bet2)
	 for i=rect(0),rect(1) do $
	    for j=rect(2),rect(3) do begin
	       temp=int_inZone(varAccess,i-set.cx,j-set.cy, $
		  bet1,bet2,r1,r2,set.mx,set.my)
	       if (temp ge 0) then begin
		  sum(temp)=sum(temp)+data(i,j)
		  numb(temp)=numb(temp)+1
	       end
	    end
	 temp=where(numb eq 0,count)
	 if (count ne 0) then begin
	    numb(temp)=1
	    sum(temp)=-1
	 end
	 res(*,2*k+p)=sum/numb
      end
      cur=cur+set.gamma
   end
   int_time=systime(1)-startTime
   ;;; The current result is stored in plots(0)...
   widget_control,set_uvalue={res:res,r:[r1,r2]},varAccess.plots(0)
;  widget_control,/sensitive,IDs.menu(0)
   ;;; ... and then it is plotted.
   widget_control,bad_ID=bad,set_value=("Plotting..."),labelID
   int_plot,varAccess,res,round([r1,r2]),opt.plotZone,1,max(res) ,'X',0 ,didID
;;; !!!
;;;  TEST RADIES (A ENLEVER QUAND MEME, APRES...)
;;; !!!
;widget_control,bad_ID=bad,set_value=("RADIES..."),labelID
;res=fltarr(dims.dim,2*set.zones)
;cur=set.alpha
;startTime=systime(1)
;for k=0,(set.zones-1) do begin
;   for p=0,1 do begin
;      a1=(cur-set.beta+360.0+p*180.0) mod 360
;      a2=(cur+set.beta+p*180.0) mod 360
;      res(*,2*k+p)=radtst(data,set.cx,set.cy,r1,r2,a1,a2)
;   end
;   cur=cur+set.gamma
;end
;rad_time=systime(1)-startTime
;window,8,retain=2,title="Radies result",xsize=422,ysize=448
;maxVal=max(res)
;plot,[r1,r2],[0,maxVal],/nodata,xstyle=9,ystyle=9,color=0,background=255, $
;   xtitle='Radius (pixels)',ytitle='Mean value',pos=[.2,.1,.9,.9],charsize=1.2
;for k=0,(set.zones-1) do begin
;colors=120/max([1.0,(set.zones-1)])*indgen(set.zones)
;for k=0,(set.zones-1) do begin
;   oplot,res(*,2*k),color=colors(k),max_value=maxVal
;   oplot,res(*,2*k+1),color=colors(k),lineStyle=2, $
;end
;      thick=3,max_value=maxVal
;end
;if (int_time ge rad_time) then temp=[" ","*"] else temp=["*"," "]
;print,(temp(0) + " Intrad : " + NUMtSTR(int_time,2) + ' s')
;print,(temp(1) + " Radies : " + NUMtSTR(rad_time,2) + ' s')
;;; !!!
;;; !!!
   widget_control,bad_ID=bad,set_value=("Ready."),labelID
end

pro int_plot,varAccess,data,rays,test,new,maxVal ,XPS ,logID ,didID
;;;;; This procedure plots the data (result of an integration), with
;;;;; an xrange of `rays', and a maximum value equal to `maxVal'.
;;;;; If new is equal to 1, then the previous plot is erased. The
;;;;; `test' param is used to test if `data' is the major plot or not.
;;;;; This procedure is useful to plot several results, obtained with
;;;;; different angles and/or rays, in the same window.

common didmod,IDdid ,wbuf,xbuf,ybuf,titx,tity
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current


if n_elements(IDdid) eq 0 then IDdid=1
if didID ne 0 then IDdid=didID

   widget_control,get_uvalue=IDs   ,varAccess.IDs

;DID!! logID if =1 then output to a workspace

   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   if n_elements(datpar) gt 1 then mtit=datpar(0) else mtit=''

   temp=size(data)
   zones=temp(2)/2
   colors=120/max([1.0,(zones-1)])*indgen(zones)
   if XPS eq 'X' then wset,IDs.draw
   trap_current=IDs.draw

   modata=data
   if (rays(0) gt 0)	     then modata(0:rays(0)-1,*)		=1+maxVal
   temp=size(modata)
   if (rays(1) lt temp(1)-1) then modata(rays(1)+1:temp(1)-1,*) =1+maxVal

   if IDdid eq 1 then begin
     	ranx=rays
     	rany=[0,maxVal]+opt.logAspect*0.1
     	titx='Radius (pixels)'
   endif else begin
        div  =rays(1)-rays(0)+1
   	if (test and new) then begin
   		 didat=fltarr(zones*2+1)
   		 div  =rays(1)-rays(0)+1
      		 for k=0,(zones-1) do begin dat =modata(rays(0):rays(1),2*k)
      		 			    idx =where(dat lt 0,count)
      		 			    if count eq div then didat(k+1)=-1 else $
      		 			       didat(k+1)      = total(dat>0) / ((div-count)>1)
      		 			    dat =modata(rays(0):rays(1),2*k+1)
      		 			    idx =where(dat lt 0,count)
      		 			    if count eq div then didat(k+zones+1)=-1 else $
      		 			       didat(k+zones+1)= total(dat>0) / ((div-count)>1)  & endfor
     		 ranx =[1,zones*2]
   	endif else begin
   		 didat=fltarr(zones+1)
      		 for k=0,(zones-1) do begin dat =modata(rays(0):rays(1),2*k:2*k+1)
      		 			    idx =where(dat lt 0,count)
      		 			    if count eq 2*div then didat(k+1)=-1 else $
      		 			       didat(k+1)      = total(dat>0) /((2*div-count)>1) & endfor
     		 ranx =[1,zones]
   	endelse
   	maxd=max(didat)
     	rany=[0,maxd]+opt.logAspect*0.1
     	titx='Sectors'
   endelse

   tity='Mean value'

   if new and (not logID)  then begin
     if opt.logAspect ne 1 then begin
      if XPS eq 'X' then plot,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,color=0,$
      		xtitle=titx,ytitle=tity,pos=[.2,.1,.9,.9],background=255 $
      else		 plot,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,$
      		xtitle=titx,ytitle=tity,pos=[.2,.1,.9,.9],$
	        xticklen=1.,yticklen=1.,xgridstyle=1,ygridstyle=1,color=128
     endif else begin
      if XPS eq 'X' then plot_io,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,color=0,$
      		xtitle=titx,ytitle=tity+' LOG)',pos=[.2,.1,.9,.9],background=255 $
      else		 plot_io,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,$
      		xtitle=titx,ytitle=tity+' LOG)',pos=[.2,.1,.9,.9],$
	        xticklen=1.,yticklen=1.,xgridstyle=1,ygridstyle=1,color=128
     endelse
   endif

   if IDdid eq 1 then begin
    if (test and new) then begin
      if logID then begin  wbuf  =fltarr(rays(1)-rays(0),zones*2)
			   modata=modata(rays(0)+1:rays(1),*)
			   for k=0,(zones-1) do begin wbuf(0,k)      =modata(*,2*k)
						      wbuf(0,k+zones)=modata(*,2*k+1) & endfor
			   xbuf=findgen(rays(1)-rays(0))+rays(0)+1
			   ybuf=indgen (2*zones)+1 &  tity=tity+'/sectors'
      endif else begin
      	temp=where(modata lt 0,count)
      	if (count ne 0) then modata(temp)=2+maxVal
      	for k=0,(zones-1) do begin
	    oplot,modata(*,2*k)  ,color=colors(k),max_value=maxVal
	    oplot,modata(*,2*k+1),color=colors(k),max_value=maxVal,lineStyle=2,thick=3
      	endfor
      endelse
    endif else begin
      if logID then begin wbuf=fltarr (rays(1)-rays(0),zones)
			  xbuf=findgen(rays(1)-rays(0))+rays(0)+1
			  ybuf=indgen (zones) +1
			  if zones gt 1 then tity=tity+'/sectors' & endif
      for k=0,(zones-1) do begin
       datz=modata(*,2*k:2*k+1)
       temp=size(datz)
       for i=0,temp(1)-1 do $
	  if (datz(i,0) lt 0) then $
	     if (datz(i,1) lt 0) and (not logID) then datz(i,0)=2+maxVal $
	     else datz(i,0)=datz(i,1) $
	  else if (datz(i,1) ge 0) then datz(i,0)=(datz(i,0)+datz(i,1))/2.0
       if logID then wbuf(0,k)=datz(rays(0)+1:rays(1),0) else $
       if new   then oplot,datz(*,0),color=colors(k),max_value=maxVal $
      	        else oplot,datz(*,0),color=colors(k),max_value=maxVal,lineStyle=2,thick=2
      endfor
    endelse

   endif else begin
   	 if XPS eq 'X'then coco=0 else coco=128
         temp=where(didat lt 0,count)
         if (count ne 0) and (not logID) then didat(temp)=2+maxd
         if logID then begin wbuf=didat(1:*) & xbuf=findgen(ranx(1)-ranx(0)+1)+ranx(0)
			     ybuf=0          & endif else $
   	 if new then oplot,didat,color=coco,max_value=maxd $
   		else oplot,didat,color=coco,max_value=maxd,lineStyle=2,thick=2
   endelse
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PARAMETER MODIFICATIONS
;;; -+-+-+-+-+-+-+-+-+-+-+-

pro int_updateMini,varAccess,ev,uv
;;;;; This procedure is called to respond to an event from
;;;;; an angle (alpha,beta or gamma) widget_slider.
   widget_control,get_uvalue=set,varAccess.settings
   if (uv(3) eq 0) then set.alpha=ev.value else $
   if (uv(3) eq 1) then begin
   			set.beta =ev.value
   			widget_control,uv(4),SET_SLIDER_MAX=(180/(ev.value>1))<36
   endif else begin
      set.gamma=ev.value
      uv(4)=set.gamma
      widget_control,set_uvalue=uv,ev.id
   endelse
   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_changeZone,varAccess,ev,gamID,openID
;;;;; Called when the '# of sectors' slider sends an event.
;;;;; If the value has not changed, the procedure return; if the
;;;;; new value is 2, then the gamma value stored in the gamma slider
;;;;; is restored. Then , Called when the '# of sectors' slider sends an event.
;;;;; If the value has not changed, the procedure return; if the
;;;;; new value is 2, then the gamma value stored in the gamma slider
;;;;; is restored. Then, the mini picture is updated.
   widget_control,get_uvalue=set,varAccess.settings
   if (ev.value eq set.zones) then return
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,set_uvalue=120/max([1.0,(ev.value-1)])* $
      indgen(ev.value),varAccess.colors
   set.gamma=180.0/ev.value
   set.zones=ev.value
   if (ev.value eq 2) then begin
      widget_control,/sensitive,gamID
      widget_control,get_uvalue=temp,gamID
      set.gamma=temp(4)
   end $
   else widget_control,sensitive=0,gamID
;DID!!
   widget_control,set_slider_max=round(90./ev.value),openID

   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_changeCenter,varAccess
;;;;; This procedure reads the four widget_texts, and updates
;;;;; the corresponding variables, and the mini picture.
;;;;; It is called by the 'updateRes' procedure, and when the
;;;;; return key is pressed within a widget_text.
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=set,varAccess.settings
   set.cx=BEN_READTEXT(IDs.cx)-1.0
   widget_control,set_value=NUMtSTR(set.cx+1.0,2),IDs.cx
   set.cy=BEN_READTEXT(IDs.cy)-1.0
   widget_control,set_value=NUMtSTR(set.cy+1.0,2),IDs.cy
   set.mx=BEN_READTEXT(IDs.mx)
   widget_control,set_value=NUMtSTR(set.mx,2),IDs.mx
   set.my=BEN_READTEXT(IDs.my)
   widget_control,set_value=NUMtSTR(set.my,2),IDs.my
   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_updateRay,varAccess,ev,x
;;;;; Updates the ray variables, and redraws the mini picture.
   widget_control,get_uvalue=set,varAccess.settings
   test=0
   if x then if (set.r2 eq ev.value) then test=1 else set.r2=ev.value $
   else if (set.r1 eq ev.value) then test=1 else set.r1=ev.value
   if test then return
   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_zonePlot,varAccess,test
;;;;; Called by the two-state button 'Separate symetrical sectors'
   widget_control,get_uvalue=opt,varAccess.options
   opt.plotZone=test
   widget_control,set_uvalue=opt,varAccess.options
   int_drawAxes,varAccess
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; LAMP-DATA LOADING
;;; -+-+-+-+-+-+-+-+-

function int_loadRequest,varAccess,wkn,w,x,y,n,p,par
;;;;; This function checks the size of the parameter `w'. If it
;;;;; is not a 2-dimension array, then it returns 0. If `w' is a
;;;;; 2-dimension array, it is loaded, and the radia, and center
;;;;; widgets and variables are modified. Then the mini picture
;;;;; is modified, and an integration is calculated.
   wkSize=size(w)
   if (wkSize(0) ne 2) then return,0
   widget_control,get_uvalue=oldims,varAccess.datAccess.dims
   int_loadData,varAccess,w,x,y,n,p,par,wkSize(1:2)
   ;int_numor,varAccess
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   wset,IDs.draw
   erase
   rapport=dims.dim/oldims.dim
   temp=1+round(sqrt(2)*dims.dim)
   set.r1=min([set.r1*rapport,temp])
   set.r2=min([set.r2*rapport,temp])
   widget_control,set_slider_max=temp,IDs.r1
   widget_control,set_value=set.r1,IDs.r1
   widget_control,set_slider_max=temp,IDs.r2
   widget_control,set_value=set.r2,IDs.r2
   set.cx=set.cx*float(wkSize(1))/oldims.dimx
   set.cy=set.cy*float(wkSize(2))/oldims.dimy
   widget_control,set_value=NUMtSTR(set.cx+1.0,2),IDs.cx
   widget_control,set_value=NUMtSTR(set.cy+1.0,2),IDs.cy
   widget_control,set_uvalue=set,varAccess.settings
   int_miniPix,varAccess,0
;  widget_control,sensitive=0,IDs.menu(0)
   widget_control,sensitive=0,IDs.menu(1)
   widget_control,sensitive=0,IDs.menu(2)
;DID!!   int_updateRes,varAccess,-1,-1,1
   return,1
end

pro int_loadData,varAccess,w,x,y,n,p,par,dims
;;;;; This procedure just writes its parameters in their
;;;;; appropriate place.
   widget_control,set_uvalue=w,varAccess.datAccess.w
   widget_control,set_uvalue=x,varAccess.datAccess.x
   widget_control,set_uvalue=y,varAccess.datAccess.y
   widget_control,set_uvalue=n,varAccess.datAccess.n
   temp=size(p)
   if (temp(0) ne 1) or (temp(1) ne 31) then p=fltarr(31)
   widget_control,set_uvalue=p,varAccess.datAccess.p
   widget_control,set_uvalue=par,varAccess.datAccess.par
   dims=float(dims)
   temp={dimx:dims(0),dimy:dims(1),dim:max(dims)}
   widget_control,set_uvalue=temp,varAccess.datAccess.dims
end

pro int_loadWorkspace,varAccess,k,labelID
;;;;; Tests if the workspace Wk has good dimensions. If it is
;;;;; the case, the procedure `int_loadRequest' is called. If the
;;;;; workspace does not fit dimension requirement, an error
;;;;; message is displayed in the widget_label `labelID'.
   temp=BEN_WK_SIZE(k)
   if (temp(0) ne 2) then begin
      widget_control,set_value=("'W" + NUMtSTR(k,0) + "' is invalid."),labelID
      print,string(7b)
      return
   end
   widget_control,set_value=("Loading 'W" + NUMtSTR(k,0) + "'."),labelID
   BEN_READ_WK,k,data,datx,daty,datn,datp,datpar
   temp=int_loadRequest(varAccess,k,data,datx,daty,datn,datp,datpar)
   widget_control,set_value="Ready.",labelID
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; INITIALIZATION OF DATA AND PROGRAM VARIABLES
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

pro int_numor,varAccess
;;;;; The display of the numor is done only in the title bar,
;;;;; because there is no room left in the window !
;;;;; It is never used, because Px does not seem to contain
;;;;; the numor number.
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   if (datpar(0) le '') then res=cst.title $
   else res=(cst.title + '  (Numor #' +      datpar(0)    + ')')
;  else res=(cst.title + '  (Numor #' + NUMtSTR(datpar,0) + ')')
   widget_control,tlb_set_title=res,IDs.menu(0)
end

pro int_initData,varAccess,request
;;;;; Fill the data variables, according to `request'. If `request' is
;;;;; set to 1, the integration window was opened because of a
;;;;; request from the desk; the function must start with the
;;;;; requested data, stored in the common `ben_data'. So, if `request'
;;;;; is set to 1, those data are loaded; if it is set to 0, default
;;;;; data are loaded, by calling `int_defaultData'.
   widget_control,get_uvalue=cst,varAccess.constants
   common ben_data,wk,w,x,y,n,p,par
   if request then begin
      wkSize=size(w)
      if (wkSize(0) eq 2) $
      then int_loadData,varAccess,w,x,y,n,p,par,wkSize(1:2) $
      else int_defaultData,varAccess
   end else int_defaultData,varAccess
;;;;; The data is now stored. The startup settings can be declared.
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=set,varAccess.settings
   set.r1=dims.dim/6.0
   set.r2=dims.dim/2.0
   set.cx=(dims.dimx-1.0)/2.0
   set.cy=(dims.dimy-1.0)/2.0
   widget_control,set_uvalue=set,varAccess.settings
end

pro int_defaultData,varAccess
;;;;; This procedure is called to store the default data, when
;;;;; the integration function is not opened for a request.
   dimx=64.0
   dimy=64.0
   midx=(dimx-1.0)/2.0
   midy=(dimx-1.0)/2.0
   data=intarr(dimx,dimy)
   data(0:midx,0:midy)=0
   data(0:midx,midy+1:dimy-1)=1
   data(midx+1:dimx-1,midy+1:dimy-1)=2
   data(midx+1:dimx-1,0:midy)=3
   int_loadData,varAccess,data,indgen(dimx),indgen(dimy), $
      0,fltarr(31),0,[dimx,dimy]
end

function int_inits,test,x
;;;;; This function returns some default value for the parameter
;;;;; settings, or constants of the program.
@lamp.cbk
   if lamp_siz lt 800 then drS=384.0 else drS=448.0
   if lamp_siz lt 800 then miS=224.0 else miS=256.0
   initz=2.0
   case test of
      0:    res={minSize:miS,drawSize:drS,deg2rad:!pi/180, $
		 title:x}
      1:    res=120/max([1.0,(initz-1)])*indgen(initz)
      2:    res={logAspect:0,plotZone:0}
      3:    res={alpha:0.0,beta:30.0,gamma:180.0/initz,zones:initz, $
		 r1:0.0,r2:0.0,cx:0.0,cy:0.0,mx:0.0,my:0.0}
      else: res=0
   end
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; WIDGET CREATION PROCEDURE
;;; -+-+-+-+-+-+-+-+-+-+-+-+-

pro ben_int_create,desk,n,m,base,request
@lamp.cbk
;;;;; Creation of the top-level base, and the top `command bar'.
   if (m eq 0) then winTitle=desk_name(n,1) $
   else winTitle=(desk_name(n,1) + " " + NUMtSTR(1+m,0))
   base=widget_base(title=winTitle,/column,group_leader=desk, $
	resource_name='lampben')
   topRow=widget_base(base,/row)
   comID=BEN_COMMANDS(topRow,n,[0,0])

;;;;; Creation of the widgets containing all the `common'
;;;;; variables used by the program. The IDs of those widgets
;;;;; are stored into the top-level base user-value.
   varBase  =widget_base(title=(winTitle + " vars"),map=0,group=base)
   datAccess=widget_base(varBase,/row)
   data	 =widget_label(datAccess,value="")
   datx	 =widget_label(datAccess,value="")
   daty	 =widget_label(datAccess,value="")
   datn	 =widget_label(datAccess,value="")
   datp	 =widget_label(datAccess,value="")
   datppp=widget_label(datAccess,value="")
   dims	 =widget_label(datAccess,value="")
   dat={w:data,x:datx,y:daty,n:datn,p:datp,par:datppp,dims:dims}
   constants=int_inits(0,winTitle)
   options=int_inits(2)
   set	 =widget_label(varBase,value="",uvalue=int_inits(3))
   opt	 =widget_label(varBase,value="",uvalue=options)
   cst	 =widget_label(varBase,value="",uvalue=constants)
   IDs	 =widget_label(varBase,value="")
   col	 =widget_label(varBase,value="",uvalue=int_inits(1))
   pix	 =widget_label(varBase,value="")
   p0	 =widget_label(varBase,value="",uvalue=0)
   p1	 =widget_label(varBase,value="",uvalue=0)
   p2	 =widget_label(varBase,value="",uvalue=0)
   varAccess={datAccess:dat,settings:set,options:opt,constants:cst, $
      IDs:IDs,colors:col,pixmap:pix,plots:[p0,p1,p2]}
   widget_control,set_uvalue=varAccess,base
   int_initData,varAccess,request
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=temp,varAccess.datAccess.dims
   dim=temp.dim

;;;;; The main draw window, to plot the integration result.
;;;;; If the screen ysize is lower than 900 pixels, then the window
;;;;; is created horizontal; otherwise, it has a more vertical aspect.
   if (lamp_siz lt 1000) then begin
      temp=widget_base(base,/row)
      settings=widget_base(temp,/row,/frame)
      result=widget_draw(temp,retain=2, $
	 xsize=constants.drawSize*(constants.drawSize/503.37),ysize=constants.drawSize)
   end else begin
      result=widget_draw(base,  xsize=constants.drawSize*(constants.drawSize/503.37),  $
      				ysize=constants.drawSize,retain=2)
      settings=widget_base(base,/row,/frame)
   end

;;;;; Creation of the column of sliders for setting angles and rays.
   sliders=widget_base(settings,/column,xsize=constants.minSize/2.0)
	   put_logo   ,widget_base(sliders,/row)
   asl=widget_slider(sliders,value=set.alpha,title="Total rotation", $
      min=0,max=90,       uvalue=[-88,412,n,0],/drag)
   gsl=widget_slider(sliders,value=set.gamma,title="Single rotation", $
      min=0,max=90,       uvalue=[-88,412,n,2,set.gamma],/drag)
   bsl=widget_slider(sliders,value=set.beta,title="Opening", $
      min=0,max=45,       uvalue=[-88,412,n,1,0L],/drag)
   zoneID=widget_slider(sliders,value=set.zones,title="# of sectors", $
      min=1,max=8,        uvalue=[-88,407,n,gsl,bsl],/drag)
   widget_control,bsl,set_uvalue=[-88,412,n,1,zoneID]
   r1ID=widget_slider(sliders,value=set.r1,title="Inner radius", $
      min=0,max=1+round(sqrt(2)*dim),uvalue=[-88,406,n,0],/drag)
   r2ID=widget_slider(sliders,value=set.r2,title="Outer radius", $
      min=0,max=1+round(sqrt(2)*dim),uvalue=[-88,406,n,1],/drag)

;;;;; The right column contains the mini draw window, where
;;;;; zones are represented, and the fields for center and
;;;;; mask settings, plus the plots buttons.
   others=widget_base(settings,/column)
   plots=widget_base(others,/row)
   mini=widget_draw(widget_base(others),retain=2, $
        xsize=constants.minSize,ysize=constants.minSize)

;;; Toggle button to set the mini to logAspect or not
   logBtn=widget_button(widget_base(plots,/nonexclusive), $
			value="Log aspect",uvalue=[-88,408,n,0])

   update=widget_button(plots,value="I(R)",uvalue=[-88,411,n,comID(7),logBtn,1], $
          font=ft_b_normal)
   update=widget_button(plots,value="I(S)",uvalue=[-88,411,n,comID(7),logBtn,2], $
          font=ft_b_normal)
;;; Creation of the 'plot' menu.
   menuID=intarr(5,/nozero)
   menuID(0)=widget_button(plots      ,value="Plot",menu=2)
   temp     =widget_button(menuID(0)  ,value="Over last plot", $
      	     					uvalue=[-88,405,n,0,0,comID(7),logBtn,0])
   menuID(1)=widget_button(menuID(0)  ,value="Over plot #1", $
      	     					uvalue=[-88,405,n,0,1,comID(7),logBtn,0])
   menuID(2)=widget_button(menuID(0)  ,value="Over plot #2", $
      	     					uvalue=[-88,405,n,0,2,comID(7),logBtn,0])
   temp     =widget_button(menuID(0)  ,value="Into Mem 1",uvalue=[-88,405,n,1,1])
   temp     =widget_button(menuID(0)  ,value="Into Mem 2",uvalue=[-88,405,n,1,2])
   menuID(3)=widget_button(menuID(0)  ,value="Plot Mem 1",uvalue=[-88,405,n,2,1])
   menuID(4)=widget_button(menuID(0)  ,value="Plot Mem 2",uvalue=[-88,405,n,2,2])
;DID!!
   temp     =widget_button(menuID(0)  ,value=" ")
   temp     =widget_button(menuID(0)  ,value="To PS File...",uvalue=[-88,405,n,3,0,comID(7),0,0])
   temp     =widget_button(menuID(0)  ,value="To Wsp W20",uvalue=[-88,405,n,3,0,comID(7),1,0])

;;; Creation of the center and mask widget_texts.
   temp=widget_base(others,/row)
   temp_lab=widget_label(temp,value="Cx = ")
   cxID=widget_text(temp,value=NUMtSTR(set.cx+1.0,2),/editable, $
      /no_newline,uvalue=[-88,409,n],xsize=6,font=ft_b_bigger)
   temp_lab=widget_label(temp,value="Cy = ")
   cyID=widget_text(temp,value=NUMtSTR(set.cy+1.0,2),/editable, $
      /no_newline,uvalue=[-88,409,n],xsize=6,font=ft_b_bigger)
   temp=widget_base(others,/row)
   temp_lab=widget_label(temp,value="Mask X:")
   mxID=widget_text(temp,value=NUMtSTR(set.mx,2),uvalue=[-88,409,n], $
      /editable,/no_newline,xsize=5,font=ft_b_bigger)
   temp_lab=widget_label(temp,value=" Y:")
   myID=widget_text(temp,value=NUMtSTR(set.my,2),uvalue=[-88,409,n], $
      /editable,/no_newline,xsize=5,font=ft_b_bigger)
   plotBtn=widget_button(widget_base(others,/nonexclusive), $
      value="Separate Symetrical Sectors",uvalue=[-88,410,n])

;;;;; All the widgets have been declared. The two-state buttons
;;;;; are now set to their correct value, widget IDs are stored,
;;;;; some widgets are made non-sensitive (the plot menu), and
;;;;; the xmanager is called.
   bid=sys_dep      ('DYNLAB',base,1)
   widget_control,/realize,base & put_logo
   widget_control,set_button=options.plotZone,plotBtn
   widget_control,set_button=options.logAspect,logBtn
   widget_control,get_value=minID,mini
   widget_control,get_value=drawID,result
   uv={menu:menuID,cx:cxID,cy:cyID,mx:mxID,my:myID, $
      r1:r1ID,r2:r2ID,draw:drawID,mini:minID}
   widget_control,set_uvalue=uv,varAccess.IDs
   for i=1,4 do widget_control,sensitive=0,menuID(i)
   int_numor,varAccess
   int_miniPix,varAccess,0
   widget_control,set_value="<- You must load W",comID(7)
   xmanager,desk_name(n,0),base,event_handler="lamp_event_parser",/just_reg
end


;;; ***************************************************************************
;;; ***				 SPECTRA GROUPING			    ***
;;; ***************************************************************************

pro rgp_event,ev,uv
   widget_control,get_uvalue=varAccess,ev.top
   case uv(1) of
      400:  begin wait,.05 & widget_control,/destroy,ev.top & end
      401:  BEN_CHANGE_WORKSPACE,uv
      402:  rgp_help,varAccess,ev.top
      403:  rgp_loadWorkspace,varAccess,uv(3),uv(4)
      404:  rgp_writeWorkspace,varAccess,uv(3)
      405:  rgp_mask_event,varAccess,ev
      406:  rgp_toggleBtn,varAccess,ev.select,uv(3)
      407:  rgp_changeMax,varAccess,ev.value,ev.drag,uv(3),uv(4)
      408:  begin
      		rgp_writeMask,varAccess,uv(3)
      		widget_control,bad_id=i,ev.id,get_value=labut
      		labut=strlowcase(labut)
      		widget_control,bad_id=i,ev.id,set_value=labut
      	    end
      409:  begin
      		rgp_loadMask,varAccess,uv(3)
      		widget_control,bad_id=i,ev.id,get_value=labut
      		labut=strlowcase(labut)
      		widget_control,bad_id=i,ev.id,set_value=labut
      	    end
      410:  rgp_groupNum,varAccess,ev.value,1
      411:  rgp_writeWorkspace,varAccess,-1
      412:  rgp_toggleExport,varAccess,ev.select,uv(3),uv(4)
      else: print,"RGP_EVENT:",uv
   end
end

function rgp_testModule,x
;;;;; This function returns the value of 'singleRun' for the grouping
;;;;; function. Also it could be run several times, it is limited to
;;;;; only one value, because several ones should be confusing.
   return,1
end

pro rgp_help,varAccess,base
   print,"HELP WANTED"
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

function mask,x,apMask
@lamp.cbk
;;;;; This function is to be used as a macro; its syntax is:
;;;;;		  Wi=mask(Wj,m), or Wi=mas(j,m)
;;;;; where `m' is the number of a mask (from 1 to 4)
;;;;; The masks are stored into the 'rgp_lampmask' common.
   common rgp_lampmask,mask1,mask2,mask3,mask4
   temp=execute("destwk=w" + NUMtSTR(one,0))
   temp=size(x)
;;;;; If x is not a number, try the common variable `two'
;;;;; `two' contains a non-zero number when user calls `wi = mask(wj,m)'
   if ((temp(0) ne 0) or (temp(1) gt 4)) then wk=two $
   else wk=x
   if ((wk le 0) or (wk gt 20)) then return,destwk
   temp=BEN_WK_SIZE(wk)
   if (temp(0) ne 2) then return,destwk
   dimx=temp(1)
   dimy=temp(2)
   BEN_READ_WK,wk,work,datx,daty,datn,datp,datpar
   temp=execute("apMask=mask" + NUMtSTR(apMask,0))
   temp=size(apMask)
   if (temp(0) ne 1) then return,destwk
   maskSize=temp(1)
   if (dimy ne maskSize) then $
      if (dimy gt maskSize) then begin
	 expMask=intarr(dimy)
	 expMask(0:maskSize-1)=apMask
	 apMask=expMask
      end
   rgp_applyMask,work,daty,apMask,ind,res,resy
   if (ind lt 0) then return,destwk
   res=res(*,0:ind)
;  datp(30)=ind+1
   BEN_WRITE_WK,one,res,datx,resy(0:ind),datn,datp,datpar
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_loadMask,varAccess,x
;;;;; This porcedure is called by one of the 'load mask' button.
;;;;; It reads one of the four mask stored in the common, and
;;;;; uses it for the current mask. It calls the imask procedure
;;;;; that updates the display and the grouping. Then the infos
;;;;; about the spectra are updated too.
   common rgp_lampmask,mask1,mask2,mask3,mask4
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   newMask=''
   temp=execute("newMask=mask" + NUMtSTR(x,0))
   temp=size(newMask)
   if (temp(0) ne 1) then return
   last=-1
   cur=intarr(dims.x,dims.y)
   cur(*,*)=1
   for i=0,min([dims.y,temp(1)])-1 do cur(*,i)=newMask(i)
   widget_control,set_uvalue={cur:cur,last:-1},varAccess.mask
   rgp_imask,varAccess,[-1],0,0
   rgp_info,varAccess,1
end

pro rgp_writeMask,varAccess,x
;;;;; This procedure writes the current mask in the 'Mx' variable
;;;;; of the rgp_lampmask common.
   common rgp_lampmask,mask1,mask2,mask3,mask4
   widget_control,get_uvalue=mask,varAccess.mask
   temp=execute("mask" + NUMtSTR(x,0) +"=reform(mask.cur(0,*))")
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_numor,varAccess
;;;;; This procedure is called at startup, and when loading a new
;;;;; workspace, to display the numor in the window title and on
;;;;; a label.
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   widget_control,get_uvalue=IDs,varAccess.IDs
   if (datpar(0) eq '') then temp=' ' $
   else temp=datpar (0)

   widget_control,set_value=temp,IDs.numor
   if (temp eq ' ') then temp='' $
   else temp=('  (Numor:' + temp + ')')
   widget_control,tlb_set_title=(cst.title + temp),IDs.numor
end

pro rgp_loadData,varAccess,wkn,w,x,y,n,p,par,dims
;;;;; This procedure just writes its parameters in their
;;;;; appropriate place.
   widget_control,set_uvalue=w  ,varAccess.datAccess.w
   widget_control,set_uvalue=x  ,varAccess.datAccess.x
   widget_control,set_uvalue=y  ,varAccess.datAccess.y
   widget_control,set_uvalue=n  ,varAccess.datAccess.n
   temp=size(p)
   if (temp(0) ne 1) or (temp(1) ne 31) then p=fltarr(31)
   widget_control,set_uvalue=p,varAccess.datAccess.p
   widget_control,set_uvalue=par,varAccess.datAccess.par
   temp={x:dims(0),y:dims(1)}
   widget_control,set_uvalue=temp,varAccess.datAccess.dims
   varAccess.datAccess.wkn=wkn
end


function rgp_loadRequest,varAccess,wk,w,x,y,n,p,par
;;;;; This function is called by the desk, or by the 'loadWorkspace'
;;;;; procedure, to make its parameters the current data. First,
;;;;; the procedure checks the data is a 2-dimensional array, and
;;;;; then the other parameters are also checked, and replaced or
;;;;; modified if needed. All variables are updated if needed, and so
;;;;; is the display and the grouping.
;;;;; The value returned by this function is 1 if the data were
;;;;; correctly loaded, 0 if there was a problem, such as trying to
;;;;; load a 'bad sized' workspace.
   wksize=size(w)
   if (wksize(0) ne 2) then return,0
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   dims.x=wksize(1)
   dims.y=wksize(2)
   cur=intarr(dims.x,dims.y)
   cur(*,*)=1
   oldMax=max(data)
   temp=size(x)
   if ((temp(0) ne 1) or (temp(1) ne dims.x)) then x=indgen(dims.x)
   temp=size(y)
   if ((temp(0) ne 1) or (temp(1) ne dims.y)) then y=indgen(dims.y)
   temp=size(p)
   if ((temp(0) ne 1) or (temp(1) ne 31)) then begin
      p=fltarr(31)
      p(30)=dims.y
   end
;;;;; All the parameters have been checked. The data are stored,
;;;;; and some variables are modified.
   rgp_loadData,varAccess,wk,w,x,y,n,p,par,wkSize(1:2)
   temp=max(w)
   widget_control,get_uvalue=uv,IDs.maxSlider
   uv(3)=temp
   widget_control,set_uvalue=uv,IDs.maxSlider
   rgp_changeMax,varAccess,-1,1,temp,uv(4)
   widget_control,set_slider_max=max([2,dims.y/2]),IDs.gpSlider
   widget_control,sensitive=(dims.y ge 2),get_value=ng,IDs.gpSlider
   widget_control,set_uvalue={cur:cur,last:-1},varAccess.mask
;;;;; The numor, the infos, grouping and display are updated.
   rgp_numor,varAccess
   rgp_info,varAccess,0
   rgp_groupNum,varAccess,ng,0
   rgp_imask,varAccess,[-1],1,1
   return,1
end

pro rgp_loadWorkspace,varAccess,wk,labelID
;;;;; This procedure simply calls the loadRequest function, but it
;;;;; displays messages in its parent window if the loading failed.
   wksize=BEN_WK_SIZE(wk)
   if (wksize(0) ne 2) then begin
      widget_control,set_value=("'W" + NUMtSTR(wk,0) + "' is invalid."),labelID
      print,string(7b)
      return
   end
   widget_control,set_value=("Loading 'W" + NUMtSTR(wk,0) + "'."),labelID
   BEN_READ_WK,wk,w,x,y,n,p,par
   temp=rgp_loadRequest(varAccess,wk,w,x,y,n,p,par)
   widget_control,set_value=' ',labelID
end

pro rgp_writeWorkspace,varAccess,x
;;;;; This procedure first transforms the current data by applying
;;;;; the mask and grouping the spectra, and then output the result
;;;;; either to the LAMP workspace Wx if x is greater than 0, or to
;;;;; the 'Scroll Spectra' function.
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=datx,varAccess.datAccess.x
   widget_control,get_uvalue=daty,varAccess.datAccess.y
   widget_control,get_uvalue=datn,varAccess.datAccess.n
   widget_control,get_uvalue=datp,varAccess.datAccess.p
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=grp,varAccess.groups
   widget_control,get_uvalue=mask,varAccess.mask
   if opt.mApply then $
   ;;;;; If the user wants to apply the mask, ...
      if opt.doGroup then begin
      ;;;; ... and also group the spectra.
	 work=data*mask.cur
	 temp=size(grp.index)
	 ind=temp(1)-1
	 res=fltarr(dims.x,ind)
	 for i=0,ind-1 do begin
	    temp=where(mask.cur(0,grp.index(i):grp.index(i+1)-1) ne 0,count)
	    if (count eq 1) then res(*,i)=work(*,grp.index(i)) $
	    else if (count gt 0) then $
	       res(*,i)=total(work(*,grp.index(i):grp.index(i+1)-1),2)/count
	 end
	 resy=grp.sinAver
	 newp=datp
;	 newp(30)=ind-1
      end else begin
      ;;; ... but not do the grouping, applyMask is called.
	 rgp_applyMask,data,daty,reform(mask.cur(0,*)),ind,res,resy
	 newp=datp
;	 datp(30)=ind+1
      end $
   else begin
      res=data
      resy=daty
      newp=datp
   end
   if (x gt 0) then begin
   ;;;;; If the output is a workspace, the workspace and its linked
   ;;;;; variables are stored, and the history is updated.
;DID!!
   if n_elements(datpar) ge 2 then from='w'+ strtrim(datpar(1),2) $
   			      else from='w'+ NUMtSTR(varAccess.datAccess.wkn,0)
   too='w'+ NUMtSTR(x,0)
   xicute,too+'=groupp('+from+')'

   BEN_WRITE_WK,x,res,datx,resy,datn,newp,datpar
   TO_DON_HISTORY,x,0,too + '=mask(' + from + ')'

   end else begin
   ;;;;; The procedure request a 'df' (ie Scroll Spectra) from the
   ;;;;; desk. If the 'Scroll Spectra' procedures are present, a new
   ;;;;; window will be opened with the parameters if possible, or
   ;;;;; the data will be loaded by an already opened window.
      temp=desk_loadRequest('df',varAccess.datAccess.wkn,res,datx,resy, $
	 datn,newp,datpar)
      if (temp eq 0) then print,"Failed."
   end
end

function groupp, w_in
;******* ******
;DID!!
	w_out=bytarr(2,2)
return, w_out
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_mask_event,varAccess,ev
;;;;; This is the procedure called by the widget_draw when the mouse is
;;;;; used inside it. It calls the imask procedure to modify the
;;;;; current mask, and to update everything.
   if (ev.type ne 0) then return
   widget_control,get_uvalue=dim,varAccess.datAccess.dims
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=mask,varAccess.mask
   spec=min([dim.y*(cst.dimy-cst.borm(3)-ev.y)/ $
      (cst.dimy-cst.borm(1)-cst.borm(3)),dim.y-1])
   if (ev.x gt (cst.dimx-cst.borm(2))) then return
   if ((mask.last lt 0) or (ev.press eq 1)) $
   then rgp_imask,varAccess,[spec],0,0 $
   else rgp_imask,varAccess,[spec,mask.last],0,0
   widget_control,get_uvalue=mask,varAccess.mask
   mask.last=spec
   widget_control,set_uvalue=mask,varAccess.mask
   rgp_info,varAccess,1
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_info,varAccess,test
;;;;; Called to update the two info labels. The first one contains info
;;;;; about the masked spectra. The second label is updated only if
;;;;; `test' is set to one, and contains info about the total number
;;;;; of spectra in the current data.
   widget_control,get_uvalue=msk,varAccess.mask
   widget_control,get_uvalue=IDs,varAccess.IDs
   temp=where(msk.cur(0,*) eq 0,count)
   case count of
      0:    temp='None masked.'
      1:    temp='One  masked.'
      else: temp=(NUMtSTR(count,0) + ' masked.')
   end
   widget_control,set_value=temp,IDs.info(1)
   if test then return
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   temp=('Dim='+NUMtSTR(dims.y,0))
   widget_control,set_value=temp,IDs.info(0)
end

pro rgp_changeMax,varAccess,x,drag,dataMax,labelID
;;;;; This procedure is called by the 'maximum value' slider, when it's
;;;;; moved. A value is displayed in a label beside the slider, to
;;;;; simulate a non-linear slider. The display is updated only when
;;;;; the slider is released (`drag' is set to 0).
   widget_control,get_uvalue=set,varAccess.settings
   if (x lt 0)  then begin x=set.maxVal & y=dataMax
   endif	else	   y=dataMax*(float(x)/100.0)^2
   widget_control,set_value=NUMtSTR(y,0),labelID
   if drag then return
   set.maxVal=y
   widget_control,set_uvalue=set,varAccess.settings
   rgp_imask,varAccess,[-1],0,1
end

pro rgp_toggleBtn,varAccess,x,test
;;;;; This procedure handles the two toggle buttons. It modifies the
;;;;; correct variable/uservalue.
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.hideMask=x $
   else opt.logAspect=x
   widget_control,set_uvalue=opt,varAccess.options
   rgp_imask,varAccess,[-1],0,1
end

pro rgp_toggleExport,varAccess,x,test,btnID
;;;;; This procedure modifies the variables concerning the output.
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.mApply=x $
   else opt.doGroup=x
;DID!
;  if test then widget_control,sensitive=x,btnID
   widget_control,set_uvalue=opt,varAccess.options
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_imask,varAccess,n,eras,redrw
;;;;; This procedure modifies the mask: it masks/unmasks the spectra
;;;;; n(0) to n(1), depending if n(0) is already maked or not. It then
;;;;; replots the column showing the mask, updates the data display
;;;;; if the opt.hideMask is set to 1. The new grouping is also
;;;;; calculated, and the new groups displayed on the right.
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=mask,varAccess.mask
   if ((n(0) ge 0) and (n(0) lt dims.y)) then begin
      if mask.cur(0,n(0)) then temp=0 else temp=1
      for i=min(n),max(n) do mask.cur(*,i)=temp
   end
   widget_control,set_uvalue=mask,varAccess.mask
   rgp_groupNum,varAccess,-1,0
   wset,IDs.mask
   if eras then erase
   if ((opt.hideMask eq 0) or redrw) then begin
      if opt.hideMask then temp=(data<set.maxVal) $
      else temp=(data<set.maxVal)*mask.cur
      if opt.logAspect then temp=alog(1+temp)
      tempx=cst.dimx-cst.borm(0)-cst.borm(2)
      tempy=cst.dimy-cst.borm(1)-cst.borm(3)
      temp=congrid(temp,tempx,tempy)

      tvscl,temp,cst.borm(0),cst.borm(1),order=opt.tvOrder
   end $
   else tempy=cst.dimy-cst.borm(1)-cst.borm(3)
   sSel=cst.borm(0)/3
   temp=110-39*mask.cur(0,*)
   tv,congrid(temp,cst.borm(0)-sSel,tempy),sSel,cst.borm(1),order=opt.tvOrder
   if (n(0) ge 0) then temp(n(0))=-1 $
   else if (mask.last ge 0) then temp(mask.last)=-1
   tv,congrid(temp,sSel,tempy),0,cst.borm(1),order=opt.tvOrder
   rgp_drawGroups,varAccess
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_applyMask,win,yin,cur,ind,res,resy
;;;;; This procedure applies the mask `cur' to the `Win' spectra, and
;;;;; also modifies the angles contained in `Yin'. The results are
;;;;; returned into `res' and `resy'.
   wkSize=size(win)
   ind=-1
   res=fltarr(wkSize(1),wkSize(2),/nozero)
   resy=fltarr(wkSize(2),/nozero)
   for i=0,wkSize(2)-1 do $
      if cur(i) then begin
	 ind=ind+1
	 res(*,ind)=win(*,i)
	 resy(ind)=yin(i)
      end
   if (ind lt 0) then return
   res=res(*,0:ind)
   resy=resy(0:ind)
end

pro rgp_groupNum,varAccess,n,disp
;;;;; This procedure calculates the groupings.
;;;;; The range of unmasked angles is searched, and then the list of
;;;;; the sinus of the half-angles is divided into `n' parts, which
;;;;; are of the same width. If a part is empty, ie it does not include
;;;;; any spectrum, it is removed. In a part, the `average' angle is
;;;;; set to the mean value of its limits, and not to the mean of
;;;;; the angles corresponding to the spectra. The 'grouped' spectrum
;;;;; is the average of all the included spectra.
   widget_control,get_uvalue=set,varAccess.settings
   if (n lt 0) then n=set.ngroups $
   else if (set.ngroups eq n) then return $
   else set.ngroups=n
   widget_control,get_uvalue=mask,varAccess.mask
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=daty,varAccess.datAccess.y
   msk=reform(mask.cur(0,*))
   temp=where(msk ne 0,usedCount)
   if (usedCount le 0) then return
   widget_control,set_uvalue=set,varAccess.settings
   sinList=1000*sin(!pi*msk*daty/360.0)
   temp=where((daty eq 0) and (msk ne 0),count)
   if (count gt 0) then begin
      minSub=min(temp)
      infVal=0
   end else begin
      minSub=min(where(sinList gt 0))
      infVal=sinList(minSub)
   end
   aver=(max(sinList,maxSub)-infVal)/n
   index=intarr(n+1,/nozero)
   sinAver=(360.0/!pi)*asin(aver/1000*(findgen(n)+0.5))
   index(0)=minSub
   for i=1,n-1 do begin
      infVal=infVal + aver
      temp=where(sinList gt infVal,count)
      if (count ne 0) then index(i)=min(temp) $
      else index(i)=index(i-1)
   end
   index(n)=maxSub+1
   ind=0
   ;;;;; The empty parts are now removed.
   for i=1,n do $
      if (index(i) ne index(ind)) then begin
	 ind=ind+1
	 index(ind)=index(i)
	 sinAver(ind-1)=sinAver(i-1)
      end
   if (ind eq 0) then return
   index=index(0:ind)
   sinAver=sinAver(0:ind-1) + min(daty) ;DID!
   ;;;;; The info label is updated.
   if (ind eq 1) then res='One group.' $
   else res=(NUMtSTR(ind,0) + ' groups.')
   temp=n-ind
   if (temp ne 0) then begin
      if (temp eq 1) then temp='(-1)' $
      else temp=('(-'+NUMtSTR(temp,0) + ')')
      res=(res + temp)
   end
   widget_control,set_value=res,IDs.info(2)
   widget_control,set_uvalue={index:index,sinAver:sinAver},varAccess.groups
   ;;;;; The display is updated if `disp' is set to 1.
   if disp then rgp_drawGroups,varAccess
end

pro rgp_drawGroups,varAccess
;;;;; This procedure just draws the left-most ribbon in the display
;;;;; area, to represent the current groups.
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=grp,varAccess.groups
   widget_control,get_uvalue=msk,varAccess.mask
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   tempy=cst.dimy-cst.borm(1)-cst.borm(3)
   if (set.ngroups gt 0) then begin
      res=110+intarr(1,dims.y)
      temp=size(grp.index)
      for i=1,temp(1)-1 do begin
	 col=35+ 36*(-1)^i
	 for j=grp.index(i-1),grp.index(i)-1 do $
	    if msk.cur(0,j) then res(0,j)=col
      end
   end else begin
      res=intarr(cst.borm(2),cst.borm(2))
      for i=0,cst.borm(2)-1 do begin
	 res(i,i)=1
	 res(i,cst.borm(2)-i-1)=1
      end
   end
   wset,IDs.mask
   tv,congrid(res,cst.borm(2),tempy),cst.dimx-cst.borm(2), $
      cst.borm(1),order=opt.tvOrder
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_initData,varAccess,request
;;;;; Fill the data variables, according to `request'. If `request' is
;;;;; set to 1, the function window was opened because of a
;;;;; request from the desk; the function must start with the
;;;;; requested data, stored in the common `ben_data'. So, if `request'
;;;;; is set to 1, those data are loaded; if it is set to 0, default
;;;;; data are loaded, by calling `rgp_defaultData'.
   widget_control,get_uvalue=cst,varAccess.constants
   common ben_data,wk,w,x,y,n,p,par
   if request then begin
      wkSize=size(w)
      if (wkSize(0) eq 2) $
      then rgp_loadData,varAccess,wk,w,x,y,n,p,par,wkSize(1:2) $
      else rgp_defaultData,varAccess
   end else rgp_defaultData,varAccess
;;;;; The data is now stored. The startup settings can be declared.
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=data,varAccess.datAccess.w
   set={maxVal:100L,ngroups:max([2,dims.y/2])}
   mask={cur:(intarr(dims.x,dims.y)+1),last:-1}
   widget_control,set_uvalue=set,varAccess.settings
   widget_control,set_uvalue=mask,varAccess.mask
end

pro rgp_defaultData,varAccess
;;;;; This procedure is called to store the default data, when
;;;;; this function is not opened for a request.
   dimx=64
   dimy=64
   data=dist(dimx,dimy)
   rgp_loadData,varAccess,0,data,indgen(dimx),indgen(dimy), $
      0,fltarr(31),0,[dimx,dimy]
end

function rgp_inits,test,x
;;;;; This function is used for variable initialization.
@lamp.cbk
if lamp_siz lt  800 then xxx=384. else xxx=512.
if lamp_siz lt 1000 then yyy=320. else yyy=384.
if lamp_siz lt  800 then yyy=256. else yyy=384.
   case test of
      0:    res={dimx:xxx   ,dimy:yyy*3 ,borm:[24,0,24,0],title:x}
      1:    res={logAspect:1,hideMask:0,tvOrder:1,mApply:1,doGroup:0}
      else: res=0
   end
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro ben_rgp_create,desk,n,m,base,request
@lamp.cbk
;;;;; This the procedure called by the LAMP Desktop to create a new
;;;;; window. `n' is the item 2 of the widgets user value. Is is used
;;;;; by P_BEN_EVENT to select which function the incoming events must
;;;;; be sent too. `m' is used only for the title. `base' is an output
;;;;; variable, used to return the new window ID number. If the window
;;;;; is created to respond to another function request, then `request'
;;;;; is set to 1, so the function will inits its data using the
;;;;; variables stored in the 'ben_data' common.
   if (m eq 0) then winTitle=desk_name(n,1) $
   else winTitle=(desk_name(n,1) + ' ' + NUMtSTR(1+m,0))
   base=widget_base(title=winTitle,/column,group_leader=desk, $
		    resource_name="lampben")
   topRow=widget_base(base,/row)
   comID=BEN_COMMANDS(topRow,n,[0,0])
   widget_control,set_value="<-- You must load W",comID(7)
;;;;; Creation of the widget_label containing all the variables.
   datAccess=widget_base(topRow,/row)
   data	 =widget_label(datAccess,value="")
   datx	 =widget_label(datAccess,value="")
   daty	 =widget_label(datAccess,value="")
   datn	 =widget_label(datAccess,value="")
   datp	 =widget_label(datAccess,value="")
   datppp=widget_label(datAccess,value="")
   dims	 =widget_label(datAccess,value="")
   dat={w:data,x:datx,y:daty,n:datn,p:datp,par:datppp,dims:dims,wkn:0}
   constants=rgp_inits(0,winTitle)
   options=rgp_inits(1)
   set	 =widget_label(topRow,value="")
   opt	 =widget_label(topRow,value="",uvalue=options)
   cst	 =widget_label(topRow,value="",uvalue=constants)
   IDs	 =widget_label(topRow,value="")
   mask	 =widget_label(topRow,value="")
   grp	 =widget_label(topRow,value="")
   varAccess={datAccess:dat,settings:set,options:opt,constants:cst, $
      IDs:IDs,mask:mask,groups:grp}
   widget_control,set_uvalue=varAccess,base
;;;;; Initialization of the data, by calling 'initData'
   rgp_initData,varAccess,request
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=dims,varAccess.datAccess.dims

;;;;; Creation of the output (to a workspace or the 'Scroll Spectra'
;;;;; function) widgets, and the masks input/output.
   temp=widget_base(base,/row)
   left=widget_base(temp,/column,space=8)
   right=widget_base(widget_base(temp,/column),/row)
   output=widget_base(left,/column,/frame)

   temp=widget_base    (base,/row)
   numorID=widget_label(temp,value='__________'		,font=ft_b_bigger)
   info   =intarr(3,/nozero)
   info(0)=widget_label(temp,value='_________'		,font=ft_propor)
   info(1)=widget_label(temp,value='_______________'	,font=ft_propor)
   info(2)=widget_label(temp,value='_______________'	,font=ft_propor)

;DID!
;  xopt=widget_base (output,/nonexclusive,/row,space=32)
;  applyBtn=widget_button(xopt,value="Apply mask")
   ropt=widget_base (output,/row)
   bido=widget_label(ropt  ,value='OUTPUT',font=ft_b_normal)
   xopt=widget_base (ropt  ,/nonexclusive)
   groupBtn=widget_button(xopt,value="Group spectra",uvalue=[-88,412,n,0,0])
;  widget_control,set_uvalue=[-88,412,n,1,groupBtn],applyBtn

   out=widget_base(output,/row)
   temp=widget_label(temp,value='')
   out=widget_base(out,/column)
   output=BEN_SELECTWID(widget_base(out,/row),n,1,0,0,0)
   useDF=widget_button(out,uvalue=[-88,411,n], $
      value=("Export to '" + desk_name(desk_winNum('df'),1) + "'"))
;   numor=widget_label(left,value=' ')
   right1=widget_base(right,/column)
   temp=widget_label(right1,value='Load mask')
   for i=1,3 do $
      temp=widget_button(right1,value=("M" + NUMtSTR(i,0)), $
      uvalue=[-88,409,n,i])
   right2=widget_base(right,/column)
   temp=widget_label(right2,value='Save mask in')
   for i=1,3 do $
      temp=widget_button(right2,value=("M" + NUMtSTR(i,0)), $
      uvalue=[-88,408,n,i])

;;;;; Creation of the spectra display, and the options widgets.
   visual=widget_base(base,/column,/frame)
;DID!
   imask=widget_draw(widget_base(visual),/button_events,retain=2  , $
      xsize=constants.dimx,ysize=constants.dimy,uvalue=[-88,405,n], $
      x_scroll_size=constants.dimx,y_scroll_size=constants.dimy/3)
   opts=widget_base(visual,/row)
	put_logo   ,opts
   togs=widget_base(opts,/row,/nonexclusive)
   hidMask=widget_button(togs,value="Hide mask",uvalue=[-88,406,n,1])
   logBtn=widget_button(togs,value="Log aspect",uvalue=[-88,406,n,0])
   maxDat=max(data)
   maxSlider=widget_slider(opts,title="Maximum value",/suppress_value, $
      /drag,value=set.maxVal)
   slidLab=widget_label(opts,value=NUMtSTR(maxDat,0))
   widget_control,set_uvalue=[-88,407,n,maxDat,slidLab],maxSlider

;;;;; Creation of a slider widget to select the desired number of
;;;;; groups; below this slider, three info widget_label are created.
   gpSlider=widget_slider(base,value=set.ngroups,uvalue=[-88,410,n], $
      min=1,max=set.ngroups,title="Number of groups",/drag)

;;;;; All the widgets are declared. They are now realized, and the
;;;;; widgets IDs are stored. The toggle buttons states are set to
;;;;; their default value, according to the "rgp_inits' function
;;;;; result. The data is displayed, and the groups calculated.
   bid=sys_dep      ('DYNLAB',base,1)
   widget_control,/realize,base & put_logo
   widget_control,get_value=maskID,imask
   if options.logAspect then widget_control,/set_button,logBtn
   if options.hideMask then widget_control,/set_button,hidMask
   if options.doGroup then widget_control,/set_button,groupBtn
;DID!
;  if options.mApply then widget_control,/set_button,applyBtn $
;  else widget_control,sensitive=0,groupBtn
   widget_control,set_uvalue={mask:maskID,maxSlider:maxSlider, $
      gpSlider:gpSlider,numor:numorID,info:info},varAccess.IDs
   rgp_numor,varAccess
   rgp_info,varAccess,0
   rgp_changeMax,varAccess,-1,1,maxDat,slidLab
   rgp_groupNum,varAccess,set.ngroups,0
   rgp_imask,varAccess,[-1],1,1
   xmanager,desk_name(n,0),base,event_handler="lamp_event_parser",/just_reg
end

pro bens
;** ****
return
end

pro live_lamp_dens, liveT, xx,yy,zz,w, thresh=thresh, box=cdbox, ax=rx,az=rz, xrange=bx, yrange=by, zrange=bz
;** **************
;**
if thresh ne -99 then begin & endif ;thresh already done !!!

if liveT ne 3 then $
PLOT_3DBOX, xx,yy,zz,psym=2, ax=rx,az=rz, xrange=bx, yrange=by, zrange=bz, $
		/solid_walls,color=80,background=255, gridstyle=0 $
else $
PLOT_3DBOX, xx,yy,zz,psym=2, ax=rx,az=rz, xrange=bx, yrange=by, zrange=bz, $
		/solid_walls,color=80,background=255, gridstyle=0, $
		/xy_plane, /xz_plane, /yz_plane
end

pro live_lamp_plot, liveT, xx,ww, xrange=bx, yrange=by
;** **************
;**
Vs=!version.release
X=xx
W=ww
if n_elements(bx) ne 2 then begin mini=min(x ,max=maxi) & bx=[mini,maxi]
endif			else begin id=where((x ge bx(0)) and (x le bx(1))) & X=X(id) & w=w(id,*) & endelse
if n_elements(by) ne 2 then begin mini=min(w ,max=maxi) & by=[mini,maxi] & endif

z=size(w) & if z(0) eq 2 then k=(z(2)-1)<24 else k=0
if k eq 0 then begin
   if Vs lt 6.0 then $
        res=execute('LIVE_PLOT, W  , independent=X, xrange=bx, yrange=by, /indexed_color, error=bidon') $
   else res=execute('IPLOT  ,X, W  , xrange=bx, yrange=by')

endif else begin s=''
   if Vs lt 6.0 then begin
     for i=0,k do s=s+',w(*,'+string(i)+')'
     res=execute('LIVE_PLOT'+s+', independent=X, xrange=bx, yrange=by, /indexed_color, error=bidon')
   endif else begin
     for i=0,k do begin s='w(*,'+string(i)+')'
       if i eq 0 then res=execute('IPLOT  ,X, '+s+' , xrange=bx, yrange=by') $
                 else res=execute('IPLOT  ,X, '+s+' , xrange=bx, yrange=by,/overplot')
     endfor
   endelse
endelse
end

pro live_lamp_img, liveT, w, xrange=bx, yrange=by
;** *************
;**
Vs=!version.release
if Vs lt 6.0 then res=execute('LIVE_IMAGE, w') $
             else res=execute('IIMAGE    , w')
end

pro live_lamp_surf, liveT, xx,yy,w, ax=rx,az=rz ,rrr=rrr, style=styles
;** **************
;** rrr=1 image+surface		rrr=2 image  +contour
;** rrr=3 image+surface+contour	rrr=4 surface+contour
;** rrr=5 contour			rrr=6 surface
;** rrr=7 vrml

Vs=!version.release
if (size(x))(0) gt 1 then x=xx(*,0)		else x=xx
if (size(y))(0) gt 1 then y=reform(yy(0,*))	else y=yy

if (rrr eq 2) or (rrr eq 3) or (rrr eq 5) then begin
  if Vs lt 6.0 then res=execute('LIVE_CONTOUR, w, Xindependent=X, Yindependent=Y, /indexed_color, error=bidon') $
               else res=execute('ICONTOUR ,X,Y,w  ')
endif else begin
  if Vs lt 6.0 then res=execute('LIVE_SURFACE, w, Xindependent=X, Yindependent=Y, /indexed_color, error=bidon') $
               else res=execute('ISURFACE ,X,Y,w  ')
endelse
end

pro live_lamp_cont, w,GROUP=group, TIT=tit, XTIT=xtit, YTIT=ytit, XX=xx, YY=yy ,WI=idn
;** **************
;**
    ii=execute("livc_lamp, w,GROUP=group, TIT=tit, XTIT=xtit, YTIT=ytit, XX=xx, YY=yy ,WI=idn")
end

pro live_lamp_vol , liveT, w, ax=rx,az=rz ,rrr=rrr, thresh=thresh, name=str
;** **************
;**
Vs=!version.release
pointr=ptr_new(w)
if Vs lt 6.0 then ii=execute("slicer3, pointr,data_names=str") $
             else ii=execute('IVOLUME ,w  ')
end

pro live_lamp_Anim, w, TITLE=tit, GROUP=group, smoo=smoo, surf=did_repr, az=rz,ax=rx ,regul=regul
;** **************
;**
surfc=0 & regul=0
if n_elements(smoo)     ne 1  then smoo=0
if n_elements(did_repr) gt 6  then begin surfc=did_repr(2) & regul=did_repr(6)
	;Care trap_current if surface mode !!!!!
endif
siz =size(w)  & sx=siz(1) & sy=siz(2) & nf=siz(3)
mini=min(w, max=maxi)
				winx=320	   &   winy=320
				xi= winx/siz(1)    &   yi=winy/siz(2)
				if (xi eq 0) then xi= -(float(siz(1))/winx)
				if (yi eq 0) then yi= -(float(siz(2))/winy)
				if  xi le -1 then fx= -1./xi else fx=xi
				if  yi le -1 then fy= -1./yi else fy=yi

				fm=min([fx,fy])    & fx=fm & fy=fm

				xi= fix(siz(1)*fx) & yi= fix(siz(2)*fy)

				if xi/yi gt 4 then yi=xi/4 else if yi/xi gt 4 then xi=yi/4

				if winx lt xi then xi=winx   &  if winy lt yi then yi=winy

				ff=fix((float(xi)/sx)*(float(yi)/sy)/2)*smoo

;loadct,4,/silent

Xinteranimate,set=[xi,yi,nf], /cycle, mpeg_file="lamp.mpg", $
              /showload, /track, title=tit

ff=fix((float(xi)/sx)*(float(yi)/sy)/2)*smoo

for i=0,nf-1 do $
if (xi eq sx) and (yi eq sy) then $
     Xinteranimate, frame=i, image=bytscl(w(*,*,i), max=maxi, min=mini) $
else begin
     if ff lt 3 then $
     Xinteranimate, frame=i, image=bytscl(congrid(w(*,*,i),xi,yi), max=maxi, min=mini) else $
     Xinteranimate, frame=i, image=bytscl(smooth(congrid(w(*,*,i),xi,yi),ff<6), max=maxi, min=mini)
endelse

Xinteranimate, GROUP=group
end

pro liv_lamp
;** *********
end

pro P_DID_SETVAR
;** ************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    common c_drow,	did_wc,did_we,did_win1,did_4dM,did_etc

    if n_elements(lamp_wrd) ne 1 then lamp_wrd=''
    did_repr=lonarr(20)  & did_repr(*)= 0
    did_inib=lonarr(3)   & did_inib(*)= 0
    did_surf=lonarr(2)	 & did_surf(*)= 0
    styles  =intarr(4,2)
    vfl     =lonarr(4)	 & vfl(*)     =-1
    vff     =fltarr(3)
    did_scan=0
    did_tio =0
    did_fu  =0
    flgsurf =0
    wbeside =0
    rx=60 & rz=20 & nlv=24 & smoo=1
    if (sys_dep('STUDENT') or sys_dep('RUNTIME')) then tcol=3 else tcol=1
    if (sys_dep('MACHINE') eq 'win')   then  tcol=3
    tcol=27
   !p.font  =0

    if sys_dep('VERSION') ge 5.0 then LIV_LAMP

    if n_elements(did_wd) eq 0 then begin did_wd=0 & did_we=0 & did_win0=0 & endif

    if b_labins(3) ne 0 then begin did_repr(2)=1 & did_x=512 & did_y=320 & vff(2)=1
	 if  b_labins(3) eq 2  then begin
	  styles(0,0)=3  & styles(1,0)= 1        & did_x=350 & did_y=230
	  if (did_wd eq 0) and (!D.name ne 'Z')  then begin
	    did_wb  =widget_base  (map=0)
	    did_wd  =widget_draw  (did_wb ,retain=2,xsize=did_x,ysize=did_y,colors=-30)
	    widget_control,bad_id=ii  ,did_wb ,/realize
	  endif
	 endif
	 P_AFTER_REALIZE_DID ,0,0,0
	 if  b_labins(3) eq 1 then begin styles(0,0)= 6 & styles(1,0)= 2 & endif
    endif     else begin did_repr(0)=1 & styles(0,0)= 3 & styles(1,0)= 0 & vff(2)=0  & endelse

    vff=[vff,did_repr(2),rz,did_fu,0,0,0,0,0,0,0,rx]
return
end

pro P_DID_CREATE ,base ,ready
;** ************
;**
;** Workspace display unit.
;**
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    common c_drow
    common c_plog,  win,sicon,pixlog

    P_DID_SETVAR

    if n_elements(ready) le 0 then begin
	bs0   =widget_base   (base   ,/column)
	bs1   =widget_base   (bs0   ,/row)
    endif else bs1 = ready(0)

	if (lamp_siz ge 800) and (GEORGE ne 1) then text=' DISPLAY WORKSPACE' else text=' DISPLAY'
	if sys_dep('MACHINE') eq 'win' then cap=1 else cap=0

	bs1_1  =widget_label (bs1   ,font=ft_biggest,value=    text)
	bhelp  =widget_button(bs1   ,font=ft_normal ,value='?',$
				     uvalue=[-88,587,0,0,0,0,0,0,0])

	bs1_2  =widget_label (bs1   ,font=ft_biggest ,value='  ')

	bs1b1  =widget_button(bs1   ,font=ft_smaller ,value='<-')
	did_wsc=widget_button(bs1   ,font=ft_propor  ,value='Plot W 1',$
				     uvalue=[-88,301,0,0,0,0,0,0,0])
	bs1b2  =widget_button(bs1   ,font=ft_smaller,value='->')
	widget_control,bad_id=i,bs1b1,set_uvalue=[-88,310,did_wsc,1,0,0,0,0,0]
	widget_control,bad_id=i,bs1b2,set_uvalue=[-88,311,did_wsc,1,0,0,0,0,0]

	bs1_3  =widget_label (bs1   ,font=ft_biggest,value=' ')

	if (GEORGE ne 1) then begin
	bs1_3  =widget_base  (bs1   ,/exclusive,/row)
	bs1_3e =widget_button(bs1_3 ,font=ft_b_normal,value='Below' ,/no_release,$
				     uvalue=[-88,302,0,0,0,0,0,0,0])
	did_inib(0)=bs1_3e
	bs1_3e =widget_button(bs1_3 ,font=ft_b_normal,value='Beside',/no_release,$
				     uvalue=[-88,303,0,0,0,0,0,0,0])
;jock	bs1_3  =widget_base  (bs1   ,/nonexclusive)
;jock	bs1_3e =widget_button(bs1_3 ,font=ft_normal  ,value='Be good',$
;jock				     uvalue=[-88,360,0,0,0,0,0,0,0])
	if sys_dep('MAP') ne -1 then $
	bs1_3  =widget_button(bs1   ,font=ft_normal,value='Options...',/menu,$
				     resource_name='discret') else $
	bs1_3  =widget_button(bs1   ,font=ft_normal,value='Options...',/menu)
	bs1_3t =widget_button(bs1_3 ,font=ft_normal,value='Titles...' ,uvalue=[-88,360,0,0,0,0,0,0])
	did_4dM=widget_button(bs1_3 ,font=ft_normal,value='4D object' ,/menu)
	did_4vM=widget_button(did_4dM,font=ft_normal,value='Vrml File',uvalue='Vrml')
	widget_control,did_4dM,sensitive=0
	if sys_dep('VERSION') ge 5.0 then $
	   bid =widget_button(bs1_3 ,font=ft_normal,value='Need Coffee!' ,uvalue=[-88,304,5,0])

	if lamp_siz ge 800 then text='Be print' else text='Print'
	if sys_dep('MAP') ne -1 then $
	bs1b   =widget_button(bs1   ,font=ft_normal,value=text,uvalue=[-88,350,0,0,0,0,0,0,0],$
				     resource_name='discret') else $
	bs1b   =widget_button(bs1   ,font=ft_normal,value=text,uvalue=[-88,350,0,0,0,0,0,0,0])

	endif
	if GEORGE ne 0 then GEORGEO, TIMER=bs1, freq=duduch1 ,lim=duduch2
	if GEORGE eq 1 then did_fu=1

;*******
	if n_elements(ready) le 0 then bsrow  =widget_base  (bs0   ,/row) $
				  else bsrow  =ready(1)
;*******
	if n_elements(ready) le 0 then bsopt  =widget_base  (bsrow ,/column) $
				  else bsopt  =ready(2)

	if abs(sys_dep('MAP')) eq 1 then option=1 else option=1
	bsoptff=bsopt
	if option then $
	bsoptf =widget_base  (bsoptff,/column,/frame) else bsoptf=bsoptff

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bsimage=widget_button(bsopt1 ,font=ft_b_normal ,value='Image  ',$
				      uvalue=[-88,320,0,0,0,0,0,0,0])
	did_inib(1)=bsimage
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bslevel=widget_button(bsopt1 ,font=ft_b_normal ,value='Contour',$
				      uvalue=[-88,321,0,0,0,0,0,0,0])

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bsurfac=widget_button(bsopt1 ,font=ft_b_normal ,value='Surface',$
				      uvalue=[-88,322,0,0,0,0,0,0,0])
	if sys_dep('MAP') ne -1 then $
	bsura1 =widget_button(bsopt0 ,font=ft_smaller  ,value='<',resource_name='discret') else $
	bsura1 =widget_button(bsopt0 ,font=ft_smaller  ,value='<')
	bsuraz =widget_text  (bsopt0 ,font=ft_b_normal ,value='+20',xsize=4+cap,ysize=1,/editable)
	if sys_dep('MAP') ne -1 then $
	bsura2 =widget_button(bsopt0 ,font=ft_smaller  ,value='>',resource_name='discret') else $
	bsura2 =widget_button(bsopt0 ,font=ft_smaller  ,value='>')
	did_repr(4) =bsuraz
	widget_control,bad_id=i,bsura1,set_uvalue=[-88,326,bsuraz,0,0,0,0,0,0]
	widget_control,bad_id=i,bsura2,set_uvalue=[-88,327,bsuraz,0,0,0,0,0,0]
;------
	bsopt0 =widget_base  (bsoptf  ,/row)
	bsopt1 =widget_base  (bsopt0  ,/nonexclusive)
	bsxy   =widget_button(bsopt1  ,font=ft_b_normal ,value='Range etc...')

	widget_control,bad_id=i  ,bsxy,set_uvalue=[-88,319 , bsxy,bsoptf,bsopt0]

	if (option) then begin
	  bsoptf =widget_base  (bsoptff,map=0,/column,/frame)
	  P_DID_CREATE_MORE , bsxy,bsoptf,bsopt0
	  widget_control,bad_id=i,bsxy,set_uvalue=[-88,319 , bsxy,bsoptf,0]
	endif
;*******allow restarting lamp after /reset.
	if n_elements(did_lamp) gt 1 then begin
	  iii=execute('wset,did_pix>1')
	  if iii ne 1 then begin
	   did_lamp=0
	   did_pio =0
	   did_buf =0
	   sicon   =0
	   Snapix  =0
	   did_zoom_reset
	   p_did_save_reset
	  endif
	endif
;*******
	did_x  =512
	if (sys_dep('MACHINE') eq 'win') then did_y=256 else did_y=288
	if lamp_siz gt  950 then did_y  =320
	if lamp_siz lt  800 then did_x  =300
	if lamp_siz lt  800 then did_y  =230
	if n_elements(ready) le 0 then begin
	   junky   =widget_base  (bsrow)
	   did_wb  =widget_base  (junky,map=1)
	   did_wc  =widget_base  (junky,map=0)
	   did_wd  =widget_draw  (did_wb ,retain=2,xsize=did_x,ysize=did_y,colors=-30,$
					 /button_events,/motion_events)
	   did_we  =0L
	   etxt="did_we  =widget_draw  (did_wc , GRAPHICS_LEVEL=2,UVALUE='DRAW', RETAIN=0,"+ $
	                               "XSIZE=did_x, YSIZE=did_y,/BUTTON_EVENTS,/EXPOSE_EVENTS)"
	   if sys_dep('VERSION') ge 5.0 then ii=EXECUTE(etxt)

	   if GEORGE ne 1 then widget_control,did_wd,draw_motion_events=1
	endif else $
	   did_wd  =ready(3)
	did_curw=10
return
end

pro P_DID_CREATE_MORE, bsxy,bsoptf,bsopt0
;** *****************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

	tmpbase=0    & P_messi , tmpbase,(lamp_b1+0)

	if GEORGE eq 1 then $
	bid = widget_button(widget_base(bsopt0  ,/nonexclusive) $
						,font=ft_normal   ,value='Be good' $
						,uvalue=[-88,360,0,0,0,0,0,0,0])   $
	else begin
	  bsbs   =widget_base  (bsopt0,/nonexclusive)
	  if sys_dep('MAP') ne -1 then $
	  bid    =widget_button(bsbs  ,font=ft_smallest,value='bg',uvalue=[-88,344,0],resource_name='discret') else $
	  bid    =widget_button(bsbs  ,font=ft_smallest,value='bg',uvalue=[-88,344,0])
	endelse
;------
	if sys_dep      ('MACHINE') eq 'win' then cap=1 else cap=0

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bstretc=widget_button(bsopt1 ,font=ft_normal ,value='X range',$
				      uvalue=[-88,325,0,0,0,0,0,0,0])
	bsminx =widget_text  (bsopt0 ,font=ft_propor ,value=' Min'  ,xsize=4+cap,ysize=1,$
				     /all_events,/editable)
	bsmaxx =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsminx,set_uvalue=[-88,330,bstretc,7,1,0,0,0,0]
	widget_control,bad_id=i,bsmaxx,set_uvalue=[-88,330,bstretc,7,1,0,0,0,0]

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bstretc=widget_button(bsopt1 ,font=ft_normal ,value='Y range',$
				      uvalue=[-88,329,0,0,0,0,0,0,0])
	bsminy =widget_text  (bsopt0 ,font=ft_propor ,value=' Min'  ,xsize=4+cap,ysize=1,$
				     /all_events,/editable)
	bsmaxy =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsminy,set_uvalue=[-88,330,bstretc,8,1,0,0,0,0]
	widget_control,bad_id=i,bsmaxy,set_uvalue=[-88,330,bstretc,8,1,0,0,0,0]

	bsmins=0
	bsmaxs=0
	if lamp_siz ge 800 then begin
	bsopt0 =widget_base  (bsoptf ,/row,map=0)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bstretc=widget_button(bsopt1 ,font=ft_normal ,value='S range',$
				      uvalue=[-88,318,0,0,0,0,0,0,0])
	bsmins =widget_text  (bsopt0 ,font=ft_propor ,value=' Min'  ,xsize=4+cap,ysize=1,$
				     /all_events,/editable)
	bsmaxs =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsmins,set_uvalue=[-88,330,bstretc,17,1,0,0,0,0]
	widget_control,bad_id=i,bsmaxs,set_uvalue=[-88,330,bstretc,17,1,0,0,0,0]
	did_inib(2)=bsopt0
	endif

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive,/row)
	bslog  =widget_button(bsopt1 ,font=ft_normal ,value='W log',$
				      uvalue=[-88,323,0,0,0,0,0,0,0])
	bsmaxb =widget_button(bsopt1 ,font=ft_normal ,value='W lim')
	bsmaxv =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsmaxb,set_uvalue=[-88,328,bsmaxv,0,0,0,0,0,0]
	widget_control,bad_id=i,bsmaxv,set_uvalue=[-88,330,bsmaxb,9,bsmaxv,0,0,0,0]
	P_messi , tmpbase,(lamp_b1+0)
	did_repr(10)=bsminx
	did_repr(11)=bsmaxx
	did_repr(12)=bsminy
	did_repr(13)=bsmaxy
	did_repr(15)=bsmins
	did_repr(16)=bsmaxs
return
end

function tvrdd,a,b,c,d
;******* *****
;**
	if (!D.Name eq 'WIN') or (!version.os eq 'darwin') then begin
		if n_elements(d) eq 1 then w=tvrd(a,b,c,d,/true) else w=tvrd(/true)
		w=color_Quan(w,1,a,b,c)
	endif else begin
		if n_elements(d) eq 1 then w=tvrd(a,b,c,d) else w=tvrd() & a=0
	endelse
return, w
end

;*************************************** Restore         *********************************
;*************************************** Restore         *********************************
;*************************************** Restore         *********************************
function P_ICK_LIST, pk_pthv, pk_flt,cnt
;******* **********
;**
	pk_list=''
	stat=0 & cnt=0
	catch,stat
	if stat eq 0 then begin
		cd,pk_pthv,current=mee
		pk_list=findfile(pk_flt,count=cnt)
		if strpos(pk_flt,'.hdf' ) ge 0 then begin
		   pk_more=findfile('*.nxs',count=cn2)
		   if cn2 gt 0 then pk_list=[pk_list,pk_more] & cnt=cnt+cn2
		   if cnt gt 0 then begin idx=where(strpos(pk_list,'.hdfimg') eq -1)
		                          if idx(0) ge 0 then begin pk_list=pk_list(idx) & cnt=n_elements(idx) & endif
		                          idx=where(strpos(pk_list,'.nxsimg') eq -1)
		                          if idx(0) ge 0 then begin pk_list=pk_list(idx) & cnt=n_elements(idx) & endif
		   endif
		endif
		if strpos(pk_flt,'_LAMP') ge 0 then begin
		   pk_more=findfile(pk_flt+'.hdf',count=cn2)
		   if cn2 gt 0 then pk_list=[pk_list,pk_more] & cnt=cnt+cn2
		   pk_more=findfile('*.xml',count=cn2)
		   if cn2 gt 0 then pk_list=[pk_list,pk_more] & cnt=cnt+cn2

		   pk_more=findfile('*.htm',count=cn2)
		   if cn2 gt 0 then $
		   for i=0L,cn2-1 do begin tmp=pk_more(i)
				j=    strpos(tmp,'.htm') & tmp=strmid(tmp,0,j)+'.zip'
				re=   findfile(tmp,count=cn3)
				if cn3 eq 0 then begin
				   tmp=strmid(tmp,0,j)+'.xdr'
				   re=findfile(tmp,count=cn3) & endif
				if cn3 gt 0 then begin
				   pk_list=[pk_list,pk_more(i)] & cnt=cnt+1 & endif
		   endfor
		endif
		cd,mee
	endif else begin
		catch,/cancel
		P_MUS,'mus_cannon'
	endelse
	if cnt gt 0 then begin
			 ln=strpos(strupcase(pk_list(0)),strupcase(pk_pthv))
			 if ln ge 0 then ln=ln+strlen(pk_pthv)
			 for i=long(0),cnt-1 do pk_list(i)=strmid(pk_list(i),ln,35)
	endif  else pk_list='No file '+pk_flt
return,pk_list
end

pro P_ICK_INIT,frm
;**
@lamp.cbk
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    i=xregistered('PICKDATA')
    if i le 0 then begin

	P_MUS,'mus_harp'
    	if n_elements(pk_sli) le 0 then pk_sli=1
    	if n_elements(pk_frm) le 0 then pk_frm=1
    	if pk_frm eq 0 then pk_frm =1
	pe='' & ii=sys_dep('POT',pe)
    	pk_hyst=''

    	pk_bxt =[ 'Lamp' , 'XY (Z)' , 'gel tif'  , 'Mar'   , 'Scan' , 'NeXus' , 'Other']
    	pk_ext =['_LAMP' , '*.*'    ,'.gel'      ,'.image' ,'.WIND' , '.hdf'  ,  pe+'*']

	IF (GEORGE ne 0) or (sys_dep('VERSION') lt 4.0) then begin j=5 & if GEORGE ne 0 then j=3
							     if n_elements(b_labins) ge 6 then $
							        if b_labins(5) eq 1 then pk_frm=j+1
							     pk_bxt(j)='Dial'  & pk_ext(j)='dial_*.pro*' & endif
    	pk_flt ='*' + pk_ext(pk_frm-1)

	pk_stak=lonarr(14+4)
    	pk_idx =-1
    	pk_img = 0
    	P_GET_DATAPATH ,pk_pthv

	pk_list=P_ICK_LIST(pk_pthv, pk_flt,cnt)

	if cnt eq 0 then pk_list='No '+pk_ext(pk_frm-1)+ ' Data in Path'

	if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

	pk_base=widget_base  (title='Lamp Pick Data',resource_name='lamptouch',/column)

	pk_p0  =widget_base  (pk_base,/row)
	pk_plab=widget_label (pk_p0  ,value='PATH:' ,font=ft_b_bigger)
	pk_path=widget_text  (pk_p0  ,value=pk_pthv ,font=ft_b_bigger,xsize=40,ysize=1,/editable)
	pk_butu=widget_button(pk_p0  ,value='Update',font=ft_b_normal) & put_logo,pk_p0

	if frm le 0 then begin
	   nxb=n_elements(pk_ext)
	   pk_x   =lonarr(nxb)
	   pk_p0b =widget_base  (pk_base,/row)
	   pk_plab=widget_label (pk_p0b ,value='FORMAT:',font=ft_b_bigger)
	   pk_p0b1=widget_base  (pk_p0b ,/row,/exclusive)
	   for j=0,nxb-1 do $
	   pk_x(j)=widget_button(pk_p0b1,value=pk_bxt(j),font=ft_b_normal)
	   endif

	pk_p1  =widget_base  (pk_base,/row)
	pk_p11 =widget_base  (pk_p1  ,/column)
	pk_root=widget_base  (pk_p11)
	pk_stak(14) =widget_base  (pk_root,map=1)
	 pk_lab     =widget_label (pk_stak(14),value='Files',font=ft_b_bigger)
	pk_stak(15) =widget_base  (pk_root,map=0,/row,uvalue='')
	 pk_lab     =widget_label (pk_stak(15),value='File',font=ft_b_bigger)
	 pk_lab     =widget_label (pk_stak(15),value='{'   ,font=ft_propor)
	 pk_stak(16)=widget_text  (pk_stak(15),value='1'   ,font=ft_propor,xsize=2+cap,ysize=1,/editable)
	 pk_lab     =widget_label (pk_stak(15),value='.'   ,font=ft_propor)
	 pk_stak(17)=widget_text  (pk_stak(15),value='1'   ,font=ft_propor,xsize=2+cap,ysize=1,/editable)
	 pk_lab     =widget_label (pk_stak(15),value='}'   ,font=ft_propor)
	pk_blis=widget_list  (pk_p11 ,value=pk_list,font=ft_b_normal ,ysize=10,xsize=13)
	pk_lab =widget_label (pk_p11 ,value='SnapShot' ,font=ft_b_bigger)
	pk_draw=widget_draw  (pk_p11 ,retain=2  ,xsize=192,ysize=192)

	pk_root    =widget_base  (pk_p1)
	pk_stak(3)=1
	pk_stak(0) =widget_base  (pk_root,/column,map=0)
	pk_lab     =widget_label (pk_stak(0),value='Ascii XY Organisation' ,font=ft_b_bigger)
	pk_stk     =widget_base  (pk_stak(0),/column,/frame)
	pk_lab     =widget_label (pk_stk    ,value=' ')
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value=' Headers'      ,font=ft_b_normal)
	 pk_stak(2)=widget_text  (pk_bid    ,value=' 0 ' ,xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' Step'         ,font=ft_b_normal)
	 pk_stak(3)=widget_text  (pk_bid    ,value=' 1 ' ,xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' max Pair'     ,font=ft_b_normal)
	 pk_stak(13)=widget_text (pk_bid    ,value='2000',xsize=5+cap,ysize=1,font=ft_propor,/editable)
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value='Contents:'     ,font=ft_b_normal)
	 pk_bid    =widget_base  (pk_bid    ,/column,/exclusive)
	   pk_bi   =widget_button(pk_bid    ,value='X , Y'         ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,0]) & widget_control,pk_bi,set_button=1
	   pk_bi   =widget_button(pk_bid    ,value='X , Y , E'     ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,1])
	   pk_bi   =widget_button(pk_bid    ,value='X , Y , Z'     ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,2])
	   pk_bi   =widget_button(pk_bid    ,value='X , Y , Z , V' ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,3])
	   pk_bi   =widget_button(pk_bid    ,value='V , X , Y , Z' ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,4])
	   pk_bi   =widget_button(pk_bid    ,value='W (m,n)'       ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,5])
	   pk_bi   =widget_button(pk_bid    ,value='W (m,n,f)'     ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,6])
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value='Read XY'       ,font=ft_b_normal)
	 pk_bid    =widget_base  (pk_bid    ,/row,/exclusive)
	   pk_bi   =widget_button(pk_bid    ,value='by pairs'      ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,1,0]) & widget_control,pk_bi,set_button=1
	   pk_bi   =widget_button(pk_bid    ,value='by n elements' ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,1,1])
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value=' m='           ,font=ft_b_normal)
	 pk_stak(4)=widget_text  (pk_bid    ,value='  64  ',xsize=6+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' n='           ,font=ft_b_normal)
	 pk_stak(5)=widget_text  (pk_bid    ,value='  64  ',xsize=6+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' f='           ,font=ft_b_normal)
	 pk_stak(6)=widget_text  (pk_bid    ,value=' 1 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value='String_# between XY pairs: (a X b Y c Z d V)',font=ft_b_normal)
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value=' a='           ,font=ft_b_normal)
	 pk_stak(7)=widget_text  (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' b='           ,font=ft_b_normal)
	 pk_stak(8)=widget_text  (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' c='           ,font=ft_b_normal)
	 pk_stak(9)=widget_text  (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' d='           ,font=ft_b_normal)
	 pk_stak(10)=widget_text (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)

	pk_stak(1) =widget_base  (pk_root,/column)
	pk_lab     =widget_label (pk_stak(1),value='Header Contents',font=ft_b_bigger)
	pk_hed     =widget_text  (pk_stak(1),value=[ ' ',' ']       ,font=ft_b_normal,xsize=40,ysize=24,/scroll)

	pk_p2  =widget_base  (pk_base,/row)
	if GEORGE eq 1 then titi='DIAL to be used' else titi='WK_Space to use'
	pk_slid=widget_slider(pk_p2,title=titi               ,font=ft_b_normal,$
				    minimum=1,maximum=lamp_sys,value=pk_sli)
	pk_butg=widget_button(pk_p2,value='GET THE FILE'     ,font=ft_b_normal)
	pk_butc=widget_button(pk_p2,value=' DONE '           ,font=ft_b_normal)
	bidon  =widget_label (pk_p2,value='     '            ,font=ft_b_normal)
	pk_butd=widget_button(pk_p2,value='DELETE THE FILE'  ,font=ft_b_normal)
	pk_p3  =widget_label (pk_p2,value='                 ',font=ft_b_normal,xsize=120)
        bid=sys_dep      ('DYNLAB',pk_base,1)
	widget_control,bad_id=i,pk_base,group_leader=lamp_b1 ,/realize & put_logo

	widget_control,bad_id=i,pk_draw,get_value =  pixw
	if frm le 0 then begin
	   for j=0,nxb-1 do widget_control,bad_id=i,pk_x(j),set_uvalue=[-88,386,pk_blis,j+1]
	   widget_control,bad_id=i,pk_x(pk_frm-1),set_button=1
	   if pk_ext(pk_frm-1) eq '*.*'  then begin i1=1  & i2=0  & endif else begin i1=0  & i2=1  & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	   if pk_ext(pk_frm-1) eq '.hdf' then begin i1=14 & i2=15 & endif else begin i1=15 & i2=14 & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	   endif
	widget_control,bad_id=i,pk_path,set_uvalue=[-88,381,pk_blis]
	widget_control,bad_id=i,pk_blis,set_uvalue=[-88,382,pk_hed ,pixw,192,192]
	widget_control,bad_id=i,pk_butg,set_uvalue=[-88,383,pk_hed ,pk_p3,pk_slid,pixw,192,192,pk_stak(15)]
	widget_control,bad_id=i,pk_butc,set_uvalue=[-88,384,0]
	widget_control,bad_id=i,pk_butd,set_uvalue=[-88,385,pk_blis,pk_p3]
	widget_control,bad_id=i,pk_butu,set_uvalue=[-88,381,pk_blis]

	XMANAGER, 'PICKDATA'  ,pk_base ,event_handler='LAMP_EVENT_PARSER',/just_reg

    endif else begin widget_control,bad_id=i,pk_base,map=1
		     P_ICK_PTH ,[-88,381,pk_blis]
    endelse
return
end

pro P_ICK_FRM,ev,uv
;** *********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

	if ev.select eq 1 then begin
	   pk_frm=uv(3)
	   pk_flt='*' + pk_ext(pk_frm-1)
	   P_ICK_PTH,uv
	   if pk_ext(pk_frm-1) eq '*.*'  then begin i1=1  & i2=0  & endif else begin i1=0  & i2=1  & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	   if pk_ext(pk_frm-1) eq '.hdf' then begin i1=14 & i2=15 & endif else begin i1=15 & i2=14 & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	endif
return
end
pro P_ICK_LST,ev,uv
;** *********
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    pk_idx=ev.index
    if pk_idx ge 0 then begin
	fil =pk_list(pk_idx)
	pk_hyst='' & w_buf=0
	pp2    =-2 & NXe='1' & NXd='1' & NXed=''

	if (pk_ext(pk_frm-1) eq '.hdf') or (pk_ext(pk_frm-1) eq '.xml') then begin
	 widget_control,pk_stak(16),bad_id=ii,get_value=NXe  &  NXe=strtrim(NXe(0),2)
	 widget_control,pk_stak(17),bad_id=ii,get_value=NXd  &  NXd=strtrim(NXd(0),2)
	 if (NXe gt '1') or (NXd gt '1') then NXed='{' +NXe+'.'+NXd+'}'
	endif
	 widget_control,pk_stak(15),bad_id=ii,set_uvalue=NXed

	if pk_ext(pk_frm-1) eq '_LAMP'  then p_did_restore_wrk,fil     ,pk_pthv,'0',pk_hyst,pp2

	if pk_ext(pk_frm-1) eq '.hdf'   then p_did_res_hdf    ,fil+NXed,pk_pthv,'0',pk_hyst,pp2
	if pk_ext(pk_frm-1) eq '.xml'   then p_did_res_hdf    ,fil+NXed,pk_pthv,'0',pk_hyst,pp2

	if (pk_ext(pk_frm-1) eq '.gel') or (pk_ext(pk_frm-1) eq '.image') or (pk_ext(pk_frm-1) eq '.WIND') $
	then if did_scan eq -1 then SL_SCANLOAD,did_scan,lamp_dir

	if pk_ext(pk_frm-1) eq '.gel'   then sl_lampscan, '.gel'   ,w_buf,pp2,pk_hyst,0, pk_pthv+fil

;	if pk_ext(pk_frm-1) eq '.image' then sl_lampscan, '.image' ,w_buf,pp2,pk_hyst,0, pk_pthv+fil

	if pk_ext(pk_frm-1) eq '.WIND'  then sl_lampscan, 'restore',w_buf,pp2,pk_hyst,0, pk_pthv+fil

	if !D.name ne 'Z' then wset,uv(3) else device,set_resolution=[uv(4),uv(5)] & erase
	u=-1
	if pk_ext(pk_frm-1) eq 'dial_*.pro*' then begin on_ioerror,misdial & str=''
					openr,u,pk_pthv+fil,/get_lun
					while (1) do begin str    = strarr(10)   & readf,u,str
					                   pk_hyst=[pk_hyst,str] & endwhile
					misdial: if u gt 0 then free_lun,u
					pk_hyst=[pk_hyst,str]
	endif
	if pk_ext(pk_frm-1) eq '*.*'    then begin on_ioerror,misread & str=strarr(10)
					openr,u,pk_pthv+fil,/get_lun
					readf,u,str
					misread: if u gt 0 then free_lun,u
					for i=0,9 do xyouts,2,173-(19*i),str(i),charsize=1.,/device,color=255

	endif else widget_control,bad_id=i,uv(2),set_value=pk_hyst

	in=-1
	pk_img=0
	on_ioerror,mispixf
	ext='img'

	i =findfile(pk_pthv+fil+'.Z',count=cnt)
	if cnt eq 1 then bid=sys_dep      ('UN_Z',pk_pthv+fil+'.Z',lamp_dir)

	i=  strpos(fil,'.htm') & ordur=0
	if i lt 0 then i=strpos(fil,'.xml')
	if i ge 0 then begin            fil=strmid(fil,0,i)
	                                res=findfile(pk_pthv+fil+'_s.png',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_i.png',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'-1.png',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_s.jpg',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_i.jpg',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'-1.jpg',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_s.gif',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_i.gif',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'-1.gif',count=cnt)
	                                if  cnt gt 0 then fil=res(0)
	endif     else begin            fii=fil & ii =sys_dep('POT+',fil,ext,1)
	                                res=findfile(pk_pthv+fil         ,count=cnt)
	                                if  cnt eq 0 then begin ext='png' & fil=fii
	                                                        ii =sys_dep('POT+',fii,ext,1)
	                                res=findfile(pk_pthv+fii         ,count=cnt) & endif
	                                if  cnt eq 0 then begin ext='jpg'
	                                                        ii =sys_dep('POT+',fil,ext,1)
	                                res=findfile(pk_pthv+fil         ,count=cnt) & endif
	                                if  cnt gt 0 then begin fil=res(0) & ordur=1 & endif
	endelse
	if NXed ne '' then cnt=0                          ;**Snap already in w_buf or other dataset
	if cnt  gt  0 then if pp2 eq 10 then READ_KIF,fil,w_buf $
	                                else READ_KIF,fil,w_buf,uv(4),uv(5) ;**pp2=10 -> (png,gif) else (img)
	mispixm:
	s=size(w_buf)
	if (s(1) eq uv(4)) and (s(2) eq uv(5)) then begin
		 worder=!order & !order=ordur
		 tvscl,w_buf   & !order=worder
		 pk_img=1
		 endif
	mispixf:if in gt 0 then free_lun,in
	p_did_setwin0
	w_buf=0
    endif
return
end
pro P_ICK_MICO, wkstring,xx,yy,uv,pp2
;** **********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

	if pk_img eq 0 then begin
	   fil =pk_list(pk_idx)

	   if pp2 eq 10 then ext='png' else ext='img'

	   i=  strpos(fil,'.htm')
	   if i lt 0 then i  =strpos(fil,'.xml')
	   if i ge 0 then fil=strmid(fil,0,i)+'-1.png' else ii =sys_dep('POT+',fil,ext,1)

	   kpDname=!D.name	; or pixmap in uv(5) but problems with true colors...
	   set_plot, 'Z' & device,set_resolution=[uv(6),uv(7)] & erase & w0=0
	   p_did_makeicon, wkstring,xx,yy, uv(6),uv(7) ,0 ,w0 ,'s'
	   worder =!order & !order=0
	   if strpos(fil,'img') gt 0 then !order=1
	   w0=tvrd(0,0,uv(6),uv(7))
	   !order =worder
	   set_plot,kpDname

	   if pp2 ne -10 then WRITE_KIF,pk_pthv+fil,w0,transparent=[0] ;**pp2=10 -> (png,gif) else (img)

	   p_did_setwin0
	endif
return
end

pro P_ICK_PTH ,uv
;** *********
;**
@lamp.cbk
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

	widget_control,bad_id=i,pk_path,get_value=pth
	pk_pthv=sys_dep      ('BLANKS',pth(0))
	if pk_pthv ne '' then begin
	   car=strmid(pk_pthv,strlen(pk_pthv)-1,1)
	   if (car ne lamp_dvd) then begin
			   pk_pthv=pk_pthv+lamp_dvd
			   widget_control,bad_id=i,pk_path,set_value=pk_pthv
			   endif
	endif
	pk_idx =-1

	pk_list=P_ICK_LIST(pk_pthv, pk_flt,cnt)

	widget_control ,bad_id=i,uv(2),set_value=pk_list

return
end
pro P_ICK_GET ,pth,filin,frm,info,uv
;** *********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    filin=''
    if pk_idx ge 0 then begin
	pth  =pk_pthv
	filin=pk_list(pk_idx)
	frm  =pk_ext(pk_frm-1)
	info =pk_hyst
	widget_control,bad_id=i,uv(4),get_value=pk_sli
    endif
return
end
pro P_ICK_DEL,uv
;** *********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    if pk_idx ge 0 then begin
    	fild=pk_list(pk_idx)
	if fild ne '' then begin
		j=strpos(fild,'.htm') &  if j lt 0 then j=strpos(fild,'.xml')
		if j gt 0 then begin     tmp=strmid(fild,0,j)
		  res =FINDFILE (pk_pthv+tmp+'*.*',count=cnt)
		  for i=0L,cnt-1 do begin
			if strpos(res(i),tmp+'.htm')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'.xml')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'.xdr')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'.zip')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_i.gif') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_s.gif') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'-1.gif') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_i.png') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_s.png') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'-1.png') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_i.jpg') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_s.jpg') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'-1.jpg') ge 0 then bid=sys_dep('DELET',res(i))
		  endfor
		endif else begin
		  bid =sys_dep ('POT+' ,fild,'*' , 2)
		  fild=FINDFILE(pk_pthv + fild)
		  for i=0,n_elements(fild)-1 do bid=sys_dep('DELET',fild(i))
		endelse
	endif
	P_ICK_PTH,uv
    endif
return
end

pro P_GET_DATAPATH, pk_pthv
;** **************
;**
@lamp.cbk
    if  n_elements(pk_pthv) le 0 then pk_pthv=''
    if  pk_pthv eq '' then begin
	pk_pthv=getenv('LAMP_DATAPATH')
	if pk_pthv eq '' then cd,current = pk_pthv
	pk_pthv=sys_dep      ('BLANKS',pk_pthv)
	car=strmid(pk_pthv,strlen(pk_pthv)-1,1)
	if (car ne lamp_dvd) then pk_pthv=pk_pthv+lamp_dvd
    endif
return
end

pro P_ICK_SCAN, pp2,frm,wnumber,uv,hyst,fname,pth
;** **********
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
    common c_ick_scan,  c_pp2,c_frm,c_w,c_uv,c_hyst,tbl

if n_elements(tbl) le 1 then  tbl =[512,512,1, 5,0, 0, 0,1]
c_pp2=pp2 & c_frm=frm & c_w=wnumber & c_uv=uv & c_hyst=hyst
if did_scan eq -1 then SL_SCANLOAD, did_scan,lamp_dir
if did_scan ge  0 then ii=execute('descript,pth+fname,tbl')
return
end

pro P_ICK_RETURN,ok,filename,xtbl
;** ************
;**
@lamp.cbk
common c_ick_scan,c_pp2,c_frm,c_w,c_uv,c_hyst,tbl

if ok eq 1 then begin
	tbl=xtbl & xtbl=[xtbl,0]
	if  xtbl(3) eq 5 then begin xtbl(3)=4 & xtbl(8)=1 & endif
	flg='pass'
	i =execute( 'sl_lampscan, flg ,w' + c_w + ',c_pp2,0,xtbl, filename' )
	comhis='P_ICK_SCAN,-1,"'+c_frm+'","'+c_w+'",0,h,"'+filename+'",""'
	p_did_just_read, c_pp2,c_frm,c_w,c_uv,c_hyst,filename ,bidon ,comhis
endif
return
end

pro P_ICK_XY, ev, uv
;** ********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

if ev.select eq 1 then pk_stak(11+uv(2))=uv(3)
end
pro READ_LXY, pthfil,w=wi,status=pp2
;** ********
;**
@lamp.cbk
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

head=0 & step=1 & mxi =2000 & m=1 & n=1 & f=1 & a=0 & b=0 & c=0 & d=0 & org=pk_stak(11) & pair=pk_stak(12)
ws  =strtrim(string(wi),2)  & strtit=['']

widget_control,bad_id=i,pk_stak(2) ,get_value=heas & on_ioerror,mish & head=long(heas(0))>0 & mish:
widget_control,bad_id=i,pk_stak(3) ,get_value=stes & on_ioerror,miss & step=long(stes(0))>1 & miss:
widget_control,bad_id=i,pk_stak(13),get_value=mxi  & on_ioerror,misx & mxi =long(mxi (0))>0 & misx:

widget_control,bad_id=i,pk_stak(4) ,get_value=ms   & on_ioerror,mism &    m=long(ms(0))>1   & mism:
widget_control,bad_id=i,pk_stak(5) ,get_value=ns   & on_ioerror,misn &    n=long(ns(0))>1   & misn:
widget_control,bad_id=i,pk_stak(6) ,get_value=fs   & on_ioerror,misf &    f=long(fs(0))>1   & misf:

widget_control,bad_id=i,pk_stak(7) ,get_value=as   & on_ioerror,misa &    a=long(as(0))>0   & misa:
widget_control,bad_id=i,pk_stak(8) ,get_value=bs   & on_ioerror,misb &    b=long(bs(0))>0   & misb:
widget_control,bad_id=i,pk_stak(9) ,get_value=cs   & on_ioerror,misc &    c=long(cs(0))>0   & misc:
widget_control,bad_id=i,pk_stak(10),get_value=ds   & on_ioerror,misd &    d=long(ds(0))>0   & misd:

ii=execute('READ_ORG, pthfil, w'+ws+',x'+ws+',y'+ws+',z'+ws+',e'+ws+', head,step,m,n,f,a,b,c,d' + $
                                    ',org,pair,mxi, status=pp2,ws=ws, strtit=strtit')
if ii eq 1 then begin nt=n_elements(strtit)
                      if nt gt 0 then w_tit(wi)    =strmid(strtit(0),0,80)
                      if nt gt 1 then x_tit(wi)    =strmid(strtit(1),0,80) else x_tit(wi)    ='X'    & y_tit(wi)='Y'
                      if nt gt 2 then other_tit(wi)=strmid(strtit(2),0,80) else other_tit(wi)=pthfil & endif
end
;*****************************************************************************************
;*****************************************************************************************
;*****************************************************************************************

pro	P_AFTER_REALIZE_DID ,sepben,sepdon,sepdid
;**	*******************
@lamp.cbk
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
        common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

	common c_drow

    	oo=n_elements(did_wd)
    	if oo eq 0 then P_DID_SETVAR
    	if oo eq 0 then P_DON_INIT_VAR

	if did_inib(0) gt 0 then widget_control,bad_id=i,did_inib(0),set_button=1
	if did_inib(1) gt 0 then widget_control,bad_id=i,did_inib(1),set_button=1
	i =0
	if sepdon gt 0 then begin widget_control,bad_id=i,sepdon ,get_value=j
				  if i eq 0 then begin wset,j & erase,50 & endif & endif

	if sepdid gt 0 then begin widget_control,bad_id=i,sepdid ,get_value=j
				  if i eq 0 then begin wset,j & erase,50 & endif & endif

	if (did_wd gt 0) or (!D.name eq 'Z') then loadct  , tcol
	ii=1
	if  did_wd gt 0 then widget_control,bad_id=ii,did_wd  ,get_value =did_win0
	if  did_we gt 0 then widget_control,bad_id=ii,did_we  ,get_value =did_win1

;	   Load Icones
;	   ---- ------
			   logo,3 & logo,4
	   if ii eq 0 then logo,1

	if did_wd  gt 0 then begin   catch,stat
	   if stat eq 0 then device ,font=sys_dep      ('FONTD') else catch,/cancel
	endif
	if lamp_focus gt 0 then widget_control,bad_id=i,lamp_focus,set_value='',/append,/no_newline,$
										/input_focus
	tso=0 & did_scan=-1
	if (!D.flags and 65536) ne 0 then sl_lampscan, 'test' ,did_scan,tso

	did_surf(0)= (tso and 1)

;	Set history
;	--- -------
	set_history
	kcol=tcol
	catch,stat
	if stat eq 0 then DON_INIT_PROG_MAC  ,-1 else catch,/cancel

	if kcol ne tcol then if (did_wd gt 0) or (!D.name eq 'Z') then loadct, tcol
	catch,stat
	if stat eq 0 then begin
	 if (not sys_dep('RUNTIME')) and (not sys_dep('EMBEDDED')) then begin
	  if  b_labins(3) ne 2 then CALL_PROCEDURE,'myinit'
	 endif
	 if  b_labins(3) ne 2 then CALL_PROCEDURE,'myinit_'+strlowcase(inst_value)
	endif
	catch,stat
	if stat eq 0 then begin
         na=FINDFILE('myinit.prox',count=nn)
         if nn gt 0 then begin
          on_ioerror, misini & in=-1
	  OPENR,in,'myinit.prox',/get_lun
	  line=''
	  WHILE (not eof(in)) DO begin readf,in,line & iii=EXECUTE(line) & ENDWHILE
	  misini: if in gt 0 then FREE_LUN,in
	  CD,current=mee
	  P_SET_PATH,mee
	 endif
	endif else catch,/cancel

	styles(2,0)=1

	!order  = 0
	!x.style= 1  &  !y.style= 1  &  !z.style= 1
	!x.range= 0  &  !y.range= 0  &  !z.range= 0
	!p.font = 0
	!p.color= 255
	!p.background= 0
	!p.position=[0,0,0,0]
return
end

pro logo ,flg
;** ****
@lamp.cbk
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

	scan_dir= lamp_dir & if scan_dir ne "" then scan_dir= scan_dir + sys_dep('DIVIDER')

;	Load Image (0) (1)show
;	---- -----
	if flg lt 2 then begin
	   if n_elements(did_lamp) le 1 then begin did_pix=0
		if (!D.flags and 65536) ne 0  then begin
      		did_pox=widget_base  (title='',map=0)
      		pix    =widget_draw  (did_pox,retain=2,xsize=512,ysize=256,colors=-30)
       		widget_control,did_pox,bad_id=i ,/realize
      		widget_control,pix,bad_id=i ,get_value=did_pix
		endif
		u=-1
		on_ioerror,misimg
		gif='lampIMG.'
		if n_elements(GEORGE) eq 1   then if (GEORGE eq 1) then gif='geoIMG.'
		if sys_dep('VERSION') ge 5.4 then gif=gif+'png' else gif=gif+'gif'
		wor=!order

		if sys_dep('STUDENT') then did_lamp=bytscl(sin(bytscl(indgen(300,150))/10.)) $
		else begin
		   did_lamp=bytarr(512-1,256)
		   bid=findfile(scan_dir+gif,count=cnt)
		   if cnt gt 0  then begin
		    READ_KIF,scan_dir+gif,did_lamp
		   endif else begin
		    if n_elements(did_icon) lt 128 then LAMPICO,did_icon
		    did_lamp=smooth (rebin(did_icon,512,256),3)
		    mx=max(did_lamp)
		    did_lamp=mx-did_lamp
		   endelse
		endelse
		p_screen & mini=0
        	if n_elements(b_labins) ge 4 then if b_labins(3) eq 2 then mini=1
		if lamp_siz lt 800 then mini=1
		if mini then did_lamp=congrid(did_lamp,300,150)

                LAMPICO,idlicon,ldi=35

		if (!D.flags and 65536) ne 0 then begin wset,did_pix & tvscl,did_lamp & endif
		if (!D.name   eq 'Z') then  begin device,set_resolution=[512,256] & tvscl,did_lamp & endif
;		if (sys_dep('RUNTIME') or sys_dep('EMBEDDED')) then $
		               tvscl,idlicon,0,(size(did_lamp))(2) - (size(idlicon))(2)
		if  sys_dep('STUDENT') then xyouts,100,75,'STUDENT Version',/device,color=0
		if n_elements(GEORGE)  eq 1 then if GEORGE eq 3 then begin
			xyouts,5  ,25,'GEORGE inside' ,/device,color=57,font=0
			xyouts,6  ,24,'GEORGE inside' ,/device,color=54,font=0 & endif

		misimg:if u gt 0 then free_lun,u
		!order=wor
		did_lamp=size(did_lamp)
	   endif
	   if flg eq 1 then begin
		p_did_setwin0 & erase,0
		s=did_lamp(2)
		k= (did_x/32)>1
		j= (did_y-s) /2
		if n_elements(GEORGE) eq 1 then if did_pix gt 0 then begin
		for i=did_x-k,0 ,-k  do device,copy=[0,0,did_x-i,s,i,j,did_pix]
					device,copy=[0,0,did_x-i,s,k,j,did_pix]
		for i=k-1,0 ,-1	     do begin  wait,.01
					device,copy=[0,0,did_x-i,s,i,j,did_pix] & endfor
		endif
	   endif
	endif

;	Load Icone (0) (2)export
;	---- -----
	if (n_elements(did_pio) eq 0) then did_pio=0
	if (did_pio(0) eq 0)  and (flg ne 4) then begin

		if (!D.flags and 65536) ne 0 then begin
      		did_poo=widget_base  (title='',map=0)
      		pio    =widget_draw  (did_poo,retain=2,xsize=128,ysize=64,colors=-30)
       		widget_control,did_poo,bad_id=i ,/realize
      		widget_control,    pio,bad_id=i ,get_value=did_pio
		endif
		u=-1
		on_ioerror,misicon
		if n_elements(did_icon) lt 128 then begin
		 did_icon=bytarr(128,64)
		 did_icon(*,*)=255
		 cnt=0 ;bid=findfile(scan_dir+'lampICO.jpg',count=cnt)
		 if cnt eq 0  then LAMPICO,did_icon  else $
		 READ_KIF,scan_dir+'lampICO.jpg',did_icon
		endif
		if (!D.flags and 65536) ne 0 then begin wset,did_pio & tvscl,did_icon,0,0 & endif
		misicon:if u gt 0 then free_lun,u
		did_icon(0,0)=max(did_icon)
	endif
	if  flg eq 0  then flg=did_pix  else $
	if  flg eq 2  then flg=did_icon else $
	if  flg eq 3  then begin  if n_elements(lamp_ben) ge 7 then if lamp_ben(6) gt 0 then begin
      			 	  widget_control, bad_id=ii ,lamp_ben(6),get_value=did_tio
				  did_pio=[did_pio,lamp_ben(6)] & endif
				  did_o=0
				  endif else $
	if (flg eq 3) or (flg eq 4) then if did_tio gt 0 then if did_o ne 1 then begin did_o=1 & keepw=!Window
					 wset,did_tio & device,copy=[0,0,128,64,0,0,did_pio(0)]
					 if keepw gt 0 then wset,keepw
	endif
return
end

pro put_logo, wid ,TIO=tio ,file=icofil
;** ********
;**
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
	common c_plog,  win,sicon,pixlog

	if !D.name ne 'Z' then begin
		if n_elements(wid) eq 1 then win=widget_Draw(wid,retain=2,xsize=64,ysize=32,/motion_event) $
		else begin
      		     widget_control,win,bad_id=i, get_value = wis
      		     widget_control,win,bad_id=i, set_uvalue=[-88,391,wis]
		     if n_elements(sicon) le 1   then begin
			if n_elements(did_icon) lt 128 then did_icon=bytarr(128,64)
			sicon=congrid(did_icon,64,32)
      			byd=widget_base  (title='',map=0)
      			bid=widget_draw  (byd,retain=2,xsize=64,ysize=64,colors=-30)
       			widget_control   ,byd,bad_id=i , /realize
      			widget_control   ,bid,bad_id=i , get_value=pixlog
			wset,pixlog  &    tvscl,sicon,0,0 & tvscl,sicon,0,32
		     endif
		     ok=0
		     if n_elements(icofil) eq 1   then begin
			bid=findfile(icofil,count=ok)
			if ok gt 0 then begin	bicon=bytarr(64,32) & READ_KIF,icofil,bicon
						bicon=congrid(bytscl(bicon),64,32)
						widget_control,win,bad_id=i,draw_motion_events=0
			endif
		     endif
		     keepw=!Window & wset,wis & if ok gt 0 then tvscl,bicon else tvscl,sicon
		     if keepw gt 0 then  wset,keepw
		     if keyword_set(tio) then did_tio=-wis
		endelse
	endif
end

pro p_did_mvlog, ev,uv
;** ***********
;**
	common c_plog,  win,sicon,pixlog

	if !D.name ne 'Z' then begin
	keepw=!Window    &  wset,uv(2)
	for i=2,32,2 do begin device,copy=[0,i,64,32,0,0,pixlog] & wait,.05 & endfor
	if keepw gt 0 then  wset,keepw
	endif
end

pro p_tremble
;** *********
;**
@lamp.cbk
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

if (lamp_b1 gt 0) and (n_elements(did_x) gt 0) and (!D.name ne 'Z') then begin
	if n_elements(did_buf) eq 0 then did_buf=0
	if did_buf eq 0  then begin

      		did_bif=widget_base  (title='',map=0)
      		buf    =widget_draw  (did_bif,retain=2,xsize=did_x,ysize=did_y)
       		widget_control,did_bif,bad_id=i ,/realize
      		widget_control,buf    ,bad_id=i ,get_value=did_buf

	endif

	keepd=!D.window
	if keepd gt 0 then begin
	   wset , did_buf
	   device,copy= [0,0,did_x,did_y,0,0,did_win0]
	   k=did_y/20 &  wset,did_win0 & erase
	   for i=k,0,-1  do device,copy=[0,0,did_x,did_y-i,0,i,did_buf]
	   wset , keepd
	endif
endif
return
end

function RDSTOP, a,b,ic, win=wit
;******* ******
;**
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
	stp=0
	if (n_elements(wit) eq 4) or (did_tio gt 0) then begin
	   if n_elements(wit) ne 4 then wit=[did_pio(1),did_tio,128,64]

	   if  ic  ne b then p=round(abs(b-a+1)/64.)>1 else p=1
	   t=long(ic-a+1)  & s=t/p & s=s*p
	   if  a eq ic  then begin
	     if a ne b then begin
	   	keepw=!Window   & if !D.name ne 'Z' then wset,wit(1)
		widget_control,wit(0),bad_id=ii,/clear_events & erase,255
		xyouts,(wit(2)-64)>1,(wit(3)/2-17)>1,'STOP',font=-1,charsize=2.,charthick=3.,/device,color=0
		if keepw gt 0 then if !D.name ne 'Z' then wset,keepw
	     endif
	   endif else begin keepw=0
		evv=widget_event(wit(0),/nowait,bad_id=ii) & widget_control,/hourglass
	   	if evv.id eq wit(0) then begin
	   	   keepw=!Window   & if !D.name ne 'Z' then wset,wit(1)
		   stp=1
		   erase ,255
		   device,copy=[0,0,128,64,0,0,did_pio(0)]
		   widget_control,wit(0),bad_id=ii,/clear_events
		   P_MUS,'mus_cannon'
		endif else if s eq t then begin
	   	   keepw=!Window   & if !D.name ne 'Z' then wset,wit(1)
		   t=fix(128.*(ic-a+1)/(b-a+1))>1
		   t=long(t*wit(2)/128.)
		   device,copy=[(128-t)>0,0,t<128,64,(t-128)>0,(wit(3)/2-32)>0,did_pio(0)]
		endif
		if keepw gt 0 then if !D.name ne 'Z' then wset,keepw
	   endelse
	endif

return, stp
end

pro RDSTAP, a,b,ic, res
;** ******
res=RDSTOP( a,b,ic)
end

pro p_did_getw_cur, widx, wnumb
;** **************
;**
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

	if n_elements(did_wsc) eq 1 then begin
		widget_control,bad_id=i,did_wsc,get_value=wnumb
		if i eq 0 then wnumb=strupcase(strtrim(wnumb(0),2))
		i =strpos(wnumb,'W')
		wnumb=strtrim(strmid(wnumb,i+1,4),2)
		widx   =fix(wnumb)
	endif else begin widx=1 & wnumb='1' & endelse
return
end

function sl_zoom, x,y,xd,yd
;******* *******
;**
	common	my_geto,go_v7,go_v2,go_v3,go_rql,go_rqm,go_x5,go_y5
;**
;**	Return -1 for none, 1 for left, -2 for middle, -3 for right button.

	ok=0  & ok2=0
	;wiwi=(sys_dep('MACHINE') eq 'win')
	if n_elements(go_v7) eq 0 then begin
	   go_v7= lonarr(7) & go_v2= lonarr(2) & go_y5= intarr(5)
	   go_v3= intarr(3) & go_x5= intarr(5) & endif

	go_x5(0)=x & go_x5(3)=x & go_x5(4)=x
	go_y5(0)=y & go_y5(1)=y & go_y5(4)=y
	xd=x & yd=y
	xp=x & yp=y

	device,set_graphics =6

	but=1 & bat=1
	while (xd ge 0) and (but ne 0) do begin
	   bat=but
	   if  (xd ne xp) or (yd ne yp) then begin
		if ok eq 1 then begin
		    if bat eq 2 then plots   ,go_x5,go_y5,/device, color=255 $
		    		else polyfill,go_x5,go_y5,/device, color=255
		    ok=0 &  endif
		xp=xd & yp=yd
		if bat eq 2 then sz=15 else sz=15
		if (xd-x gt sz) or (xd-x lt -sz) and  $
		   (yd-y gt sz) or (yd-y lt -sz) then begin
		    go_x5(1)=xd  &  go_x5(2)=xd
		    go_y5(2)=yd  &  go_y5(3)=yd
		    if bat eq 2 then plots   ,go_x5,go_y5,/device, color=255 $
		    		else polyfill,go_x5,go_y5,/device, color=255
		    ok=1 & ok2=1
		endif
	   endif
	   cursor  ,xd,yd,0,/device
	   but=!err & if  but lt 0 then but=-but & if (but eq 1) or (but eq 4) then but=5-but
	  ;if wiwi then if but eq 1 then but=2
	endwhile

	if ok eq 1 then if bat eq 2 then plots   ,go_x5,go_y5,/device, color=255 else $
			if bat eq 4 then polyfill,go_x5,go_y5,/device, color=255 else $
			if xd  lt 0 then polyfill,go_x5,go_y5,/device, color=255
	if xd lt 0 then ok=-1
	if ok eq 0 then if ok2 eq 1 then ok=-1
	if ok eq 1 then if bat eq 1 then ok=-3 else $
			if bat eq 2 then ok=-2

	device,set_graphics =3

return, ok
end

pro did_zoom_reset
;** **************
;**
    common c_titi,viex,xxs,yys,wt,xo,yo,zn,xn,but,redo,ok,w_suf
viex=0
end

pro did_zoom ,event,uv
;** ********
;** Draw event (zoom turn)
;**
;**uv:	 2:base	 3:wi	 4:draw	 5:wind	 6:x0	 7:y0	 8:bstx	 9:bsty	10:rgx	11:rgx	12:rgy	13:rgy
;**	14:surf	15:!ord	16:axy	17:labl	18:xof	19:yof	20:log	(12=-1 ->vector)

;**	type 0:pressed	 1:released	 2:motion
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff
    common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

    common c_titi,viex,xxs,yys,wt,xo,yo,zn,xn,but,redo,ok,w_suf

	if (!D.name ne 'Z') then $
	if (event.type eq 0) or (event.type eq 2) or (event.type eq 1) then begin
		x=event.x & y=event.y
		if (uv(14) eq 0) or (uv(12) lt 0) then begin	;no surf

		 ws =strtrim(string(uv(3)),2)
		 ssz=[0] & ii=execute( 'ssz=size(w'+ws+')' ) & if ssz(0) gt 2 then RETURN
		 if (trap_current ne uv(5)) and (uv(16) ne 1)  then  RETURN

		 if (event.type ne 1) then begin
		  bu=event.press & xd=0 & yd=0
		  wset,uv(5)
		  if (uv(17) eq l_message) and (did_tio gt 0) then oki=1 else oki=0
		  XV=0 & YV=0 & XG=0 & YG=0
		  if event.type eq 0 then begin if uv(12) lt 0 then begin
						  tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
						  XV=tmXYZ(0) & YV=tmXYZ(1) ;CURSOR,XV,YV ,/nowait,/data
						endif
						p_zoom, x,y,xd,yd,bb & wset,uv(5)
					  endif
		  if event.type eq 2 then begin   tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
						  XV=tmXYZ(0) & YV=tmXYZ(1) ;CURSOR,XV,YV ,/nowait,/data
						  bb=-9 & xd=x & yd=y & endif
;**		  Activate zoom
;**		  -------- ----
		  if (bb eq 1) or (bb eq -2) or (bb eq -3) or (bb eq -9) then begin ole=1
		  	vft=vfl
		  	xo =uv(6)
		  	xb =uv(18)
			vft(0)=round(uv(10) + (uv(11)-uv(10)) * (float((min([x,xd])-xo)) / (uv(8)-(xo+xb))) )
			flut  =      uv(10) + (uv(11)-uv(10)) * (float((max([x,xd])-xo)) / (uv(8)-(xo+xb)))
			if (vft(0) lt uv(10)) or (flut gt uv(11)) then ole=0
			vft(0)=vft(0)>0
			vft(1)=round(flut)
			if uv(16) eq 1 then begin XV=vft(0)-uv(10) & XG=vft(1)-uv(10) & endif
			vft(3)=0
			if  uv(12) ge 0 then begin
		  	 yo =uv(7)
		  	 yb =uv(19)
		  	 mx =max([y,yd]) & mn =min([y,yd])
		  	 if uv(15) eq 0 then begin i=uv(9)-mn & mn=uv(9)-mx & mx=i & endif $
		  		        else begin i=yo	      & yo=yb       & yb=i & endelse

			 vft(2)=round(uv(12) + (uv(13)-uv(12)) * (float((uv(9)-mx-yo)) / (uv(9)-(yo+yb))) )
			 flut  =      uv(12) + (uv(13)-uv(12)) * (float((uv(9)-mn-yo)) / (uv(9)-(yo+yb)))
			 if (vft(2) lt uv(12)) or (flut gt uv(13)) then ole=0
			 vft(2)=vft(2)>0
			 vft(3)=round(flut)
			 if uv(16) eq 1 then begin YV=vft(2)-uv(12) & YG=vft(3)-uv(12) & endif

			endif else if (trap_current eq uv(5)) and (uv(16) eq 0) then begin
				tmXYZ=CONVERT_COORD(xd,yd,/dev,/to_data)
				XG=tmXYZ(0) & YG=tmXYZ(1) ;CURSOR,XG,YG ,/nowait,/data
		    		if uv(20) eq 1 then begin YV=exp(YV) & YG=exp(YG) & endif
				XS =[0L] &  iii=execute( 'XS=n_elements(x'+ws+')-1' )
			      	ivf= 0L  &  iii=execute('ivf= where(X'+ws+' ge XV )') & ivf=ivf(0)>0<XS
			      	ivl= 0L  &  iii=execute('ivl= where(X'+ws+' ge XG )') & ivl=ivl(0)>0<XS
			      	if ivl  eq 0     then   ivl= uv(11)
				vft (0) =  min([ivf,ivl])   & vft (1) = max([ivf,ivl])
			endif	else begin XV=vft(0)-uv(10) & iii=execute('YV=w'+ws+'(XV)')
				           XG=vft(1)-uv(10) & iii=execute('YG=w'+ws+'(XG)')
			endelse
;**			Total
;**			-----
			if bb eq -3 then begin
			      trap_x1=vft(0) & trap_x2=vft(1) & trap_y1=vft(2) & trap_y2=vft(3)
			      trap_ws=ws
			      trapp  ,tot
			      avg= tot / ((vft(1)-vft(0))*(vft(3)-vft(2)))
			      tx1='  Total :  '   +strtrim(string(tot),2)
			      tx2=' Average : '   +strtrim(string(avg),2)
		     	      if oki eq 0 then   widget_control ,bad_id=i,uv(17),set_value=tx1+tx2 $
			      else begin wset,did_tio & erase,255 & xyouts,3,20, tx1,charsize=1.2,/device,color=120
						      	xyouts,3,3, tx2,charsize=1.2,/device,color=120 & endelse

;**			Motion
;**			------
			endif else if bb eq -9  then begin
			   if (uv(12) lt 0) and (ssz(2) ne 6) then if (YV lt w_min(uv(3))) or (YV gt w_max(uv(3))) then ole=0
			   if ole eq 1 then begin
			      IV=0
			      if uv(16) eq 1 then begin    XI=round(XV>0)+uv(10)
				    iii=execute('XV=X'+ws+'(XI)')
				    if uv(12) ge 0 then begin YI=round(YV>0)+uv(12)
		    				YS =[0] & ii=execute( 'YS=size(y'+ws+')' )
						if YS(0) eq 2 then begin XI=XI+ XI*YI & YI=XI & endif
						iii=execute('XV=X'+ws+'(XI)')
						iii=execute('YV=Y'+ws+'(YI)')
				    endif else  iii=execute('YV=W'+ws+'(XI)')

			      endif
			      tx1=' X='+strtrim(string(XV),2) & tx2=' Y='+strtrim(string(YV),2)
		     	      if oki eq 0 then   widget_control ,bad_id=i,uv(17),set_value=tx1+tx2 $
			      else begin did_o=0 & wset,did_tio & d =32
					 xd=(x+d*2-1) & if xd gt (did_x-1) then a=xd-(did_x-1)  else a=0
					 yd=(y+d-1)   & if yd gt (did_y-1) then b=yd-(did_y-1)  else b=0
					 xe=(x-d*2)   & if xe lt  0        then c=xe		else c=0
					 ye=(y-d-1)   & if ye lt  0        then d=ye		else d=0
					 xe=xe-a-c    & ye=ye-b-d & off=10
	   				 device,copy= [xe,ye,128,64 ,0,0,did_win0]
					 device,get_graphics=oldg,set_graphics=6
	   				 device,copy= [xe,ye,128,off,0,0,did_win0]
					 plots,[64,64]+a+c,[63,32+b+d],color=255,/device,psym=0
					 device,set_graphics=oldg
					 xyouts,2,1, tx1+tx2,/device,color=255
					 endelse
			   endif else LOGO,4
;**			Zoom
;**			----
			endif else begin
			      if (uv(12) lt 0) and (y lt yd) then begin vft(2)=0 & vff(1)=YG & endif
			      vfl= vft
			      uv =[-88,301,uv(2),uv(3)]
			endelse
;**		  Activate cursor position
;**		  -------- ------ --------
		  endif else begin
		    cursor,X,Y ,/nowait,/device
		    if (X ge 0) and (Y ge 0) then begin
		     xdv=x & ydv=y
		     XS =[0L] & ii=execute( 'XS=size(x'+ws+')' )
		        xo =uv(6)
		        yo =uv(7)
		  	xb =uv(18)
		  	yb =uv(19)
			XI =round( uv(10) + (uv(11)-uv(10)) * (float(X-xo) / (uv(8)-(xo+xb))) ) >0
			YI =0. & ii =execute( 'YI=w'+ws+'(XI)' )
;**		     For a vector
;**		     --- - ------
		     if (uv(12) lt 0) then begin
		    	if (trap_current eq uv(5)) and (uv(16) eq 0) then cursor,X,Y ,/nowait,/data $
		    	else begin	X=XI & Y=YI & endelse
		    	YC =Y
		  	D  =uv(10)
		  	YV =0. & XV =X
		  	IDX=[0L]
		  	if (XS(0) le 0) or (uv(16) eq 1) then begin
		  				X =round(X)>0
		  				if XS(0) gt 0 then ii=execute( 'XV=x'+ws+'(X)' ) $
		  				else XV=X
		  				ii=execute( 'YV =w'+ws+'(X)' )
		  	endif else begin 	ii=execute( 'IDX=where(x'+ws+' ge X)' )
		  		if ii eq 1 then ii=execute( 'X  =x'+ws+'(IDX(0))' )
		  		if ii eq 1 then ii=execute( 'YV =w'+ws+'(IDX(0))' )
		  		XV=X
		  	endelse
		  	if ii eq 1 then Y=YV
		  	Ym=w_min(uv(3)) & Ymx=w_max(uv(3))
		  	ii=execute( 'Ym =min(w'+ws+'(uv(10):uv(11)),max=Ymx)' )
		  	if uv(20) eq 1 then begin Ym=alog10(temporary(Ym) > 1E-9) & Y=alog10(temporary(Y) > 1E-9) & endif
			if (trap_current eq uv(5)) and (uv(16) eq 0) then begin
		  	   oplot,[X,X],[Ym,Y],linestyle=1,color=0
		  	   if bu ne 4 then $
		  	   xyouts,X,YC,'_x='+strtrim(string(XV),2),charsize=1.2,/data,color=0 else $
		  	   xyouts,X,YC,'_y='+strtrim(string(YV),2),charsize=1.2,/data,color=0
			endif else begin
			   XR =round( (XI-uv(10))*float((uv(8)-(xo+xb)))/(uv(11)-uv(10)) +xo ) >0
		    	   YR =round( (YV-Ym    )*float((uv(9)-(yo+yb)))/(Ymx   -Ym)     +yo ) >0
		  	   plots,[XR,XR],[yo,YR],linestyle=1,color=0,/device
		  	   if bu ne 4 then $
		  	   xyouts,XR,ydv,'_x='+strtrim(string(XV),2),charsize=1.2,/device,color=0 else $
		  	   xyouts,XR,ydv,'_y='+strtrim(string(YV),2),charsize=1.2,/device,color=0
			endelse
;**		     For an image
;**		     --- -- -----
		     endif else begin
		        if (uv(16) eq 0) then begin
					tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
					XG=tmXYZ(0) & YG=tmXYZ(1) & endif ;CURSOR,XG,YG ,/nowait,/data
		  	yo =uv(7)
		  	yb =uv(19)
		  	if uv(15) eq 0 then YI=Y else YI=uv(9)-Y
		  	if uv(15) eq 1 then begin i=yb & yb=yo & yo=i & endif
			YI =round (uv(12) + (uv(13)-uv(12)) * (float(YI-yo)/ (uv(9)-(yo+yb))) ) >0

			if (uv(16) eq 0) then begin  IDX=[XI] & IDY=[YI]
				if XS(0) eq 2 then ii=execute( 'IDX=where((x'+ws+' ge XG) and (y'+ws+' ge YG))')$
					      else ii=execute( 'IDX=where (x'+ws+' ge XG)' )
				if XS(0) ne 2 then ii=execute( 'IDY=where (y'+ws+' ge YG)' ) else IDY=IDX
				XI =IDX(0)>0
				YI =IDY(0)>0
			endif else if XS(0) eq 2 then begin XI=XI+ XI*YI & YI=XI & endif
			XV=XI & ii=execute( 'XV=x'+ws+'(XI)' )
			YV=YI & ii=execute( 'YV=y'+ws+'(YI)' )
			IV=0.
			if XS(0) eq 2   then ii=execute( 'IV =w'+ws +'(XI)' ) $
					else ii=execute( 'IV =w'+ws +'(XI,YI)' )
			tx1=' X='+strtrim(string(XV),2) & tx2=' Y=' +strtrim(string(YV),2)
							  tx3=' I=' +strtrim(string(IV),2)
			tx4=' in W'+ws+'('+strtrim(string(XI),2)+','+strtrim(string(YI),2)+')'

			;if trap_current ne uv(5) then begin tx1=' ' & tx2=' ' & tx3=' ' & endif
		     	if oki ne 0 then begin	wset,did_tio & erase,200
						xyouts,3,37, tx1,charsize=1.2,/device,color=50
					   	xyouts,3,20, tx2,charsize=1.2,/device,color=50 & did_o=0
					   	xyouts,3, 3, tx3,charsize=1.2,/device,color=50 & endif
			widget_control ,bad_id=i,uv(17),set_value=tx1+tx2+tx3+tx4
		     endelse ; End image and vector
		    endif    ; End X,Y >= 0
		  endelse    ; End cursor position
		 endif       ; End not type=1 (not release)
		endif else begin ;zoom_surf,event,uv, rx,rz,did_repr(4)
;Surface rotation
;****************
if n_elements(viex) eq 0 then  viex=0
if viex eq 0 then begin ok=0 & xxs=192 & yys=128
	bas=widget_base(map=0)
	pix=widget_draw(bas,xsize=xxs,ysize=yys,retain=2)
	widget_control, bas,/realize
	widget_control, pix, get_value=viex
	wt=dist(19)  &  wt(9,9)=wt(9,9)*2
	endif
wset,uv(5)
case event.type of
0:begin ;	button pressed
		but=event.press
		if but eq 1 then begin ok=1 & redo=0
			Xo=x & Yo=y   ;cursor, Xo,Yo ,/nowait,/device
			ws='Sna'+strtrim(string(uv(3)),2)   & wsz  =0L
			ii=execute('wsz=size('+ws+')') & w_suf=0L
			if (wsz(0) eq 2) or (wsz(wsz(0)+1) eq 8) then ii=execute('w_suf='+ws) ;2D or struc
			endif
		if but eq 2 then ok=0
		if but eq 4 then begin ok=0
			tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
			XV=tmXYZ(0) & YV=tmXYZ(1) & ZV=tmXYZ(2) ;CURSOR,XV,YV ,/nowait,/data
			endif
  end
1:begin ;	button released
		ok=0
		if but eq 1 then if redo then begin
			rx=long(xn) & rz=long(zn)
			if did_repr(4) gt 0 then widget_control,bad_id=i,did_repr(4),$
						       set_value=strtrim(string(rz),2)
			uv =[-88,301,uv(2),uv(3)]
		endif
  end
2:if ok then begin ;motion
		Xc=x & yc=y ;cursor,Xc,Yc ,/nowait,/device
		if (Xc ge 0) and (Yc ge 0) then begin
		  xt= (xc-xo)/1.5
		  yt=-(yc-yo)/1.5
		  if (xt ne 0) or (yt ne 0) then begin redo=1
			zn= (rz+xt)-long((rz+xt)/360)*360
			xn= (rx+yt)-long((rx+yt)/360)*360
			wset,viex & trap_current=viex
			if (size(w_suf))(0) gt 0 then begin
			   if (size(w_suf))(0) eq 2 then $
			           shade_surf,w_suf,az=zn,ax=xn,xstyle=4,ystyle=4,zstyle=4,subtitle='X--->' $
			   else begin ;->3D
			     if thresh ne w_suf.thresh then begin
				shade_volume,w_suf.w,thresh,vvv,ppp
				if n_elements(vvv) gt 1 then $
				w_suf={w:w_suf.w,thresh:thresh,v:vvv,p:ppp}
			     endif
			     if n_elements(w_suf.p) gt 3 then begin sz=size(w_suf.w)
				   scale3, xrange=[0,sz(1)-1], yrange=[0,sz(2)-1], zrange=[0,sz(3)-1],ax=0.,az=0.
				   t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , zn  , 0. ]
				   t3d,                   rot=[ xn , 0.  , 0. ]
				   t3d, tr=[+.5,+.5,+.5]
				   set_shading,reject=0 & tvscl,polyshade(w_suf.v,w_suf.p,/t3d) & set_shading,reject=1

				   if sys_dep('VERSION') lt 4.0 then begin xtit='x' & ytit='y'
				   endif                        else begin xtit='scan' & ytit='x' & endelse

				   surface,w_suf.v,xrange=[0,sz(1)-1], yrange=[0,sz(2)-1], zrange=[0,sz(3)-1],$
					   az=zn,ax=xn,xticks=1,yticks=1,zticks=1,/nodata,/noerase,xtitle=xtit,ytitle=ytit,$
					   title='rx:'+strtrim(round(xn),2)+' rz:'+strtrim(round(zn),2)
			     endif
			   endelse
			endif else shade_surf,wt   ,az=zn,ax=xn,xstyle=4,ystyle=4,zstyle=4,subtitle='X--->'
			wset,uv(5)
			DEVICE,copy=[0,0,xxs,yys,xo<(uv(8)-xxs),yo<(uv(9)-yys),viex]
		  endif
		endif
  endif
else:
endcase
		endelse
	endif
return
end
;*************************************** Process Events **********************************
;*************************************** Process Events **********************************
;*************************************** Process Events **********************************
pro P_DID_EVENT	,event,uv
;** ***********
;**
;** Event parser.
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff
    common c_drow

    if uv(1) eq 390 then did_zoom ,event,uv

;** Are there enought LUN left !!!!
;** -------------------------------
    fee=0 & catch,stat
    if stat ne 0  then fee=128 else begin get_lun,fee & free_lun,fee & endelse
    catch,/cancel & if fee ge 120 then for i=1,120 do   free_lun,i
    i=0
    on_ioerror,mis
    on_error  ,1
    ab=1

    if uv(0) eq -87 then begin
;**	Scan event
;**	---- -----
	if uv(1) eq 21 then begin
		windn=-1
		sl_lampscan, 'w_to_wind' , uv(2) , windn
		if windn ge 0 then begin
		   uv(1)=305
		   wintb(0)=-1
		   index=where(wintb eq windn , i )
		   if i ge 1 then scanum='w'+strtrim(string(index(0)),2) else begin scanum='w0'
		   							 w0=[0,0]
		   							 wintb(0)=  windn
		   							 wtb(0)=1 & endelse
		   endif
	endif else uv(1)=0

    endif

    caze=uv(1)
    if caze  eq 305 then caze=301
    if caze  eq 306 then caze=301
    if caze  eq 308 then begin ;**Tlb_size_events
		 widget_control,bad_id=ii ,event.id ,tlb_get_size=v2
		 if (abs(uv(7)-v2(0)) gt 50) or (abs(uv(8)-v2(1)) gt 50) then begin
		 				 caze=301
						 uv=[-88,301,uv(2),uv(13)]  & endif
    endif


    case caze of

	300:begin ;**	Disactivate scan
		sl_lampscan, 'send_event',-88
		p_did_setwin0
		set_xy
		!p.font = 0
	    end

;**	Display a workspace
;**	------- - ---------
	301:begin
		ab=0 & i=0
		wnumber='W'
		if (uv(1) eq 301) or (uv(1) eq 306)  then $
			if uv(3) eq -1 then widget_control,bad_id=i,did_wsc ,get_value=wnumber else $
			if uv(3) eq  0 then widget_control,bad_id=i,event.id,get_value=wnumber $
				       else wnumber='W'+strtrim(string(uv(3)),2)
		if uv(1) eq 305 then 	    wnumber=scanum
		if i eq 0 then wnumber=strupcase(strtrim(wnumber(0),2))
		i =strpos(wnumber,'W')
		wnumber=strtrim(strmid(wnumber,i+1,4),2)
		wi=fix(wnumber)
		if (wi ge 0) and (wi le lamp_sys) then begin
		    s =[0L,0L]
		    bb=execute( 's=size(w' + wnumber + ')' ) ;+newtypes*****
		    if  bb eq 1 then if (s(0) ge 1) and (s(0) le 3) and $
			                 ((s(s(0)+1) le 6) or (s(s(0)+1) ge 12) or (s(s(0)+1) eq 9)) then begin
			ab=1
			turn=0
			fu_out  =did_fu
			if (uv(1) eq 301) and (uv(2) eq  0 ) then p_did_makeSnap,wi
			if (uv(1) eq 305)  or (uv(1) eq 306) then fu_out=2 $
				      else if  uv(2) ne 0 then begin fu_out=1 & turn=uv(2) & endif
			if fu_out eq 2  then begin
			 if (lamp_act eq 0) then begin
			  if (did_scan eq -1) then begin SL_SCANLOAD,did_scan,lamp_dir
			                                 if (did_scan ge 0) then loadct,tcol & endif
			  if (did_scan ge  0) then begin
;			   call scan
;			   ---- ----
			   lamp_act=1
			   data='w' + wnumber
			   flg='scan'
			   pp2=wintb(wi)
			   pp3=wtb  (wi)
			   pp4=0
			   while pp4 ge 0 do begin
			     pp4=-1
			     sl_lampscan, 'set_size', 0,0,0, lamp_b1 ,wi

			     stat=0 & i=1
      			     catch,stat
      			     if (stat eq 0) and (i eq 1) then begin
      			         pp5=[w_tit(wi),x_tit(wi),y_tit(wi),z_tit(wi),other_tit(wi)]

			      if s(s(0)+1) le 6 then $ ;+newtypes*******
				 i =execute( 'sl_lampscan, flg ,'      +data+ ',pp2,pp3,pp4,pp5 ' ) else $
				 i =execute( 'sl_lampscan, flg ,float('+data+'),pp2,pp3,pp4,pp5 ' )

		    		 bb=execute( 's=size('+data+')' )
		    		 if s(0) eq 2 then if s(2) eq 1 then bb=execute(data+'=total('+data+',2)')
				 w_tit(wi)=strtrim(pp5(0),2) & x_tit(wi)=strtrim(pp5(1),2)
				 y_tit(wi)=strtrim(pp5(2),2) & z_tit(wi)=strtrim(pp5(3),2)
				 other_tit(wi)=strtrim(pp5(4),2)
			     endif
      			     if  i  ne 1 or stat ne 0 then begin
      			             catch,/cancel
			   	     if pp2 ge 0 then sl_lampscan,'purge',pp2
      			             pp2= -1
      			             pp4= -1
      		     		     print,string(7b),!err_string
			     endif
			     if wi gt 0 then begin
			        to_don_history, wi , -1 , ''
			        wintb(wi)=pp2
			        wtb  (wi)=1
			     endif
			     if pp4 ge 0 then begin
			   		pp2=pp4 & pp3=1 & wi=0 & w0='[0,0]' & data='w0'
			   		index=where(wintb eq pp2 , i )
			   		if i ge 1 then begin wi=index(0)
			   				     pp3=wtb(wi)
							     data='w'+ strtrim(string(wi),2)
							     endif
			     endif
			   endwhile
			   !p.font = 0
			   set_xy
			   p_did_setwin0
			 endif &   endif
			endif else begin
;			   call below or beside views
;			   ---- ----- -- ------ -----
				string_w=wnumber
				vff(2)=0
				p_did_drawidl,turn, string_w, s
				if did_repr(0) eq 1 then txt=' ,/image'    else $
				if did_repr(1) eq 1 then txt=' ,/contour'  else $
				if did_repr(2) eq 1 then txt=' ,/surface'  else txt=' '
				if did_fu      eq 0 then txt=txt+',/below' else txt=txt+',/beside'
				to_don_history,-1,0,'SEE ,w='+string_w    +txt
			endelse
			lamp_act=0
		    endif else if did_fu eq 0 then logo,1
		endif
	    end
;**	Below button
;**	----- ------
	302:begin
		did_fu =0
		p_did_setwin0
	    end
;**	Beside button
;**	------ ------
	303:begin
		did_fu = event.select
		p_did_setwin0
	    end

;**	Need tea or coffee!
;**	------------------
	304:begin l_mess=l_message
		pth=sys_dep('NEWSUB',lamp_dir,'lamp_mac')
		if b_labins(6) then if b_labins(7) gt 0 then l_mess=b_labins(7)
		if uv(2) eq  2  then wi=lamp_sys+1 else wi=0
		if uv(2) eq  2  then READ_LAMP,'teapot.hdf',w=wi, path=pth
		txt='liv_objet,wdraw=did_we,dim=[did_x,did_y],menubas=did_4dM,alter=did_wb,l_mess=l_mess,mytem=uv(2),wi=wi'
		if uv(2) eq  2  then WIDGET_CONTROL,event.id,set_value='Need Coffee!',set_uvalue=[-88,304,5,0]
		if uv(2) eq  5  then begin
		  t = findfile (pth + 'teapot.hdf',count =exist)
		  if exist gt 0 then WIDGET_CONTROL,event.id,set_value='Have Tea!'   ,set_uvalue=[-88,304,2,0]
		endif
		ii =EXECUTE(txt)
	    end

;**	Menu-bar
;**	---- ---
	307:case uv(2) of
		11: CALIBRATION
		12: begin SAVESESSION & p_did_event,0,[-88,398,0]    & end
		61: begin widget_control,bad_id=ii,lamp_b1    ,scr_xsize=uv(5)
		          widget_control,bad_id=ii,lamp_ben(0),map=1
			  widget_control,bad_id=ii,lamp_b1    ,scr_ysize=uv(6)
			  widget_control,bad_id=ii,lamp_don(0),map=1
			  widget_control,bad_id=ii,uv(7)      ,sensitive=0
			  widget_control,bad_id=ii,uv(8)      ,sensitive=1
			  b_labins(6)=0
			  end
		62: begin widget_control,bad_id=ii,lamp_don(0),map=0
			  widget_control,bad_id=ii,lamp_b1    ,scr_ysize=uv(4)
		          widget_control,bad_id=ii,lamp_ben(0),map=0
			  widget_control,bad_id=ii,lamp_b1    ,scr_xsize=uv(3)
			  widget_control,bad_id=ii,uv(7)      ,sensitive=1
			  widget_control,bad_id=ii,uv(8)      ,sensitive=0
			  b_labins(6)=1
			  end
		else:
	    endcase

;**	Decrement Wsc
;**	--------- ---
	310:	begin
		 widget_control,bad_id=i,uv(2),get_value=wnumber & wnumber=wnumber(0)
		 i =strpos(wnumber,'W')
		 if i gt 0 then wf=strmid(wnumber,0,i) else wf=''
		 wn=strtrim(strmid(wnumber,i+1,4),2)
		 wi=fix(wn)-1
		 maxwi=20
		 if (wi lt  1) then wi=lamp_sys<maxwi
		 if (wi gt lamp_sys<maxwi) then wi=1
		 wnumber=strtrim(string(wi),2)
		 wn=wf+'W'+wnumber
		 if wi le 9 then wn=wn+' '
;		 if uv(3) eq 1 then wn='Plot '+wn
;		 if uv(3) eq 2 then wn='LOAD '+wn
;		 if uv(3) eq 3 then wn='SCAN '+wn
		 widget_control,bad_id=i,uv(2),set_value=wn
		 p_did_makeSnap,wi
		 if b_labins(6) then if b_labins(7) gt 0 then widget_control,bad_id=iii,b_labins(7),set_value=HIS(wi)
 		end
;**	Increment Wsc
;**	--------- ---
	311:	begin
		 widget_control,bad_id=i,uv(2),get_value=wnumber & wnumber=wnumber(0)
		 i =strpos(wnumber,'W')
		 if i gt 0 then wf=strmid(wnumber,0,i) else wf=''
		 wn=strtrim(strmid(wnumber,i+1,4),2)
		 wi=fix(wn)+1
		 maxwi=20
		 if (wi lt  1) then wi=lamp_sys<maxwi
		 if (wi gt lamp_sys<maxwi) then wi=1
		 wnumber=strtrim(string(wi),2)
		 wn=wf+'W'+wnumber
		 if wi le 9 then wn=wn+' '
		 widget_control,bad_id=i,uv(2),set_value=wn
		 p_did_makeSnap,wi
		 if b_labins(6) then if b_labins(7) gt 0 then widget_control,bad_id=iii,b_labins(7),set_value=HIS(wi)
		end
;**	Button  Raw
;**	------  ---
	312:	begin	monimon=-(event.select)
			if event.select then txt='/raw' else txt='/noraw'
			to_don_history,-1,0,'RDSET,'+txt
		end

;**	Button  More...
;**	------  -------
	319:	begin
		if uv(4) gt 0 then P_DID_CREATE_MORE, uv(2),uv(3),uv(4) $
		else widget_control,bad_id=i,uv(3) ,map=1
		widget_control,bad_id=i,uv(2) ,set_value='Regular Grid',set_uvalue=0
		widget_control,bad_id=i,uv(2) ,set_button=0,set_uvalue=[-88,324,0]
		end

;**	Button  Image
;**	------  -----
	320:	did_repr(0) =event.select
;**	Button  Contour
;**	------  -------
	321:	did_repr(1) =event.select
;**	Button  Surface
;**	------  -------
	322:	did_repr(2) =event.select

;**	Button  Log aspect
;**	------  ----------
	323:	did_repr(5) =event.select
;**	Button  Use Xi,Yi
;**	------  --- -----
	324:	did_repr(6) =event.select
;**	Button  X Stretch
;**	------  - -------
	325:	did_repr(7) =event.select
;**	Button  Y Stretch
;**	------  - -------
	329:	did_repr(8) =event.select

;**	Button  S Stretch
;**	------  - -------
	318:	did_repr(17)=event.select

;**	Button  Turn -angle
;**	------  -----------
	326:	p_did_drawidl, -1, 0,0
;**	Button  Turn +angle
;**	------  -----------
	327:	p_did_drawidl,  1, 0,0

;**	Button  Maxi value
;**	------  ---- -----
	328:	begin
		did_repr(9)=event.select
		if did_repr(9) eq 1 then did_repr(9)=uv(2)
		end

;**	Scale text imply set button
;**	----- ---- ----- --- ------
	330:	begin
		if did_repr(uv(3)) eq 0 then if event.type lt 3 then begin
			widget_control,bad_id=i,uv(2),set_button=1
			did_repr(uv(3))=uv(4)
		endif
		end


;**	Touch Base
;**	**********
	331:	begin p_set_font,1 & lamp_siz=lamp_siz<800
		      TOUCH_B   ,1 ,inst_value
		      p_set_font,0
		end
;**	Touch_base get catalog
;**	---------- --- -------
	332:	touch_list, event,uv
;**	Touch_base select experiment
;**	---------- ------ ----------
	333:	touch_exper,uv,event.index
;**	Touch_base select run
;**	---------- ------ ---
	334:	touch_run,  uv,event.value ,event.drag
;**	Touch_base representation
;**	---------- --------------
	335:	touch_mode, uv
;**	Touch_base done
;**	---------- ----
	336:	touch_done, event ,uv
;**	Touch_base done
;**	---------- ----
	337:	touch_restore, uv
;**	Touch_base color , draw_event ...
;**	---------- -----   ----------
	338:	touch_more, uv,event

;**	didline
;**	-------
	340:	pho_event, event ,uv
;**	inx
;**	---
	341:	inx_event, event ,uv

;**	342:    Do not use
;**	343:    Do not use

;**	Background
;**	----------
	344:    begin if event.select eq 1 then begin tvlct,255,255,255,0  & tvlct,0,0,0,255
	              endif		   else begin tvlct,0,0,0,0        & tvlct,255,255,255,255 & endelse
		end

;**	Print format
;**	------------
	345:    widget_control,bad_id=i,uv(3),set_uvalue=uv(2)

;**	Annotate
;**	--------
	346:	begin keepfont=!p.font & !p.font=-1 & if !D.name ne 'Z' then wset,uv(2)
		      ANNOTATE,COLOR_INDICES=shift(indgen(10)*22,5)
		     ;trap_current=uv(2)
		      that=lamp_don(0) & if b_labins(8) gt 0 then that=[that,b_labins(8)]
		      widget_control,bad_id=i,that,/clear_events
		      !p.font=keepfont & end

;**	Load colors
;**	---- ------
	347:	begin
		i=xregistered('xloadct')
		if i lt 1 then xloadct,group=lamp_b1,/use_current
		end

;**	Remove_event
;**	------------
	349:	begin wait,.3 & widget_control,bad_id=i,uv(2),/destroy & end

;**	Print_event
;**	-----------
	350:begin l_mess=l_message
		if b_labins(6) then if b_labins(7) gt 0 then l_mess=b_labins(7)

		keep_w  =!D.window
		keep_d  =!D.name
		keep_o  =!order
		keep_u  =did_fu
		modop   =1
		err	=1
		if (uv(3) eq 0) and (uv(4) gt 0) then begin
		           widx=uv(4) & wnumber=strtrim(string(widx),2) & modop=uv(6)>1
		           if modop eq 1 then out_file='lamp_w' +wnumber + '_cp.ps' $
		                         else out_file='lamp_w' +wnumber + '_cp.gif'
		endif else begin   p_did_getw_cur, widx, wnumber
		           l='_' & if did_repr(0) eq 1 then l=l+'i'
		                   if did_repr(1) eq 1 then l=l+'c'
		                   if did_repr(2) eq 1 then l=l+'s'
		           out_file='lamp_w' +wnumber +l+ '.ps'
			   ;Next line in comment means print screen
			   ;***************************************
			   if uv(3) ge 0 then begin modop=3  & w_numor(0)=out_file  & endif
			   if uv(3) le 0 then begin did_fu=0 & uv(6)=0 & uv(4)=widx & endif
			   endelse
		if !D.name ne 'Z' then $
		if uv(2)  gt 0 then wset,uv(2) else p_did_setwin0
		if uv(3)  gt 0 then begin widget_control,bad_id=i,uv(3),get_value= out_file
					  out_file=strtrim(out_file(0),2)
					  id      =strpos (out_file,'_h.')
					  if id lt 0 then id=strpos (out_file,'.')
					  if id gt 0 then  out_file=strmid (out_file,0,id)
					  widx    =uv(4)
					  if sys_dep('VERSION') ge 5.4 then kif='.png' else kif='.gif'
					  widget_control,bad_id=i,uv(7),get_uvalue=modop
					  if modop eq 1 then out_file = out_file+'_h.ps'
					  if modop eq 2 then out_file = out_file+  kif
					  if modop eq 3 then out_file = out_file+'.ps'
					  w_numor(0) =  out_file
					  did_fu=1
					  widget_control,bad_id=i,uv(3),set_value= out_file
				    endif
		if  (modop ne 3) and (uv(2) lt 0) then begin ;An object for GIF or Screen copy
		  if modop eq 2 then ps='GIF' else ps='SCREEN'
		  txt='liv_objet,WDRAW=-uv(2),PS=ps'
		  ii=EXECUTE(txt)
		endif else if modop ne 3 then begin
		  !order=0 & r=0
		  w0=tvrdd(r,g,b)
		  s =size(w0)
		  on_ioerror,misps_open

		  if modop eq 2 then begin if n_elements(r) le 1 then tvlct,r,g,b,/get
		  	WRITE_KIF,out_file,w0,r,g,b & err=0
			if l_mess gt 0 then widget_control,bad_id=i,l_mess  ,set_value= out_file+' updated ...'
		  endif
		  if modop eq 1 then begin

		    tvlct, cur_r, cur_g, cur_b, /get
		    if n_elements(r) le 1 then begin r=cur_r & g=cur_g & b=cur_b & endif
		    set_plot,'PS'
		    device,filename=out_file,bits_per_pixel=8,/color

		    pos_r=bytarr(256) & pos_g=bytarr(256) & pos_b=bytarr(256)
		    pos_r(0)=r    & pos_g(0)=g    & pos_b(0)=b
		    tvlct ,  pos_r    ,          pos_g    ,          pos_b
		    covec=indgen(n_elements(cur_r))

			 sx  =7.21 & sy=10.6 & bpi=300. & pi=90 & fx=1. & fy=1.
			 bord=0.5
			 lup =0.3
			 if s(1) le s(2) then begin
			    ix=float(s(1))/pi & iy=float(s(2))/pi
			 endif else begin
			    ix=float(s(2))/pi & iy=float(s(1))/pi & endelse
			 if ix gt sx then fx=sx/ix & if iy gt sy then fy=sy/iy
			 if fy lt fx then fx=fy    & ix=ix*fx  & iy=iy*fx

		    on_ioerror,misps_write

		    xo  =(sx-ix)/2 & yo=(sy-iy)/2

		    if s(1)  le s(2) then begin
			 if yo lt bord then yo=bord & if yo lt 0.8 then lup=0.1
			 if xo lt bord then xo=bord
			 device,/portrait       ,/inches,xoffset=xo       ,yoffset=yo
			 tv,w0      ,0    ,0        ,xsize=ix,ysize=iy    ,/inches
			 tvlct, cur_r, cur_g, cur_b
			 if uv(5) gt 1 then $
			 tv,covec   ,ix-1.,iy+lup   ,xsize=1.,ysize=0.25  ,/inches
			 p_did_ps_header, iy+lup , widx ,out_file
		    endif else begin
			 if xo lt bord then xo=bord & if xo lt 0.8 then lup=0.1
			 device,/landscape      ,/inches,xoffset=xo       ,yoffset=sy-yo
			 tv,w0      ,0    ,0        ,xsize=iy,ysize=ix    ,/inches
			 tvlct, cur_r, cur_g, cur_b
			 if uv(5) gt 1 then $
			 tv,covec   ,iy-1.,ix+lup   ,xsize=1.,ysize=0.25  ,/inches
			 p_did_ps_header, ix+lup , widx ,out_file
		    endelse
		    if l_mess gt 0 then widget_control,bad_id=i,l_mess  ,set_value= out_file+' updated ...'
		    err=0
		    misps_write: if err eq 1 then device,/close_file
		    set_plot,keep_d
		    tvlct ,  cur_r    ,          cur_g    ,          cur_b
		  endif

		  misps_open:   set_plot,keep_d
		  !order  =keep_o
		  if keep_w ge 0  then if !D.name ne 'Z' then wset,keep_w
		  if err    eq 1  then begin
				widget_control,bad_id=i,l_mess  ,set_value='Print write error !!!'
				P_MUS,'mus_cannon' & endif
		endif else begin
		;** POSTSCRIPT REPLOT
		  if uv(8) eq 0 then uv(8)=did_wd
		  widget_control,bad_id=ii,uv(8),get_uvalue=lov
		  if ii eq 0 then begin
		  ;** RESTORE ZOOM... LIMITS
			;lov: [-88,390, b_cur, fix(string_w), d_cur, w_cur, xo, yo,$
			;	bst_x, bst_y, vfl(0), vfl(1),vfl(2),vfl(3), isurf ,$
			;	w_order, axy, baslb, xof, yof, did_repr(5)]
		  	if n_elements(lov) gt 13 then vfl(0:3)=lov(10:13)
		  endif
		  styles(3,0)=1
		  p_did_event,0,[-88,301,uv(6),uv(4)]
		endelse
		did_fu=keep_u
	    end

;**	Multi_plot create
;**	---------- ------
	352:begin
		p_did_getw_cur, widx, wnumber
		suprplot, widx
	    end
;**	Multi_plot event (353:slider_w_x_y 354:slider_range 355:keep etc. 356:buttons)
;**	---------- -----
	353:	p_rom_super_event, event,uv
	354:	p_rom_super_event, event,uv
	355:	p_rom_super_event, event,uv
	356:	p_rom_super_event, event,uv

;**	TRIPX
;**	-----
	357:	ii=execute('tripx_event, event,uv')
	358:	ii=execute('tripx')

;**	TOMOGRAPHY
;**	----------
	359:    tomo_event_parser, event,uv

;**	Begood button
;**	------ ------
	360:begin p_did_getw_cur, widx, wnumber
		  p_set_font,1
		  p_did_create_begood, widx ,rx ,nlv ,smoo ,styles ,did_repr
		  p_set_font,0
		 ;widget_control,bad_id=i,event.id,set_button=0
	    end
;**	Begood updat
;**	------ -----
	361:	p_did_begood_updat
;**	Begood updat
;**	------ -----
	362:	p_did_begood_slide,event
;**	Begood done
;**	------ ----
	363:	p_did_begood_done, rx ,nlv
;**	Begood device for PS
;**	------ ------ --- --
	364:	p_did_begood_devps
;**	Begood view angle
;**	------ ---- -----
	365:	if uv(2) eq 0 then p_did_begood_ax, rx else p_did_begood_nlv, nlv
;**	Begood Surface style
;**	------ ------- -----
	366:	if uv(2) le 6 then styles(0,0)=uv(2) $
		else begin
		     if uv(2) eq 7 then if   event.select eq 1 then !P.psym=10 else !P.psym=0
		     if uv(2) eq 8 then smoo=event.select
		     if uv(2) eq 9 then did_repr(14)=event.select
		endelse
;**	Begood Contour style
;**	------ ------- -----
	367:	styles(1,0)=uv(2)
;**	Begood Scan preference
;**	------ ---- ----------
	368:	styles(uv(2),1)=event.select
;**	Begood Projection style
;**	------ ---------- -----
	369:	if event.select eq 1 then styles(2,0)=uv(2) else styles(2,0)=1

;**	Save workspace
;**	---- ---------
	370:begin
		p_did_getw_cur, widx, wnumber
		p_did_save_menu,widx
	    end
	371:p_did_save_list,event
	372:p_did_save_format,uv(2)
	373:p_did_save_filename,event
	374:p_did_save_work,event,uv ,0

;**	Diag UI.
;**	---- --
	378:wdiag_event, event,uv

;**	Phil filter UI.
;**	---- ------ --
	379:P_FIL_EVENT ,event,uv

;**	Restore workspace create widget
;**	------- --------- ------ ------
	380:P_ICK_INIT,0
;**	Restore workspace change path
;**	------- --------- ------ ----
	381:P_ICK_PTH,uv
;**	Restore workspace select
;**	------- --------- ------
	382:P_ICK_LST,event,uv
;**	Restore done button
;**	------- ---- ------
	384:	widget_control,bad_id=i,event.top,map=0
;**	Restore workspace remove
;**	------- --------- ------
	385:P_ICK_DEL ,uv
;**	Restore workspace change format
;**	------- --------- ------ ------
	386:P_ICK_FRM ,event,uv
;**	Restore XY change format
;**	------- --------- ------
	387:P_ICK_XY  ,event,uv
;**	Restore workspace read
;**	------- --------- ----
	383:begin P_ICK_GET,pth,fname,frm ,info ,uv
	      if fname ne '' then begin NXed=''
		     widget_control,bad_id=i,uv(8)   ,get_uvalue=NXed
		     widget_control,bad_id=i,uv(4)   ,get_value =iw
		     lamp_wrd='W'+strtrim(string(iw),2)
		     p_did_before_read, wnumber,uv(3)
		     pp2=-1 & hyst=''
		     comhis=''
;		Workspaces
		     if frm eq '_LAMP'  then begin
			comhis='READ_LAMP,"'+pth+fname+'",w='+wnumber
		        p_did_restore_wrk, fname,pth,wnumber,hyst,pp2
		     endif
;		NeXus
		     if (frm eq '.hdf') or (frm eq '.xml') then begin
			comhis='READ_LAMP,"'+pth+fname+NXed+'",w='+wnumber
		        p_did_res_hdf    , fname+NXed,pth,wnumber,hyst,pp2
		     endif
;		XY ascii
		     if frm eq '*.*'  then begin
			comhis='READ_LXY,"'+pth+fname+'",w='+wnumber
		        read_lxy, pth+fname,w=wnumber,status=pp2
		     endif
;		.gel
		     if frm eq '.gel'   then begin
			flg='.gel'
			comhis='sl_lampscan,"'+flg+'",w'+wnumber+'-1,0,0,"'+pth+fname+'"'
			i =execute( 'sl_lampscan, flg ,w' + wnumber + ',pp2,0,0, pth+fname' )
		     endif
;		.image
		     if frm eq '.image' then begin
			flg='.image'
			comhis='sl_lampscan,"'+flg+'",w'+wnumber+'-1,0,0,"'+pth+fname+'"'
			i =execute( 'sl_lampscan, flg ,w' + wnumber + ',pp2,0,0, pth+fname' )
		     endif
;		.SCAN
		     if frm eq '.WIND'  then begin
			flg='restore'
			comhis='sl_lampscan,"'+flg+'",w'+wnumber+'-1,0,0,"'+pth+fname+'"'
			i =execute( 'sl_lampscan, flg ,w' + wnumber + ',pp2,0,0, pth+fname' )
		     endif
;		.PICT
		     if frm eq '.PICT'  then begin
			colr=0 & colg=0 & colb=0
			comhis='READ_PICT,'+pth+fname+',w'+wnumber+'r,g,b'
			i =execute( 'READ_PICT, pth+fname, w' + wnumber + ', colr,colg,colb')
			tvlct,colr,colg,colb
		     endif
;		DIAL
		     if frm eq 'dial_*.pro*' then begin
			dname=strmid(fname,5,strpos(fname,'.')-5)
			comhis='DialInit, "'+dname+'", d='+wnumber+', path="'+pth+'"'
			i =execute( comhis )
			if i then pp2=0
		     endif
;		Others
		     if (frm eq '*') or (frm eq '.*')  then $
			    P_ICK_SCAN     , pp2,frm,wnumber,uv,hyst,fname ,pth $

		     else   p_did_just_read, pp2,frm,wnumber,uv,hyst,fname ,info ,comhis
	      endif
	    end

;**	LOGO event
;**	**********
	391:	  p_did_mvlog,  event,uv

;**	Calibration
;**	***********
	394:	  p_did_calev,  event,uv

;**	Journal
;**	*******
	395:	  p_did_journal_print,uv
	396:begin p_set_font,1
		  p_did_journal,event,uv
		  p_set_font,0 & end
;**	Save all
;**	********
	397:p_did_save_session

;**	Exit
;**	****
	398:begin
;	    DON_WRITE_PROG_MAC ,0
	    if lamp_b1 gt 0 then begin
	       if sys_dep ('MAP') gt 1 then if lamp_siz gt 1000 then begin
		  widget_control,bad_id=i,lamp_don(0),/destroy
		  widget_control,bad_id=i,lamp_ben(0),/destroy
		  widget_control,bad_id=i,lamp_ben(9),/destroy
		  LOGO,1 & endif
	       P_MUS,'mus_cannon'                       & l_message=0
	       if (george gt 0) then WebOff
	       widget_control,bad_id=i,lamp_b1,/destroy & lamp_b1  =0

;**	       In case P_DYING did'nt destroyed all the group at time.
	       rout=[1L]
	       if  sys_dep('VERSION') ge 5.1 then ii=execute('rout=widget_info(/managed)')
	       if  rout(0)  gt 0 then exok=0 else exok=1
	       if (exok) then EXIT
;	       widget_control,/reset
	    endif else exit
	    end

;**	Destroy
;**	*******
	399:begin wait,.3 & widget_control,bad_id=i,event.top,/destroy & end

	else:
	endcase

mis:
;if ab eq 0 then print,string(7b)

return
end

pro p_did_before_read, wnumber,laber
;** *****************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

		wnumber=lamp_wrd
		wnumber=strtrim(strmid(wnumber,1,2),2)
		did_curw=fix(wnumber)
		widget_control,bad_id=i,laber, set_value='Reading in '+'# '+wnumber
return
end
pro p_did_just_read, pp2,frm,wnumber,uv,hyst,fname ,info ,comhis
;** ***************
@lamp.cbk
 common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    		did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

	if pp2 ge 0 then  begin
		            if frm eq '_LAMP'  then wintb(did_curw)=-1 else wintb(did_curw)=pp2
		            if frm eq '.hdf'   then wintb(did_curw)=-1 else wintb(did_curw)=pp2
		            if frm eq '.xml'   then wintb(did_curw)=-1 else wintb(did_curw)=pp2
	                    if frm ne 'dial_*.pro*' then $
	                    if frm ne '*.*'         then $
			           ii=execute('P_ICK_MICO, wnumber,x'+wnumber+',y'+wnumber+',uv,pp2') $
	                    else   ii=execute('P_ICK_MICO, wnumber,x'+wnumber+',y'+wnumber+',uv,-10')
	endif

	if hyst ne '' then hyst=fname+' <-- '+hyst else hyst=fname
	p_did_after_read,  wnumber,uv(3), hyst ,pp2 ,comhis

	if (pp2 ge 0) and (frm ne '_LAMP') and (frm ne '.hdf') and (frm ne '*.*') $
			  and (frm ne 'dial_*.pro*') and (frm ne '.xml') then begin siz=0L
			i=execute('siz=size(w'+wnumber+')')
			siz1=siz(1) & if siz(0) gt 1 then siz2=siz(2) else siz2=1
			fixw=fix(wnumber)
			clearpar,fixw,wnumber
			x_tit    (fixw)=' X,Y -> '+strtrim(string(siz1),2)+','   + $
						   strtrim(string(siz2),2)
			z_tit    (fixw)=' Min='+strtrim(string(w_min(fixw)),2)+ $
					' Max='+strtrim(string(w_max(fixw)),2)
			other_tit(fixw)  =fname
			head_tit (fixw,2)=frm

		        if (frm eq '.gel')  or (frm eq '.image') or (frm eq '.WIND') or $
		           (frm eq '.PICT') or (frm eq '') then begin

			   other_tit(fixw) =other_tit(fixw) + x_tit(fixw) + z_tit(fixw)
			   n=n_elements(info)

			   if (frm eq '.gel')  then if n gt 1 then begin
			   	other_tit(fixw)=other_tit(fixw)+' created '+info(0)
			   	w_tit    (fixw)=info(1)
			   	endif
			   if (frm eq '.WIND') then if n ge 5 then begin
			   	tmp=strtrim(info(0),2) & if tmp ne '' then w_tit(fixw)=tmp
			   	tmp=strtrim(info(1),2) & if tmp ne '' then x_tit(fixw)=tmp
			   	tmp=strtrim(info(2),2) & if tmp ne '' then y_tit(fixw)=tmp
			   	tmp=strtrim(info(3),2) & if tmp ne '' then z_tit(fixw)=tmp
			   	tmp=strtrim(info(4),2) & if tmp ne '' then other_tit(fixw)=tmp
			   	endif
			endif
	endif
	if pp2 ge 0 then P_MUS,'mus_shot'
return
end
pro p_did_after_read, wnumber,laber,fname,pp2 ,comhis
;** ****************
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

		if pp2 ge 0 then begin
			   did_curw=fix(wnumber)
			   to_don_history, did_curw , 0 , comhis
			   if strpos(strupcase(comhis),'DIAL') ge 0 then tit='d' else tit='w'
			   widget_control,bad_id=i,laber, set_value=tit+wnumber+' loaded ...'

			   if wintb(did_curw) ge 0 then ii=execute("sl_lampscan,'purge',wintb(did_curw)")
			   wtb  (did_curw)=0
		endif else widget_control,bad_id=i,laber, set_value='No file restored !!!'
		print,string(7b)
return
end

pro write_ps
;** ********
    p_did_event,0,[-88,350,0,0,0,0,0,0,0]
end
pro p_did_ps_header, yo , widx ,out_file
;** ***************
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

		tvlct ,  cur_r,cur_g,cur_b ,/get
		loadct,1,ncolors=did_icon(0,0)+1,/silent
		keep_o  =!order
		!order  =0
		tv,did_icon,0    ,yo   ,xsize=1.,ysize=0.5   ,/inches
		tvlct ,  cur_r,cur_g,cur_b
		icl     =n_elements(cur_r)/2
;		icl     =2
		if widx gt 0 then begin titi=strmid(strtrim(w_tit(widx),2),0,55)
		   on_ioerror,misps
		   device,/helvetica,/bold
		   xyouts,0,-0.20*2540,   other_tit(widx),CHARSIZE =0.65,font=0,/device,color=icl
		   xyouts,1.5*2540 ,yo*2540  ,  titi     ,CHARSIZE =1.5 ,font=0,/device,color=icl
		   misps: print,string(7b)
		endif

		device,/close_file
		!order=keep_o

		txt=out_file+' created'
		if lamp_devps ne '' then begin
						kppw=!D.Name & if sys_dep('MACHINE') eq 'win' then set_plot,'WIN'
						dir=''
						;if strpos(out_file,lamp_dvd) lt 0 then begin
						;	cd,current=dir
						;	if strmid(dir,strlen(dir)-1,1) ne lamp_dvd then dir=dir+lamp_dvd
						;endif
						bid=sys_dep('PRINT',lamp_devps,dir+out_file)  &    set_plot,kppw
						txt=txt+' ,sent to '+lamp_devps
						endif
		if l_message gt 0 then widget_control,bad_id=ii,l_message  ,set_value=txt
		if b_labins(6)    then if b_labins(7) gt 0 then $
		                       widget_control,bad_id=ii,b_labins(7),set_value=txt
return
end

pro Launch, what
;***************
CASE strlowcase(what) of
"colors":	p_did_event,0,[0,347,0]
"scan":		p_did_event,0,[0,306,0,-1]
"superplot":	p_did_event,0,[0,352,0]
"gk_fit":	p_mac_event,0,[0,580,0]
"ben_int":	desk_event ,0,[0,401,0]
"ben_def":	desk_event ,0,[0,402,0]
"ben_rgp":	desk_event ,0,[0,403,0]
"wdiag":	desk_event ,0,[0,401,-1]
"tomo":		desk_event ,0,[0,401,-2]
"calib":	desk_event ,0,[0,307,0]
"inx":		desk_event ,0,[0,571,0]
"exit":		p_did_event,0,[0,398,0]
ELSE:
ENDCASE
end

pro SaveSession
    p_did_save_session & end
pro p_did_save_session
;** ******************
@lamp.cbk
@dons.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

	save,/variables,filename='lamp.ses'
	txt='Current Lamp Session is SAVED ....'
	if l_message gt 0 then begin  print,string(7b) & widget_control,bad_id=ii,l_message  ,set_value=txt
			  endif else  print,txt
	if b_labins(6)    then if b_labins(7) gt 0 then  widget_control,bad_id=ii,b_labins(7),set_value=txt
	P_MUS,'mus_shot'
	DID_WRITE_JOURNAL
return
end

pro did_set, text
;** *******
@lamp.cbk
@dons.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    i=execute(text)
return
end

pro p_did_setwin0, map=map
;** *************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

catch,stat & if stat ne 0 then begin catch,/cancel & print,!err_string
		did_wd  =widget_draw  (did_wb ,retain=2,xsize=did_x,ysize=did_y,$
					 /button_events,/motion_events)
		if GEORGE ne 1 then widget_control,did_wd,draw_motion_events=1 & return
             endif
if !D.name eq 'Z' then begin device,set_resolution=[did_x,did_y] & erase
endif else if did_wd gt 0 then begin widget_control,did_wd  ,get_value=did_win0
			             if keyword_set(map) then WIDGET_CONTROL,did_wb ,bad_id=ii,MAP=1
			             WSET,did_win0   &  endif
return
end

pro to_did_cur,	wkspce
;** **********
;**
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    if strlen(wkspce) le 2 then bb=' ' else bb=''
    if n_elements(did_wsc) eq 1 then widget_control,bad_id=i,did_wsc,$
    						    set_value='Plot '+strupcase(wkspce)+bb

return
end

pro DECOR, cti_,ctj_,a1_,a2_,DIS_,PIXV_,PIXH_,shap,squa,LVu_,LVd_,LHl_,LHr_,FQ_,PHI_,DXT_,DYT_,FCTX_,FCTY_
;** *****
;**
common depli,cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar

WDIAG, /nw

cti=cti_ & ctj=ctj_
if n_elements(a1_)   eq 1 then a1=a1_		else a1=0.
if n_elements(a2_)   eq 1 then a2=a2_		else a2=360.
if n_elements(DIS_)  eq 1 then DIS=DIS_		else DIS=100.
if n_elements(PIXV_) eq 1 then PIXV=PIXV_	else PIXV=150.
if n_elements(PIXH_) eq 1 then PIXH=PIXH_	else PIXH=150.
if n_elements(LVu_)  eq 1 then LVu=LVu_		else LVu=0
if n_elements(LVd_)  eq 1 then LVd=LVd_		else LVd=0
if n_elements(LHl_)  eq 1 then LHl=LHl_		else LHl=0
if n_elements(LHr_)  eq 1 then LHr=LHr_		else LHr=0
if n_elements(FG_)   eq 1 then FQ=FQ_		else FQ=4
if n_elements(PHI_)  eq 1 then PHI=PHI_		else PHI=0
if n_elements(DXT_)  eq 1 then DXT=DXT_		else DXT=0.
if n_elements(DYT_)  eq 1 then DYT=DYT_		else DYT=0.
if n_elements(FCTX_) eq 1 then FCTX=FCTX_	else FCTX=-1.
if n_elements(FCTY_) eq 1 then FCTY=FCTY_	else FCTY=-1.
if n_elements(shap)  eq 1 then shape=shap	else shape=0
if n_elements(squa)  eq 1 then squar=squa	else squar=0

; then DEPLI,  area, ry1,ry2 ,arel,diam,xdiam,b_red, AV,AH
end

;*************************************** Process Display *********************************
;*************************************** Process Display *********************************
;*************************************** Process Display *********************************

pro FORCPLOT ,wi, w=wj ,image=im,contour=co,surface=su,vrml=vr,below=bl,beside=bs,pscript=ps,gif=gf,png=pg,htm=hm
    SEE	     ,wi, w=wj ,image=im,contour=co,surface=su,vrml=vr,below=bl,beside=bs,pscript=ps,gif=gf,png=pg,htm=hm & end
pro SEE      ,wi, w=wj ,image=im,contour=co,surface=su,vrml=vr,below=bl,beside=bs,pscript=ps,gif=gf,png=pg,htm=hm $
                       ,xypixels=sp, screen=sc, replot=rp
;** ***
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

wk=0 & if n_elements(wi) eq 1 then wk=wi else if n_elements(wj)  eq 1     then wk=wj $
					 else if alone gt 0 then wk=alone else wk=one>1
if (wk gt 0) and (wk le lamp_sys+3) then begin
	ws=strtrim(string(wk),2) & s=0L
	bb=execute( 's=size(w' + ws + ')' )
	keep_repr=did_repr & did_repr(0:2)=0
	keep_fu  =did_fu
	keep_st  =styles
	if vff(2) eq 1 then begin
				if vff(3) eq 0 then did_repr(0)=1
				if vff(3) eq 1 then did_repr(1)=1
				if vff(3) eq 2 then did_repr(2)=1
				did_repr(5)= vff(10)
				did_repr(6)= vff(12)
				did_fu	   = vff(5)
				endif
	if keyword_set(vr)	then begin su=1 & bs=1 & endif
	if keyword_set(im)      then did_repr(0)    =im
	if keyword_set(co)      then did_repr(1)    =co
	if keyword_set(su)      then did_repr(2)    =su
	if keyword_set(vr)      then did_repr(2)    =1
	if keyword_set(vr)      then styles(0,1)    =1
	if keyword_set(ps)      then styles(3,0)    =1
	if keyword_set(ps)      then w_numor(0)     ="lamp.ps"
	if keyword_set(gf)      then styles(3,0)    =2
	if keyword_set(pg)      then styles(3,0)    =4
	if keyword_set(hm)      then styles(3,0)    =3
	if keyword_set(sc)      then styles(3,0)    =5
	if keyword_set(bl)      then did_fu	    =0
	if keyword_set(bs)      then did_fu	    =1
	if n_elements (sp) eq 2 then did_repr(18)   =sp
	if keyword_set(rp) and (n_elements(wbeside) gt 1) then turn=wbeside(0) else turn=0
	if (!D.name ne 'Z')     then $
	if (!D.flags and 65536) eq 0 then did_fu=0 else if ((b_labins(3) eq 1) and (!D.name eq "X")) then did_fu=1

;	if ((did_fu eq 0) and (GEORGE ne 0)) then DialWSet

	p_did_drawidl, turn, ws, s

	did_repr=keep_repr  &  styles  =keep_st  &  did_fu  =keep_fu
endif
return
end

pro FORCSET ,image=im,contour=co,surface=su,rot=rot,below=bl,beside=bs,xrange=xr,yrange=yr,$
				 log=lg,zlim=zl,regular=rg,vrml=vr,view=va
    SEEM    ,image=im,contour=co,surface=su,rot=rot,below=bl,beside=bs,xrange=xr,yrange=yr,$
				 log=lg,zlim=zl,regular=rg,vrml=vr,view=va		   & end
pro SEEM    ,image=im,contour=co,surface=su,rot=rot,below=bl,beside=bs,xrange=xr,yrange=yr,$
				 log=lg,zlim=zl,regular=rg,vrml=vr,view=va
;** ****
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

vff(2)=1 & vff(3)=-1
if keyword_set(vr)	 then begin   su=1 & bs=1 & endif
if keyword_set(im)       then vff(3)  =0
if keyword_set(co)       then vff(3)  =1
if keyword_set(su)       then vff(3)  =2
if n_elements (rot) eq 1 then vff(4)  =rot
if keyword_set(bl)       then vff(5)  =0
if keyword_set(bs)       then vff(5)  =1
if n_elements (xr)  eq 2 then vff(6:7)=xr
if n_elements (yr)  eq 2 then vff(8:9)=yr
if n_elements (lg)  eq 1 then vff(10) =lg
if n_elements (zl)  eq 1 then vff(11) =zl
if n_elements (rg)  eq 1 then vff(12) =rg
if n_elements (va)  eq 1 then vff(13) =va
return
end

pro FORCPAR, param
;** *******
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
h=10 & m=did_y/h
n=n_elements(param)<m -1

if n gt 0 then begin
   y=did_y-h
   k=!window
   p_did_setwin0 & erase
   for i=0,n do begin xyouts,1,y,param(i),/dev,charsize=1.2,font=0  &  y=y-h & endfor
   if k gt 0 then if !D.name ne 'Z' then wset,k
endif
end

pro DRAWIND  ,xsiz,ysiz , DrawId=basw
;** *******
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

if  l_message le 0 then return

if (n_elements(xsiz) ne 1) then xsiz=512
if (n_elements(ysiz) ne 1) then ysiz=512
if (xsiz gt 0) and (ysiz gt 0) and (xsiz le 4000) and (ysiz le 4000)  then begin
	keep_rep =did_repr & did_repr(2)=1 & did_repr(6)=0 & did_repr(7)=0
	keep_fu  =did_fu   & did_fu     =1
	w0	 =[[xsiz,xsiz],[ysiz,ysiz]]

	p_did_drawidl,	0, '0' , size(w0) , DrawId=basw

	did_repr =keep_rep
	did_fu   =keep_fu
endif
return
end

pro p_did_rep, r,spc
;** *********
;**
;		r=0 image
;		r=1 image   +  surface
;		r=2 image   +  contour
;		r=3 image   +  contour   +  surface
;		r=4 contour +  surface
;		r=5 contour
;		r=6 surface

    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
		spc=0
		r  =0
		if (did_repr(0) eq 1) and (did_repr(1) eq 1) and (did_repr(2) eq 1) then r=3 else $
		if (did_repr(0) eq 1) and (did_repr(1) eq 1) then r=2 else $
		if (did_repr(0) eq 1) and (did_repr(2) eq 1) then r=1 else $
		if (did_repr(1) eq 1) and (did_repr(2) eq 1) then r=4 else $
		if (did_repr(1) eq 1) then r=5			      else $
		if (did_repr(2) eq 1) then r=6
		if (r eq 5) then spc=-10
		if (r eq 6) then spc= 10
return
end

pro p_did_drawidl,	turn,  string_w	, isiz , DrawId=basw
;** *************
;**
;** turn= 0	new plot
;** turn= 1	replot +10 degres
;** turn=-1	replot -10 degres
;** turn> 2	replot beside
;** turn<-2	replot LiveTools

@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff
    common c_drow
    common c_drow2, bas_x,bas14
;**
    common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
;**
    common c_codens,	zz,mx1,mx2,my1,my2,mz1,mz2,mxv2,cdbox,idn,CODENS
    trap_ws='0'
    redraw = 0 & errps=0
    bobol  = 0
    new    = 1
    off60  = 60
    off90  = off60*3/2
    p_did_rep,rrr,spc

    keeprp1=did_repr(1)

    if (turn lt -2)     and (turn gt -10000) then liveT=1  else liveT=0
    if (turn lt -10000) and (turn gt -20000) then liveC=1  else liveC=0
    if (turn lt -20000) and (turn gt -30000) then liveA=1  else liveA=0
    if (turn lt -30000) and (turn gt -40000) then begin rrr  =7 &  did_repr(1)=1  & endif
    if (turn eq  0)     or  (turn gt 2)      then $
                        if  (sys_dep('VERSION') ge 5.0) and (b_labins(3) eq 0) then begin
                        if (rrr eq 3) and (isiz(0) eq 1) then liveT=10
                        if (rrr eq 4) and (isiz(0) eq 1) then liveT=10
                        if (rrr eq 4) and (isiz(0) eq 2) and (did_fu eq 1) then liveC=1
                        if (rrr eq 2) and (isiz(0) eq 3) then liveA=1
                       ;if (rrr eq 3) and (isiz(0) eq 3) then liveT=10
                        endif
    if (turn lt -2)     then turn=0
    if styles(3,0) eq 1 then begin ps_ok =1	& styles(3,0)=0 & endif else ps_ok =0
    if styles(3,0) eq 2 then begin gif_ok=1	& styles(3,0)=0 & endif else gif_ok=0
    if styles(3,0) eq 3 then begin htm_ok=1	& styles(3,0)=0 & endif else htm_ok=0
    if styles(3,0) eq 4 then begin gif_ok=1	& styles(3,0)=0 & png_ok=1 & endif else png_ok=0
    if styles(3,0) eq 5 then begin scr_ok=1	& styles(3,0)=0 & endif else scr_ok=0

    if (turn gt  2) then fu_out=1  else fu_out=did_fu
    if (did_repr(18) gt 50) and (did_repr(19) gt 50) then fu_out=1

    if (turn eq  0) and (string_w eq '0') then wonly =[w0(0,0),w0(1,1)]  else wonly=[0,0]
    if (turn eq  0) or  (turn gt 2) then  begin
	wnumber=string_w
        idn    =fix(wnumber)
	if wonly(0) eq 0 then w0 =0
	uxy=0 & axy=0
	siz=isiz
	if (siz(1) eq 1) or (siz(2) eq 1) then  begin
			bb=execute( 'w' + wnumber + '=reform(w' + wnumber + ')' )
			bb=execute( 'siz=size(w' + wnumber + ')' ) & endif
	bb=execute( 'if n_elements(x'+wnumber+') gt 1 then x' + wnumber + ' =reform(x' + wnumber + ')' )
	bb=execute( 'if n_elements(y'+wnumber+') gt 1 then y' + wnumber + ' =reform(y' + wnumber + ')' )
	bb=execute( 'if n_elements(z'+wnumber+') gt 1 then z' + wnumber + ' =reform(z' + wnumber + ')' )
    endif else  if (n_elements(flgsurf) gt 1) and ((did_repr(2) eq 1) or (siz(0) eq 3))  then $
    		if  flgsurf(2) eq  idn then redraw=1

;Density points?
;***************
        sizx =[0L]  & i=execute('sizx=size(x'    + wnumber + ')' ) & CODENS= 0
        sizy =[0L]  & i=execute('sizy=size(y'    + wnumber + ')' )
        sizz =[0L]  & i=execute('sizz=size(z'    + wnumber + ')' )
	if (siz (0)  le 2) and (sizx(0) eq 1) and (sizy(0) eq 1) and (sizz(0) eq 1)  then $
        if (siz (1)  eq sizx(1)) and (siz (1)  eq sizy(1)) and (siz (1)  eq sizz(1)) then $
	if (siz (0)  eq 1) or (siz (2) le 3) then CODENS=-1

    flgsurf=0
    isurf  =0
    if CODENS eq -1 then isurf=1
    if  siz(0) gt 1 then if (did_repr(2)) or ((siz(0) eq 3) and ((did_repr(0) eq 0) and (did_repr(1) eq 1))) then isurf=1

;Z angle !
    if isurf then begin
			if vff(2) eq 1 then rx=vff(13)
			if vff(2) eq 1 then rz=vff(4)  else begin
				srz='+30' & rz=20
				if  l_message gt 0 then $
			    	    widget_control,bad_id=i,did_repr(4),get_value=srz else srz=string(vff(4))
				 srz=strcompress(srz(0),/remove_all)
				 deg=strpos(srz,'^')
				 if deg gt 0 then srz=strmid(srz,0,deg)
				 on_ioerror,misrz
				 rz=fix(srz)
				 if (turn eq 1) or (turn eq -1) then begin
				    rz=rz+ turn*10
				    if rz ge  360 then rz=rz-360
				    if rz le -360 then rz=rz+360
				    srz=strtrim(string(rz),2)+'^'
				    if l_message gt 0 then widget_control,bad_id=i,did_repr(4),set_value=srz
				 endif
				 misrz:
			endelse
    endif
;***
    if (turn eq 0) or (turn gt 2) or (redraw eq 1) then begin
;***
       bst_x=did_x  & bst_y=did_y

;Density points? or object? or standard plot?
;*************** ** ******* ** **************
	IF  b_labins(3) eq 0  then begin
	 if CODENS ne 0       then begin
	    DID_OBJET,idn,monobj
	    if monobj gt 0 then begin CODENS=monobj & liveT=0 & redraw=0 & endif
	 endif
	 if fu_out eq 0 then if (CODENS gt 0)     then $
			WIDGET_CONTROL,did_wb ,bad_id=ii,MAP=0 $ ;Case we come back from liv_objet (below)
	    else begin	WIDGET_CONTROL,did_wb ,bad_id=ii,MAP=1 & WIDGET_CONTROL,did_wc,bad_id=ii,MAP=0
	                WIDGET_CONTROL,did_4dM,bad_id=ii,sensitive=0  & endelse
	ENDIF
;********
       use_scan=0
           if (siz(0) gt 1) and (styles(2,0) eq 3)  then use_scan=1
           if (siz(0) eq 3) and (styles(2,0) eq 4)  then use_scan=1
           if (siz(0) eq 3) and (did_repr(2)+did_repr(1) eq 0)  then use_scan=1
	   if (siz(0) eq 2) and (did_repr(6) eq 0)  then $
			if  did_surf(0)  eq 1 then begin
	   				 if (rrr eq 5) and (styles(1,1)  eq 1) then use_scan=1
	   				 if (rrr eq 6) and (styles(0,1)  eq 1) then $
						    if sys_dep('VIEWER') eq 0  then use_scan=0 ;or = 1 !!!
			endif
       if (use_scan ne  0) then if (did_scan eq -1) then begin SL_SCANLOAD,did_scan,lamp_dir
			                                 if (did_scan ge 0) then loadct,tcol & endif
       if (did_scan lt  0) then use_scan=0

;      if (rrr eq 6) and (styles(0,1) eq 1) then $
       if ((rrr eq 1) or (rrr eq 3) or (rrr eq 4) or (rrr eq 6)) and (styles(0,1) eq 1) then $
		if (b_labins(3) eq 2) or (sys_dep('VIEWER') eq 1) then rrr=7

;Set below or beside !
;*** ***** ** ******
       if (htm_ok) or (liveT ne 0) or (liveC) or (liveA) or (rrr eq 7) then $
        if CODENS  ge 0 then begin
	               fu_out=0 & use_scan =0 & redraw=0 & endif
       if fu_out eq 0 then begin if (redraw eq 0) then LOGO,4
                                 if (liveT  eq 0) then p_did_setwin0
       endif else begin
            if n_elements(wbeside) le 1 then    redraw=0 $
             else if  redraw  eq 1  then begin   widget_control,bad_id=i,wbeside(0),map=1
            					 if i ne 0 then RETURN else if !D.name ne 'Z' then $
            					                              if wbeside(2) gt 0 then wset,wbeside(2)
       endif & endelse

      if (ps_ok) then if use_scan gt 0 then begin ps_ok=0 & scr_ok=1 & endif

;redraw=0
;******
       if redraw eq 0 then begin

	if use_scan eq 0 then begin
	   !p.background =0
	   !p.noerase =0
	   !p.color =255
	   !p.font =0
	   !order =0
	   !x.style= 1 & !y.style= 1 & !z.style= 1
	   !x.range= 0 & !y.range= 0 & !z.range= 0
	   !p.position=[0,0,0,0]     & !p.multi= 0
	   if (liveT ne 0) or $
	    (((did_repr(2) ne 1) or (siz(0) eq 1)) and (CODENS eq 0) and (siz(0) ne 3)) then begin
		if ps_ok then !p.title   ='' else !p.title   =strmid(w_tit(idn),0,100)
		if ps_ok then !p.subtitle='' else !p.subtitle=strmid(other_tit(idn),0,100)
		!x.title   =strmid(x_tit(idn),0,100)
		!y.title   =strmid(y_tit(idn),0,100)
		!z.title   =strmid(z_tit(idn),0,100)
		if (not ps_ok) then $
		if did_repr(5) eq 1 then if siz(0) lt 2 then !p.subtitle=!p.subtitle + ' Y=LOG10(f(x))' else $
						     	     !p.subtitle=!p.subtitle + ' Z=LOGn (z)'
	   endif
	endif
;Use true axis !
;*** **** ****
	xx=[1L] & yy=[1L] & zz=[1L] & ee=0 & nn=1 & vv=0
	if (sizx(0)  eq 0) or  (sizx(1) ne siz(1))   then i=execute('x'+ wnumber+'=lindgen(siz(1))+1')
	if (siz(0)   eq 3) then $
	if (sizz(0)  eq 0) then i=execute('z'+ wnumber+'=lindgen(siz(3))+1')
	if  CODENS   eq 0  then begin
	 if  siz(0)  eq 1  then i=execute('y'+ wnumber+'=y'+ wnumber+'(0)') else $
	 if (sizy(0) eq 0) or ((sizy(0) eq 1) and (sizy(1) ne siz(2)))$
			   or ((sizy(0) eq 2) and (sizy(2) ne siz(2)))      then $
			        i=execute('y'+ wnumber+'=lindgen(siz(2))+1')
	endif

	if (sys_dep('STUDENT')) and (rrr eq 0) and (fu_out eq 1)  then begin
	                                                           did_repr(1)=1 & rrr=5 & endif
	i =execute('xx= x'+wnumber) & sizx=size(xx)
	i =execute('yy= y'+wnumber) & sizy=size(yy)
	i =execute('zz= z'+wnumber) & sizz=size(zz)

	if did_repr(6) eq 1 then begin
		uxy=1
		if (rrr eq 0) and (siz(0) eq 2) then begin did_repr(1)=1 & rrr=2 & endif
	endif

	if ( (xx(1) -xx(0))*(siz(1)-1) eq xx(siz(1)-1)-xx(0)) then if (siz(0) gt 1) then $
	if ( (yy(1) -yy(0))*(siz(2)-1) eq yy(siz(2)-1)-yy(0)) then axy=1 else axy=0 else axy=1

;Use errors !
	if siz(0) eq 1 then begin sizee=[0L]
	   i = execute('sizee=size(e' + wnumber + ')' )
	   if (sizee(0) eq 1) and (sizee(1) eq siz(1)) then i=execute('ee= e'+wnumber)
	   endif
	if siz(0) eq 1 then begin siznn=[0L]
	   i = execute('siznn=size(n' + wnumber + ')' )
	   if (siznn(0) eq 1) and (siznn(1) eq siz(1)) then i=execute('nn= n'+wnumber)
	   endif
	if CODENS gt 0 then $
	if siz(0) eq 1 then begin sizvv=[0L]
	   i = execute('sizvv=size(pv'+ wnumber + ')' )
	   if (sizvv(0) eq 2) and (sizvv(1) eq 2)      then i=execute('vv=pv'+wnumber)
	   if (sizvv(0) eq 1) and (sizvv(1) eq siz(1)) then i=execute('vv=pv'+wnumber)
	   endif
;Stretch !
	keyrangx=''  & xl=0 & xf=0 & mx1=0 & mx2=0
	keyrangy=''  & yl=0 & yf=0 & my1=0 & my2=0
	keyrangz=''  & zl=0 & zf=0 & mz1=0 & mz2=0
	if vfl(0) ge 0 then begin xf=vfl(0) & xl=vfl(1) & if xl ge siz(1) then xl=siz(1)-1 & endif
	if vfl(2) ge 0 then begin yf=vfl(2) & yl=vfl(3) & if yl ge siz(2) then yl=siz(2)-1 & endif
;Stretch x !
	on_ioerror,misxrange
	if (((did_repr(7) eq 1) and (vfl(0) lt 0) and (did_repr(10) gt 0)) or (vff(6) ne vff(7))) then begin

	    if  sizx(0) le 1 then xw=0   else xw=siz(2)/2

	    mx2  =max(xx(*,xw),min=mx1) ;or xx(siz(1)-1) & xx(0)
	    kpmx1=mx1  & kpmx2=mx2

	    if vff(2) eq 1 then begin
		if vff(6) ne vff(7) then begin mx1=vff(6) & mx2=vff(7) & endif
	    endif else begin
	    	widget_control,bad_id=i,did_repr(10),get_value=smxr
				 smxr=STRLOWCASE(strcompress(smxr(0),/remove_all))
				 if   STRPOS(smxr,'min') lt 0   then mx1=float(smxr)
	    	widget_control,bad_id=i,did_repr(11),get_value=smxr
				 smxr=STRLOWCASE(strcompress(smxr(0),/remove_all))
				 if   STRPOS(smxr,'max') lt 0   then mx2=float(smxr)
	    endelse

	    if CODENS ne 0 then begin
	    	idx=where((xx ge mx1) and (xx le mx2)) & nidx=n_elements(idx)
	    	if (nidx gt 2) and (nidx lt n_elements(xx)) then begin
	    	    i =execute( 'w0= w'+wnumber +'(idx)') & siz=size(w0) & wnumber= '0'
		    MYREDUCE, idx, xx,yy,zz,ee,nn,vv
	    	    xl=0 & xf=0 & endif
	    endif else begin
		ivf= where(xx(*,xw) ge mx1 ,count1)
		     if count1 gt 0 then xf=ivf(0) else xf=0
		ivl= where(xx(*,xw) ge mx2 , count2)
		     if count2 gt 0 then xl=ivl(0) else xl=siz(1)-1
		if (count1 le 0) or (count2 le 0) or (siz(0) eq 1) then keyrangx=',xrange=[mx1,mx2]'
		if ((kpmx1 gt mx1) or (kpmx2 lt mx2)) and (siz(0) eq 1) then axy=0
	    endelse
	endif
	if (xl gt xf) and (xf ge 0) and (xl lt siz(1)) and ((xf ne 0) or (xl ne siz(1)-1)) then begin
		  if siz(0) eq 1 then i=execute( 'w0= w'+wnumber +'(xf:xl)'     )
		  if siz(0) eq 2 then i=execute( 'w0= w'+wnumber +'(xf:xl,*)'   )
		  if siz(0) gt 2 then i=execute( 'w0= w'+wnumber +'(xf:xl,*,*)' )
		  siz=size(w0)
		  wnumber= '0'
		  if sizx(0) eq 2 then xx=xx(xf:xl,*) else xx=xx(xf:xl)
		  if sizy(0) eq 2 then yy=yy(xf:xl,*)
		  if n_elements(ee) gt 1 then ee=ee(xf:xl)
		  vfl(0)=xf & vfl(1)=xl
		  set_xy
	endif else vfl(0)=-1
	misxrange:
	if vfl(0) lt 0 then begin vfl(0)=0 & vfl(1)=siz(1)-1 & endif

;Stretch y !
	if (((did_repr(8) eq 1) and (did_repr(12) gt 0)) or (vff(8) ne vff(9))) then begin
	    my1=w_min(idn)
	    my2=w_max(idn)
	    if (CODENS ne 0) or (siz(0)  ge 2)  then  begin
	       if sizy(0) le 1 then yw=yy else yw =reform(yy(siz(1)/2,*))
	       my1=min(yw,max=my2)  &    endif

	    if vff(2) eq 1 then begin
		if vff(8) ne vff(9) then begin my1=vff(8) & my2=vff(9) & endif
	    endif else begin
	    	on_ioerror,misyrange
	    	widget_control,bad_id=i,did_repr(12),get_value=smyr
				 smyr=STRLOWCASE(strcompress(smyr(0),/remove_all))
		 		 if   STRPOS(smyr,'min') lt 0 then my1=float(smyr)
	    	widget_control,bad_id=i,did_repr(13),get_value=smyr
				 smyr=STRLOWCASE(strcompress(smyr(0),/remove_all))
	    		 	 if   STRPOS(smyr,'max') lt 0 then my2=float(smyr)
	    	misyrange:
	    endelse
	endif
;	For Image
	if (siz(0) ge 2) or (CODENS ne 0) then begin

	if ((did_repr(8) eq 1) and (did_repr(12) gt 0)) or (vff(8) ne vff(9)) then if vfl(2) lt 0 then begin
	    if CODENS ne 0 then begin
		idx=where((yy ge my1) and (yy le my2)) & nidx=n_elements(idx)
		if (nidx gt 2) and (nidx lt n_elements(yy)) then begin
	    	    i=execute( 'w0= w'+wnumber +'(idx)') & siz=size(w0) & wnumber= '0'
		    MYREDUCE, idx, xx,yy,zz,ee,nn,vv
	    	    yl=0 & yf=0 & endif
	    endif else begin
		ivf= where(yw ge my1 , count)
		     if count gt 0 then yf=ivf(0) else yf=0
		ivl= where(yw ge my2 , count)
		     if count gt 0 then yl=ivl(0) else yl=n_elements(yw)-1
	    endelse
	endif
	if (yl gt yf) and (yf ge 0) and (((yl lt siz(2)) and ((yf ne 0) or (yl ne siz(2)-1))))$
		  then begin
		  if siz(0)  eq 2 then i=execute( 'w0= w'+wnumber +'(*,yf:yl)'   ) else $
		  if siz(0)  gt 2 then i=execute( 'w0= w'+wnumber +'(*,yf:yl,*)' )
		  siz=size(w0)
		  wnumber= '0'
		  if sizy(0) eq 2 then yy=yy(*,yf:yl) else yy=yy(  yf:yl)
		  if sizx(0) eq 2 then xx=xx(*,yf:yl)
		  vfl(2)=yf & vfl(3)=yl
		  set_xy
	endif else vfl(2)=-1
	if vfl(2) lt 0 then begin vfl(2)=0 & vfl(3)=siz(2)-1 & endif

;	For Vector
	endif else begin
	   if ((did_repr(8) eq 1) and (did_repr(12) gt 0)) or (vff(8) ne vff(9)) then begin
	       if (my1 lt w_max(idn)) and (my2 gt w_min(idn)) then keyrangy=',yrange=[my1,my2]'
	   endif else begin my1=w_min(idn)
	   		    my2=w_max(idn) & endelse

	   if vfl(2) ge 0  then begin my2=vff(1) & keyrangy=',yrange=[my1,my2]' &  endif
	   vfl(2)=-1
	   if (my1 lt w_min(idn)) or (my2 gt w_max(idn)) then axy=0
	endelse

;Stretch scan or z!
	on_ioerror,miszrange
	if  (siz(0) eq 3) or (CODENS ne 0) then begin
	 if (did_inib(2)  gt 0) then widget_control,bad_id=ii,did_inib(2),map=1 & did_inib(2)=0
	 if (did_repr(17) eq 1) and (did_repr(15) gt 0) then begin

	    mz2=max(zz,min=mz1)

	    	widget_control,bad_id=i,did_repr(15),get_value=smzr
				 smzr=STRLOWCASE(strcompress(smzr(0),/remove_all))
				 if   STRPOS(smzr,'min') lt 0   then mz1=float(smzr)
	    	widget_control,bad_id=i,did_repr(16),get_value=smzr
				 smzr=STRLOWCASE(strcompress(smzr(0),/remove_all))
				 if   STRPOS(smzr,'max') lt 0   then mz2=float(smzr)

	    if CODENS ne 0 then begin
		idx=where((zz ge mz1) and (zz le mz2)) & nidx=n_elements(idx)
		if (nidx gt 2) and (nidx lt n_elements(zz)) then begin
	    	    i=execute( 'w0= w'+wnumber +'(idx)') & siz=size(w0) & wnumber= '0'
		    MYREDUCE, idx, xx,yy,zz,ee,nn,vv
	    	    zl=0 & zf=0 & endif
	    endif else begin
		ivf= where(zz(*) ge mz1 ,count1)
		     if count1 gt 0 then zf=ivf(0) else zf=0
		ivl= where(zz(*) ge mz2 ,count2)
		     if  count2 gt 0 then zl=ivl(0) else zl=n_elements(zz)-1
	    endelse
	 endif
	endif
	if (zl gt zf) and (zf ge 0) and ((zl lt siz(3)) and ((zf ne 0) or (zl ne siz(3)-1)))$
		  then begin
		  i=execute( 'w0= w'+wnumber +'(*,*,zf:zl)' )
		  siz=size(w0)
		  wnumber= '0'
		  zz=zz(zf:zl)
		  set_xy
	endif
	miszrange:

;Beside construction !
       if (rrr eq 2) and (fu_out eq 1) and (siz(0) eq 2) then bobol=90

       if fu_out eq 1 then begin
	  if turn gt 2 then begin
		i =0 & widget_control,bad_id=i,turn, get_uvalue=uv ,tlb_get_size=v2

		if i eq 0 then begin v2=long(v2) & uv=long(uv)
			new=0
			bst_x=uv(5)-bobol & bst_y=uv(6)
			wbeside=[uv(2),uv(3),uv(4),bst_x,bst_y,uv(9),uv(12)]

			widget_control,bad_id=i,uv(10), get_value=rsz_x & rsz_l=bst_x
			widget_control,bad_id=i,uv(11), get_value=rsz_y & rsz_h=bst_y
			on_ioerror,misrsz & rsz_l=fix(rsz_x(0))+off90
			                    rsz_h=fix(rsz_y(0))+off90   & misrsz:

			if (rsz_l ne bst_x) or (rsz_h ne bst_y) then begin ;User changed size texts
				bst_x=rsz_l<3000>100 & xi=bst_x            ;***********************
				bst_y=rsz_h<2000>100 & yi=bst_y
				new=2
				wait,.3
				if (not ps_ok) then widget_control,bad_id=i,turn,/destroy

			endif else if (v2(0) ne uv(7)) or (v2(1) ne uv(8)) then begin ;User resized window
				bst_x=(bst_x+v2(0)-uv(7))>(v2(0)-30)                  ;**** ******* ******
				bst_x=(bst_x-bobol)>100
				bst_y=(bst_y+v2(1)-uv(8))>100
				xi=bst_x & yi=bst_y
				new=2
				wait,.3
				if (not ps_ok) then widget_control,bad_id=i,turn,/destroy
			endif
		endif
	  endif
	  if new ne 0 then begin
	       if new ne 2 then begin ymini=lamp_siz/2
		bst_x=512  & bst_y=ymini
		if wonly(0) ne 0 then begin bst_x=wonly(0) & bst_y=wonly(1)
		endif else $
		if (siz(0) ge 2) and (CODENS eq 0) then begin
		   bst_x=siz(1) & bst_y=siz(2) & maxvol=long(512)*512

		   bty  =bst_x/(bst_y*6) & if bty lt 1 then bty=1
		   btx  =bst_y/(bst_x*6) & if btx lt 1 then btx=1
		   bst_x=bst_x*btx	 & bst_y=bst_y*bty

		   if (did_repr(2)+did_repr(1) eq 0) and (siz(0) eq 3) then begin
		   	f=float(bst_x)/bst_y
		   	fi=round(sqrt(siz(3))/f) & fj=round(sqrt(siz(3))*f)

		   	if fi gt 1 then bst_x=bst_x*fi
		   	if fj gt 1 then bst_y=bst_y*fj
		   	while bst_x gt 640 do bst_x=bst_x-fi
		   	while bst_y gt 640 do bst_y=bst_y-fj
		   endif
		   maxi=4000
		   if bst_x gt maxi then begin bst_x=bst_x/(bst_x/maxi) & bst_y=bst_y/(bst_x/maxi) & endif
		   if bst_y gt maxi then begin bst_y=bst_y/(bst_y/maxi) & bst_x=bst_x/(bst_y/maxi) & endif

		   while bst_x*bst_y lt maxvol do begin bst_x=bst_x+siz(1)
		   					bst_y=bst_y+siz(2) & endwhile
		   while ((bst_x/bst_y gt 4) and (bst_x gt siz(1))) do bst_x=bst_x-siz(1)
		   while ((bst_y/bst_x gt 4) and (bst_y gt siz(2))) do bst_y=bst_y-siz(2)
		   if (did_repr(1) eq 1) or (did_repr(2) eq 1) then begin
		   	if bst_x lt 256 then bst_x=(256/bst_x) * bst_x
		   	if bst_y lt 256 then bst_y=(256/bst_y) * bst_y
		        if isurf then if bst_x lt bst_y then bst_x=bst_y
		   endif
		endif
		if (did_repr(18) gt 50) and (did_repr(19) gt 50) then begin
			bst_x=did_repr(18) & bst_y=did_repr(19)
			did_repr(18)=0 & did_repr(19)=0 & endif
		bst_x=bst_x+off90 & bst_y=bst_y+off90
		if bst_x gt 512  +off90 then xi=min([bst_x,lamp_siz]) else xi=bst_x
		if bst_y gt ymini+off90 then yi=min([ymini,lamp_siz]) else yi=bst_y
	       endif

	       wbeside=[0,0,0,0,0,0,0]
	       if !D.name ne 'Z' then begin
		if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0
		ttl='Lamp ' + strtrim(his(fix(string_w)),2)
		basid=widget_base  (title=ttl,/column,resource_name='lampdid',map=0,/tlb_size_events)
		bas1 =widget_base  (basid    ,/row)
		bas11=widget_button(bas1,value='Remove'    ,font=ft_b_normal,uvalue=[-88,349,basid])
		bas12=widget_button(bas1,value='Color'     ,font=ft_b_normal,uvalue=[-88,347,basid])
		if wonly(0) eq 0 then $
		bas1r=widget_button(bas1,value='Replot'    ,font=ft_b_normal,$
						uvalue=[-88,301, basid,fix(string_w)])
		lue="" & basmo=0L
		if (sys_dep('VERSION') lt 5.0) or (wonly(0) ne 0) then $
		bas13=widget_button(bas1,value='Annotate'  ,font=ft_b_normal) $
		else begin
		basm =widget_button(bas1,value='LiveTools' ,font=ft_b_normal, menu=2)
		bas13=widget_button(basm,value='Annotate'  ,font=ft_b_normal)
		if siz(0) eq 3 then lue='Slicer' else if CODENS eq -1 then lue='Plot 3Dbox' $
		                                 else if CODENS gt  0 then lue='4D object' else lue='LiveTools'
		if (CODENS gt 0) then begin
		  basmo=widget_button(basm ,value=lue,font=ft_b_normal,/menu) & widget_control,basmo,sensitive=0
		  d_4vM=widget_button(basmo,font=ft_normal,value='Vrml File',uvalue='Vrml')
		endif else $
		  basmo=widget_button(basm,value=lue,font=ft_b_normal,uvalue=[-88,301,-basid,fix(string_w)])

		if (siz(0) eq 2) and (CODENS eq 0) then $
		basma=widget_button(basm,value='LiveContour',font=ft_b_normal,$
						uvalue=[-88,301,-basid-10000,fix(string_w)])
		if (siz(0) eq 3) then $
		basma=widget_button(basm,value='Animation'  ,font=ft_b_normal,$
						uvalue=[-88,301,-basid-20000,fix(string_w)])
		if (siz(0) ge 2) and (CODENS eq 0) then $
		basma=widget_button(basm,value='Vrml file'  ,font=ft_b_normal,$
						uvalue=[-88,301,-basid-30000,fix(string_w)])
		endelse
		bas14=widget_button(bas1,value='Print to'  ,font=ft_b_normal)
		ttl='lamp_W'+string_w+'.ps    '
		bas15=widget_text  (bas1,value=ttl,font=ft_b_normal,xsize=11+cap,ysize=1,/editable)

		bas_x=widget_base  (bas1 ,/exclusive,/row,uvalue=3)
		biscr=widget_button(bas_x,value='screen',font=ft_smallest,/no_release,uvalue=[-88,345,1,bas_x])
		if wonly(0) eq 0 then begin
		  if (sys_dep('VERSION') ge 5.4) then kif='png' else kif='gif'
		  bid=widget_button(bas_x,value= kif    ,font=ft_smallest,/no_release,uvalue=[-88,345,2,bas_x])
		  byd=widget_button(bas_x,value='ps'    ,font=ft_smallest,/no_release,uvalue=[-88,345,3,bas_x])
		endif
		bas2 =widget_base  (basid,/row)
		      put_logo	   ,bas2
		bid  =widget_label (bas2,value='Size'				    ,font=ft_smaller)
		pixrx=widget_text  (bas2,value=strtrim(fix(bst_x-off90),2),xsize=6,ysize=1,/editable ,font=ft_smaller)
		bid  =widget_label (bas2,value='x'				    ,font=ft_smaller)
		pixry=widget_text  (bas2,value=strtrim(fix(bst_y-off90),2),xsize=6,ysize=1,/editable ,font=ft_smaller)
		baslb=widget_label (bas2,value=string(replicate(32b,40))                  ,xsize=270 ,font=ft_b_normal)

		if CODENS gt 0 then begin
		  etxt="basd= widget_draw(basid, GRAPHICS_LEVEL=2,UVALUE='DRAW', RETAIN=0 ,"+ $
			                 "XSIZE=bst_x+bobol, YSIZE=bst_y, /BUTTON_EVENTS  ,"+ $
			                 "/EXPOSE_EVENTS,/frame)"
			                                        ii=EXECUTE(etxt) & endif else $
		if (bst_x eq xi) and (bst_y eq yi) then $
	     		basd= widget_draw(basid,retain=2,/frame,xsize=bst_x+bobol,ysize=bst_y,$
	     							/button_event,/motion_event)  $
	     	else	basd= widget_draw(basid,retain=2,/frame, /button_event,/motion_event, $
			   		  xsize=bst_x+bobol,ysize=bst_y,x_scroll_size=xi,y_scroll_size=yi)
   		bid=sys_dep      ('DYNLAB',basid,0)

		widget_control,bad_id=i,   basid,group_leader=lamp_b1, /realize & put_logo
		widget_control,bad_id=i,   basd , get_value=basw

		if CODENS gt 0 then basw=-basd
		if CODENS gt 0 then widget_control,bad_id=i, bas13, sensitive=0
		if wonly(0) eq 0 then $
		widget_control,bad_id=i, byd  , set_button=1
		widget_control,bad_id=i, bas13, set_uvalue=[-88,346,basw]
		widget_control,bad_id=i, bas14, set_uvalue=[-88,350,basw ,bas15,fix(string_w),siz(0),basid,bas_x,basd]
		widget_control,bad_id=i, basid, tlb_get_size=v2  &  v2=long(v2)
		widget_control,bad_id=i, basid, set_uvalue=[-88,308,basid,basd ,basw,bst_x+bobol,bst_y,$
								v2(0),v2(1),baslb,pixrx,pixry,basmo,fix(string_w)]

	        XMANAGER, 'Beside', basid, event_handler='LAMP_EVENT_PARSER',/just_reg
		wbeside=[basid,basd,basw,0,0,baslb,basmo]
	       endif
	       wbeside(3)=bst_x & wbeside(4)=bst_y
	  endif
	  if !D.name eq 'Z' then begin device,set_resolution=[bst_x+bobol,bst_y] & erase
	  endif else if wbeside(2) gt 0 then wset,wbeside(2)
	endif
;Large dimensions
	if (siz(0) ge 2) and (CODENS eq 0) then begin
	   xi=siz(1) & yi=siz(2)
;	   Image...
	   if   did_repr(0) eq 1 then  $
	        if  (xi gt bst_x) or (yi gt bst_y) then begin
			xo= float(xi)/bst_x
			yo= float(yi)/bst_y
			if yo ge xo then fx=yo else fx=xo
	        	if xo gt .5 then xi=fix(xi/fx)
	        	if yo gt .5 then yi=fix(yi/fx)
	        	endif
;	   Contour.
	   if  (did_repr(1) eq 1) or (did_repr(0)*did_repr(6)*uxy eq 1) then begin
			if use_scan eq 1 then maxvol=1000 else maxvol=512
			    xo=xi/maxvol
			    yo=yi/maxvol
			    if xo gt 0 then xi=xi/xo
			    if yo gt 0 then yi=yi/yo
	   endif
;	   Other...
	   if  (xi ge bst_x) and (yi ge bst_y) then begin
		xo=float(xi)/bst_x
		yo=float(yi)/bst_y
		if yo ge xo then fx=yo else fx=xo
		if use_scan eq 1 then maxvol=2000 else maxvol=1000
		if (xi gt maxvol) and (yi gt maxvol) $
				  and (did_repr(1)+did_repr(2) gt 0) then fx=fx*2
	        if xo gt .5 then xi=fix(xi/fx)
	        if yo gt .5 then yi=fix(yi/fx)
		endif

	   xi=xi>2
	   yi=yi>2

	   if  (xi ne siz(1)) or (yi ne siz(2)) then begin
		if wnumber eq '0' then st='temporary(w0)' $
		                  else st='w'+wnumber

	   	if siz(0) eq 2  then i = execute('w0=congrid('+st + ',xi,yi,/interp)' )
	   	if siz(0) eq 3  then i = execute('w0=congrid('+st + ',xi,yi,siz(3))' )

		if sizx(0) eq 2 then xx= congrid(temporary(xx),xi,yi,/interp) else if xi ne siz(1) then xx= congrid(xx,xi,/interp)
		if sizy(0) eq 2 then yy= congrid(temporary(yy),xi,yi,/interp) else if yi ne siz(2) then yy= congrid(yy,yi,/interp)

		siz=size(w0)
		wnumber= '0'
		endif
;	   Smooth Contour.
	   if  ((did_repr(1) eq 1) and (sizx(0) lt 2)) or (did_repr(0)*did_repr(6)*uxy eq 1) then $
	   	if (xi gt 50) and (yi gt 50) and (use_scan eq 0) then begin
		    if wnumber eq '0' then st='temporary(w0)' $
		                      else st='w'+wnumber
		    if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
		    i = execute('w0=smooth('+st + ',3'+edg+')' )
		    siz=size(w0)
		    wnumber= '0'
	       endif
	endif
;Max value !
	thresh=-99.
	mxv2  = 0.
	if (did_repr(9) gt 0) or (vff(2) eq 1) then begin mxv2=-99.
				 on_ioerror,mismx
				 if (l_message gt 0) and (vff(2) eq 0) then begin
				     widget_control,bad_id=i,did_repr(9),get_value=smxv & smxv=smxv(0)
				     mxv=0. & READS,smxv+' -99 -99 ' ,mxv,mxv2
				 endif else if vff(11) eq 0 then mxv=w_max(idn) else mxv=vff(11)
				 if CODENS gt 0 then  thresh=mxv else $
				 if mxv ne -99 then begin
				    thresh=mxv
				    if (siz(0) ne 3) or (not isurf) then begin
					if CODENS eq -1  then begin id=0L
					  if mxv2 ne -99 then begin mxv1=mxv
					  endif else begin mxv =(w_max(idn)-w_min(idn))/50.
							   mxv1=thresh-mxv & mxv2=thresh+mxv & endelse
					  i  =execute( 'id=where((w' + wnumber  +' le mxv2)'$
							  + 'and (w' + wnumber  +' ge mxv1))>0' )
					  i  =execute( 'w0=w' + wnumber  +'(id)' )
					  xx =xx(id)    & yy=yy(id) & zz=zz(id)
					  siz=size(w0) & wnumber= '0'
					endif else if siz(0) eq 1 then begin
					  if  keyrangy eq '' then $
					  if  mxv2 eq -99 then keyrangy=',yrange=[my1,mxv]' $
					                  else keyrangy=',yrange=[mxv,mxv2]'
					endif else begin
					  if wnumber eq '0' then st='temporary(w0)' $
					                    else st='w'+wnumber
					  if (mxv2 ne -99)  then $
						i  =execute( 'w0='+st +' > mxv < mxv2' ) $
					  else  i  =execute( 'w0='+st +' < mxv' )
					  if  keyrangz eq '' then begin
					   if mxv2  eq -99 then begin mxv2=mxv & mxv=w_min(idn) & endif
					   if (mxv2 gt w_max(idn)) or (mxv lt w_min(idn)) then  $
					   	!Z.range=[mxv,mxv2]
					  endif
					  siz=size(w0)
					  wnumber= '0'
					endelse
				    endif else if did_repr(5) eq 1 then thresh=alog(thresh)
				 endif
				 mismx:
	endif

;Stretch Z !
	if CODENS eq -1 then begin mx1=min(xx,max=mx2) & my1=min(yy,max=my2) & mz1=min(zz,max=mz2)
	   cdbox=[ [mx2,my2,mz1],[mx2,my1,mz1],[mx2,my1,mz2],[mx2,my2,mz2],[mx2,my2,mz1],[mx1,my2,mz1],$
		   [mx1,my2,mz2],[mx1,my1,mz2],[mx2,my1,mz2],[mx2,my2,mz2],[mx1,my2,mz2]] & endif

;Log !
	if (did_repr(5) eq 1) and (CODENS eq 0) then begin
		if wnumber eq '0'  then st='temporary(w0)' $
		                   else st='w'+wnumber
		if siz(0) eq 1     then i =execute( 'w0=alog10('+st +' > 1E-9)')  else $
		if w_min(idn) gt 0 then i =execute( 'w0=alog  ('+st +' )' )       $
				   else i =execute( 'w0=alog  ('+st +' > 0.001)')
		if n_elements(ee)  gt 1    then      ee=0

		siz=size(w0)
		wnumber= '0'

		if keyrangy ne '' then begin if siz(0) eq 1 then my1=alog10(my1 > 1E-9) else my1=alog(my1 > 0.001)
					     if siz(0) eq 1 then my2=alog10(my2 > 1E-9) else my2=alog(my2 > 0.001)
					     keyrangy=',yrange=[my1,my2]' & endif
	endif
;***
;end redraw=0
;**********
       endif else begin if fu_out eq 0 then bst_x=did_x else bst_x=wbeside(3)
			if fu_out eq 0 then bst_y=did_y else bst_y=wbeside(4) & endelse
;***
       l_mess=l_message
       if b_labins(6) then if b_labins(7) gt 0 then l_mess=b_labins(7)
;***
       on_ioerror,IfPsErr
       if (not htm_ok) and (not liveC) and (not liveA) then begin

	if fu_out eq 0 then b_cur=0         else b_cur=wbeside(0)
	if fu_out eq 0 then d_cur=did_wd    else d_cur=wbeside(1) & if (CODENS gt 0) and (fu_out eq 0) then d_cur=did_we
	if fu_out eq 0 then w_cur=did_win0  else w_cur=wbeside(2)
	if fu_out eq 0 then baslb=l_mess    else baslb=wbeside(5)
	xo=off60 & yo=off60 & xof=xo/2 & yof=yo/2
	w_order=0
;Plot
;----
	poskey  =',position=[xo,yo,bst_x-xof,bst_y-yof]*f_dps,/device'
	poskeyPS='' & f_dps=1
	wplot   =!D.name
	if (ps_ok) and (CODENS le 0) then begin
		x_sx =7.  & y_sy = 9.5  &  xoff=x_sx/15. & yoff=y_sy*3./40
		x_sps=x_sx & y_sps= y_sy
		if did_fu eq 0 then y_sps=y_sps/2. $
		else begin
			if bst_x+bobol ge bst_y then begin
				y_sps=x_sps*bst_y/bst_x
			endif else begin  tmp  =y_sps*bst_x/bst_y & ttm=(tmp-x_sps)>0
				x_sps=tmp-ttm & y_sps=y_sps-ttm   & endelse
		endelse
		poskeyPS=poskey
		psFile  ='lamp.ps'
		if strpos(w_numor(0),'.ps') gt 0 then psFile=w_numor(0) else psFile='lamp.ps'
		w_numor(0)=''
		errps =1
		nc =256
		keepcol=!P.COLOR
		popo   =!P.COLOR
		popi   =!P.BACKGROUND
		if b_labins(3) ne 1 then tvlct ,  cur_r    ,          cur_g    ,          cur_b ,/get
		set_plot,'PS'
		if b_labins(3) ne 1 then begin
			pos_r=congrid(cur_r,nc) & pos_g=congrid(cur_g,nc) & pos_b=congrid(cur_b,nc)
			popo=min(fix(pos_r)+fix(pos_g)+fix(pos_b))
			popo=!C
			popi=max(fix(pos_r)+fix(pos_g)+fix(pos_b))
			popi=!C
			endif

		!P.COLOR=popo
		!P.BACKGROUND=popi
		lan=0
		if (did_fu ne 0) and (bst_x+bobol ge bst_y) then begin lan=1
		  device,xsize=x_sps,ysize=y_sps, yoffset=y_sy+yoff ,xoffset=xoff ,/inches,/landscape & pdph= x_sps-xoff+.5
		endif else begin
   		  device,xsize=x_sps,ysize=y_sps, yoffset=yoff      ,xoffset=xoff ,/inches,/portrait  & Pdph= y_sps+.5
		endelse
   		device,bits_per_pixel=8,/color
		device,filename=psFile
		if b_labins(3) ne 1 then tvlct ,  pos_r    ,  pos_g    ,  pos_b

		f_dps  =min([x_sps/bst_x , y_sps/bst_y]) *2.4 * !d.x_px_cm
		;fifix  =bst_x*f_dps*2.512/300. & if fifix gt 1 then fifix=fix(fifix)
		;f_dps  =fifix*300. /2.512/bst_x
		dd1    =convert_coord([0,1,1.,0],[0.,0,1,1],/normal,/to_device)
		bst_x  =round(dd1(0,1)/f_dps) ;**bst_x=round((x_sps*2.4 * !d.x_px_cm)/f_dps)
		bst_y  =round(dd1(1,2)/f_dps) ;**bst_y=round((y_sps*2.4 * !d.x_px_cm)/f_dps)
	endif
	if wonly(0) eq 0 then $
	if CODENS ne 0 then begin
	 if (liveT ne 0) then begin  liveT=0
		if wnumber ne '0' then ii=execute('w0=w'+wnumber)
		ii=execute('live_lamp_dens, rrr, xx,yy,zz,w0, thresh=thresh, box=cdbox,'+ $
	                       'xrange=[mx1,mx2], yrange=[my1,my2], zrange=[mz1,mz2],ax=rx,az=rz')

	 endif else if CODENS eq -1 then begin
	   if mx1 eq mx2 then mx2=max (xx ,min=mx1)
	   if my1 eq my2 then my2=max (yy ,min=my1)
	   scale3 ,             xrange=[mx1,mx2], yrange=[my1,my2], zrange=[mz1,mz2],ax=rx,az=rz
			;t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , rz , 0. ]
			;t3d,                   rot=[ rx , 0. , 0. ]
			;t3d, tr=[+.5,+.5,+.5]
	   surface,fltarr(2,2), xrange=[mx1,mx2], yrange=[my1,my2], zrange=[mz1,mz2],/nodata,/t3d
	   s =(50000./n_elements(xx)/6)>1
	   pk=4   &   if s lt 9 then pk=3   &   s=round(s/2)>1<3
	   if (thresh ne -99) and (mxv2 eq 0.) then plots,xx,yy,zz,psym=pk,symsiz=s,/t3d $
	   else begin
		if thresh ne -99 then begin ji=10. & mxv= (mxv2 - thresh)	     & p=thresh
		endif		 else begin ji=50. & mxv= (w_max(idn)-w_min(idn)) & p=w_min(idn) & endelse
		mxk=mxv /ji & if mxk eq 0 then ji=1
		              if mxk ne 0 then mxv=mxk
		col=220./ji
		for i=1,ji do begin id=0L
		    ii=execute('id=where((w'+wnumber+' ge p) and (w'+wnumber+' le p+mxv))')
		    if id(0) ge 0 then plots,xx(id),yy(id),zz(id),psym=pk,symsiz=s,/t3d,color=col*i
		    p =p+mxv
		    if RDSTOP(1,ji,(i)) then i=ji+1
		endfor
	   endelse
	   plots,cdbox,/t3d

	 endif else begin
	 	if fu_out eq 0 then begin odim=[did_x,did_y]  & omen=did_4dM    & endif
	 	if fu_out ne 0 then begin odim=[bst_x,bst_y]  & omen=wbeside(6) & endif
	 	if rrr    eq 7 then begin ps='VRML' & rrr=6   & endif else ps='' ;but fu_out=0!!!!!
	 	if ps_ok       then begin ps='PS'   & ps_ok=0 & endif

		txt='liv_objet,WDRAW=d_cur,DIM=odim,MENUBAS=omen,L_MESS=baslb,WI=idn,PS=ps'+$
		             ',XX=xx,YY=yy,ZZ=zz,WW=w'+wnumber+',THRESH=thresh,REPR=did_repr,EE=ee,NN=nn,VV=vv'
		ii = EXECUTE(txt)
	 endelse
	endif else $
	if siz(0)   eq 1 then begin
		keepcol=!P.COLOR
		if not ps_ok then !P.COLOR=0
		keywrd=',yticklen=1.,ygridstyle=1,background=255,charsize=1.2'
		wnumbxy='w'+wnumber & wxx=''
		wxx='xx,'

		if liveT ne 0 then begin
			i=execute('live_lamp_plot,liveT,xx,'+wnumbxy +keyrangx+keyrangy)
		endif else if n_elements(ee) le 1 then begin
			i=execute(' plot,' + wxx+wnumbxy +keywrd+poskey+keyrangx+keyrangy)
		endif else begin
			m=max(ee) & mq=sqrt(w_max(idn))
			if  m*(w_max(idn)+1) eq mq then opp1='*(1+ee)' else opp1='+ee'
			if  m*(w_max(idn)+1) eq mq then opp2='*(1-ee)' else opp2='-ee'
			if bst_x/siz(1) gt 3 then keywrd=keywrd+',psym=2' $
					     else keywrd=keywrd+',psym=3'
			i=execute(' plot,' + wxx+wnumbxy +keywrd+poskey+keyrangx+keyrangy)

			if bst_x/siz(1) ge 6 then begin
			i=execute('oplot,' + wxx+wnumbxy+opp1+',linestyle=1')
			i=execute('oplot,' + wxx+wnumbxy+opp2+',linestyle=1')
			endif
			i=execute('errplot,' + wxx + wnumbxy+opp2+','+wnumbxy+opp1)
		endelse
		!P.COLOR=keepcol
;Display
;-------
	endif else begin
;	   Use Scan
;	   --- ----
	   if use_scan eq 1 then begin
	   			if fu_out eq 0 then $
	   			   sl_lampscan, 'set_size', bst_x     ,bst_y     ,d_cur,lamp_b1 ,0
	   			if fu_out ne 0 then $
	   			   sl_lampscan, 'set_size', wbeside(3),wbeside(4),d_cur,lamp_b1 ,0
	   			f_fg=[-1,-1]
	   			if did_repr(1) eq 1 then begin
	   				if styles(1,0) eq 1 then f_fg(1)=10 else $
	   				if styles(1,0) eq 2 then f_fg(1)=11
	   				endif
	   			if did_repr(2) eq 1 then begin
	   				if styles(0,0) eq 1 then f_fg(0)=1
;	   				if styles(0,0) eq 2 then f_fg(0)=8  else $
	   				if styles(0,0) eq 3 then f_fg(0)=7  else $
	   				if styles(0,0) eq 4 then f_fg(0)=3  else $
	   				if styles(0,0) eq 5 then f_fg(0)=4  else $
	   				if styles(0,0) eq 6 then f_fg(0)=3
	   				endif
				spm=4
	   			if (styles(2,0) eq 3) then if siz(0) eq 3 then spc=-30 $
	   								  else spm= 6  else $
	   			if (styles(2,0) eq 4)  and    siz(0) eq 3 then spc=-20
				if  spc ge 0 then spc=spc+spm else spc=spc-spm
				if  rz eq 0 then rz=-1

			   	sl_lampscan, 'set_params', rx,rz,nlv ,f_fg
				if rz eq -1 then rz=0
				flg='views'
			      if siz(siz(0)+1) le 6 then $ ;+newtypes*******
			   	i =execute( 'sl_lampscan, flg ,w' + wnumber + ',spc') else $
			        i =execute( 'sl_lampscan, flg ,float(w' + wnumber + '),spc')
				xo=0 & yo=0 & xof=0 & yof=0
				!p.font = 0
				w_order=!order
				set_xy
				!p.title=w_tit(idn)
				!p.subtitle=''
				if !D.name ne 'Z' then if w_cur gt 0 then wset,w_cur
				plot,[0,0],/nodata,xstyle=4,ystyle=4,/noerase
	   endif else $
	   if (siz(0) eq 2) or ((siz(0) eq 3) and (did_repr(2)+did_repr(1) eq 0)) then begin
;	   Use Idl
;	   --- ---

		if (siz(0) eq 3) then begin
					    i =execute('w0=total(w'+wnumber+ ',3)' )
					    siz=size(w0)
					    wnumber='0'
					    endif
		axkey=''
		wnumbxy=wnumber+',xx,yy'
	   	if  uxy eq 0  then begin if (rrr eq 0) or (axy ne 1) then wnumbxy=wnumber
					    xs=siz(1)-1. & ys=siz(2)-1.
					    xdx=[0,xs/4.,xs/2.,xs*3./4.,xs] & sxx=strarr(5)
					    ydx=[0,ys/4.,ys/2.,ys*3./4.,ys] & syy=strarr(5)
					    for i=0,4 do begin
						te=fix(xdx(i)) & td=round((xdx(i)-te)*10.)/10.
						a =string( xx(  te)*(1.-td) + xx(  (te+1)<xs)*td)
						j =strlen(a)-1 & while (j gt 0) and (j eq strpos(a,'0',j)) do j=j-1
						sxx(i)=strmid (a,0,j+1)
						sxx   =strtrim(sxx,2)
						te=fix(ydx(i)) & td=round((ydx(i)-te)*10.)/10.
						if (size(yy))(0) le 1 then $
						a =string( yy(  te)*(1.-td) + yy(  (te+1)<ys)*td) else $
						a =string( yy(0,te)*(1.-td) + yy(0,(te+1)<ys)*td)
						j =strlen(a)-1 & while (j gt 0) and (j eq strpos(a,'0',j)) do j=j-1
						syy(i)=strmid (a,0,j+1)
						syy   =strtrim(syy,2)
					    endfor

					                        scalex=float([sxx(0),sxx(4)])
					    if !order eq 0 then scaley=float([syy(0),syy(4)])  $
					                   else scaley=float([syy(4),syy(0)])

					    if total(long(scalex)) eq total(scalex) then ent=1 else ent=0 ;!!!
					    typ=size(xx) & typ=typ(typ(0)+1)
					    if (typ le 3) and (rrr ne 0) and (axy eq 1) then begin
					    		sxx=round(float(sxx))
							tickx=',xticks=4,xtickv=sxx'
					    endif else	tickx=',xticks=4,xtickname=sxx'

					    if total(long(scaley)) eq total(scaley) then ent=1 else ent=0 ;!!!
					    typ=size(yy) & typ=typ(typ(0)+1)
					    if (typ le 3) and (rrr ne 0) and (axy eq 1) then begin
							syy=round(float(syy))
							ticky=',yticks=4,ytickv=syy'
					    endif else	ticky=',yticks=4,ytickname=syy'

					    wnumbxy=wnumbxy+tickx+ticky
					    axkey  =axkey  +tickx+ticky
		endif

		noaxe=',xstyle=5,ystyle=5,zstyle=5'
		if did_repr(14) eq 1 then begin wnumbxy=wnumbxy+noaxe & noaxe='' & endif
		if did_repr(2)  eq 1 then begin
		 surfstyl='shade_surf' & surfkey=''
		 if styles(0,0) eq 1 then begin if redraw eq 0 then  i=execute('w4d=bytscl(w'+wnumber+')')
		 						     surfkey=',shades=w4d'  & endif
		 if styles(0,0) eq 2 then begin
		 			if redraw eq 0 then begin
		 			 siw=size(w10)
				         if siw(0) ne 2 then i=execute('w10=w'+wnumber) $
				         else if (siw(1) ne isiz(1)) and (siw(2) ne isiz(2)) then $
							 w10=congrid(temporary(w10),isiz(1),isiz(2))
					 w4d=w10(vfl(0):vfl(1) , vfl(2):vfl(3))
		 			 siw=size(w4d)
				         if (siw(1) ne siz(1)) and (siw(2) ne siz(2)) then $
							 w4d=congrid(temporary(w4d), siz(1), siz(2))
					 if (thresh ne -99)    then  w4d=temporary(w4d) < mxv
					 if (did_repr(5) eq 1) then  w4d=alog(temporary(w4d) > 0.001)
					 w4d=bytscl(temporary(w4d))
					endif
								     surfkey=',shades=w4d'  & endif
		 if styles(0,0) eq 4 then begin
		 				surfstyl='surface' & surfkey=''		    & endif
		 if styles(0,0) eq 5 then begin if redraw eq 0 then  i=execute('w4d=bytscl(w'+wnumber+')')
		 				surfstyl='surface' & surfkey=',/lego,shades= w4d' & endif
		 if styles(0,0) eq 6 then begin
		 				surfstyl='surface' & surfkey=',/horizontal' & endif

		 if ps_ok then axsup=',charsize=2. ,zticks=4,font=-1,xtitle=x_tit(idn),ytitle=y_tit(idn),ztitle=z_tit(idn)' $
		          else axsup=',charsize=1.2,zticks=3'
		 surfkey=surfkey+axsup
		 axkey  =axkey  +axsup

		 if siz(1)*siz(2) gt long(128)*64 then horz=',/horizontal' else horz=''

		 if ((rz ge -90.) and (rz le  90.)) or ((rz le -270.)  or (rz ge  270.)) then pvx=0 else pvx=1
		 if ((rz ge   0.) and (rz le 180.)) or ((rz le -180.))                   then pvy=0 else pvy=1
		 if ((rz ge   0.) and (rz le  90.)) or ((rz le -270.))                   then pvz=2 else $
		 if ((rz gt  90.) and (rz le 180.)) or ((rz le -180.) and (rz gt -270.)) then pvz=3 else $
		 if ((rz gt 180.) and (rz le 270.)) or ((rz le - 90.) and (rz gt -180.)) then pvz=0 else $
		 if ((rz gt 270.) and (rz lt 360.)) or ((rz lt    0.) and (rz gt - 90.)) then pvz=1 else pvz=2

		;if ((pvz eq 2) or (pvz eq 1)) and (ps_ok) then axkey=axkey+',font=-1'
		endif
				winx=bst_x	   &   winy=bst_y
				if rrr eq 0 then begin winx=winx-off90 & winy=winy-off90 & endif
				xi= winx/siz(1)    &   yi=winy/siz(2)
				if (xi eq 0) then xi= -(float(siz(1))/winx)
				if (yi eq 0) then yi= -(float(siz(2))/winy)
				if  xi le -1 then fx= -1./xi else fx=xi
				if  yi le -1 then fy= -1./yi else fy=yi
				fm= min([fx,fy])
				if fu_out eq 0 then begin fx=fm & fy=fm & endif
				xi= fix(siz(1)*fx)
				yi= fix(siz(2)*fy)
				if xi/yi gt 4 then yi=xi/4 else $
				if yi/xi gt 4 then xi=yi/4

				if winx lt xi then xi=winx
				if winy lt yi then yi=winy
;		rrr=0 image
;		-----------
		if rrr eq 0 then  begin
				w_order=!order
				xo=(winx-xi)/2 + off60 & xof=bst_x-xi-xo	;prev 55
				yo=(winy-yi)/2 + off60 & yof=bst_y-yi-yo	;prev 45
						     rangex=[vfl(0),vfl(1)]-vfl(0)
				if w_order eq 0 then rangey=[vfl(2),vfl(3)]-vfl(2) $
						else rangey=[vfl(3),vfl(2)]-vfl(3)

				if total(long(scalex)+long(scaley)) eq total(scalex+scaley) then $
				   if axy eq 1 then wnumbxy=wnumber
				axy=1
				if ((xi ne siz(1)) or (yi ne siz(2))) then begin
					     if wnumber eq '0' then st='temporary(w0)' $
					     else st='w'+wnumber
					     if ((xi lt siz(1)) or (yi lt siz(2))) or ((fm ge 3) and (smoo eq 1)) then $
					          i= execute('w0=congrid('+st + ',xi,yi,/interp)' ) $
					     else i= execute('w0=congrid('+st + ',xi,yi)' )
					     ;if (fm ge 5) and (smoo eq 1) then begin
						;if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
						;i=execute('w0=smooth(temporary(w0),fix(fm-2)<9'+edg+')') & endif
				  if liveT ne 0 then $
				   i= execute('live_lamp_img,liveT,w0,xrange=scalex,yrange=scaley')  $
				  else begin erase
				   if not ps_ok then tvscl,w0,xo,yo $
				   		else tvscl,w0,xo*f_dps,yo*f_dps,xsize=(xi)*f_dps,ysize=(yi)*f_dps
				   i= execute('plot,w'+wnumbxy+ ',charsize=1.2 ,xrange=scalex,yrange=scaley'+  $
					      ',/nodata,position=[xo,yo,xo+xi-1,yo+yi-1]*f_dps ,/device,/noerase')
				  endelse
				endif else   begin
				  if liveT ne 0 then $
				   i= execute('live_lamp_img,liveT,w'+wnumber+',xrange=scalex,yrange=scaley')  $
				  else begin erase
				   if not ps_ok then didi="" else didi=",xsize=(xi)*f_dps,ysize=(yi)*f_dps"
				   i= execute('tvscl,     w'+ wnumber + ',xo*f_dps  , yo*f_dps'+didi )
				   i= execute('plot,w'+wnumbxy+ ',charsize=1.2 ,xrange=scalex,yrange=scaley'+  $
					      ',/nodata,position=[xo,yo,xo+xi-1,yo+yi-1]*f_dps,/noerase,/device')
				  endelse
				endelse
		endif

		if (liveT ne 0) and (rrr ge 1) then begin
				i=execute('live_lamp_surf,liveT,xx,yy,w'+ wnumber +$
					   ',az=rz,ax=rx,rrr=rrr,style=styles')
		endif else begin

;		rrr=1 image + surface
;		---------------------
		if rrr eq 1 then  begin
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/save,/nodata'+poskeyPS+noaxe )
				i=execute( 'contour   ,w' + wnumbxy + ',/fill' + $
						     ',/noerase,/t3d,zvalue=0.   ,nlevels=nlv'    +poskeyPS+noaxe )
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/noerase,' +$
									'bottom=80' +horz         +poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
				endif
;		rrr=2 image + contour
;		---------------------
		if rrr eq 2 then  begin
				i=execute( 'contour   ,w' + wnumbxy + ',/fill  ,nlevels=nlv' +poskey)
				if (fu_out eq 1) and (did_repr(14) eq 0) then begin
				   wmin =w_min(idn) & wmax=w_max(idn) & i=execute('wmin=min(w'+wnumber+',max=wmax)')
				   if did_repr(5) eq 1 then begin wmin=exp(wmin) & wmax=exp(wmax) & endif
				   bn2  =15 & bn1 =(bst_y-yof-yo)
				   bobo =findgen(bn1)/(bn1-1)*(wmax-wmin)
				   if did_repr(5) eq 1 then bobo=alog(bobo > 0.001)
				   bobox=fltarr(bn1,bn2)  & for i=0,bn2-1 do bobox(0,i)=bobo
				   posx =(bst_x-xof+bn2+bn2)
				   posy =(yo)
				   bobox=transpose(bobox)
				   if (    ps_ok) then tvscl,bobox,posx*f_dps,posy*f_dps,xsize=bn2*f_dps,ysize=bn1*f_dps
				   if (not ps_ok) then tvscl,bobox,posx*f_dps,posy*f_dps
				   wmix=wmax-wmin
				   xyouts,(posx+bn2+3)*f_dps, posy         *f_dps,strtrim(string(wmin)        ,2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+  bn1/4)*f_dps,strtrim(string(wmin+wmix/4.),2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+  bn1/2)*f_dps,strtrim(string(wmin+wmix/2.),2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+3*bn1/4)*f_dps,strtrim(string(wmax-wmix/4.),2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+  bn1)  *f_dps,strtrim(string(wmax)        ,2),/device
				endif
				if uxy eq 0 then axy=1
				endif

;		rrr=3 image + contour + surface
;		-------------------------------
		if rrr eq 3 then  begin
				col=(indgen(nlv/2)+1)*10 + 50
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/save,/nodata'+poskeyPS+noaxe )
				i=execute( 'contour   ,w' + wnumbxy + ',/fill' + $
						     ',/noerase,/t3d,zvalue=0.   ,nlevels=nlv'    +poskeyPS+noaxe )
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/noerase,' +$
									'/t3d,bottom=80' +horz    +poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
				i=execute( 'contour   ,w' + wnumbxy + ',c_colors=col' +$
						     ',/noerase,/t3d,zvalue=1.   ,nlevels=nlv/2'  +poskeyPS+noaxe )
				endif
;		rrr=4 contour +  surface
;		------------------------
		if rrr eq 4 then  begin
				col=(indgen(nlv/2)+1)*10  + 50
				i=execute( surfstyl+ ',w' + wnumbxy + ',az=rz,ax=rx,/save'+surfkey+poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
				i=execute( 'contour   ,w' + wnumbxy + ',c_colors=col' +$
						     ',/noerase,/t3d,zvalue=1.   ,nlevels=nlv/2'  +poskeyPS+noaxe )
				endif
;		rrr=5 contour
;		-------------
		if rrr eq 5 then  begin
			if styles(1,0) eq 1 then begin
				c_lab=round(abs(sin(indgen(nlv)*!pi/2.)))
				c_lin=round(findgen(nlv)/(nlv-1)*5)
				c_ll =[1,4,3,2,5,0]
				for i=0,nlv-1 do c_lin(i)=c_ll(c_lin(i))
				i=execute( 'contour   ,w' + wnumbxy + ',/follow,nlevels=nlv,charsize=1.5,c_linestyle=c_lin'+$
					   ',font=-1,charthick=2.,c_labels=c_lab'+poskey)
			endif else begin
				col=(indgen(nlv)+1)*(180/nlv) + 50
				i=execute( 'contour   ,w' + wnumbxy + ',c_colors=col,nlevels=nlv' +poskey)
			endelse
			if uxy eq 0 then axy=1
		endif
;		rrr=6 surface
;		-------------
		if rrr eq 6 then  begin
				i=execute( surfstyl+ ',w' + wnumbxy + ',az=rz,ax=rx,/save'+surfkey +poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
			    endif
;		rrr=7 VRML
;		----------
		if rrr eq 7 then  begin if uxy eq 1 then wnumbxy=wnumber+',xx,yy' else wnumbxy=wnumber
					if styles(0,0) eq 1 then pol=',/poly' else pol=''
					i=execute('matovr,w'+wnumbxy+pol)
					if b_labins(3) ne 2 then i=sys_dep('VIEWER','lamp.wrl')
					endif
		endelse
	   endif else if (siz(0) eq 3) and (did_repr(2)+did_repr(1) ge 1)  then begin
		kpcol=!p.color
		isurf =1
		if liveT ne 0 then begin
			i=execute('live_lamp_vol,liveT,w'+wnumber+',thresh=thresh,az=rz,ax=rx,rrr=rrr,name=w'+string_w)
		endif else begin

		if redraw eq 0 then begin
		   mini=w_min(idn) & maxi=w_max(idn)
		   if did_repr(5) eq 1   then begin i=execute( 'W0=w'+wnumber+'>0' )
		                                    wnumber='0' & maxi=max(W0,min=mini) & endif
		   if thresh      eq -99 then thresh=mini + (maxi-mini)/3.
		   v=0 & p=0
		   if rrr eq 7  then begin if styles(0,0) lt 4 then txt=',/poly' else  txt=''
				     i=execute( 'matovr,w' + wnumber + ' , iso=thresh'+txt)
				     if b_labins(3) ne 2 then i=sys_dep('VIEWER','lamp.wrl')
		   endif	else begin
				     if wnumber ne '0' then begin W0 =0 & i=execute( 'W0=float(w'+wnumber+')')
				                       endif else W0 =float(W0)
				     WT = total(W0) & WI = 0.

				     if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
				     if did_repr(6) eq 1 then begin
					i=execute('W0=smooth(temporary(W0),3'+edg+')')
					W0=W0*(WT/total(W0))
				     endif

				     if edg ne '' then begin
				     	i=execute('W0=transpose(W0,[2,0,1])')
					xtit=z_tit(idn) & ytit=x_tit(idn) & ztit=y_tit(idn) & xxr=zz & yyr=xx & zzr=yy
				     endif else begin
				        xtit=x_tit(idn) & ytit=y_tit(idn) & ztit=z_tit(idn) & xxr=xx & yyr=yy & zzr=zz
				     endelse
				     suz=size(W0)

				     shade_volume,W0,thresh,v,p
				     idx=  where (W0 ge thresh)
				     WN =  n_elements(idx)
				     WE =  n_elements(W0)
				     if WN gt 1 then begin WI=total(W0(idx))
							   if (did_repr(0) eq 0) and (did_repr(2) eq 1) then $
				     			   W0(idx)=-maxi*max([suz(1),suz(2),suz(3)]) & endif
				     WP0= (total(W0,3)>(mini*suz(3)))/suz(3)
				     WP1= (total(W0,2)>(mini*suz(2)))/suz(2)
				     WP2= (total(W0,1)>(mini*suz(1)))/suz(1)
				     W0 ={A:WP0,B:WP1,C:WP2,T:WT,N:WN,I:WI,E:WE,PXZ:total(WP0,2),PYZ:total(WP0,1),$
				          SIZ:suz,XTIT:xtit,YTIT:ytit,ZTIT:ztit,XXR:xxr,YYR:yyr,ZZR:zzr,TH:thresh}
				     endelse
		endif

		if n_elements(p) gt 3 then begin
		   tmp=fltarr(2,2)
		   col=(indgen(nlv/2)+1)*10 + 50
			scale3, xrange=[0,W0.siz(1)-1], yrange=[0,W0.siz(2)-1], zrange=[0,W0.siz(3)-1],ax=0.,az=0.
			t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , rz , 0. ]
			t3d,                   rot=[ rx , 0. , 0. ]
			t3d, tr=[+.5,+.5,+.5]
			kpn=!D.name
			if kpn ne wplot then set_plot,wplot
			set_shading,reject=0,values=[100,254]
			image=polyshade(v,p,/t3d,xsize=bst_x,ysize=bst_y)
			set_shading,reject=1
			if kpn ne wplot then set_plot,kpn
			!p.color=kpcol
			myproj,image,W0, smoo,f_dps, profile=did_repr(1), surf=did_repr(2)
			if did_repr(5) eq 1 then loo=' (Logn)' else loo=''
			other_tit(idn)='Threshold='+strtrim(string(thresh),2)+loo+'  Total volume:'+strtrim(string(W0.I),2)+loo + $
			               '  Npoints:'+strtrim(string(W0.N),2)
		endif

		endelse
	   endif
	endelse
       endif else begin
	  if wnumber  ne  '0'  then  w0=0
          if (htm_ok) then HtmW,idn, w0, xx, yy
          if (liveC)  then if siz(0) eq 2 then ii=execute('live_lamp_cont,w'+wnumber+',GROUP=lamp_b1,XX=xx,YY=yy,WI=idn'+ $
                                                             ',TIT=w_tit(idn),XTIT=x_tit(idn),YTIT=y_tit(idn)')
          if (liveA)  then if siz(0) eq 3 then ii=execute('live_lamp_anim,w'+wnumber+',GROUP=lamp_b1'+ $
							  ',TIT=w_tit(idn),smoo=smoo,surf=did_repr,az=rz,ax=rx')
       endelse

	if ps_ok then begin
		if (CODENS gt 0) then begin
			txt='liv_objet,WDRAW=d_cur,DIM=odim,MENUBAS=omen,L_MESS=baslb,WI=idn,PS="PS"'
			ii=EXECUTE(txt)
		endif else begin
			if b_labins(3) ne 1 then begin
				P_DID_PS_HEADER, pdph , idn ,psFile
				!P.COLOR=keepcol
				errps=0
			endif
			if errps eq 1 then begin errps=0 & device,/close_file & endif
			set_plot,wplot
			if  b_labins(3)  ne 1 then tvlct , cur_r , cur_g , cur_b
			widget_control,bad_id=i,l_mess,set_value= psFile+' updated ...'
		endelse
	endif
	IfPsErr:if errps eq 1 then begin errps=0 & device,/close_file & set_plot,wplot
			           if  b_labins(3)  ne 1 then tvlct , cur_r , cur_g , cur_b & endif

	if l_mess gt 0 then $
	if htm_ok	then widget_control,bad_id=i,l_mess,set_value='lamp.htm updated ...' else $
	if rrr eq 7	then widget_control,bad_id=i,l_mess,set_value='lamp.wrl updated ...'

	if (liveT eq 0) and (rrr ne 7) and (not htm_ok) and (not liveC) and (not liveA) then begin
	  if (CODENS eq -1) or (isurf) or (siz(0) eq 3)  then begin
		!p.title   =w_tit(idn)
		if (CODENS ne 0) or (isurf) then !p.subtitle=strmid(other_tit(idn),0,100)
		if (CODENS le 0) then plot,[0,0],/nodata,xstyle=4,ystyle=4,/noerase
	   	flgsurf    =[0,rz,idn]
		endif

	  if (not ps_ok) then begin
	     if (b_labins(3) ne 1) and (!D.name ne 'Z') then $
	     if (redraw eq 0) and (l_message gt 0) and (CODENS le 0) then begin
	      widget_control,bad_id=i,d_cur,set_uvalue=long ([-88,390,b_cur,fix(string_w),d_cur,w_cur,xo,yo,$
						       bst_x,bst_y,vfl(0),vfl(1),vfl(2),vfl(3),isurf,$
						       w_order,axy,baslb,xof,yof,did_repr(5)])

	      if ((did_fu eq 0) and (GEORGE ne 0)) then WebDo,'dws',1,0,0
	     endif
	  endif

	  trap_current=w_cur
	  trap_x1=vfl(0) & trap_x2=vfl(1) & trap_y1=vfl(2) & trap_y2=vfl(3) & trap_ws=string_w

	  if ((b_labins(3) eq 2) or (gif_ok)) then begin
		if (CODENS gt 0) then begin
			txt='liv_objet,WDRAW=d_cur,DIM=odim,MENUBAS=omen,L_MESS=baslb,WI=idn,PS="GIF"'
			ii=EXECUTE(txt)
		endif else begin
			r=0 & buf=tvrdd(r,g,b)
			if png_ok then giffile='lamp.png' else giffile='lamp.gif'
			if n_elements(r) le 1 then WRITE_KIF,giffile,buf else WRITE_KIF,giffile,buf, r,g,b
			if gif_ok then widget_control,bad_id=i,l_mess  ,set_value=giffile+' updated ...'
		endelse
	  endif
	  if scr_ok then begin
	     if fu_out eq 0 then  p_did_event,0,[-88,350,0,-1,0,0,0,0,0] $
	     else begin
	     	widget_control,bad_id=i, bas_x,get_uvalue=kuv		;actual modop (screen,gif,ps)
	     	widget_control,bad_id=i, bas_x,set_uvalue= 1		;set to screen
		widget_control,bad_id=i, bas14,get_uvalue=scr_uv	;get uv of "print to" button
		p_did_event,0 ,scr_uv
	     	widget_control,bad_id=i, bas_x,set_uvalue=kuv		;restore modop
	     endelse
	  endif
	  if fu_out eq 1 then begin
	     if  (not ps_ok) and (not gif_ok) and (not scr_ok) and ((b_labins(3) eq 0)   or $
	        ((!D.name eq "X") and  (b_labins(3) eq 1))) or (turn gt 2) then widget_control,bad_id=i,wbeside(0),map=1 $
	     else if (new ne 0)   and (!D.name ne 'Z')                     then widget_control,bad_id=i,wbeside(0),/destroy
	  endif
	endif

	vfl(*)     =-1
	did_repr(1)= keeprp1
	!p.title   =''
	!p.subtitle=''
	!x.title   =''
	!y.title   =''
	!z.title   =''
	!z.range   = 0
    endif
return
end

PRO myreduce, idx, xx,yy,zz,ee,nn,vv
;** ********
		    if n_elements(ee) eq n_elements(xx) then ee=ee(idx)
		    if n_elements(nn) eq n_elements(xx) then nn=nn(idx)
		    if (size(vv))(0)  eq 1 then $
		    if n_elements(vv) eq n_elements(xx) then vv=vv(idx)
	    	    xx=xx(idx) & yy=yy(idx) & zz=zz(idx)

		    if (size(vv))(0)  eq 2 then begin
		        for i=0,(size(vv))(2)-1 do begin idv=where(idx eq vv(0,i)) & vv(0,i)=idv(0)
			       if idv(0) ge 0 then begin idv=where(idx eq vv(1,i)) & vv(1,i)=idv(0)
			                                 if idv(0) lt 0 then vv(0,i)=-1  & endif
			endfor
			idv=where(vv(0,*) ge 0) & if idv(0) ge 0 then vv=vv(*,idv) else vv=0
		    endif
end

PRO myproj , image ,W0 ,smoo, f_dps, profile=profile, surf=surf
;** ******
;**
;**image= byte shaded volume
;**W0.A = total(data,3)
;**W0.B = total(data,2)
;**W0.C = total(data,1)
;**smoo = smooth flag 1 or 0
;**f_dps= 1 or PS factor

sizm= size(image)
x   =(size(W0.A))(1) & y=(size(W0.A))(2) & z=(size(W0.B))(2)
surface,image,xrange=[0,x], yrange=[0,y], zrange=[0,z],/nodata,/t3d,/sav,$
        xmargin=[0,0],ymargin=[0,0]

k=x & i=y & x=x-1 & y=y-1 & z=z-1   & ym1=1 & ym2=1 & ym3=1
M=0 & MM1=0 & MM2=0 & MM3=0 & dd1=0 & dd2=0 & dd3=0

 coom=[[0,0,0],[0,i,0],[k,i,0],[k,0,0]]

 dd1=round(convert_coord([0,0,x,x],[0,y,y,0],[0,0,0,0],/data,/t3d,/to_device)/f_dps)
 ya =dd1(1,2)  + dd1(1,1)
 yb =dd1(1,3)  + dd1(1,0)
 yc =dd1(1,0)  + dd1(1,1)
 yd =dd1(1,2)  + dd1(1,3)
 if (dd1(1,0) eq dd1(1,2)) or (dd1(0,0) eq dd1(0,2)) then $
 if (dd1(1,0) eq dd1(1,1)) or (dd1(0,0) eq dd1(0,1)) then ym1=0

if ya gt yb then $
 dd2=round(convert_coord([0,0,x,x],[i,i,i,i],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if ya le yb then $
 dd2=round(convert_coord([0,0,x,x],[0,0,0,0],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if (dd2(1,0) eq dd2(1,2)) or (dd2(0,0) eq dd2(0,2)) then $
if (dd2(1,0) eq dd2(1,1)) or (dd2(0,0) eq dd2(0,1)) then ym2=0
if  dd2(1,0) gt dd2(1,1) then up =1 else up =0 ;We may redo dd1 with z=[z,z,z,z]

if yd gt yc then $
 dd3=round(convert_coord([k,k,k,k],[0,0,y,y],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if yd le yc then $
 dd3=round(convert_coord([0,0,0,0],[0,0,y,y],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if (dd3(1,0) eq dd3(1,2)) or (dd3(0,0) eq dd3(0,2)) then $
if (dd3(1,0) eq dd3(1,1)) or (dd3(0,0) eq dd3(0,1)) then ym3=0

if (profile and (not surf))  then begin ym1=0 & ym2=0 & ym3=0 & endif

if ym1 then begin
 XX1=reform(dd1(0,*)) & YY1=reform(dd1(1,*))
 XI =[0,0,x,x]
 YI =[0,y,y,0]
 POLYWARP, XI, YI, XX1, YY1, 1, KX, KY
 MM1= POLY_2D(sqrt(W0.A), KX, KY,smoo,sizm(1),sizm(2),missing=0)
endif

if ym2 then begin
 XX2=reform(dd2(0,*)) & YY2=reform(dd2(1,*))
 XI =[0,0,x,x]
 YI =[0,z,z,0]
 POLYWARP, XI, YI, XX2, YY2, 1, KX, KY
 MM2= POLY_2D(sqrt(W0.B), KX, KY,smoo,sizm(1),sizm(2),missing=0)
endif

if ym3 then begin
 XX3=reform(dd3(0,*)) & YY3=reform(dd3(1,*))
 XI =[0,0,y,y]
 YI =[0,z,z,0]
 POLYWARP, XI, YI, XX3, YY3, 1, KX, KY
 MM3= POLY_2D(sqrt(W0.C), KX, KY,smoo,sizm(1),sizm(2),missing=0)
endif

if ym2 then M=fix(bytscl(MM2))
if ym3 then M=fix(bytscl(MM3))+M

idx=where(image ne 0)>0
if up then begin
	if (size(M))(0) eq 2 then M(idx)=image(idx) else M=image
	idx=where (MM1 ne 0)
	if idx(0) ge 0 then M(idx)=bytscl(MM1 (idx))
endif else begin
	if ym1 then M=M+bytscl(MM1)
	if (size(M))(0) eq 2 then M(idx)=image(idx) else M=image
endelse

if (size(M))(0) eq 2 then TVscl,M, xsize=sizm(1)*f_dps, ysize=sizm(2)*f_dps

!p.color=!p.color>250
if (up) then f=0 else f=z+1
plots,[0,k,k,0,0],[0,0,i,i,0],[f,f,f,f,f],/data,/t3d	;upper plan

bid=min(dd1(1,*),my) & cyc=coom(0:1,my)
oy=(my+1) mod 4      & coc=coom(0:1,oy)
ay=(my+2) mod 4      & cac=coom(0:1,ay)
uy=(my+3) mod 4      & cuc=coom(0:1,uy)
plots,[cyc(0),cyc(0)],[cyc(1),cyc(1)],[z+1,0],/data,/t3d	;three verticales
plots,[coc(0),coc(0)],[coc(1),coc(1)],[z+1,0],/data,/t3d
plots,[cuc(0),cuc(0)],[cuc(1),cuc(1)],[z+1,0],/data,/t3d

if up then f=z+1 else f=0
; plots,[cac(0),cac(0)],[cac(1),cac(1)],[z,0],/data,/t3d,linestyle=1	;back corners
; plots,[coc(0),cac(0),cuc(0)],[coc(1),cac(1),cuc(1)],[f,f,f],/data,/t3d,linestyle=1
; plots,[cuc(0),cyc(0),coc(0)],[cuc(1),cyc(1),coc(1)],[f,f,f],/data,/t3d

if ya gt yb then axis,0,0,f,xax=0,/data,/t3d,xrange=[W0.xxr(0),W0.xxr(x)],font=-1,charsize=2.5,xtitle=W0.xtit $
            else axis,0,i,f,xax=1,/data,/t3d,xrange=[W0.xxr(0),W0.xxr(x)],font=-1,charsize=2.5,xtitle=W0.xtit
if yd gt yc then axis,0,0,f,yax=0,/data,/t3d,yrange=[W0.yyr(0),W0.yyr(y)],font=-1,charsize=2.5,ytitle=W0.ytit $
            else axis,k,0,f,yax=1,/data,/t3d,yrange=[W0.yyr(0),W0.yyr(y)],font=-1,charsize=2.5,ytitle=W0.ytit

vert=coc ; if dd1(1,oy) lt dd1(1,uy) then vert=cuc
verv=[W0.zzr(0),W0.zzr(z/3),W0.zzr(z*2/3),W0.zzr(z)]
if ya gt yb then axis,vert(0),vert(1),0,zax=1,/data,/t3d,zrange=[W0.zzr(0),W0.zzr(z)],font=-1,charsize=2.5,zticks=3,ztickv=verv,ztitle=W0.ztit $
            else axis,vert(0),vert(1),0,zax=0,/data,/t3d,zrange=[W0.zzr(0),W0.zzr(z)],zticks=3,ztickv=verv,ztitle=W0.ztit

if (profile)  then begin
    px=W0.PXZ-min(W0.PXZ) & py=W0.PYZ-min(W0.PYZ)
    px=px/max(px)*z       & py=py/max(py)*z
    if ya gt yb then h=0 else h=i
    plots,indgen(k),intarr(k)+h,px,/t3d,/data
    if yd gt yc then h=0 else h=k
    plots,intarr(i)+h,indgen(i),py,/t3d,/data

    if up then h=0. else h=1.
    nlv=6 & col=(indgen(nlv)+1)*(255/nlv)
    contour,(W0.A<(W0.TH)),/t3d,nlevels=nlv,/noerase,zvalue=h,c_colors=col,xmargin=[0,0],ymargin=[0,0],$
                   xticks=1,yticks=1,xtickname=[' ',' '],ytickname=[' ',' ']
endif
end

pro setcol, n
;** ******
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    if (n ge 0) and (n lt 40) then begin loadct,n & tcol=n & endif

return
end
pro trapx,w_res
;** ****  *****
    trap, w_res , 2
return
end
pro trapy,w_res
;** ****  *****
    trap, w_res , 1
return
end
pro trapt,w_res
;** ****  *****
    trap, w_res , 3
return
end
pro trapp,w_res
;** ****  *****
    trap, w_res , 4
return
end
pro trap, w_res ,flag
;** ****  *****  ****
;**
;** Get last zoomed workspace into w_res (c.a.d alone)
;** Flag=0 then return array
;** Flag=1 then return total(array,1)
;** Flag=2 then return total(array,2)
;** Flag=3 then return total(array)
;** Flag=4 then print  total(array)

@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

    if (trap_x1 ge  0) or (trap_y1 ge 0) then $
    if  trap_ws gt '0' then begin
	if trap_x1 ge 0 then sx=strtrim(string(trap_x1),2) + ':' + $
				strtrim(string(trap_x2),2) $
			else sx='*'
	if trap_y1 ge 0 then sy=strtrim(string(trap_y1),2) + ':' + $
				strtrim(string(trap_y2),2) $
			else sy='*'

	siz=[0L] & ii=execute( 'siz=size(w'+trap_ws+')' )
	tx =''
	if siz(0) eq 1 then tx='('+sx+')'
 	if siz(0) eq 2 then tx='('+sx+','+sy+')'

	fl=0
 	nl=n_elements(flag) & if nl eq 1 then fl=flag

	if fl eq 4 then begin w_res=0.
	    ii=execute( 'w_res=total(w'+trap_ws+tx+')' )
	endif else if (alone gt 0) and (alone le lamp_sys) then begin
	    ws='W'+strtrim(string(alone),2)
	    xfor=ws +'=W'+trap_ws+tx & XICUTER,xfor
	    if fl gt 0 then begin
		if fl eq 1 then xicuter, ws +'=total('+ws+',1)'
		if fl eq 2 then xicuter, ws +'=total('+ws+',2)'
		if fl eq 3 then xicuter, ws +'=total('+ws+  ')'
	    endif
	endif
;	For xicute recursivity
	one=-1
	two= 0
   endif
return
end

pro positive, w_in
;** ********
;**
;** Transform an integer*2 unsigned array in a long positive one.
;** Call: W1 = POSITIVE ( W1 )

    s=size(w_in)
    if s(s(0)+1) eq 2 then begin

        index=where ( w_in lt 0 )

        w_in       =long  (temporary(w_in))

        if index(0) ge 0 then w_in(index)=65536+ w_in(index)

    endif
end

;*************************************** Process Create Multi  ***************************
;*************************************** Process Create Multi  ***************************
;*************************************** Process Create Multi  ***************************
pro p_did_multi_cre, widx
;** ***************
;**
;** Create the Multi_Plot interface.
return
end

;*************************************** Process Create begood ***************************
;*************************************** Process Create begood ***************************
;*************************************** Process Create begood ***************************

pro p_did_create_begood, widx ,rx ,nlv ,smoo ,styles ,did_repr
;** *******************
;**
;** Make a UI to change titles and general settings.
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

    i=xregistered('BEGOOD')
    if i le 0 then begin
	if widx le 0 then widx=1
	beg_wid=widx
	beg_t  =lonarr(5)
	if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

	beg_id	=widget_base  (title='Lamp Begood settings',/column,resource_name='lampdon')

;**	TITLES
	btmp0	=widget_base  (beg_id,/column,/frame)
	btmp	=widget_base  (btmp0 ,/row)
	bg_updat=widget_button(btmp  ,value='Update new titles',font=ft_b_normal  ,uvalue=[-88,361,0])
	bg_slid =widget_slider(btmp  ,title='WK_Space titles'  ,font=ft_b_normal,$
				      xsize=200,minimum=1,maximum=lamp_sys,value=beg_wid,uvalue=[-88,362,0])
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(0)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Main Title'       ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='w_tit(i)'         ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(1)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Sub Title'        ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='other_tit(i)'     ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(2)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='X   Title'        ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='x_tit(i)'         ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(3)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Y  Title'         ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='y_tit(i)'         ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(4)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Z Title'          ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='z_tit(i)'         ,font=ft_smallest)

;**	GENERAL SETTINGS
	btmp0	=widget_base  (beg_id,/column,/frame)
	btmp11	=widget_base  (btmp0 ,/row)

	btmpa0	=widget_base  (btmp11,/column)
	btmp2t	=widget_base  (btmpa0,/row)
	btmp1t	=widget_label (btmp2t,value='GENERAL SETTINGS' ,font=ft_b_bigger)
	btmp10	=widget_base  (btmpa0,/column,/frame)
	btmp	=widget_label (btmp10,value='... SURFACE ...'  ,font=ft_b_normal)
	btmpb0  =widget_base  (btmp10,/column,/exclusive)
	btmps=lonarr(7)
	btmps(1)=widget_button(btmpb0,value='Shading based on intensities'  ,font=ft_normal,/no_release,$
							uvalue=[-88,366,1])
	btmps(2)=widget_button(btmpb0,value='Shading from Wk_Space W10 "'   ,font=ft_normal,/no_release,$
							uvalue=[-88,366,2])
	btmps(3)=widget_button(btmpb0,value='Shading from a light source'   ,font=ft_normal,/no_release,$
							uvalue=[-88,366,3])
	btmps(4)=widget_button(btmpb0,value='Wire mesh' 		    ,font=ft_normal,/no_release,$
							uvalue=[-88,366,4])
	btmps(5)=widget_button(btmpb0,value='Box style' 		    ,font=ft_normal,/no_release,$
							uvalue=[-88,366,5])
	btmps(6)=widget_button(btmpb0,value='Vectors' 			    ,font=ft_normal,/no_release,$
							uvalue=[-88,366,6])
	btmpr	=widget_base  (btmp10,/row)
	btmp	=widget_label (btmpr ,value='View Angle'       ,font=ft_normal)
	beg_view=widget_text  (btmpr ,value=strtrim(string(rx),2),/editable ,font=ft_b_normal,$
							uvalue=[-88,365,0]  ,xsize=4+cap,ysize=1)
	btmpn	=widget_base  (btmpr,/nonexclusive)
	btmpvr	=widget_button(btmpn ,value='VRML' 		,font=ft_normal,$
							uvalue=[-88,368,0])

	btmp10 =widget_base   (btmpa0,/row,/frame)
	btmp	=widget_label (btmp10,value='.. PLOT ..'  ,font=ft_b_normal)
	btmpb0  =widget_base  (btmp10,/nonexclusive,/row)
	btmphi  =widget_button(btmpb0,value='Histogram',font=ft_normal,uvalue=[-88,366,7])
	btmpna  =widget_button(btmpb0,value='noAxes'   ,font=ft_normal,uvalue=[-88,366,9])

	btmp0a	=widget_base  (btmp11,/column)
	btmp0i	=widget_base  (btmp0a,/row,/frame)
	btmp	=widget_label (btmp0i,value='... IMAGE ...'  ,font=ft_b_normal)
	btmpbi  =widget_base  (btmp0i,/nonexclusive)
	btmpsi  =widget_button(btmpbi,value='Smooth',font=ft_normal,uvalue=[-88,366,8])

	btmp01	=widget_base  (btmp0a,/column,/frame)
	btmp	=widget_label (btmp01,value='... CONTOUR ...'  ,font=ft_b_normal)
	btmp0b  =widget_base  (btmp01,/column,/exclusive)
	btmpct1	=widget_button(btmp0b,value='Using annotations ' 	    ,font=ft_normal,/no_release,$
							uvalue=[-88,367,1])
	btmpct2	=widget_button(btmp0b,value='Using colors lines'            ,font=ft_normal,/no_release,$
							uvalue=[-88,367,2])
	btmpr	=widget_base  (btmp01,/row)
	btmp	=widget_label (btmpr ,value='Levels nb'        ,font=ft_normal)
	beg_lev =widget_text  (btmpr ,value=strtrim(string(nlv),2),/editable,font=ft_b_normal,$
							uvalue=[-88,365,1]  ,xsize=4+cap,ysize=1)
	btmpn	=widget_base  (btmpr,/nonexclusive)
	btmpsp	=widget_button(btmpn ,value='Scan pref' 		    ,font=ft_normal,$
							uvalue=[-88,368,1])

	btmp01	=widget_base  (btmp0a,/column,/frame)
	btmp	=widget_label (btmp01,value='... PROJECTIONS ...'  	    ,font=ft_b_normal)
	btmp0b  =widget_base  (btmp01,/column,/exclusive)
	btmpp   =lonarr(5)
	btmpp(1)=widget_button(btmp0b,value='Frames' 		            ,font=ft_normal,$
							uvalue=[-88,369,1])
	btmpp(2)=widget_button(btmp0b,value='Using polygons'                ,font=ft_normal,$
							uvalue=[-88,369,2])
	btmpp(3)=widget_button(btmp0b,value='Sum dimensions (box)'          ,font=ft_normal,$
							uvalue=[-88,369,3])
	btmpp(4)=widget_button(btmp0b,value='Showing maximum values'        ,font=ft_normal,$
							uvalue=[-88,369,4])
	widget_control,btmpp(2),sensitive=0
	widget_control,btmpp(4),sensitive=0
;	btmp11	=widget_label (btmp0 ,value=' ')
	btmp11	=widget_base  (btmp0 ,/row)
	btmp	=widget_label (btmp11,value='Default PostScript DEVICE:'    ,font=ft_b_normal)
	beg_dev =widget_text  (btmp11,xsize=15,ysize=1, uvalue=[-88,364,0]  ,font=ft_b_bigger,/editable,$
							 value=lamp_devps)

	bg_done =widget_button(btmp11,value='Done'    , uvalue=[-88,363,0]  ,font=ft_b_bigger)
		 put_logo     ,btmp11

	p_did_begood_getitle

   	bid=sys_dep      ('DYNLAB',beg_id,0)
	widget_control,beg_id,group_leader=lamp_b1,/realize & put_logo

        if !P.psym eq 10    then widget_control,btmphi   ,bad_id=i,set_button=1
        if smoo    eq  1    then widget_control,btmpsi   ,bad_id=i,set_button=1
        ix=styles(0,0)>1<6    &  widget_control,btmps(ix),bad_id=i,set_button=1
        if did_repr(14)     then widget_control,btmpna   ,bad_id=i,set_button=1
        if styles(1,0) eq 1 then widget_control,btmpct1  ,bad_id=i,set_button=1
        if styles(1,0) eq 2 then widget_control,btmpct2  ,bad_id=i,set_button=1
        if styles(0,1) eq 1 then widget_control,btmpvr   ,bad_id=i,set_button=1
        if styles(1,1) eq 1 then widget_control,btmpsp   ,bad_id=i,set_button=1
        ix=styles(2,0)>1<4    &  widget_control,btmpp(ix),bad_id=i,set_button=1

	XMANAGER, 'BEGOOD' ,beg_id,event_handler='LAMP_EVENT_PARSER',/just_reg

    endif else widget_control,bad_id=i,beg_id,map=1
return
end

pro p_did_begood_getitle
;** ********************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,beg_t(0),set_value= w_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(1),set_value= other_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(2),set_value= x_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(3),set_value= y_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(4),set_value= z_tit	(beg_wid)
return
end

pro p_did_begood_setitle
;** ********************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,beg_t(0),get_value= txt & w_tit    (beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(1),get_value= txt & other_tit(beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(2),get_value= txt & x_tit	   (beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(3),get_value= txt & y_tit	   (beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(4),get_value= txt & z_tit	   (beg_wid)=txt(0)
return
end

pro p_did_begood_updat
;** ******************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	p_did_begood_setitle
return
end

pro p_did_begood_slide,ev
;** ******************
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,ev.id,get_value=wi
	if beg_wid ne wi then p_did_begood_setitle
	beg_wid=wi
	p_did_begood_getitle
return
end

pro p_did_begood_nlv, nlv
;** ****************
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	level=12
	widget_control,bad_id=i,beg_lev,get_value=level
	slv=strcompress(level(0),/remove_all)
	on_ioerror,mislv
	nlv=fix(slv)
	mislv:
return
end


pro p_did_begood_ax, rx
;** ***************
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	angle=60
	widget_control,bad_id=i,beg_view,get_value=angle
	srx=strcompress(angle(0),/remove_all)
	on_ioerror,misrx
	rx=fix(srx)
	misrx:
return
end

pro p_did_begood_devps
;** ******************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,beg_dev,get_value=txt
	lamp_devps=strcompress(txt(0),/remove_all)
return
end

pro p_did_begood_done, rx ,nlv
;** *****************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev
	p_did_begood_setitle
	p_did_begood_ax,  rx
	p_did_begood_nlv, nlv
	p_did_begood_devps
	widget_control,bad_id=i,beg_id,map=0
	widget_control,bad_id=i,beg_id,/destroy
return
end

;
;*************************************** Process Save Wi *********************************
;*************************************** Process Save Wi *********************************
;*************************************** Process Save Wi *********************************

pro p_did_save_reset
;** ****************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
sav_uv=0
end

pro p_did_save_menu,widx
;** ***************
;**
@lamp.cbk
;
; Make a menu list to save workspace
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
    common c_savt,	sav_tab ,sav_tap,sav_forp,sav_m

    if (sys_dep('VERSION') ge 5.4) then kif='Png' else kif='Gif'

    sav_tab=['hdf','xml','Ascii','xdr','F77','htm']
    sav_tap=['Tiff','Bmp',kif,'Pict'] ; sav_tap=['Tiff','Bmp','Gif','Jpeg','Pict']
    sav_tab=[sav_tab,lamp_wrti,sav_tap]   &   sav_tap=[lamp_wrtp,sav_tap]
    if n_elements(sav_forp) eq 0 then sav_forp=7
    if widx eq -1 then return

    P_GET_DATAPATH, sav_pthv

    i=xregistered('SAVE_MENU')
    if i gt 0 then widget_control,bad_id=i,(sav_b+0),/destroy
    n= n_elements(limtxt)
    if n gt 0 then begin
      sav_idx=-1
      if n_elements(sav_form) le 0 then sav_form=5
      dat=systime()
      sav_file=strmid(dat,8,2) + strmid(dat,4,3)
      sav_file=strcompress(sav_file,/remove_all)
      num=strcompress(w_numor(widx),/remove_all)
      if num ne '' then sav_file=num
      p_did_save_seq
      if sav_seq gt 0 then seq='_'+strtrim(string(sav_seq),2) else seq=''
      sav_b=widget_base  (title='Lamp Save a Workspace',/column,resource_name='lampdon')
      list =widget_list  (sav_b,font=ft_b_bigger,uvalue=[-88,371,0],$
      					        value=limtxt,ysize=n<17,/frame)
      btmp =widget_label (sav_b,value='           ')

      btmp =widget_base  (sav_b,/row)
      none =widget_button(btmp,uvalue=[-88,399,0],value= 'DONE ')
      s_ok =widget_button(btmp                   ,value=' SAVE ',font=ft_b_normal)
      bf   =widget_label (btmp,                   value='   Output File :')
      sav_f=widget_text  (btmp,font=ft_b_bigger, $
      			       uvalue=[-88,373,0],value=sav_file+seq,xsize=20,ysize=1,/editable)
      b_ico=widget_base  (sav_b,/row)
	    put_logo	 ,b_ico
      sav_l=widget_label (b_ico,font=ft_b_normal,value=string(replicate(95b,40)))

      form =widget_label (sav_b,value=' LAMP FORMAT (Web is default, hdf is NeXus)',font=ft_b_bigger)
      formb=widget_base  (sav_b,/row)
      form =widget_base  (formb,/row,/exclusive)
      bt   =lonarr(8)
      bt(0)=widget_button(form ,uvalue=[-88,372,0],/no_release,value='hdf'       ,font=ft_b_normal)
      bt(1)=widget_button(form ,uvalue=[-88,372,1],/no_release,value='xml'       ,font=ft_b_normal)
      bt(2)=widget_button(form ,uvalue=[-88,372,2],/no_release,value='Ascii')
      bt(3)=widget_button(form ,uvalue=[-88,372,3],/no_release,value='xdr (Bin)' ,font=ft_b_normal)
      bt(4)=widget_button(form ,uvalue=[-88,372,4],/no_release,value='F77')
      bt(5)=widget_button(form ,uvalue=[-88,372,5],/no_release,value='htm'       ,font=ft_b_normal)
      bt(6)=widget_button(form ,uvalue=[-88,372,6],/no_release,value='-->'       ,font=ft_b_normal)
      sav_m =widget_button(formb,uvalue=[-88,372,7],    menu=2 ,value=sav_tab(sav_forp))
      FOR i=7,n_elements(sav_tab)-1 do $
       ptmp=widget_button(sav_m,uvalue=[-88,372,i]            ,value=sav_tab(i)  ,font=ft_b_normal)

      btmp =widget_base  (sav_b,/row)
      lpth =widget_label (btmp,value=' Save Path:',font=ft_b_normal)
      bpth =widget_text  (btmp,value=sav_pthv,font=ft_b_bigger,xsize=40,ysize=1,/editable)

      bid=sys_dep      ('DYNLAB',sav_b,0)
      widget_control,sav_b,group_leader =lamp_b1,/realize & put_logo
      widget_control,bt(sav_form<6),bad_id=i,set_button=1
      if sys_dep('VERSION') lt 5.0 then widget_control,bt(0),bad_id=i,sensitive =0

      XMANAGER, 'SAVE_MENU' ,sav_b,event_handler='LAMP_EVENT_PARSER',/just_reg

      pixm =widget_base  (title='Save Icon',map=0)
      pixd =widget_draw  (pixm,retain=2,xsize=192,ysize=192)
      widget_control,pixm ,group_leader=sav_b ,/realize
      widget_control,pixd          ,bad_id=i  ,get_value=pixw

      widget_control,s_ok          ,bad_id=i,set_uvalue=[-88,374,bpth,pixw,192,192,pixm]

      if (widx gt 0) and (widx le lamp_sys) then begin sav_idx=0
						 for i=0,n_elements(limtxt)-1 do begin
	    						wi=fix(strmid(limtxt(i),1,2))
	    						if wi eq widx then sav_idx=i
	    					 endfor
						 widget_control,list,bad_id=i,SET_LIST_SELECT=sav_idx
      endif
    endif
return
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro write_kif,file,image,r,g,b ,TRANSPARENT=trans
;** *********
;**
;** Used for compatibilty with Idl versions.

catch,stat & if stat ne 0 then begin catch,/cancel & print,!err_string & return & endif

ver =sys_dep('VERSION') & png=0 & gif=0 & jpg=0 & img=0
fifi=strlowcase(file)
idx =strpos(fifi,'.gif')
if idx gt 0 then gif=1 else begin
	idx=strpos(fifi,'png')  & if idx gt 0 then png=1 else begin
		idx=strpos(file,'img') & if idx gt 0 then img=1 else jpg=1
		endelse & endelse

pnt =strmid(file,idx+3,5)

if (ver lt 5.2) and (png) then begin file=strmid(file,0,idx)+'jpg'+pnt & jpg=1 & png=0 & endif
if (ver ge 5.4) and (gif) then begin file=strmid(file,0,idx)+'.png'    & png=1 & gif=0 & endif

if jpg then write_jpeg,file,image
if png then if (ver lt 5.4) then imag2=reverse(image,2) else imag2=image
if png then if n_elements(trans) gt 0 then if n_elements(r) gt 1 then $
				           write_png ,file,imag2 ,r,g,b ,TRANSPARENT=[trans] else $
				           write_png ,file,imag2        ,TRANSPARENT=[trans] $
				      else if n_elements(r) gt 1 then $
				           write_png ,file,imag2 ,r,g,b else $
				           write_png ,file,imag2

if gif then if n_elements(r)     gt 1 then write_gif ,file,image ,r,g,b $
				      else write_gif ,file,image
if img then begin
	      out=-1 & on_ioerror,mispixf
	      OPENW,out, file,/GET_LUN & WRITEU  ,out,image
	      mispixf:if out gt 0 then   FREE_LUN,out
endif
end

pro read_kif ,file,image ,sx,sy
;** ********
;**
;** Used for compatibilty with Idl versions.

catch,stat & if stat ne 0 then begin catch,/cancel & print,!err_string & return & endif

ver =sys_dep('VERSION') & png=0 & gif=0 & jpg=0 & img=0
fifi=strlowcase(file)
idx =strpos(fifi,'.gif')
if idx gt 0 then gif=1 else begin
	idx=strpos(fifi,'png')  & if idx gt 0 then png=1 else begin
		idx=strpos(file,'img') & if idx gt 0 then img=1 else jpg=1
		endelse & endelse

pnt =strmid(file,idx+3,5)

if (img) and (n_elements(sx) eq 0) then begin gif=1 & img=0 & endif
if (ver lt 5.2) and (png) then begin file=strmid(file,0,idx)+'jpg'+pnt & jpg=1 & png=0 & endif

if (ver ge 5.4) and (gif) then begin image=0 & print,'!! GIF read not implemented...' & return & endif
if (ver lt 5.2) and (png) then begin image=0 & print,'!! PNG read not implemented...' & return & endif

if jpg then read_jpeg,file,image,COLORS=!D.n_colors-1
if png then image=read_png(file)
if png then if (ver lt 5.4) then image=reverse(image,2)
if gif then read_gif ,file,image
if img then begin
	     in=-1 & on_ioerror,mispixm & image=bytarr(sx,sy)
	     OPENR,in,file,/GET_LUN     & READU   ,in,image
	     mispixm:if in  gt 0   then   FREE_LUN,in
endif
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro write_lamp,file, w=wi ,fmt=fmt ,format=format, path=patho
;** **********
;**
common c_savt,	sav_tab ,sav_tap, sav_forp,sav_m

auto=0
if (n_elements(wi) eq 1) and (n_elements(file) eq 1)  then $
if (wi gt 0)  and (file gt ' ')         then begin auto=1
					if n_elements(fmt)    eq 1 then p_did_save_format,fmt
					if n_elements(patho)  ne 1 then patho=""
					if n_elements(format) eq 1 then begin
					   p_did_save_menu,-1
					   idx=where(strlowcase(sav_tab) eq strlowcase(format))
					   if idx(0)  ge  0	   then p_did_save_format,idx(0)
					endif
					p_did_save_auto,wi,patho,file,auto & endif
if auto eq 0 then print,string(7b)+'file not saved ...!'
return
end

pro HtmW, wi ,w,x,y
;** ****
;**
@lamp.cbk
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
	if n_elements(w) gt 1 then begin
		kpw=0. & kpx=0. & kpy=0.  & ws=strtrim(string(wi),2)
		ii=execute('kpw=w'+ws)    & ii=execute('kpx=x'+ws)
		ii=execute('kpy=y'+ws)
		ii=execute('w'+ws+'=w') & ii=execute('x'+ws+'=x')
		ii=execute('y'+ws+'=y') & endif
	sav_form=5
	if (GEORGE ne 0) then WebDo,'pth',wpth
	if wpth eq '' then fif='lamp' else fif='geo_d_12htm.web'
	P_DID_SAVE_AUTO, wi,wpth,fif,1
	if (GEORGE ne 0) then WebDo,'fil',fif

	if n_elements(w) gt 1 then begin
		ii=execute('w'+ws+'=kpw') & ii=execute('x'+ws+'=kpx')
		ii=execute('y'+ws+'=kpy') & endif
end

pro p_did_WebIda, inst,year,cycl,runs,furm, patho, rep
;** ************
;**
@lamp.cbk
    common c_WebTouch , wtweb, wtinst, wtyear, wtcycl, wtfile, wtcn, wtrep, wtrop, wtroot, wtpath
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

	if n_elements(wtinst) eq 0 then begin	wtinst="" & wtyear="" & wtcycl="" & wtrop=""
	                                        wtfile="" & endif
	if (wtinst ne   inst) or (wtyear ne year) or (wtcycl ne cycl) then begin
		RDSET,  inst=inst, base="C_Year "+year, cycle=cycl
		wtinst =inst & wtyear=year & wtcycl=cycl & wtfile=inst+"_"+cycl+"_"
		endif

	for i=0,n_elements(runs)-1 do begin
		fils  = strtrim(string(runs(i)),2)
		status= 1
		catch,stat & if stat eq 0 then P_DID_GETRUN, runs(i) ,1, status else catch,/cancel
		to_don_history, 1,0,'W1=RDRUN('+fils+') ;'+inst+"_"+cycl
		if (status eq 0) then begin
			status=1
			px=strpos(fils,'.') & if px gt 0 then fils=strmid(fils,0,px)

			WRITE_LAMP,wtfile+fils, w=1 ,format=furm, path=patho
		endif
	endfor
end

pro p_did_WebTouch, inst,year,cycl,runs,prun, wi, rep
;** **************
;**
@lamp.cbk
    common c_WebTouch , wtweb, wtinst, wtyear, wtcycl, wtfile, wtcn, wtrep, wtrop, wtroot, wtpath
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

	if n_elements(wtinst) eq 0 then begin	wtinst="" & wtyear="" & wtcycl="" & wtrop="" & endif
	if (wtinst ne   inst) or (wtyear ne year) or (wtcycl ne cycl) then begin
		RDSET,  inst=inst, base="C_Year "+year, cycle=cycl
		wtinst =inst & wtyear=year & wtcycl=cycl & wtfile=inst+"_"+cycl+"_"
		wtpath ="/var/www/htdocs/BARNS/UserZone/Commons/TOUCH_BASE"
		wtpath =sys_dep ('NEWSUB',wtpath ,wtyear)	  & wtroot=wtyear
		ii=findfile(wtpath,count=cnt) & if cnt eq 0 then ii=sys_dep('MKDIR',wtpath)
		wtpath =sys_dep ('INSUB' ,wtpath ,wtinst)	  & wtroot=wtroot+"/"+wtinst+"/"
		ii=findfile(wtpath,count=cnt) & if cnt eq 0 then ii=sys_dep('MKDIR',wtpath)
		endif
	wtrep=rep
	path =wtpath
	chang=""
	wci  = wi & if wci le 0 then wci=1
	WS   ="w" + strtrim(string(wci),2) & sizw=[0L]
	tab=runs
	for j=1b,2 do begin
	if  tab(0) gt 0 then $
	for i=0,n_elements(tab)-1 do begin
		fils  = strtrim(string(tab(i)),2) ; or flto6(tab(i))
		file  = wtfile+fils
		status= 0
		cnti  = 0
		iii   = findfile(path+file+".htm",count=wtcn)
		fili  = file+"_"+wtrep
		if wtcn gt 0 then iii= findfile(path+fili+".png",count=cnti)
		if cnti eq 0 then begin
			if wi le 0 then begin 	status= 1
			   catch,stat & if stat eq 0 then P_DID_GETRUN, tab(i) ,wci, status else catch,/cancel
			   to_don_history, wci,0,WS+'=RDRUN('+fils+') ;'+inst+"_"+cycl
			endif
			if (status eq 0) and (wtrep ne "i") then begin
				ii=execute('sizw=size('+WS+')')
				if sizw(0) eq 1 then begin wtrep ="i" & chang =" i" & fili = file+"_"+wtrep & endif
				if sizw(0) eq 2 then if (wtrep eq 'pz') or (wtrep eq 'lz') then begin
				   			    wtrep ="i" & chang =" i" & fili = file+"_"+wtrep & endif
				if (wtrep eq "i") and (wtcn gt 0) then begin
						iii= findfile(path+fili+".png",count=cnti)
						if cnti gt 0 then status=-1 & endif
			endif
			if status eq 0 then begin
				if (wi le 0) and (wtrep ne wtrop) then begin
					if wtrep eq "s" then begin setcol,3  & tvlct,100,100,100,0 & endif else $
					if wtrep eq "c" then begin setcol,5  & tvlct,100,100,100,0 & endif $
					                else begin setcol,27 & tvlct,160,160,160,0 & endelse
					wtrop=wtrep & endif
				sav_form=5
				P_DID_SAVE_AUTO, wci,path,file,1
				endif
		endif
		if status gt 0 then fili=file+"_failed"
		if wi le 0 then print,"WT "+wtroot+fili+" complete ",j,chang
	endfor
	tab=prun
	endfor
	wtcn=0
end

pro p_did_save_auto, widx,path,file, auto
;** ***************
;**
;** auto =-1 auto save without  data (return -2 for 'imgR')
;** auto = 1 auto save with the data
@lamp.cbk
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

    if widx gt lamp_sys+3 then return
    sav_idx = widx
    for i =0,n_elements(limtxt)-1 do   begin
	wi=fix(strmid(limtxt(i),1,2))
	if wi eq widx then sav_idx=i & endfor
    sav_pthv= path
    sav_file= file
    if auto eq -1		 then sav_form=3
    if n_elements(sav_form) eq 0 then sav_form=5
    sav_seq = 0
    if n_elements(sav_uv) lt 6 then begin
	 sav_uv=[long(0),0,0,0,192,192]
	     if (!D.flags and 65536) ne 0 then begin
      		pixm  =widget_base  (title='Save Icon',map=0)
      		pixd  =widget_draw  (pixm,retain=2,xsize=sav_uv(4),ysize=sav_uv(5))
      		widget_control,pixm ,group_leader=lamp_b1 ,/realize
      		widget_control,pixd ,bad_id=i  ,get_value=pixw
      		sav_uv(3)=pixw
	     endif
    endif
    if !D.name eq 'Z' then device,set_resolution=[192,192]
    p_did_save_work, 0, sav_uv ,auto
return
end

pro p_did_save_work, event,uv ,auto
;** ***************
;**
;** auto = 0 save from interface
;** auto =-1 auto save without  data (return -2 for 'imgR')
;** auto = 1 auto save with the data
@lamp.cbk

    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
    common c_savt,	sav_tab ,sav_tap,sav_forp,sav_m
    common c_WebTouch , wtweb, wtinst, wtyear, wtcycl, wtfile, wtcn, wtrep, wtrop, wtroot, wtpath
;
; Save a workspace from menu list
on_ioerror,mis
out=-1

	if (sav_idx ge 0) and (sav_idx lt n_elements(limtxt)) then begin
	    wi=fix(strmid(limtxt(sav_idx),1,2))

	    if (wi ge 1) and (wi le lamp_sys) then begin
		if auto eq 0  then begin p_did_save_filename,0 & wtrep='-1' & endif
		if n_elements(wtcn) eq 0 then begin wtcn=0     & wtrep='-1' & endif
		wkstring=strtrim(string(wi),2)
		sizw=[0L] & sizx=[0L] & sizy=[0L] & sizp=[0L] & sizi=[0L] & sizn=[0L]
		i  =execute('sizw=size(w' + wkstring + ')' )
		i  =execute('sizx=size(x' + wkstring + ')' )
		i  =execute('sizy=size(y' + wkstring + ')' )
		i  =execute('sizp=size(p' + wkstring + ')' )
		i  =execute('sizi=size(e' + wkstring + ')' )
		i  =execute('sizn=size(n' + wkstring + ')' )

		if sizw(0) gt 0 then begin
		   if sav_form eq 5 then begin sav_form=3 & wtweb=1 & endif else wtweb=0
		   if (sizx(1) ne sizw(1))  then $
		   		i=execute('x'+wkstring+'=lindgen(sizw(1))+1')
		   if (sizy(sizy(0)+2) ne sizw(sizw(0)+2)) then $
		   if (sizy(1) ne sizw(2))  then $
		   if (sizy(2) ne sizw(2))  then $
		   		i=execute('y'+wkstring+'=lindgen(sizw(2))+1')
		   if  sizp(0) ne 1 then $
				i=execute('p'+wkstring+'=[0]')
		   if (sizi(0) lt 1) and (sizi(1) lt 1) then $
				i=execute('e'+wkstring+'=[0]')
		   if (sizn(0) lt 1) and (sizn(1) lt 1) then $
				i=execute('n'+wkstring+'=[0]')

		   fltr=''
		   if (not wtweb and strpos(sav_file,'_LAMP') lt 0) then fltr='_LAMP' else sav_seq=0

		   if auto eq 0 then begin
		      widget_control,/hourglass
		      widget_control,bad_id=i,uv(2),get_value=pth
		      sav_pthv=sys_dep      ('BLANKS',pth(0))
		      if sav_pthv ne '' then begin
		       car=strmid(sav_pthv,strlen(sav_pthv)-1,1)
		       if (car ne lamp_dvd) then sav_pthv=sav_pthv+lamp_dvd
		      endif
		      p_did_save_seq
		   endif
		   if sav_seq gt 0 then seq='_'+strtrim(string(sav_seq),2) else seq=''

;*****		   ***********************************************************Forms 0 1 2 3 4
		   if (sav_form le 4) then begin
			xx=[1L] & yy=[1L] & zz=[1L] & nn=[0L] & pv=[0L] & ee=[0L]
		   	i=execute('xx = x' +wkstring)
		   	i=execute('yy = y' +wkstring)
		   	i=execute('zz = z' +wkstring)
		   	i=execute('nn = n' +wkstring)
		   	sizn= size(nn)
		   	i=execute('pv = pv'+wkstring)
		   	i=execute('ee = e' +wkstring) & sizi=size(ee)
			sx=sizw(1)
			if sizw(0)  gt 1 then sy=sizw(2) else sy=long(1)
			if sizw(0)  gt 2 then sz=sizw(3) else sz=long(1)
			symod=sy

			if sav_form eq 0 then ext =fltr+'.hdf'
			if sav_form eq 1 then ext =fltr+'.xml'
			if sav_form eq 2 then ext =fltr+'ascii'
			if sav_form eq 3 then $
				if wtweb then ext =fltr+'.xdr' $
					 else ext =fltr+'xdr'
			if sav_form eq 4 then ext =fltr+'f77'

			if not wtweb then ii=sys_dep('POT',ext)
			doe=''
			if  sizi(sizi(0)+2) eq sizw(sizw(0)+2)	then begin c=0L & maxw=0.
				i  =execute('maxw=max(w' + wkstring + ',c)' ) & maxe=ee(c)
				sqr=sqrt(maxw)
				if  sqr          eq maxe then doe='sqrt(i)'       else $
				if  sqr/ maxw    eq maxe then doe='sqrt(i)/ i'    else $
				if  sqr/(maxw+1) eq maxe then doe='sqrt(i)/(i+1)' $
				else     if (not wtweb) or (auto eq 0) then doe='file'
			endif
;****			**********************Write data and header
			if wtcn eq 0 then begin

			if auto ge 0 then begin
;***		Data  file
			 if sav_form eq 4 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun,/F77 else $
			 if sav_form eq 3 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun,/XDR else $
			 if sav_form eq 2 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun      else $
		;	 if sav_form eq 1 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun      else $
			 if sav_form eq 1 then begin & end
			 if sav_form eq 0 then begin & end

			 if sav_form gt 1 then begin
			 if sav_form ne 2 then i=execute('writeu,out,w' + wkstring)
			 if sav_form eq 2 then begin
			       if sy gt 1 then i=execute('printf,out,w' + wkstring) $
			       else begin      symod=0 &  ww=0.
			       		       if (sizi(1) ne sx) then ee=bytarr(sx)
			      		       i=execute('ww = w' +wkstring)
			      		       for i=0,sx-1 do printf,out,xx(i),ww(i),ee(i)
			       		       endelse
			  endif
			  free_lun,out
			 endif
			 if wtweb then begin  ii=sys_dep('ZIP',sav_file+seq+ext,sav_pthv)
					      if ii then  ext='.zip'   & endif
;***		Error file
			 if   sav_form gt 1 then begin
		   	 if   doe eq 'file' then $
		   	 if ((sav_form ne 2) or (sy gt 1)) $
		   	 		    and (sav_form ne 0) then begin  eet=ext+'_e'
			  if sav_form eq 4 then openw,out,sav_pthv+sav_file+seq+eet  ,/get_lun,/F77 else $
			  if sav_form eq 3 then openw,out,sav_pthv+sav_file+seq+eet  ,/get_lun,/XDR $
					   else openw,out,sav_pthv+sav_file+seq+eet  ,/get_lun
			  if sav_form ne 2 then i=execute('writeu,out,ee')
			  if sav_form eq 2 then i=execute('printf,out,ee')
			  free_lun,out
		   	 endif else doe=''

		   	 endif;sav_form gt 1
			endif ;auto ge 0
			;**********************End Write data
;***		Header file
			machine=sys_dep   ('MACHINE')
			if n_elements(histxt) gt sav_idx then histoire=histxt(sav_idx) else histoire=' '
			limxt  =limtxt(sav_idx)
		   	src    =head_tit  (fix (wkstring),2)

			out=-1
			if wtweb then exss=".htm" $
				 else begin exss=fltr & ii=sys_dep('POT',exss) & endelse

			if sav_form eq 3 then exs='png' else exs='img'

			if wtweb then begin exs='.png'
				if (sys_dep('VERSION') lt 5.4) and (!D.Name eq 'Z') then exs='.gif'
				if wtrep ne '-1' then exs="_"+wtrep+exs else exs=wtrep+exs
			endif else ii=sys_dep  ('POT',exs)

			if sav_form eq 1 then form='Binary'
			if sav_form eq 2 then form='Ascii'
			if sav_form eq 3 then form='XDR'
			if sav_form eq 4 then form='F77 unformatted'
			tiip=sizw(sizw(0)+1) ;+newtypes*****
			case  tiip of
			   1: tip='(1 )Byte'
			   2: tip='(2 )Short Integer'
			   3: tip='(3 )Long Integer'
			   4: tip='(4 )Floating'
			   5: tip='(5 )Double Floating'
			   6: tip='(6 )Complex'
			   7: tip='(7 )String'
			   8: tip='(8 )Structure'
			   9: tip='(9 )Double Complex'
			   10:tip='(10)Pointer'
			   11:tip='(11)Object'
			   12:tip='(12)Unsigned Integ'
			   13:tip='(13)Unsigned Long'
			   14:tip='(14)Long Int64'
			   15:tip='(15)Unsigned Int64'
			else:tip='(0) Undefined'
			endcase
      			npa=0L & npv=[0L]
      			bb=execute('npa=n_elements(p' +wkstring+')' )
      			bb=execute('npv=size      (pv'+wkstring+')' )
     			i  =0
       			bb=execute('for i=0,npa-1 do par_txt_all(i)=strtrim(par_txt(fix(wkstring),i))+string(p' $
      						   +wkstring + '(i))')
			if (sizn(0) eq 2) then if (sizn(1) eq sx) and (n_elements(nn) gt sx) then begin
				j=sizn(2)-1
				k=1
				for i=sizn(2)-1,1,-1 do if (k and max(nn(*,i)) eq 0) then j=j-1 else k=0
				if j lt sizn(2)-1 then  begin nn=nn(*,0:j) & sizn=size(nn) & endif
			endif
		   	ttl=w_tit     (fix (wkstring))
		   	ttx=x_tit     (fix (wkstring))
		   	tty=y_tit     (fix (wkstring))
		   	ttz=z_tit     (fix (wkstring))
		   	tto=other_tit (fix (wkstring))
			A_ac=""
			trf =""
			apl =""
			if wtweb then if (sy gt 1) and (sz le 1) then begin	A_type=strtrim(string(tiip)	,2)
										A_sx  =strtrim(string(sx )	,2)
										A_sy  =strtrim(string(sy )	,2)
										A_x0  =strtrim(string(xx(0))	,2)
										A_x1  =strtrim(string(xx(1))	,2)
										A_xn  =strtrim(string(xx(sx-1))	,2)
										A_y0  =strtrim(string(yy(0))	,2)
										A_y1  =strtrim(string(yy(1))	,2)
										A_yn  =strtrim(string(yy(sy-1))	,2)
										A_fl  =sav_file+seq+ext
									;	A_fl  =strmid(A_fl,strpos(A_fl,"/BARNS"),100)
										A_ac  ="Exec" & if sav_file eq 'lamp' then A_ac ="Start"
										A_wht ='300'  & if sav_file eq 'lamp' then A_wht='30'
			 apl='<APPLET Codebase= "http://barns.ill.fr/BARNS/GRAPH/V3D/classes/"' +$
			 ' Code="V3D.class" archive="V3D.jar" Width= '+A_wht+' Height= 70>'     +$
			 '<PARAM Name="Action"   Value="'+A_ac+'">'  +$
			 '<PARAM Name="User"     Value="$BarnsUser">'+$
			 '<PARAM Name="CGI"      Value="/cgi-bin/barns/nph-barns?Application=#WebLamp+-nws">'+$
 			 '<PARAM Name="File"     Value="'+A_fl+'">'  +$
			 '<PARAM Name="Format"   Value="xdr">'+$
			 '<PARAM Name="Type"     Value="'+A_type+'">'+$
			 '<PARAM Name="Title"    Value="'+ttl+'">'+$
			 '<PARAM Name="TitleX"   Value="'+ttx+'">'+$
			 '<PARAM Name="TitleY"   Value="'+tty+'">'+$
			 '<PARAM Name="SubTitle" Value="'+tto+'">'+$
			 '<PARAM Name="NbX"      Value="'+A_sx+'">'+$
			 '<PARAM Name="X0"       Value="'+A_x0+'">'+$
			 '<PARAM Name="X1"       Value="'+A_x1+'">'+$
			 '<PARAM Name="Xn"       Value="'+A_xn+'">'+$
			 '<PARAM Name="NbY"      Value="'+A_sy+'">'+$
			 '<PARAM Name="Y0"       Value="'+A_y0+'">'+$
			 '<PARAM Name="Y1"       Value="'+A_y1+'">'+$
			 '<PARAM Name="Yn"       Value="'+A_yn+'"></APPLET>'
			endif
			if wtweb then trf='<br>Get vrml !'+ $
					  '<br><a href="'+sav_file+seq+ ext+'" >Get Data (bin zipped) !</a>'+ $
					  apl+'<br><br><pre>'

			if sav_form gt 1 then begin
			openw,out,sav_pthv+sav_file+seq+exss,/get_lun

			printf,out,'<html><head><title>LAMP_FORMAT ' + systime()+'</title></head><body><img align =right src="'+sav_file+seq+fltr+exs+'"><b>'
			printf,out,' HEADER FILE written by the LAMP APPLICATION</b>'+trf
			printf,out,' '

			if auto ge 0 then  begin
			printf,out,' '
			printf,out,' DATA_FILE:      ' + sav_file +seq+ ext
			if src ne '' then $
			printf,out,' SOURCE:         ' + src
			endif

			if doe eq 'file' then if auto ge 0 then doe=sav_file +seq+ ext+'_e' else doe=''
			if doe ne ''     then begin
			printf,out,' ERRO_FILE:      ' + doe
			printf,out,' '
			endif

			printf,out,' HISTORY:        ' + histoire
			printf,out,' '
			printf,out,' X_SIZE:         ' + strtrim(string(sx)   ,2)
			printf,out,' Y_SIZE:         ' + strtrim(string(symod),2)
			printf,out,' Z_SIZE:         ' + strtrim(string(sz)   ,2)
			printf,out,' FORMAT:         ' + form
			printf,out,' TYPE:           ' + tip
			printf,out,' '

			if A_ac ne "Start" then begin

			printf,out,' MIN,MAX VALUES: ' + limxt
			printf,out,' '
			printf,out,' TITLES: ' + ttl
			if ttx ne '' then $
			printf,out,'      X: ' + ttx
			if tty ne '' then $
			printf,out,'      Y: ' + tty
			if ttz ne '' then $
			printf,out,'      Z: ' + ttz
			if tto ne '' then $
			printf,out,'  OTHER: ' + tto
			printf,out,' '
			printf,out,' PARAMETERS:'
			n=npa-1
			if n gt 0 then $
			printf,out,' ----------'
			if n gt 0 then for i=0,n do printf,out,' * '+  par_txt_all(i)
			printf,out,' '

			if npv(0) ge 1 then begin
			    tmp=strtrim(string(npv(1)),2)
			    if npv(0) gt 1 then tmp=tmp+' '+strtrim(string(npv(2)),2) else tmp=tmp+' 0'
			    if npv(0) gt 2 then tmp=tmp+' '+strtrim(string(npv(3)),2) else tmp=tmp+' 0'
			    printf,out,' VAR PARAM: nb='   +tmp
			    printf,out,' ---------                        (hidden)</pre><!--'
			    printf,out, pv
			    printf,out,'                                  --><pre>'
			endif

			if (long(xx(0)) eq xx(0)) and (xx(sx-1)-xx(0) eq sx-1) then begin
			    printf,out,' X_COORDINATES:'+string(xx(0))+' --> X size'
			    printf,out,' '
			endif else begin
			    sizx=size(xx) & if sizx(0) eq 2 then tmp=' bi_dim' else tmp=''
			    printf,out,' X_COORDINATES: '+ tmp
			    printf,out,' -------------                    (hidden)</pre><!--'
			    printf,out, xx
			    printf,out,'                                  --><pre>'
			endelse

			if (long(yy(0)) eq yy(0)) and (yy(sy-1)-yy(0) eq sy-1) and (sizw(0) gt 1) then begin
			    printf,out,' Y_COORDINATES:'+string(yy(0))+' --> Y size'
			    printf,out,' '
			endif else begin
			    sizy=size(yy) & if sizy(0) eq 2 then tmp=' bi_dim' else tmp='nb='+string(n_elements(yy))
			    printf,out,' Y_COORDINATES: '+ tmp
			    printf,out,' -------------                    (hidden)</pre><!--'
			    printf,out, yy
			    printf,out,'                                  --><pre>'
			endelse

			sizz=n_elements(zz)
			if (sizz gt 1) or (zz(0) ne 0) then begin
			 if sizz eq 1 then begin
			    printf,out,' Z_COORDINATES: '+string(zz(0))
			    printf,out,' '
			 endif else begin
			    printf,out,' Z_COORDINATES: nb='+string(sizz)
			    printf,out,' -------------                    (hidden)</pre><!--'
			    printf,out, zz
			    printf,out,'                                  --><pre>'
			 endelse
			endif

			if sizn(0) lt 1 then tmp='1' else tmp=strtrim(string(sizn(1)),2)
			if sizn(0) gt 1 then tmp=tmp+' '+strtrim(string(sizn(2)),2) else tmp=tmp+' 0'
			if sizn(0) gt 2 then tmp=tmp+' '+strtrim(string(sizn(3)),2) else tmp=tmp+' 0'
			printf,out,' MONITORS: nb='   +tmp
			printf,out,' --------                             </pre><!--'
			if (sizn(0) gt 2) or (sizn(0) le 1) then printf,out, nn $
			else		 for i=0,sizn(2)-1 do printf,out, nn(*,i)
			printf,out,'                                      --><pre>'

			if (not wtweb and auto eq 0) then begin

			printf,out,' MACHINE: ' + machine
			printf,out,'                                      </pre><!--'
			printf,out,' HOW TO READ THE DATA (example)'
			printf,out,' --------------------'
			printf,out,' USING IDL'
			printf,out,' ----- ---'
			if  symod    gt 0 then $
			printf,out,'        array = MAKE_ARRAY( xsize,ysize,zsize ,TYPE=code)'
			if  symod    eq 0 then $
			printf,out,'        array = MAKE_ARRAY( 3 , xsize ,TYPE=code)'
			printf,out,' '
			if (sav_form eq 1) or (sav_form eq 2) then $
			printf,out,'        OPENR,  unit, "'+sav_file+seq+ext +'" ,/GET_LUN'
			if  sav_form eq 3 then $
			printf,out,'        OPENR,  unit, "'+sav_file+seq+ext +'" ,/GET_LUN,/XDR'
			if  sav_form eq 4 then $
			printf,out,'        OPENR,  unit, "'+sav_file+seq+ext +'" ,/GET_LUN,/F77_UNFORMATTED'
			printf,out,' '
			if (sav_form ne 2)  then $
			printf,out,'        READU,  unit, array'
			if sav_form eq 2 then $
			printf,out,'        READF,  unit, array'
			printf,out,' '
			printf,out,' USING FORTRAN'
			printf,out,' ----- -------'
			if sav_form eq 2 then begin
			   if sy gt 1    then begin
			   	printf,out,'        REAL array(xsize,ysize,zsize)'
			   	printf,out,'        OPEN(unit=20,status="old",file="'+sav_file+seq+ext+'")'
			   	printf,out,'        READ(20,*) array'
			   endif else begin
			   	printf,out,'        REAL*4 x(xsize) , y(xsize) , e(xsize)'
			   	printf,out,'        OPEN(unit=20,status="old",file="'+sav_file+seq+ext+'")'
			   	printf,out,'        DO i=1,xsize'
			   	printf,out,'           READ(20,*) x(i),y(i),e(i)'
			   	printf,out,'        ENDDO'
			   endelse
			endif
			if (sav_form ne 2)   then begin
			   if tiip eq 1 then printf,out,'        BYTE array(xsize,ysize,zsize)'
			   if tiip eq 2 then printf,out,'        INTEGER*2 array(xsize,ysize,zsize)'
			   if tiip eq 3 then printf,out,'        INTEGER*4 array(xsize,ysize,zsize)'
			   if tiip eq 4 then printf,out,'        REAL*4 array(xsize,ysize,zsize)'
			   if tiip eq 5 then printf,out,'        DOUBLE PRECISION array(xsize,ysize,zsize)'
			   if tiip eq 6 then printf,out,'        COMPLEX array(xsize,ysize,zsize)'
			   if tiip eq 9 then printf,out,'        DOUBLE COMPLEX array(xsize,ysize,zsize)'
			   if sav_form eq 1 then printf,out,'        OPEN(unit=20,status="old",file="' $
			   			+sav_file+seq+ext+'",form="unformatted",' $
			   			+'recl=xsize*ysize*zsize,access="direct")'
			   if sav_form eq 3 then printf,out,'        OPEN(unit=20,status="old",file="' $
			   			+sav_file+seq+ext+'",form="xdr")'
			   if sav_form eq 4 then printf,out,'        OPEN(unit=20,status="old",file="' $
			   			+sav_file+seq+ext+'",form="unformatted")'

			   printf,out,'        READ(20) array'
			endif
			printf,out,'                                  --><pre>'
			endif		;not wtweb and auto eq 0

			endif		;A_ac="Start"

			printf,out,'</body></html>'
			free_lun,out
			out=-1
			endif		;sav_form gt 1
			endif		;wtcn eq 0
;****			**********************End Write data and header

;****			**********************Write Snapshot or HDF or XML file
			if (uv(3) gt 0) or (!D.name eq 'Z') then begin
;			Icone
;			-----
			kpDname=!D.name	;or pixmap in uv(3) but problems with true colors...
			set_plot, 'Z' & device,set_resolution=[uv(4),uv(5)]
			if auto ne -1 then erase
			if sav_form le 1 then wr=1 else  wr=0
			if wtrep eq '-1' then wttr='s' else wttr=wtrep

			p_did_makeicon, wkstring,xx,yy, uv(4),uv(5) ,auto ,wr ,wttr

			if auto ne -1 then begin worder=!order & !order=0
						 if (sav_form gt 1) and (not wtweb) then !order=1
						 wr=tvrd(0,0,uv(4),uv(5))
						 !order=worder & endif
			set_plot,kpDname

			if n_elements(wr) eq 1 then exs='imgR' else if sav_form eq 3 then exs='png' else exs='img'
			if wtweb then begin exs='.png'
				if (sys_dep('VERSION') lt 5.4) and (!D.Name eq 'Z') then exs='.gif'
				if wtrep ne '-1' then exs="_"+wtrep+exs else exs=wtrep+exs
			endif    else ii=sys_dep  ('POT',exs)
			ftxt=sav_pthv+sav_file+seq+fltr+exs

			if (sav_form le 1) then  begin fi=sav_file+seq+ext & ptfi=sav_pthv+fi
			    if sav_form eq 0 then pcm='write_hdf' else pcm='write_xml'
			    cmd= pcm +  ',ptfi,w'+wkstring+',xc=xx,yc=yy'              + $
			                ',zc=zz,e=ee,par_txt_all=par_txt_all'          + $
			                ',pr=p'+wkstring+',pv=pv,n=nn,w_tit=ttl'       + $
			                ',x_tit=ttx,y_tit=tty,z_tit=ttz,other_tit=tto' + $
			                ',SRC=src,HIST=histoire,LIM=limxt,MACH=machine'+ $
			                ',DOE=doe,SNAP=wr,DATE=head_tit(wi,4),FIFI=fi'
			    err=execute(cmd)
			endif else begin
			    if n_elements(wr) eq 1 then begin
				OPENW,out,ftxt,/get_lun,/XDR
				i=execute('WRITEU,out,fix(sx),fix(sy),fix(tiip),w' + wkstring)
				FREE_LUN,out   &  out=-1
				if save_form ne 3 then auto=-2
				if auto le -1 then bid=sys_dep('DO_Z',sav_pthv+sav_file+seq+fltr+exs,lamp_dir)
				auto=-2
			    endif else begin
				if (sav_form eq 3) then begin tvlct,r,g,b,/get
				                 WRITE_KIF,ftxt,wr,r,g,b, transparent=[0]
					         if (wtweb) and (strpos(ftxt,'gif') gt 0) then ii=sys_dep('GIFTRANS',ftxt)
				endif else begin WRITE_KIF,ftxt,wr
				if auto le -1 then bid=sys_dep('DO_Z',sav_pthv+sav_file+seq+fltr+exs,lamp_dir)
				endelse
			    endelse
			endelse
		        endif
;****			********************** End Write Snapshot or HDF or XML

		     if (auto eq 0) or ((sav_form ne 3) and (b_labins(3) ne 0)) then begin
			   text='W'+wkstring+ ' saved in '+sav_file+seq+ext
		           if wtweb then text=text + ' (& .htm)'
			   p_did_setwin0
			   if auto eq 0 then widget_control,bad_id=i,sav_l,set_value=text $
					else print ,text
			   text='WRITE_LAMP,"'+sav_pthv+sav_file+seq+'",w='+wkstring
			   to_don_history,-1,-1,text
		     endif
		   endif
;*****		   ***********************************************************End Forms 0 1 2 3 4
		   if (auto ge 0) and (sav_form ge 7)  then begin

		    proced=sav_tap(sav_form-6) & ptfi=sav_pthv+sav_file+seq & s=sizw(0) & err=88

		    if (proced eq 'Tiff') and (s eq 2) then begin ext='.tiff'
			  if sys_dep('VERSION') ge 5.2 then begin
				keywrd=',compression=1'
				tiip  =  sizw(sizw(0)+1) ;+newtypes*****
				if tiip  eq 2 then keywrd=keywrd+',/short'
				if tiip  eq 3 then keywrd=keywrd+',/long'
				if tiip  eq 4 then keywrd=keywrd+',/float'
				err=execute('write_tiff,ptfi+ext,w'+wkstring+keywrd )
			  endif else begin
				err=execute('write_tiff,ptfi+ext,bytscl(w'+wkstring +')')
				if err ne 1 then $
				err=execute('tiff_write,ptfi+ext,bytscl(w'+wkstring +')')
			  endelse
		    endif else $
		    if (proced eq 'Gif')  and (s eq 2) then begin
				if (sys_dep('VERSION') ge 5.4) then ext='.png' else ext='.gif'
				err=execute('WRITE_KIF ,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Bmp')  and (s eq 2) then begin ext='.bmp'
				err=execute('write_bmp ,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Jpeg') and (s eq 2) then begin ext='.jpg'
				err=execute('write_jpeg,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Png')  and (s eq 2) then begin ext='.png'
				err=execute('write_png ,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Pict') and (s eq 2) then begin ext='.pict'
				err=execute('write_pict,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else  begin ext=''
		     err=execute(proced+',ptfi,w'+wkstring+',xc=x'+wkstring+',yc=y'+wkstring+ $
		                 ',zc=z'+wkstring+',e=e'  +wkstring+',par_txt=par_txt(wi,*)'+ $
		                 ',pr=p'+wkstring+',pv=pv'+wkstring+',n=n'+wkstring         + $
		                 ',w_tit=w_tit(wi),x_tit=x_tit(wi),y_tit=y_tit(wi)'         + $
		                 ',z_tit=z_tit(wi),other_tit=other_tit(wi)')
		    endelse

		    if auto eq 0 then if err eq 1 then $
		    widget_control,bad_id=i,sav_l,set_value='W'+wkstring+' is saved in '+sav_file+seq+ext

		    if err eq 88 then begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Workspace not a 2D array!!!'
				print,string(7b)
		    endif
		   endif
		   if wtweb then sav_form=5

		endif else begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Workspace is not an array!!!'
				print,string(7b) & endelse
	    endif else begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Choose a Workspace !!!'
				print,string(7b) & endelse
	endif else begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Choose a Workspace !!!'
				print,string(7b) & endelse
return
mis:				if auto eq 0 then widget_control,bad_id=i,sav_l,set_value=!err_string $
					     else print,!err_string
				print,string(7b)
				if out gt 0 then free_lun,out
				auto=0
				if wtweb then sav_form=5
return
end

pro p_did_makeSnap, wi
;** **************
;**
@lamp.cbk
common c_did
common c_trap
	ws=strtrim(string(wi),2)
		if n_elements(Snapix) eq 0 then Snapix=0
		if Snapix eq 0 then begin
			aa=64L & bb=32L
      			byd=widget_base  (title='',map=0)
      			bid=widget_draw  (byd,retain=2,xsize=aa,ysize=bb * 21)
       			widget_control   ,byd,bad_id=i , /realize
      			widget_control   ,bid,bad_id=i , get_value=Snapix
      			byd=widget_base  (title='',map=0)
      			bid=widget_draw  (byd,retain=2,xsize=aa,ysize=bb)
       			widget_control   ,byd,bad_id=i , /realize
      			widget_control   ,bid,bad_id=i , get_value=Snapil
		endif
	ii=execute('p_did_makSnaps,w'+ws+', Sna'+ws+', Snapix, Snapil, did_tio, wi')
	trap_current=Snapil
end
pro p_did_makSnaps, w, s, Snapix, Snapil, dido, wi
;** **************
;**
aa=64L & bb=32L
kpwin=!window
if n_elements(s) eq 1 then begin
   if !D.name ne 'Z' then wset,Snapil & erase,255
   if n_elements(w) gt 1 then begin
	sz=size(w)
	if sz(0) eq 1 then begin s=congrid(w,sz(1)<100)
	                           plot,s,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4 & endif
	if sz(0) eq 2 then begin i=sz(1)<aa>(aa/2) & j=sz(2)<bb>(bb/2)
	                         s=congrid(w,i,j)
	                           tvscl,s,(aa-i)/2,(bb-j)/2 & endif
	if sz(0) eq 3 then begin i=sz(1)<aa>(aa/2) & j=sz(2)<bb>(bb/2) & k=sz(3)<40

				 if sys_dep('VERSION') ge 4.0 then ii=execute('s=transpose(congrid(w,i,j,k),[2,0,1])') $
				                              else s =congrid(w,i,j,k)

				 maxi=max (s,min=mini) & thresh=mini+(maxi-mini)/3.
				 shade_volume,s,thresh,v,p
				 if n_elements(p) gt 3 then begin
				   s={w:s,thresh:thresh,v:v,p:p}
				   scale3, xrange=[0,k-1], yrange=[0,i-1], zrange=[0,j-1],ax=0.,az=0.
				   t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , 20. , 0. ]
				   t3d,                   rot=[ 60., 0.  , 0. ]
				   t3d, tr=[+.5,+.5,+.5]
				   set_shading,reject=0 & tvscl,polyshade(v,p,/t3d) & set_shading,reject=1
				 endif else begin
	                           s=congrid(total(w,3),i,j)
 	                           tvscl,s,(aa-i)/2,(bb-j)/2 & endelse
	endif
  endif
  if !D.name ne 'Z' then begin wset,Snapix & device,copy=[0,0,aa,bb,0,bb*wi,Snapil] & endif
endif
if (dido ne 0) and (!D.name ne 'Z') then begin
	wset,abs(dido) & i=0 & j=0
	if dido gt 0 then begin i=32 & j=16 & erase,255 & endif
	device,copy=[0,bb*wi,aa,bb,i,j,Snapix]
endif
if kpwin gt 0 then if !D.name ne 'Z' then wset,kpwin
end

pro p_did_makefunc, w,w0, rep, ln
;** **************
;**
if (size(w))(0) lt 2 then rep='ln'
if (size(w))(0) eq 2 then if (rep eq 'pz') or (rep eq 'lz') then rep='i'

if rep eq 'px' then w0=      total(w,2)          else $
if rep eq 'py' then w0=      total(w,1)          else $
if rep eq 'pz' then w0=      total(w,3)          else begin ln=1
if rep eq 'lx' then w0=alog (total(w,2)>0 + 0.1) else $
if rep eq 'ly' then w0=alog (total(w,1)>0 + 0.1) else $
if rep eq 'lz' then w0=alog (total(w,3)>0 + 0.1) else $
if rep eq 'ln' then w0=alog (      w   >0 + 0.1) &  endelse
rep='i'
end

pro p_did_makeicon, wkstr,xx,yy, uv4,uv5 ,auto ,wr ,rup
;** **************
;**
;** auto = 0 save from interface
;** auto =-1 auto save without  data (no web)
;** auto = 1 auto save with the data
@lamp.cbk
common c_trap
		trap_current=!D.window
		ln=0   &  rep=rup  &  wkstring=wkstr  &  nlv=11 & sizw=[0L]

		i =execute('sizw=size(w'+wkstring+')') & if sizw(0) eq 1 then rup="i"

		if strlen(rep) gt 1 then begin
			i =execute('p_did_makefunc, w'+wkstring+',w0,rep,ln')
			wkstring='0' & endif
		i =execute('sizw=size(w'+wkstring+')')
		sx=sizw(1)
		if sizw(0)  gt 1 then sy=sizw(2) else sy=long(1)
		if sizw(0)  gt 2 then sz=sizw(3) else sz=long(1)

		xi=sx & yi=sy   & xo=sx*2/uv4 & yo=sy*2/uv5
		if yo ge xo then  fx=xo else fx=yo
		if fx gt 1  then  begin xi=(sx/fx)<uv4 & yi=(sy/fx)<uv5 & endif
		xo=(uv4-xi)/2 & yo=(uv5-yi)/2

		worder=!order & if not wr then !order=1

		if auto ne -1 then begin
		   if sz eq 1    then begin
			if sy eq 1 then begin
			      if n_elements(xx) gt 1 then $
			      	i=execute('plot,xx,w' + wkstring + ',xmargin=[5,0],ymargin=[3,0]') else $
			      	i=execute('plot   ,w' + wkstring + ',xmargin=[5,0],ymargin=[3,0]')
			endif
			if sy gt 1 then begin
			  if rep ne 's'   then begin tmw=0L
			    if rep eq 'c' then begin xi=sx<64  & yi=sy<64  & endif
			    if rep eq 'i' then begin xi=uv4 & yi=uv5
			                             if sy le sx/2 then yi=yi/2
			                             if sx le sy/2 then xi=xi/2
			                             xo=(uv4-xi)/2 & yo=(uv5-yi)/2 & endif
			    i=execute('tmw=congrid(w'+ wkstring + ',xi,yi,/interp)')
			    if ln eq 0 then begin
			       minx=min ( tmw ) & if minx le 0 then tmw=tmw-minx+0.1
			       tmw=alog  (temporary(tmw)) & endif
			    if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
			    i=execute('tmw=smooth(temporary(tmw),4'+edg+')')
			    tmw=bytscl(temporary(tmw))
			  endif
			    if (n_elements(xx) eq sx) and (n_elements(yy) eq sy) and (rep ne 'i') then begin
			      if (sx ne xi) or (sy ne yi) then begin six=size(xx) & siy=size(yy)
				 if six(0)  eq  2  then tmx=congrid(xx,xi,yi) else tmx=congrid(xx,xi)
				 if siy(0)  eq  2  then tmy=congrid(yy,xi,yi) else tmy=congrid(yy,yi)
			      endif
			      if (sx ne xi) or (sy ne yi) then begin
			         if rep eq 'c' then contour,tmw,tmx,tmy,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4, $
			                                 c_colors=(indgen(nlv)+1)*(180/nlv) + 50 ,nlevels=nlv $
				 else $
			         i=execute('shade_surf,congrid(w' + wkstring + ',xi,yi,/interp)' +$
			      		   ',tmx,tmy    ,xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' )
			      endif else $
			         if rep eq 'c' then contour,tmw,xx,yy,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4, $
			                                 c_colors=(indgen(nlv)+1)*(180/nlv) + 50 ,nlevels=nlv $
				 else $
			         i=execute('shade_surf,w' + wkstring + ',xx,yy,xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' )

			    endif else begin
			      if rep eq 'c' then contour,tmw,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4, $
			                                 c_colors=(indgen(nlv)+1)*(180/nlv) + 50 ,nlevels=nlv
			      if rep eq 'i' then tv,tmw,xo,yo else $
			      if (sx ne xi) or (sy ne yi) then $
			         i=execute('shade_surf,congrid(w' + wkstring + ',xi,yi,/interp)' +$
			      		   				     ',xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' ) $
			      else $
			         i=execute('shade_surf,w' + wkstring + ',      xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' )
			    endelse
			endif
		   endif
		   if sz gt 1    then begin
			   if (xi gt 60) and (yi gt 60)   then begin
			      if (sx ne xi) or (sy ne yi) then $
			         i=execute('tvscl,congrid(total(w' + wkstring + ',3),xi,yi),xo,yo') else $
			         i=execute('tvscl,        total(w' + wkstring + ',3)       ,xo,yo')
			   endif else $
			         i=execute('tvscl,congrid(total(w' + wkstring + ',3),uv4,uv5)')
		   endif
		endif else begin
			minx=w_min(fix(wkstring))
			wks ='w' + wkstring
			wr  =0.
			if sz eq 1    then begin
			  tip =sizw(sizw(0)+1) ;+newtypes*****
			  if tip lt  2 then nbyt=sx*sy   else if tip eq  2 then nbyt=sx*sy*2 else $
			  if tip le  4 then nbyt=sx*sy*4 else if tip eq 12 then nbyt=sx*sy*2 else $
			  if tip eq 13 then nbyt=sx*sy*4 else nbyt=sx*sy*8
			  if (nbyt+3*2 ge long(uv4)*uv5) and (sy gt 1) then begin
			   if minx le 0 then i =execute( 'wr=alog('+wks+'-minx+0.1)' ) $
			         	else i =execute( 'wr=alog('+wks+')' )
			   if sy eq 1 then begin
;			         wt=congrid(wr,uv4,/interp)
;			         if n_elements(xx) gt 1 then $
;			      	    plot,congrid(xx,uv4),wt,xmargin=[5,0],ymargin=[3,0],ytitle='log' $
;			      	 else plot,		 wt,xmargin=[5,0],ymargin=[3,0],ytitle='log'
;				 wr     =tvrd(0,0,uv4,uv5)
;			      	 wr(0,0)=bytscl(congrid(wt,uv4,2))
			   endif else wr=bytscl(congrid(temporary(wr),uv4,uv5,/interp))
			  endif
			endif else begin
			   if sx gt sy then begin i=execute('wr=reform(w'+wkstring+',sx,sy*sz)')
		      	        		  mini=w_min(fix(wkstring))
		      	       			  maxi=w_max(fix(wkstring))
			   endif else begin
			        if (sy gt sz) and (sy ne sx) then j=2 else j=3
			        i  =execute('wr=total(w' + wkstring + ',j)')
		  	        maxi =max(wr,min=mini)
		      	        w_min(fix(wkstring))=mini
		      	        w_max(fix(wkstring))=maxi
			   endelse

			   sizw=size(wr) & sx=sizw(1) & sy=sizw(2) & tip=sizw(sizw(0)+1)
			   if tip lt  2 then nbyt=sx*sy   else if tip eq  2 then nbyt=sx*sy*2 else $
			   if tip le  4 then nbyt=sx*sy*4 else if tip eq 12 then nbyt=sx*sy*2 else $
			   if tip eq 13 then nbyt=sx*sy*4 else nbyt=sx*sy*8 ;+newtypes*****

;			   if (nbyt+3*2 ge long(uv4)*uv5) then begin
			       if mini le 0 then wr=alog(temporary(wr)-mini+0.1) $
			         	    else wr=alog(temporary(wr))
			       wr=bytscl(congrid(temporary(wr),uv4,uv5,/interp))
;			   endif
			endelse
		endelse
		!order=worder
return
end

pro p_did_save_format, form
;** *****************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
    common c_savt,	sav_tab ,sav_tap,sav_forp,sav_m

    sav_form=form
    if form eq 6 then sav_form=sav_forp
    if form gt 6 then begin sav_forp=form
                      widget_control,bad_id=i,sav_m,set_value=sav_tab(form) & endif
return
end

pro p_did_save_list, event
;** ***************
;**
@lamp.cbk
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
	sav_idx=event.index
	if (sav_idx ge 0) and (sav_idx lt n_elements(limtxt)) then begin
	    wi=fix(strmid(limtxt(sav_idx),1,2))
	    if (wi ge 1) and (wi le lamp_sys) then begin
	    	num=strcompress(w_numor(wi),/remove_all)
	    	if num ne '' then begin
	    		widget_control,sav_f,bad_id=i,set_value=num
	    		sav_file=num
	endif & endif & endif
return
end

pro p_did_save_filename,event
;** *******************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

      widget_control,sav_f,bad_id=i,get_value=fname
      sav_file=sys_dep      ('BLANKS',fname(0))
      i=strpos(sav_file,'.')
      if i ge 0 then sav_file=strmid(sav_file,0,i)+'_'+strmid(sav_file,i+1,20)
return
end

pro p_did_save_seq
;** **************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

      sav_seq=0
      k=0
      res=findfile(sav_pthv+sav_file+'*',count=k)

      i=0
      while k gt 0 do begin i=i+1 & res=findfile(sav_pthv+sav_file+'_'+strtrim(string(i),2)+'*',count=k)
      		   endwhile
      sav_seq=i
return
end

;*************************************** Process Restore Wi ******************************
;*************************************** Process Restore Wi ******************************
;*************************************** Process Restore Wi ******************************
function read_tmp, INST , PATH , FILENAME , STATUS , DATP
;******* ********
;**
 DATA=dist(40)         & STATUS=0 &  pall=INDGEN(40,6)
 xv  =INDGEN(40)*2 +15 & wt=' Template_read test '
 par =[3.0,5.5]        & xt=' This is the X axis '
 ptxt=['First  parameter','Second parameter' ]
 DATP={X:xv,W_TIT:wt,X_TIT:xt,P:par,PAR_TXT:ptxt,PV:pall}
 return,DATA
end

pro read_lamp,file, w=wi, path=pth
;** *********
;**
@lamp.cbk
auto=-1
if (n_elements(wi) eq 1) and (n_elements(file) gt 0) then $
if (wi gt 0) and (wi le lamp_sys+3) and (file(0) gt ' ')   then begin
						     if n_elements(pth) ne 1 then pth=''
						     ws=strtrim(string(wi),2) & fil=file
		   				     if (strpos(file(0),'_LAMP') lt 0) and $
						        (strpos(file(0),'.htm' ) lt 0) and $
						        (strpos(file(0),'.xml' ) lt 0) and $
						        (strpos(file(0),'.nxs' ) lt 0) and $
						        (strpos(file(0),'.hdf' ) lt 0)  then fil(0)=fil(0)+'_LAMP'
						     p_did_restore_wrk,fil,pth,ws,'',auto & endif
						     if strpos(fil(0),'{') gt 0 then file(0)=fil(0)
						     if (wi le lamp_sys) then $
						     to_don_history, wi,0,'READ_LAMP,"'+pth+file(0)+'",w='+ws
if auto lt 0 then print,string(7b)+'file not read ...!'
return
end

pro read_myGIF,file, w=wi
;** **********
;**
@lamp.cbk
	wstr='w'+strtrim(string(wi),2) & XICUTE, wstr+'=0'
	i=execute('READ_KIF,file,'+wstr)
	to_don_history, wi,0,'READ_KIF,'+file+', '+wstr
end

pro p_did_res_hdf,fil,pth,ws,hyst,rflag
;** *************
;** Read  HDF LAMP format
@lamp.cbk

if rflag eq -2 then look=1 else look=0
if strpos(strlowcase(fil),'.xml') gt 0 then xml=1 else xml=0
rflag=-1
ac   = 0
      i=strpos(fil,'{') & nimg=1
      if i gt 1 then begin j=strpos(fil,'}')
                     ac=1
                     if j gt i+1 then nimg=strmid(fil,i+1,j-i-1)
                     fil=strmid(fil,0,i)
                     endif
if look eq 1 then begin Data=-88
	if xml then read_xml,pth+fil, Data, SNAP=w_buf, IMG=nimg  $
	       else read_hdf,pth+fil, Data, SNAP=w_buf, IMG=nimg
	if n_elements(Data) gt 1 then begin hyst=Data & rflag=0 & endif
endif else  begin
      if xml then proc='read_xml' else proc='read_hdf'
      wi=fix(ws)
      p_txt=''
      ii=execute(proc+',pth+fil,w'+ws+',XC=x'+ws+',YC= y'+ws+',ZC=z'+ws+',E=e'+ws      + $
                      ',N= n'+ws+',PR=p'+ws+',PV=pv'+ws+',PAR_TXT=p_txt,W_TIT=wt,X_TIT=xt'+ $
                      ',Y_TIT=yt,Z_TIT=zt,OTHER_TIT=ot ,SOURCE=src, HIST=hyst, IMG=nimg')
      if ii eq 1 then begin
         par_txt(wi,*)='' & npar=n_elements(p_txt) & if npar gt npars then npar=npars
         rflag=0
         if npar gt 0 then for i=0,npar-1 do par_txt(wi,i)=p_txt(i)
         head_tit(wi,2)=src
         w_tit(wi)=wt & x_tit(wi)=xt & y_tit(wi)=yt & z_tit(wi)=zt & other_tit(wi)=ot
	 if src ne '' then if strlowcase(inst_value) ne strlowcase(src) then RDSET,inst=src
      endif
endelse
if not ac then fil=fil+'{1.1}'
if xml then if (rflag eq 0) then rflag=10
end

pro p_did_restore_wrk,fil,pth,wnumber,hyst,rflag
;** *****************
;** Read  LAMP  format
;** Incoming:   input filename 		= pth+fil
;**		workspace string number = wnumber

@lamp.cbk
if n_elements(fil) eq 2 then if strpos(fil(0),'{') lt 0 then fil=fil(0)+'{'+fil(1)+'}'

if strpos(strlowcase(fil),'.xml') ge 0 then begin p_did_res_hdf,fil,pth,wnumber,hyst,rflag & return & endif
if strpos(strlowcase(fil),'.hdf') ge 0 then begin p_did_res_hdf,fil,pth,wnumber,hyst,rflag & return & endif
if strpos(strlowcase(fil),'.nxs') ge 0 then begin p_did_res_hdf,fil,pth,wnumber,hyst,rflag & return & endif
;                          ****
if rflag eq -2 then look=1 else look=0
rflag=-1

;**Read Header
;****** ******
   standard=0
   unit=-1
   on_ioerror,pathread		& ok=0
   openr,unit,fil ,/get_lun	& ok=1
   pathread:  on_ioerror,endhead
   if ok eq 0 then openr,unit, pth+fil ,/get_lun
   standard=1

   keyw=['LAMP_FORMAT'   , 'DATA_FILE:'    , 'HISTORY:'   , 'X_SIZE:'    , 'Y_SIZE:'  , $
	 'Z_SIZE:'       , 'FORMAT:'       , 'TYPE:'      , 'PARAMETERS:', 'MONITORS:', $
	 'X_COORDINATES:', 'Y_COORDINATES:', 'TITLES:'    , 'VAR PARAM:' , 'MACHINE:' , $
	 'Z_COORDINATES:', 'ERRO_FILE:'    , 'SOURCE:']
   nkey=n_elements(keyw)-1

   data=''   & wyst='' & xsiz=0  & ysiz=0  & zsiz=0 & frmt=0  & tipe=0
   parm=0    & ttl ='' & moni=0  & cdnx=0  & cdny=0 & cdnz=0  & npar=0
   ttx =''   & tty ='' & ttz ='' & tto ='' & parv=0 & erro='' & sorc=''

   partx =['']
   hyst  =''
   line  =' '
   mach  ='uni'

   while (1) do begin
	readf,unit, line
	if look eq 1 then hyst=[hyst,line]

	n=-1 & r=-1
	while (n lt nkey) and (r lt 0) do begin
	       n=n+1
	       r=STRPOS(line,keyw(n))
	endwhile

	if r ge 0 then begin
	 r=STRPOS(line,':')
	 if r ge 0 then remi=strtrim( strmid(line,r+1,100) ,2)

	 CASE keyw(n) of
	'LAMP_FORMAT':   begin standard=1
			 end
	'DATA_FILE:':	 begin data= strtrim(remi,2)
			 end
	'ERRO_FILE:':	 begin erro= strtrim(remi,2)
			 end
	'HISTORY:':	 begin wyst= strtrim(remi,2)
			 end
	'SOURCE:':	 begin sorc= strtrim(remi,2)
			 end
	'X_SIZE:':	 begin xsiz= long(remi)
			 end
	'Y_SIZE:':	 begin ysiz= long(remi)
			 end
	'Z_SIZE:':	 begin zsiz= long(remi)
			 end
	'FORMAT:':	 begin if remi eq 'Binary' 		then frmt=1
			       if remi eq 'Ascii'  		then frmt=2
			       if remi eq 'XDR'    		then frmt=3
			       if remi eq 'F77 unformatted'	then frmt=4
			 end
	'TYPE:':	 begin if strmid(remi,2,1) eq ')' then r=1 else r=2 ;+newtypes*****
	        	       tipe=fix( strmid(remi,1,r) )
			 end
	'TITLES:':	 begin ttl = remi
			 	r=1
			 	while r ge 0 do begin
				    readf,unit, line
			 	    if look eq 1 then hyst=[hyst,line]
				    r=STRPOS(line,' X:')
				    if r ge 0 then    ttx=strtrim(strmid(line,r+3,80),2) $
				    else begin        r  =STRPOS(line,' Y:')
				     if r ge 0 then   tty=strtrim(strmid(line,r+3,80),2) $
				     else begin       r  =STRPOS(line,' Z:')
				      if r ge 0 then  ttz=strtrim(strmid(line,r+3,80),2) $
				      else begin      r  =STRPOS(line,' OTHER:')
				       if r ge 0 then tto=strtrim(strmid(line,r+7,80),2)
				    endelse & endelse & endelse
				endwhile
			 end
	'PARAMETERS:':	 begin
			 readf,unit, line
			 if look eq 1 then hyst=[hyst,line]
			 r=STRPOS(line,'--')
			 if r ge 0 then begin
			 	r=0 & npar=0
			 	while r ge 0 do begin
				    readf,unit, line
			 	    if look eq 1 then hyst=[hyst,line]
				    r=STRPOS(line,'* ')
				    if r ge 0 then begin   ip=STRPOS(line,'==')
					   if ip lt 0 then ip=STRPOS(line,'=' ) else ip=ip+1
				     if ip gt 0 then begin remi=         strmid(line,r+2,ip-r-1)
				    			   if npar eq 0 then partx=[remi] $
				    			 	        else partx=[partx,remi]
				    			   remi=strtrim(strmid(line,ip+1,15)   ,2)
				    			   if npar eq 0 then parm =[remi] $
				    			 	        else parm =[parm ,remi]
				    			   npar=npar+1
				     endif
				    endif
				endwhile
				on_ioerror,misfloat & parm=float(parm) & misfloat: on_ioerror,endhead
			 endif
			 end
	'VAR PARAM:':	 begin
			 r=STRPOS(remi,'nb=')
			 if r ge 0 then begin
			 	reads, strmid(remi,r+3,10)+'0 0 0' ,da1,da2,da3
			 	if da1 gt 0 then begin
			 	 if da2 gt 0 then if da3 gt 0 then parv=fltarr(da1,da2,da3) $
			 				    else parv=fltarr(da1,da2)    $
			 				    else parv=fltarr(da1)
			 	 readf,unit, line
			 	 readf,unit, parv
			 	 if look eq 1 then begin
					parv= reform(parv,1.*da1*(da2>1)*(da3>1))
					hyst= [hyst,line,string(parv,format='(10G)')]
			 	 endif
			 	endif
			 endif
			 end
	'MONITORS:':	 begin
			 r=STRPOS(remi,'nb=')
			 if r ge 0 then begin
			 	reads, strmid(remi,r+3,10)+'0 0 0' ,da1,da2,da3
			 	if da1 gt 0 then begin
			 	 if da2 gt 0 then if da3 gt 0 then moni=fltarr(da1,da2,da3) $
			 				    else moni=fltarr(da1,da2)    $
			 				    else moni=fltarr(da1)
			 	 readf,unit, line
			 	 readf,unit, moni
			 	 if look eq 1 then begin
					moni= reform(moni,1.*da1*(da2>1)*(da3>1))
					hyst= [hyst,line,string(moni,format='(10G)')]
			 	 endif
			 	endif
			 endif
			 end
	'X_COORDINATES:':if xsiz gt 0 then begin
			 r=STRPOS(remi,'->')
			 if r lt 0 then begin
			        r=STRPOS(remi,'bi_dim')
			 	if r lt 0 then cdnx=fltarr(xsiz) else cdnx=fltarr(xsiz,ysiz)
			 	readf,unit, line
			 	readf,unit, cdnx
			 	if look eq 1 then hyst=[hyst,line,string(cdnx,format='(10G)')]
			 endif else begin  da1=1L
				reads, strmid(remi,0,r-1)+' 1' ,da1
				cdnx=lindgen(xsiz)+da1
			 endelse & endif
	'Y_COORDINATES:':begin
			 r=STRPOS(remi,'->')
			 if r lt 0 then begin
			        r=STRPOS(remi,'bi_dim')
			 	if r lt 0  then begin r=STRPOS(remi,'nb=') & da1=0
				           if r ge 0 then reads,strmid(remi,r+3,20)+' 0',da1
				           if da1 le 0 then da1=ysiz>1
				           cdny=fltarr(da1)
				endif else cdny=fltarr(xsiz,ysiz>1)
			 	readf,unit, line
			 	readf,unit, cdny
			 	if look eq 1 then hyst=[hyst,line,string(cdny,format='(10G)')]
			 endif else begin  da1=1L
				reads, strmid(remi,0,r-1)+' 1' ,da1
				cdny=lindgen(ysiz>1)+da1
			 endelse  & end
	'Z_COORDINATES:':begin
			 r=STRPOS(remi,'nb=')
			 if r ge 0 then begin
			 	reads, strmid(remi,r+3,20)+' 1' ,da1
				cdnz=fltarr(da1>1)
			 	readf,unit, line & readf,unit, cdnz
			 endif else $
				reads,remi+' 0',cdnz
			 	if look eq 1 then hyst=[hyst,line,string(cdnz,format='(10G)')]
			 end
	'MACHINE:':	 mach=strmid(remi,0,3)

	'HOW TO READ':   while (1) do readf,unit, line

	 else:
	 endcase
	endif
   endwhile
   endhead:if unit gt 0 then free_lun,unit else return

;**Test Header
;****** ******
   pngr =-1
   rflag= 0
   zdel = 0
   j=strpos(fil,'.')
   if j gt 0 then jz ='Z' else jz='.Z'

   if (standard eq 0)              then  hyst=[hyst,' ??? Header file not readable ....'] else $
   if (xsiz le 0) and (ysiz le 0)  then  hyst=[hyst,' ??? Data size not specified .....'] else $
   if (frmt eq 0)                  then  hyst=[hyst,' ??? Data format not specified ...'] else $
   if (tipe le 0) or  (tipe ge 16) then  hyst=[hyst,' ??? Data type not specified .....'] else $ ;+newtypes*****
   if (data eq '')                 then  begin rflag=1
;   					hyst=[hyst,' ??? Data file not specified .....']
;					TOUCH_BASE   ???
;				     ***Try imgR
   					pngr=1 & j=strpos(fil,'.')
   					if j gt 0 then data=strmid(fil,0,j)+'imgR.' $
   						  else data=fil+'imgR'
   					if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						     else i=findfile(    data   ,count=cnt)
;				     ***Try xdr
   					if (cnt le 0) and (pth gt ' ') then begin
   					   pngr=-1
 					   k   =strlen(pth)
 					   ddir=strmid(pth,0,k-1)+'d'+strmid(pth,k-1,1)
					   data=strmid(fil,0,lamp_6)
   					   if j gt 0  then    data=data+'.'
   					   i   =findfile(ddir+data+jz ,count=cnt)
   					   if cnt gt 0 then frmt=3
   					   if cnt gt 0 then pth =ddir
   					endif
;				     ***Try png
   					if cnt le 0 then begin
   					   pngr=0
   					   if j gt 0 then data=strmid(fil,0,j)+'png.' $
   						     else data=fil+'png'
   					   if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						        else i=findfile(    data   ,count=cnt)
   					endif
;				     ***Try jpg
   					if cnt le 0 then begin
   					   pngr=0
   					   if j gt 0 then data=strmid(fil,0,j)+'jpg.' $
   						     else data=fil+'jpg'
   					   if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						        else i=findfile(    data   ,count=cnt)
   					endif
;				     ***Try img
   					if cnt le 0 then begin
   					   pngr=0
   					   if j gt 0 then data=strmid(fil,0,j)+'img.' $
   						     else data=fil+'img'
   					   if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						        else i=findfile(    data   ,count=cnt)
   					endif
   					if cnt le 0 then rflag=-1
   endif else rflag=1

;**Read the Data
;****** *** ****
     if (look eq 0) and (rflag eq 1) then begin
        if frmt ne 3 then rflag=-1 else rflag=0
	on_ioerror, nofile
	unit=-1
	unet=-1
	ptd =pth

	i=findfile(pth+data,count=cnt)
	if cnt eq 0 then begin
	  i=findfile(data,count=cnt)
	  if cnt gt 0 then ptd='' else begin
	   i=findfile(pth+data+jz,count=cnt)
	   if cnt gt 0 then begin
	      i=strpos(strupcase(pth),'TOUCH')
	      if (i ge 0) or (pth ne '') then begin
		   bid =sys_dep      ('COPY',data+jz,pth)
		   zdel=1
		   ptd =''
	      endif
	      bid=sys_dep      ('UN_Z',ptd+data+jz,lamp_dir)
	   endif
	   if cnt eq 0 then begin
		i=findfile(data+'.',count=cnt)
		if cnt gt 0 then begin data=data+'.' & if erro ne '' then erro=erro+'.'
		endif else begin
			if frmt eq 0 then ext ='hdf'   else if frmt eq 1 then ext ='bin' else $
			if frmt eq 2 then ext ='ascii' else if frmt eq 3 then ext ='xdr' else $
			if frmt eq 4 then ext ='f77'
			i=strpos(fil,'.htm')
			if i gt 0 then begin data=strmid(fil,0,i)+'.xdr' & dat2=strmid(fil,0,i)+'.zip'
			                     if (findfile(pth+data))(0) eq '' then  data=dat2
			endif else data=fil+ext
			if erro ne '' then erro=data+'_e'
		endelse
	   endif
	  endelse
	endif

	i= strpos(data,'.zip')
	if i gt 0 then begin dat2=strmid(data,0,i)+'.xdr'
	                     re =findfile(ptd+dat2,count=cnt)
	                     if  cnt eq 0 then re=sys_dep('UNZIP',data,ptd) & data=dat2 & endif

	if (frmt eq 1) or (frmt eq 2)	then OPENR,  unit, ptd+data ,/GET_LUN
	if (frmt eq 3)			then OPENR,  unit, ptd+data ,/GET_LUN,/XDR
	if (frmt eq 4)			then OPENR,  unit, ptd+data ,/GET_LUN,/F77

	rflag=0
	doe=erro
	if erro ne '' then if strpos(doe,'sqrt(i)') ge 0 then erro='' else doe=''
	if erro ne '' then begin
	on_ioerror, noerro
	flge=0
	if (frmt eq 1) or  (frmt eq 2)	then OPENR,  unet, pth+erro ,/GET_LUN
	if (frmt eq 3) and (pngr ne 0)  then OPENR,  unet, pth+erro ,/GET_LUN,/XDR
	if (frmt eq 4)			then OPENR,  unet, pth+erro ,/GET_LUN,/F77
	flge=1
	noerro:if flge eq 0 then erro=''
	endif

	on_ioerror, enddata
	fil  =data

	if xsiz le 0 then xsiz=1
	if ysiz lt 0 then ysiz=1
	if pngr ne 0 then begin
	   if zsiz gt 1 then i=execute('w'+wnumber+'=MAKE_ARRAY( xsiz,ysiz,zsiz ,TYPE=tipe)' ) else $
	   if ysiz gt 1 then i=execute('w'+wnumber+'=MAKE_ARRAY( xsiz,ysiz      ,TYPE=tipe)' ) else $
	   if ysiz eq 1 then i=execute('w'+wnumber+'=MAKE_ARRAY( xsiz           ,TYPE=tipe)' ) else $
	   if ysiz eq 0 then i=execute('w'+wnumber+'=MAKE_ARRAY(  3  ,xsiz      ,TYPE=tipe)' )
	endif
	i=execute('x'     +wnumber+' =cdnx')
	i=execute('y'     +wnumber+' =cdny')
	i=execute('z'     +wnumber+' =cdnz')
	i=execute('e'     +wnumber+' =0   ')
	i=execute('n'     +wnumber+' =moni')
	i=execute('p'     +wnumber+' =parm')
	i=execute('pv'    +wnumber+' =parv')
	par_txt(fix(wnumber),*)=''
	if npar gt npars then npar=npars
	if npar gt 0 then for i=0,npar-1 do par_txt(fix(wnumber),i)=partx(i)
	w_numor  (fix(wnumber))  =''
	w_tit    (fix(wnumber))  =ttl
	x_tit    (fix(wnumber))  =ttx
	y_tit    (fix(wnumber))  =tty
	z_tit    (fix(wnumber))  =ttz
	other_tit(fix(wnumber))  =tto
	head_tit (fix(wnumber),*)=''
	head_tit (fix(wnumber),2)=sorc
	if sorc ne '' then if strlowcase(inst_value) ne strlowcase(sorc) then RDSET,inst=sorc

	if pngr lt 0 then begin
	   if  frmt ne 2 then i=execute('READU,  unit,w'+wnumber ) else $
	   if  frmt eq 2 then i=execute('READF,  unit,w'+wnumber )
	   if  erro ne '' then begin
	    i=execute('e'+wnumber+ '=w'+wnumber)
	    if frmt ne 2 then i=execute('READU,  unet,e'+wnumber ) else $
	    if frmt eq 2 then i=execute('READF,  unet,e'+wnumber )
	   endif
	endif else begin
	   if pngr eq 0 then begin
	   		     if frmt eq 3 then READ_KIF,pth+data,buf $
	   		                  else READ_KIF,pth+data,buf, 192,192
	   		     buf=float (buf)
	   		     if zsiz gt 1 then begin
	   		        if  xsiz gt ysiz then  ysiz=ysiz*zsiz else $
	   		        if (ysiz gt zsiz) and (ysiz ne xsiz) then ysiz=zsiz
	   		        zsiz=1
	   		     endif
	   		     i=execute('w'+wnumber+'=CONGRID(buf,xsiz,ysiz,/INTER)' )
	   endif else begin  bxs=fix(0) & bys=fix(0) & bts=fix(0)
	   		     READU, unit, bxs,bys,bts
	   		     i=execute('READU,  unit,w'+wnumber )
	   endelse
	endelse

	if doe ne '' then $
	if doe eq 'sqrt(i)'       then i=execute('e'+wnumber+' =sqrt(w'+wnumber+')')                else $
	if doe eq 'sqrt(i)/i'     then i=execute('e'+wnumber+' =sqrt(w'+wnumber+')/ w'+wnumber)     else $
	if doe eq 'sqrt(i)/(i+1)' then i=execute('e'+wnumber+' =sqrt(w'+wnumber+')/(w'+wnumber+'+1)')

	enddata:if  unit gt 0  then free_lun,unit

	if pngr lt 0 then $
	if ysiz eq 0 then if frmt eq 2  then begin
					i=execute('e'+wnumber+'=reform(w'+wnumber+'(2,*))' )
					i=execute('w'+wnumber+'=reform(w'+wnumber+'(1,*))' )
					endif
	res=sys_dep      ('SWAPER',mach)
	if (frmt eq 1) and (res eq 1) then begin ;+newtypes*****
				if tipe eq 2  then i=execute('BYTEORDER,w'+wnumber+',/SSWAP')   else $
				if tipe eq 3  then i=execute('BYTEORDER,w'+wnumber+',/LSWAP')   else $
				if tipe eq 12 then i=execute('BYTEORDER,w'+wnumber+',/SSWAP')   else $
				if tipe eq 13 then i=execute('BYTEORDER,w'+wnumber+',/LSWAP')   else $
				if tipe eq 14 then i=execute('BYTEORDER,w'+wnumber+',/L64SWAP') else $
				if tipe eq 15 then i=execute('BYTEORDER,w'+wnumber+',/L64SWAP')
				if erro ne '' then $
				if tipe eq 2  then i=execute('BYTEORDER,e'+wnumber+',/SSWAP') else $
				if tipe eq 3  then i=execute('BYTEORDER,e'+wnumber+',/LSWAP')
	endif

	nofile: if unit lt 0 then print,string(7b),'% File '+pth+data+' not found ...'
	if zdel eq 1 then bid =sys_dep      ('DELET',data)

     endif

  if rflag ge 0 then if frmt eq 3  then rflag=10
  if look  eq 0 then if hyst eq '' then hyst =strtrim(wyst,2) else print,string(7b),hyst

end

;*************************************** Data access ******************************
;*************************************** Data access ******************************
;*************************************** Data access ******************************

pro P_DATA_ACCESS, laber,b33,bac,butb, flag
;** *************
;**
;** Create Data Access buttons
@lamp.cbk

if b33 gt 0 then begin
   if flag ne 0 then begin
	  tmpbase=0    & P_messi , tmpbase,(lamp_b1+0)

	  P_DATA_IDOL
	  if lamp_siz ge 800 then bid = widget_label (b33     ,font=ft_b_normal,value='Ins:')
	  NEW=inst_value & IF strcompress(NEW) LE ' ' THEN NEW='New !!'
	  if sys_dep('MAP') ne -1 then $
	  b_labins(0)=widget_button(b33     ,font=ft_b_normal,value=NEW,menu=2,$
	  						      resource_name='discret') else $
	  b_labins(0)=widget_button(b33     ,font=ft_b_normal,value=NEW,menu=2)

	 ;if lamp_siz ge 900 then bid = widget_label (b33     ,font=ft_b_normal,value='Pth:')
	  if sys_dep('MAP') ne -1 then $
	  b_labins(1)=widget_button(b33     ,font=ft_b_normal,value=cycle     ,menu=2,$
	  						      resource_name='discret') else $
	  b_labins(1)=widget_button(b33     ,font=ft_b_normal,value=cycle     ,menu=2)

	  to_don_history,-1,0,'RDSET,base="'+cycle   ;+'",inst="'+inst_value+'"'

	  uval =[-88,560,laber,b_labins(0),b_labins(1)]
	  gcur =' '
	  entr1=b_labins(0)
	  for i=0,n_elements(lamp_ins)-1 do begin
	      if  gcur ne  lamp_grp(i) then begin
		  gcur  =  lamp_grp(i)
		  if gcur eq ' ' then entr1=b_labins(0) else $
		  entr1 =widget_button(b_labins(0),font=ft_b_normal,value=gcur,menu=2)
		  endif
	      bidon=widget_button(entr1  ,font=ft_b_normal,value=lamp_ins(i),uvalue=[uval,i,0,0])
	  endfor
	  bidon=widget_button(b_labins(0),font=ft_bigger ,value='CUSTOMIZE',uvalue=[uval,-1,0,0])

	  uval =[-88,561,laber,b_labins(0),b_labins(1)]
	  for i=0,n_elements(lamp_ali)-1 do begin
	      if strpos(strlowcase(lamp_ali(i)),'c_year') ge 0 then begin
		yr =strtrim(strmid(lamp_ali(i),7,15),2) & yr=strmid(yr,2,2)
		didon=widget_button(b_labins(1),font=ft_b_normal,menu=2		    ,value=lamp_ali(i))
		for j=1,5 do begin  yrs=yr+strtrim(string(j),2)
		  bid=widget_button(didon      ,font=ft_b_normal,uvalue=[uval,i,0,long(yrs)],value='Cycle '+yrs)
		endfor
	      endif else $
		bidon=widget_button(b_labins(1),font=ft_b_normal,uvalue=[uval,i,0,0]	    ,value=lamp_ali(i))
	  endfor

	  uvbuti=[-88,575,laber,0,b33,0,0,0,0]
	  P_MAC_COMPLETE, uvbuti ,butb
	  widget_control,bad_id=i,b33, set_uvalue=uvbuti

   	  bid=sys_dep      ('DYNLAB',b33,1)
	  P_messi , tmpbase,(lamp_b1+0)
   endif
   if ((flag eq 0) or (flag eq 2)) and (lamp_data ne 'hostvms') then begin
	  if lamp_siz ge 800 then text='Self...' else text='Self...'
	  widget_control,bad_id=i,b33, get_uvalue=uvbuti
	  widget_control,bad_id=i,bac ,set_value = text, set_uvalue=uvbuti
   endif
endif
return
end
pro	P_MAC_COMPLETE, uv ,butb
;**	**************
;**
@lamp.cbk
if uv(3) eq 0 then begin
	bsup =widget_base  (uv(4),/row)
	if lamp_siz ge 800 then bid = widget_label (bsup,font=ft_b_normal,value='File:')

	bnum =widget_text  (bsup,xsiz=14,ysize=1,font=ft_propor,/editable,value='Name')

	if sys_dep('MAP') ne -1 then $
	bget =widget_button(bsup,font=ft_b_normal,value='Read ',resource_name='discret') else $
	bget =widget_button(bsup,font=ft_b_normal,value='Read ')

	if sys_dep('MAP') ne -1 then $
	bnex =widget_button(bsup,font=ft_smaller ,value='+1',resource_name='discret') else $
	bnex =widget_button(bsup,font=ft_smaller ,value='+1')
	uv(3)=bnum
	if lamp_siz ge 800 then text='raw ->' else text='raw'
	bidon=widget_base  (bsup,/nonexclusive)
	if sys_dep('MAP') ne -1 then $
	braw =widget_button(bidon,value=text,font=ft_smaller,resource_name='discret') else $
	braw =widget_button(bidon,value=text,font=ft_smaller)
	b_labins(4) =braw

	widget_control,butb,get_uvalue=uvb & wread=uvb(4)

	if uvb(5) ne -2 then begin
	 bs1f =widget_base  (bsup,/row,/frame)
	 if sys_dep('MAP') ne -1 then $
	 bs1b1=widget_button(bs1f,font=ft_smaller ,value='<',resource_name='discret') else $
	 bs1b1=widget_button(bs1f,font=ft_smaller ,value='<')
	 wread=widget_label (bs1f,font=ft_b_normal,value='W1 ',xsize=29)
	 if sys_dep('MAP') ne -1 then $
	 bs1b2=widget_button(bs1f,font=ft_smaller ,value='>',resource_name='discret') else $
	 bs1b2=widget_button(bs1f,font=ft_smaller ,value='>')

	 widget_control, bs1b1  ,bad_id=i,set_uvalue=[-88,310,wread,0   ,0,0,0,0,0]
	 widget_control, bs1b2  ,bad_id=i,set_uvalue=[-88,311,wread,0   ,0,0,0,0,0]
	endif

	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1

	widget_control, braw   ,bad_id=i,set_uvalue=[-88,312,0]
	widget_control, butb   ,bad_id=i,set_uvalue=[-88,562,uv(2),bnum,wread,-1,-1,0],sensitive=1
	widget_control, bget   ,bad_id=i,set_uvalue=[-88,577,uv(2),bnum,wread,0,0,0,0]
	if txev then $
	widget_control, bnum   ,bad_id=i,set_uvalue=[-88,577,uv(2),bnum,wread,0,0,0,0]
	widget_control, bnex   ,bad_id=i,set_uvalue=[-88,578,uv(2),bnum,wread,0,0,0,0]

	if n_elements(monimon) eq 0 then monimon=-1
	if monimon lt 0 then    widget_control,braw    ,bad_id=i,set_button=1
endif
return
end

pro P_DATA_IDOL
;** ***********
@lamp.cbk
    	if (lamp_data  eq 'hostvms') then begin
    				if lamp_exec ne '' then tmp=findfile(lamp_exec,count=j) else j=0
				if j le 0 then  lamp_data  =''
				if j gt 0 then  begin cycle='On_Line'
						inst_value = lamp_host
						lamp_exec  ='lamp_exec'
					;	lamp_entry ='r_mic'
						endif
    	endif else begin	j=0
				if lamp_exec gt ' '   then tmp=findfile(lamp_exec,count=j)
				if j le 0 then begin
				  lamp_exec=sys_dep      ('EXEC',lamp_dir)
				  if lamp_exec gt ' ' then tmp=findfile(lamp_exec,count=j)
				endif
				if j gt 0 then if lamp_cyc(0) eq 0 then begin
				  lamp_data ='idol'
				  lc  =where(lamp_ali eq 'On_Line') & lamp_cyc(0)=lc(0)>0
				  cycle     =lamp_ali(lamp_cyc(0))
				  if inst_value eq '' then inst_value='?Inst?'
				 ;lamp_entry=sys_dep      ('ENTRY')
				endif
    	endelse
end

pro	P_MAC_LABINS
;**	************
;**
@lamp.cbk
	   NEW=inst_value & IF strcompress(NEW) LE ' ' THEN NEW='New !!'
	   if b_labins(0) gt 0 then widget_control,b_labins(0),bad_id=i,set_value=NEW
	   if b_labins(1) gt 0 then widget_control,b_labins(1),bad_id=i,set_value=cycle
return
end

function flto6, run
;******* *****
;**
@lamp.cbk
    	file=strtrim(string(run),2) & ln=strlen(file)
    	while ln lt lamp_6 do begin file='0'+file & ln=ln+1 & endwhile
return, file
end

pro CALIBRATION ,FILE=file ,NOCAL=nocal ,LIST=list
;** ***********
@lamp.cbk
    ii=0 & ii=execute('ii=rdid()')
    if keyword_set(file)  then P_DID_CALOD, strlowcase(inst_value) ,file ,flg	else $
    if keyword_set(nocal) then P_DID_CALOD, strlowcase(inst_value)		else $
    if keyword_set(list)  then P_DID_CALOD, strlowcase(inst_value) ,/LIST	else $
    if b_labins(3) ge  1  then P_DID_CALOD, strlowcase(inst_value) ,/LIST	     $
			  else P_DID_CALIB, inst_value+'' , lamp_b1
return
end

function rlamp, inst,path,file,status,datp
;******* *****
;**
status=0
		 pp2=-1
		 p_did_restore_wrk, file,path,datp,'',pp2
		 if pp2 lt 0 then status=11
return,1
end

pro p_did_get_it, run,wi,status,uv ,run_fil
;** ************
;**
@lamp.cbk
    if uv(2) gt 0 then $
       if strpos(path_for_online,strlowcase(inst_value)) gt 0 then $
            widget_control,uv(2),bad_id=i,set_value='Checking '+path_for_online+' ...' $
       else widget_control,uv(2),bad_id=i,set_value='Reading ...'
    ran=run
    if run_fil eq 'run' then p_did_getrun, run,wi,status
    if run_fil eq 'fil' then p_did_getfil, run,wi,status
    if run_fil eq 'opr' then rdmulti     , run   ,status,uv(2),wi

    if status ne 0 then begin
		 	     errtxt=' Un_implemented status '+string(status)
	if status eq 1  then errtxt=' Client/server on local node not established'
	if status eq 2  then errtxt=' Client/server on router node not established'
	if status eq 3  then errtxt=' The local node cannot access the server node'
	if status eq 4  then errtxt=' The router node cannot access the server node'
	if status eq 5  then errtxt=' VME memory read error'
	if status eq 6  then errtxt=' No host defined'
	if status eq 7  then errtxt=' Sequence error in data transfer'
	if status eq 8  then errtxt=' Memory space or buffer too small'
	if status eq 9  then errtxt=' Parameter error'
	if status eq 10 then errtxt=' Router is busy with other transfer'
	if status eq 11 then errtxt=' Cant open the file'
	if status eq 12 then errtxt=' Syntax error'
	if status eq 13 then errtxt=' Data file incomplete'
	if status eq 14 then errtxt=' Bad instrument data definition'
	if status eq 23 then errtxt=' Internal error'
	if status eq 24 then errtxt=' Cant read the file'
	print,string(7b)
	if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value=errtxt else print,errtxt
    endif  else begin
	strun=strtrim(string(run),2) & stwi='w'+strtrim(string(wi),2)

	if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value=strun+' may be plotted from '+stwi
	if uv(3) gt 0 then $
	widget_control,bad_id=i,uv(3),set_value=strun
	if run_fil eq 'run' then cmd="=RDRUN(" +strun+") ;.."  else $
	if run_fil eq 'fil' then cmd="=RDRUN(" +strun+") ;.."  else $
				 cmd="=RDOPR('" +strun+"') ;.."
	if run_fil ne 'opr' then RDSET,golast=[wi,wi]
	to_don_history, wi,0,stwi+ cmd+inst_value
    endelse
return
end

pro p_did_getfil, run,wi,full
;** ************
;**
i=strpos(run,'{') & nimg=0
if i ge 1 then begin j=strpos(run,'}') & m=0
                     if j gt i+1 then begin
                     	for k=i+1,j-1 do begin
				c=strmid(run,k,1)
				if ((c lt '0') or (c gt '9')) and (c ne ' ') then m=1
			endfor
                     	if m eq 0 then nimg=long(strmid(run,i+1,j-i-1))
                     endif
                     if m eq 0 then run=strmid(run,0,i) & endif

if nimg le 1 then p_did_getrun , run,wi,full,'file' $
             else p_did_getrun , run,wi,full,'file' ,FRAME=nimg

return
end

pro p_did_getrun, run,wi,full,fifi ,FRAME=nimg
;** ************
;**
@lamp.cbk
common rd_filter,filter_proc

full	=23
status  =14
wstr    =strtrim(string(wi),2)
inst_val=strlowcase(inst_value)

idx=where(lamp_ins eq inst_value) & idx=idx(0) > 0 & proced=lamp_proc(idx)
if (proced  gt ' ') and (proced ne 'ill') and ((proced ne 'mic') or (strpos(strupcase(run),'_LAMP') gt 0)) $
		    and (cycle  ne 'On_Line')  then begin
		 	  if strpos(strlowcase(cycle),'cycle') lt 0 then kc='' else kc='1'
			  if monimon lt 0 then km='1' else km='0'
    			  inst  =[inst_value,inst_group,km,kc]
    			  path  =path_for_online
    			  if n_elements(fifi) eq 0 then begin
    			  	 file  =flto6(run)
    			  	 if  strlowcase(proced) eq 'rlamp' then $
		   		     if (strpos(file,'_LAMP') lt 0) and $
				        (strpos(file,'.htm' ) lt 0) and $
				        (strpos(file,'.xml' ) lt 0) and $
				        (strpos(file,'.nxs' ) lt 0) and $
				        (strpos(file,'.hdf' ) lt 0) then file=file+'_LAMP'
    			  	 bid =sys_dep      ('POT',file)
    			  endif else file=run
			  ac=strpos(file,'{')
    			  if n_elements(nimg) eq 1 then if nimg gt 0 then file=[file,strtrim(string(nimg),2)]

	    		  iii   =execute( 'w'+wstr+'=0') & datp=wstr
	    		  clearpar, wi,wstr
    	    		  head_tit (wi,2)=inst_value
      	    		  w_numor  (wi)  =strtrim(string(run),2)

			  if (proced eq 'rlamp') or (strpos(strupcase(file(0)),'_LAMP') gt 0) then $
			  iii   =rlamp(inst,path,file,status,datp)                  else $
    			  iii   =execute( 'w'+wstr+'=call_function(proced,inst,path,file,status,datp)')

	    		  if iii ne 1 then status=23 else if status  eq 0 then $
    	    		     iii =execute( 'if n_elements(w'+wstr+') eq 1 then if w'+wstr+' eq 0 then status=13' )

	    		 ;if (status eq 0) then begin
      	    		      one=wi
	    		      GETDATP,datp
	    		      if ac lt 0 then if strpos(file(0),'{') gt 0 then run=file(0)
    	    		 ;endif
endif  else $
if inst_val eq 'pn1'  then begin
    			  status=0
    			  file  =strtrim(string(run),2)
    			  one =wi & two=0
    			  iii =execute( 'w'+wstr+'=pn1(file)' )
    			  if iii ne 1 then status=11 else $
    			     iii =execute( 'if n_elements(w'+wstr+') eq 1 then status=w'+wstr )
endif  else $
if inst_val eq 'inx'  then begin
    			  status=0
    			  file  =strtrim(string(run),2)
    			  one =wi & two=0
    			  iii =execute( 'w'+wstr+'=inx_in(file)' )
    			  if iii ne 1 then status=11 else $
    			     iii =execute( 'if n_elements(w'+wstr+') eq 1 then status=w'+wstr )
endif  else $
if (cycle eq 'On_Line') then begin
			     RPCILL, inst_val,run,wi,wstr,status
endif else begin

;*******TOF LSS
;*******TOF LSS
	    mic,1
	    clearpar,  wi,wstr
    	    fil =flto6(run)

    	    pthv=path_for_online
	    bid =findfile(pthv+FIL+'.Z',count=cprs)
	    IF  cprs GT 0     THEN BEGIN
		IF pthv NE '' THEN bid=sys_dep      ('COPY',FIL+'.Z',pthv) ELSE cprs=0
			   bid=sys_dep      ('UN_Z',FIL+'.Z')    &   path_for_online=''
	    ENDIF


    	    bid =sys_dep('POT',fil)
	    file_found =[ path_for_online+fil ]
      	    w_numor(wi)=  strtrim(string(run),2)
	    nwk_select =  wi
	    swk_select =  wstr
	    status     =0
	    iii=execute('w'+wstr+'=0')
	    iii=execute('read_data')
	    if iii ne 1 then status=23 else $
    	       iii=execute( 'if n_elements(w'+wstr+') eq 1 then status=24' )

    	    path_for_online=pthv
	    IF cprs gt 0 THEN bid=sys_dep      ('DELET',FIL)
endelse

n=n_elements(filter_proc)
if (status eq 0) and (n gt 0)	then if filter_proc(0) ne '' $
				then for i=0,n-1 do CALL_PROCEDURE,filter_proc(i),wi
full=status
return
end

pro filterpro, name
;**
common rd_filter,filter_proc
filter_proc=name
end

pro clearpar, wi,wstr
;** ********
@lamp.cbk
    	        iii=execute('p' +wstr+'= 0') & iii=execute('pv'+wstr+'= 0')
    	        iii=execute('e' +wstr+'= 0')
     	        iii=execute('n' +wstr+'= 0') & iii=execute('x' +wstr+'= 0')
     	        iii=execute('y' +wstr+'= 0') & iii=execute('z' +wstr+'= 0')
     	        par_txt  (wi,*)	 ='' & w_numor(wi)	 =''
     	        w_tit    (wi)	 ='' & x_tit  (wi)='' & y_tit(wi)='' & z_tit(wi)=''
     	        other_tit(wi)	 =''
     	        head_tit (wi,*)  =''
return
end
pro movepar, wi,wsti,wo,wsto
;** *******
@lamp.cbk
	   if wi ne wo then begin
    	      iii=execute('p' +wsto+'= p' +wsti)
    	      iii=execute('pv'+wsto+'= pv'+wsti)
     	      iii=execute('e' +wsto+'= e' +wsti)
     	      iii=execute('n' +wsto+'= n' +wsti)
     	      iii=execute('x' +wsto+'= x' +wsti)
     	      iii=execute('y' +wsto+'= y' +wsti)
     	      iii=execute('z' +wsto+'= z' +wsti)

     	      par_txt  (wo,*)   =par_txt  (wi,*)
     	      w_numor  (wo)     =w_numor  (wi)
    	      w_tit    (wo)	=w_tit    (wi)
     	      x_tit    (wo)	=x_tit    (wi)
     	      y_tit    (wo)	=y_tit    (wi)
     	      z_tit    (wo)   	=z_tit    (wi)
     	      other_tit(wo)   	=other_tit(wi)
     	      head_tit (wo,*) 	=head_tit (wi,*)
     	   endif
return
end

pro take_w, wkp , w=wi
;** ******
@lamp.cbk
if n_elements(wi) ne 1  then $
if two gt 0 then wi=two else if alone gt 0 then wi=alone else wi=one
wkp=[0L]
if wi  gt 0 then if wi  lt n_elements(w_tit) then ii=execute('wkp=w'+strtrim(string(wi),2))
return
end

pro new_w , wkp
;** ******
end

pro give_w, wkp , w=wi
;** ******
@lamp.cbk

if n_elements(wi) ne 1  then $
if one gt 0 then wi=one else if alone  gt 0  then wi=alone else wi=two
if n_elements(wkp) eq 0 then wkp=0
if wi  gt 0 then if wi  lt n_elements(w_tit) then begin
		 ii=execute('w'  +strtrim(string(wi),2)+'=wkp')
		 to_don_history, wi,0,'NEW_w,w'+strtrim(string(wi),2) & endif
return
end

pro W_store    ,W=wii ,ALL=all
;** *******
lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then FOR i=1,lamp_sys do A_store, W=(i) $
else A_store, W=wii
end
pro W_restore  ,W=wii ,ALL=all
;** *********
lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then FOR i=1,lamp_sys do A_restore, W=(i) $
else A_restore, W=wii
end
pro W_exchange ,W=wii ,ALL=all
;** **********
lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then FOR i=1,lamp_sys do A_exchange, W=(i) $
else A_exchange, W=wii
end
pro W_clear    ,W=wii ,ALL=all
;** *******
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then begin FOR i=1,lamp_sys do A_clear, W=(i)
	a=0 & b=0 & c=0 & d=0 & e=0 & f=0 & g=0 & h=0 & i=0 & j=0 & k=0 & l=0 & m=0
	n=0 & o=0 & p=0 & q=0 & r=0 & s=0 & t=0 & u=0 & v=0 & w=0 & x=0 & y=0 & z=0
endif else A_clear, W=wii
end

pro A_exchange ,W=wii
;** **********
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys<20) then begin
	ws=strtrim(string(wii),2)
	ii=execute('wst0=wst'+ws)
	if n_elements(wst0) le 1 then return
	ii=execute('pst0=pst'+ws)
	A_store,  W=wii
	A_restore,W=wii ,/TEMP & endif
end
pro A_store ,W=wii
;** *******
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys<20) then begin
	ws=strtrim(string(wii),2)
	ii=execute('wst'+ws+'=w'+ws)
	ii=execute('take_datp,pst'+ws+',W=wii') & endif
end
pro A_restore ,W=wii ,TEMP=temp
;** *********
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys<20) then begin
	ws=strtrim(string(wii),2)
	if keyword_set(temp) then wa='0' else wa=ws
	nel=0L & ii=execute('nel=n_elements(wst'+wa+')')
	if nel le 1 then return
	ii=execute('w'+ws+'=wst'+wa)
	ii=execute('give_datp,pst'+wa+',W=wii')
	to_don_history, wii,0,'W_restore ,W='+ws ,/nojournal & endif
end
pro A_clear ,W=wii
;** *******
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

wst0=0 & pst0=0
if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys+3) then begin
	ws=strtrim(string(wii),2)
	if wii le 20 then ii=execute('wst'+ws+'=0')
	if wii le 20 then ii=execute('pst'+ws+'=0')
	ii=execute('W'  +ws+'=0')
	CLEARPAR,wii,ws & endif
end

pro   setdatp, datp
    take_datp, datp & return & end
pro take_datp, datp , w=wi ,second=second ,third=third ,fourth=eme4,fifth=eme5,sixth=eme6
;** *********
@lamp.cbk
common eme456,	fourth,fifth,sixth

if n_elements(wi) ne 1  then $
if two gt 0 then wi=two else if alone gt 0 then wi=alone else wi=one
if keyword_set(second)  then wi=two
if keyword_set(third)   then wi=three
if keyword_set(eme4)    then wi=fourth
if keyword_set(eme5)    then wi=fifth
if keyword_set(eme6)    then wi=sixth
datp={empty:0}
if wi  gt 0 then if wi  lt n_elements(w_tit) then begin
		 wstr=strtrim(string(wi),2)
		 ii=execute('datp={x:		x' +wstr  + $
		 		 ',y:		y' +wstr  + $
		 		 ',z:		z' +wstr  + $
		 		 ',e:		e' +wstr  + $
		 		 ',n:		n' +wstr  + $
		 		 ',p:		p' +wstr  + $
		 		 ',pv:		pv'+wstr  + $
		 		 ',w_tit:	w_tit(wi)'+ $
		 		 ',x_tit:	x_tit(wi)'+ $
		 		 ',y_tit:	y_tit(wi)'+ $
		 		 ',z_tit:	z_tit(wi)'+ $
		 		 ',other_tit:	other_tit(wi)'  + $
		 		 ',time:	head_tit (wi,4)'+ $
		 		 ',par_txt:	par_txt  (wi,*) }')
endif
return
end

pro   getdatp, datp
    give_datp, datp & return & end
pro give_datp, datp , w=wi ,second=second ,third=third ,fourth=eme4,fifth=eme5,sixth=eme6
;** *********
@lamp.cbk
common eme456,	fourth,fifth,sixth

if n_elements(wi) ne 1  then $
if one gt 0 then wi=one else if alone  gt 0  then wi=alone else wi=two
if keyword_set(second)  then wi=two
if keyword_set(third)   then wi=three
if keyword_set(eme4)    then wi=fourth
if keyword_set(eme5)    then wi=fifth
if keyword_set(eme6)    then wi=sixth
if wi  gt 0 then if wi  lt n_elements(w_tit) then begin
	    		if n_tags(datp) gt 0 then begin
			     wstr=strtrim(string(wi),2)
	    		     tlist=tag_names(datp)
	    		     for k=0,n_elements(tlist)-1 do begin
	    		         CASE tlist(k) of

	    		         'X':	 iii =execute('x' +wstr+'=datp.x' )
	    		         'Y':	 iii =execute('y' +wstr+'=datp.y' )
	    		         'Z':	 iii =execute('z' +wstr+'=datp.z' )
	    		         'E':	 iii =execute('e' +wstr+'=datp.e' )
	    		         'N':	 iii =execute('n' +wstr+'=datp.n' )
	    		         'PV':	 iii =execute('pv'+wstr+'=datp.pv')

	    		         'W_TIT':    w_tit(wi)      =string(datp.w_tit)
	    		         'X_TIT':    x_tit(wi)      =string(datp.x_tit)
	    		         'Y_TIT':    y_tit(wi)      =string(datp.y_tit)
	   			 'Z_TIT':    z_tit(wi)      =string(datp.z_tit)
	   			 'OTHER_TIT':other_tit(wi)  =string(datp.other_tit)
	   			 'TIME' :    head_tit (wi,4)=string(datp.time)

	   			 'P'	  :begin  j=n_elements(datp.p)       < npars
	   			 		  if j eq 1 then $
	   			 		  iii=execute ('p'+wstr+'=datp.p') else $
	   			 		  iii=execute ('p'+wstr+'=datp.p(0:j-1)')
	   			 	   end
	   			 'PAR_TXT':begin  j=n_elements(datp.par_txt) < npars
	   			 		  if j eq 1 then par_txt(wi,0)=datp.par_txt else $
	   			 		  for i=0,j-1 do begin
	   			 		  		 par_txt(wi,i)=datp.par_txt(i)
	   			 		  		 if strpos(par_txt(wi,i),'=') le 0 then $
	   			 		  		 par_txt(wi,i)=par_txt(wi,i)+'='
	   			 		  endfor
	   			 	   end
	   			  ELSE:
	   			  ENDCASE
	    		     endfor
			endif
endif
return
end

pro mod_datp,datp,tag,val
;** ********
sz=size(tag)
if (n_tags(datp) gt 0) and (sz(1) gt 0) and (sz(2) eq 1) and (n_elements(val) gt 0) then begin

	    		     x=0 & y=0 & z=0 & e=0 & n=0 & pv=0 & p=0      & par_txt=''
	    		     w_tit=''  & x_tit=''  & y_tit=''   & z_tit='' & other_tit='' & time=''
	    		     tlist=tag_names(datp)
	    		     for k=0,n_elements(tlist)-1 do begin
	    		         CASE tlist(k) of

	    		         'X':	 x =datp.x
	    		         'Y':	 y =datp.y
	    		         'Z':	 z =datp.z
	    		         'E':	 e =datp.e
	    		         'N':	 n =datp.n
	    		         'PV':	 pv=datp.pv

	    		         'W_TIT':    w_tit    =datp.w_tit
	    		         'X_TIT':    x_tit    =datp.x_tit
	    		         'Y_TIT':    y_tit    =datp.y_tit
	   			 'Z_TIT':    z_tit    =datp.z_tit
	   			 'OTHER_TIT':other_tit=datp.other_tit
	   			 'TIME' :    time     =datp.time

	   			 'P'	  :  p        =datp.p
	   			 'PAR_TXT':  par_txt  =datp.par_txt
	   			  ELSE:
	   			  ENDCASE
	    		     endfor

	    		     iii=execute(tag+'=val')
      			     DATP={X:x,Y:y,Z:z,E:e,N:n,PV:pv,W_TIT:w_tit,X_TIT:x_tit    ,$
      			     	   Y_TIT:y_tit,Z_TIT:z_tit,OTHER_TIT:other_tit,TIME:time,$
      			     	   P:p,PAR_TXT:par_txt}
endif
return
end

pro did_objet,wi,objout
;** *********
@lamp.cbk

objout=0
if (wi ge 1) and (wi le lamp_sys+3) and (sys_dep('VERSION') ge 5.1) then begin
	if strpos(strupcase(par_txt(wi,0)),'OBJECT:') eq 0  then begin
	   ii=execute('P=P'+strtrim(string(wi),2)+'(0)')
	   if (P ge 1) and (fix(P) eq P) then objout=P
endif & endif
end

pro set_suf ,input & RDSET,suffix=input & END
pro set_pref,input & RDSET,prefix=input & END
;** ********

pro RDSET , INST=inst , BASE=base  ,CYCLE=cyclo , TOLERANCE=tol ,STEP=step ,RAW=raw ,DEFAULT=def $
	  , DIR=dir   , NORAW=noraw,DIF=dif , LAST=lst , GOLAST=gol , PREFIX=prefx   ,SUFFIX=sufx
;** *****
;** set INST_VALUE , PATH_FOR_ONLINE , Other dependent parameters for read-in procedures
@lamp.cbk
common c_rdid , dzap, pzap, pzip, pzup
common c_rdid2, zapa, zape, zipi, zupo, zupe
common c_edf  , pref, suf

if keyword_set(inst) then begin
   ins=strlowcase(strtrim(inst,2))
   idx=where  (strlowcase(lamp_ins) eq ins) & idx=idx(0)
   if  idx ge 0 then P_MAC_EVENT  ,0 ,[-88,560,0,b_labins(0),b_labins(1),idx,0,0]
   endif
if keyword_set(base) then begin
   bas=strtrim(base,2)
   idx=where  (strlowcase(lamp_ali) eq strlowcase(bas)) & idx=idx(0)
   if n_elements(cyclo) ne 1 then cyclo=0
   if  idx ge 0 then P_MAC_EVENT  ,0 ,[-88,561,0,b_labins(0),b_labins(1),idx,0,long(cyclo)]
   endif
if keyword_set(raw)	 then begin if b_labins(4) gt 0 then widget_control,bad_id=ii,b_labins(4),set_button=1
				    monimon=-1 & endif
if (keyword_set(noraw) or $
    keyword_set(def))	 then begin if b_labins(4) gt 0 then widget_control,bad_id=ii,b_labins(4),set_button=0
				    monimon= 0 & endif

if n_elements(lst)   eq 1 then  if (size(lst))(1)    eq 7 then if lst  gt ' ' then zapa=lst

if n_elements(gol)   eq 2 then  if  n_elements(zapa) eq 1 then if zapa gt ' ' then begin
				    ii=execute(zapa+',W'+strtrim(string(gol(1)),2)+',gol(0)') & zapa='' & endif

if n_elements(tol)   eq 1 then set_tolerance,tol
if n_elements(step)  eq 1 then pzip=step<10.>0.
if n_elements(dir)   eq 1 then pzup=dir
if n_elements(dif)   eq 1 then dzap=dif
if n_elements(prefx) eq 1 then pref=prefx
if n_elements(sufx)  eq 1 then suf =sufx
end

function rdsum, run1,run2 ,stati,datp=rdp ,W=wii ,COMPLEMENT=complement
;******* *****
;** read run1 sum to run2 from formula entry	!!! W21 is the temp workspace
@lamp.cbk
    wac=lamp_sys+1 &  was=strtrim(string(wac),2) & A_clear, W=wac
    stati=0 & status=-1
    if (n_elements(run1) eq 1) and (n_elements(run2) eq 1) then begin
    	if one le 0 then  one  =19
	if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then one=wii
	wi =one & ws =strtrim(string(wi),2)

	if keyword_set(complement) then begin bod=one & bid=two & XICUTE,'w'+was+'=w'+ws & one=bod & two=bid & endif

	if abs(run2-run1) ge 10 then begin
		p_did_getrun, run1 ,wi,stati & if stati ne 0 then return,0
		p_did_getrun, run2 ,wi,stati & if stati ne 0 then return,0
	endif
	for i=long(run1),run2 do begin
		p_did_getrun, i ,wi,status
		if status eq 0 then begin
			tt=tolerance
			if monimon lt 0 then W_ACCU, accu=wac , add=wi ,tolerance=tt ,/raw $
					else W_ACCU, accu=wac , add=wi ,tolerance=tt
			toler=tt
		endif else stati=i
		if RDSTOP(run1,run2,(i)) then i=run2+1
	endfor
	iii=execute('x'+ws+'=x'+was)
	iii=execute('n'+ws+'=n'+was)
	iii=execute('e'+ws+'=e'+was)
        other_tit(one)=other_tit(one)+' '+strtrim(string(run1),2)+'>'+strtrim(string(run2),2)
	if status eq 0 then RDSET,golast=[wi,wac]
   endif
if n_elements(rdp) gt 0 then begin tmp=two & two=one & take_datp,rdp & two=tmp & endif
tmp=0 & ii=execute('tmp=w'+was)
return,tmp
end

function rdrun, run ,stati,datp=rdp ,W=wii
;******* *****
;** read a run from formula entry
@lamp.cbk

   wtm=0L & run2=0
   if n_elements(stati) eq 1 then if stati gt run then begin
      run2=stati
      wtm =rdsum(run,run2,W=wii)
   endif

   if run2 eq 0 then begin
    stati=0
    if n_elements(run) eq 1 then begin
        if one le 0 then  one  =19
	if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then one=wii
	wi =one & ws =strtrim(string(wi),2)
	p_did_getrun, run,wi,status
	if status eq 0 then RDSET,golast=[wi,wi]
	if status eq 0 then iii=execute('wtm=w'+ws) else stati=run
    endif
   endif
if n_elements(rdp) gt 0 then begin tmp=two & two=one & take_datp,rdp & two=tmp & endif
return,wtm
end

function rdand, run1,run2 ,stati ,datp=rdp ,accu=accu ,flip=flip ,mon=monoto ,FRAME=rrun ,W=wii ,COMPLEMENT=complement
;******* *****
;** read run1 and to run2 from formula entry	!!! W21 is the temp workspace
@lamp.cbk
common keep_rd, sz,sn,tkx,tkz

   cool=1
   if (n_elements(w21) gt 1) and (lamp_sys gt 21) then begin cool=0 & was=strtrim(string(lamp_sys+1),2) & bod=one & bid=two & XICUTE,'w'+was+'=w21' & one=bod & two=bid & endif
;  Ken"s crack
   IF (inst_group EQ 'ISIS') THEN BEGIN
	ii=EXECUTE('w21=rdand_isis(run1,run2,flip=flip)')
	if ii eq 1 then begin tmp=w21 & if cool then w21=0 else begin bod=one & bid=two & XICUTE,'w21=w'+was & one=bod & two=bid & endelse
			      RETURN, tmp ;if rdand_isis not here then continue...
	ENDIF
   ENDIF
   w21=0 & x21=0 & n21=0 & e21=0 & stati=0
   if (n_elements(run1) eq 1) and (n_elements(run2) eq 1) then $
   if  run2 ge run1 then begin
        if one le 0 then  one  =19
	if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then one=wii
	wi =one & ws =strtrim(string(wi),2)
	status=0
	if n_elements(rrun)   eq 0 then rrun   =0
	if n_elements(monoto) ne 1 then monoto =monimon
	if not keyword_set(flip)   then flip   =1
	if     keyword_set(accu)   then begin J=0
			 bod=one & bid=two & XICUTE,'w21=w'+ws & one=bod & two=bid & sz21=size(w21)
			 mon= fltarr(sz21(sz21(0)))+n21(0)
	endif else begin J=flip
			 if rrun(0) then begin ruun=rrun(0) & nimg=run1 & endif else ruun=run1
			 if n_elements(rrun) eq 2 then $
				nimg=strtrim(string(rrun(1)),2)+'.'+strtrim(string(nimg),2)
			 p_did_getrun, ruun ,21,status, FRAME=nimg
			 sz =(size(w21))(0)     & sn =(size(n21))(0)  & tkx=0
			 if sz eq 1 then if n_elements(x21) eq n_elements(w21) then tkx=1
			 pv21=p21 & z21=z21(*,0)
			 if n_elements (z21) eq 1 then tkz=1 else tkz=0
			 mon= total  (n21(*,0))
			 if   keyword_set(complement)  then begin J=0
			      MOVEPAR, (wi),ws, 21,'21' & ii=execute('W21=W'+ws)
			      sz21=size(w21)
			      if sz lt sz21(0) then mon=fltarr(sz21(sz21(0))) else mon=0.
			      mon=mon+total(n21(*,0))
			      endif
	endelse

	if status eq 0 then $
	if run2-run1 ge 10 then begin
	   if J      eq 0  then p_did_getrun, (run1) ,wi,status
	   if status eq 0  then p_did_getrun, (run2) ,wi,status
	endif
	stati=status

	if status eq 0 then $
	for i=long(run1)+J,run2,flip do begin
		if rrun(0) then begin ruun=rrun(0) & nimg=i & endif else ruun=i
		if n_elements(rrun) eq 2 then $
				nimg=strtrim(string(rrun(1)),2)+'.'+strtrim(string(nimg),2)
		p_did_getrun, ruun ,wi,status, FRAME=nimg
		if status eq 0 then begin
			if sz  lt 1 then iii=execute('w21=[  w21  ,  w'+ws+'  ]')    else $
			if sz  eq 1 then iii=execute('w21=[ [w21] , [w'+ws+'] ]')    else $
			if sz  ge 2 then iii=execute('w21=[[[w21]],[[w'+ws+']]]')
			if sz  lt 1 then iii=execute('x21=[  x21  ,  x'+ws+'  ]')    else $
			if tkx eq 1 then iii=execute('x21=[ [x21] , [x'+ws+'] ]')
			if sz  eq 1 then iii=execute('y21=[  y21  ,  y'+ws+'  ]')
			if sz  eq 1 then       if n_elements(e21) gt 1 then $
			                 iii=execute('e21=[ [e21] , [e'+ws+'] ]')
			if sn  lt 2 then iii=execute('n21=[ [n21] , [n'+ws+'] ]')    else $
					 iii=execute('n21=[[[n21]],[[n'+ws+']]]')
			if tkz eq 1 then iii=execute('z21 =[ z21  ,  z'+ws+'(*,0)]') else $
					 iii=execute('z21=[ [z21] , [z'+ws+'(*,0)]]')
			iii=execute('mon =[  mon   , total(n'+ws+'(*,0)) ]')
			iii=execute('pv21=[ [pv21] , [p'+ws+'     ] ]')
		endif
		if RDSTOP(run1+J,run2,(i)) then i=run2+1
	endfor
	if monoto ge 0 then RDMONI,0, W21,E21,N21,mon>1,monoto

	iii=execute('n' +ws+'= n21')
	iii=execute('z' +ws+'= z21')
	iii=execute('e' +ws+'= e21')
	iii=execute('pv'+ws+'=pv21')
	if sz  lt  1 then if x21(0) ne x21(n_elements(x21)-1) then iii=execute('x'+ws+'=x21')
	if sz  eq  1 then if y21(0) ne y21(n_elements(y21)-1) then iii=execute('y'+ws+'=y21')
	if tkx eq  1 then begin sid=size (x21) & mid=sid(sid(0))
				if sid(0) eq 2 then if sid(2) eq (size(w21))(2) then begin
				   zid=total(x21( *,mid-1) - x21(*,0))
				   if zid ne 0 then begin          iii=execute('x'+ws+'=x21')
							    	   y21=transpose([[y21],[y21]])
							    	   y21=congrid  (  y21 ,sid(1),mid)
								   iii=execute('y'+ws+'=y21')
				endif & endif
	endif
	if sz lt  1 then if x_tit(wi) eq '' then x_tit(wi)='Run number'
	if sz eq  1 then if y_tit(wi) eq '' then y_tit(wi)='Run number'
	if sz eq  2 then if z_tit(wi) eq '' then z_tit(wi)='Run number'
	if (n_elements(accu) eq 0) and (status eq 0) then   RDSET,golast=[wi,21]
   endif

if n_elements(rdp) gt 0 then begin bid=two & two=one & take_datp,rdp & two=bid & endif
tmp=w21 & if cool then w21=0 else begin bod=one & bid=two & XICUTE,'w21=w'+was & one=bod & two=bid & endelse
return,tmp
end

function rdopr, text,stati,datp=rdp,W=wii
;******* *****
;**
@lamp.cbk

if one le 0 then  ones =19 else ones=one
if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then ones=wii
txt=text
rdmulti, txt,stati,0,ones
wt =0L
if stati   eq 0 then ii=execute('wt=w'+strtrim(string(ones),2)  )

if n_elements(rdp) gt 0 then begin tmp=two & two=one & take_datp,rdp & two=tmp & endif
return,wt
end

pro rdmulti, txt,status,labid,wi,monoto
;** *******
;**
;	!!! W21 or W22 or W23 is the temp workspace
@lamp.cbk

run_comd,txt,tbl,tbf
status=12
if txt ne '' then begin
	if n_elements(wi)     eq 0 then wi=one
	if n_elements(labid)  eq 0 then labid=0
	if n_elements(monoto) eq 0 then monoto=monimon
	nn=size(tbl)
	if nn(0) lt 2 then nn=1 else nn=nn(2)

        ws=strtrim(string(wi),2)
	ii=execute( 'w'+ws+'=0' )
	status=0
	lo =0
    	wac=lamp_sys+1 & if wi eq wac  then wac=wac+1
	was=strtrim(string(wac),2) & A_clear, W=wac

    	accu=',accu=ac,flip=op)' & ac=0
	mltr=(nn gt 1) or (tbl(0,0) gt 0)
	while  (status eq 0) and lo lt nn do begin
        	if (tbl(1,lo) ne 0) and (tbl(2,lo) ne 0) then begin
		    ru0 =tbl(0,lo)
        	    ru1 =tbl(1,lo)
		    rrun=tbl(3,lo) & if (rrun eq 0) and (tbf gt ' ') then rrun=tbf

        	    if ru0 eq 0 then ru0=ru1 else if ru0 gt ru1 then ru1=ru0
        	    if tbl(2,lo) ge 1 then opr='+'  else  begin opr='-'
			if ru1 gt ru0 then begin		opr='-+'
				wau=lamp_sys+3 & wat=strtrim(string(wau),2)
				A_clear, W=wau & endif & endelse
		    run =ru0
		    if (ru1-ru0 ge 10) and (abs(tbl(2,lo)) lt 2) then begin
			p_did_getrun, (ru0) ,wi,status & if status ne 0 then return
			p_did_getrun, (ru1) ,wi,status & if status ne 0 then return
		    endif
        	    while  (status eq 0) and (run le ru1) do begin
	   	        op=abs(tbl(2,lo))
	   	        if op ge 2 then begin
	   	        	if labid gt 0 then $
	   	                widget_control,bad_id=i,labid,set_value='Reading '+string(ru0)+' to '+string(ru1)
	  			one=wi
				op =op-1
				nimg=rrun
				if tbl(4,lo) gt 0 then nimg=[string(rrun),string(tbl(4,lo))]

	   	        	ii =execute('w'+ws+'=RDAND(ru0,ru1,status ,mon=monoto,FRAME=nimg'+accu)
	   	        	run=ru1
				ac=1
	   	        endif else begin
	   	        	if labid gt 0 then $
	   	                widget_control,bad_id=i,labid,set_value='Reading '+string(run)+' ...'
				nimg=0
				if rrun then begin ruun=rrun & nimg=run & endif else ruun=run
						if tbl(4,lo) gt 0 then begin
						   nimg=strtrim(string(tbl(4,lo)),2)+'.'+strtrim(string(nimg),2)
						endif

	   	        	P_DID_GETRUN, ruun ,wi, status, FRAME=nimg

        	        	if  mltr then begin
				    tt=tolerance
				    if status ne 0 then status=0    else $
        	        	    if   opr eq '-'  then W_ACCU, accu=wac ,sub=wi  else begin
				     if monoto(0) lt 0 then $
				      if opr eq '-+' then W_ACCU, accu=wau ,add=wi ,tolerance=tt,/raw else $
        	        	      if opr eq '+'  then W_ACCU, accu=wac ,add=wi ,tolerance=tt,/raw
				     if monoto(0) ge 0 then $
				      if opr eq '-+' then W_ACCU, accu=wau ,add=wi ,tolerance=tt      else $
        	        	      if opr eq '+'  then W_ACCU, accu=wac ,add=wi ,tolerance=tt
				    endelse
				    toler=tt
        	        	endif
				if RDSTOP(ru0,ru1,(run)) then run=ru1+1
	   	        endelse
			if status eq 0 then run=run+1
        	    endwhile
		    if 	opr eq '-+'  then W_ACCU, accu=wac ,sub=wau
		    if  abs(tbl(2,lo)) lt 2 then  $
			if monoto(0) gt 0 then begin moni=monoto
;			   if monoto(0) eq 0 then moni=-(ru1-ru0+1) ;(IF /RAW !!!)
			   if mltr then ii=execute('RDMONI,1,W'+was+',E'+was+',N'+was+',N'+was+'(*,0)>1,moni') $
				   else ii=execute('RDMONI,1,W'+ws +',E'+ws +',N'+ws +',N'+ws +'(*,0)>1,moni')
			endif
        	endif
        	lo=lo+1
	endwhile
	if status ne 0  then begin ii=execute( 'w'+ws+'=0' )
			outext='% Restore '+string(run)+' failed ...'
	endif else begin
        	        if (nn gt 1) or ((tbl(0,0) gt 0) and (abs(tbl(2,0)) eq 1)) then $
			if (abs(tbl(2,0)) ne 2) then begin
        	           ii=execute( 'W'+ws+'=w'+was )
        	           ii=execute( 'X'+ws+'=x'+was )
        	           ii=execute( 'N'+ws+'=n'+was )
        	           ii=execute( 'E'+ws+'=e'+was )
			   if monimon   ge 0 then $
			   ii=execute( 'E'+ws+'=e'+was ) else ii=execute( 'E'+ws+'=0')
        	        endif
        	        other_tit(wi)=other_tit(wi)+' '+txt
			outext='Data restored in W'+ws
			RDSET,golast=[wi,wi]
	endelse
	if labid gt 0 then if wi le lamp_sys then widget_control,bad_id=i,labid,set_value=outext
endif
return
end

pro RDMONI,HZ, W21,E21,N21,moni,mol
;** ******
;** HZ=0 comes  from RDAND   (one count by spectra or frame)
;** HZ=1 comes  from RDMULTI (X monitor)
;** moni is the current monitor while mol is the new monitor.
	mon=moni
	if mol eq 0 then mol=round(total(mon)/n_elements(mon))*1.
	if mol lt 0 then mol=round(total(mon)/n_elements(mon))*1./(-mol)
	if (mon(0) ne mol(0)) or (mon(n_elements(mon)-1) ne mol(0)) then begin
	   if HZ then n21(*,0)=mol else n21=mol
	   mon=mol/mon & sz21=size(w21)
	   if  n_elements(w21) eq n_elements(E21)  then ero=1 else ero=0
	   if (n_elements(mon) ne sz21(1)) and HZ  then mon=mon(0)

	   if  sz21(0) le 1 then  begin	if ero then E21=E21*mon  else $
					if HZ  then E21=sqrt(w21)*mon & w21=w21*mon & endif

	   if  sz21(0) eq 2 then  begin	for i=0,sz21(2)-1 do if HZ then w21(0,i)  =(w21(*,i)  )*mon $
								   else w21(0,i)  =(w21(*,i)  )*mon(i)
			    if ero then for i=0,sz21(2)-1 do if HZ then E21(0,i)  =(E21(*,i)  )*mon $
								   else E21(0,i)  =(E21(*,i)  )*mon(i) & endif
	   if  sz21(0) eq 3 then  begin	for i=0,sz21(3)-1 do if HZ then w21(0,0,i)=(w21(*,*,i))*mon $
								   else w21(0,0,i)=(w21(*,*,i))*mon(i)
			    if ero then for i=0,sz21(3)-1 do if HZ then E21(0,0,i)=(E21(*,*,i))*mon $
								   else E21(0,0,i)=(E21(*,*,i))*mon(i) & endif
	endif
end

pro run_comd, text,tbl,tbf
;** ********
;**
;** Command analysis

text=text+"&"
ttt =[0L,0L,0L,0L,0L]
tbf =''
tbl =ttt & tbl(2)=1 & j =1 & run=''
on_ioerror,mis     & ok=0 & fil=0
for i=0,strlen(text)-1 do begin

    c =  strmid(text,i,1)
    case 1 of
    (c eq ' ') or (c eq '(') or (c eq ')'):
    (c eq '{') or (c eq '['):begin
			     if run ne ''  then  begin fil=0 & on_ioerror,misfil
			     	a=strmid(run,0,1)
				if (a ge '0') and (a le '9') then fil=long(run)
			     	misfil: if fil eq 0 then tbf=run
			        on_ioerror,mis & endif
			     run=''  & end
    (c eq '}') or (c eq ']') or (c eq '&'):begin
    			     if run ne ''  then tbl(1  ,j-1)=long(run)
    			     if run ne ''  then tbl(3  ,j-1)=fil
    			     run='' & fil=0 & end
    (c eq '-') or (c eq '+') or (c eq ',') or (c eq ';'):begin
    			     if run ne ''  then tbl(1  ,j-1)=long(run)
    			     if run ne ''  then tbl(3  ,j-1)=fil
    			     run=''
    			     tbl=[[tbl],[ttt]]
    			     if (c eq '-') then tbl(2  ,j)=-1   else tbl(2,j)=1
    			     j  =j+1 & end
    (c eq '<') or (c eq '>') or (c eq ':'):begin
    			     if run ne ''  then tbl(0  ,j-1)=long(run)
    			     if run ne ''  then tbl(3  ,j-1)=fil
    			     if  c  eq ':' then tbl(2  ,j-1)=abs(tbl(2,j-1))+1
    			     run=''  & end
    (c eq '.'):              begin
			     if (fil eq 0) and (tbf eq '') then run=run+c $
			     else begin
    			     if run ne ''  then tbl(4  ,j-1)=long(run) & run=''
			     endelse
			     end
    else:		     run=run + c
    endcase
    endfor
nn=size(tbl)
if nn(0)    lt 2 then nn=1  else nn=nn(2)
if tbl(1,0) eq 0 then if nn gt 1 then begin tbl=tbl(*,1:*) & nn=nn-1 & endif
ok=1
mis:text=''
bo=0
if  ok eq 1 then $
for i=0,nn-1  do $
    if (tbl(1,i) ne 0) and (tbl(2,i) ne 0)  then begin
	if tbl(3,i) ne fil then  if bo eq 1 then text=text+'}'
    	if tbl(2,i) eq  1  then  if i  gt 0 then text=text+'+'
	if tbl(2,i) ge  2  then  if i  gt 0 then text=text+','
    	if tbl(2,i) le -1  then                  text=text+'-'
	if tbl(3,i) ne fil then  begin fil= tbl(3,i) & bo=0
	     if fil gt  0  then  begin bo = 1  & text=text+strtrim(string(fil),2)+'{' & endif
	endif
    	if tbl(0,i) ne  0  then  $
    	if tbl(4,i) eq  0  then text=text+strtrim(string(tbl(0,i)),2) $
    	else text=text+strtrim(string(tbl(4,i)),2)+'.'+strtrim(string(tbl(0,i)),2)

	op=abs(tbl(2,i))
    	if tbl(0,i) ne  0  then  if op eq 1 then text=text+'>' $
					    else text=text+string(replicate(58b,op-1))

    	if tbl(4,i) eq  0  then text=text+strtrim(string(tbl(1,i)),2) $
    	else text=text+strtrim(string(tbl(4,i)),2)+'.'+strtrim(string(tbl(1,i)),2)
    endif
if  bo eq 1  then text=text+'}'
if (tbf gt '') and (strpos(text,'{') lt 0) then text=tbf+'{'+text+'}'
return
end

pro set_tolerance,tt ,get=get ,tol=tol
;** *************
;**
@lamp.cbk
    if keyword_set(get) then   tt=tolerance else $
    if keyword_set(tol) then   toler=tol    else $
    if n_elements (tt)  eq 1 then tolerance=tt
end

pro W_ACCU, accu=wi , add=wj , sub=wk , combine=wl , tolerance=tt , ero=ero ,raw=raw
;** ******
;**
;** Operation on accumulator wi (add or subtract or combine)

@lamp.cbk

;CHECK FOR CONSISTENCIES
;***** *** *************
if n_elements(wi) eq 1 then if (wi ge 1) and (wi le lamp_sys+3) then begin

   wis= strtrim(string(wi),2)	& wiw='w'+wis & wix='x'+wis & win='n'+wis & wie='e'+wis

   wjn= n_elements(wj)		& wkn=n_elements(wk)	    & wln=n_elements(wl)

   if wjn+wkn+wln eq 1 then begin

      if wkn eq 1 then begin opr='-' & wj=wk & endif else $
      if wln eq 1 then begin opr='c' & wj=wl & endif else opr='+'
      if keyword_set(raw)  then rw=1 else rw=0

      if (wj ge 1) and (wj le lamp_sys+3) then begin

   	wjs= strtrim(string(wj),2)	& wjw='w'+wjs & wjx='x'+wjs & wjn='n'+wjs & wje='e'+wjs

   	swi=0L & ii=execute( 'swi=size('+wiw+')' ) & swj=0L & ii=execute( 'swj=size('+wjw+')' )
   	sxi=0L & ii=execute( 'sxi=size('+wix+')' ) & sxj=0L & ii=execute( 'sxj=size('+wjx+')' )
   	sni=0L & ii=execute( 'sni=size('+win+')' ) & snj=0L & ii=execute( 'snj=size('+wjn+')' )
   	sei=0L & ii=execute( 'sei=size('+wie+')' ) & sej=0L & ii=execute( 'sej=size('+wje+')' )

	if swi(swi(0)+2)  gt 1 then begin

;	DEFINE PARAMETERS IF NECESSARY (X,N,E).
;	****** ********** ** ********* *******
;I-x						ii=execute( wix+'=float('+wix+')')
	if swi(0) 	 gt 0 		  then  $
	   if  swi(1)    ne sxi(1)	  then  ii=execute( wix+'=findgen(swi(1))+1' )
;I-e
	ero=1 & oro=0
   	if sei(sei(0)+2) ne swi(swi(0)+2) then  if swi(0) eq 1 then $
   						ii=execute( wie+'=sqrt('+wiw+')' ) else ero=0 else oro=1
;I-n
	if (sni(0) gt 1) and (sni(1) ne swi(1)) then iro=0 else iro=1
	if iro eq 1 then begin
  	if sni(1)	 ne   swi(1)	  then  ii=execute( win+'=fltarr(swi(1))+'+win+'(0)>1' ) else $
        if sni(0)	 gt 1		  then  $
	   if  swi(0)    eq 1		  then  ii=execute( win+'=fltarr(swi(1))+total('+win+'(*,0))>1' )
	endif
   	ii=execute( 'sxi=size('+wix+')' )
	ii=execute( 'sni=size('+win+')' )
	ii=execute( 'sei=size('+wie+')' )
;J-x
	if swj(0) 	 gt 0 		  then  $
	   if  swj(1)    ne sxj(1)	  then  ii=execute( wjx+'=findgen(swj(1))+1' )
;J-e
	if ero eq 1 then begin
	   if swj(0) eq 1 then wjee=1  &  ii=execute('wjee='+wje)
   	   if sej(sej(0)+2) ne swj(swj(0)+2) then  if swj(0) eq 1 then $
   						   ii=execute( 'wjee=sqrt('+wjw+')' ) else ero=0
        endif
;J-n
	wjnn=1    &   ii=execute('wjnn=' +wjn)
	if iro eq 1 then begin
   	if snj(snj(0)+2) ne swj(swj(0)+2) then  $
   	   if  snj(1)    ne     swj(1)    then  ii=execute( 'wjnn=fltarr(swj(1))+'+wjn+'(0)>1' ) else $
           if  snj(0)	 gt 1		  then  $
	     if  swj(0)  eq 1		  then  ii=execute( 'wjnn=fltarr(swj(1))+total('+wjn+'(*,0))>1' )
	endif
   	ii=execute( 'sxj=size('+wjx+')' )
	ii=execute( 'snj=size('+wjn+')' )
	ii=execute( 'sej=size('+wje+')' )

;	DEFINE A TOLERANCE IF NOT
;	****** * ********* ** ***
   	if n_elements(tt) ne 1 then tt=0
	if tt le 0 then begin
		k1=1L & ii=execute( 'k1=n_elements('+wix+')-1' )
		k2=1L & ii=execute( 'k2=n_elements('+wjx+')-1' )
		ii=execute( 'k1=float(abs('+wix+'(k1-1)-'+wix+'(0)))/k1' )
   		ii=execute( 'k2=float(abs('+wjx+'(k2-1)-'+wjx+'(0)))/k2' )
		tt=min([k1,k2])/3
	endif

;	   MATRIX OPERATION
;	   ****** *********
	   if (swj(0) gt 1) or (not iro)  then begin
	   		if opr eq 'c' then opr='+'
	   		if opr eq '+' then begin
			  tst=1 & iii=execute('tst=('+wix+'(0) eq '+wjx+'(0)) and ('+wix+'(swi(1)-1) eq '+wjx+'(swj(1)-1))')
			  if (sxj(0) ne 1) or (tst) or (swj(2) ne swi(2)) or (not iro) then begin
			   iii=execute( wiw+'=float(' +wjw +')' +opr+wiw )
			   iii=execute( win+'=float(   wjnn  )' +opr+win )
			   iii=execute( wie+'=sqrt(float(' +wje+')^2'+opr+wie+'^2)' )
			   if (iro) and (tst) and (not rw) then begin m1=1.  & iii=execute('m1=total('+win+'(*,0))')
			        if m1 le 1 then iii=execute( win+'=0') ;$
				;else      begin iii=execute( wiw+'='+wiw+'/2') & iii=execute( win+'(*,0)='+win+'(*,0)/2')
				;		 iii=execute( wie+'='+wie+'/2') & endelse
			   endif

			  endif else begin
			   if ero eq 0 then begin tmerr=fltarr(swj(1))+1 & myerr='tmerr'
						  tme  =fltarr(swi(1))+1 & endif
			   if oro eq 1 then rw=0 ;added for D2B !!!
			   tmw=0 & tmx=0 & tmn=0 & rsw=0 & rse=0
			   for  i=0,swj(2)-1 do begin
				iii=execute('tmw=' +wiw+'(*,i)')  &  iii=execute('tmx=' +wix)
				iii=execute('tmn=' +win)
				if ero eq 1 then iii=execute('tme=' +wie+'(*,i)')
				if ero eq 1 then myerr=wje+'(*,i)'
	   			iii=execute( 'V_ACCU,opr,   tmw       ,  tmx  ,  tmn       ,  tme    ,'   $
	   						   +wjw+'(*,i),'+wjx+',  wjnn(*,0) ,'+myerr+', tt ,raw=rw')
				if i eq 0 then begin rsw=fltarr(n_elements(tmw),swj(2))
				                     if ero eq 1 then rse=rsw & endif
				rsw(*,i)=tmw
				if ero eq 1 then rse(*,i)=tme
			   endfor
			   iii=execute(wiw+'=rsw') & iii=execute(wix+'=tmx')
			   iii=execute(win+'=tmn') & iii=execute(wie+'=rse')
			  endelse

			endif
	   		if opr eq '-' then begin na=1. & ni =1.
	   		   iii=execute('na   =total(' +win +'(*,0))>1')
					ni   =total(     wjnn(*,0))>1
	   		   m  =na/ni
			   iii=execute( wiw+'='+wiw+opr+wjw+'*m' )
			   if ero eq 1 then iii=execute(wie+'=sqrt('+wie+'^2+'+wje+'^2*m)')
			endif

;	   VECTOR OPERATION
;	   ****** *********
	   endif else begin
			if oro eq 1 then rw=0 ;added for I dont know !!!
	   		iii=execute( 'V_ACCU,opr,' +wiw+','+wix+','+win+'      ,'+wie+','   $
	   					   +wjw+','+wjx+',  wjnn(*,0)  ,  wjee , tt ,raw=rw')
	   endelse

	endif else begin oon=one & too=two & tee=three & alo=alone & ifi=ifixed & don_me_lastf, lfoo ,0
			 ifixed=0
			 XICUTE,wiw+'=float('+wjw+')'
			 one=oon & two=too & three=tee & alone=alo & ifixed=ifi & don_me_lastf, lfoo ,1
	endelse
      endif
   endif else begin bid=two & XICUTE,wiw+'=0' & two=bid & one=0 & endelse
endif
return
end

pro V_ACCU, ops ,wa,xa,na,ea, wi,xi,ni,ei , tt ,raw=raw
;** ******
;**
    if  ops eq 'c' then opr='-' else opr=ops

;   ADDITION : Accumulator  --> wa, xa, na, ea = counts, abcissa, monitors, errors
;   -------- : New spectrum --> wi, xi, ni, ei   tolerance is tt.

    if  opr eq '+' then begin
;	JOIN ACCU AND SPECTRUM
;	---- ---- --- --------
	if keyword_set(raw)  then rw=1 else rw=0
	xa =[xa,xi]	   & sa=n_elements(wa) & si=n_elements(wi)
	idx=sort(xa)	   & xa=xa(idx)
	wa =[wa,wi]	   & wa=wa(idx)  & wa=float(temporary(wa))
	na =[na(*,0),ni]>1 & na=na(idx)  & na=float(temporary(na))
	ea =[ea,ei]	   & ea=ea(idx)  & nn=n_elements(xa)
	if not rw then begin wa=wa/na	 & m1=total (na)/nn & ea=ea/na*m1 & na(*)=1. & endif
	k  = 0

	for  i=1,nn-1 do begin

	     if (xa(i)-xa(k))  le tt  then begin
;	     MERGE TWO POINTS
;	     ----- --- ------
		 wp =wa(i) & ep=ea(i)

;		 INTERPOLATE IF POSSIBLE.
;		 ----------- -- --------
		 if (xa(i) ne xa(k)) and (not rw) then begin ip=idx(i)-sa-1
ip=-1 ;No op
		  if ip    ge  0     then begin   if (xa(k) gt xi(ip)) then begin	   ;i is  new
						  fac  =(xa(i)-xa(k))  /(xa(i)-xi(ip))
						  fac  = fac<.5 & fac1=1.-fac
						  wp   =(fac1)*wa(i)+ fac*wi(ip)/(ni(ip)>1)
						  ep   =(fac1)*ea(i)+ fac*ei(ip)/(ni(ip)>1)*m1
					  	  endif
		  endif else begin ip=idx(k)-sa
ip=-1 ;No op
		   if (ip ge 0) and (ip lt si-1)  then begin ip=ip+1			   ;k was new
						  if (xi(ip) gt xa(i)) then begin
						  fac  =(xa(i)-xa(k))  /(xi(ip)-xa(k))
						  fac  = fac<.5 & fac1=1.-fac
						  wa(k)=(fac1)*wa(k)+ fac*wi(ip)/(ni(ip)>1)
						  ea(k)=(fac1)*ea(k)+ fac*ei(ip)/(ni(ip)>1)*m1
						  xa(k)= xa(i)
						  endif
		 endif & endelse & endif

;!!!!!!		 Physique or not physique ????
		 phy=ea(k)*ep ; phy=0

		 idx(k)=0
		 if rw  then begin wa(k)= wa(k)+wp & na(k)=na(k)+na(i) & ea(k)=sqrt(ea(k)^2+ep^2)   ; raw addition !!

		 endif else if phy eq 0 then begin
	     	    na(k)= na(k)+1
	     	    wa(k)= wa(k)+wp			; w = (wa+wi)
	     	    ea(k)= sqrt(ea(k)^2 + ep^2)		; e = sqrt(ea^2 + ei^2)
		 endif else begin
		    eak  =1./ea(k)^2 &  epk=1./ep^2
		    wa(k)=(wa(k)*eak+wp*epk)/(eak+epk)	; w = ( wa/ea^2 + wi/ei^2 ) / ( 1/ea^2 + 1/ei^2)
		    ea(k)=1./sqrt(eak+epk)		; e = 1/sqrt(1/ea^2 + 1/ei^2)
		 endelse
	     endif else begin
;	     OR MAKE A NEW POINT.
;	     -- ---- - --- -----
	      	 k= k+1
	      	 if k ne i then begin
	            xa(k)= xa(i) & idx(k)=idx(i)
	            wa(k)= wa(i) & ea (k)= ea(i)
		    if rw  then    na (k)= na(i)
	       	 endif
	     endelse
	endfor
	if k lt nn-1 then begin
	   xa= xa(0:k)  & wa=wa(0:k)
	   na= na(0:k)  & ea=ea(0:k)
	   if not rw then begin wa= wa/na & ea= ea/na & endif
	endif
;	NORMALIZE
;	---------
	   if not rw then begin wa= wa*m1 & na(*)= m1 & endif
    endif

;   SUBTRACTION
;   -----------
    if  opr eq '-' then begin
;	SORT
;	----
	idx=sort(xa)  & xa=xa(idx) & wa=wa(idx) & na=na(idx) & ea=ea(idx)
	idx=sort(xi)  & xi=xi(idx) & wi=wi(idx) & ni=ni(idx) & ei=ei(idx)

;	INTERPOLATE MISSING ABSCISSA
;	----------- ------- --------
	if ops ne 'c' then begin

	 m1 =total(na)/ n_elements(wa)
	 wa =float(temporary(wa))/(na>1)*m1
	 wp =float(wi)/(ni>1)*m1   & si=n_elements(wp)

	 yy =INTERPOL(wp, xi,xa)   & ea=ea/(na>1)* m1
	 yer=INTERPOL(ei/(ni>1)*m1 , xi,xa)

	 id1=where(xa lt xi(0))			& i1=n_elements(id1)
	 id2=where(xa gt xi(n_elements(xi)-1))	& i2=n_elements(id2)

	 nn =10<(si/3) & nn=nn>1
	 if i1 gt 1 then begin	ab =LADFIT(xi(0:nn),wp(0:nn))
				yy (id1)=ab(0)+ ab(1)*xa(id1)
				yer(id1)=max(abs(yy(id1)))/2    & endif
	 if i2 gt 1 then begin	ab =LADFIT(xi(si-nn-1:*),wp(si-nn-1:*))
				yy (id2)=ab(0)+ ab(1)*xa(id2)
				yer(id2)=max(abs(yy(id2)))/2    & endif

;	 NORMALIZE
;	 ---------
	 wa   = (wa-yy)
	 na(*)=  m1
	 ea   =  sqrt((ea^2 + yer^2))

;   COMBINE
;   -------
	endif else begin
	 id1=where(xa ge xi(0))			& id1=id1(0)>0<(n_elements(xa)-1)
	 id2=where(xa ge xi(n_elements(xi)-1))  & id2=id2(n_elements(id2)-1)>0<(n_elements(xa)-1)
	 m  =float(na(id1:id2))/(ni>1) & m1=m>1
	 yy =INTERPOL(wi*m1,xi,xa(id1:id2))
	 wa(id1:id2)=(wa(id1:id2)-yy)>0
	endelse
    endif
return
end

;************************************ JOURNAL *************************************
;************************************ JOURNAL *************************************
;************************************ JOURNAL *************************************

pro p_did_journal, event,uv
;** *************
;**
@lamp.cbk
    i=xregistered('JOURNAL')
    if i gt 0 then widget_control,bad_id=i,uv(2),/destroy

    base=widget_base  (title='Lamp Journal',/column,resource_name='lamptouch')
    tit =widget_label (base,value='JOURNAL OF CURRENT SESSION (lamp.jou)',font=ft_biggest)
    basc=widget_text  (base,value=jou_c+'            '+jou_w,font=ft_b_normal,xsize=80,ysize=20,/scroll)
    brow=widget_base  (base,/row,SPACE=30)
    prin=widget_button(brow,value='PRINT' ,uvalue=[-88,395,base,1,basc])
    cler=widget_button(brow,value='CLEAR' ,uvalue=[-88,395,base,2,basc])
    updt=widget_button(brow,value='UPDATE',uvalue=[-88,395,base,3,basc])
    done=widget_button(brow,value='CLOSE' ,uvalue=[-88,399])
	 put_logo     ,brow

    uv(2)=base
    widget_control,event.id   ,bad_id=i,set_uvalue=uv
    widget_control,lamp_don(0),bad_id=i,set_uvalue=basc

    bid=sys_dep      ('DYNLAB',base,0)
    widget_control,base,group_leader=lamp_b1,/realize & put_logo
    widget_control,basc,SET_TEXT_TOP_LINE=(n_elements(jou_c)-18)>0
    XMANAGER, 'JOURNAL' ,base,event_handler='LAMP_EVENT_PARSER',/just_reg
return
end

pro p_did_journal_print, uv
;** *******************
;**
@lamp.cbk

if uv(3) eq 1 then begin
    text=[''] & widget_control,bad_id=ii,uv(4),get_value=text
    ON_IOERROR,misopn
    OPENW ,out,'journal.print',/GET_LUN
    	ON_IOERROR,miswrt
    	for i=0,n_elements(text)-1 do PRINTF,out,text(i)
    	miswrt:FREE_LUN,out
	dir=''
	;cd,current=dir
	;if strmid(dir,strlen(dir)-1,1) ne lamp_dvd then dir=dir+lamp_dvd
	bid=sys_dep      ('PRT_DEF',dir+'journal.print')
    misopn:
endif
if uv(3) eq 2 then begin
    DID_WRITE_JOURNAL, /clear
    widget_control,bad_id=ii,uv(2),/destroy
endif
if uv(3) eq 3 then begin
    DID_WRITE_JOURNAL
endif
return
end

pro DID_WRITE_JOURNAL, jou ,htm=htm ,clear=clear ,check=check
;** *****************
;**
@lamp.cbk
common c_kpjou, kpjou
	out=-1
	on_ioerror, end_wr
	if n_elements(jou) gt 0 then begin
		if n_elements(kpjou) eq 0 then kpjou=[2,0]
		jj=n_elements(jou_c)
		kk=(jj-kpjou(1))<20 & if kk lt 0 then kk=jj
		if kk gt 0 then jou=jou_c(jj-kk-1:jj-1)+'            '+jou_w(jj-kk-1:jj-1)
		kpjou(1)=jj
	endif else if keyword_set(htm) then begin wpth=''
	        if (GEORGE ne 0) then WebDo,'pth',wpth
		if wpth eq '' then wpth='journal.htm' else wpth=wpth+'geo_d_12htm.web'
		OPENW,out,wpth,/get_lun
		PRINTF,out,'<html><pre>'
		for i= 0,n_elements(jou_c)-1 do PRINTF,out,jou_c(i)+'            '+jou_w(i)
		PRINTF,out,'</pre></html>'
	endif else begin
		j= n_elements(jou_c)-1 & k=j & ok=0
		if n_elements(kpjou) eq 0 then kpjou=[2,0]

		if (keyword_set(check)) and (j-kpjou(0) le 35) then return

		while (k gt 0) and (not ok) do begin
	   	if strpos(jou_c(k),'SESSION') eq 0 then ok=1 else k=k-1
		endwhile

		OPENW,out,'lamp.jou',/get_lun,/APPEND
		for i= k-1,j do PRINTF,out,jou_c(i)+'            '+jou_w(i)

		if (j gt 300) or (keyword_set(clear)) then begin & kpjou(0)=2
        	                 jou_c=[      '*******','SESSION','*******'] & jou_w=[      ' ',!stime,' ']
        	endif else begin jou_c=[jou_c,'*******','SESSION','*******'] & jou_w=[jou_w,' ',!stime,' ']
        	                 kpjou(0)=j+3 & endelse
	endelse
	end_wr: if out gt 0  then begin FREE_LUN,out & if (GEORGE ne 0) and keyword_set(htm) then WebDo,'fil','geo_d_12htm.web' & endif
return
end

pro DID_PARAM_HTM , nwk
;** *************
;**
@lamp.cbk
	on_ioerror, end_wr & out=-1  & wpth=''
	        if (GEORGE ne 0) then WebDo,'pth',wpth
		if wpth eq '' then wpth='param.htm' else wpth=wpth+'geo_d_12htm.web'
		OPENW,out,wpth,/get_lun
		pp =['0']
		bb =execute('pp=string(p'+nwk+')')
		PRINTF,out,'<html><b>Parameters from W'+nwk+'  '+w_numor(fix(nwk))+'</b></br><pre>'
		for i=0,n_elements(pp)-1 do PRINTF,out,par_txt(fix(nwk),i) + pp(i)
		PRINTF,out,'</pre></html>'
	end_wr: if out gt 0  then begin FREE_LUN,out & if (GEORGE ne 0) then WebDo,'fil','geo_d_12htm.web' & endif
return
end

pro p_did_help, flg, formu,formt
;** **********
;**
common dialshare2
	if flg eq 586 then begin
	   	formu=[      'Path is your PATH WORKING DIRECTORY you can change at any time.']
	   	formt=[      '']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'Click the "Data..." button to access your instrument data on site']
	   	formt=[formt,'']
	   	formu=[formu,'        ']
	   	formt=[formt,'you may have to customize the two ins: pull-down menus.']
	   	formu=[formu,'The READ button allows access  to data from several types.']
	   	formt=[formt,'']
	   	formu=[formu,'You have to adjust the Ins format type and its location (second Ins menu)']
	   	formt=[formt,'']
	   	formu=[formu,'then enter the Run number (or file_name{i.j}) and adjust W_space (W1).']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'The CUSTOMIZE entry in the Ins: menu is what you need to start with Lamp!']
	   	formt=[formt,'']
	   	formu=[formu,'If you click the "Self..." button then you can bring up']
	   	formt=[formt,'']
	   	formu=[formu,'YOUR special interface window for accessing your data.(See CUSTOMIZE)']
	   	formt=[formt,'']
	   	formu=[formu,'This is a programmed button, as an example you may']
	   	formt=[formt,'']
	   	formu=[formu,'associate the RDFILTER procedure which provides:']
	   	formt=[formt,'']
	   	formu=[formu,'        ']
	   	formt=[formt,'- X Y and Z scaling.']
	   	formu=[formu,'        ']
	   	formt=[formt,'- X Y and Z projections, consistencies']
	   	formu=[formu,'        ']
	   	formt=[formt,'- Do simple operations on several Runs as they are read in.']
	   	formu=[formu,'The IMPORT File entry  allows you to get']
	   	formt=[formt,'']
	   	formu=[formu,'files having format such as:']
	   	formt=[formt,'']
	   	formu=[formu,'        ']
	   	formt=[formt,'- LAMP format  - XY ascii files  - NeXus hdf files      .../...']
	   	formu=[formu,'The EXPORT button is the best way to save your WORKSPACES and']
	   	formt=[formt,'']
	   	formu=[formu,'their associated parameters,history,coordinates,titles.']
	   	formt=[formt,'']
	   	formu=[formu,'The LAMP format is quit clear: A header ascii file is produced']
	   	formt=[formt,'']
	   	formu=[formu,'containing the parameters, a litte snapshot file(192*192 bytes),']
	   	formt=[formt,'']
	   	formu=[formu,'and a data file:']
	   	formt=[formt,'BINARY for c & lamp , F77 for fortran , ASCII for suspicious , XDR']
      		formu=[formu,''] & formt=[formt,'']
		formu=[formu,'Choose NeXus standard hdf format for data interchange.']
	   	formt=[formt,'']

	endif else if flg eq 587 then begin
	   	formu=[formu,'To visualize a workspace you must click on the PLOT W n button.']
	   	formt=[formt,'']
	   	formu=[formu,'']
	   	formt=[formt,'You may have to adjust its number by pressing the neighbouring arrows.']
	   	formu=[formu,'']
	   	formt=[formt,'Plot result depends of a combination of Image,Contour,Suface radio buttons.']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'Data are plotted in the small drawing-window unless you press the BESIDE button.']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'A beside-drawing-window can be re_sized using the mouse, then']
	   	formt=[formt,'']
	   	formu=[formu,'when the new size is suitable press the REPLOT button']
	   	formt=[formt,'You may also use the X-Ysize fields.']
	   	formu=[formu,'']
	   	formt=[formt,'Each time you press the PLOT W n button you get a new window.']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The PRINT buttons produce a PostScript file.']
	   	formt=[formt,'If a PostScript Device is']
	   	formu=[formu,'']
	   	formt=[formt,'specified in the Titles... interface then print-out is automatic.']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The Options... button allows you to change:']
	   	formt=[formt,'Titles, surface aspects ...']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The W LOG button (seen after More... is pressed) associated with the']
	   	formt=[formt,'']
	   	formu=[formu,'IMAGE button is useful to check for backgrounds and detector problems.']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The axis are labelled according to the values of the Workspaces"s']
	   	formt=[formt,'']
	   	formu=[formu,'coordinates. The REGULAR GRID option may imply an interpolation.']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'----']

	endif else if flg eq 588 then begin
		if GEORGE eq 1 then begin
	   	formu=[formu,'LIST OF FUNCTIONS USED TO MANAGE THE DIALS:']
	   			formt=[formt,' ']
	   	formu=[formu,'DialTag   ,    "temp2",TAG="VALUE",GET=V']
	   			formt=[formt,'    Return V, the value of the tag  "VALUE" of dial "temp2"']
	   	formu=[formu,'DialTag   ,    "temp3",TAG="ONOFF",SET=1']
	   			formt=[formt,'    Set to 1  the value of the tag  "ONOFF" of dial "temp3"']
	   	formu=[formu,'DialStart ,    "temp3"']
	   			formt=[formt,'    A short  for previous call']
	   	formu=[formu,'DialStop  ,    "temp3"']
	   			formt=[formt,'    A short  too']
	   	formu=[formu,'D1.upperlim=   150.']
	   			formt=[formt,'    modify a property of DIAL 1 (Set upper limit for plotting)']
	   	formu=[formu,'DialInit,      "template4",[NEW="tmp4"]']
	   			formt=[formt,'    Initiate dial  "template4" from file:dial_template4.pro']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    (You may change its name to "tmp4" and use DialStart,"tmp4" to activate it)']
	   	formu=[formu,'DialMacro,     "template4"']
	   			formt=[formt,'    Force execution of DIAL_TEMPLATE4_MACRO']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    ("template4"  is keept inactive, ONOFF=0)']
	   	formu=[formu,'DialClear,     "template4"']
	   			formt=[formt,'    Suppress dial  "template4" from memory']
	   	formu=[formu,'WebOn  ,       [PATH="pth"],[PASSWD="pwd"]']
	   			formt=[formt,'    Output to the web (allow input if passwd is set)']
	   	formu=[formu,'WebOff            ']
	   			formt=[formt,'    Output to the web (allow input if passwd is set)']
	   	formu=[formu,'DialsFrequency,[GET=freq],[SET=.5],[/STOP],[DURATION=90.],[/START]']
	   			formt=[formt,' ']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    Set  or Get the general frequency value (time is in seconds)']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    Stop or Start the general process, Set Time limit for the active process']
	   	formu=[formu,' ']
		formt=[formt,' ']
	   	formu=[formu,'FUNCTIONS USED EXCLUSIVELY INSIDE A DIAL-MACRO']
	   			formt=[formt,' ']
	   	formu=[formu,'R=DialOn ()']
	   			formt=[formt,'                 Return 0 if Dial has been interrupted (To be used inside loops)']
	   	formu=[formu,'DialWSet']
	   			formt=[formt,'                        Reserve central draw window for next plot']
	   	formu=[formu,'V=DialNewValue([/SETVALUE, COMMENT=txt])']
	   			formt=[formt,'    Get a new value from DIAL_"generic"_READ']
	   			formu=[formu,'                  ']
				formt=[formt,'    (a request is made to the instrument)(/SETVALUE means D.value is set to V)']
	   	formu=[formu,'C=DialControl ("command syntax",[CHECK=.5])']
	   			formt=[formt,'    Send a command to the instrument control']
	   			formu=[formu,'                  ']
				formt=[formt,'    (CHECK means check every .5 sec till the command is complete)']
	   	formu=[formu,'DialModValue,   V']
	   			formt=[formt,'     Set the new value for current dial if type or dimensions have changed']

		endif else begin

	   	formu=[formu,'RAW MANIPULATIONS']
	   			formt=[formt,'Set this mode to prevent Lamp from adjusting results as a']
	   			formu=[formu,'']
				formt=[formt,'                  function of monitors & operators.(see setmanip in INTERNAL)']
	   	formu=[formu,'INTERNAL MACROS']
	   			formt=[formt,'Access to the list by the "UserMacros" button.']
	   			formu=[formu,'IDL LANGUAGE:'] & formt=[formt,'']
	   	formu=[formu,'W4 = W1(0:35 , 5:40)']
	   	         	formt=[formt,'EXTRACT a sub-array']
	   	formu=[formu,'W4 = W1( *   ,  8)']
	   	           	formt=[formt,'EXTRACT all points at y = 8']
	   			formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'w4 = FLTARR(256,128)']
	   	           	formt=[formt,'CREATE an empty floating matrix']
	   	formu=[formu,'OPENR,L,"DON.DAT",/GET_LUN']
	   	           	formt=[formt,'OPEN the file containing the matrix']
	   	formu=[formu,'READF ,L, W4']
	   	           	formt=[formt,'READ the matrix from ASCII format or']
	   	formu=[formu,'READU ,L, W4']
	   	           	formt=[formt,'READ the matrix from BINARY format']
	   	           	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'W4 = TOTAL ( W1 )']
	   	           	formt=[formt,'Total INTEGRATION of W1 ']
	   	formu=[formu,'W4 = TOTAL ( W1 ,2)']
	   	           	formt=[formt,'Vector INTEGRATION of W1 :SUM the SECOND dimension']
	   	formu=[formu,'W4 = TOTAL ( W1 ,1)']
	   	           	formt=[formt,'Vector INTEGRATION of W1 :Y PROJECTION']
	   	           	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'W4 = CONGRID ( W1 ,100,50)']
	   	           	formt=[formt,'RESIZE W1 to a new matrix sized by 100*50']
	   	formu=[formu,'W1 = W1 > 2']
				formt=[formt,'Force any values in W1 to be >= 2']
	   	formu=[formu,'W4 = ALOG ( W1 + W2 + W3 + 1)']
	   	           	formt=[formt,'The LOGARITHMIC SUM of 3 WKspaces']
	   	           	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'W4 = [  W1  ,  W2  ,  W3  ]']
	   			formt=[formt,'JOIN workspaces into FIRST dimension']
	   	formu=[formu,'W4 = [ [W1] , [W2] , [W3] ]']
	   			formt=[formt,'into SECOND dimension']
	   	formu=[formu,'W4 = [[[W1]],[[W2]],[[W3]]]']
	   			formt=[formt,'into THIRD  dimension']
	   			formu=[formu,''] & formt=[formt,'---- See the IDL user"s guide ...']
		endelse
	endif else if flg eq 589 then begin
	   	formu=[formu,'SCROLL SPECTRA']
	   	formt=[formt,'This interface scrolls individual spectra within a workspace.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'It provides interactive zoom and animation.']
	   	formu=[formu,'RADIAL INTEGRATION']
	   	formt=[formt,'This interface defines sectors of integrations.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'MASK & GROUP']
	   	formt=[formt,'This interface regroups spectra within a workspace and']
	   	formu=[formu,'                           ']
	   	formt=[formt,'creates a mask which defines defective detectors.']
	   	formu=[formu,'GK_FIT']
	   	formt=[formt,'Calcutates gaussians & lorentz from a spectrum within a workspace.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'LOAD NEW COLORS']
	   	formt=[formt,'is used for colors adjustements and loading new tables.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'SCAN Wi']
	   	formt=[formt,'This interface provides interactive facilities such as:']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- SLICING.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- ZOOMING.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- INTEGRATING ZONES.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- FOURIER TRANSFORM.           ..../....']
	   	formu=[formu,'SUPER PLOT']
	   	formt=[formt,'Is usefull to compare spectra within one on several wkp.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'THE JOURNAL']
	   	formt=[formt,'The journal.']
	   	formu=[formu,'SAVE LAMP SESSION']
	   	formt=[formt,'Workspaces and parameters are saved for next lamp time.']
	   	formu=[formu,''] & formt=[formt,'']

endif else if flg eq 591 then begin

formu=[formu,'SuperPlot']
formt=[formt,' was written by JOUFFREY Romuald, on August 1995. Hope this Helps']
formu=[formu,'What is to be plotted :']
formt=[formt,'']
formu=[formu,'']
formt=[formt,'Adjust workspace number and cutting value with sliders, cutting axis with X or Y button.']

formu=[formu,'Manipulating local workspace plots :']
formt=[formt,'']
formu=[formu,'    "Keep as"']
formt=[formt,' Buttons allow you to keep a workspace in one of the six buffers']
formu=[formu,'']
formt=[formt,'            You can replace any kept workspace by any other, just click !']
formu=[formu,'    "Hide"']
formt=[formt,' temporarily hide a plot without losing it,'+ $
		' data are still processed, without be plotted']
formu=[formu,'    "Scale"']
formt=[formt,' temporarily disactivate scaling of '+ $
		'considered buffer, allowing to scale one plot versus another']
formu=[formu,'    Apply cut to "Current Workspace"']
formt=[formt,' cut is processed only on selected workspace']
formu=[formu,'                          "All Workspace"']
formt=[formt,' cut is processed on all kept workspaces']
formu=[formu,'    ']
formt=[formt,'                           You can change from on mode to the other, cuts are preserved for each']

formu=[formu,'Changing plotting parameters :']
formt=[formt,'']
formu=[formu,'    Bottom horizontal sliders']
formt=[formt,' permit to define X minimum and maximum Range']
formu=[formu,'    Left side slider']
formt=[formt,' defines Y axis scale ratio']
formu=[formu,'    Right side slider']
formt=[formt,' defines Y axis offset values']

formu=[formu,'Integrity of plots versus data :']
formt=[formt,' Beware of errors on plot interpretation']
formu=[formu,'']
formt=[formt,'     - when "normalize all" is set, the Y scale is'+ $
		' from 0 to 1. Each plot is normalized over its own range']
formu=[formu,'']
formt=[formt,'     - when the right side slider' + $
		' isn'+string(39B)+'t at the bottom, each plot has an Y incremental offset.']
formu=[formu,'']
formt=[formt,'     - when the XMin and XMax range sliders are not set to'+ $
		' minimum and maximum respectively.']
formu=[formu,'']
formt=[formt,'     - when the Filter button is set, smooth and median filters are'+ $
		' processed for plotting.']

formu=[formu,'Other Abilities :']
formt=[formt,'']
formu=[formu,'    "PRINT"']
formt=[formt,' Generate a PS file of the plotting window, you get what you see']
formu=[formu,'    "ANNOTATE"']
formt=[formt,' allows you to annotate the plotting window']

endif else if (flg eq 592) or (flg eq 594) then begin
	formu=[formu,'AVAILABLE OPERATORS between runs ']
	formt=[formt,' +   -   >   :']
	formu=[formu,'FRAME OPERATORS for runs or file ']
	formt=[formt,'{ +   -   >   : }']
	formu=[formu,'NO OPERATOR between alphabetic FileName ']
	formt=[formt,'']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'To select a  run  number     ']
	formt=[formt,' Enter only the run number ex: 211 ']
	formu=[formu,'To select and add three runs ']
	formt=[formt,' 211 + 214 + 218']
	formu=[formu,'To add a range of runs       ']
	formt=[formt,' 211 > 300']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'ALLOWED COMBINATIONS ']
	formt=[formt,' 205 + 211>300 + 315 - 316>318 - 321']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'To concatenate runs 211 to 300 and 303 to 314']
	formt=[formt,' 211:300 , 303:314']
	formu=[formu,'To concatenate every third runs  210 to 300']
	formt=[formt,' 210 ::: 300']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'Frame operations in run 211 and 214']
	formt=[formt,' 211{1>5 +7} + 214{1>6}']
	formu=[formu,'Frame operations in Nexus or Spec files ']
	formt=[formt,' File{1>5 +7.3}']
	formu=[formu,'']
	formt=[formt,'']
	IF flg eq 592 then begin
	formu=[formu,'TO STORE A RUN IN W1 USING THE MOUSE ']
	formt=[formt,' Click a SnapShot with the middle button']
	formu=[formu,'TO _ADD_ A RUN TO W1 USING THE MOUSE ']
	formt=[formt,' Click a SnapShot with the right  button']
	endif
	IF flg eq 594 then begin
	formu=[formu,'SCALING AND PROJECTIONS APPLY TO RUNS INDIVIDUALY']
	formt=[formt,' ']
	formu=[formu,'CONSISTENCY IS USED WITH CONCATENATION ']
	formt=[formt,' only']
	endif
endif else if (flg eq 595) then begin
	formu=[formu,'LIKEABLE URL: http://www.ill.fr/YellowBook/D7/home/D7_george_book.html']
	formt=[formt,'']
	formu=[formu,'THE PAD INTERFACE BUTTONS IS DESIGNED FROM A FILE.']
	formt=[formt,'']
	formu=[formu,'DEFAULT FILE:']
	formt=[formt,' lamp/lamp_mac/dial_pad_init.pro']
	formu=[formu,'WHERE TO PLACE YOUR dial_pad_init.pro FILE:']
	formt=[formt,' in the directory where you have your macros.']
	formu=[formu,'']
	formt=[formt,' Otherwise you may have a local dial_pad_init.prox file (see that one in /lamp_mac)']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'SOME WORDS about DIALS:']
	formt=[formt,' Dials are named Objects, designed to perform actions at a frequency time.']
	formu=[formu,'']
	formt=[formt,' A Dial consists of a set of own and general properties, plus a macro procedure.']
	formu=[formu,'']
	formt=[formt,' An object named "model" is placed in a file named "dial_model.pro"']
	formu=[formu,'']
	formt=[formt,' The minimum code for an object is:  (see lamp/lamp_mac/dial_template1.pro  for a more complete Dial)']
	formu=[formu,'    PRO dial_model_macro, Dial']
	formt=[formt,'    ;(The METHOD)']
	formu=[formu,'']
	formt=[formt,'    V=DialNewValue()            &   Dial.value=sqrt(V)']
	formu=[formu,'']
	formt=[formt,'    R=DialControl ("My wish")   &   end']
	formu=[formu,'    FUNCTION dial_model']
	formt=[formt,'    ;(The CONSTRUCTOR)']
	formu=[formu,'']
	formt=[formt,'    return, {NAME:"model", GENERIC:"interface", TYPE:"temperature" }   &   end']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'    DIAL "model" gets its value from function dial_interface_read']
	formt=[formt,' "interface" comes from the GENERIC tag value.']
	formu=[formu,'']
	formt=[formt,'    George hidden call is: v=dial_interface_read("temperature")    if DialNewValue() is used.']
	formu=[formu,'    DIAL "model" sends its command to function dial_interface_send']
	formt=[formt,' "interface" comes from the GENERIC value.']
	formu=[formu,'']
	formt=[formt,'    George hidden call is: errcod=dial_interface_send("temperature",0,"My wish","model")   if DialControl() is used.']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'SOME WORDS about PAD:']
	formt=[formt,' a generic value is associated to each button. George proceeds in the same way']
	formu=[formu,'']
	formt=[formt,'   as for Dials: errcod=dial_myface_send("PAD",0,"My wish","button label")']

endif else if (flg eq 596) then begin
	formu=[formu,'Very easy !!!  Check for the template file lamp/lamp_mac/A_List_oldTOF.prox']
	formt=[formt,'']
	formu=[formu,'You will be able to define the tags which describe your macros.']
	formt=[formt,'']
	formu=[formu,'Then put your file A_List_*.prox near your macros or in directory lamp/lamp_mac/']
	formt=[formt,'']
endif
return
end

pro dids
;** ****
return
end

pro don_init_prog_mac ,flg
;** *****************
;**
@dons.cbk
@lamp.cbk

 common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
		wbeside,vfl,styles,w4d,smoo,vff

;Read in user command list
         on_ioerror, end_fc
	 in=-1
	 fifi='lamp.cds' & ii  = findfile(fifi,count=n)
	 if  n eq 0 then begin
	  CATCH,stat
	  if stat eq 0 then begin
	   hhm= sys_dep('HOME') & cd,hhm,current=mee & cd,mee,current=hmm
	   if strmid(hhm,strlen(hhm)-1,1) ne lamp_dvd then hhm=hhm+lamp_dvd
	   fifi=hmm+fifi & endif
 	 endif
         openr,in,fifi,/get_lun
	 n=n_elements(prog_mac)
         bstr=''
         for k=0,5 do begin
             readf,in,bstr
             prog_mac(k)=bstr
	     if flg eq 1 then $
	        if prog_txt(k) gt 0 then widget_control,prog_txt(k),bad_id=i,set_value=bstr
         endfor
         if flg eq -1 then begin
         	readf,in,bstr & bstr=''
         	readf,in,bstr & if bstr ne '' then lamp_devps=bstr
         	readf,in,bstr & bstr=''
         	readf,in,rx,rz,nlv,bstr
         	readf,in,bstr & bstr='' & s1=0 & s2=0 & s3=0 & s4=0
         	readf,in,s1,s2,s3,s4,bstr
         	styles(0,0)=s1 & styles(1,0)=s2 & styles(2,0)=s3 & !P.psym=s4
         	readf,in,bstr & bstr=''
         	readf,in,bstr & if strcompress(bstr) gt ' ' then begin
         				      inst_value=strtrim(bstr,2)
					      RDSET,inst=inst_value
         				     ;if b_labins(0) gt 0  then widget_control,bad_id=i,b_labins(0),set_value=inst_value
         				      endif
         	readf,in,bstr & bstr='' & s1=-1
         	readf,in,s1,bstr & if (s1 ge 0) and (s1 le 40) then tcol=s1
         	readf,in,bstr & bstr='' & s1=-1
         	readf,in,s1,bstr & if (s1 ge 0) then smoo=s1

         	readf,in,bstr
         	readf,in,bstr ;Free
         	readf,in,bstr ;Free
         	readf,in,bstr

         endif else for i=1,16 do readf,in,bstr

         for k=6,n-1 do begin
             readf,in,bstr
             prog_mac(k)=bstr
         endfor

end_fc:  if in gt 0 then free_lun,in

for i=0,n_elements(lamp_ins)-1 do if inst_value eq lamp_ins(i) then $
    				     inst_group =  lamp_grp(i)
return
end
;
;
pro p_don_init_var ,prog_base ,mess_base
;** **************
;**       Sets up variables
@lamp.cbk
@dons.cbk
	n=22
	if n_elements(prog_base) eq n then prog_txt =prog_base ;!!! why not
	prog_txt =lonarr(n) ;!!!

	if n_elements(mess_base) eq 1 then l_message=mess_base
	last_w  =1
	nwk     =1
	ifixed  =0
	formtxt =0
	his_info=0
	rawmanip=0
	mac_raw =0
	prog_mac=strarr(n_elements(prog_txt))
		prog_mac(0)='setcol,27'
		prog_mac(2)='w2=total(w1,2) ;X projection'
		prog_mac(3)='w3=w2-shift(w2,1) &  w3(0)=0'
		prog_mac(4)='x_tit(3)="Derivative" & x3=findgen(n_elements(w3))'
	don_init_prog_mac  ,1
return
end
;
pro p_don_create ,base
;** ************
;**       Sets up Formula windows etc

@lamp.cbk
@dons.cbk
;
	p_don_init_var

	formu =['Enter formula below','']
	umac='User'
	if GEORGE eq 1 then  begin dou  =" STATUS CONTROL" & formu(0)='' & umac='Dial'
	                     baso =widget_base(base  ,/row)
	                     baso1=widget_base(baso  ,/column)
	                     baso1=widget_base(baso1 ,/column)
	                     baso2=widget_base(baso  ,/column)
	                     baso2=widget_base(baso2 ,/column)
	                     basoo=widget_base(baso  ,/column)
	                     	basii=widget_base(basoo ,/row)
	                     	baso3=widget_base(basii ,/column)
	                     	basoL=widget_base(basoo)
	                     base =widget_base(map=0,group_leader=lamp_b1)
	endif     else       dou  =" MANIPULATIONS"
;
; Help and Macro buttons
;
; Text area for formula entry
;
	bar0        =widget_base(base   ,/row)
	bar001	    =widget_base(bar0   ,/column)
	macro_area_a=widget_base(bar0)

; First Column
; ***** ******
	bar01		=widget_base  (bar001 ,/row)
	bar1		=widget_base  (bar01  ,/column)

	bar1_1	=widget_base  (bar1   ,/row)
	btit1		=widget_label (bar1_1 ,font=ft_biggest,value=dou)
	bar1_x 	=widget_base  (bar1_1 ,/nonexclusive)
	if sys_dep('MAP') ne -1 then $
	mac_raw	=widget_button(bar1_x ,value='raw',font=ft_smaller,resource_name='discret') else $
	mac_raw	=widget_button(bar1_x ,value='raw',font=ft_smaller)
	bhelp		=widget_button(bar1_1 ,font=ft_normal ,value='?')

	if lamp_siz lt 900 then begin nbli1=2 & nbli2=2  & labx =350
	   formtxt	=widget_text  (bar1   ,font=ft_b_bigger,xsize=40,ysize=nbli1,/editable,value=formu)
	endif		   else begin nbli1=3 & nbli2=2  & labx =562
	   formtxt	=widget_text  (bar1   ,font=ft_b_bigger,xsize=40,ysize=nbli1,/editable,value=formu,/scroll)
	endelse
;
	bar2		=widget_base  (bar01 ,/column)
	mac_but	=widget_button(bar2   ,value=umac+' Macros?')
	idlbut	=widget_button(bar2   ,value='The Journal')
	lamp_don	=[lamp_don,idlbut]
	up_button	=widget_button(bar2   ,value='Data Params')
	lamp_don	=[lamp_don,up_button]
; *****
	l_message	=widget_label (bar001 ,font=ft_b_bigger ,xsize=labx,value='                 ')
; *****
	bar01		=widget_base  (bar001 ,/row)
	his_info	=widget_text  (bar01  ,font=ft_b_bigger ,xsize=40,ysize=nbli2,/scroll,$
					  value=lims(1:*))
	bar2		=widget_base  (bar01  ,/column)
	bar2_1	=widget_base  (bar2   ,/column,/exclusive)
	info_but	=widget_button(bar2_1 ,value='W Min,Max ' ,/no_release)
	his_but	=widget_button(bar2_1 ,value='W History ' ,/no_release)

; Second Column
; ****** ******
	prog_buttons
; Third Column
; ****** *****
	machin=sys_dep('MACHINE')
	if ((lamp_siz ge 800) and (lamp_siz le 950) and (machin eq 'win')) or $
	   ((lamp_siz ge 800) and (GEORGE eq 1)) or $
	   ((lamp_siz ge 800) and (lamp_siz lt 900))                       then begin
;	   ((lamp_siz ge 800) and (lamp_siz lt 900) and (machin eq 'mac')) then begin
		   w0=2 & LOGO,w0 & pax1=size(w0)
		   if GEORGE eq 1 then bose=widget_base (basii,/column) $
		   else                bose=widget_base (bar0 ,/column)
		                       bose=widget_base (bose ,/frame,/row)
		                lamp_ben(6)=widget_draw (bose ,retain=2,xsize=pax1(1),ysize=pax1(2),/button_event)
	endif
;
; Controls
        widget_control,bhelp     ,bad_id=i,set_uvalue=[-88,588,0,0]
        widget_control,formtxt   ,bad_id=i,set_uvalue=[-88,200,0,0]
        widget_control,idlbut    ,bad_id=i,set_uvalue=[-88,396,0]
        widget_control,his_but   ,bad_id=i,set_uvalue=[-88,202,0,0]
        widget_control,mac_but   ,bad_id=i,set_uvalue=[-88,203,0,0]
        widget_control,up_button ,bad_id=i,set_uvalue=[-88,204,0,0]
        widget_control,info_but  ,bad_id=i,set_uvalue=[-88,207,0,0]
        widget_control,mac_raw   ,bad_id=i,set_uvalue=[-88,212,0]
        widget_control,his_info  ,bad_id=i,set_uvalue=[-88,215,0,0]
;;;;    widget_control,save_but  ,bad_id=i,set_uvalue=[-88,370,0,0]

	lamp_focus	=formtxt

	if GEORGE eq 1  then begin widget_control,base,/REALIZE
			XMANAGER, 'Don beside' ,base, event_handler='LAMP_EVENT_PARSER',/just_reg
			for k=0,2 do begin
				if prog_mac(k) eq '' then prog_mac(k)=' '
				baso11=widget_base  (baso1,/row)
				button=widget_button(baso11,value='Do')
				text  =widget_text  (baso11,value=prog_mac(k),font=ft_propor,/editable,xsize=30,ysize=1)
				widget_control,button,set_uvalue=[-88,214,0,text,0]   &   prog_txt(k)=text
				widget_control,text  ,set_uvalue=[-88,214,0,text,0]   &   endfor
			baso21 =widget_base   (baso2 ,/row)
			mac_but=widget_button (baso21,value='Macros' ,uvalue=[-88,203,0,0],font=ft_normal)
			idlbut =widget_button (baso21,value='Journal',uvalue=[-88,396,0,0],font=ft_normal)
			baso31 =widget_base   (baso3 ,/row) & k=3
				if prog_mac(k) eq '' then prog_mac(k)=' '
				text  =widget_text  (baso31,value=prog_mac(k),font=ft_propor,/editable,xsize=30,ysize=1)
				button=widget_button(baso31,uvalue=[-88,214,0,text,0],value='Do')
				widget_control,text ,   set_uvalue=[-88,214,0,text,0] &   prog_txt(k)=text
				;text   =widget_text   (baso21,value='Ctrl:'  ,font=ft_propor,/editable,xsize=30,ysize=1,resource_name="geo")
				;button =widget_button (baso21,value='Send'   ,uvalue=[-88,614,0,text,0])
				;widget_control,text   ,  set_uvalue=[-88,614,0,text,0]

			baso22 =widget_base   (baso2,/row)
			bhelp	 =widget_button (baso22,value='?'      ,uvalue=[-88,588,0,0],font=ft_normal)
			baso32 =widget_base   (baso3 ,/row) & k=4
				if prog_mac(k) eq '' then prog_mac(k)=' '
				text  =widget_text  (baso32,value=prog_mac(k),font=ft_propor,/editable,xsize=30,ysize=1)
				button=widget_button(baso32,uvalue=[-88,214,0,text,0],value='Do')
				widget_control,text ,   set_uvalue=[-88,214,0,text,0] &   prog_txt(k)=text

			baso23 =widget_base   (baso2,/row)
			bact   =widget_base   (baso23,/nonexclusive)
			bact   =widget_button (bact  ,value='Activity ->',uvalue=[-88,660,0,0],font=ft_normal)

			l_message=widget_label(basoL,font=ft_b_bigger ,xsize=labx<500,value='                 ')
	endif
return
end
;
pro prog_buttons
;** ************
;**
@lamp.cbk
@dons.cbk
	macro_area_b  =widget_base(macro_area_a,/column)
	if lamp_siz lt 900 then n=5 else n=6
	dou="Do" & uv=214 & prpt=''
	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1
	for k=0,n-1 do begin
	    if prpt ne '' then if strpos(prog_mac(k),':') ne 4 then prog_mac(k)=prpt
	    base  =widget_base   ( macro_area_b,/row)
	    if prog_mac(k) eq '' then prog_mac(k)=' '
	    if prpt ne '' then $
 	         text=widget_text( base,value=prog_mac(k),font=ft_propor,/editable,$
 	                           xsize=26,ysize=1,resource_name="geo")           $
	    else text=widget_text( base,value=prog_mac(k),font=ft_propor,/editable,$
 	                           xsize=26,ysize=1)
	    button=widget_button( base,value=dou)

	    widget_control,button,bad_id=i,set_uvalue=[-88,uv,k,text,0]
	    if txev then $
	    widget_control,text  ,bad_id=i,set_uvalue=[-88,uv,k,text,0]
	    prog_txt(k)=text
	endfor
	return
	end

pro don_do_cmd, prox=fiprox
;** **********
;**
@lamp.cbk
@dons.cbk
common c_dondo, bas,nbd,fullist

	nprox=n_elements(fiprox) & if nprox gt 0 then idpx=lonarr(nprox)-1
	if xregistered('DoCmd') ne 0 then if nprox gt 0 then widget_control,bas,/destroy
	if xregistered('DoCmd') eq 0 then begin
		bas=widget_base  (title='DO commands',/column,resource_name="lampmic") & nbd=0
		llg=widget_base  (bas,/row) & put_logo,llg
		bid=widget_button(llg,value='?',font=ft_b_normal,uvalue=[-88,588,0,0])
		bid=widget_label (llg,value='      More....',font=ft_b_normal)
		bid=widget_button(llg,value='+2',font=ft_b_normal,uvalue=[-88,224])
		b_labins(8)=bas
		fullist=[' ']
		MAC_LIST,n_em,fullist,maclist,THISFILE='*.prox'
		moclist=strlowcase(strmid(maclist,0,5))
		idx    =where((moclist ne 'dial_') and (moclist ne 'list_') and (moclist ne 'templ'))
		if idx(0) ge 0 then begin
		                        maclist =maclist(idx) & fullist=fullist(idx)
		   idx=sort(maclist) &  maclist =maclist(idx) & fullist=fullist(idx)
		   widget_control,llg,set_uvalue=maclist
		   bid=widget_label (llg,value='   '       ,font=ft_b_normal)
		   if nprox eq 0 then biron=1 else biron=0
		   bil=widget_button(llg,value='Prox files',font=ft_b_normal,uvalue=fullist,menu=2)
		   bir=widget_button(widget_base(llg,/nonexclusive),value='replace',font=ft_smallest,uvalue=[-88,225,-1,biron])
		   widget_control,bir,set_button=biron
		   for i= 0,n_elements(maclist)-1 do begin   uvprox=[-88,225,i,bil,llg,bas,bir]
		      bid=widget_button(bil,value=maclist(i),uvalue=uvprox,font=ft_b_normal)
		      if nprox gt 0 then begin idxpx=where(strlowcase(fiprox) eq maclist(i)) & if idxpx(0) ge 0 then idpx(idxpx(0))=i & endif
		   endfor
		endif
	endif
	if nbd lt n_elements(prog_txt)-1 then begin
	n=n_elements(prog_mac)
	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1
	for k=0,1 do begin
	 if nbd ge n  then val=' ' else val=prog_mac(nbd)
	 if val eq '' then val=' '
	 bdo=widget_base  (bas,/row)
	 txt=widget_text  (bdo,value=val,font=ft_propor,/editable,xsize=40,ysize=1)
	 tdo=widget_button(bdo,value='Do',font=ft_b_normal)
	 if txev then $
	 widget_control,txt,bad_id=i,set_uvalue=[-88,214,nbd<(n-1),txt,0]
	 widget_control,tdo,bad_id=i,set_uvalue=[-88,214,nbd<(n-1),txt,0]
	 if (nbd gt 6) and (nbd lt n) then prog_txt(nbd)=txt
	 nbd=nbd+1
	endfor
	endif

	if xregistered('DoCmd') eq 0 then begin
		widget_control  ,bas,group_leader=lamp_b1,/realize & put_logo
		XMANAGER,'DoCmd',bas,event_handler='LAMP_EVENT_PARSER',/just_reg
		if nprox gt 0 then for i=0,nprox-1 do if idpx(i) ge 0 then don_do_prox,0,[-88,225,idpx(i),uvprox(3:6)]
	endif
end

pro don_do_prox, event, uv
;** ***********
;**
@lamp.cbk
@dons.cbk
	if uv(2) lt 0 then begin
		widget_control,event.id,set_uvalue=[-88,225,-1,event.select] & return
		endif
	files=['']
	widget_control,uv(3) ,bad_id =ii,get_uvalue=files
	widget_control,uv(4) ,bad_id =ii,get_uvalue=filx

	on_ioerror,misfil
	OPENR,u,files(uv(2)),/get_lun
	on_ioerror,eoffil
	contain=strarr(600) & READF,u,contain
	eoffil: free_lun,u
	idx=where(contain gt ' ')
	if idx(0) eq -1 then return
	contain=strtrim(strcompress(contain(idx)),2)

	bax=widget_base  (title=files(uv(2)),/column,resource_name="lampmic")

	llg=widget_base  (bax,/row) & put_logo,llg
	widget_control,llg,set_uvalue=filx
	bid=widget_button(llg,value='Play all',font=ft_b_normal,uvalue=[-88,214,-1,0,bax])
	bid=widget_label (llg,value='   '     ,font=ft_b_normal)
	biron=1
	bil=widget_button(llg,value='Prox files',font=ft_b_normal,uvalue=files,menu=2)
	bir=widget_button(widget_base(llg,/nonexclusive),value='replace',font=ft_smallest,uvalue=[-88,225,-1,biron])
	widget_control,bir,set_button=biron
	for i= 0,n_elements(filx)-1 do bid=widget_button(bil,value=filx(i),uvalue=[-88,225,i,bil,llg,bax,bir],font=ft_b_normal)

	if lamp_siz lt 900 then cnt=19 else if lamp_siz lt 1300 then cnt=23 else cnt=27
	if n_elements(contain) le cnt   then $
	box=widget_base  (bax,/column)  else $
	box=widget_base  (bax,/column,y_scroll=long(cnt*31.58))

	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1
	if sys_dep('VERSION') ge 4.0 then begin
		bdu=widget_base  (box,/row)
		txt=widget_text  (bdu,value='Just bidon',font=ft_propor,/editable,xsize=40,ysize=1)
		tdo=widget_button(bdu,value='Do',font=ft_b_normal)
		gml=widget_info(bdu,/geometry) & stx=gml.scr_xsize+2*gml.margin
		widget_control,bdu,/destroy
	endif else stx=350

	FOR i=0,n_elements(contain)-1 do begin
	    if strmid(contain(i),0,1) eq ';' then begin
		bid=widget_label (box,value=contain(i),font=ft_smaller,xsize=stx)
	    endif else begin
		bdo=widget_base  (box,/row)
		txt=widget_text  (bdo,value=contain(i),font=ft_propor,/editable,xsize=40,ysize=1)
		tdo=widget_button(bdo,value='Do',font=ft_b_normal)
		if txev then $
		widget_control,txt,set_uvalue=[-88,214,-1,txt,0]
		widget_control,tdo,set_uvalue=[-88,214,-1,txt,0]
		if n_elements(tot) eq 0 then tot=txt else tot=[tot,txt]
	    endelse
	ENDFOR
	if n_elements(bdo) eq 1 then begin
	   if n_elements(contain) le 10 then stxp=0 else stxp=35
	   widget_control,bax,set_uvalue=tot
	   widget_control,box,scr_xsize=stx+stxp

	   widget_control,uv(6),bad_id=ii,get_uvalue=biroff
	   if biroff(3) then widget_control,uv(5),bad_id=ii,/destroy
	   widget_control,bax,group_leader=lamp_b1,/realize  & put_logo
	   XMANAGER,'Prox_'+strtrim(string(uv(2)),2),bax,event_handler='LAMP_EVENT_PARSER',/just_reg
	endif
	return
misfil: print,!err_string
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pro	p_don_event  ,event,uv
;**	***********
;**
;
;  299     Destroy alert windows
       if uv(1) eq 299 then begin wait,.3 & widget_control,event.top,/destroy & endif
;
;  200     CR in formula entry
      if uv(1) eq 200 then form_in,event
;
;  201     IDL help
      if uv(1) eq 201 then MANUAL
;     if uv(1) eq 201 then if sys_dep('MAP') le 0 then man_proc,''
;     if uv(1) eq 201 then if sys_dep('MAP') le 0 then man_proc,'' $
;		      else spawn,'$IDL_DIR/bin/idlhelp&'
;
;  202     History
      if uv(1) eq 202 then history,event
;
;  203     Update macros
      if uv(1) eq 203 then macro_files,event,uv
;
;  204     Display user parameters
      if uv(1) eq 204 then par_disp,event
;
;  205     Update user parameters
      if uv(1) eq 205 then par_mod,event,uv(2),uv(3)
;
;  206     Update NWK
      if uv(1) eq 206 then nwk_mod,event,uv(2),uv(3),uv(4)
;
;  207     Update limits
      if uv(1) eq 207 then limits,event
;
;  210     Fire instrument macro
;     if uv(1) eq 210 then fire_inst_mac,event,uv(2)
;
;  211     Display *.pro file
      if uv(1) eq 211 then pro_list,event
;
;  212
      if uv(1) eq 212 then begin
	if event.select then	  setmanip,/raw	 else	   setmanip
	if event.select then txt="SETMANIP,/raw" else txt="SETMANIP,/noraw"
	to_don_history,-1,0, txt
      endif
;
;  213     Set up programable button window
      if uv(1) eq 213 then prog_buttons
;
;  214     Fire instrument macro
      if uv(1) eq 214 then fire_prog_mac,event,uv(2),uv(3),uv(4)
;
;  215     Set up current workspace
      if uv(1) eq 215 then set_cur_work,event
;
;  216     Create a .pro file
      if uv(1) eq 216 then pro_create ,uv
;
;  217     Compile a .pro file
      if uv(1) eq 217 then pro_compile
;
;  218     Show INTERNALS
      if uv(1) eq 218 then show_internal,uv
;
;  219     Create a .pro file
      if uv(1) eq 219 then pro_creater ,uv
;
;  222     DO not use
;
;  224     Create new DO command
      if uv(1) eq 224 then don_do_cmd
;
;  225     Create new DO prox window
      if uv(1) eq 225 then don_do_prox, event,uv
;
;  226     Create XBU dial window
      if uv(1) eq 226 then DialInit,'xbu'
;
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro setmanip,raw=raw,noraw=noraw
;** ********
;**
@dons.cbk
if keyword_set(raw) then rawmanip=1 else rawmanip=0
if mac_raw  gt 0    then widget_control,mac_raw,bad_id=ii,set_button=rawmanip
end

pro form_in,event
;** *******
;**
;FORMULA WINDOW
;
@lamp.cbk
@dons.cbk

;       Reads Formula Windows
;

      widget_control,event.id,get_value=formu

      n        =n_elements (formu)-1
      formu(n) =strtrim    (formu(n),2)

      index    =where(formu ne '')
      if n_elements(index)  le n then formu=formu(index)
      nelement =n_elements (formu)-1
      if n gt nelement  then begin
      			widget_control,event.id,set_value=formu(0:nelement)
      			widget_control,event.id,set_value='',/append,/no_newline,$
						set_text_top_line=nelement-1
			endif
      if nelement gt 20 then begin
      			widget_control,event.id,set_value=formu(nelement-10:nelement)
			widget_control,event.id,set_value='',/append,/no_newline,$
						set_text_top_line=10-1
			endif

if (last_form ne formu(nelement)) or  (nelement eq n) then begin
		 ifixed=1 & xfor=formu(nelement) & xfor=strtrim(xfor,2) & xicute,xfor & endif
return
end

pro form_out,outxt
;** ********
;**
@dons.cbk
	if formtxt gt 0 then begin
           widget_control,formtxt,bad_id=i,get_value=formu
           n=(n_elements(formu)-1) >0
	     formu=[formu((n-15)>0:n),outxt]
           n=(n_elements(formu)-1) >0
      	   widget_control,formtxt,bad_id=i,set_value=formu
           widget_control,formtxt,bad_id=i,set_value=''   ,/append,/no_newline,$
							   set_text_top_line=n
	endif else print,outxt
end

pro commsi ,file, params, macro=extxt, exec=exec
;** ******
;**
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
@lamp.cbk
on_ioerror,miscom
line='' & extxt='' & u=-1
OPENR,u,file,/get_lun
      while (not EOF(u)) do begin READF,u,line & extxt=[extxt,line] & endwhile
miscom:if u gt 0 then begin free_lun,u
		nn= n_elements(params)<(lamp_sys+3)
		if nn gt 0 then for ii=1,nn do begin
		    jj  =strtrim(string(ii),2)
		    xfor='par'+jj+'='+params(ii-1)
		    kk  =execute(xfor)
		endfor
		extxt= extxt(1:*)
		if keyword_set(exec) then COMMCA,extxt
		if nn gt 0 then for ii=1,nn do begin
		    jj  =strtrim(string(ii),2)
		    xfor=params (ii-1)+'=par'+jj
		    kk  =execute(xfor)
		endfor
       endif
end
pro commca ,extxt, prox
;** ******
;**
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
common c_lamp_par

	i1=0L & i2=n_elements(extxt)-1
	if n_elements(prox) eq 2 then if prox(0) ge 0 then begin i1=prox(0)
	                              i2=prox(1)  &  endif
	for kk=i1,i2 do begin xfor=extxt(kk) & jj=execute(xfor) & endfor
end

pro xicuter,intxt
;** *******
;**
@lamp.cbk
@dons.cbk
	ii=strpos(strlowcase(intxt),'passw')
	if formtxt gt 0 then if ii lt 0 then begin
           widget_control,formtxt,bad_id=i,set_value=intxt,/append
           widget_control,formtxt,bad_id=i,get_value=formu
           n=(n_elements(formu)-1) >0
           widget_control,formtxt,bad_id=i,set_value=''   ,/append,/no_newline,$
							   set_text_top_line=n
	endif
	ifixed=1 & xicute,intxt
return
end

pro xicute,intxt
;** ******
;**
@lamp.cbk
@dons.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

  on_ioerror, mis
  GEORGEO, COMMAND=intxt

  last_form=intxt & lwtxt=strlowcase(intxt)

  pvirg=strpos(intxt,';') & if pvirg lt 0 then pvirg=1000

  if pvirg             eq 0 then begin & endif else $

  if strpos(intxt,'$') eq 0 then begin
     len=strlen(intxt)
     if b_labins(3) ne 2 then spawn,strmid(intxt,1,len)

  endif else $
  if (strpos(intxt,'&') gt 0) and (strpos(intxt,'&') lt pvirg) and (strpos(lwtxt,'begin') lt 0) then begin
     com_split,last_form

  endif else $
  if strpos(intxt,'@') eq 0 then begin
     intxtp=strmid(intxt,0,pvirg)
     sep=str_sep(intxtp,',')
     sep=strtrim(sep,2)
     if  strpos (sep(0),'.')  lt 0 then file_name=sep(0)+'.prox' else file_name=sep(0)
     len=strlen (file_name) & file_name=strmid(file_name,1,len)
     if n_elements(sep) eq 1 then  com_file,file_name  $
                             else  begin to_don_history, -1,0, intxt
                                         commsi,file_name, sep(1:*), /EXEC  & endelse
  endif else $
  if strpos(intxt,'?') eq 0 then begin
;    if sys_dep('MAP') le 0 then man_proc,''
     if sys_dep('VERSION') ge 5.0 then online_help else $
     if sys_dep('MAP') gt 0 then spawn,'$IDL_DIR/bin/idlhelp&'

  endif else $
  if strpos(lwtxt,'retall')   eq 0 then begin		 & endif else $
  if       (lwtxt eq 'lamp')       then begin		 & endif else $
  if strpos(lwtxt,'saveses,') eq 0 then begin SaveSession  & endif else $
  if       (lwtxt eq 'save')       then begin SaveSession  & endif else $
  if       (lwtxt eq 'stop')       then begin P_LAMP_STOP  & endif else $
  if strpos(lwtxt,'sho')      eq 0 then begin show,intxt   & endif else begin

      if strpos(lwtxt,'exit')   eq 0 then DON_WRITE_PROG_MAC ,0

;**   Inspect line for "W" or "Dials"
;**   -------------------------------
      ii=strpos(intxt,';') & if ii gt 0 then intxt=strmid(intxt,0,ii)

      find_w1_w2, intxt ,line_2,one,two,three ,alone ,splitxyz ,opp_r
;     print,one,two,opp_r,three ,alone ,splitxyz
      if (one ge 0) and (one le lamp_sys+3) then begin
	 if (two lt 0) or (two gt lamp_sys+3) then two=0

     	 if one gt 0 then begin
;**	  SAVE one parameters
;**	  ---- --- ----------
	  one_str  =strtrim(string(one)  ,2)
	  two_str  =strtrim(string(two)  ,2)
	  three_str=strtrim(string(three),2)

	  					MOVEPAR, (one),one_str, 0,'0'

;**	  PUT two parameters in one
;**	  --- --- ---------- -- ---
     	  if two ne 0 then begin
     	   sz_two=[0L]
	   iii   =execute('sz_two=size(w' +two_str+')')

	   calc_e=0
	   rawraw=rawmanip
	   if strpos(last_form,';++') gt 0 then rawraw=0 else $
	   if strpos(last_form,';--') gt 0 then rawraw=1
	   if (not rawraw) then $
	   if  sz_two(sz_two(0)+2) gt 1 then $
	   if (three gt 0) and ((opp_r eq '+') or (opp_r eq '-') or (opp_r eq '*') or (opp_r eq '/')) then begin
	      sz_three=[0L] & iii=execute('sz_three=size(w' +three_str+')')
	      if sz_three(sz_three(0)+2) gt 1 then begin

;**		First if third W is here then update n,e
;**		----- -- ----- - -- ---- ---- ------ ---
		tix1=''   & tix2='' & tix3='E'+one_str & tix4='' & kp_n='' & kp_e=''
		nenn=1L   & iii=execute('nenn=n_elements(n'+two_str   +'(*,0))')
		nenk=1L   & iii=execute('nenk=n_elements(n'+three_str +'(*,0))')
		jjn =0.   & iii=execute('jjn =total(n'+two_str  +'(*,0))/nenn')
		jjk =jjn  & iii=execute('jjk =total(n'+three_str+'(*,0))/nenk')

		jje =1L   & iii=execute('jje=2*sz_two(sz_two(0)+2)-n_elements(e'+two_str+')-n_elements(e'+three_str+')')

		tsto=((opp_r eq '-') and (jjn ne jjk))
		tstn=((jjn le 1) and (jjk le 1)) or ((nenn eq 1) and (nenk eq 1))
		tstx=1L   & iii=execute('tstx=(x'+two_str  +'(0) eq x'+three_str+'(0)) and '     + $
					     '(x'+two_str  +'(n_elements(x'+two_str  +')-1)  eq '+ $
					      'x'+three_str+'(n_elements(x'+three_str+')-1)) and'+ $
					     '(sz_two(0) eq sz_three(0))')

;		Monitors are # or X different then W_ACCU is used
;		*************************** **** ****************
		if (( opp_r eq '+') or (opp_r eq '-')) and (splitxyz(0) ne 'yes') $
						       and ((not tstx) or (tsto)) then begin

		   if opp_r eq '+' then ads=      ',add='   else ads=',sub='

		   roaw='' ;if monimon lt 0 then roaw=',/raw'
		   tt  =tolerance
		   tix4=last_form
		   plac=0
		   if (sz_two(0) ne sz_three(0)) then begin
		      plac=1
		      tix4='; Incompatible dimensions ...'
		      if (sz_two(1) eq sz_three(1))   then begin
		      if (sz_two(0) eq 2) and (sz_three(0) eq 1) then $
		      			   tix4='W=w'+two_str+' & for i=0,'+strtrim(string(sz_two(2)-1),2)+ $
		      			        ' do w(*,i)=w'  +two_str+'(*,i) '+opp_r+' w'  +three_str+' & w'+one_str+'=W' $
		      else $
		      if (sz_two(0) eq 3) and (sz_three(0) eq 2) then $
		      			   tix4='W=w'+two_str+' & for i=0,'+strtrim(string(sz_two(3)-1),2)+ $
		      			        ' do w(*,*,i)=w'+two_str+'(*,*,i) '+opp_r+' w'+three_str+' & w'+one_str+'=W'
		      endif
		   endif else begin
		      if one eq two   then tix4='W_ACCU,accu='+  one_str+  ads  +three_str +',tol=tt'+roaw else $
		      if one eq three then begin
					   tix4='W_ACCU,accu='+three_str+  ads  +two_str	+',tol=tt'+roaw
					   if opp_r eq '-'  then tix4=tix4+'& w'+one_str+'=-w'+one_str
			        endif else tix4='W'+one_str+'=0'$
							   +' & W_ACCU,accu='+one_str+',add='+  two_str +',tol=tt' $
							   +' & W_ACCU,accu='+one_str+  ads  +three_str +',tol=tt'+roaw
		   endelse
		   toler=tt
		   oon=one & if one ne two then too=two else too=three
		   laa=last_form & ifixed=0

		   if  (plac) then begin
			 iii=EXECUTE(tix4)
			 if one ne two then MOVEPAR ,(two),two_str , (one),one_str
		   endif else begin
			 XICUTE, tix4
			 if (jjk+jjn gt 1) then tix4='N'+one_str+' average ... ' else tix4=''
			 if (jje eq 0)     then tix4=tix4+'E'+one_str+' evaluated ...'
			 if opp_r eq '-'   then $
			 if (jjk ne jjn)   and (not tstn) then tix4='n'+three_str+' and n'+two_str+' are different ...'
		   endelse
		   if l_message gt 0 then widget_control,bad_id=iii,l_message  ,set_value=tix4 else print,tix4
		   if b_labins(6)    then if b_labins(7) gt 0 then $
		                          widget_control,bad_id=iii,b_labins(7),set_value=tix4

		   last_w=oon & to_don_history, oon , too , laa+';W_ACCU'
		   RETURN
		endif else begin
;**		N..
		   if jjn gt 0 then begin
		      if  one ne two then kp_n='n0' else kp_n='n'+one_str+'(*,0)'
		      if (opp_r ne '-') then begin
			tix0= kp_n      +'=n'+two_str+'(*,0)'+opp_r+'n'+three_str+'(*,0)'
			tix1='n'+one_str+'=n'+two_str        +opp_r+'n'+three_str
			iii=execute(tix0) & if iii ne 1 then tix1=''
		      endif
		   endif
;**		E..
		   if jje eq 0 then begin
		      if one ne two then kp_e='e0' else kp_e=tix3
		      if (opp_r eq '+') then tix2='=SQRT( e'+two_str+'^2+e'+three_str+'^2)'
		      if (opp_r eq '-') then tix2='=SQRT( e'+two_str+'^2+e'+three_str+'^2)'
		      if (opp_r eq '*') then tix2='=SQRT((e'+two_str+'*w'+three_str+')^2+(e'+three_str+'*w'+two_str+')^2)'
		      if (opp_r eq '/') then tix2='=SQRT((e'+two_str+'/w'+three_str+')^2+(e'+three_str+'*w'+two_str+'/w'+three_str+'^2)^2)'
		      xfor=kp_e+tix2
		      iii=execute(xfor) & if iii ne 1 then tix2='' else if tix1 ne '' then tix1=tix1+' & '
		   endif
		endelse
		if tix1+tix2 ne '' then  calc_e=1
	      endif
	   endif

	   if one ne two then begin 		MOVEPAR ,(two),two_str , (one),one_str
						if calc_e ne 0 then if tix1 ne '' then iii=execute('n'+one_str+'(*,0)='+kp_n)
						if calc_e ne 0 then if tix2 ne '' then iii=execute('e'+one_str+     '='+kp_e)
	   					endif
;**	  ELSE CLEAR one parameters
;**	  ---- ----- --- ----------
     	  endif else if strpos(lwtxt,'/compl') eq -1 then	CLEARPAR,(one),one_str

     	 endif
      if l_message gt 0 then widget_control,bad_id=iii,l_message  ,set_value=' '
      if b_labins(6)    then if b_labins(7) gt 0 then $
			     widget_control,bad_id=iii,b_labins(7),set_value=' '

      datpon=strpos(strlowcase(strcompress(last_form,/remove_all)),',datp')
      if datpon gt 0 then SETDATP,datp

      stat=0 & jjj=1
      on_error,1 & catch,stat
      xfor=last_form
      if (stat eq 0) and (jjj eq 1) then begin  ok=0
        if (sys_dep('VERSION') lt '5.3') then if (sys_dep('MACHINE') eq 'win') then $
        if (not sys_dep('EMBEDDED'))     then if (not sys_dep('RUNTIME')) then begin
      			on_ioerror,misexc & un=-1
      			openw ,un,'exelamp.pro',/get_lun
      			printf,un,'pro exelamp'		& printf,un,'@lamp.cbk'
      			printf,un,'common for_users'	& printf,un, xfor
      			printf,un,'end'			& free_lun,un & ok=1
      			resolve_routine,'exelamp' & exelamp & misexc:
      			endif
        if (not ok) then jjj=EXECUTE(xfor)     ;<--------------------
      endif
      if jjj ne 1 then print,!err_string
      if n_elements(one_str) eq 0 then one=0 ;Recursivity Problem ...

      if (stat ne 0) or  (jjj ne 1) then begin
      		     catch,/cancel
      		     catch,stat & if stat ne 0 then return
      		     P_MUS,'mus_cannon'
      		     therror=strmid(!err_string,0,65)
		     if l_message gt 0 then $
      			widget_control,bad_id=iii,l_message  ,set_value=therror $
		     else print,!err_string
		     if b_labins(6)    then if b_labins(7) gt 0 then $
			widget_control,bad_id=iii,b_labins(7),set_value=therror
      		     print,string(7b)
;**	  		ERROR RESTORE one parameters
;**	  		----- ------- --- ----------
     	 		if   one gt 0 then 	MOVEPAR, 0,'0' , (one),one_str
			if ((one gt 0) or (alone gt 0)) and (ifixed eq 1) then begin
         		     jou_c=[jou_c,last_form]
         		     jou_w=[jou_w,'??? '+!err_string]
         		endif
		     ifixed=0 & return
      endif else begin

      if datpon gt 0 then GETDATP,datp

;	 Place x,y title correctly when nb dimensions change.
;	 ----- --- ----- --------- ---- -- ---------- ------
     	 if (one gt 0) and (two gt 0) then begin
     	 	sz_one=[0L] & sz_err=[0L] & sz_mon=[0L] & sz_x=[0L] & sz_y=[0L]
		iii   =execute('if n_elements(w'+one_str+') gt 1 then w'+one_str+ '=reform(w' +one_str+ ',/overwrite)')
		iii   =execute('if n_elements(x'+one_str+') gt 1 then x'+one_str+ '=reform(x' +one_str+ ',/overwrite)')
		iii   =execute('if n_elements(y'+one_str+') gt 1 then y'+one_str+ '=reform(y' +one_str+ ',/overwrite)')
		iii   =execute('sz_one=size(w' +one_str+')')
		iii   =execute('sz_err=size(e' +one_str+')')
		iii   =execute('sz_mon=size(n' +one_str+')')
		iii   =execute('sz_x  =size(x' +one_str+')')
		iii   =execute('sz_y  =size(y' +one_str+')')

		if (sz_one(sz_one(0)+2) eq sz_x  (sz_x  (0)+2)) or $
		   (sz_one(1)		eq sz_x  (1))		then xko=0 else xko=1
		if (sz_one(sz_one(0)+2) eq sz_y  (sz_y  (0)+2)) or $
		   (sz_one(0) eq 1) or  $
		  ((sz_one(0) gt 1) and (sz_one(2) eq sz_y(1)))	then yko=0 else yko=1
		if  sz_one(sz_one(0)+2) eq sz_err(sz_err(0)+2)  then eer=0 else eer=1
		if  sz_one(sz_one(0)+2) eq sz_mon(sz_mon(0)+2)  then mon=0 else mon=1

;**		Then reform x,y,z,e,n with splitxyz
;**		---- ------ --------- ---- --------
		if splitxyz(0) eq 'yes' then begin
;**		X..
		   if splitxyz(1) ne '' then if xko eq 1 then begin
		   	svtwo=[0L] & iii=execute( 'svtwo=size(x' +two_str+')' )
			if sz_two(0) ge 1 then begin
			 if (svtwo(0) eq 0) or (svtwo(1) ne sz_two(1)) then $
			 iii=execute( 'x'+two_str+'=indgen(sz_two(1))+1' )
			 if  svtwo(0) gt 1 then $
			 iii=execute( 'x'+one_str+'=reform(x'+two_str+splitxyz(4)+')' ) else $
			 iii=execute( 'x'+one_str+'=   x'+two_str+'('+splitxyz(1)+')' )
			 iii=execute( 'sz_x  =size(x' +one_str+')')
			 if (sz_one(sz_one(0)+2) eq sz_x  (sz_x  (0)+2)) or $
		   	    (sz_one(1)		 eq sz_x  (1))		 then xko=0 else xko=1
		   	endif
		   endif
;**		Y..
		   if splitxyz(2) ne '' then if yko eq 1 then begin
		   	svtwo=[0L] & iii=execute( 'svtwo=size(y' +two_str+')' )
			if sz_two(0) ge 2 then begin
			 if (svtwo(0) eq 0) or $
			   ((svtwo(0) eq 1) and (svtwo(1) ne sz_two(2))) or $
			   ((svtwo(0) eq 2) and (svtwo(2) ne sz_two(2))) then $
			 iii=execute( 'y'+two_str+'= indgen(sz_two(2))+1' )
			 if  svtwo(0) gt 1 then $
			 iii=execute( 'y'+one_str+'=reform(y'+two_str+splitxyz(4)+')' ) else $
			 iii=execute( 'y'+one_str+'=   y'+two_str+'('+splitxyz(2)+')' )
			 iii=execute( 'sz_y  =size(y' +one_str+')')
			 if (sz_one(sz_one(0)+2) eq sz_y  (sz_y  (0)+2)) or $
		   	   ((sz_one(0) gt 1) and (sz_one(2) eq sz_y(1))) then yko=0 else yko=1
			endif
		   endif
;**		Z..
		   if splitxyz(3) ne '' then begin
		   	svtwo=[0L] & iii=execute( 'svtwo=size(z' +two_str+')' )
			if sz_two(0) ge 3 then begin
			 if (svtwo(0) eq 0) or (svtwo(1) ne sz_two(3)) then $
			 iii=execute( 'z'+two_str+'= indgen(sz_two(3))+1' )
			 iii=execute( 'z'+one_str+'= z'+two_str+'('+splitxyz(3)+')' )
			endif
		   endif
;**		E..
		   if (eer eq 1) and  (sz_err(0) eq sz_two(0)) then begin
		      ei1=max(sz_err(0:sz_err(0)) - sz_two(0:sz_two(0)),min=ei2)
		      if (ei1 eq 0) and (ei2 eq 0) then begin
		   	  iii=execute( 'e'+one_str+'=reform(e'+two_str+splitxyz(4)+')' )
			  iii=execute( 'sz_err=size( e'+one_str+')')
		          if sz_one(sz_one(0)+2) eq sz_err(sz_err(0)+2) then eer=0 else eer=1
		      endif
		   endif
;**		N..
		   if (mon eq 1) and  (sz_mon(0) eq sz_two(0)) then begin
		      ei1=max(sz_mon(0:sz_mon(0)) - sz_two(0:sz_two(0)),min=ei2)
		      if (ei1 eq 0) and (ei2 eq 0) then begin
		   	  iii=execute( 'n'+one_str+'=reform(n'+two_str+splitxyz(4)+')' )
			  iii=execute( 'sz_mon=size( n'+one_str+')')
		          if sz_one(sz_one(0)+2) eq sz_mon(sz_mon(0)+2) then mon=0 else mon=1
		      endif
		   endif
		endif

;**		Now check if TOTAL or slice was used
;**		--- ----- -- ----- -- ----- --- ----
;		---- X Y Z
		if (strpos(strcompress(lwtxt,/remove_all),'total(') gt 0) or (splitxyz(0) eq 'yes') then begin
		 if (sz_one(0) eq 2) and (sz_two(0) eq 3)  then begin
		     if sz_one(1) eq sz_two(1) then begin
		        if sz_one(2) eq sz_two(2) then begin
		        endif else if (sz_one(2) eq sz_two(3)) and (yko eq 1) then begin
		 	   iii=execute('y' +one_str+'= z' +two_str)
		 	   y_tit(one) = z_tit(two)
		        endif
		     endif else    if (sz_one(1) eq sz_two(2)) and (xko eq 1) then begin
		 	   iii=execute('x' +one_str+'= y' +two_str)
		 	   iii=execute('y' +one_str+'= z' +two_str)
		 	   x_tit(one) = y_tit(two)
		 	   y_tit(one) = z_tit(two)
		     endif
		     z_tit(one) ='Count'
		     iii=execute('z' +one_str+'= 0')
		 endif
;		 ---- X Y
		 if   (sz_one(0) eq 1) and (sz_two(0) gt 1) then begin   ;and (xko+yko ge 1)
		  y_tit(one) = 'Count'
		  if  (sz_x(0)   gt 1)         then iii=execute('x' +one_str+'= x' +one_str+'(*,0)')
		  if  (sz_one(1) eq sz_two(2)) then begin
		   if (sz_one(1) ne sz_two(1)) then begin
		 	 iii=execute('x' +one_str+'= y' +two_str)
			 if(sz_y(0)   gt 1)   then iii=execute('x' +one_str+'= reform(x' +one_str+'(0,*))')
		 	 x_tit(one) = y_tit(two)
		 	;if splitxyz(0) ne 'yes' then y_tit(one) = z_tit(two)
		   endif
		  endif else if sz_two(0) gt 2 then if (sz_one(1) eq sz_two(3)) then begin
		 	 iii=execute('x' +one_str+'= z' +two_str)
		 	 x_tit(one) = z_tit(two)
		 	 y_tit(one) = 'Count'
		  endif
     	      	  z_tit(one)	=''
		  iii=execute('sz_x =size(x' +one_str+')')
     	      	  iii=execute('y' +one_str+'= [0]')
		 endif
		endif
		if (strpos(strcompress(lwtxt,/remove_all),'total(') gt 0) then begin
;		 ---- E
		 if (eer eq 1) and (sz_err(0) eq sz_one(0)+1) then begin
		  if sz_err(0) eq 1 then iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2  ))') else $
		  if sz_err(0) ge 2 then if sz_one(1) ne  sz_err(1) then $
		 			iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2,1))') else $
		 			if sz_one(1) eq  sz_err(1) then $
		 			iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2,2))') else $
		  if sz_err(0) eq 3 then if sz_one(2) ne  sz_err(3) then $
		 			iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2,3))')
		 endif
;		 ---- N
		 if (mon eq 1) and (sz_mon(0) eq sz_one(0)+1) then begin
		  if sz_mon(0) eq 1 then iii=execute('n'+one_str+'=total(n'+one_str+'  )') else $
		  if sz_mon(0) ge 2 then if sz_one(1) ne  sz_mon(1) then $
;		 			iii=execute('n'+one_str+'=total(n'+one_str+',1)') else $
					iii=1 else $
		 			if sz_one(1) eq  sz_mon(1) then $
		 			iii=execute('n'+one_str+'=total(n'+one_str+',2)') else $
		  if sz_mon(0) eq 3 then if sz_one(2) ne  sz_mon(3) then $
		 			iii=execute('n'+one_str+'=total(n'+one_str+',3)')
		 endif
		endif

;**		Now check if TRANSPOSE was used
;**		--- ----- -- --------- --- ----
		tmptr=strcompress(lwtxt,/remove_all)
		if (strpos(tmptr,'=transpose(') gt 0) then begin
		   if sz_x(0)   gt 1 then iii=execute('x'+one_str+ '=reform(transpose(x' +one_str+ '),/overwrite)')
		   if sz_y(0)   gt 1 then iii=execute('y'+one_str+ '=reform(transpose(y' +one_str+ '),/overwrite)')
		   if sz_err(0) gt 1 then iii=execute('e'+one_str+ '=reform(transpose(e' +one_str+ '),/overwrite)')
		   tmp=0.  &  iii=execute('tmp= x' +one_str)
		   iii=execute('x' +one_str+'= y' +one_str)
		   iii=execute('y' +one_str+'= tmp')
		   tmp=x_tit(one)
		   x_tit(one)=y_tit(one) & y_tit(one) = tmp
		endif

		if calc_e ne 0 then begin
		   if tix2  ne ''    then begin tix2=tix3+' evaluated'  & last_form=last_form+';E'+one_str  &    endif
		   if l_message gt 0 then widget_control,bad_id=iii,l_message  ,set_value=tix1+tix2 else print,tix1+tix2
		   if b_labins(6)    then if b_labins(7) gt 0 then $
		                          widget_control,bad_id=iii,b_labins(7),set_value=tix1+tix2
		endif
	 endif

;        Keep last workspace altered in last_w in common block
;        Update history if "wn=" found
         if (one ge 1) and (one le lamp_sys) then begin last_w=one
         					  his_mod,last_form,line_2
         endif else if alone gt 0 then begin
         		     one=alone & two=-1 & last_w=one
         		     his_mod,last_form,''
         		     one=0     & two= 0
         endif else if (one  ge  0) and (ifixed eq 1) then begin
         		     jou_c=[jou_c,last_form]
         		     jou_w=[jou_w,'']
         		     endif
      endelse
      endif
   endelse
ifixed=0
return
mis:		     therror=strmid(!err_string,0,65)
		     if l_message gt 0 then $
		     widget_control,bad_id=iii,l_message  ,set_value=therror $
		     else print,!err_string
		     if b_labins(6) then if b_labins(7) gt 0 then $
		     widget_control,bad_id=iii,b_labins(7),set_value=therror
		     print,string(7b)
		     ifixed=0
return
end

pro don_me_lastf, ici ,flg
;** ************
@dons.cbk
if flg then last_form=ici else ici=last_form
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro com_split,formi
;** *********
;**
@lamp.cbk
	form =formi & pe=strpos(form,'&')   & ifi=ifixed
	xfor =strmid (form,0,pe) & xfor=strtrim(xfor,2)	   & xicute,xfor  & ifixed=ifi
	xfor =strtrim(strmid(form,pe+1,strlen(form)-pe),2) & xicute,xfor
return
end

pro com_file,file_name
;** ********
;**
; Executes command file
common c_dondo, bas,nbd,fullist

         bstr=''
         on_ioerror, end_f & in=-1

	 if strpos(strlowcase(file_name),'.prox') ge 0 then begin
	 	fifi=file_name
		bid=findfile(fifi,count=n_em)
		if n_em eq 0 then begin
		   if n_elements(fullist) eq 0 then MAC_LIST,n_em,fullist,maclist,THISFILE='*.prox'
		   idx=where(strpos(fullist,fifi) ge 0)
		   if idx(0) ge 0 then fifi=fullist(idx(0))
		endif
	 endif else fifi=file_name

         openr,in,fifi,/get_lun
	 ok=1
	 CATCH,stat & if stat ne 0 then begin print,!err_string & ok=0 & endif
         while (ok) and (not eof(in)) do begin
          	readf,in,bstr
;		assume xicuter is recursive.
	  	bstr=strtrim(bstr,2) & xicuter ,bstr
		RDSTAP,1,50,1,res & if res then ok=0
         endwhile
 end_f:  if in gt 0 then free_lun,in else print,!err_string

return
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro history, event
;** *******
;**
@lamp.cbk
;HISTORY BUTTON

      if event.select eq 1 then begin
	 widget_control,his_info,set_value=histxt
	 ihis=1
      endif
return
end
pro set_history
;** ***********
;**
@lamp.cbk
;SHOW HISTORY
	DON_LIM_SENS & nh=n_elements(histxt)
	if his_info  gt 0 then widget_control,his_info,set_value=histxt else $
	if l_message le 0 then if nh gt 1 then for i=0,nh-2 do print,histxt(i)
return
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro limits, event
;** ******
;**
@lamp.cbk
;Info BUTTON

      if event.select eq 1 then begin
	 widget_control,his_info,set_value=limtxt
	 ihis=0
      endif
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
pro macro_files,event, uv
;** ***********
;** Display macros
@lamp.cbk
@dons.cbk

prx =uv(2)
intn=uv(3)
curr_macr=''
n_emacs  =0
if prx then mac_list ,n_emacs, THISFILE='*.prox', /SET $
       else mac_list ,n_emacs, /SET

i=xregistered('mac_page')
if i eq 0 then begin
      script=strarr(1000)
      mac_help = widget_base  (title='Lamp Macro Information',/column,resource_name='lamptouch')

      mc_bar1  = widget_base  (mac_help ,/row)
;***
      mc_bar11 = widget_base  (mc_bar1  ,/column)
		 put_logo     ,widget_base(mc_bar11,/row)
      header   = widget_label (mc_bar11 ,value='Select macro',font=ft_b_bigger)
      header   = widget_label (mc_bar11 ,value='to view     ',font=ft_b_bigger)
      mc_bidon = widget_label (mc_bar1  ,value='     '	     ,font=ft_b_bigger)

      mc_bar11 = widget_base  (mc_bar1  ,/column,/frame)
      mc_bar111= widget_base  (mc_bar11 ,/row)

      if GEORGE ne 0 then can='New:' else can='Create a new:'
      mc_bidon = widget_label (mc_bar111,value=can          	     ,font=ft_b_bigger)
	compp    ='Write new file'
      if (sys_dep('RUNTIME') or sys_dep('EMBEDDED')) then $
	  crea_but2= widget_button(mc_bar111,value='Batch file'      ,font=ft_b_bigger,uvalue=[-88,216,2,0]) $
      else begin
	  compp    ='Compile new file'
	  crea_but1= widget_button(mc_bar111,value='Macro'  	     ,font=ft_b_bigger,uvalue=[-88,216,1,0])
	  crea_but2= widget_button(mc_bar111,value='Batch'  	     ,font=ft_b_bigger,uvalue=[-88,216,2,0])
	  if GEORGE ne 0 then $
	  crea_but2= widget_button(mc_bar111,value='Dial'  	     ,font=ft_b_bigger,uvalue=[-88,216,3,0])
      endelse

      mac_file = widget_text  (mc_bar11 ,value=' ',xsize=18,ysize=1  ,font=ft_propor,/editable,uvalue=[0])

      mc_bar11 = widget_base  (mc_bar1  ,/column)
      done_but = widget_button(mc_bar11 ,value='Exit'		     ,font=ft_b_bigger)
      comp_but = widget_button(mc_bar11 ,value= compp                ,font=ft_b_bigger)
      mac_labl = widget_label (mc_bar11 ,value='                    ',font=ft_b_normal,xsize=200)
;***
      mc_bar2  = widget_base  (mac_help ,/row)
      if lamp_siz lt 900 then nl=30 else nl=35
	macdid   = widget_base  (mc_bar2  ,/column)
      macdd    = widget_button(macdid   ,value= "Internals"             ,font=ft_propor)
      mack     = widget_list  (macdid   ,ysize=n_emacs <nl ,value=macros,font=ft_propor)
      file_text= widget_text  (mc_bar2  ,xsize=80,ysize=30 ,value=script,font=ft_propor,$
      					/scroll,/editable)
      bid=sys_dep      ('DYNLAB',mac_help,1)
      widget_control,mac_help ,group_leader=lamp_b1,/realize & put_logo

      widget_control,mack     ,bad_id=i,set_uvalue=[-88,211,0,0,0,0,0,0,0]
      widget_control,comp_but ,bad_id=i,set_uvalue=[-88,217,0,0,0,0,0,0,0]
      widget_control,macdd    ,bad_id=i,set_uvalue=[-88,218,file_text,mac_file]
      widget_control,done_but ,bad_id=i,set_uvalue=[-88,299,0,0,0,0,0,0,0]

      XMANAGER, 'mac_page' ,mac_help,event_handler='LAMP_EVENT_PARSER',/just_reg
      widget_control,bad_id=i,file_text,set_value=''

      if intn then begin txti=""
	 internal,txti & widget_control,bad_id=ii,file_text,set_value=txti
      endif

endif else begin
      if not intn then widget_control,bad_id=i,mack     ,set_value=macros
      if not intn then widget_control,bad_id=i,file_text,set_value=''
      widget_control,bad_id=i,mac_help ,map=1
endelse

return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro mac_list,n_emacs ,mac_ful_out,macros_out, thisfile=thisfile ,set=setmacros
;** ********
;**
@lamp.cbk
@dons.cbk
; Set up macros

	mic_ful=['']   & macris=['']
	cd,current=mee & home=mee  & pmac=''
	lmac=sys_dep      ('NEWSUB',lamp_dir,'lamp_mac')

	hhm=sys_dep      ('HOME')
	cd,hhm
	cd,mee,current=home
		stat=0 & catch,stat
		if stat ne 0 then begin lamp_macro='' & pmac='' & submac=[''] & catch,/cancel
		endif else begin
			if lamp_macro ne '' then pmac=lamp_macro else pmac=lmac ;=sys_dep('NEWSUB',!Dir,'lib')
			bid=FINDFILE(pmac,count=nn)
			if nn eq 0 then pmac=lmac
			cd,pmac   & cd,mee,current=pmac
			submac =expand_path('+'+pmac,/array,count=nsub)
			if strmid(pmac  ,strlen(pmac)-1,1)   ne lamp_dvd then pmac  =pmac  +lamp_dvd
			if strmid(submac(0),strlen(submac(0))-1,1) ne lamp_dvd then submac=submac+lamp_dvd
		endelse

		stat=0 & catch,stat
		if stat ne 0 then begin lmac='' & catch,/cancel
		endif else begin
			cd,lmac  & cd,mee,current=lmac
			if strmid(lmac,strlen(lmac)-1,1) ne lamp_dvd then lmac=lmac+lamp_dvd
		endelse
	if strmid(mee  ,strlen(mee)-1,1)   ne lamp_dvd then mee  =mee  +lamp_dvd
	if strmid(home ,strlen(home)-1,1)  ne lamp_dvd then home =home +lamp_dvd

      if (sys_dep('RUNTIME') or sys_dep('EMBEDDED')) then xx='x' else xx='*'
;**	Current macros
	if n_elements(thisfile) eq 1 then file_names=mee + thisfile $
	                             else file_names=mee +'*.pro'+xx
	mac_all=findfile(file_names,count=n_files)
	if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(mee))
					   if ln ge 0 then ln=ln+strlen(mee)
					   macris =['-- USER --',strmid(mac_all,ln,30)]
					   mic_ful=['', mac_all]
					   n_files=n_files+1
	endif
	n_emacs=n_files

;**	Home macros
	if home ne mee then begin
	if n_elements(thisfile) eq 1 then file_names=home + thisfile $
	                             else file_names=home +'*.pro'+xx
	mac_all=findfile(file_names,count=n_files)
	if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(home))
					   if ln ge 0 then ln=ln+strlen(home)
		if n_emacs gt 0 then begin macris =[macris ,'','-- HOME --',strmid(mac_all,ln,30)]
					   mic_ful=[mic_ful,'','', mac_all]
					   n_files=n_files+1
		endif 		else begin macris =[           '-- HOME --',strmid(mac_all,ln,30)]
					   mic_ful=[           '', mac_all]
		endelse
		n_files=n_files+1
	endif
	n_emacs=n_emacs+n_files
	endif

;**	Lamp_macro macros
	if pmac ne '' then if pmac ne home then if pmac ne mee then begin
	 lsub = strlen(pmac)
	 okf  = intarr(nsub>1)
	 ok   =1
	 for i=0,nsub-1 do if (strpos(strlowcase(submac(i)),strlowcase(inst_value)) ge 0) or $
	                      (strpos(strlowcase(submac(i)),strlowcase(inst_group)) ge 0) or $
	                      (strpos(submac(i),lamp_dvd,lsub) lt 0) then begin ok=0 & okf(i)=1 & endif
	 if n_elements(thisfile) eq 1 then if strpos(thisfile,'A_') eq 0 then ok=1
	 for i=0,nsub-1 do begin
	  if (ok) or (okf(i)) then begin
	   if n_elements(thisfile) eq 1 then file_names=submac(i) + thisfile $
	                                else file_names=submac(i) +'*.pro'+xx
	   mac_all=findfile(file_names,count=n_files)
	   if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(submac(i)))
					   if ln ge 0 then ln=ln+strlen(submac(i))
					   MACP=strupcase(strmid(submac(i),lsub,18)) & if MACP eq "" then MACP="MACROS"
		if n_emacs gt 0 then begin macris =[macris ,'','-- '+MACP+' --',strmid(mac_all,ln,30)]
					   mic_ful=[mic_ful,'','', mac_all]
					   n_files=n_files+1
		endif           else begin macris =[           '-- '+MACP+' --',strmid(mac_all,ln,30)]
					   mic_ful=[           '', mac_all]
		endelse
		n_files=n_files+1
	   endif
	   n_emacs=n_emacs+n_files
	  endif
	 endfor
	endif

	if lmac ne pmac then if lmac ne home then if lmac ne mee then begin
	if n_elements(thisfile) eq 1 then file_names=lmac + thisfile $
	                             else file_names=lmac +'*.pro'+xx
	mac_all=findfile(file_names,count=n_files)
	if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(lmac))
					   if ln ge 0 then ln=ln+strlen(lmac)
		if n_emacs gt 0 then begin macris =[macris ,'','-- LAMP --',strmid(mac_all,ln,30)]
					   mic_ful=[mic_ful,'','', mac_all]
					   n_files=n_files+1
		endif 		else begin macris =[           '-- LAMP --',strmid(mac_all,ln,30)]
					   mic_ful=[           '', mac_all]
		endelse
		n_files=n_files+1
	endif
	n_emacs=n_emacs+n_files
	endif
	if n_elements(thisfile) eq 1 then begin
		mac_ful_out=[''] & macros_out=['No MacrosList has been found...']
		idx=where(mic_ful ne '')
		if idx(0) ge 0 then begin
			mic_ful=mic_ful(idx) & macris    =macris(idx)
			idx=uniq(macris,sort(macris)) & mic_ful=mic_ful(idx) & macris=macris(idx)
			mac_ful_out=mic_ful  & macros_out=macris
			for i=0,n_elements(idx)-1 do begin
				t=strpos(macros_out(i),'A_')+1 & if t eq 1 then t=t+1
				p=strpos(macros_out(i),'.') & if p le 0 then p=30
				macros_out(i)=strmid(macros_out(i),t,p-t)
			endfor
		endif
	endif
	if keyword_set(setmacros) then macros =macris
	if keyword_set(setmacros) then mac_ful=mic_ful
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro pro_list,event
;** ********
;**
@dons.cbk

      curr_macr=macros (event.index)
      file_name=mac_ful(event.index)

      ln=strpos(curr_macr,';')
      if ln gt 0 then curr_macr=strmid(curr_macr,0,ln)

      if file_name ne '' then begin
        on_ioerror, no_f
	in=-1 & k=0
        openr,in,file_name,/get_lun

        on_ioerror, end_f
        script= strarr(1000)
	bstr  = ''
        for k=long(0),999 do begin
            readf,in,bstr
            script(k)=bstr
        endfor
        on_ioerror, end_m
        while (1) do begin
            mors  = strarr(1000)
            readf , in,mors
            script=[script,mors] & k=k+1000
        endwhile
 end_m:     script=[script,mors] & k=k+1000
 	while script(k-1) eq '' do k=k-1
 end_f:
 no_f:  if in gt 0 then free_lun,in
	if in gt 0 then widget_control,bad_id=i,mac_file ,set_value=curr_macr
        if k  gt 0 then widget_control,bad_id=i,file_text,set_value=script(0:k-1)
	if k  gt 0 then widget_control,bad_id=i,mac_labl ,set_value=' ' $
		   else widget_control,bad_id=i,mac_labl ,set_value='Read error ...!'
      endif
return
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro pro_create ,uv
;** **********
;**
@lamp.cbk
@dons.cbk
	if xregistered('MacName') gt 0 then begin widget_control,macro_area_a,get_uvalue= bazar
	                                          widget_control,bazar,bad_id=ii,/destroy & endif
	if uv(2) eq 1   then ctxt="macro"
	if uv(2) eq 2   then ctxt="batch"
	if uv(2) eq 3   then ctxt="dial"
	bazar =  widget_base  (title='Lamp Macro Name',/column,resource_name='lamptouch')
	put_logo,widget_base  (bazar,/row)
	bazr1 =  widget_base  (bazar,/row)
	bid   =  widget_label (bazr1,value='Enter the name of the '+ctxt,font=ft_b_normal)
	baz1  =  widget_text  (bazr1,value='my'+ctxt,xsize=15, /editable,font=ft_propor)
	if uv(2) eq 1   then begin
	 bazr2=  widget_base  (bazar,/row)
	 bazrb=  widget_button(bazr2,value='Create a function'          ,font=ft_b_normal,uvalue=[-88,219,0,baz1,bazar])
	 bazrb=  widget_button(bazr2,value='Create a procedure'         ,font=ft_b_normal,uvalue=[-88,219,1,baz1,bazar])
	endif
	if uv(2) eq 2   then begin
	 bazr2=  widget_base  (bazar,/row)
	 bazrb=  widget_button(bazr2,value='Create'                     ,font=ft_b_normal,uvalue=[-88,219,2,baz1,bazar])
	endif
	if uv(2) eq 3  then begin
	 bazr2=  widget_base  (bazar,/row)
	 bazrb=  widget_button(bazr2,value='Create a classical Dial'    ,font=ft_b_normal,uvalue=[-88,219,3,baz1,bazar])
	 bazrb=  widget_button(bazr2,value='Create a Dial for Pad'      ,font=ft_b_normal,uvalue=[-88,219,4,baz1,bazar])
	endif

	widget_control,bazar ,group_leader=lamp_b1,/realize & put_logo
	widget_control,macro_area_a,set_uvalue=bazar
	XMANAGER, 'MacName'  ,bazar,event_handler='LAMP_EVENT_PARSER',/just_reg
return
end

pro pro_creater ,uv
;** ***********
;**
@dons.cbk
	widget_control,uv(3),get_value=curr_macr & curr_macr=strcompress(strlowcase(curr_macr(0)),/remove_all)
	idx=strpos(curr_macr,'.')
	if idx ge 0 then curr_macr=strmid(curr_macr,0,idx)
	idx=strpos(curr_macr,'dial_')
	if idx ge 0 then curr_macr=strmid(curr_macr,idx+5,30)
	MacName=curr_macr
	if uv(2) le 1 then curr_macr=MacName+'.pro'
	if uv(2) eq 2 then curr_macr=MacName+'.prox'
	if uv(2) eq 3 then curr_macr='dial_'+MacName+'.pro'
	if uv(2) eq 4 then curr_macr='dial_'+MacName+'_send.pro'

	widget_control,bad_id=i,mac_file ,set_value= curr_macr ,set_uvalue=uv(2)
	widget_control,bad_id=i,file_text,set_value='',/input_focus
	widget_control,bad_id=i,mac_labl ,set_value=' '

	if uv(2) eq 0 then mactxt=["FUNCTION "+MacName+" ; , p1 , p2 ,p3 ...",";********",";**" $
	                          ,";** The call is w6="+MacName+"(...)","","Wout=0","return, Wout","end"]

	if uv(2) eq 1 then mactxt=["PRO "+MacName+" ; , p1 , p2 ,p3 ...",";***",";**" $
	                          ,";** The call is "+MacName+",...","","print,!stime","end"]

	if uv(2) eq 2 then mactxt=[";Enter lines of IDL commands below. THE CALL will be @"+MacName $
	                          ,";Use one line loops (ie FOR i=0,n DO BEGIN ... & ... & ENDFOR" $
	                          ,";Use variables a-z only (and w1,x1,y1,z1,n1,e1,p1,pv1,w_tit(1),x_tit(1)...)"]

	if uv(2) eq 3 then begin
			   mactxt=[";*********************","PRO dial_"+MacName+"_macro, D" $
	                          ,";*********************",";**" $
	                          ,";** Input D is the dial structure as defined by the function dial_"+MacName $
	                          ,";** This macro procedure is called by George every D.frequency seconds","","" $
	                          ,"    IF D.init eq 0 THEN BEGIN D.init=1 & ENDIF   ;Do your cooking","" $
	                          ,"    V=DialNewValue(TYPE='status',/setvalue)      ;Get status from Mad" $
				  ,"    IF V eq 'Burning' then C=DialControl('stop') ;Stop Mad command" $
				  ,"    IF V eq 'StandBy' then D.frequency=3         ;Change frequency","end","","","" $
	                          ,";*********************","FUNCTION dial_"+MacName $
				  ,";*********************",";**",";** The dial constructor" $
				  ,"","    return,{FREQUENCY:1.5}","end","","","" $
				  ,";****************************************** THAT's ALL ****************","","","" $
				  ,"","   ;Dial Variables (Defaulted if not present in return statement)","   ;--------------" $
				  ,"   ;GENERIC='mad'    ;connect to the mad-idl interface" $
				  ,"   ;TYPE='monitor'   ;then V=DialNewValue() stands for V=DialNewValue(TYPE='monitor')" $
				  ,"   ;ONOFF=0          ;state of the Dial 1=running" $
				  ,"   ;FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used" $
				  ,"   ;VALUE=fltarr(64) ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var." $
				  ,"   ;PLOT=0           ;-2=none 0=plot 1=surface 2=contour n>2 means show vector of last n scalar values" $
				  ,"   ;INIT=0           ;may be used in "+MacName+"_macro when started or on reset" $
				  ,"   ;UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)" $
				  ,"   ;HISTORY=0        ;=1 to record values in file "+MacName+".his" $
				  ,"   ;DURATION=0       ;if >0 then Dial is stopped after running duration seconds" $
				  ,"   ;WUPDATE=0        ;=1 to automaticaly update corresponding workspace, =-1 silent!" $
				  ,"                     ;=2 to automaticaly update and plot workspace to the main window" $
				  ,"                     ;   0,1,2 are set by pressing the left,middle,right mouse button on the dial snapshot" $
				  ,"","   ;User Variables (Must be present in return statement to be available)","   ;-------------" $
				  ,"   ;XVALUE=fltarr(64);Abscissa of VALUE  (ordinates go in YVALUE)" $
				  ,"   ;X_TIT='I am X'   ;X axis title       (Y axis title go in Y_TIT)" $
				  ,"   ;...              ;etc" $
				  ,"","   ;return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,init:INIT}",""]
		mactxt=[mactxt $
		,";***************************************************************************************" $
		,";** Usefull calls to be used in procedure dial_"+MacName+"_macro :" $
		,";** *************" $
		,";** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ" $
		,";**                [TYPE='monitor'])           (a request is made to the instrument)" $
		,";**                                            (/SETVALUE means D.value is set to V)" $
		,";** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control" $
		,";**                                            (CHECK means check every .5 sec till the" $
		,";**                                             command  is complete)" $
		,";** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'" $
		,";**                                                                of  the dial 'temp2'" $
		,";** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'" $
		,";** DialStart ,    'temp3'                     ;A short  for previous call" $
		,";** DialStop  ,    'temp3'                     ;A short  too" $
		,";**" $
		,";** DialModValue,   V ,[tag='VALUE']           ;Set the new value for current dial or" $
		,";** D.value   =     V                          ;modify yourself the tag Value if type &" $
		,";**                                            ;dimensions don't change.(same for Error)" $
		,";** D.upperlim=   150.                         ;Set upper limit for plotting." $
		,";**" $
		,";** R=DialOn ()                                ;Return 0 if Dial has been interrupted" $
		,";**                                            (To use inside loops)" $
		,";** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:" $
		,";**                           ,[PATH=path ]                dial_template4.pro" $
		,";**                                            (You may change its name to 'tmp4' and" $
		,";**                                            (use DialStart,'tmp4' to activate it)" $
		,";** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO" $
		,";**                                            ('template4'  is keept inactive, ONOFF=0)" $
		,";** DialClear,     'template4'                 ;Suppress dial  'template4' from memory" $
		,";** DialWSet                                   ;Reserve central draw window for next plot" $
		,";**" $
		,";** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value" $
		,";**                [DURATION=90.] ,   [/START] ;              (time is in seconds)" $
		,";**                                            ;Stop or Start the general process" $
		,";**                                            ;Set  Time  limit for the active process"]
		endif
	if uv(2) eq 4 then mactxt=["FUNCTION dial_"+MacName+"_send, dummy1,dummy2, text, button",";*******",";**" $
	                          ,";** Called from the Pad, generaly to start and stop Dials","" $
                                  ,"Dials=strlowcase(strtrim(str_sep(text(0),'~'),2))","" $
				  ,"FOR i=0,n_elements(Dials)-1 DO BEGIN" $
                                  ,"    DialInit ,Dials(i)" $
	                          ,"    DialTag  ,Dials(i),tag='FREQUENCY',set=1.0" $
	                          ,"    DialStart,Dials(i)" $
				  ,"ENDFOR" $
	                          ,"","return,0","end","","","","","","" $
		,";***************************************************************************************","" $
		,";** Usefull calls to be used in procedure dial_"+MacName+"_send :" $
		,";** *************" $
		,";** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'" $
		,";**                                                                of  the dial 'temp2'" $
		,";** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'" $
		,";** DialStart ,    'temp3'                     ;A short  for previous call" $
		,";** DialStop  ,    'temp3'                     ;A short  too" $
		,";**" $
		,";** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:" $
		,";**                                                               dial_template4.pro" $
		,";**                                            (You may change its name to 'tmp4' and" $
		,";**                                            (use DialStart,'tmp4' to activate it)" $
		,";** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO" $
		,";**                                            ('template4'  is keept inactive, ONOFF=0)" $
		,";** DialClear,     'template4'                 ;Suppress dial  'template4' from memory" $
		,";** DialWSet                                   ;Reserve central draw window for next plot" $
		,";**" $
		,";** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value" $
		,";**                [DURATION=90.] ,   [/START] ;              (time is in seconds)" $
		,";**                                            ;Stop or Start the general process" $
		,";**                                            ;Set  Time  limit for the active process"]

widget_control,bad_id=ii,uv(4),/destroy
widget_control,bad_id=ii,file_text,set_value=mactxt
return
end

pro pro_compile
;** ***********
;**
@dons.cbk

widget_control,bad_id=i,mac_file ,get_value=curr_macr ,get_uvalue=typ
curr_macr=strlowcase(strtrim(curr_macr(0),2))

if curr_macr ne '' then begin
	widget_control,bad_id=i,file_text,get_value=new_macro

	bat=strmid (curr_macr,strpos(curr_macr,'.'),5)
	ran=long((systime(1)-(long(systime(1)/10000))*double(10000))*100)
	ran=strtrim(string(randomu(ran)),2) & ran=strmid(ran,strpos(ran,'.')+1,4)
	poc='n'+ran+curr_macr
	pac=strmid (poc,0,strpos(poc,'.'))

	!Error=0

	ON_IOERROR,mis_open & out2=-1
	OPENW ,out2,        curr_macr,/get_lun
	ON_IOERROR,mis_io
	for i=0,n_elements(new_macro)-1 do PRINTF,out2,new_macro(i)
	FREE_LUN,out2 & out2=-1

	DON_COMP, new_macro, bat

	P_MUS,'mus_shot'
	mac_list ,n_emacs, /set
	widget_control,bad_id=i,mack     ,set_value=macros

mis_io: if out2 gt 0 then free_lun,out2

mis_open:if !Error ne 0 then widget_control,bad_id=i,mac_labl ,set_value=!err_string  $
			else widget_control,bad_id=i,mac_labl ,set_value=curr_macr+' Created'

endif
return
end

pro don_comp, new_macro, bat
;** ********
;**
	resol =0
	if (not sys_dep("EMBEDDED")) and (not sys_dep("RUNTIME")) then resol=1
	if (resol eq 1)  and (sys_dep ('VERSION') ge 4.0)         then resol=2
	poc='lamp_tmp.pro'
	pac='lamp_tmp'
	if resol gt 0 then begin out1=-1
	   ON_IOERROR,mis_cmp
	   OPENW ,out1,poc,/get_lun
	   if bat ne '.pro' then PRINTF,out1,'pro '+pac
	   for i=0,n_elements(new_macro)-1 do PRINTF,out1,new_macro(i)
	   PRINTF,out1,''
	   if bat ne '.pro' then PRINTF,out1,'end' $
	   else begin	PRINTF,out1,'pro '+pac & PRINTF,out1,'end'
			endelse
	   PRINTF  ,out1,''
 	   FREE_LUN,out1 & out1=-1

	  if resol eq 1 then iii=EXECUTE   ( pac )
	  if resol eq 2 then RESOLVE_ROUTINE,pac

	  mis_cmp:if out1 gt 0 then free_lun,out2
	 ;OPENR ,out1,poc,/get_lun,/DELETE & FREE_LUN,out1 & out1=-1
	endif
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro par_disp, event
;** ********
;**compile
@lamp.cbk
@dons.cbk
;USERPAR BUTTON
;
; Construct the text
      if nwk le 0 then nwk=1

      par_txt_all(*)=''
      npa=0L
      bb=execute('npa=n_elements(p'+strtrim(string (nwk),2)+')' )
      i =0
      bb=execute('for i=0,npa-1 do par_txt_all(i)=strtrim(par_txt(nwk,i))+string(p' $
      						   +strtrim(string (nwk),2) + '(i))')

      up_t    =widget_base  (title='LAMP Instrument Parameters',/column,resource_name='lampdon')
      bar1    =widget_base  (up_t,/row)
	       put_logo	    ,widget_base(bar1,/column)
      donebut =widget_button(bar1,value='Write')
      abortbut=widget_button(bar1,value='Quit')
      up_slid =widget_slider(bar1,value=nwk,title='Workspace #',maximum=lamp_sys,$
								minimum=1,xsize=200)
      up_labl =widget_label (bar1,value='Numor #',xsize=8*10)
      mc_bidon=widget_label (bar1,value=' '	 ,xsize=4)
      up_win  =widget_text  (up_t,xsize=51,ysize=31,/scroll,/editable,font=ft_propor)
      bid=sys_dep      ('DYNLAB',up_t,0)
      widget_control,up_t,group_leader=lamp_b1,/realize & put_logo
      widget_control,up_win   ,bad_id=i,set_value =  par_txt_all
      widget_control,up_slid  ,bad_id=i,set_uvalue=[-88,206,up_win,up_slid,up_labl,0,0,0,0]
      widget_control,donebut  ,bad_id=i,set_uvalue=[-88,205,up_win,up_slid,up_labl,0,0,0,0]
      widget_control,abortbut ,bad_id=i,set_uvalue=[-88,299,0,0,0,0,0,0,0]

      XMANAGER, 'ups' ,up_t,event_handler='LAMP_EVENT_PARSER',/just_reg
      return
      end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pro par_mod,event,up_win,up_slid
;** *******
;**
@lamp.cbk
@dons.cbk
; DONE button in USERPAR display

      i=0
      widget_control,bad_id=i,up_slid,get_value=nwk
      if i eq 0 then begin
      	widget_control,bad_id=i,up_win, get_value=par_txt_all
      	n   =n_elements(par_txt_all)
      	junk=fltarr(n)
      	for j=0,n-1 do begin
          sht_txt=strtrim (par_txt_all(j))
          lnth=strlen(sht_txt)
;
;         Pick out number after '='

          npos   =rstrpos(sht_txt,'=')
          par_len=lnth-npos
          par_val=strmid(sht_txt,npos+1,par_len)
          junk(j)=float(par_val)
      	endfor

      	bb=execute('p' + strtrim(string(nwk),2) + '=junk' )

;	Destroy the evidence
      	wait,.3 & widget_control,event.top,/destroy
      endif
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pro nwk_mod,event,up_win,up_slid,up_labl
;** *******
;**
@lamp.cbk
@dons.cbk
;
;Changes current workspace
    widget_control,bad_id=i,up_slid,get_value=nwk
    widget_control,bad_id=i,up_labl,set_value=w_numor(nwk)

      par_txt_all(*)=''
      npa=0L
      bb=execute('npa=n_elements(p'+strtrim(string (nwk),2)+')' )
      i =0
      bb=execute('for i=0,npa-1 do par_txt_all(i)=strtrim(par_txt(nwk,i))+string(p' $
      						   +strtrim(string (nwk),2) + '(i))')
;
;   Update window text

    widget_control,bad_id=i,up_win,set_value=par_txt_all
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

function str_focc, s,c1,c2,c,f
;******* ********
;**
l=strlen(s) & occ=0
for i=f,l-1 do begin ch=strmid(s,i,1)
    if ch eq c  then if occ le 0 then return,i
    if ch eq c1 then occ=occ+1 else if ch eq c2 then occ=occ-1
endfor
return,-1
end

pro find_w1_w2, line,line_2,one,two,three ,alone ,splitxyz ,opp_r
;** **********
;**
common eme456,	fourth,fifth,sixth

;find first two workspaces on line
;must be an "="
;must be one "w" each side of "="

splitxyz=['no']
line_2  =''
opp_r   =''
one     =0
two     =0
three   =0 & fourth=0 & fifth=0 & sixth=0
alone   =0
ok3	=0

;find first "w"
;--------------
line =strcompress(line)
lnth =strlen(line)
pos_w=-1
ch1  ='a'
while ((ch1 lt '0') or (ch1 gt '9')) do begin
	pos_w=strpos(strlowcase(line),'w',pos_w+1)
	if pos_w lt 0 then RETURN
	ch1=strmid(line,pos_w+1,1)
endwhile

;find  ","
;--------
pos_v=strpos(line,',')

;find  "="
;--------
pos_e=strpos(line,'=')
if pos_v ge 0 then if pos_v lt pos_w then pos_e=-1
		   if pos_e lt pos_w then pos_e=-1

;find a lone "w"
;---- ---------
if pos_e le 0 then begin
	ch1=strmid(line,pos_w+1,1)
	if (ch1 ge '0') and (ch1 le '9') then begin
		ch2=strmid(line,pos_w+2,1)
		if (ch2 lt '0') or (ch2 gt '9') then alone=fix(ch1)   $
			   			else alone=fix(ch1+ch2)
	endif
	RETURN
endif

; is there a second "w" before the "="?
;--------------------------------------
line_t=strmid(line,pos_w+1,pos_e-(pos_w))
pos_t =strpos(strlowcase(line_t),'w')
if pos_t gt 0 then RETURN

;what follows first "w";Is it a number?
;--------------------------------------
ch1=strmid(line,pos_w+1,1)
if (ch1 lt '0') or (ch1 gt '9') then RETURN

;next;Try a case       (care wi(m,n)=x --> assume two=one to keep history)
;---------------
ch2=strmid(line,pos_w+2,1) & pd2=3
if ch2 eq ' ' then begin     pd2=4 & ch2=strmid(line,pos_w+3,1) & endif
case 1 of
  (ch2 eq ' '): one=fix(ch1)
  (ch2 eq '='): one=fix(ch1)
  (ch2 eq '+'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ;Compound operation
  (ch2 eq '-'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '*'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '/'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '^'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '#'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '<'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '>'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '('): begin one=fix(ch1) & two=one & end
  (ch2 eq '['): begin one=fix(ch1) & two=one & end
  (ch2 lt '0')  or (ch2 gt '9'): RETURN
  else:         begin one=fix(ch1+ch2)
		      ch3=strmid(line,pos_w+pd2,1)
		      if ch3 eq ' ' then ch3=strmid(line,pos_w+pd2+1,1)
		      if (ch3 eq '(') or (ch3 eq '[') then two=one
		      if (ch3 eq '+') or (ch3 eq '-') or (ch3 eq '*') or (ch3 eq '/') or (ch3 eq '^') or (ch3 eq '#') or $
		         (ch3 eq '<') or (ch3 eq '>') then begin two=one & opp_r=ch3 & ok3=-1 & endif
		end
endcase


; is there a "w" after the "="
;-----------------------------
;This is repeated until a "w" if followed by an number or eol
iquit=0 & pos_e1=pos_e
while (iquit eq 0) do begin
	line_2=strmid(line,pos_e,lnth-pos_e)
;	find second or third "w"
	pos_w =strpos(strlowcase(line_2),'w')
	if pos_w lt 0 then begin
		iquit=1
		RETURN
		endif

;	what follows second or third "w"
	ch1=strmid(line_2,pos_w+1,1)
;	Is it a number?
	if (ch1 ge '0') and (ch1 le '9') then begin

		ch2=strmid(line_2,pos_w+2,1)
		po3=pos_w+3
		case 1 of
	  	(ch2 eq ''):  if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
	  	(ch2 eq ' '): if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
		(ch2 eq '(') or (ch2 eq '['): begin po3=po3-1
			      if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
			      end
	  	else: 	      if (ch2 ge '0') and (ch2 le '9')  then begin
			      if two    eq 0 then two   =fix(ch1+ch2) else $
		              if three  eq 0 then three =fix(ch1+ch2) else $
		              if fourth eq 0 then fourth=fix(ch1+ch2) else $
		              if fifth  eq 0 then fifth =fix(ch1+ch2) else $
			      if sixth  eq 0 then sixth =fix(ch1+ch2)
			      endif else begin
			      if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
			      endelse
		endcase

;	Check for splitxyz
		pe=po3
		lp=pos_w+1
		chbrk=strmid(line_2,po3,1) & if chbrk eq '(' then chprbk=')'
		                             if chbrk eq '[' then chprbk=']'
		if (chbrk eq '(') or (chbrk eq '[') then $
		 if three gt 0 then pe=(str_focc(line_2,chbrk,chprbk,chprbk,po3+1)+1)>po3 else $
		 if ok3   eq 0 then begin
		   lp =str_focc(line_2,chbrk,chprbk,chprbk,po3+1)

		   if (lp gt po3+1) then splitxyz=['yes','','','',strmid(line_2,po3,lp-po3+1)]

		   fv =str_focc(line_2,'(',')',',',po3+1)

;**		     SPLIT X
;**		     -------
		     if (fv lt 0) or (fv gt lp)   then ib=lp else  ib=fv
		     splitxyz(1)=strmid(line_2,po3+1,ib-po3-1)

		     if fv gt 0 then begin
		        sv =str_focc(line_2,'(',')',',',fv+1)

;**		        SPLIT Y
;**		        -------
		     	if (sv lt 0) or (sv gt lp) then ib=lp else  ib=sv
		     	splitxyz(2)=strmid(line_2,fv+1,ib-fv-1)

		        if sv gt 0 then begin
		      	   tv =str_focc(line_2,'(',')',',',sv+1)

;**		      	   SPLIT Z
;**		    	   -------
		     	   if (tv lt 0) or (tv gt lp) then ib=lp else  ib=tv
		     	   splitxyz(3)=strmid(line_2,sv+1,ib-sv-1)
		       endif
		    endif
;if splitxyz(0) eq 'yes' then print,splitxyz(1),'_',splitxyz(2),'_',splitxyz(3),'_',splitxyz(4)
		 endif
; is there a third "w" ?
;-----------------------
		if ok3 lt 0  then begin   if three gt 0 then begin
					    pe_l  =strcompress(strmid(line_2,pe,10),/remove_all)
					    if pe_l eq '' then begin
					       line_2=strmid(line,pos_e1,pos_e+pos_w-pos_e1+1)
					       if strpos(line_2,'+') ge 0 then opp_r=opp_r+'+'
					       if strpos(line_2,'-') ge 0 then opp_r=opp_r+'-'
					       if strpos(line_2,'/') ge 0 then opp_r=opp_r+'/'
					       if strpos(line_2,'*') ge 0 then opp_r=opp_r+'*'
					       if strpos(line_2,'#') ge 0 then opp_r=opp_r+'#'
					    endif
					    ok3=1
					  endif
		endif
		if ok3 eq 0 then ok3 =-1
		pos_e1=pos_e+lp
	endif
	pos_e=pos_e+pos_w+1
	if pos_e ge lnth then RETURN
endwhile
RETURN
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


pro to_don_history, did_one , did_two , line ,nojournal=nojournal
;** **************
;**
@lamp.cbk
@dons.cbk
	kp_one=one & kp_two=two
	one=did_one
	two=did_two
	if (not keyword_set(nojournal)) then ifixed=1 else ifixed=0
 	his_mod,  line , ''
	ifixed=0
	if did_one lt 0 then begin one=kp_one & two=kp_two & endif
 return
end

pro his_mod,line,line_2
;** *******
;**
;Modify history of one
@lamp.cbk
@dons.cbk

IF one ge 0 THEN BEGIN
dim=[0L,0L]
wkspce='w'+strtrim(string(one),2)
wkspac='w'+        string(one,format='(i2)')
i=execute('dim=size('+wkspce+')')
tipe=dim(dim(0)+1)	;+newtypes*****
case tipe of
   1: lims(one)='Byte   '
   2: lims(one)='Integer'
   3: lims(one)='Long   '
   4: lims(one)='Float  '
   5: lims(one)='Double '
   6: lims(one)='Complex'
   7: lims(one)='String '
   8: lims(one)='Struct '
   9: lims(one)='Dcomplx'
   10:lims(one)='Pointer'
   11:lims(one)='Object '
   12:lims(one)='Uintegr'
   13:lims(one)='Ulong  '
   14:lims(one)='Int64  '
   15:lims(one)='Uint64 '
else: lims(one)='Undef  '
endcase
lims(one)=wkspac+': '+lims(one)

if dim(0) ge 1 then lims(one)=lims(one)+' dim = '   + strtrim(string(dim(1)),2)
if dim(0) ge 2 then lims(one)=lims(one)+' * '       + strtrim(string(dim(2)),2)
if dim(0) ge 3 then lims(one)=lims(one)+' * '       + strtrim(string(dim(3)),2)
if dim(0) ge 4 then lims(one)=lims(one)+' * '       + strtrim(string(dim(4)),2)

miny=0.
maxy=0.	;+newtypes*****
if ((tipe gt 0) and (tipe lt 7)) or (tipe eq 9) or ((tipe ge 12) and (tipe le 15)) then begin
  if dim(0) gt 0 then begin
    i=execute('maxy=max('+wkspce+',min=miny)')
    if sys_dep('MATLAB') then $
    i=execute('miny=min('+wkspce+')')
    if tipe eq 1 then begin miny=fix(miny) & maxy=fix(maxy) & endif

    lims(one)=lims(one)+' min='+strtrim(string(miny),2)+$
			' max='+strtrim(string(maxy),2)
  endif else begin
    i=execute('miny='+wkspce)
    if tipe eq 1 then miny=fix(miny)

    if miny ne 0 then lims(one)=lims(one)+' Scalar='+  strtrim(string(miny),2) $
		 else lims(one)=' '
  endelse
endif

w_min(one)=miny
w_max(one)=maxy

DON_LIM_SENS

if ihis eq 0 then begin
		  n=n_elements(limtxt)
		  i=0 & chk='w'+string(last_w,format='(i2)')
		  if n gt 1 then $
			for j=1,n-1 do if strmid(limtxt(j),0,3) eq chk then i=j
		  if his_info gt 0 then $
		  widget_control,bad_id=ii,his_info ,set_value=limtxt,   $
						     set_text_top_line=i $
		  else if l_message gt 0 then $
		  widget_control,bad_id=ii,l_message,set_value=lims(one) $
		  else print,lims(one)
		  endif
if two  lt 0 then begin
; update info only
endif else begin
;
; search for another wkspce after the =
   pos2=strpos(line_2,wkspce)
;
; when wkspce appears again append history
   if pos2 ge 0 then begin
      his(one)=line+' ... '+his(one)

; when wkspce appears again but not the same
   endif else if two gt 0 then begin
      his(one)=line+' ... '+his(two)

; when no second workspace just use line as history
   endif else begin
	his(one)=line
      if ((tipe  gt 0) and (tipe lt 7)) or (tipe eq 9) or ((tipe ge 12) and (tipe le 15)) then $
	if (dim(0) eq 0) and (miny eq 0) then his(one)=' '
   endelse
endelse

wtb(one)=0
if (one gt 0) and (one le lamp_sys) then begin i=execute('Sna'+strtrim(string(one),2)+'=0')
                                    if abs(sys_dep('MAP')) ne 1 then $
				      if ifixed ne 0 then to_did_cur , wkspce
endif
histxt=his(where(his ne ' '))
if ihis eq 1 then if his_info gt 0 then $
		  widget_control,bad_id=i,his_info ,set_value=histxt   $
		  else if l_message gt 0 then $
		  widget_control,bad_id=i,l_message,set_value=his(one) $
		  else print,his(one)
ENDIF

if ifixed eq 1 then begin
		  DID_WRITE_JOURNAL,/check & j=n_elements(jou_c)-1
		  if one lt  0 then begin one=0
		   i=strpos(strlowcase(line),'see')
		   if i ge 0 then i=strpos(strlowcase(jou_c(j)),'see') $
		             else i=strpos(strlowcase(line)    ,'passw')
		   if i lt 0 then begin jou_c=[jou_c,line]
					j=n_elements(line)  & lines=strarr(j)
					jou_w=[jou_w,lines]
		   endif else begin lines='' & line='' & endelse

		  endif else begin
		   if b_labins(6) then if b_labins(7) gt 0 then if one gt 0 then begin
			     widget_control,bad_id=iii,b_labins(7),set_value=lims(one)
		   endif
                   if (one gt 0) and (two gt 0) then line=his(one)
		   jou_c=[jou_c,line]  & lines=';'+lims(one)
		   jou_w=[jou_w,lines] & endelse

    i=xregistered('JOURNAL')
    if line ne ''  then  $
    if i gt 0 then begin widget_control,bad_id=i,lamp_don(0),get_uvalue=basc
    			 linn=n_elements(jou_c) & lnew=line+'            '+lines
			 if linn lt 10 then begin
			 	widget_control,bad_id=i,basc,set_value=jou_c+'            '+jou_w
			 endif else $
			 	widget_control,bad_id=i,basc,set_value=lnew,$
                                /append,SET_TEXT_TOP_LINE=(n_elements(jou_c)-18)>0
    endif
endif
end

pro DON_LIM_SENS
;** ************
;**
@lamp.cbk

limtxt=lims(where(lims ne ' '))

if n_elements(lamp_don) gt 2 then begin
 nl=n_elements(limtxt) & j=-1
 if (nl gt 1) and (lamp_don(1) eq 1) then begin lamp_don(1)=0 & j=1 & endif
 if (nl le 1) and (lamp_don(1) eq 0) and (n_elements(w1) lt 2) then begin lamp_don(1)=1 & j=0 & endif

 if GEORGE ne 1 then $
 if  j ge 0 then begin  for i=2,n_elements(lamp_don)-1 do $
		     widget_control,bad_id=ii,lamp_don(i),sensitive=j
 endif
endif
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro fire_prog_mac,event,num1,num2, prox
;** *************
;**
@dons.cbk
;
; Put programmed key macro command into formula window for last workspace

comy=[' ']
if prox eq 0 then begin
	widget_control,num2  ,bad_id=ii,get_value=comy & comy=comy(0)
	jj=strpos(strlowcase(comy),'passw')
	if jj ge 0 then widget_control,num2  ,bad_id=ii,set_value=""
	if jj lt 0 then if num1 ge 0 then prog_mac(num1)=comy
	xfor=strtrim(comy,2)  & xicuter,xfor
endif else begin
      widget_control,prox    ,bad_id=ii,get_uvalue=tot
;;    lab='Play all'
;;    widget_control,event.id,bad_id=ii, set_value='Stop!'
      nl=n_elements(tot)  & k=0
      CATCH,stat & if stat ne 0 then begin print,!err_string & k=nl & endif
      while (k lt nl) do begin
	widget_control,tot(k),bad_id=ii,get_value=comy
	k=k+1
;;	evv=widget_event(evv.top,/nowait) & widget_control,/hourglass
;;	if  evv.id ne 0 then k=nl else $          ; if RDSTOP(1,nl,(k)) then k=nl
	xfor=strtrim(comy(0),2) & xicuter,xfor
	RDSTAP,1,nl,(k),res & if res then k=nl
      endwhile
;;    widget_control,event.id,bad_id=ii, set_value=lab
endelse
return
end
;

pro don_write_prog_mac ,flg
;** ******************
;**
;** Write user command list and begood options
@dons.cbk
@lamp.cbk

 common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
		wbeside,vfl,styles,w4d,smoo,vff

	 n=n_elements(prog_mac)

	 if flg eq 0 then begin
	    for k=0,n-1 do begin
	     comy=[' ']
	     if prog_txt(k) gt 0 then begin
	     	widget_control,prog_txt(k),bad_id=i,get_value=comy

		if i ne 0 then prog_txt(k)=0 else prog_mac(k)=comy(0)
	     endif
	    endfor
	 endif

         on_ioerror, end_fc
	 bid=findfile('lamp.cds',count=cnt)
         if cnt gt 0 then bid=sys_dep('DELET','lamp.cds')
	 out=-1 & openw,out ,'lamp.cds',/get_lun
         for k=0,5 do printf,out,prog_mac(k)
         printf,out,' '
         printf,out,lamp_devps
         printf,out,' '
         printf,out,rx,rz,nlv,'   For rx ry nlv'
         printf,out,' '
         printf,out,styles(0,0),styles(1,0),styles(2,0),!P.psym,'   For styles !P.psym'
         printf,out,' '
         printf,out,inst_value
         printf,out,' '
         printf,out,tcol,'   For color table #'
         printf,out,' '
         printf,out,smoo,'   For smooth image '
         printf,out,' '
         printf,out,'Free line'
         printf,out,'Free line'
         printf,out,' '

         for k=6,n-1 do printf,out,prog_mac(k)

	 end_fc: if out gt 0  then free_lun,out
return
end

pro set_cur_work,event
;** ************
;**
@lamp.cbk
	w =event.index
	wk=strmid(limtxt(w),0,3)
	to_did_cur , wk
return
end

pro show,string_in
;** ****
;**
;
;Handles sho command
;
@lamp.cbk
@dons.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

     	rhs =' '
	moan='Cant show '
	stat=0 & jjj=1
	catch,stat

        if (stat ne 0) or  (jjj ne 1) then begin
		     catch,/cancel
		     P_MUS,'mus_cannon'
		     if l_message le 0 then print,moan+rhs else $
      		     widget_control,bad_id=iii,l_message,set_value=moan+rhs
      		     print,string(7b)
		     return
        endif else begin

	   string_in=strtrim(string_in,2)
	   coma=strpos(string_in,',')
	   if (coma le 0) then coma=strpos(string_in,' ')
	   fin =strlen(string_in)
	   lstr=fin-coma
	   if (coma le 0) or (coma eq fin-1) then return
	   rhs =strmid(string_in,coma+1,lstr)

	   abc=' '
	   xfor='abc='+rhs & jjj=execute(xfor)

	   icheck=n_elements(abc)
	   if icheck gt 1  then abc=reform(abc,icheck,/overwrite)
	   if icheck gt 10 then abc=abc(0:9)
 	   ans=string(abc)

	   if GEORGE gt 0 then begin
		if icheck gt 10 then ans=['!first elements printed ...',ans]
		to_don_history,-1,0,ans
		WebDo,'log',['SHOW',ans],12
	   endif
	   if formtxt le 0 then begin
              if icheck eq 1 then  if l_message le 0 then print,ans else $
					widget_control,l_message,bad_id=iii,set_value=ans $
              else begin print,ans & ans='!first elements printed ...'
			 if l_message le 0 then print,ans else $
              		 widget_control,bad_id=iii,l_message,set_value=ans
              endelse
           endif else begin
	      if l_message le 0 then begin
		print,ans
		if icheck gt 10 then print,'Woops - Only first 10 elements given'
	      endif else begin
              	if (b_labins(6) and b_labins(7) gt 0) then $
              	widget_control,b_labins(7),bad_id=iii,set_value=ans(0) else $
              	widget_control,formtxt    ,bad_id=iii,set_value=ans,/append
              	widget_control,formtxt    ,bad_id=iii,set_value='' ,/append
	      	if icheck gt 10 then begin
		         i_bust='Woops - Only first 10 elements given'
      		         widget_control,bad_id=iii,l_message,set_value=i_bust
	      	endif else widget_control,bad_id=iii,l_message,set_value=' '
	      endelse
           endelse
endelse

return
end

pro show_internal,uv
;** *************
;**
txti="" & internal,txti & widget_control,bad_id=ii,uv(2),set_value=txti
                          widget_control,bad_id=ii,uv(3),set_value="internal.prox"
end

pro internal,txti
;** ********
;**
txti=[$
";       INTERNAL PROCEDURES AND FUNCTIONS accessible from command lines",$
";       -------- ---------- --- ---------         as from macros.",$
" ",$
";       DRAWIND     Draw    procedure         (window device)",$
";       SEE         Draw    procedure         (gif, png,  ps)",$
";       SEEM        Draw    procedure",$
";       P_SET_FONT  Draw    procedure         (window device)",$
";       SUPRPLOT    Draw    interface         (window device)",$
";       GFIT        Draw    interface         (window device)",$
";       DON_DO_CMD  Do      interface         (window device)",$
" ",$
";       POSITIVE    Convert procedure",$
";       W_ACCU      Add     procedure",$
" ",$
";       RDSET       Read    procedure",$
";       RDRUN       Read    function",$
";       RDSUM       Read    function",$
";       RDAND       Read    function",$
";       RDOPR       Read    function",$
";       CALIBRATION Read    function",$
";       RDFILTER    Read    interface",$
" ",$
";       READ_LAMP   Read    procedure",$
";       WRITE_LAMP  Write   procedure",$
";       SAVESESSION Write   procedure",$
" ",$
";       SHOW        Print   procedure",$
";       SETCOL      Color   procedure         (window device)",$
" ",$
";       TRAP        Scale   procedure         (window device)",$
";       TRAPX       Scale   procedure         (window device)",$
";       TRAPY       Scale   procedure         (window device)",$
";       TRAPT       Total   procedure         (window device)",$
" ",$
";       XICUTE      Lamp    procedure",$
";       SETMANIP    Lamp    procedure",$
" ",$
";       TAKE_DATP   param   procedure",$
";       GIVE_DATP   param   procedure",$
";       MOD_DATP    param   procedure",$
";       TAKE_W      param   procedure",$
";       GIVE_W      param   procedure",$
";       W_STORE     param   procedure",$
";       W_RESTORE   param   procedure",$
";       W_EXCHANGE  param   procedure",$
" ",$
";       MYINIT      init    procedure",$
";       MYHELP      init    procedure",$
";       P_LAYOUT    init    procedure",$
" ",$
" ",$
";pro    DRAWIND [,xsize] [,ysize] [,DrawId=drawid]",$
";***    *******",$
";**",$
";**     Creates a drawing window for plotting in user_macros (default size is 512*512).",$
";**     The  call is DRAWIND,600,600 ,DrawId=drawid         (drawid is returned).",$
" ",$
" ",$
";pro    SEE, W=i [,/Contour ,/Surface ,/Beside ,/Replot,/Screen,/Gif,/Png,/Ps ,XYpixels=[xsz,ysz] ]",$
";***    ***  ",$
";**",$
";**     Has the same function as the 'Plot Wi' button.",$
" ",$
" ",$
";pro    SEEM  [,/Beside ,/Below ,/Image ,/Contour ,/Surface ,Rot=angle",$
";***    ****   ,/Regular, Xrange=[x1,x2], Yrange=[y1,y2] ,/Log ,Zlim=max ]",$
";**",$
";**     SEEM replaces all buttons within DISPLAY WORKSPACE area.",$
" ",$
" ",$
";pro    P_SET_FONT ,size",$
";***    **********",$
";**",$
";**     Changes the look of next graphics interfaces. size is 0,1,2 for large,medium,small ",$
";**     The  call is P_SET_FONT ,2",$
" ",$
" "] & txti=[txti,$
";pro    SUPERPLOT",$
";***    *********",$
";**",$
";**     Interface for over_plotting workspaces.",$
" ",$
" ",$
";pro    GFIT",$
";***    ****",$
";**",$
";**     Interface for fitting.",$
" ",$
" ",$
";pro    DON_DO_CMD",$
";***    **********",$
";**",$
";**     Creates new Do command buttons.",$
" ",$
" ",$
";pro    POSITIVE, w_in",$
";***    ********",$
";**",$
";**     Transforms an integer*2 unsigned array in a long positive one.",$
";**     The  call is POSITIVE ,W1",$
" ",$
" ",$
";pro    W_ACCU, accu=i , add=j [, tolerance=t]",$
";***    ******",$
";**",$
";**     This procedure adds workspace number j to workspace accumulator number i.",$
";**     using the monitors Ni,Nj and propagating the errors EI,Ej.",$
";**     The tolerance is used for vectors; the default is MIN([step(Xi),step(Xj)])/3",$
";**     The call is   W_ACCU, accu=1         (for W1=0)",$
";**                   W_ACCU, accu=1 , add=3 (for W1=W1+W3  using N1,N3,X1,X3,E1,E3)",$
" ",$
" "] & txti=[txti,$
";pro    RDSET  , INST=inst  ,BASE=base [,CYCLE=965] [,STEP=.14553]  [,TOLERANCE=.2]",$
";***    *****              [,/RAW] [,/DEF] [,/DIR] [,/DIF] [,LAST=procedureName]",$
";**                        [,/SUFFIX=string] [,/PREFIX=string] ",$
";**",$
";**     This procedure changes the current instrument name and (or)",$
";**                            the current base access (see Customize).",$
";**     This procedure can also be used to change specific read-variables [STEP,TOL]." ,$
";**                              [/RAW] means do not use treatment in read operations.",$
";**                              [/DEF] means use specific treatment  during the read.",$
";**                              [/DIR] [DIF] [/SUF] [/PREF] specific use at ILL,ESRF.",$
";**                              [LAST=proc]  proc is the name of a procedure called by",$
";**                                           Lamp just after a multiple read (proc,j,data)",$
";**                                           j is worksp number & data is Wj values",$
";**     The  call is RDSET, INST='D20' , BASE='Current Path'",$
" ",$
" ",$
";function RDRUN  , runnumber [,DATP=datp] [,W=i]",$
";******** *****",$
";**",$
";**       This function reads the run number from the currently selected instrument.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       The  call is  W1 = RDRUN(1280)",$
" ",$
" ",$
";function RDSUM  , firstrun,lastrun [,DATP=datp] [,W=i] [,/COMPLEMENT]",$
";******** ***** ",$
";**",$
";**       This function reads and adds the run numbers range from the selected instrument.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       If COMPLEMENT is set then Wi is not erased before read",$
";**       The  call is  W1 = RDSUM(1280,1295)",$
" ",$
" ",$
";function RDAND  , firstrun,lastrun [,DATP=datp] [,W=i] [,/COMPLEMENT]",$
";******** ***** ",$
";**",$
";**       This function reads and joins the run numbers range from the selected instrument.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       If COMPLEMENT is set then Wi is not erased before read",$
";**       The  call is  W1 = RDAND(1280,1295)",$
" ",$
" "] & txti=[txti,$
";function RDOPR  , text [,DATP=datp] [,W=i]",$
";******** ***** ",$
";**",$
";**       This function reads specified runs and performs basic operations on them.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       The  call is  W1 = RDOPR( ' 624 + 627>629 - 630>631 - 633 ' )",$
";**                     W2 = RDOPR( ' 624 : 627 ' )",$
";**",$
";**       Result of W1  is   624+ (627+628+629) - (630+631) -633",$
";**       Result of W2  is   [[624],[625],[626],[627]] the runs are joined..!",$
" ",$
" ",$
";pro      CALIBRATION [,FILE=file ,NOCAL=nocal ,LIST=list]",$
";**       ***********",$
";**",$
";**       This procedure sets or unsets calibrations.",$
";**       In   window mode the call is  CALIBRATION",$
";**       In   batch  mode the call is  CALIBRATION, file='calibration_file'",$
";**                                 or  CALIBRATION, /nocal [,/list]",$
" ",$
" ",$
";pro      RDFILTER  [,XRANGE =xrg   ,YRANGE=yrg ,ZRANGE=zrg ,XMASK=xtext ,YMASK=ytext $",$
";***      ********   ,MONIMOD=momod ,XPROJ=xproj ,YPROJ=yproj,ZPROJ=zproj,WKSP =wksp  $",$
";**                  ,MONIVAL=value ,SIGMA=sigma ,TOLERANCE=latol  , SELECTION =selec ]",$
";**",$
";**       This procedure creates a general window interface for the use of",$
";**       the  above function RDOPR.",$
";**       In batch mode, use the keywords. The call is:",$
";**       RDFILTER   ,XRANGE=[10,60] ,YMASK='0 12 27' ,/XPROJ ,WKSP=20 $",$
";**                  ,MONIMOD=3 ,MONIVAL=100000 ,SELECTION='104>122 + 127'",$
" ",$
" ",$
";pro      READ_LAMP ,  filename ,W=i, path=pth",$
";***      *********",$
";**",$
";**       This procedure reads the file 'filename' into workspace number i.",$
";**                                File  filename  is a LAMP_Format file.",$
" ",$
" ",$
";pro      WRITE_LAMP , filename ,W=i [,FORMAT='Bin'] [,FORMAT='Ascii']",$
";***      **********",$
";**",$
";**       This procedure writes workspace number i to the file 'filename'",$
";**                                File   is written in a LAMP_Format.",$
" ",$
" "] & txti=[txti,$
";pro      SAVESESSION",$
";***      ***********",$
";**",$
";**       This procedure saves all variables & workspaces in 'lamp.ses'.",$
" ",$
" ",$
";pro      SHOW   , variable",$
";***      **** ",$
";**",$
";**       This procedure prints the contents of the variable. If variable is an",$
";**            array then only first ten elements are shown.",$
";**       the  call is   SHOW, y1 ",$
" ",$
" ",$
";pro      SETCOL , number",$
";***      ******",$
";**",$
";**       This procedure loads the color table number. This number is the index of the",$
";**            table listed when 'Load new Colors' button is pressed.",$
";**       This number is saved when you exit from LAMP.",$
";**       The  call is  SETCOL, 27",$
" ",$
" ",$
";pro      TRAP   , workspace",$
";***      ****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace.",$
";**       To zoom an image you can drag the left button of the mouse.",$
";**       The call is  TRAP,  W3",$
" ",$
" ",$
";pro      TRAPX  , workspace",$
";***      *****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace",$
";**            and does the sum on the  X axis  into  that workspace.",$
";**       The call is  TRAPX, W4",$
" ",$
" ",$
";pro      TRAPY  , workspace",$
";***      *****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace",$
";**            and does the sum on the  Y axis  into  that workspace.",$
";**       The call is  TRAPY, W5",$
" ",$
" ",$
" ",$
";pro      TRAPT  , workspace",$
";***      *****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace",$
";**            and totalizes   all elements into  that workspace.",$
";**       The call is  TRAPT, W6",$
" ",$
" ",$
" "] & txti=[txti,$
";pro      XICUTE  , formula",$
";***      ******",$
";**",$
";**       This procedure executes the string 'formula' using the Lamp passing rule",$
";**            as if you typed    the formula in the Formulae Entry.",$
";**       The call is  XICUTE, formula",$
" ",$
" ",$
" ",$
";pro      SETMANIP  [,/raw] [,/noraw]",$
";***      ********",$
";**",$
";**       When Lamp calculates a single operation between two workspaces (w1=w2+w3),",$
";**           it tries to adjust the result as a function of the monitors (n2 & n3)",$
";**           and coordinates (x2 & x3) then adjusts the resulting errors (e1).",$
";**       To  prevent Lamp from this extra charge, the call is SETMANIP,/raw",$
";**           to  ask Lamp for  an   extra again , the call is SETMANIP",$
";**",$
";**       Regardless  of this  status,  if Lamp sees  ;++ at the end of a command,",$
";**           it goes in extra for that command only, ;-- is for the opposite expect.",$
" ",$
" ",$
";pro      TAKE_DATP , datp [,W=i] [,/third][,/fourth,/fifth,/sixth]",$
";***      *********",$
";**",$
";**       This procedure allows you to access the following data parameters:",$
";**       datp.X , datp.Y , datp.Z , datp.E , datp.N , datp.PV , datp.W_TIT ....",$
";**       If called from a macro specified  by W3=MACRO(w6,w7)  then:",$
";**                 returned datp is that of w6 by default",$
";**                 returned datp is that of w7 if third is set",$
";**                 returned datp is that of Wi if W is set.",$
";**",$
";**       You can   modify all parameters ex: datp.X_TIT='this is the X axis'",$
";**       You can't modify the size of an array parameter.",$
" ",$
";pro      GIVE_DATP , datp [,W=i] [,/second][,/third,/fourth,/fifth,/sixth]",$
";***      *********",$
";**",$
";**       This procedure allows you to give data parameters back to lamp.",$
";**       If called from a macro specified  by W3=MACRO(w6,w7)  then:",$
";**                      given datp is for w3 by default",$
";**                      given datp is for w6 if second is set",$
";**                      given datp is for w7 if third  is set",$
";**                      given datp is for wi if W  is set.",$
" ",$
";pro      MOD_DATP , datp , tag , value",$
";***      ********",$
";**",$
";**       This procedure allows you to change the size of a parameter.",$
";**       The call is MOD_DATP, datp , 'X' , alog(indgen(50)+1)",$
";**                   MOD_DATP, datp , 'E' , sqrt(w)",$
" ",$
" ",$
" "] & txti=[txti,$
";pro      TAKE_W , variable ,W=i",$
";***      ******",$
";**",$
";**       This procedure gets workspace number i into variable.",$
" ",$
" ",$
" ",$
";pro      GIVE_W , variable ,W=i",$
";***      ******",$
";**",$
";**       This procedure puts variable into workspace number i.",$
" ",$
" ",$
" ",$
";pro      W_STORE    , W=i [,/ALL]",$
";***      *******",$
";**",$
";**       This procedure duplicates workspace number i and its parameters into memory.",$
";**       The call is W_STORE, W=3           (use /ALL to duplicate all workspaces)",$
" ",$
" ",$
";pro      W_RESTORE  , W=i [,/ALL]",$
";***      *********",$
";**",$
";**       This procedure retrieves  workspace number i and its parameters from memory.",$
";**       The call is W_RESTORE, W=3         (use /ALL to retrieve  all workspaces)",$
" ",$
" ",$
";pro      W_EXCHANGE , W=i [,/ALL]",$
";***      **********",$
";**",$
";**       This procedure exchanges  workspace number i and its duplicate   in  memory.",$
";**       The call is W_EXCHANGE, W=3        (use /ALL to exchange  all workspaces)",$
" ",$
" ",$
";pro      MYINIT",$
";***      ******",$
";**",$
";**       This procedure executes your code after lamp is loaded.",$
";**       You may also put some code in the file 'myinit.prox'.",$
" ",$
";pro      MYHELP",$
";***      ******",$
";**",$
";**       This procedure associates your help-text to the upper left ? of lamp.",$
" ",$
" "] & txti=[txti,$
";pro      P_LAYOUT , flag (or a Help-macros-file) [,prox=proxfile]",$
";***      ********",$
";**",$
";**       This procedure should be used as commands in MYINIT procedure.",$
";**       flag='george' , 'lamp' , 'light' , 'full' , 'hide' , 'show' FOR LAMP LAYOUT",$
";**       flag='List_oldTOF' TO LOAD 'A_List_oldTOF.prox' FOR MACROS LAYOUT",$
";**       prox=['file1','file2'] TO LOAD 'file1.prox' & 'file2.prox' IN DO COMMAND GUI",$
" ",$
" ",$
" "]
end


pro dons
;** ****
return
end

;=============================================================================================================
PRO CHRIS_EVENT, event
;=============================================================================================================
common chr1 ,comment,listd,listp,newdata,newproc,newpath,mnemo,lindex,lindex1 $
            ,last_list,lirinst,lirpath,ttinst,ttgroup,ttproc,ttpath,ttsymbol  $
            ,ttouch,ttmacro,touch,macros,access,site,actif,pth,base0,potn,magn,npar,wall
common didi1,WoR,worb,wort,txtr,txtw,deffont

		 stat=0 & catch,stat
	         if stat  ne 0  then begin catch,/cancel
	         		widget_control,bad_id=i,comment,set_value=strmid(!err_string,0,55)
	         		return & endif

widget_control,event.id,get_uvalue = uv                                          ;  WIDGET UVALUE ?
widget_control,comment,set_value   = ''                                          ;  COMMENT area set with blank

IF n_elements(uv) gt 1 then IF uv(1) eq 391 then begin  p_did_mvlog, event,uv
							return & endif
;-----------------------EXAMPLE------------------------------------------------------------------------------

IF (uv eq 'TEMPLATE')  then begin
	bib=widget_base (title = 'Lamp  template read_tmp.pro' ,resource_name='lamptouch')
	if n_elements(deffont) eq 1 then widget_control,bib,default_font=deffont
	bob=widget_text (bib,value=txtr,xsize=95,ysize=30,/scroll)
	widget_control,  bib,group_leader=base0,/realize & endif
IF (uv eq 'TEMPLATE2') then begin
	bib=widget_base (title = 'Lamp  template write_tmp.pro',resource_name='lamptouch')
	if n_elements(deffont) eq 1 then widget_control,bib,default_font=deffont
	bob=widget_text (bib,value=txtw,xsize=95,ysize=30,/scroll)
	widget_control,  bib,group_leader=base0,/realize & endif

IF (uv eq 'WoRtoggle') then begin wort=abs(wort-1) & widget_control,worb,set_value=WoR(wort) & endif
;---------------------- CARRIAGE RETURN ? --------------------------------------------------------------------

IF (uv eq 'CR')    then return                                                   ;  IF <CR> in input fields RETURN

;---------------------- BUTTON ABORT -------------------------------------------------------------------------

IF (uv eq 'ABORT') then begin

    widget_control,event.top,/destroy                                            ;  ABORT SESSION?..destroy bases
    return

ENDIF

;-------------INDEX IN DATATYPE LIST--------------------------------------------------------------------------

IF (uv eq 'INDEX_DATA') then begin

     widget_control,listp,set_list_select = -1                                   ;  SUPRESS INDEX IN OTHER LIST
     widget_control,newpath,set_value = ''                                       ;  PUT BLANK IN OTHER FIELDS
     widget_control,mnemo,set_value   = ''
     lindex = event.index                                                        ;  INDEX SELECTED ?
     last_list = 1                                                               ;  LAST LIST SELECTED ?
     IF (lindex eq 0) then return                                                ;  TOTAL SELECTED ? RETURN
     widget_control,NEWDATA,set_value = strmid(lirinst(lindex),0,10)             ;  SHOW SELECTED DATATYPE
     widget_control,NEWPROC,set_value = strmid(lirinst(lindex),24,30)            ;  SHOW SELECTED PROCEDURE

ENDIF

;-------------INDEX IN PATHLIST ------------------------------------------------------------------------------

IF (uv eq 'INDEX_PATH') then begin

     widget_control,listd,set_list_select = -1                                   ; EQUAL ABOVE..............
     widget_control,newdata,set_value = ''
     widget_control,newproc,set_value = ''
     lindex1 = event.index
     last_list = 2
     IF (lindex1 eq 0) then return
     widget_control,NEWPATH,set_value = strmid(lirpath(lindex1),20,100)
     widget_control,MNEMO,  set_value = strmid(lirpath(lindex1),0,14)

ENDIF

;-------------BUTTON REMOVE DATA------------------------------------------------------------------------------

IF (uv eq 'REM_DATA') then BEGIN

     IF(lindex eq -1 or last_list eq 2 or last_list eq 0)then begin              ; if nothing selected
        widget_control,comment,set_value = 'Select an Item before Remove...'     ; or concerns other list -> return
        return
     ENDIF

     IF (lindex eq 0) then return
     IF (lindex eq 1) then begin                                                 ; line 0 or DEMO cannot be removed.....
        widget_control,comment,set_value='DEMO cannot be removed...'
        widget_control,newdata,set_value = ''
        widget_control,newproc,set_value = ''
        return
     ENDIF

     widget_control,comment,set_value = strmid(lirinst(lindex),0,12)$
                  +'...Removed...' ;remove from list
     lirinst(lindex) = 'DELETED'                                                 ; flags items to be deleted
     ttinst(lindex)  = 'DELETED'
     ttproc(lindex)  = 'DELETED'
     ttgroup(lindex) = 'DELETED'

     lirinst = lirinst(where(lirinst ne 'DELETED'))                              ; does same lists minus item selected
     ttinst  = ttinst (where(ttinst ne  'DELETED'))
     ttgroup = ttgroup(where(ttgroup ne 'DELETED'))
     ttproc  = ttproc (where(ttproc ne  'DELETED'))

     widget_control,listd,set_value = strmid(lirinst(0:*),0,32)                  ; Show new list until 30 car.

     widget_control,newdata,set_value = ''                                       ; set entry fields with blank
     widget_control,newproc,set_value = ''

ENDIF

;------------BUTTON REMOVE PATH--------------------------------------------------------------------------------

IF (uv eq 'REM_PATH') then begin                                                 ; EQUAL ABOVE.....

     IF(lindex1 eq -1 or last_list eq 1or last_list eq 0)then begin
        widget_control,comment,set_value = 'Select an Item before Remove...'
        return
     ENDIF

     IF (lindex1 eq 0) then return

     IF (lindex1 eq 1) then begin
        widget_control,comment,set_value = 'CURRENT PATH cannot be removed...'
        return
     ENDIF

     widget_control,comment,set_value = strmid(lirpath(lindex1),0,10)$
                                        + '...Removed...'
     lirpath (lindex1) = 'DELETED'
     ttpath  (lindex1) = 'DELETED'
     ttsymbol(lindex1) = 'DELETED'

     lirpath  = lirpath (where(lirpath  ne  'DELETED'))
     ttpath   = ttpath  (where(ttpath   ne  'DELETED'))
     ttsymbol = ttsymbol(where(ttsymbol ne  'DELETED'))

     widget_control,listp,set_value   = strmid(lirpath(0:*),0,50)                ; SHOW NEW LIST
     widget_control,newpath,set_value = ''
     widget_control,mnemo,set_value   = ''

ENDIF

;-----------BUTTON ADD DATA------------------------------------------------------------------------------------
IF (uv eq 'ADD_DATA') then BEGIN

      widget_control,newdata,get_value = ndata                                   ; GET DATATYPE
      widget_control,newproc,get_value = prodata                                 ; GET PROCEDURE
      ndata   = ndata(0)
      prodata = prodata(0)
      prodata = strlowcase(prodata);                                             ; SET PROCEDURE IN LOWERCASE

      blanc   = strpos(prodata,'.pro')                                           ; ".PRO" EXISTS ?
      IF (blanc ne -1) then begin
         prodata=strtrim(strmid(prodata,0,blanc),2)                              ; REMOVE ".PRO"
      ENDIF

      ndata   = strtrim(strcompress(ndata),2)                                    ; SUPRESS BLANKS IN 2 FIELDS
      prodata = strtrim(strcompress(prodata),2)
      IF (ndata eq '' or prodata eq '') then begin                               ; IF ONE NOT FILLED ? MESSAGE...
         widget_control,comment,set_value = $
           'COMPLETE fields DATATYPE and READ(write) BY before adding...'
         return
      ENDIF

      blanc   = strpos(ndata,' ')                                                ; EXISTS GROUP ?
      tgroup  = " "
      IF (blanc ne -1) then begin
         tinst =  strtrim(strmid(ndata,0,blanc),2)                               ; EXTRACT DATATYPE & GROUP
         tgroup = strtrim(strmid(ndata,blanc,strlen(ndata)),2)
      ENDIF else begin
         tinst  = strtrim(strmid(ndata,0,strlen(ndata)),2)
      ENDELSE
      IF wort then IF strpos(tinst,'.') ne strlen(tinst)-1 then tinst=tinst+'.'
      IF strpos(tinst,'.') eq strlen(tinst)-1 then rb='--Write_by> ' else rb='--Read_by-> '

      tproc   = strtrim(strmid(prodata,0,strlen(prodata)),2)                     ; EXTRACT PROCEDURE
      ndata   = tinst+' '+tgroup

      ex1 = 0 & ex2 = 0 & ex3 = 0 & ipos = 0
      FOR i1  = 1,n_elements(ttinst)-1 DO begin                                  ; DATATYPE ALREADY EXISTS ?
         IF strupcase(ttinst(i1))eq strupcase(tinst) then begin
                              ex1 = 1 & ipos = i1
                              IF strupcase(ttgroup(i1))eq strupcase(tgroup) then ex2 = 1
                              IF strupcase(ttproc(i1))eq strupcase(tproc) then   ex3 = 1
         ENDIF
      ENDFOR

      IF (strlen(ndata) lt 12) then ndata = ndata+$                               ; DATATYPE MAXIMUM 12 CAR.
                      string(replicate(32b,12 -strlen(ndata)))
      IF (strlen(ndata) ge 12) then ndata = strmid(ndata,0,12)
      IF (strlen(tproc) ge 20) then tproc = strmid(tproc,0,20)

      IF ex1 eq 0 and ex2 eq 0 and ex3 eq 0 then begin                            ; DATATYPE DOES NOT EXIST ?
          widget_control,comment,set_value = ndata+'...Added...'
          lirinst = [lirinst,ndata+rb+tproc]                 	        	  ; INCREASE ARRAYS.....
          ttinst  = [ttinst,tinst]
          ttproc  = [ttproc,tproc]
          ttgroup = [ttgroup,tgroup]
          position= n_elements(lirinst)-1
          widget_control,listd,set_value    = strmid(lirinst(0:*),0,32)           ; <SHOW NEW LIST....
          widget_control,listd,set_list_top = (n_elements(lirinst)-4)>0           ; TOP OF LIST WITH NEW....
      endif

      IF ex1 eq 1 then begin                                                      ; DATATYPE EXISTS BUT MODIFIED
          widget_control,comment,set_value = ndata+'...Modified...'
          lirinst (ipos)= ndata+rb+tproc                              		  ; MODIFY ARRAYS
          ttinst(ipos)  = tinst
          ttproc(ipos)  = tproc
          ttgroup (ipos)= tgroup
          widget_control,listd,set_value    = strmid(lirinst(0:*),0,32)           ; <SHOW NEW LIST....
          widget_control,listd,set_list_select = ipos                             ; SET POSITION WITH NEW....
      endif

      widget_control,newdata,set_value = ''                                       ; 2 FIELDS ARE FILLED WITH BLANKS...
      widget_control,newproc,set_value = ''

ENDIF


;-----------BUTTON ADD PATH-------------------------------------------------------------------------------------
IF (uv eq 'ADD_PATH') then begin

  widget_control,newpath,get_value = pathn					  ; GET DATABASE
  widget_control,mnemo,  get_value = symbol					  ; GET FULL PATH
  symbol = symbol(0) & pathn = pathn(0)
  symbol = strtrim(strcompress(symbol),2) & pathn = strtrim(strcompress(pathn),2)
      IF (symbol eq '' or pathn eq '') then begin                                 ; ONE FIELD NOT FILLED ?
         widget_control,comment,set_value = $
            'COMPLETE fields DATABASE and PATH before adding...'
         return
      ENDIF


      symbol  = strtrim(strmid(symbol,0,strlen(symbol)),2)
      pathn   = strtrim(strmid(pathn ,0,strlen(pathn)),2)

      ex1 = 0 & ex2 = 0 & ipos = 0
      FOR i1  = 1,n_elements(ttpath)-1 DO begin                                   ; DATABASE ALREADY EXISTS ?
         IF strupcase(ttsymbol(i1))eq strupcase(symbol) then begin
                ex1 = 1 & ipos = i1
                IF strupcase(ttpath(i1))eq strupcase(pathn) THEN ex2 = 1
         ENDIF
      ENDFOR

      IF (strlen(symbol) lt 14) then symbol = symbol+$
           string(replicate(32b,14 -strlen(symbol)))                              ; COMPLETE DATABASE -> 20 CAR.
      IF (strlen(symbol) ge 14) then symbol = strmid(symbol,0,14)


      IF ex1 eq 0 and ex2 eq 0  then begin                                        ; DATABASE NOT EXISTS ?
          widget_control,comment,set_value = symbol+'...Added...'
          ttdata   = symbol+'----> '+pathn
          lirpath  = [lirpath,ttdata]                                             ; INCREASE ARRAYS
          ttpath   = [ttpath,strtrim(pathn,2)]
          ttsymbol = [ttsymbol,strtrim(symbol,2)]
      widget_control,listp,set_value   = strmid(lirpath(0:*),0,50)                ; SHOW NEW LIST
      widget_control,listp,set_list_top = (n_elements(lirpath)-4)>0                   ; TOP LIST WITH NEW
      endif

      IF ex1 eq 1  then begin                                                     ; DATABASE EXISTS BUT PATH MODIFIED
          widget_control,comment,set_value = symbol+'...Modified...'
          lirpath (ipos)= symbol+'----> '+pathn                                   ; MODIFY ARRAYS
          ttpath(ipos)  = strtrim(pathn,2)
          ttsymbol(ipos)= strtrim(symbol,2)
      widget_control,listp,set_value   = strmid(lirpath(0:*),0,50)                ; SHOW NEW LIST
      widget_control,listp,set_list_select = ipos                                 ; HIGHTLIGHT NEW
      endif

      widget_control,newpath,set_value = ''
      widget_control,mnemo,  set_value = ''

ENDIF

;---------------------- BUTTON DONE (WRITES FUNCTION READ_PAR.PRO)----------------------------------------------------------
IF (uv eq 'DONE')  then begin;

  valid = 0
  on_ioerror, err_write                                                           ;  ERROR ?

  openw,in ,pth+'read_par.pro',/get_lun                                        ;  WRITE NEW FILE
  Printf,in,"FUNCTION READ_PAR , inst ,path, filename, status, datp"
  Printf,in,';-----------------------------------------------------'
  Printf,in,''
  Printf,in,'CASE inst OF ';              <
  Printf,in,''
  IF (n_elements(ttinst)gt 1) then begin                                          ;  WRITE "CASES OF" DATATYPES,PROCEDURES ....
    FOR i = 1,n_elements(ttinst)-1 DO begin
     IF strpos(ttinst(i),'.') le 0 then begin
      n=fix(2-strlen(ttproc(i))/8)
      if n eq 0 then n=1
      bl=string(replicate(9b,n))

      n=fix(1-strlen(ttinst(i)+ttgroup(i))/8)
      if n gt 0 then bl1=string(replicate(9b,n)) else bl1=''
      Printf,in,"'"+ttinst(i)+"'"+string(9b)+": "+"RETURN,"+ ttproc(i)+bl+"(['"+ttinst(i)+"','"+ttgroup(i)+"']"+bl1+",path,filename,status,datp)"
     ENDIF
    ENDFOR
  ENDIF
  Printf,in,"'init'"+string(9b)+": BEGIN  Status=0"                                         ;  WRITE "CASE OF INIT"........
  Printf,in,''
;.........................................................................................................
  IF (n_elements(ttinst)eq 1) then Printf,in,"  ttinst   = ['demo']'",string(replicate(9b,4))+";exec"        ;  Concatenates DATATYPES
  IF (n_elements(ttinst)ge 1) then begin ;
      FOR i = 1,n_elements(ttinst)-1 DO begin
          IF( i eq 1) then Printf,in,"  ttinst   = ['"+ttinst(i)+"']"+string(replicate(9b,2))+";exec"  $
             else Printf,in,"  ttinst   = [ttinst,"+"'"+ttinst(i)+"']"+string(9b)+";exec"
      ENDFOR
  ENDIF
;.........................................................................................................
  Printf,in,''
  IF (n_elements(ttinst)eq 1) then Printf,in,"  ttproc   = ['read_tmp']",string(9b)+";exec";  Concatenates PROCEDURES
  IF( n_elements(ttproc)ge 1) then begin
      FOR i = 1,n_elements(ttproc)-1 DO begin
        IF(i eq 1)then Printf,in,"  ttproc   = ['"+ttproc(i)+"']"+string(9b)+";exec" $
          else Printf,in,"  ttproc   = [ttproc,"+"'"+ttproc(i)+"']"+string(9b)+";exec"
      ENDFOR
  ENDIF
;.........................................................................................................
  Printf,in,''
  IF (n_elements(ttinst)eq 1) then Printf,in,"  ttgroup  = [' ']"+string(replicate(9b,2))+";exec"            ;  Concatenates GROUPS
  IF (n_elements(ttgroup)ge 1) then begin
      FOR i = 1,n_elements(ttgroup)-1 DO begin
        IF(i eq 1)then Printf,in,"  ttgroup  = ['"+ttgroup(i),"']"+string(replicate(9b,2))+";exec" $
          else Printf,in,"  ttgroup  = [ttgroup,"+"'"+ttgroup(i)+"']"+string(9b)+";exec"
      ENDFOR
  ENDIF
;.........................................................................................................
  Printf,in,''
      Printf,in,"  ttsymbol = ['Current Path']"+string(replicate(9b,3))+";exec"                              ;  Concatenates SYMBOLS
  IF (n_elements(ttsymbol)ge 2) then begin
      FOR i = 2,n_elements(ttsymbol)-1 DO begin
      if strlen(ttsymbol(i)) ge 14 then tabul=string(9b) else tabul=string(replicate(9b,2))
            Printf,in,"  ttsymbol = [ttsymbol,"+"'"+ttsymbol(i)+"']"+tabul+";exec"
      ENDFOR
  ENDIF
;.........................................................................................................
  Printf,in,''
      Printf,in,"  ttpath   = ['.']"+string(replicate(9b,4))+";exec"                                         ;  Concatenates PATHS
  IF (n_elements(ttpath)ge 2) then begin
      FOR i = 2,n_elements(ttpath)-1 DO begin
      if strlen(ttpath(i)) ge 10 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,3))
            Printf,in,"  ttpath   = [ttpath,"+"'"+ttpath(i)+"']"+tabul+";exec"
      ENDFOR
  ENDIF
;.........................................................................................................
  widget_control,touch,get_value=touch_v                                          ;  Get TOUCH_BASE location (if empty then default)
  touch_v = touch_v(0)
  if(touch_v eq '')then touch_v="/home/cs/TOUCH_BASE"
  touch_v = strtrim(strcompress(touch_v))
  Printf,in,''
      ;if strlen(touch_v) ge 16 then tabul=string(replicate(9b,3)) else tabul=string(replicate(9b,2))
       Printf,in,"  ttouch   = '"+touch_v+"' ;exec"
;.........................................................................................................
  widget_control,macros,get_value=macro_v                                         ;  Get USER_MACROS location (if empty then default)
  macro_v = macro_v(0)
  macro_v = strtrim(strcompress(macro_v),2)
  Printf,in,'';

     ;if strlen(macro_v) gt 16 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,3))
      Printf,in,"  ttmacro  = '"+macro_v+"' ;exec"
;.........................................................................................................
  widget_control,access,get_value=access_v                                        ;  Get DATA_ACCESS location (if empty then default)
  access_v  = access_v(0)
  access_v  = strlowcase(access_v)                                                ;  SET IN LOWERCASE
      blanc = strpos(access_v,'.pro');
      IF (blanc ne -1) then begin
         access_v = strtrim(strmid(access_v,0,blanc),2)                           ;  REMOVE ".PRO"
      ENDIF
  access_v = strtrim(strcompress(access_v))
  Printf,in,'';
      if strlen(access_v) gt 16 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,4))
      Printf,in,"  ttaccess = '"+access_v+"'"+tabul+";exec"
;.........................................................................................................
  widget_control,site,get_value = site_v                                          ;  Get SITE_DISPLAY function (if empty then default)
  site_v = site_v(0)
  site_v = strlowcase(site_v)                                                     ;  SET IN LOWERCASE
  if(site_v eq '')then site_v = " "
      blanc = strpos(site_v,'.pro')                                               ;  REMOVE ".PRO"
      IF (blanc ne -1) then begin
         site_v = strtrim(strmid(site_v,0,blanc),2)
      ENDIF
  if(site_v ne ' ')then site_v =  strtrim(strcompress(site_v))
  Printf,in,'';

      if strlen(site_v) gt 12 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,4))
      Printf,in,"  ttsite   = '"+site_v+"'"+tabul+";exec"
  Printf,in,'';
;.........................................................................................................
  widget_control,magn,get_value = magic
  magic  = strtrim(magic(0),2)
  if (magic lt '2') or (magic gt '9') then magic='6'
      Printf,in,"  ttmagi   = '"+magic +"' "+";exec"
      Printf,in,''
;.........................................................................................................
  widget_control,wall,get_value = fwall
  fwall  = strtrim(fwall(0),2)
      Printf,in,"  ttwall   = '"+fwall +"' "+";exec"
      Printf,in,''
;.........................................................................................................
  widget_control,npar,get_value =   npars
  on_ioerror,mispar   & npars =long(npars(0)) & mispar: on_ioerror,err_write
  npars=npars>40<10000 & npars=strtrim(string(npars),2)
      Printf,in,"  ttpars   = '"+npars +"' "+";exec"
      Printf,in,''
;.........................................................................................................
      Printf,in,"  datp     = {a:ttinst,  b:ttproc,  c:ttgroup,  $"               ; CREATE STRUCTURE DATP
      Printf,in,"              d:ttsymbol,e:ttpath,  f:ttouch,   $"
      Printf,in,"              g:ttmacro, h:ttaccess,i:ttsite,j:ttmagi,k:ttwall,l:ttpars}"
;.........................................................................................................
  Printf,in,''
  printf,in,"  return,0"
  Printf,in,''
  Printf,in,'         END'
  Printf,in,''
  Printf,in,'ELSE :'
  Printf,in,''
  Printf,in,'ENDCASE'
  Printf,in,''
  Printf,in,"Status = 14"
  Printf,in,''
  Printf,in,'return,0'
  Printf,in,''
  Printf,in,'END'
  Printf,in,''
  valid = 1
  FREE_LUN,in                                                                     ; END WRITE READ_PAR.PRO..........

  if actif eq 1 then begin P_NEWCUST, /fromcust
  			   n=n_elements(ttinst)
;  			   if n gt potn then i=sys_dep      ('POT','',n-1)
			   potn=n & endif

   err_write: if (valid eq 0) then widget_control,comment,set_value=$              ; TEST OF WRITING:
                pth+"READ_PAR.PRO : unable to write !!!"
  if(valid eq 1)then WIDGET_CONTROL,event.top,/DESTROY

ENDIF

END
;===============================================================================================================
;                                 END OF EVENT
;===============================================================================================================






;***************************************************************************************************************
;                                 BEGIN CUSTOMIZ
;***************************************************************************************************************

PRO CUSTOMIZ ,inter

@lamp.cbk
common chr1 ;comment,listd,listp,newdata,newproc,newpath,mnemo,lindex,lindex1 $
            ;last_list,lirinst,lirpath,ttinst,ttgroup,ttproc,ttpath,ttsymbol  $
            ;ttouch,ttmacro,touch,macros,access,site,actif,pth,base0,potn,magn,npar,wall
common didi1;WoR,worb,wort,txtr,txtw,deffont

if xregistered('CUSTOMIZ') gt 0 then widget_control,bad_id=i,base0,map=1 $
else begin

actif = n_elements(inter)
if n_elements(lamp_asite) gt 0 then if lamp_asite eq 'customiz' then actif=1
if n_elements(lamp_siz)   eq 0 then lamp_siz=800

if(actif ne 0) then pth=sys_dep      ('NEWSUB',lamp_dir,'lamp_mac') else pth=''
if(actif ne 0) then deffont=ft_propor

lirinst   =  ' '
lirpath   =  ' '
ttinst    = [' ','demo']
ttgroup   = [' ',' ']
ttproc    = [' ','read_tmp']
ttsymbol  = [' ','Current Path']
ttpath    = [' ','.']                                                             ; CURRENT PATH IS SET....
ttouch    =  ' '
if sys_dep("MACHINE") eq "unix" then ttouch = '/home/cs/TOUCH_BASE'            ; DEFAULT TOUCH_BASE IS SET
if sys_dep("MACHINE") eq "vms"  then ttouch = 'dka0:[lamp.demo.TOUCH_BASE]'
ttmacro   =  ''  	                                                    ; DEFAULT MACROS IS SET
if sys_dep("MACHINE") eq "unix" then ttmacro= '~lambda/macros'
if sys_dep("MACHINE") eq "vms"  then ttmacro= 'dka0:[macros]'
if sys_dep("MACHINE") eq "mac"  then ttmacro= 'disk:macros'
if sys_dep("MACHINE") eq "win"  then ttmacro= 'c:\lambda\macros'
ttaccess  =  'rdfilter'
WoR       = ['Read  by','Write by'] & wort=0
ttsite    =  'language_help'
ttmagi	  =  '6'
ttwall	  =  ''
ttpars	  =  '120'

last_list =  0                                                                    ; LAST LIST SELECTED
lindex    = -1                                                                    ; INDEX NEVER TOUCHED
lindex1   = -1
valid     =  0                                                                    ; PARAMETER I/O ERRORS

;--------------------READ FILE READ_PAR.PRO --------------------------------------

t = findfile (pth + 'read_par.pro',count = exist)
ptth=pth
if (exist eq 0) then begin pth=!dir    +sys_dep("DIVIDER")
t = findfile (pth + 'read_par.pro',count = exist) & endif
if (exist eq 0) then begin status=23 & datp=0
		if ptth ne '' then begin  t = findfile (ptth + '*',count = cnt)
		                          if cnt gt 0 then pth=ptth & endif
                ii=execute('bid=read_par("init","","",status,datp)')
                if status eq 0 then begin ttinst  =datp.a & ttproc  =datp.b & ttgroup=datp.c
                                          ttsymbol=datp.d & ttpath  =datp.e & ttouch =datp.f
                                          ttmacro =datp.g & ttaccess=datp.h & ttsite =datp.i
                                          ttmagi  =datp.j & ttwall  =datp.k & ttpars =datp.l
endif     &     endif
valid=2
on_ioerror, no_file & in=-1						; FLAG ERROR
   OPENR,in,pth+'read_par.pro',/get_lun                                        ; OPEN...
	ligne=' '
   	on_ioerror, end_file
        WHILE (1) DO begin
            readf,in,ligne                                                        ; READ UNTIL END_OF_FILE...
            IF (strpos(ligne,';exec')   ge 0) THEN r=execute(ligne)               ; CAN TRANSLATE LINE IN ARRAY
        ENDWHILE                                                                  ; END READ
        end_file:FREE_LUN,in                                                           ; CLOSE FILE

   valid=3

   on_ioerror, no_write & in=-1
   OPENW,in,pth+'read_par.pro',/APPEND,/get_lun
   	valid=1
   no_write:if in gt 0 then FREE_LUN,in

no_file:

IF (ttinst(0) ne ' ') then begin                                                  ; FIRST ELEMENT OF ARRAYS
       ttinst  = [' ',ttinst]                                                  ; IS ALWAYS A BLANK
       ttproc  = [' ',ttproc]
       ttgroup = [' ',ttgroup]
ENDIF

IF (ttpath(0) ne ' ') then begin                                                  ;   "   "    "
       ttpath  = [' ',ttpath]
       ttsymbol= [' ',ttsymbol]
ENDIF

;if (ttouch(0)   ne ' ') then ttouch  = ttouch(0)                                  ;   "   "    "
;if (ttmacro(0)  ne ' ') then ttmacro = ttmacro(0)
;if (ttaccess(0) ne ' ') then ttacces = ttaccess(0)
;if (ttsite(0)   ne ' ') then ttsite  = ttsite(0)

potn=n_elements(ttinst)
IF (potn ge 1) then begin                                           ; MAKES LIST OF DATATYPES
   FOR ij = 1,n_elements(ttinst)-1 DO begin
       l1 = strlen(ttinst(ij))
       l2 = strlen(ttgroup(ij))
       l3 = l1+l2+1
       if strpos(ttinst(ij),'.') ne strlen(ttinst(ij))-1 then rb='--Read_by-> ' else rb='--Write_by> '
       if l3 lt 12 then t1 = ttinst(ij)+' '+ttgroup(ij)+string(replicate(32b,12-(l3)))+$
                             rb+ttproc(ij) else t1 = ttinst(ij)+' '+ttgroup(ij)
       lirinst = [lirinst,t1]
   ENDFOR
ENDIF

IF (n_elements(ttpath) ge 1) then begin                                           ; MAKES LIST OF PATHNAMES
   FOR ij = 1,n_elements(ttpath)-1 DO begin
       l1 = strlen(ttsymbol(ij))
    if(l1 lt 14)then lirpath=[lirpath,ttsymbol(ij)+string(replicate(32b,14-l1))+$
          '----> '+ttpath(ij)]
    if(l1 eq 14)then lirpath=[lirpath,ttsymbol(ij)+'----> '+ttpath(ij)]
   ENDFOR
ENDIF


;-------------------TEXTS OF HELP------------------------------------------------------
explain1  = 'Enter label for datatype  to appear in LAMP menus in the field DATATYPE '
explain1b = '      you   may enter  an optional  group   for datatype (label group)'
explain2  = 'Enter name  of  procedure to read   datatype      in the field READ  BY'
explain22 = 'Enter name  of  procedure to write  datatype      in the field WRITE BY'
explain3  = 'Enter label for database  to appear in LAMP menus in the field DATABASE'
explain4  = 'Enter Path  to  database  to appear in LAMP menus in the field FULL PATH'

explain5  = 'Enter full path to the directory containing user macros and to the Catalog'
explain6  = 'Enter the name of procedure mapped to the Self... button '
explain7  = 'and one of the DISPLAY FUNCTIONS button'

;--------------------WIDGETS------------------------------------------------------------

base0        =  widget_base  (/column,title = 'Lamp  CUSTOMIZE',/frame,$
				      resource_name='lamptouch')

if actif ne 0 then widget_control,bad_id = ii,base0,default_font = deffont                       ; INSTALL FONT

 base01      =  widget_base  (base0  ,/row)
  txt1       =  widget_label (base01 ,value = explain1)
 base01      =  widget_base  (base0  ,/row)
  txt1       =  widget_label (base01 ,value = explain1b)

 base01      =  widget_base  (base0  ,/row)
  txt2       =  widget_label (base01 ,value = explain2)
  template   =  widget_button(base01, value='(see  read_tmp)',uv='TEMPLATE')
 base01      =  widget_base  (base0  ,/row)
  txt2       =  widget_label (base01 ,value = explain22)
  template   =  widget_button(base01, value='(see write_tmp)',uv='TEMPLATE2')

 base01      =  widget_base  (base0  ,/row)
  txt3       =  widget_label (base01 ,value = explain3)
 base01      =  widget_base  (base0  ,/row)
  txt4       =  widget_label (base01 ,value = explain4)

base001      =  widget_base  (base0  ,/row)
  BUT_ABORT  =  widget_button(base001,value = 'ABORT' ,uvalue = 'ABORT')
		if (actif ne 0) then put_logo     ,base001
  BUT_DONE   =  widget_button(base001,value = 'APPLY ',uvalue = 'DONE',/frame)
  nul0       =  widget_label (base001,value = '   ')
  COMMENT    =  widget_label (base001,value = '   ',xsize=lamp_siz/2 + 30)
  nul0       =  widget_label (base001,value = ' ')

base1	     =  widget_base  (base0  ,/row)
  base11     =  widget_base  (base1  ,/column,/frame)
  LISTD      =  widget_list  (base11 ,value = lirinst,uvalue = 'INDEX_DATA',ysize = 7)
  base12     =  widget_base  (base1  ,/column,/frame)
  LISTP      =  widget_list  (base12 ,value = strmid(lirpath(0:*),0,50),$
                                           uvalue = 'INDEX_PATH',ysize = 7)
base2        =  widget_base  (base11 ,/row)
  n1         =  widget_label (base2  ,value = 'Datatype :')
  NEWDATA    =  widget_text  (base2  ,/editable,value = '',uvalue = 'CR',xsize = 10)
  REM_DATA   =  widget_button(base2  ,value = 'Remove',uvalue = 'REM_DATA')
  ADD_DATA   =  widget_button(base2  ,value = 'Update',uvalue = 'ADD_DATA')
base21       =  widget_base  (base11 ,/row)
  worb       =  widget_label (base21 ,value = WoR(wort)+' :')
  NEWPROC    =  widget_text  (base21 ,/editable,value = '',uvalue = 'CR',xsize = 20)
  toggle     =  widget_button(base21 ,value ='R<-->W', uvalue='WoRtoggle')

base3        =  widget_base  (base12 ,/row)
  n4         =  widget_label (base3  ,value = 'Database :')
  MNEMO      =  widget_text  (base3  ,/editable,value = '',xsize = 14,uvalue = 'CR')
  REM_PATH   =  widget_button(base3  ,value = 'Remove',uvalue = 'REM_PATH')
  ADD_PATH   =  widget_button(base3  ,value = 'Update',uvalue = 'ADD_PATH')

base31       =  widget_base  (base12 ,/row)
  n3         =  widget_label (base31 ,value = 'Full Path:')
  NEWPATH    =  widget_text  (base31 ,/editable,value = '',xsize = 40,uvalue = 'CR')

base350	     =  widget_base  (base0  ,/row)
bid	     =  widget_label (base350,value = 'Magic_number:')
magn	     =  widget_text  (base350,value =  ttmagi,xsize=4,ysize=1,/editable,uvalue = 'CR')
bid	     =  widget_label (base350,value = '(Char.lenght: accessing data by numor means'$
					     +' numor is in the filename)')
base350	     =  widget_base  (base0  ,/row)
bid	     =  widget_label (base350,value = 'FTP proxy (Firewall):')
wall	     =  widget_text  (base350,value =  ttwall,xsize=8,ysize=1,/editable,uvalue = 'CR')

bid	     =  widget_label (base350,value = '  -----  ')
bid	     =  widget_label (base350,value = 'Data Parameters maxi_length:')
npar	     =  widget_text  (base350,value =  ttpars,xsize=6,ysize=1,/editable,uvalue = 'CR')

base400      =  widget_base  (base0  ,/column,/frame)
base411      =  widget_base  (base400,/row)
  n24        =  widget_label (base411,value = 'User macros location:')
  MACROS     =  widget_text  (base411,/editable,xsize = 20,value = ttmacro,uvalue = 'CR')
  n25        =  widget_label (base411,value = 'TOUCH_BASE location :')
  TOUCH      =  widget_text  (base411,/editable,xsize = 20,value = ttouch ,uvalue = 'CR')
  txt5       =  widget_label (base400,value = explain5)

base500      =  widget_base  (base0 ,/column,/frame)
base511      =  widget_base  (base500 ,/row)
  n26        =  widget_label (base511,value = 'Procedure for Self... button:')
  ACCESS     =  widget_text  (base511,/editable,xsize = 10,value = ttaccess,uvalue = 'CR')
  n27        =  widget_label (base511,value = 'Procedure for site display function:')
  SITE       =  widget_text  (base511,/editable,xsize = 10,value = ttsite  ,uvalue = 'CR')

  txt6       =  widget_label (base500,value = explain6)
  txt7       =  widget_label (base500,value = explain7)

   		   if actif ne 0 then bid=sys_dep      ('DYNLAB',BASE0,0)
		   WIDGET_CONTROL,BASE0,/REALIZE & if (actif ne 0) then put_logo
leader=0
if  n_elements(lamp_b1) eq 1 then leader=lamp_b1
if (actif ne 0) and (leader gt 0) then WIDGET_CONTROL,BASE0,GROUP_LEADER=leader

one_error:
IF (valid eq 0)THEN widget_control,comment,set_value = 'problem reading '+pth+'READ_PAR.PRO'
IF(valid eq 1) THEN widget_control,comment,set_value = 'OK Reading '     +pth+'READ_PAR.PRO'
IF(valid eq 2) THEN widget_control,comment,set_value = pth+'READ_PAR.PRO is a new file....'
IF(valid eq 3) THEN widget_control,comment,set_value = pth+'READ_PAR.PRO access denied !!!'

XMANAGER,'CUSTOMIZ', BASE0,EVENT_HANDLER = 'CHRIS_EVENT',/just_reg

txtw=[$
"pro write_tmp, FileName , Data , XC=x, YC=y , ZC=z ,E=e , N=n      $",$
"                               , PR=p, PV=pv, PAR_TXT=p_txt        $",$
"                               , W_tit=wt   , X_tit=xt  , Y_TIT=yt $",$
"                               , Z_tit=zt   , OTHER_TIT=ot",$
";** *********",$
";**",$
";**	Standard call for a data-write procedure called by LAMP.",$
" ",$
";**	Keywords:",$
";**           XC       = [vector of x coordinates.]",$
";**           YC       = [vector of y coordinates.]",$
";**           ZC       = [vector of z coordinates.]",$
";**           W_TIT    =   main title",$
";**           X_TIT    = x axis title",$
";**           Y_TIT    = y axis title",$
";**           Z_TIT    = z axis title",$
";**           OTHER_TIT=    sub title",$
";**           N        = monitors",$
";**           PR       = vector of parameter values",$
";**           PAR_TXT  = string array of text associated to PR (same size)",$
";**           PV       = an array of any dimensions containing other parameter values",$
";**           E        = the errors associated to DATA (same size) or 0",$
" ",$
"CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif",$
"ON_IOERROR,mis",$
" ",$
"OPENW ,unit, FileName, /get_lun",$
" ",$
"WRITEU,unit, Data    ;Write the Data (and parameters in the way you want).",$
" ",$
"FREE_LUN,unit",$
"return",$
" ",$
"mis:print,!err_string",$
"end"]

txtr=[$
"function read_tmp, INST , PATH , FILENAME , STATUS , DATP",$
";******* ********",$
";**",$
";**	Standard call for a data-read function interfacing LAMP.",$
"",$
";**	Return of the function",$
";**	 DATA     is an array of any dimensions and type containing the data values (spectra).",$
"",$
";**	Input  parameters:",$
";**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).",$
";**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).",$
";**	 INST(2)  is '1' if raw  button is set.",$
";**	 PATH     is the full path where to find the data (string defined in customize tables).",$
";**	 FILENAME is the name of the data file.",$
";**             if FILENAME(1) exists, this is the requested image number in the file",$
";**                                    entered as  file.ext{3} (for image 3).",$
";**	Output parameters:",$
";**	 STATUS   is the returned error code you can choose from the following list:",$
";**           0 =' Successfull read'",$
";**           1 =' Client/server on local  node not established'",$
";**           2 =' Client/server on router node not established'",$
";**           3 =' The local  node cannot access the server node'",$
";**           4 =' The router node cannot access the server node'",$
";**           5 =' VME memory read error'",$
";**           7 =' Sequence error in data transfer'",$
";**           9 =' Parameter error'",$
";**           10=' Router is busy with other transfer'",$
";**           11=' Cant open the file or file not found'",$
";**           13=' Data file incomplete'",$
";**           14=' Bad instrument data definition'",$
";**           24=' Cant read the file'.",$
";**",$
";**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)",$
";**           DATP.X        = vector of x coordinates.",$
";**           DATP.Y        = vector of y coordinates.",$
";**           DATP.Z        = vector of z coordinates.",$
";**           DATP.W_TIT    =   main title",$
";**           DATP.X_TIT    = x axis title",$
";**           DATP.Y_TIT    = y axis title",$
";**           DATP.Z_TIT    = z axis title",$
";**           DATP.OTHER_TIT=    sub title",$
";**           DATP.N        = monitors",$
";**           DATP.P        = vector of parameter values, max dim is defined in customize.",$
";**           DATP.PAR_TXT  = string array of text associated to DATP.P (same size)",$
";**           DATP.PV       = an array of any dimensions containing other parameter values",$
";**           DATP.E        = the errors associated to DATA (same size)",$
";**           DATP.TIME     = string date of the experiment.",$
"",$
" DATA  =0",$
" STATUS=7",$
" CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif",$
"",$
" ON_IOERROR, no_file",$
" OPENR,unit, PATH+FILENAME,/get_lun                   ;Open the data file",$
"",$
"      ON_IOERROR, read_err",$
"      STATUS=13",$
"      DATA  =FLTARR(40,40)                            ;Make a floating array",$
"      READU,unit,DATA                                 ;Read the data",$
"      STATUS=0                                        ;Status is ok",$
";     ********",$
"          xv       =  INDGEN(40)*2 +15                ;Make X coordinates",$
"          wt       =' Template_read test '",$
"          xt       =' This is the X axis '",$
"          par      = [        3.0       ,        5.5        ]",$
"          ptxt     = ['First  parameter','Second parameter' ]",$
"          pall     =  INDGEN(40,6)",$
"",$
"      DATP={X:      xv,    $                          ;Pass into the DATP structure",$
"            W_TIT:  wt,    $                          ;those variables which were read-in",$
"            X_TIT:  xt,    $",$
"            P:      par,   $",$
"            PAR_TXT:ptxt,  $",$
"            PV:     pall   }",$
";     **********************",$
"",$
" read_err:  FREE_LUN,unit                             ;Free the unit number",$
" no_file:",$
"",$
" RETURN, DATA                                         ;Return the data values",$
";************",$
" END"]

IF ACTIF EQ 0 THEN XMANAGER
endelse
return
END
;***************************************************************************************************************
;                                       END CUSTOMIZ
;***************************************************************************************************************

;                  FILE : DESCRIPT.PRO
;                 --------------------

;PARAMETERS RECIEVED ---->    NAMEFILE, TBL (lonarr(8))

;tbl(0) = x
;tbl(1) = y
;tbl(2) = z
;tbl(3) = type
;2        1  Byte
;4        2  Integer 2
;5       -2  Integer 2 unsigned
;16       3  Integer 4 long
;8        4  Floating point
;32       5  complex
;64       6  double precision
;tbl(4) = format
;5        0  unformatted fortran
;3        1  stream Vms binary
;2        2  Tiff gp uncompressed
;6        3  CCP4                     (unsensitive)
;0        4  stream unix, fixed vms
;7        5  Mar image plate
;1        6  Formatted ascii
;4        7  Formatted ix,iy,value    (unsensitive)
;8        8  Formatted value,ix,iy,iz (unsensitive)
;tbl(5) = swap
;         0   no swap
;         1   swap
;tbl(6) = record_size
;tbl(7) = start_record or Byte offset

;PARAMETERS RETURNED in P_ICK_RETURN : ok,namefile,tbl
;                                      ok = 1 open file
;                                      ok = 0 CANCEL)

;****************************************************************************
PRO DESCRIPT_EVENT, event
;****************************************************************************

common widg3,wstrec,getfil,xs,ys,zs,w_typ,w_swap,w_form,rsize,strec,apply,$
            typfil,formdata,rs_typfil,rs_formdata,ids_type,ids_form,ids_swap,$
            button_type,button_form,comment,val_type,val_form,base0

common values,namefile,tbl

		 stat=0 & catch,stat
	         if stat  ne 0  then begin catch,/cancel
	         		widget_control,bad_id=i,comment,set_value=strmid(!err_string,0,50)
	         		return & endif

widget_control,event.id,get_uvalue  =  uv               ; WIDGET UVALUE

IF n_elements(uv) gt 1 then IF uv(1) eq 391 then begin  p_did_mvlog, event,uv
							return & endif
;-----------------------------------------------------------------------
;                     BUTTONS "FORMATS"
;-----------------------------------------------------------------------
if(uv eq 'BUTTON_FORM')then begin
   tbl(4)  =  val_form(event.value)
   MOD_TITTLE,tbl(4)
endif
;------------------------------------------------------------------------
;                     BUTTONS type
;------------------------------------------------------------------------
if(uv eq 'BUTTON_TYPE')then begin
   tbl(3) = val_type(event.value)
endif
;------------------------------------------------------------------------
;                     BUTTON  BYTE SWAP
;------------------------------------------------------------------------
if(uv eq 'SWAP') then begin
   widget_control,w_swap(0),get_value = swap
   tbl(5) = swap
endif
;------------------------------------------------------------------------
;                    <CARRIAGE RETURN> IN FIELD NAMEFILE ?
;------------------------------------------------------------------------
if(uv eq 'CR') then return
;-------------------------------------------------------------------------
;                     BUTTON CANCEL
;-------------------------------------------------------------------------
if(uv eq 'CANCEL') then begin
   widget_control,event.top,/destroy
   P_ICK_RETURN,0,namefile,tbl
   return
endif
;-------------------------------------------------------------------------
;                     BUTTON READ
;-------------------------------------------------------------------------
if(uv eq 'READ')then begin;
     widget_control,getfil,get_value = namefile         ; GET NAMEFILE
     namefile = strcompress(namefile(0))
     VERIF_NAME,namefile,exist                          ; File exist and not blank ?
     if exist eq 0 then return
;........................ GET XSIZE
     widget_control,xs,get_value = ix                   ; GET XSIZE
     ix = ix(0)
     ix = strtrim(ix(0),2)
     if(ix eq '')then ix ='1'                           ; Blank ?
     field = 'Dim X' & good = 0
     VERIF_CHAR,ix,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(0) = long(ix)
;........................ GET YSIZE
     widget_control,ys,get_value = iy                   ; GET YSIZE
     iy = iy(0)
     iy = strtrim(iy(0),2)
     if(iy eq '')then iy = '1'                          ; Blank ?
     field = 'Dim Y' & good = 0
     VERIF_CHAR,iy,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(1) = long(iy)
;........................ GET ZSIZE
     widget_control,zs,get_value = iz                   ; GET ZSIZE
     iz = iz(0)
     iz = strtrim(iz(0),2)
     if(iz eq '')then iz = '1';                         ; Blank ?
     field = 'Dim Z' & good = 0
     VERIF_CHAR,iz,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(2) = long(iz)
;.........................GET RECORD SIZE
  widget_control,rsize,get_value = rs                   ; GET RECORD SIZE
  rs = strtrim(rs(0),2)
  if(rs eq '')then rs = '0';                            ; Blank ?
     field = 'Record' & good =0
     VERIF_CHAR,rs,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
  tbl(6) = long(rs)
;........................ GET START RECORD
  widget_control,strec,get_value = st                   ; GET START RECORD
  st = strtrim(st(0),2)
  if(st eq '')then st = '1'                             ; Blank ?
     field = 'Offset' & good =0
     VERIF_CHAR,st,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(7) = long(st)

;......................... ALL IS GOOD ........ THEN
  widget_control,event.top,/destroy                     ; destroy base
  P_ICK_RETURN,1,namefile,tbl                          ; call p_ick_return
  return

ENDIF

END
;*********************************************************************************************************
;                           END EVENT PROCEDURE
;*********************************************************************************************************



;^^^^^^^^^^^^^^^^^^^^^^^^^^ CONTROL PROCEDURES ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

PRO VERIF_NAME,name,exist           ;EXIST FILE AND NOT BLANK ?
common widg3
if(name eq '')then begin;
   widget_control,comment,set_value='fill up name of file area...'
   return
endif
b = findfile(name,count = exist);
if(exist eq 0)then widget_control,comment,set_value = '****** FILE DOES NOT EXIST...... ' else $
                   widget_control,comment,set_value = '****** FILE EXISTS................'
return
end
;-----------------------------------------------------------------------------
PRO VERIF_CHAR,name,field,good      ;ALPHABETICS CHARACTERS IN NUMERICS FIELDS ?
common widg3
fl='!!!...Non Numeric character in '+field+' area...!!!'
  for i1 = 0,strlen(name)-1 do begin
       car = (strmid(name,i1,1))
       if ((car ge 'A') and (car le 'Z')) or ((car ge 'a') and (car le 'z')) then begin
          widget_control,comment,set_value=fl
          good=1
          return
       endif
  endfor
  return
end
;-----------------------------------------------------------------------------
PRO MOD_TITTLE,num
common widg3
common values
if (num ne 5) and (num ne 2) then $
   widget_control,wstrec,set_value = 'Byte offset 1->n:' else $
   widget_control,wstrec,set_value = 'Starting record'

   if (num eq 0) 		then widget_control,bad_id=i,rsize,set_value='0'
   if (num eq 2) or (num eq 3)  then widget_control,bad_id=i,rsize,set_value='512'
   if (num eq 5) 		then widget_control,bad_id=i,rsize,set_value='-1'
   if (num eq 6) 		then widget_control,bad_id=i,rsize,set_value='1024'
   if (num eq 7) then begin	     widget_control,bad_id=i,xs   ,set_value='1200'
   				     widget_control,bad_id=i,ys   ,set_value='1200'
   				     widget_control,bad_id=i,zs   ,set_value='1'
   				     widget_control,bad_id=i,rsize,set_value='0'
   				     widget_control,bad_id=i,strec,set_value='2401'
   				     tbl(3)=5 & tbl(4)=0  &  endif
return
end
;^^^^^^^^^^^^^^^^^^^^^^^^^^ END CONTROL PROCEDURES ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^






;**********************************************************************************************************
PRO DESCRIPT,xnamefile,xtbl
;**********************************************************************************************************
@lamp.cbk
common widg3
common values

if xregistered('descript') gt 0 then widget_control,bad_id=i,base0,map=1 $
else begin


namefile=xnamefile;
tbl=xtbl

typfil   = strarr(7)
typfil   = ['Byte','Integer 2','Integer 2 unsigned','Integer 4 long',$
'Floating_point','Double_precision floating','Complex floating']
ids_type = intarr(7) ;                                                       ID type
but_type = intarr(7) ;
val_type = [2,4,5,16,8,32,64];                                               Values returned by type
val_form = [5,3,2,6,0,7,1,4,8];						     Values returned by format
formdata = strarr(9)
formdata = ['Unformatted Fortran','Stream VMS binary','Tiff g.p Uncompressed ',$
'Ccp4 (.map binary)','Stream Unix , Fixed VMS','Mar image plate','Formatted Ascii',$
'Formatted ix,iy,value','Formatted val,ix,iy,iz']

ids_form = intarr(9) ;                                                       ID form
ids_swap = intarr(1) ;                                                       ID swap

;^^^^^^^^^^^^^^^^^^^^^^^^^ WIDGETS DESCRIPTION ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

base0   = widget_base (/column,title = 'Data description',resource='lampdid')

widget_control,bad_id = ii,base0,default_font = ft_propor;                  Install FONT

bid	= widget_base (base0 ,/row)
	  put_logo    ,bid
COMMENT = widget_label(bid   ,value =string(replicate(32b,50)) )

base01  = widget_base (base0 ,/row)
chf     = widget_label(base01,value = 'File name :')
GETFIL  = widget_text (base01,/editable,value = strcompress(xnamefile),xsize = 45,uvalue = 'CR')

base02  = widget_base (base0 ,/row)
bid     = widget_label(base02,value = 'Dimensions:   X=')
XS      = widget_text (base02,/editable,value = strcompress(string(tbl(0))),xsize = 5,uvalue = 'CR')
bid     = widget_label(base02,value = 'Y=')
YS      = widget_text (base02,/editable,value = strcompress(string(tbl(1))),xsize = 5,uvalue = 'CR')
bid     = widget_label(base02,value = 'Z=')
ZS      = widget_text (base02,/editable,value = strcompress(string(tbl(2))),xsize = 5,uvalue = 'CR')

base03  = widget_base (base0, column = 2)

base031 = widget_base (base03 , /column,/frame)
W_TYP   = cw_bgroup   (base031, /column,/exclusive,typfil,uvalue = 'BUTTON_TYPE',$
				/no_release,ids = ids_type,label_top='DATA Type')

base032 = widget_base (base031, /column)
W_SWAP  = cw_bgroup   (base032, /row,/nonexclusive,'swap byte for Integers',$
					    ids = ids_swap,uvalue = 'SWAP',/frame)

base033 = widget_base (base03 , /column,/frame)
W_FORM  = cw_bgroup   (base033, /column,/exclusive,formdata,uvalue = 'BUTTON_FORM',$
				/no_release,ids = ids_form,label_top='DATA Format')


base4   = widget_base (base0,/row)
wstrec  = widget_label(base4, value = 'Byte offset 1->n:')
STREC   = widget_text (base4,/editable,xsize = 5,uvalue = 'CR',value = strcompress(string(tbl(7))))
w_rsize = widget_label(base4,value  = '[byte_recl](vms)')
RSIZE   = widget_text (base4,/editable,xsize = 5,uvalue = 'CR',value = strcompress(string(tbl(6))))

base41  = widget_base  (base0,/row)
CANCEL  = widget_button(base41,value = 'Cancel',uvalue = 'CANCEL')
bid     = widget_label (base41,value = 'or confirm characteristics pressing')
APPLY   = widget_button(base41,value = '    READ    ',uvalue = 'READ',/frame)

;^^^^^^^^^^^^^^^^^^^^^^^^^ END WIDGETS DESCRIPTION ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

bid=sys_dep      ('DYNLAB',base0,0)
WIDGET_CONTROL,group_leader=lamp_b1,/REALIZE,BASE0 & put_logo;               CREATE WIDGETS

widget_control,ids_form(3),sensitive = 0;                                    SET UNSENSITIVE BUTTONS FORM
widget_control,ids_form(7),sensitive = 0
widget_control,ids_form(8),sensitive = 0

but_type = where(val_type eq tbl(3)) & but_type=but_type(0)>0 ;              Corresponding buttons type
but_form = where(val_form eq tbl(4)) & but_form=but_form(0)>0 ;              Corresponding buttons type

widget_control,ids_type(but_type),set_button = 1   ;                         Set Buttons pushed with form and type recieved
widget_control,ids_form(but_form),set_button = 1
widget_control,ids_swap(0),       set_button = tbl(5)

VERIF_NAME,namefile

MOD_TITTLE,but_form

xmanager,'descript', base0,event_handler='descript_event',/just_reg

endelse
return
END

pro DialCommons
;** ***********
;**
@lamp.cbk
common c_geo, geo_stat, geo_w  , geo_vis, geo_alp, geo_freq, geo_isw, geo_onbas,$
              geo_bxy , geo_cur, geo_ran, geo_seq, geo_info, geo_lim, geo_timon,$
              geo_par2, geo_lead,geo_act

common c_geweb, geo_web,gew_act, gew_pth, gew_snd, gew_err, gew_pwd, gew_r,gew_g,gew_b,gew_v
end

function N2S, number
;******* ***
;**
return, strtrim(string(number),2)
end

function DialNameToNumber, name, find=find
;******* ****************
;**
;** Given the name of a dial, return its number
;** If keyword_set find then  return a free number if no name match

common dialshare2
common c_geo

named=strupcase(name) & nome=''
N=0   & Pn=(size(geo_w))(2)-1
k=1   & while k le Pn do begin di=strtrim(string(k),2)
		    ii=execute ('if n_tags(d'+di+') gt 1 then nome=d'+di+'.NAME')
		    if strupcase(nome) eq named then begin N=k & k=Pn & endif & k=k+1
        endwhile

if N eq 0 then if keyword_set(find) then begin
			k=1 & while k le Pn do begin di=strtrim(string(k),2)
			      ii=execute ('if n_tags(d'+di+') le 1 then N=k')
			      ii=execute ('if n_tags(d'+di+') gt 1 then if d'+di+'.NAME eq "" then N=k')
			      if N gt 0 then   k=Pn & k=k+1
				endwhile
			if N eq 0 then $
			k=1 & while k le Pn do begin di=strtrim(string(k),2) & onoff=1
			      ii=execute ('if (n_tags(d'+di+') gt 1) then onoff=d'+di+'.ONOFF')
			      if onoff ne 1 then begin N=k & k=Pn & endif & k=k+1
				endwhile
			endif
return,N
end

;******* **************************************************************************
;******* **************************************************************************
;******* **************************************************************************
pro DialTag, name, d=dnum, TAG=tag, SET=setv, GET=getv
;** *******
;**
;** Set or Get the tag value of named dial
common c_geo
common dialshare2
	getv=0
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then if n_elements(tag) eq 1 then begin
	   if n_elements(setv) gt 0 then begin
	      if strupcase(tag) eq "ONOFF"   then if setv gt 0 then DialStart, d=dnum $
	                                                       else DialStop , d=dnum else $
	      if strupcase(tag) eq "HISTORY" then DialHistory, d=dnum ,ONOFF=setv     else $
	      if strupcase(tag) eq "VALUE"   then DialModValue,d=dnum ,      setv     else $
	      if strupcase(tag) eq "ERROR"   then DialModValue,d=dnum ,      setv, tag='ERROR' $
		  else DialModValue,d=dnum ,      setv, tag=strupcase(tag)
	     ;else    ii=execute('d'+strtrim(string(dnum),2)+'.'+tag+'=setv')

	   endif else ii=execute('getv=d'+strtrim(string(dnum),2)+'.'+tag)
	endif else if n_elements(setv) eq 0 then ii=execute('getv=d'+strtrim(string(dnum),2))  $
	                                    else ii=execute('d'+strtrim(string(dnum),2)+'=setv')
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialsFrequency, GET=getv, SET=setv, STOP=stop, START=start, DURATION=lim, SENS=sens
;** **************
;**
;** Settings of the Timer

common c_geo
	if n_elements(setv) eq 1 then begin
	   on_ioerror,miset & geo_freq=setv & v=strtrim(string(setv),2)
	   if geo_onbas(0) gt 0 then widget_control,geo_onbas(0),bad_id=ii,set_value=v
	   miset:
	endif
	if n_elements(lim)  eq 1 then begin
	   on_ioerror,mislm & geo_lim =lim  & v=strtrim(string(lim),2) & if lim le 0 then v=" "
	   if geo_onbas(2) gt 0 then widget_control,geo_onbas(2),bad_id=ii,set_value=v
	   mislm:
	endif
	if keyword_set(stop)  then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=0
	   geo_stat=0 & geo_w(8,*)=0 & endif
	if keyword_set(start) then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=1
	   geo_stat=1 & geo_timon(0)=systime(1)*1000 & P_GEO_TIMER, {id:geo_onbas(3)}
	   geo_w(8,*)=0 & endif

	if keyword_set(sens)  then if geo_stat  then   P_GEO_TIMER, {id:geo_onbas(3)}

	getv=geo_freq
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialNewValue, tope, NAME=name, d=dnum, SETVALUE=setvalue, COMMENT=ctxt, TYPE=tipe
;******* ************
;**
;** Get next value of the named dial by calling dial_"generic"_read interface function
;** (called from dial_macros)

common dialshare2
common c_lamp_par
common c_geo
val='0'
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if n_elements(ctxt) eq 0 then ctxt=""
	if n_elements(tope) eq 1 then if n_elements(tipe) ne 1 then tipe=tope

	 di=strtrim(string(dnum),2)

	   P_GEO_STATUS, dnum, "Get"

	   generic='' & nome='' & prox=-1
	   if n_elements(tipe) eq 1 then nome=tipe else $
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('generic=d' +di+'.GENERIC')
	   ii=execute('prox   =d' +di+'.PROX')
	   now=systime(1)
	   val=3.14

	   if generic eq 'lamp' then begin val=' '
	      CASE strlowcase(nome) of
	      'flagus':	val=0
	      'status':	val='Idle'
	      'log':	DID_WRITE_JOURNAL, val
	      ELSE:
	      ENDCASE
	   endif else $
	   if prox(0) ge 0 then begin par1=nome & par2=now     & par3=ctxt & par4=val
	                              COMMCA, proxcod ,prox    & val =par4 ; GET THE VALUE !!!!!!!!!!!!
	   endif else begin
	    ii=execute('val=dial_'+generic+'_read(nome, now, ctxt)')       ; GET THE VALUE !!!!!!!!!!!!
	    if not ii then begin val='0' & DialErrMes & DialStop & endif
	   endelse

	   geo_w(9,dnum)=geo_w(9,dnum)+((systime(1)-now)*1000)
	   sv=SIZE(val)
	   if sv(sv(0)+1) eq 4 then if val(0) eq 3.14 then P_GEO_STATUS, dnum, "GetNone" $
	                                              else P_GEO_STATUS, dnum, "GetOk"   $
	                                              else P_GEO_STATUS, dnum, "GetOk"

	   if keyword_set(setvalue) then DialModValue, val, d=dnum
return, val
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialModValue, val, NAME=name, d=dnum ,tag=TAG
;** ************
;**
;** Used when dial.VALUE changes its type or dimension

common dialshare2
common c_geo

    if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
    if n_elements(dnum) ne 1 then dnum=geo_cur
    if dnum gt 0 then begin
      di=strtrim(string(dnum),2)
      sv=SIZE   (val)
      if n_elements(TAG) ne 1 then TAG='VALUE' else TAG=strupcase(TAG)
      sz=[0,0,0] & ii=execute('sz=SIZE(d'+di+'.'+TAG+')')
      if (sz(sz(0)+1) ne sv(sv(0)+1)) or (sz(sz(0)+1) eq 8) or  $
         (sz(0) ne sv(0)) or (sz(sz(0)+2) ne sv(sv(0)+2)) then begin
	 elsa = ''
	 tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
	 for k=0,n_elements(tlist)-1 do begin
          CASE tlist(k) of
           TAG:
           ELSE:      elsa =elsa+','+tlist(k)+':d'+di+'.'+tlist(k)
          ENDCASE
	 endfor
                 ii=execute('d'+di+'={'+TAG+':val'+ elsa +'}')
      endif else ii=execute('d'+di+'.' +TAG+'=val')
    endif
end

pro DialMix, A,B
;** *******
;**
;** Mixe Dial B into Dial A

    nA=n_tags(A)  & nB=n_tags(B)
    if nB lt 1 then return
    if nA lt 1 then begin A=B  & return & endif
    elsa=''
    lA=strupcase(tag_names(A))
    for k=0,nA-2 do  elsa =elsa    + lA(k)   +':A.'+lA(k)+','
                     elsa =elsa    + lA(nA-1)+':A.'+lA(nA-1)
    lB=strupcase(tag_names(B))
    for k=0,nB-1 do  if (where(lA eq lB(k)))(0) eq -1 then $
                     elsa =elsa+','+ lB(k)   +':B.'+lB(k)

    ii=execute('A={'+ elsa +'}')
end

pro DialHistory, name, d=dnum, ONOFF=v
;** ***********
;**
;** A short for DialTag procedure

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  ii=execute('d'+strtrim(string(dnum),2)+'.HISTORY=v')
	                   if v then lab ='History is on' else lab ='History is off'
				 if geo_isw then widget_control,bad_id=ii,geo_w(7,dnum),set_value=lab
				 endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStop, name, d=dnum
;** ********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geo
common c_geweb
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=0')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=0
				 geo_w(8,dnum)=0
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' stopped'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial stopped' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' stopped'
				 if geo_web then WebDo,'val',dnum,dnum
				 endif
end
;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStart, name, d=dnum
;** *********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geo
common c_geweb
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=1')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=1
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
				 freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
				 geo_w(8,dnum)=0
				 geo_timon(dnum)=systime(1)*1000
				 if freq  gt 0  then  P_GEO_TIMER, {id:geo_w(11,dnum)} $
	                                  else  DialsFrequency, /SENS
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' started'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial started' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' started'
				 if n_elements(gew_pth) eq 0 then WEBON
	endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialControl, command, d=dnum ,check=check ,name=nome
;******* ***********
;**
;** Back control to the instrument

common dialshare2
common c_lamp_par
common c_geo
common c_geweb

if n_elements(dnum)  ne 1 then dnum =geo_cur
if n_elements(nome)  eq 1 then dnum =DialNameToNumber(nome)
if n_elements(check) ne 1 then check=0.

di     =strtrim(string(dnum),2)
generic='' & ii=execute('generic=d' +di+'.GENERIC')
if generic eq 'lamp' then ctrl='' else ctrl='Ctrl:'

comm=[strtrim(command,2)]
comh= comm
for i=0,n_elements(comm)-1 do begin

	if strpos(strupcase(comm(i)),'CTRL:') eq 0 then comm(i)=strmid(comm(i),5,85)
	if i eq 0 then comh(i)= ctrl  +comm(i)+" ;; "+!stime $
	          else comh(i)='----:'+comm(i)
	to_don_history,-1,0,comh(0)
endfor
if geo_web then WebDo,'snd',comh,dnum

if generic ne "lamp" then begin
	   P_GEO_STATUS,dnum, "Send"

	   nome='' & prox=-1 & name=""
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('name   =d' +di+'.NAME')
	   ii=execute('prox   =d' +di+'.PROS')
	   now=systime(1)
	   val=3.14

	   if prox(0) ge 0 then begin par1=nome & par2=check & par3=comm & par4=val & par5=name
	                              COMMCA, proxcod ,prox  & val =par4     ; SEND THE COMMAND !!!!!!!!!!!!

	   endif else begin CoCo='val=dial_'+generic+'_send(nome, check, comm, name)'
				      ii=EXECUTE(CoCo)                       ; SEND THE COMMAND !!!!!!!!!!!!

	    if not ii then begin val=0 & DialErrMes & DialStop & endif
	   endelse

	   geo_w(10,dnum)=geo_w(10,dnum)+((systime(1)-now)*1000)

	   if val ne 3.14 then P_GEO_STATUS,dnum, "SendOk" $
                        else P_GEO_STATUS,dnum, "SendNone"

endif else begin val=0 & XICUTE,comm(0) & endelse
return,val
end

pro DialClear, name, d=dnum
;** *********
;**
;** Remove the named dial

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
				 DialStop,d=dnum
				 DialTag ,d=dnum, tag="NAME", set=""
				;DialTag ,d=dnum, tag="PWD",  set=""
				 geo_w(6,dnum)=0
				 geo_w(8,dnum)=0
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =0
				 if geo_w(1,dnum) gt 0 then begin
				    di=strtrim(string(dnum),2)
				    P_GEO_DISPLAY, 'd'+di, geo_w(1,dnum) ,-1 ,DNUM=dnum
	endif		&	 endif
end

pro DialMacro, name, d=dnum, Si=di
;** *********
;**
;** Execute the macro of the named dial
;** Display the result

@lamp.cbk
common c_geo
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)   else name=''
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
	   if n_elements(di) ne 1 then di = strtrim(string(dnum),2)

	   geo_w(5,dnum)=geo_cur & geo_cur= dnum
	   geo_w(9,dnum)=0       & geo_w(10,dnum)=0
	   now=systime(1)

	   ii=execute('name =d'+di+'.NAME')
	   ii=execute('orig =d'+di+'.ORIGIN')
	   ii=execute('prox =n_elements(dt'+di+')') & jj=1

	   CATCH,stat & if stat ne 0 then begin catch,/cancel & DialErrMes & DialStop & return & endif

	   if prox gt 1 then begin DialFromD,keepd
	                     ii=execute('DialToD,  d'+di)
	                     jj=execute('COMMCA,  dt'+di)           ;EXECUTE THE MACRO OF THE DIAL from .prox
	                     ii=execute('DialFromD,d'+di)
	                                 DialToD  ,keepd
	   endif        else jj=execute('dial_'+orig+'_macro,d'+di) ;EXECUTE THE MACRO OF THE DIAL from .pro

	   if jj eq 0 then begin DialErrMes &  DialStop & endif

	   geo_w(8,dnum)=((systime(1)-now)*1000)>1

	   sz  =0  & ii=execute('sz   = SIZE (d'+di+'.VALUE)')
	   wupd=0  & ii=execute('wupd =d'+di+'.WUPDATE')
	   hiss=0  & ii=execute('hiss =d'+di+'.HISTORY')
	   if hiss then begin u=-1
		ii=execute('val=d'+di+'.VALUE(0)')
		if (val ne '') or (sz(sz(0)+2) gt 1) then begin
			on_ioerror,misopn & openw,u,"dial_"+name+".his",/append,/get_lun
			ii=execute('printf,u,d'+di+'.VALUE')
			misopn: if u gt 0 then free_lun,u
	   endif  & endif
	   val  =0
	   plt  =0      &         ii=execute('plt =       d'+di+'.PLOT')
	   histo=0

	   dw=di
	   if wupd le 0 then dw=strtrim(string(dnum+70),2)

	   if (sz(sz(0)+1) eq 7) and (plt gt -2) then begin
		ii=execute('val =  ";"+ d'+di+'.VALUE')
		if sz(sz(0)+2) gt 1 then begin
			WebDo,'log',val,dnum
			form_out,val & print,val & val='... '+val(n_elements(val)-1)
		endif else begin
			if val(0) le "; " then plt=-2
		endelse
		if plt ne -2 then begin ii=execute('w'+dw+' = val') & plt=-1 & endif

	   endif else if plt eq -1 then ii=execute('w'+dw+' = d'+di+'.VALUE') $

	   else if plt ge 0 then begin
		   sze=0.       &   ii=execute('sze  = d'+di+'.ERROR')
		   if n_elements(sze) ne sz(sz(0)+2) then sze=0.
				    alltag=[' '] & ii=execute('alltag = strupcase(TAG_NAMES(d'+di+'))')
				    xtl='' & ytl=''
				    idx=where(alltag eq 'X_TIT')  & idy=where(alltag eq 'Y_TIT')
				    if idx(0) ge 0 then  ii=execute ( 'xtl     = d'+di+'.X_TIT')
				    if idy(0) ge 0 then  ii=execute ( 'ytl     = d'+di+'.Y_TIT')
				    if wupd   gt 0 then  x_tit(dnum) = xtl    & !X.title=xtl
				    if wupd   gt 0 then  y_tit(dnum) = ytl    & !Y.title=ytl
				    if wupd   gt 0 then  w_tit(dnum) = name
				    if wupd   gt 0 then  other_tit(dnum) =  '(Dial)'
		   if sz(sz(0)+2) gt 1 then begin
				    ii=execute('w'+dw+' = d'+di+'.VALUE')
				    ii=execute('e'+dw+' = sze')
				    idx=where(alltag eq 'XVALUE') & idy=where(alltag eq 'YVALUE')
				    if idx(0) ge 0 then  ii=execute ( 'x'+dw+' = d'+di+'.XVALUE')
				    if idy(0) ge 0 then  ii=execute ( 'y'+dw+' = d'+di+'.YVALUE')
		   endif else begin
		     if plt gt 1 then  begin val=0 & ii=execute('val    = d'+di+'.VALUE')
			                             ii=execute('sz     = n_elements(w'+dw+')')
			if sz lt plt then begin      ii=execute('w'+dw+'=[(lonarr(plt-sz)+1)*val,w'+dw+']')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			if sz gt plt then begin      ii=execute('w'+dw+'= w'+dw+'(sz-plt:sz-1)')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			                 ii=execute('w'+dw+'=[w'+dw+'(1:plt-1),val]')
			if sze gt 0 then ii=execute('e'+dw+'=[e'+dw+'(1:plt-1),sze]')
			histo=1
		     endif          else ii=execute('w'+dw+'= d'+di+'.VALUE')
		   endelse
	   endif
	   if plt ge -1 then if (geo_w(1, dnum) gt 0) or (geo_w(13, dnum) gt 0) then begin
			ii=execute('P_GEO_DISPLAY, D'+di+', W'+dw+', error=E'+dw+', X=X'+dw+', Y=Y'+dw+', histo=histo')
	   endif
	   if geo_act eq 2 then WebDo,'dws',0,0,0

	   geo_cur=geo_w(5,dnum) & geo_w(5,dnum)=0
	   nel=n_elements(geo_timon)-1
	   if now - geo_timon(nel-dnum) gt 3. then begin
	   	if (dw eq di) and (plt gt -2) then TO_DON_HISTORY ,dnum,0,'W'+di+'=dial_'+name+'_macro result' ,/nojournal
		geo_timon(nel-dnum)=now
	   endif
	endif
end

pro DialFromD, Dial
;** *********
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
if n_elements(d) gt 0 then Dial=d
end
pro DialToD, Dial
;** *******
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
d=Dial
end
pro DialErrMes
;** **********
@lamp.cbk
common c_geo
  if l_message gt 0 then widget_control,bad_id=ii,l_message,set_value=strmid(!err_string,0,65)+' ...'
  print, !err_string
  WebDo,'err',!err_string
end
pro DialWSet, Activity=activity
;** ********
@lamp.cbk
common c_geo
  if keyword_set(activity) then begin
	P_GEO_DISPLAY,did_win0,1,0
  	geo_act=0
  endif else begin
  	if geo_act ne 2 then P_GEO_DISPLAY,did_win0,-1,0
  	geo_act=2
  	p_did_setwin0,/map
  endelse
end

pro DialInit, name, d=dnum, path=pth, restore=restore, new=newed, herits=diaH, nostart=nostart
;** ********
;**
;** the dial_name.pro file is compiled
;** and dial_name function is used to initiate the Dial.
;** Check for dial consistency then put it in D'dnum'.
;** /restore is used when restore saved session.
;** If new is defined then after loaded, give it the name "newed".

@lamp.cbk
common c_geo
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

if n_elements(name)   eq 1 then begin
 if n_elements(newed) ne 1 then newed =strlowcase(name)
 if n_elements(dnum)  ne 1 then dnum  =DialNameToNumber( newed, /find)
 if (dnum ge 1) and (dnum lt (size(geo_w))(2)) then begin
  di=strtrim(string(dnum),2)
  if l_message gt 0 then widget_control,l_message,bad_id=ii,set_value=" "
  if n_elements(pth) ne 1 then pth =""
  CD,current=mee
  if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
  fname="dial_"+name
  dial =''
  proc =findfile(fname+".pro" ,count=nn)
  if nn eq 0 then begin
     prox =findfile(fname+".prox",count=nn)
     if  nn gt 0 then begin DialFromD,keepd
                         COMMSI,fname+".prox", /EXEC             & DialFromD,dial
                         COMMSI,fname+"_macro.prox", MACRO=extxt & ii=execute('dt'+di+'=extxt')
                         DialToD  ,keepd  &  nn=-2
     endif & CD,mee
  endif
  if  nn ne -2 then begin
       if newed eq strlowcase(name) then if  sys_dep ('VERSION') ge 4.0 then $
       if (not sys_dep("EMBEDDED")) and (not sys_dep("RUNTIME")) then $
       ii  =execute('RESOLVE_ROUTINE,fname,/is_f')
       rout=[strupcase(fname)]
       if  sys_dep ('VERSION') ge 5.1 then ii=execute('rout=routine_info(/functions)')
       idx=where(rout eq strupcase(fname))
       if idx(0) ge 0 then ii=execute('dial='+fname+'()')	;INITIATE THE DIAL
       CD,mee
       if not ii then DialErrMes
  endif

  if n_elements(restore) eq 0 then begin

   if n_tags(dial) lt 1 then dial={init:0}

	tlist=strupcase(tag_names(dial))
	idx=where(tlist eq 'INHERIT')
	if idx(0) ge 0 then if dial.inherit gt ' ' then begin    diaG=''
	    DialInit , string (dial.inherit) , d=dnum, path=pth, herits=diaG
	    DialMix  , dial ,  diaG
	    tlist=strupcase(tag_names(dial)) & endif

	if n_elements(diaH) gt 0 then begin
	    DialMix  ,diaH,dial  &   return  & endif

	named    =newed
	generic  ='mad'
	type     =name
	value    =""
	error    =0.
	onoff    =0
	number   =dnum
	frequency=0.
	wupdate  =0. & if GEORGE eq 1 then wupdate=1
	upperlim =0.
	lowerlim =0.
	plot     =50
	history  =0
	duration =0
	init     =0
	unit     =''
	elsa     =''
	for k=0,n_elements(tlist)-1 do begin

	    CASE tlist(k) of
	    'NAME':
	    'NUMBER':
	    'PATH':
	    'ONOFF':     onoff    =fix   (dial.onoff)
	    'VALUE':     value    =dial.value
	    'ERROR':     error    =float (dial.error)
	    'PLOT':      plot     =fix   (dial.plot)
	    'WUPDATE':   wupdate  =fix   (dial.wupdate)
	    'INIT':      init     =fix   (dial.init)
	    'UNIT':      unit     =string(dial.unit)
	    'UPPERLIM':  upperlim =float (dial.upperlim)
	    'LOWERLIM':  lowerlim =float (dial.lowerlim)
	    'GENERIC':   generic  =string(dial.generic)
	    'TYPE':      type     =string(dial.type)
	    'FREQUENCY': frequency=float (dial.frequency)
	    'HISTORY':   history  =fix   (dial.history)
	    'DURATION':  duration =float (dial.duration)
	     ELSE:       elsa=elsa+','+tlist(k)+':dial.'+tlist(k)
	     ENDCASE
	endfor

	if keyword_set(nostart) then onoff=0
	DialClear,named
	ii=execute('d'+di+'={NAME:named,ORIGIN:name,GENERIC:generic,TYPE:type,INIT:init'+ $
	                   ',PLOT:plot ,UPPERLIM:upperlim,LOWERLIM:lowerlim,WUPDATE:wupdate'    + $
	                   ',ONOFF:onoff,VALUE:value,ERROR:error,FREQUENCY:frequency,DURATION:duration' +$
	                   ',HISTORY:history,PROX:[-1L,0],PROS:[-1L,0],NUMBER:number,UNIT:unit,PATH:pth'+$
	                     elsa +'}')

	if (wupdate gt 0) then begin
		ii=execute('w'+di+'=0')
		CLEARPAR, dnum,di
		w_tit    (dnum)=named  +' dial'
		other_tit(dnum)=type   +' (type) <- '+generic
		y_tit    (dnum)=unit
	endif
	ii=execute('w'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('x'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('y'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('e'+strtrim(string(dnum+70),2)+'=0')

	if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
	SetDuduch, "_read", generic, PROX & ii=execute('d'+di+'.PROX=PROX')
	SetDuduch, "_send", generic, PROX & ii=execute('d'+di+'.PROS=PROX')
	CD,mee

  endif
  if geo_isw then begin
			widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
			P_GEO_DISPLAY, newed, dnum ,-2

			DialTag, d=dnum, TAG='ONOFF'  , GET=onoff
			DialTag, d=dnum, TAG='ONOFF'  , SET=onoff
			DialTag, d=dnum, TAG='HISTORY', GET=history
			DialTag, d=dnum, TAG='HISTORY', SET=history
			endif

  if geo_w(1,dnum) gt 0 then P_GEO_DISPLAY, newed, geo_w(1,dnum) ,-1 ,DNUM=dnum

  if geo_cur le 0 then geo_cur=dnum ; To prevent problems in DialControl & DialNewValue
  geo_w(6,dnum)=1
 endif
endif
end

pro SetDuduch, proo, generic, PROX
;** *********
;**
common dialshare2

PROX=[-1L,0]
	  proc  =findfile ("dial_"+generic+proo+".pro" ,count=nn)
	  if nn eq 0 then begin
	   prof =findfile ("dial_"+generic+proo+".prox",count=nn)
	   if nn gt 0 then begin
		idx=where(duduch3 eq generic+proo) & idx=idx(0)
		if idx eq -1 then begin              idx=n_elements(proxcod)
		   COMMSI,"dial_"+generic+proo+".prox",  MACRO=tmpcod
		   nn     =n_elements(tmpcod)
		   duduch3=[duduch3,generic+proo,string(idx),string(idx+nn-1)]
		   proxcod=[proxcod,tmpcod]
		   PROX   =[idx,idx+nn-1L]
		endif else PROX=[long(duduch3(idx+1)),long(duduch3(idx+2))]
	   endif
	  endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialOn, dial, d=dnum
;******* ******
;**
;** Check for a User interrupt

common dialshare2
common c_geo

R=1
if geo_isw then begin
	if geo_onbas(1) gt 0 then begin
	   evv=widget_event(geo_onbas(1),/nowait,bad_id=ii)
	   if evv.id    eq  geo_onbas(1) then begin geo_stat =evv.select & R=geo_stat
	                                            geo_timon(0)=systime(1)*1000  &  endif
	endif
	if R then begin
	   if n_elements(dnum) ne 1 then dnum=geo_cur
	   if n_tags(dial)     gt 1 then dnum=dial.number
	   if (dnum ge 1) and (dnum le (size(geo_w))(2)) then begin
	     evv=widget_event(geo_w(3,dnum),/nowait,bad_id=ii)
	     if evv.id    eq  geo_w(3,dnum) then DialTag, d=dnum, tag='ONOFF', set=evv.select
	     DialTag ,d=dnum,tag='ONOFF', get=R
	   endif
	endif
endif
return,R
end

;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
pro WebFTP, file ,open=opn ,ifopn=ifopn ,check=check
;** ******
common c_geweb
common c_geUnit, gew_unit, gew_tftp ,gew_chk

;TEST FOR FTP AND BARNS ENABLE
if n_elements (gew_unit)  eq 0 then begin
   if sys_dep ('MACHINE') eq 'unix' then gew_unit= 0 else gew_unit=-1
   if sys_dep ('VERSION') lt 5.2    then gew_unit=-1
   bb=findfile(expand_path('~/.ssh')+'/*',count=n)  & if n lt 1 then gew_unit=-1
   gew_chk=0 & gew_tftp= dblarr(2)
endif else if keyword_set(opn) then begin if gew_unit lt 0 then gew_unit=0 & gew_chk=0 & endif

gew_unit=-1 ;Barns now is inside ILL

if gew_unit ge 0 then begin line=' ' & u=0
   on_ioerror,misftp
   if gew_unit gt 0 then begin now=systime(1) & delt=now-gew_tftp(0)
;   TEST TIME-TO-TIME FOR PIPE CONNECTION (OR INPUT COMMAND)
    if keyword_set(check) or (delt gt 7.) then begin
       if delt le 7. then begin if check eq 2 then gew_chk=0 & ok=1 & endif else ok=0
       s=fstat(gew_unit) & six=6
       if s.size gt six then begin ok=1
          while s.size gt six do begin readf,gew_unit,line & s=fstat(gew_unit)
	   if strpos(line,'Timeout')  ge 0 then begin s.size=0 & ok=0 & WebFTP_close & endif else $
	   if strpos(line,'by peer')  ge 0 then begin s.size=0 & ok=0 & WebFTP_close & endif else $
	   if strpos(line,gew_pth(3)) ge 0 then if (strpos(line,'Fetching') lt 0) and (strpos(line,'Removing') lt 0) then begin
	                                        printf, gew_unit,'get '+gew_pth(1)+gew_pth(3)+' '+gew_pth(1)+gew_pth(3)
                                                printf, gew_unit,'rm  '+gew_pth(1)+gew_pth(3) & gew_chk=2 & endif
          endwhile
          if ok eq 1 then begin if keyword_set(check) then begin
	                           if check eq 2 then gew_chk=0 $  ;RESET by webon_macro
				   else begin check=gew_chk        ;WILL BE THERE NEXT TIME IF gew_chk eq 2
	                                      if gew_chk eq 2 then begin gew_chk=1 & check=0 & endif
                                              if gew_chk eq 0 then printf, gew_unit,'dir '+gew_pth(1) & endelse
	                        endif
				printf, gew_unit,'pwd' & gew_tftp(0)=now & endif
       endif else check=gew_chk
       if ok eq 0 then if now-gew_tftp(1) gt 60*6. then gew_tftp(1)=now else $
                       if now-gew_tftp(1) gt 60*4. then WebFTP_close    else $
		       if now-gew_tftp(1) lt 20*1. then begin print,'No response from Ftp '+!stime & gew_tftp(1)=now-20 & endif
    endif
   endif
;  OPEN FIRST OR BROKEN CONNECTION
   if gew_unit eq 0 then begin
      if keyword_set(ifopn) then return
;     openr ,u,gew_pth(2),/get_lun & readf ,u,line & free_lun,u
;     openw ,u,'~/.netrc',/get_lun & printf,u,line & free_lun,u
;     spawn,'chmod 600 ~/.netrc' & openr ,u,'~/.netrc',/get_lun,/DELETE
      spawn,['sftp','arthur@barns'],unit=gew_unit,/noshell
      printf, gew_unit,'cd '+ gew_pth(0)
      printf, gew_unit,'pwd' & wait,2 & s=fstat(gew_unit) & six=6
      ok=1
      if gew_tftp(0) eq 0 then begin jj=5 & ok=0 ;FIRST TIME OPENED
         while (s.size le six) and (jj gt 0) do begin wait,1 & jj=jj-1 & s=fstat(gew_unit) & endwhile
         if s.size gt six then begin
            while s.size gt six do begin readf,gew_unit,line & s=fstat(gew_unit) & endwhile
            if strpos(line,strmid(gew_pth(0),0,strlen(gew_pth(0))-1)) ge 0 then begin
               printf, gew_unit,'pwd' & print,'Ftp reactivated '+!stime & ok=1 & endif
         endif
      endif                                      ;-----------------
      gew_tftp(0:1)=systime(1)
      if not ok then begin WebFTP_close & gew_unit=-1 & endif
      if u gt 0 then free_lun,u & u=0
   endif

;  SEND THE FILE
   if n_elements(file) eq 1 then printf, gew_unit,'put '+gew_pth(0)+file+ ' '+file
   return

   misftp: WebFTP_close & if u gt 0 then free_lun,u & if gew_tftp(0) eq 0 then gew_unit=-1
endif
end

pro WebFTP_close
;** ************
common c_geUnit
if n_elements(gew_unit) eq 1 then if gew_unit gt 0 then begin
   print,'Ftp canceled '+!stime
   if sys_dep('VERSION') lt 5.4 then free_lun,gew_unit else ii=execute('free_lun,gew_unit,/force')
   gew_unit=0
endif
end

pro dial_webon_macro,D
;** ****************
;**
nn =1 & WebFtp,CHECK=nn
if  nn eq 1 then bid=FINDFILE(D.webpth,count=nn)
IF  nn gt 0 then begin wline=[''] & value=['']
    on_ioerror,misopn
    OPENR,u,D.webpth,/GET_LUN,/DELETE
	on_ioerror,misread
	line=''
	WHILE (not EOF(u)) do begin READF,u,line & wline=[wline,line] & ENDWHILE
	misread:  on_ioerror,misopn
	FREE_LUN ,u
	WebFtp,CHECK=2
	IF n_elements(wline) gt 2 then if wline(1) eq D.pwd then begin
		wline=wline(2:*)
		XICUTER,' ;--->WebOn '+!stime+' {'+wline(0)+'...}'
		CATCH,stat & if stat ne 0 then begin print,!err_string & return & endif
		FOR i=0,n_elements(wline)-1 do $
			IF wline(i) ne D.pwd then begin line=strtrim(wline(i),2)

			   if strpos(line,'ii=barns_i') ge 0 then jj=EXECUTE(line) $
			   else if line gt ' '	then begin XICUTER,(line+'') & value=[value,line]
			        endif
			ENDIF
		XICUTER,' ;---> '
		if n_elements(value) gt 1 then value=value(1:n_elements(value)-1)
		WebDo,'log',value,12
	ENDIF
	DialModValue,value, TAG='VALUE'
    misopn:
endif else if D.value(0) ne '' then DialModValue,[''], TAG='VALUE'
end

function dial_webon
;******* **********
;**
return,{NAME:"webon",PLOT:0,HISTORY:0,VALUE:[''],FREQUENCY:3,WEBPTH:'',PWD:'',WUPDATE:-1}
end

pro WebOn, PATH=wpth ,PASSWORD=pass, PASSWD=pasw
;** *****
common c_geo
common c_geweb

catch,stat & if stat ne 0 then return

if n_elements(gew_pwd) ne 1 then       gew_pwd= ''
if n_elements(   pass) eq 1 then begin gew_pwd=pass & ii=execute('geokey,gew_pwd') & endif
if n_elements(   pasw) eq 1 then begin gew_pwd=pasw & ii=execute('geokey,gew_pwd') & endif
Mach=strupcase(getenv('HOST')) & id=strpos(Mach,'.')
if id gt 0 then Mach=strmid(Mach,0,id)
dvd=sys_dep('DIVIDER')
if n_elements(gew_pth) lt 2 then begin gew_pth=['','','','.geo_webon.txt']
		if Mach eq "" then begin F='C:\User\Didier\geoport\' & Mach='pcRichard'
		endif         else       F='/home/cs/lambda/geoport/'
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(0)=F+Mach
		gew_pth(2)=F+'.bArns'
		F=F+'WebGeorge'+dvd
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(1)=F+Mach+dvd else gew_pwd=''
endif

if n_elements(wpth) eq 1 then gew_pth(0)=  wpth
nld=strlen(gew_pth(0))-1
if nld gt 0 then if strmid(gew_pth(0),nld,1) eq dvd then gew_pth(0)=strmid(gew_pth(0),0,nld)

if gew_pth(0) gt ' ' then begin
 gew_pth(0)=gew_pth(0)+dvd
 on_ioerror,misopn
 openw,u,gew_pth(0)+'geo_d_0.web',/get_lun & free_lun,u

    list=findfile(gew_pth(0)+'geo_d_*',count=nn)
    if  nn gt 0 then bid=sys_dep('DELIST',list)

    par1 =''
    if Mach ne '' then begin
	catch,stat
	if stat eq 0 then ii=execute('par1=dial_pad_init_'+(Mach)+'(dummy)') else catch,/cancel
    endif

    WebFTP,/open

    sz=SIZE(par1)
    if  sz(0) lt 2 then ii=execute("par1=dial_pad_init()") & sz=SIZE(par1)
    if (sz(0) eq 2) and (sz(1) eq 5) then begin
	  openw,u,gew_pth(0)+'dial_pad.web',/get_lun
	  printf,u,'# George Instrument PAD'
	  printf,u,'# ',strtrim(string(sz(2)),2),' * 5 entries (label command flag program check)'
	  printf,u,'# First 5 lines for input text, others for buttons'
	  printf,u,'# '
	  for j=0,sz(2)-1 do for i=0,sz(1)-1 do printf,u,par1(i,j)
	  free_lun,u
	  WebFTP, 'dial_pad.web' & endif

 if sys_dep('MACHINE')  eq  'vms' then gew_v=';1' else gew_v=''
 gew_act=100 & gew_snd=['-'] & gew_err='-'
 tvlct,gew_r,gew_g,gew_b,/get
 if    gew_pwd gt ' ' then begin list=findfile(gew_pth(1)+gew_pth(3),count=nn)
				 if  nn gt 0 then bid=sys_dep('DELIST',list)
				 DialInit ,"webon",d=12
				 DialTag  ,"webon",tag="WEBPTH",set=gew_pth(1)+gew_pth(3)
				 DialTag  ,"webon",tag="PWD"   ,set=gew_pwd
				 DialStart,"webon" & endif
 geo_web=1
 WebDo,"sta","on",0
 return
 misopn: ;DialErrMes
endif
gew_pth='' & gew_pwd= ''
end

pro WebOff
;** ******
common c_geo
common c_geweb
if geo_web gt 0 then WebDo,"sta","off",0
geo_web=0
gew_pth='' & gew_pwd= '' & DialClear,"webon" & WebFTP_close
end

pro WebMess, val
;** *******
WebDo, 'log', val, 9
end

pro WebDo, flag, val, dnum, matx
;** *****
common c_geo
common dialshare2
common c_geweb

if geo_web eq 0 then return
on_ioerror,misopn
flg=flag
case flg of
'act':gew_act=100 + 100-val
'err':gew_err=val
'snd':gew_snd=val
'pth':begin   val=gew_pth(0) & return & end
'fil':WebFTP, val
'log':begin fifi='geo_d_'+strtrim(dnum,2)+'Lhtm.web'+gew_v
		openw,u,gew_pth(0)+fifi,/get_lun
		printf,u,'<html><head></head><body><b>'
		if dnum eq 12 then printf,u,'<h3>Command executed:</h3><br>'
		for i=0,n_elements(val)-1 do printf,u,'<nobr>'+val(i)+'<br>'
		printf,u,'</body></html>'  & printf,u,''
		flush,u & free_lun,u
		WebFTP, fifi
      end
;'dws':return ;nfs problem for big files
 else:begin ds=strtrim(dnum,2)			;'gif' 'dws' ('val' 'wks')
       now=systime(1)
       nel=n_elements(geo_timon)-1
       onf=1     &  if dnum gt 0 then ii=execute('onf =d'+ds+'.onoff')
       if (now-geo_timon(nel-dnum) ge 3.) or (flg eq 'val') or (not onf) then begin ;Care 3. le that for history!!!!!!

	freq=0   &  if dnum gt 0 then ii=execute('freq=d'+ds+'.frequency')
	dur =0   &  if dnum gt 0 then ii=execute('dur =d'+ds+'.duration')
	his =0   &  if dnum gt 0 then ii=execute('his =d'+ds+'.history')
	nam ='z' &  if dnum gt 0 then ii=execute('nam =d'+ds+'.name')
	if (not onf) then nam=nam+'_stopped'
	ifopn=0
	dws =flg
	if flg eq 'dws' then begin flg='gif' & if not val then begin DialWSet & geo_act=1 & endif else ifopn=1 & endif
	if flg eq 'gif' then begin r=0       & matx=tvrdd(r,g,b) & endif
	if flg eq 'val' then flg='gif'
	if flg eq 'gif' then if sys_dep('VERSION') ge 5.4 then  flg='png'

	img=n_elements(matx)
	if img gt 1 then $
	   if flg ne 'wks' then begin fifi='geo_d_'+ds+'.'+flg+gew_v
	    if n_elements(r) le 1 then $
	         WRITE_KIF,gew_pth(0)+fifi,matx,gew_r,gew_g,gew_b,transparent=0 $
	    else WRITE_KIF,gew_pth(0)+fifi,matx, r,g,b,transparent=0
	    WebFTP, fifi, IFOPN=ifopn
	   endif
	if dws eq 'dws' then flg=dws

	fifi='geo_d_'+ds+'.web'+gew_v
	openw,u,gew_pth(0)+fifi,/get_lun
	printf,u, nam,gew_act,geo_freq,geo_lim
	printf,u, freq,dur,his,' '+flg
	printf,u, val
	if gew_err    ne '' then begin printf,u,'err:'+gew_err & gew_err=''   & endif
	if gew_snd(0) ne '' then begin printf,u,'snd:'+gew_snd & gew_snd=[''] & endif
	flush,u & free_lun,u
	WebFTP, fifi, IFOPN=ifopn

       endif
      end
endcase
misopn:
end
;************************************ END WEB MODULES *************************
;************************************ END WEB MODULES *************************

pro P_GEO_EVENT, ev, uv
;** ***********
;**
;** Widget events handler
@lamp.cbk
common c_geo

if uv(1) eq 667 then begin geo_stat  =ev.select  & uv(1)=666                        ;on/off General
                           geo_w(8,*)=0 & endif
case uv(1) of
	614: begin                                                                  ;Mad command
		widget_control,uv(3),bad_id=ii,get_value=comm
		comm=strtrim(comm(0),2)
		if strpos(strupcase(comm),'CTRL:') ne 0 then comm='Ctrl:'+comm
		XICUTER,comm
	     end
	660: if geo_act ne ev.select then begin geo_act=ev.select                   ;plot Activity
	        if geo_act gt 0 then P_GEO_DISPLAY,did_win0,0,0 $
			        else P_GEO_DISPLAY,did_win0,1,0
	     endif
	665: DialTag, d=uv(2), tag='ONOFF', set=ev.select                           ;on/off on Dials
	666: begin                                                                  ;Change frequency ?
		widget_control,uv(2),get_value=bid
		on_ioerror,mis666
		geo_freq=(float(bid(0))>0.) & duduch1=geo_freq
		bid=0
		widget_control,uv(4),get_value=bid,bad_id=ii                        ;Change duration  ?
		on_ioerror,misbid
		geo_lim =(float(bid(0))>0.) & duduch2=geo_lim & misbid:
                geo_timon(0)=systime(1)*1000
		P_GEO_TIMER, {id:uv(3)}
		mis666:
	     end
	670: begin case uv(2) of
	     1:  begin dnum=uv(3)                                                   ;Reset
	               pth   =''   & DialTag,d=dnum,tag="PATH"  ,get=pth
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               origin=''   & DialTag,d=dnum,tag="ORIGIN",get=origin
	               DialInit, origin, d=dnum, path=pth ,new=named
	                            DialTag,d=dnum,tag="ONOFF",set=onoff
	               end
	     2:  DialTag,d=uv(3),tag="HISTORY",set=0                                ;History off
	     3:  DialTag,d=uv(3),tag="HISTORY",set=1                                ;History on
	     4:  begin DialTag,d=uv(3),tag="NAME",get=named                         ;Clear history file
	               bid=sys_dep('DELET',"dial_"+named+".his")
	               end
	     5:  begin dn=uv(3) & dw=geo_w(13,dn)                                   ;large dial
		       keep_w=!D.window
	               if dw gt 0 then begin ii=execute('wset,dw')
	                                     if ii ne 1  then dw=0 else wshow,dw & endif
	               DialTag,d=uv(3),tag="WUPDATE",get= wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=(wupd<1)

	               if dw le 0 then begin DialTag,d=dn,tag="NAME" ,get=named
		                               if geo_w(1,dn) gt 0 then P_GEO_DISPLAY, 'Large '+named,geo_w(1,dn),-1
	                                     WINDOW,xsize=geo_bxy(0)*2,ysize=geo_bxy(1)*2,title=named,/FREE
	                                     dw=!D.Window & endif
	               geo_w(13,dn)=dw
		       if keep_w gt 0 then wset,keep_w
	         end
	     6:  begin di=strtrim(string(uv(3)),2)                                  ;Properties list
	               tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
		       if geo_lead gt 0 then begin b0=widget_base(title="Dial "+di+" properties",resource_name="lamp")
						   b1=widget_base(b0,/column,resource_name="geo") & endif
	               for k=0,n_elements(tlist)-1 do begin
			   DialTag,d=uv(3),tag=tlist(k),get=V & tag='d'+di+'.'+tlist(k)
	                   CASE tlist(k) of
	                   'ERROR':
	                   'PROX':
	                   'PROS':
	                   'PWD':
	                    ELSE:   if geo_lead gt 0 then begin sz=SIZE(V)
			    		if sz(sz(0)+1) eq 8 then V='is a structure' $
			    		else if sz(sz(0)+2) gt 1 then begin  V=strtrim(string(sz(1)),2)
							if sz(0) gt 1 then V=V+','+strtrim(string(sz(2)),2)
							if sz(0) gt 2 then V=V+','+strtrim(string(sz(3)),2)
							if sz(0) gt 3 then V=V+',..'
							V='size('+V+')'
					endif else      V= strtrim(string(V(0)),2)
			    		b2=widget_base (b1,/row)
					bb=widget_label(b2,value=tag+"=",font=ft_b_normal)
					bb=widget_label(b2,value=V      ,font=ft_b_normal)
				    endif else print, tag+'= ',V
	                   ENDCASE
	               endfor
		       if geo_lead gt 0 then widget_control,b0,group_leader=geo_lead,/realize
	         end
	     7:  if ev.TYPE eq 0 then begin
	               di=strtrim(string(uv(3)),2) & N=0 & wupd=0				;plot in main window
	               geo_info(5)=did_win0							;case main window changed
	               DialTag,d=uv(3),tag="WUPDATE",get=wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=2
	               ii=execute('N=n_elements(D'+di+'.VALUE)')
	               if N  gt 1 then begin
	                  DialTag,d=uv(3),tag="XVALUE",get=XX
	                  DialTag,d=uv(3),tag="YVALUE",get=YY
	                  ii=execute('P_GEO_DISPLAY, D'+di+', D'+di+'.VALUE, error=D'+di+'.ERROR, X=XX, Y=YY')
	               endif
	               if ev.PRESS eq 2 then DialTag,d=uv(3),tag="WUPDATE",set=1 ;middle
	               if ev.PRESS eq 1 then DialTag,d=uv(3),tag="WUPDATE",set=0 ;left
		 endif
	     8:        DialClear,d=uv(3)                                            ;Remove the dial
	     else:
	     endcase
	     if (uv(2) ge 80) and (uv(2) le 95) then begin
			widget_control,ev.id,get_value=fq & DialTag,d=uv(3),tag="FREQUENCY",set=float(fq(0))
			;widget_control,uv(4),set_value='Own Frequency='+fq
			DialTag,d=uv(3),tag="ONOFF",get=V & if V eq 1 then DialTag,d=uv(3),tag="ONOFF",set=1
	     endif
	     end
	671: begin  DialTag,d=uv(3),tag="PLOT",set=uv(2)
	            if uv(2) eq -2 then if geo_w(1,uv(3)) gt 0 then P_GEO_DISPLAY,'no Plot',geo_w(1,uv(3)),-1, DNUM=uv(3)
	     end
	else:
endcase
end

pro P_GEO_TIMER, ev
;** ***********
;**
;** Timer handler

common dialshare2
common c_geo

begtim=systime(1)
if ev.id eq geo_onbas(3) then begin
;  GENERAL TIMER
   if geo_lim gt 0  then if (begtim*1000 - geo_timon(0) gt geo_lim*1000) then DialsFrequency,/STOP
   if geo_stat      then begin
	 P_GEO_RETIM ,ev.id, geo_freq
	 Pn=((size(geo_w))(2))-1
	 dnum =0
	 R    =1
	 for i=1,Pn do if geo_w(6,i) eq 1 then begin

	   di   =strtrim(string(i),2)
	   onoff=0 & ii=execute('if n_tags(d'+di+') gt 1 then onoff=d'+di+'.ONOFF else geo_w(6,i)=0')
	   if onoff then begin
	    freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    if   freq le 0 then begin
	      if dnum eq 0 then P_GEO_STATUS, 0,"Loop",begtim  else   R=DIALON(d=(i+0))

	      if geo_stat  then if R then begin dnum=i
	                                        P_GEO_STATUS, dnum, "This" ,2
		                                DIALMACRO,  d=dnum, Si=di
	    					freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    					if freq gt 0 then P_GEO_RETIM ,geo_w(11,dnum), freq
	      endif
	    endif else if abs(geo_w(12,i)) eq 2 then  DialStart,d=(i+1-1)
	   endif else geo_w(8,i)=0
	 endif
	 if   dnum  gt 0   then P_GEO_STATUS, (geo_freq+0), "EndL" ,begtim
	 totim=geo_freq-(systime(1)-begtim)
	 if totim lt 0 then if geo_freq gt 0 then P_GEO_RETIM ,ev.id, totim ;GIVE TIME FOR OTHERS.
   endif
endif else begin

;  SPECIFIC TIMER
   widget_control,ev.id,get_uvalue=dnum
   di   = strtrim(string(dnum),2)
   freq = 0 & ii=execute('freq =d'+di+'.FREQUENCY')
   durat= 0 & ii=execute('durat=d'+di+'.DURATION')
   if durat gt 0 then if (begtim*1000 - geo_timon(dnum) gt durat*1000) then DialStop, d=dnum
   onoff= 0 & ii=execute('onoff=d'+di+'.ONOFF')
   if freq gt 0 then if onoff then begin
		P_GEO_RETIM ,ev.id,  freq
		P_GEO_STATUS, 0   , "Loop", begtim
		P_GEO_STATUS, dnum, "This" ,1
		DIALMACRO  ,d=dnum, Si=di
		P_GEO_STATUS, freq, "EndL" ,begtim
		fruq=freq & ii=execute('freq =d'+di+'.FREQUENCY')
		if freq ne fruq then P_GEO_RETIM ,ev.id,  freq $
		else begin
		  totim=(geo_freq*geo_stat)+freq - (systime(1)-begtim)
		  if totim lt 0 then P_GEO_RETIM ,ev.id, totim              ;GIVE TIME FOR OTHERS.
		endelse
   endif    else geo_w(8, dnum)=0
endelse
end

pro P_GEO_RETIM, id,freq
;** ***********
;**
;** RE-TIMER
			widget_control,bad_id=ii,id,/CLEAR_EVENTS
if freq gt 0 then	widget_control,bad_id=ii,id, TIMER=freq	else $
if freq lt 0 then	widget_control,bad_id=ii,id, TIMER=0.05<(-freq)
end

pro P_GEO_STATUS, dnum, way , flgtim
;** ************
;**
;** Display a scheme for the timer process

common dialshare2
common c_lamp_info
common c_geo
common c_geweb
common c_geostat,kpstr

if way eq "Loop" then       geo_seq=flgtim
if way eq "This" then       geo_w(12,dnum)=flgtim
if geo_isw then begin

   if geo_act eq 0 then begin keep_w=!D.window & wset,did_win0
   case way of

	"Loop":
	"This":     begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	            end

	"Get":      begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	                  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=120
	            end

	"GetOk":          plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0

	"GetNone":  begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Bad new Value !!!'
			  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0
	            end

	"Send":     begin if dnum gt 0 then $
			   if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
			  plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=120
	            end

	"SendOk":   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0

	"SendNone": begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Send Control error-code !!!'
			   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0
	            end

	"EndL":     begin device,copy=[0,0      ,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
	                  geo_info(4)= 0
				idx=where(geo_w(8,*) gt 0)
				totim= ((systime(1)-flgtim)*1000+geo_w(9,0))>1
				now  =   systime(1)
				if idx(0) ge 0 then begin
				   for i= 0,n_elements(idx)-1 do if geo_w(12,idx(i)) gt 0 then begin

				       j=idx(i)
				       geo_w(8 ,j)=(geo_w(8 ,j)*100./totim)>1
				       geo_w(9 ,j)=(geo_w(9 ,j)*100./totim)
				       geo_w(10,j)=(geo_w(10,j)*100./totim)
				       geo_w(12,j)=-geo_w(12,j)

				       endif else geo_w(8:10)=1

				   P_GEO_DISPLAY, idx ,dnum,totim
				   if geo_web then begin
				      if dnum gt 0 then ppm=long(dnum*1000*100./totim)<100 else ppm=100
				      WebDo,'act',ppm
				      endif
				endif
				device,copy=[0,0,geo_info(0)/2+30,geo_info(1)*2/3,geo_info(0)/2-32,geo_info(1)/3-2,geo_alp(4)]
				geo_w(9,0) =(systime(1)-now)*1000
	            end
	else:
	endcase
	if keep_w gt 0 then wset,keep_w

   endif else if geo_act gt 0 then begin di=string(dnum)
   case way of

	"Loop":      kpstr=''
	"This":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	                    di=strtrim(di,2) &  name="" & ii=execute('name=d'+di+'.NAME')
						wupd="" & ii=execute('wupd=d'+di+'.WUPDATE')
	             if wupd gt 0 then sws='W' else sws='D'
	             if wupd ge 0 then begin kpstr=kpstr+' ('+sws+di+')'+name
	             widget_control,l_message,bad_id=ii,set_value='............ Dial '+name+' running ...'
		     endif & endif
		     end
	"Get":      ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' requesting ...'
	"GetOk":    ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"GetNone":  ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad request !!!'
	"Send":     ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' sending control ...'
	"SendOk":   ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"SendNone": ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad control !!!'
	"EndL":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	               if kpstr gt ' ' then begin
	                  totim= ((systime(1)-flgtim)*1000)>1
	                  ppm  =long(dnum*1000*100./totim)
	                  if ppm lt 100 then miss=' mis:'+string(long(totim-dnum*1000)/1000.)+' sec' else miss=''
	                  widget_control,l_message,bad_id=ii,set_value=kpstr+string(ppm<100)+'%'+miss
	                  if geo_web then WebDo,'act',ppm<100
                       endif
	             endif
		     end
	else:
   endcase
   endif
endif
end

pro P_GEO_DISPLAY, D, W ,totim  ,error=E ,X=XXX ,Y=YYY ,histo=histo ,DNUM=dnum
;** *************
;**
;** Dial   display -> D=dial      ,  W=workspace
;** Scheme display -> D=dial index,  W=frequence,  totim= time
;** Backgr display -> D=did_win0  ,  W=big arrow,  totim= 0
;** Backgr reset   -> D=did_win0  ,  W=1        ,  totim= 0
;** Backgr erase   -> D=did_win0  ,  W=0        ,  totim= 0
;** di     xyouts  -> D=di        ,  W=winID    ,  totim=-1
;** Dial big name  -> D=name      ,  W=dnum     ,  totim=-2
;** c_did  info    -> D=return [] ,  W=0        ,  totim=-3

common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common c_draw ; rx,rz,nlv,styles(0,0),styles(1,0)
common c_did  ;[did_x,did_y,did_wd]
common c_geo
common c_geweb

	keep_w=!D.window
	if n_elements(totim)  eq 0 then begin

			dw  =geo_w(13,D.NUMBER)
			if  (D.WUPDATE eq 2)  then begin if dw gt 0 then              ii=execute('wdelete,dw')
							 dw=geo_info(5)
							 geo_w(13,D.NUMBER)=0       & ii=execute('wset   ,dw')
			endif else if dw gt 0 then begin ii= execute('wset, dw')    & if ii ne 1  then    dw=0
							 geo_w(13,D.NUMBER)=dw      & endif
			trap_current=dw
			stime=strmid(!stime,12,8)
			sz =SIZE(W) & upl=D.UPPERLIM & lwl=D.LOWERLIM
			if sz(sz(0)+2) eq 1 then begin
			   if (D.PLOT le 0) or (upl le lwl) or (dw gt 0) then begin
				if  (dw le 0) or (geo_web) then begin
				     wset,geo_alp(1) & erase
				     xyouts,3,3,strtrim(string(W(0)),2), charsize=1.,/device
				     xyouts,3,geo_bxy(1)-10,D.NAME     , charsize=1.,/device
				     wset  ,geo_w(1,D.NUMBER)
				     device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				     if geo_web then WebDo,'gif',W(0),D.number
				     endif
				if  (dw gt 0) then begin
				     if geo_web then wset,dw & erase
				     xyouts,9,9,strtrim(string(W(0)),2), charsize=3.,charthick=3,font=-1,/device
				endif
			   endif else begin
				wset,geo_w(1,D.NUMBER)
				on_ioerror,notan & res=0
				res=fix(float(upl-W(0))/(upl-lwl) * geo_bxy(0))
				device,copy=[res,0,geo_bxy(0),geo_bxy(1)-3,0,3,geo_alp(0)]
				notan: if res eq 0 then erase
				xyouts,3,geo_bxy(1)-23,strtrim(string(W(0)),2),charsize=1.,/device
			        xyouts,3,geo_bxy(1)-10,D.NAME,charsize=.6,/device
				if geo_web then WebDo,'gif',W(0),D.number
			   endelse

			endif else if sz(0) eq 1 then begin
			   if n_elements(xxx) ne sz(1) then xxx=indgen(sz(1))
			   if keyword_set(histo) then velu=       strtrim(string(W(sz(1)-1)),2) $
			   		   else begin mox =max(W) & velu= 'Max:'  +strtrim(string(mox),2)     + $
					   				  ' at X:'+strtrim(string(xxx(!C)),2)
					   endelse
			   if (dw le 0) or (geo_web)   then begin
			      wset,geo_alp(1)
			      if upl le lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1,yrange=[lwl,upl]
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,D.NAME+'='+velu+'  ',charsize=.6,/device $
			                       else xyouts,3,geo_bxy(1)-10,velu+'      '       ,charsize=.6,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				if geo_web then WebDo,'gif',W(n_elements(W)-1),D.number
				endif
			   if (dw gt 0)  then begin
				if geo_web then wset,dw
			      erase
			      velu=velu+' Updated:'+stime
			      if n_elements(E) eq n_elements(W) then sym=4 else sym=10
			      if upl le lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,yrange=[lwl,upl],$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if n_elements(E) eq n_elements(W) then errplot,xxx,W-E,W+E
			   endif

			endif else if sz(0) eq 2 then begin
			   if (n_elements(xxx) ne sz(1)) and (n_elements(xxx) ne sz(1)*sz(2)) then xxx=indgen(sz(1))
			   if (n_elements(yyy) ne sz(2)) and (n_elements(yyy) ne sz(1)*sz(2)) then yyy=indgen(sz(2))
			   congw='w' & congx=',xxx' & congy=',yyy' & qq=128L
			   if upl gt lwl then congw='w>lwl<upl'
			   if (sz(sz(0)+2) gt qq*qq) and (D.PLOT ne 0) then begin
			   	                                 congw= 'congrid('+congw+',qq<sz(1),qq<sz(2))'
			   	if n_elements(xxx) eq sz(1) then congx=',congrid(xxx,qq<sz(1))'          else $
								 congx=',congrid(xxx,qq<sz(1),qq<sz(2))'
			   	if n_elements(yyy) eq sz(2) then congy=',congrid(yyy,qq<sz(2))'          else $
								 congy=',congrid(yyy,qq<sz(1),qq<sz(2))'
			   endif
			   if D.PLOT eq 0 then mmx=max(W)
			   if (dw le 0) or (geo_web)  then begin
			      wset,geo_alp(1)
			      if D.PLOT eq 0 then begin
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',geo_bxy(0),geo_bxy(1))+1)>1)') $
					       else ii=execute('tvscl,      CONGRID('+congw+',geo_bxy(0),geo_bxy(1))      ')
			      endif else $
			      if D.PLOT ne 2 then ii=execute($
				'shade_surf,'+congw+congx+congy+',xstyle=4,ystyle=4,zstyle=4,xmargin=[0,0],ymargin=[0,0],az=rz,ax=rx') $
			                      else ii=execute($
				'contour,'   +congw+congx+congy+',xstyle=4,ystyle=4,/fill   ,xmargin=[0,0],ymargin=[0,0],nlevels=nlv')
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,    D.NAME,    charsize=1.,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
			      if geo_web then WebDo,'gif',0,D.number
			      endif
			   if (dw gt 0) then begin
			   	titil=D.NAME+' updated:'+stime
				if geo_web then wset,dw
			      ;sxx=[1,round(sz(1)/4),round(sz(1)/2),round(sz(1)*3/4),sz(1)] & sxx=strtrim(string(sxx),2)
			      ;syy=[1,round(sz(2)/4),round(sz(2)/2),round(sz(2)*3/4),sz(2)] & syy=strtrim(string(syy),2)
			      if D.PLOT eq 0 then begin
				dxsiz=!D.x_size & xo=40 & xf=10
				dysiz=!D.y_size & yo=40 & yf=20
				if (sz(1) eq sz(2)) and (D.WUPDATE eq 2) then begin
				   if dxsiz gt dysiz then dxsiz=dysiz else dysiz=dxsiz
				endif
				erase
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf)+1)>1),xo,yo') $
					       else ii=execute('tvscl,     (CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf))     ,xo,yo')
				ii=execute('plot,W,charsize=1.2 ,xrange=[xxx(0),xxx(sz(1)-1)],yrange=[0,sz(2)-1]'+$
				           ',/nodata,position=[xo,yo,dxsiz-xf-1,dysiz-yf-1],/noerase,/device,title=titil')
			      endif else $
			      if D.PLOT ne 2 then begin
				surfbody=congw+congx+congy+',az=rz,ax=rx,xticks=4,yticks=4,zticks=1,title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
			 	surfkey ='' & surf='surface,'
				if styles(0,0) eq 4 then surfkey =''             else $
				if styles(0,0) eq 5 then surfkey =',/lego'       else $
				if styles(0,0) eq 6 then surfkey =',/horizontal'      $
				                    else surf    ='shade_surf,'
				ii=execute( surf+surfbody+surfkey )
			      endif else begin
				surfbody=congw+congx+congy+',xticks=4,yticks=4,zticks=2,xmargin=[10,1],ymargin=[4,2],title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
				surf    ='contour,'
				if styles(1,0) ne 1 then surfkey =',/fill,nlevels=nlv' $
				                    else surfkey =',c_colors=(indgen(nlv)+1)*(180/nlv)+50,nlevels=nlv'
				ii=execute( surf+surfbody+surfkey )
			      endelse
			   endif
			endif

	endif else if totim gt 0 then begin

		if W gt 0 then ppm=long(W*1000*100./totim)<100 else ppm=100
		wset,geo_alp(4) & trap_current=geo_alp(4)
		nk =n_elements(D)
		YYt=reform(geo_w(8 ,D))
		YYl=reform(geo_w(10,D))
		YYm=reform(geo_w(9 ,D))+YYl

		if  nk eq 1 then begin
		    YYt=[YYt,0] & YYm=[YYm,0] & YYl=[YYl,0] & D=[D,0] & endif
		sx ='d'+strtrim(string(D),2)
		if  nk eq 1 then begin nk =2  & sx(1)='  '  & endif
		ttl=    strtrim(string(round(totim/10.)/100.),2)+' Elapse sec.'

		if nk gt 8 then begin
		plot, YYl,xmargin=[2,2],ymargin=[2,2],charsize=.8,font=0,yrange=[0,100],$
		          psym=10,xticks=nk-1,xtickname=sx,title=ttl,ystyle=4,xthick=2,linestyle=1

		oplot,YYm,psym=10,linestyle=2
		oplot,YYt,psym=10,linestyle=0
		if ppm lt 100 then begin YYl(*)=ppm & oplot,YYl,thick=2 & endif

		endif else begin
		YP =[[YYl],[YYm],[YYt]]
		sy =['Command    ','Request  ','Macro']
		sz =[ ' ' , strtrim(string(ppm),2)+'%' ]
		w4d=bytscl(YP,min=0,max=100)>20
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],xticks=nk-1,xtickname=sx,shades=w4d,$
		        title=ttl,/lego,charsize=1.2,font= 0,yticks=2,ytickname=sy,zticks=1,ztickname=sz

		if ppm lt 100 then begin
		YP(*)=ppm
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],/lego,/noerase,$
		        xstyle=4,ystyle=4,zstyle=4,charsize=1.2,font= 0
		endif
		endelse

	endif else if totim eq 0 then begin
		if n_elements(w) gt 1 then begin
		    wset,geo_alp(4) & erase
		    wset,geo_alp(3) & erase
		    wset,geo_alp(0) & erase & tv,W
		endif else begin
		 wset,D
		 if (n_elements(w) eq 1) and (w(0) le 0) then begin
		 ;if w(0) eq 0 then did_fu=0 else did_fu=1
		 endif else begin
		  erase
		 ;did_fu=1
		  inf=2.4
		  eng=sys_dep('MACHINE') & if (eng eq 'win') then inf=3. else if (eng eq 'mac') then inf=1.5
		  geo_info(3)= geo_info(1)-geo_bxy(1)-10
		  geo_info(2)= geo_info(0)-geo_bxy(0)-10
		  wdt=20 & cz=(geo_info(0)/341.33*2) & ct=round(cz) & cz=cz<inf
		  xyouts,wdt-4,14,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,13,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,10,"Values REQUEST ",font=-1,charsize=cz,charthick=ct,/device,color=255,width=wdt
		  wdt=geo_info(0)*wdt
		  wdt=geo_info(0)-1-wdt-20
		  xyouts,wdt-4,44,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,43,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,40,"COMMAND Control",font=-1,charsize=cz,charthick=ct,/device,color=255

		  xf1=(geo_info(0)*2/3) - ((geo_info(0)*2/3)-(geo_bxy(0)/2+20))/4
		  xf2=(geo_info(0)  /3) - ((geo_info(0)  /3)-(geo_bxy(0)/2+20))/4
		  yf1=70 + ((geo_info(3)-10)-(70))/4
		  yf2=40 + ((geo_info(3)-10)-(40))/4
		  plots,[xf1,geo_info(0)*2/3], [yf1,70],thick=2.,/device,color=255
		  plots,[xf2,geo_info(0)  /3], [yf2,40],thick=2.,/device,color=255
		 endelse
		endelse
	endif else if totim eq -1 then begin

		wset,W   &  erase
		xyouts,3,geo_bxy(1)-9,D,charsize=1,/device
		if n_elements(dnum) eq 1  then dw  =geo_w(13,dnum) else dw=0	    ;Delete the large Dial plot.
		if dw gt 0 then begin ii=execute('wdelete,dw')  & geo_w(13,dnum)=0 & endif

	endif else if totim eq -2 then begin

		wset, geo_alp(3)
		device,copy=[0,0, geo_bxy(0),geo_bxy(1)/2, 0,W*25]
		xyouts,0,W*25+1, D ,font=-1,charsize=1.5,charthick=2,/device,color=255

	endif else if totim eq -3 then D=[did_x,did_y,did_wd]

	if keep_w gt 0 then wset,keep_w
end

function P_GEO_Ndials & return,20 & end
;******* ************

pro GEORGEO, init=init, construct=base, timer=bs1, freq=freq, command=intxt, nowin=nowin, lim=lim, duduch=prox
;** *******
;**
;** Construct the base then initiate george (lamp startup)
;** handle a command line for instrument control (from dons)

@lamp.cbk
common c_geo
common c_geweb

	if n_elements(intxt) eq 1 then begin
	   comm=strtrim(intxt,2)
	   if strpos(strupcase(comm),'CTRL:') eq 0 then begin intxt=';' & ln=strlen(comm)
	   		comm=strmid(comm,5,ln)
			typ='PAD' & gen=geo_par2(3)
			if (geo_par2(4) eq '1') then check=1 else check=0
			if strpos(comm,'G:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								gen  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								typ  ='WEB'        & endif
			if strpos(comm,'T:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								typ  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								endif
			if strpos(comm,'K:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								check=strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								on_ioerror,mischk  & check=float(check)
								mischk:            & endif
			comm=str_sep(comm, '<br>') & if n_elements(comm) eq 1 then comm=comm(0)

			d0={GENERIC:gen,NAME:geo_par2(0),TYPE:typ,PROS:long(geo_par2(5:6))} & R=0
			R = DialControl(comm,   d=0, check=check)
			if (R lt 0) or (R gt 1)    then begin print,'error-code '+string(R)
					if geo_web then WebDo,'err','error-code '+string(R) & ENDIF
	   endif
	   return
	endif else $
	if n_elements(base) eq 1 then begin
	   Pn     =P_GEO_Ndials()
	   geo_w  =lonarr(14,Pn+1)
	   geo_vis=Pn/2 -Pn/10
	   geo_bxy=[100,50]
	   if n_elements(geo_freq) eq 0 then begin geo_freq=0 & geo_lim=0 & endif
	   bid=widget_button(base,font=ft_biggest,value='....GET DIALS....',uvalue=[-88,380,0],resource_name="geo")
	   bas=widget_base (base,/column,y_scroll=fix(lamp_siz/2.1)<395)
	   for i=1,((size(geo_w))(2))-1 do begin
		di=strtrim(string(i),2)
		if sys_dep('VERSION') lt 4.0 then bod=widget_base(bas,/column) $
		else bod  =widget_base  (bas,/column,xsize=110)
		bud       =widget_base  (bod,/row)

		if i le geo_vis+4 then begin
	 	  byd     =widget_button(bud,value='d'+di                       ,font=ft_b_normal,menu=2,resource_name="geo")
			bed3   =widget_button(byd ,value='Large Dial'		,font=ft_normal,uvalue=[-88,670,5,i])
			bed1   =widget_button(byd ,value='Reset'		,font=ft_normal,uvalue=[-88,670,1,i])
			bed4   =widget_button(byd ,value='Properties'		,font=ft_normal,uvalue=[-88,670,6,i])
			bed8   =widget_button(byd ,value='Remove'		,font=ft_normal,uvalue=[-88,670,8,i])
			bed2   =widget_button(byd ,value='History is off'	,font=ft_normal,menu=2)
			  bed21=widget_button(bed2,value='Stop recording'	,font=ft_normal,uvalue=[-88,670,2,i])
			  bed22=widget_button(bed2,value='Start recording'	,font=ft_normal,uvalue=[-88,670,3,i])
			  bed23=widget_button(bed2,value='Clear History file'	,font=ft_normal,uvalue=[-88,670,4,i])
			if i le geo_vis  then begin
			bed5   =widget_button(byd ,value='Change Plot'		,font=ft_normal,menu=2)
			  bed51=widget_button(bed5,value='-2 (no plot)'         ,font=ft_normal,uvalue=[-88,671,-2 ,i,bed5])
			  bed51=widget_button(bed5,value='-1 (in W'+di+')'      ,font=ft_normal,uvalue=[-88,671,-1 ,i,bed5])
			  bed51=widget_button(bed5,value=' 0 (scalar,image)'    ,font=ft_normal,uvalue=[-88,671,0  ,i,bed5])
			  bed51=widget_button(bed5,value=' 1 (arrow,surface)'   ,font=ft_normal,uvalue=[-88,671,1  ,i,bed5])
			  bed51=widget_button(bed5,value=' 2 (contour)'         ,font=ft_normal,uvalue=[-88,671,2  ,i,bed5])
			  bed51=widget_button(bed5,value='10 (vector)'          ,font=ft_normal,uvalue=[-88,671,10 ,i,bed5])
			  bed51=widget_button(bed5,value='20 (  ..  )'          ,font=ft_normal,uvalue=[-88,671,20 ,i,bed5])
			  bed51=widget_button(bed5,value='30'                 ,font=ft_normal,uvalue=[-88,671,30 ,i,bed5])
			  bed51=widget_button(bed5,value='50'                 ,font=ft_normal,uvalue=[-88,671,50 ,i,bed5])
			  bed51=widget_button(bed5,value='100'                ,font=ft_normal,uvalue=[-88,671,100,i,bed5])
			  bed51=widget_button(bed5,value='200'                ,font=ft_normal,uvalue=[-88,671,200,i,bed5])
			  bed51=widget_button(bed5,value='500'                ,font=ft_normal,uvalue=[-88,671,500,i,bed5])
			bed6   =widget_button(byd ,value='Own Frequency'      ,font=ft_normal,menu=2)
			  bed61=widget_button(bed6,value='0.00'               ,font=ft_normal,uvalue=[-88,670,80,i,bed6])
			  bed61=widget_button(bed6,value=' .1 '               ,font=ft_normal,uvalue=[-88,670,81,i,bed6])
			  bed61=widget_button(bed6,value=' .5 '               ,font=ft_normal,uvalue=[-88,670,82,i,bed6])
			  bed61=widget_button(bed6,value='1   '               ,font=ft_normal,uvalue=[-88,670,83,i,bed6])
			  bed61=widget_button(bed6,value='2   '               ,font=ft_normal,uvalue=[-88,670,84,i,bed6])
			  bed61=widget_button(bed6,value='4   '               ,font=ft_normal,uvalue=[-88,670,85,i,bed6])
			  bed61=widget_button(bed6,value='10  '               ,font=ft_normal,uvalue=[-88,670,86,i,bed6])
			  bed61=widget_button(bed6,value='30  '               ,font=ft_normal,uvalue=[-88,670,87,i,bed6])
			  bed61=widget_button(bed6,value='60  '               ,font=ft_normal,uvalue=[-88,670,88,i,bed6])
			  bed61=widget_button(bed6,value='240 '               ,font=ft_normal,uvalue=[-88,670,89,i,bed6])
			  bed61=widget_button(bed6,value='600 '               ,font=ft_normal,uvalue=[-88,670,90,i,bed6])
			  bed61=widget_button(bed6,value='1800'               ,font=ft_normal,uvalue=[-88,670,91,i,bed6])
			  bed61=widget_button(bed6,value='3600'               ,font=ft_normal,uvalue=[-88,670,92,i,bed6])
			endif
		endif
		bidof=0
		if (i eq geo_vis+5) and (GEORGE eq 2) then begin
		 cap=0
		 eng=sys_dep('MACHINE') & if eng eq 'win' then cap=3 else if eng eq 'mac' then cap=-2

		 bs1_t =widget_label (bod,font=ft_b_normal,value ='General Freq.' , event_pro='P_GEO_TIMER')
		 bs1_f =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_freq),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bod,font=ft_b_normal,value='Duration:')
		 bs1_d =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_lim ),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bact  =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='no plot,resource_name="geo"')
		 widget_control,bact ,set_uvalue=[-88,660,0,0],set_button=1
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
		if i le geo_vis+4 then $
		   bidof  =widget_button(widget_base(bud,/nonexclusive),uvalue=[-88,665,i],$
						     value='on/off',font=ft_smaller)

		bedou     =widget_label (bud,value="", event_pro='P_GEO_TIMER',uvalue=i)

		geo_w(2 ,i)=bud
		geo_w(3 ,i)=bidof
		geo_w(4 ,i)=byd	;not used at this time!
		geo_w(7 ,i)=bed2
		geo_w(11,i)=bedou
		widget_control,bud  ,sensitive=0
		if i le geo_vis then geo_w(0,i)=widget_draw (bod,retain=2,xsize=geo_bxy(0),ysize=geo_bxy(1),$
							     /button_events,uvalue=[-88,670,7,i])
	   endfor

	endif else $
	if n_elements(bs1)  eq 1 then begin
		eng=sys_dep('MACHINE')
		if eng eq 'win' then begin cap= 3 & scheme=' SCHEME'        & reffre=' frequency:' & dur='Duration:'
		endif           else $
		if eng eq 'mac' then begin cap=-2 & scheme='SCHEME'         & reffre='freq:'      & dur='for:'
		endif           else begin cap= 0 & scheme=' SCHEME'        & reffre='frequency:' & dur='Duration:' & endelse

		if n_elements(lim)  eq 1 then geo_lim =lim  else geo_lim =0
		if n_elements(freq) eq 1 then geo_freq=freq else geo_freq=0
		vaf=strtrim(string(geo_freq),2) & vaf =" 0 "  &  geo_freq=0
		vad=strtrim(string(geo_lim ),2) & if geo_lim le 0 then vad=" "
		geo_onbas=[0L,0L,0L,0L]
		if GEORGE eq 1 then begin
		 bs1_1 =widget_label (bs1,font=ft_biggest ,value = scheme)
		 bs1_t =widget_label (bs1,font=ft_b_normal,value = reffre , event_pro='P_GEO_TIMER')

		 bs1_f =widget_text  (bs1,font=ft_propor  ,value=vaf,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_label (bs1,font=ft_smallest,value='seconds')
		 bs1_1 =widget_button(widget_base(bs1,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bs1,font=ft_normal  ,value='Duration:')
		 bs1_d =widget_text  (bs1,font=ft_propor  ,value=vad,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")

		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]

		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
	endif else $
	if n_elements(prox)  gt 1 then begin
		geo_par2=prox
		SetDuduch,"_send", geo_par2(3,0), prox
		geo_par2=[geo_par2,string(prox)]
	endif else $
	if keyword_set(init) then begin
		setcol,27
		geo_info =lonarr(6)
		P_GEO_DISPLAY, info,0 ,-3                      ;return [did_x,did_y,did_wd]
		geo_info(0)  = info(0) & geo_info(1)=info(1)   ;r=widget_info(did_wd,/geometry)
		geo_info(5)  = did_win0
		P    =geo_bxy(0)   & N=geo_bxy(1)/2
		for i=1,((size(geo_w))(2))-1 do   begin
		    if geo_w(0,i) gt  0  then begin
			   widget_control,bad_id=ii,geo_w(0,i),get_value=j
			   geo_w(1,i)=j
			   di=strtrim(string(i),2)
			   P_GEO_DISPLAY, 'd'+di, j ,-1
		    endif
		endfor
		geo_alp =lonarr(5)
		bid  =widget_base(map=0)
	        geo_alp(0)=widget_draw(bid,retain=2,xsize=2*P,ysize=2 *N)
	        geo_alp(1)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(2)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(3)=widget_draw(bid,retain=2,xsize=  P,ysize=21*N)
	        geo_alp(4)=widget_draw(bid,retain=2,xsize=geo_info(0)/2+30,ysize=geo_info(1)*2/3)
		widget_control,bid,group_leader=lamp_b1,/realize
		widget_control,geo_alp(0),get_value=j & geo_alp(0)=j
		widget_control,geo_alp(1),get_value=j & geo_alp(1)=j
		widget_control,geo_alp(2),get_value=j & geo_alp(2)=j
		widget_control,geo_alp(3),get_value=j & geo_alp(3)=j
		widget_control,geo_alp(4),get_value=j & geo_alp(4)=j
		bid=bindgen(P)*2+55
		bis=bytarr(P,N)  & for i=0,n-1,2 do bis(0,i)=bid
		bid=reverse(bid) & for i=1,n-2,2 do bis(0,i)=bid
		bis=bytscl (bis)
		for i=0,N-1 do bis(P-1-abs((N-1)/2-i)/2:P-1,i)=253*0

		P_GEO_DISPLAY, did_win0, bis ,0

		if GEORGE eq 1 then geo_act=0 else geo_act=1
		if GEORGE eq 1 then P_GEO_DISPLAY, did_win0, 1 ,0

		geo_stat=1 & geo_isw=1 & geo_cur=0 & geo_seq=.0D & geo_timon=dblarr(((size(geo_w))(2))*2)
		geo_lead=lamp_b1       & geo_web=0

		if dial_ini then begin
		 for i=1,((size(geo_w))(2))-1 do begin    di=strtrim(string(i),2)
		    named=''
		    ii=execute ('if n_tags(d'+di+') gt 1 then named=d'+di+'.NAME')
		    if named ne '' then begin
			 dnum =i
			 pth  ='' & DialTag,d=dnum, tag="PATH",get=pth
			 DialInit , named,  d=dnum, path=pth, /restore
		    endif
		 endfor
		endif  else dial_ini=1
	endif else $
	if keyword_set(nowin) then begin
		Pn       =P_GEO_Ndials()    ;
		geo_freq =0                 ;General Timer
		geo_timon=dblarr((Pn+1)*2)  ;Time on Timer start process
		geo_lim  =0                 ;General Timer limit
		geo_par2 =['','','','','','-1','0'] ;Contains "dial_pad_init" table
		dial_ini =1
		geo_stat =0                 ;General Timer is on or off
		geo_act  =0                 ;0:plot Activity  1:output strings
		geo_web  =0                 ;1:outputs for web mirror
		geo_alp  =[0L,0L,0L,0L,0L]  ;BaseId  for pixmap plotting
		geo_vis  =0                 ;Visible short Dials
		geo_w    =lonarr(14,Pn+1)   ;0:drawBase    1:drawId  2:sensBase  3:OnOffButton
		                            ;4:HiLightBase 5:previous active dial (geo_cur) 6:has a dial
		                            ;7:HistoryBase 8:time in Macro 9:time in Get 10:time in Send
		                            ;11:Specific timer base  12:in the general or spec loop(2,1)
		                            ;13:large drawId
		geo_info =lonarr(6)         ;0:draw.xsize  1:draw.ysize  4:last dial scheme  5:did_win0
		geo_bxy  =[0,0]             ;short drawBase size
		geo_isw  =0                 ;0 for noWindow
		geo_cur  =0                 ;Current active Dial
		geo_onbas=[0L,0L,0L,0L]     ;BaseId for text & on/off Timer button & limit & Timer
		geo_lead =lamp_b1           ;Group Leader
		geo_seq  =.0D               ;Current Time (double flt)
	endif
end

pro DialCommons
;** ***********
;**
@lamp.cbk
common c_geo, geo_stat, geo_w  , geo_vis, geo_alp, geo_freq, geo_isw, geo_onbas,$
              geo_bxy , geo_cur, geo_ran, geo_seq, geo_info, geo_lim, geo_timon,$
              geo_par2, geo_lead,geo_act

common c_geweb, geo_web,gew_act, gew_pth, gew_snd, gew_err, gew_pwd, gew_r,gew_g,gew_b,gew_v
end

function N2S, number
;******* ***
;**
return, strtrim(string(number),2)
end

function DialNameToNumber, name, find=find
;******* ****************
;**
;** Given the name of a dial, return its number
;** If keyword_set find then  return a free number if no name match

common dialshare2
common c_geo

named=strupcase(name) & nome=''
N=0   & Pn=(size(geo_w))(2)-1
k=1   & while k le Pn do begin di=strtrim(string(k),2)
		    ii=execute ('if n_tags(d'+di+') gt 1 then nome=d'+di+'.NAME')
		    if strupcase(nome) eq named then begin N=k & k=Pn & endif & k=k+1
        endwhile

if N eq 0 then if keyword_set(find) then begin
			k=1 & while k le Pn do begin di=strtrim(string(k),2)
			      ii=execute ('if n_tags(d'+di+') le 1 then N=k')
			      ii=execute ('if n_tags(d'+di+') gt 1 then if d'+di+'.NAME eq "" then N=k')
			      if N gt 0 then   k=Pn & k=k+1
				endwhile
			if N eq 0 then $
			k=1 & while k le Pn do begin di=strtrim(string(k),2) & onoff=1
			      ii=execute ('if (n_tags(d'+di+') gt 1) then onoff=d'+di+'.ONOFF')
			      if onoff ne 1 then begin N=k & k=Pn & endif & k=k+1
				endwhile
			endif
return,N
end

;******* **************************************************************************
;******* **************************************************************************
;******* **************************************************************************
pro DialTag, name, d=dnum, TAG=tag, SET=setv, GET=getv
;** *******
;**
;** Set or Get the tag value of named dial
common c_geo
common dialshare2
	getv=0
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then if n_elements(tag) eq 1 then begin
	   if n_elements(setv) gt 0 then begin
	      if strupcase(tag) eq "ONOFF"   then if setv gt 0 then DialStart, d=dnum $
	                                                       else DialStop , d=dnum else $
	      if strupcase(tag) eq "HISTORY" then DialHistory, d=dnum ,ONOFF=setv     else $
	      if strupcase(tag) eq "VALUE"   then DialModValue,d=dnum ,      setv     else $
	      if strupcase(tag) eq "ERROR"   then DialModValue,d=dnum ,      setv, tag='ERROR' $
		  else DialModValue,d=dnum ,      setv, tag=strupcase(tag)
	     ;else    ii=execute('d'+strtrim(string(dnum),2)+'.'+tag+'=setv')

	   endif else ii=execute('getv=d'+strtrim(string(dnum),2)+'.'+tag)
	endif else if n_elements(setv) eq 0 then ii=execute('getv=d'+strtrim(string(dnum),2))  $
	                                    else ii=execute('d'+strtrim(string(dnum),2)+'=setv')
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialsFrequency, GET=getv, SET=setv, STOP=stop, START=start, DURATION=lim, SENS=sens
;** **************
;**
;** Settings of the Timer

common c_geo
	if n_elements(setv) eq 1 then begin
	   on_ioerror,miset & geo_freq=setv & v=strtrim(string(setv),2)
	   if geo_onbas(0) gt 0 then widget_control,geo_onbas(0),bad_id=ii,set_value=v
	   miset:
	endif
	if n_elements(lim)  eq 1 then begin
	   on_ioerror,mislm & geo_lim =lim  & v=strtrim(string(lim),2) & if lim le 0 then v=" "
	   if geo_onbas(2) gt 0 then widget_control,geo_onbas(2),bad_id=ii,set_value=v
	   mislm:
	endif
	if keyword_set(stop)  then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=0
	   geo_stat=0 & geo_w(8,*)=0 & endif
	if keyword_set(start) then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=1
	   geo_stat=1 & geo_timon(0)=systime(1)*1000 & P_GEO_TIMER, {id:geo_onbas(3)}
	   geo_w(8,*)=0 & endif

	if keyword_set(sens)  then if geo_stat  then   P_GEO_TIMER, {id:geo_onbas(3)}

	getv=geo_freq
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialNewValue, tope, NAME=name, d=dnum, SETVALUE=setvalue, COMMENT=ctxt, TYPE=tipe
;******* ************
;**
;** Get next value of the named dial by calling dial_"generic"_read interface function
;** (called from dial_macros)

common dialshare2
common c_lamp_par
common c_geo
val='0'
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if n_elements(ctxt) eq 0 then ctxt=""
	if n_elements(tope) eq 1 then if n_elements(tipe) ne 1 then tipe=tope

	 di=strtrim(string(dnum),2)

	   P_GEO_STATUS, dnum, "Get"

	   generic='' & nome='' & prox=-1
	   if n_elements(tipe) eq 1 then nome=tipe else $
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('generic=d' +di+'.GENERIC')
	   ii=execute('prox   =d' +di+'.PROX')
	   now=systime(1)
	   val=3.14

	   if generic eq 'lamp' then begin val=' '
	      CASE strlowcase(nome) of
	      'flagus':	val=0
	      'status':	val='Idle'
	      'log':	DID_WRITE_JOURNAL, val
	      ELSE:
	      ENDCASE
	   endif else $
	   if prox(0) ge 0 then begin par1=nome & par2=now     & par3=ctxt & par4=val
	                              COMMCA, proxcod ,prox    & val =par4 ; GET THE VALUE !!!!!!!!!!!!
	   endif else begin
	    ii=execute('val=dial_'+generic+'_read(nome, now, ctxt)')       ; GET THE VALUE !!!!!!!!!!!!
	    if not ii then begin val='0' & DialErrMes & DialStop & endif
	   endelse

	   geo_w(9,dnum)=geo_w(9,dnum)+((systime(1)-now)*1000)
	   sv=SIZE(val)
	   if sv(sv(0)+1) eq 4 then if val(0) eq 3.14 then P_GEO_STATUS, dnum, "GetNone" $
	                                              else P_GEO_STATUS, dnum, "GetOk"   $
	                                              else P_GEO_STATUS, dnum, "GetOk"

	   if keyword_set(setvalue) then DialModValue, val, d=dnum
return, val
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialModValue, val, NAME=name, d=dnum ,tag=TAG
;** ************
;**
;** Used when dial.VALUE changes its type or dimension

common dialshare2
common c_geo

    if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
    if n_elements(dnum) ne 1 then dnum=geo_cur
    if dnum gt 0 then begin
      di=strtrim(string(dnum),2)
      sv=SIZE   (val)
      if n_elements(TAG) ne 1 then TAG='VALUE' else TAG=strupcase(TAG)
      sz=[0,0,0] & ii=execute('sz=SIZE(d'+di+'.'+TAG+')')
      if (sz(sz(0)+1) ne sv(sv(0)+1)) or (sz(sz(0)+1) eq 8) or  $
         (sz(0) ne sv(0)) or (sz(sz(0)+2) ne sv(sv(0)+2)) then begin
	 elsa = ''
	 tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
	 for k=0,n_elements(tlist)-1 do begin
          CASE tlist(k) of
           TAG:
           ELSE:      elsa =elsa+','+tlist(k)+':d'+di+'.'+tlist(k)
          ENDCASE
	 endfor
                 ii=execute('d'+di+'={'+TAG+':val'+ elsa +'}')
      endif else ii=execute('d'+di+'.' +TAG+'=val')
    endif
end

pro DialMix, A,B
;** *******
;**
;** Mixe Dial B into Dial A

    nA=n_tags(A)  & nB=n_tags(B)
    if nB lt 1 then return
    if nA lt 1 then begin A=B  & return & endif
    elsa=''
    lA=strupcase(tag_names(A))
    for k=0,nA-2 do  elsa =elsa    + lA(k)   +':A.'+lA(k)+','
                     elsa =elsa    + lA(nA-1)+':A.'+lA(nA-1)
    lB=strupcase(tag_names(B))
    for k=0,nB-1 do  if (where(lA eq lB(k)))(0) eq -1 then $
                     elsa =elsa+','+ lB(k)   +':B.'+lB(k)

    ii=execute('A={'+ elsa +'}')
end

pro DialHistory, name, d=dnum, ONOFF=v
;** ***********
;**
;** A short for DialTag procedure

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  ii=execute('d'+strtrim(string(dnum),2)+'.HISTORY=v')
	                   if v then lab ='History is on' else lab ='History is off'
				 if geo_isw then widget_control,bad_id=ii,geo_w(7,dnum),set_value=lab
				 endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStop, name, d=dnum
;** ********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geo
common c_geweb
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=0')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=0
				 geo_w(8,dnum)=0
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' stopped'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial stopped' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' stopped'
				 if geo_web then WebDo,'val',dnum,dnum
				 endif
end
;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStart, name, d=dnum
;** *********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geo
common c_geweb
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=1')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=1
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
				 freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
				 geo_w(8,dnum)=0
				 geo_timon(dnum)=systime(1)*1000
				 if freq  gt 0  then  P_GEO_TIMER, {id:geo_w(11,dnum)} $
	                                  else  DialsFrequency, /SENS
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' started'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial started' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' started'
				 if n_elements(gew_pth) eq 0 then WEBON
	endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialControl, command, d=dnum ,check=check ,name=nome
;******* ***********
;**
;** Back control to the instrument

common dialshare2
common c_lamp_par
common c_geo
common c_geweb

if n_elements(dnum)  ne 1 then dnum =geo_cur
if n_elements(nome)  eq 1 then dnum =DialNameToNumber(nome)
if n_elements(check) ne 1 then check=0.

di     =strtrim(string(dnum),2)
generic='' & ii=execute('generic=d' +di+'.GENERIC')
if generic eq 'lamp' then ctrl='' else ctrl='Ctrl:'

comm=[strtrim(command,2)]
comh= comm
for i=0,n_elements(comm)-1 do begin

	if strpos(strupcase(comm(i)),'CTRL:') eq 0 then comm(i)=strmid(comm(i),5,85)
	if i eq 0 then comh(i)= ctrl  +comm(i)+" ;; "+!stime $
	          else comh(i)='----:'+comm(i)
	to_don_history,-1,0,comh(0)
endfor
if geo_web then WebDo,'snd',comh,dnum

if generic ne "lamp" then begin
	   P_GEO_STATUS,dnum, "Send"

	   nome='' & prox=-1 & name=""
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('name   =d' +di+'.NAME')
	   ii=execute('prox   =d' +di+'.PROS')
	   now=systime(1)
	   val=3.14

	   if prox(0) ge 0 then begin par1=nome & par2=check & par3=comm & par4=val & par5=name
	                              COMMCA, proxcod ,prox  & val =par4     ; SEND THE COMMAND !!!!!!!!!!!!

	   endif else begin CoCo='val=dial_'+generic+'_send(nome, check, comm, name)'
				      ii=EXECUTE(CoCo)                       ; SEND THE COMMAND !!!!!!!!!!!!

	    if not ii then begin val=0 & DialErrMes & DialStop & endif
	   endelse

	   geo_w(10,dnum)=geo_w(10,dnum)+((systime(1)-now)*1000)

	   if val ne 3.14 then P_GEO_STATUS,dnum, "SendOk" $
                        else P_GEO_STATUS,dnum, "SendNone"

endif else begin val=0 & XICUTE,comm(0) & endelse
return,val
end

pro DialClear, name, d=dnum
;** *********
;**
;** Remove the named dial

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
				 DialStop,d=dnum
				 DialTag ,d=dnum, tag="NAME", set=""
				;DialTag ,d=dnum, tag="PWD",  set=""
				 geo_w(6,dnum)=0
				 geo_w(8,dnum)=0
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =0
				 if geo_w(1,dnum) gt 0 then begin
				    di=strtrim(string(dnum),2)
				    P_GEO_DISPLAY, 'd'+di, geo_w(1,dnum) ,-1 ,DNUM=dnum
	endif		&	 endif
end

pro DialMacro, name, d=dnum, Si=di
;** *********
;**
;** Execute the macro of the named dial
;** Display the result

@lamp.cbk
common c_geo
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)   else name=''
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
	   if n_elements(di) ne 1 then di = strtrim(string(dnum),2)

	   geo_w(5,dnum)=geo_cur & geo_cur= dnum
	   geo_w(9,dnum)=0       & geo_w(10,dnum)=0
	   now=systime(1)

	   ii=execute('name =d'+di+'.NAME')
	   ii=execute('orig =d'+di+'.ORIGIN')
	   ii=execute('prox =n_elements(dt'+di+')') & jj=1

	   CATCH,stat & if stat ne 0 then begin catch,/cancel & DialErrMes & DialStop & return & endif

	   if prox gt 1 then begin DialFromD,keepd
	                     ii=execute('DialToD,  d'+di)
	                     jj=execute('COMMCA,  dt'+di)           ;EXECUTE THE MACRO OF THE DIAL from .prox
	                     ii=execute('DialFromD,d'+di)
	                                 DialToD  ,keepd
	   endif        else jj=execute('dial_'+orig+'_macro,d'+di) ;EXECUTE THE MACRO OF THE DIAL from .pro

	   if jj eq 0 then begin DialErrMes &  DialStop & endif

	   geo_w(8,dnum)=((systime(1)-now)*1000)>1

	   sz  =0  & ii=execute('sz   = SIZE (d'+di+'.VALUE)')
	   wupd=0  & ii=execute('wupd =d'+di+'.WUPDATE')
	   hiss=0  & ii=execute('hiss =d'+di+'.HISTORY')
	   if hiss then begin u=-1
		ii=execute('val=d'+di+'.VALUE(0)')
		if (val ne '') or (sz(sz(0)+2) gt 1) then begin
			on_ioerror,misopn & openw,u,"dial_"+name+".his",/append,/get_lun
			ii=execute('printf,u,d'+di+'.VALUE')
			misopn: if u gt 0 then free_lun,u
	   endif  & endif
	   val  =0
	   plt  =0      &         ii=execute('plt =       d'+di+'.PLOT')
	   histo=0

	   dw=di
	   if wupd le 0 then dw=strtrim(string(dnum+70),2)

	   if (sz(sz(0)+1) eq 7) and (plt gt -2) then begin
		ii=execute('val =  ";"+ d'+di+'.VALUE')
		if sz(sz(0)+2) gt 1 then begin
			WebDo,'log',val,dnum
			form_out,val & print,val & val='... '+val(n_elements(val)-1)
		endif else begin
			if val(0) le "; " then plt=-2
		endelse
		if plt ne -2 then begin ii=execute('w'+dw+' = val') & plt=-1 & endif

	   endif else if plt eq -1 then ii=execute('w'+dw+' = d'+di+'.VALUE') $

	   else if plt ge 0 then begin
		   sze=0.       &   ii=execute('sze  = d'+di+'.ERROR')
		   if n_elements(sze) ne sz(sz(0)+2) then sze=0.
				    alltag=[' '] & ii=execute('alltag = strupcase(TAG_NAMES(d'+di+'))')
				    xtl='' & ytl=''
				    idx=where(alltag eq 'X_TIT')  & idy=where(alltag eq 'Y_TIT')
				    if idx(0) ge 0 then  ii=execute ( 'xtl     = d'+di+'.X_TIT')
				    if idy(0) ge 0 then  ii=execute ( 'ytl     = d'+di+'.Y_TIT')
				    if wupd   gt 0 then  x_tit(dnum) = xtl    & !X.title=xtl
				    if wupd   gt 0 then  y_tit(dnum) = ytl    & !Y.title=ytl
				    if wupd   gt 0 then  w_tit(dnum) = name
				    if wupd   gt 0 then  other_tit(dnum) =  '(Dial)'
		   if sz(sz(0)+2) gt 1 then begin
				    ii=execute('w'+dw+' = d'+di+'.VALUE')
				    ii=execute('e'+dw+' = sze')
				    idx=where(alltag eq 'XVALUE') & idy=where(alltag eq 'YVALUE')
				    if idx(0) ge 0 then  ii=execute ( 'x'+dw+' = d'+di+'.XVALUE')
				    if idy(0) ge 0 then  ii=execute ( 'y'+dw+' = d'+di+'.YVALUE')
		   endif else begin
		     if plt gt 1 then  begin val=0 & ii=execute('val    = d'+di+'.VALUE')
			                             ii=execute('sz     = n_elements(w'+dw+')')
			if sz lt plt then begin      ii=execute('w'+dw+'=[(lonarr(plt-sz)+1)*val,w'+dw+']')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			if sz gt plt then begin      ii=execute('w'+dw+'= w'+dw+'(sz-plt:sz-1)')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			                 ii=execute('w'+dw+'=[w'+dw+'(1:plt-1),val]')
			if sze gt 0 then ii=execute('e'+dw+'=[e'+dw+'(1:plt-1),sze]')
			histo=1
		     endif          else ii=execute('w'+dw+'= d'+di+'.VALUE')
		   endelse
	   endif
	   if plt ge -1 then if (geo_w(1, dnum) gt 0) or (geo_w(13, dnum) gt 0) then begin
			ii=execute('P_GEO_DISPLAY, D'+di+', W'+dw+', error=E'+dw+', X=X'+dw+', Y=Y'+dw+', histo=histo')
	   endif
	   if geo_act eq 2 then WebDo,'dws',0,0,0

	   geo_cur=geo_w(5,dnum) & geo_w(5,dnum)=0
	   nel=n_elements(geo_timon)-1
	   if now - geo_timon(nel-dnum) gt 3. then begin
	   	if (dw eq di) and (plt gt -2) then TO_DON_HISTORY ,dnum,0,'W'+di+'=dial_'+name+'_macro result' ,/nojournal
		geo_timon(nel-dnum)=now
	   endif
	endif
end

pro DialFromD, Dial
;** *********
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
if n_elements(d) gt 0 then Dial=d
end
pro DialToD, Dial
;** *******
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
d=Dial
end
pro DialErrMes
;** **********
@lamp.cbk
common c_geo
  if l_message gt 0 then widget_control,bad_id=ii,l_message,set_value=strmid(!err_string,0,65)+' ...'
  print, !err_string
  WebDo,'err',!err_string
end
pro DialWSet, Activity=activity
;** ********
@lamp.cbk
common c_geo
  if keyword_set(activity) then begin
	P_GEO_DISPLAY,did_win0,1,0
  	geo_act=0
  endif else begin
  	if geo_act ne 2 then P_GEO_DISPLAY,did_win0,-1,0
  	geo_act=2
  	p_did_setwin0,/map
  endelse
end

pro DialInit, name, d=dnum, path=pth, restore=restore, new=newed, herits=diaH, nostart=nostart
;** ********
;**
;** the dial_name.pro file is compiled
;** and dial_name function is used to initiate the Dial.
;** Check for dial consistency then put it in D'dnum'.
;** /restore is used when restore saved session.
;** If new is defined then after loaded, give it the name "newed".

@lamp.cbk
common c_geo
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

if n_elements(name)   eq 1 then begin
 if n_elements(newed) ne 1 then newed =strlowcase(name)
 if n_elements(dnum)  ne 1 then dnum  =DialNameToNumber( newed, /find)
 if (dnum ge 1) and (dnum lt (size(geo_w))(2)) then begin
  di=strtrim(string(dnum),2)
  if l_message gt 0 then widget_control,l_message,bad_id=ii,set_value=" "
  if n_elements(pth) ne 1 then pth =""
  CD,current=mee
  if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
  fname="dial_"+name
  dial =''
  proc =findfile(fname+".pro" ,count=nn)
  if nn eq 0 then begin
     prox =findfile(fname+".prox",count=nn)
     if  nn gt 0 then begin DialFromD,keepd
                         COMMSI,fname+".prox", /EXEC             & DialFromD,dial
                         COMMSI,fname+"_macro.prox", MACRO=extxt & ii=execute('dt'+di+'=extxt')
                         DialToD  ,keepd  &  nn=-2
     endif & CD,mee
  endif
  if  nn ne -2 then begin
       if newed eq strlowcase(name) then if  sys_dep ('VERSION') ge 4.0 then $
       if (not sys_dep("EMBEDDED")) and (not sys_dep("RUNTIME")) then $
       ii  =execute('RESOLVE_ROUTINE,fname,/is_f')
       rout=[strupcase(fname)]
       if  sys_dep ('VERSION') ge 5.1 then ii=execute('rout=routine_info(/functions)')
       idx=where(rout eq strupcase(fname))
       if idx(0) ge 0 then ii=execute('dial='+fname+'()')	;INITIATE THE DIAL
       CD,mee
       if not ii then DialErrMes
  endif

  if n_elements(restore) eq 0 then begin

   if n_tags(dial) lt 1 then dial={init:0}

	tlist=strupcase(tag_names(dial))
	idx=where(tlist eq 'INHERIT')
	if idx(0) ge 0 then if dial.inherit gt ' ' then begin    diaG=''
	    DialInit , string (dial.inherit) , d=dnum, path=pth, herits=diaG
	    DialMix  , dial ,  diaG
	    tlist=strupcase(tag_names(dial)) & endif

	if n_elements(diaH) gt 0 then begin
	    DialMix  ,diaH,dial  &   return  & endif

	named    =newed
	generic  ='mad'
	type     =name
	value    =""
	error    =0.
	onoff    =0
	number   =dnum
	frequency=0.
	wupdate  =0. & if GEORGE eq 1 then wupdate=1
	upperlim =0.
	lowerlim =0.
	plot     =50
	history  =0
	duration =0
	init     =0
	unit     =''
	elsa     =''
	for k=0,n_elements(tlist)-1 do begin

	    CASE tlist(k) of
	    'NAME':
	    'NUMBER':
	    'PATH':
	    'ONOFF':     onoff    =fix   (dial.onoff)
	    'VALUE':     value    =dial.value
	    'ERROR':     error    =float (dial.error)
	    'PLOT':      plot     =fix   (dial.plot)
	    'WUPDATE':   wupdate  =fix   (dial.wupdate)
	    'INIT':      init     =fix   (dial.init)
	    'UNIT':      unit     =string(dial.unit)
	    'UPPERLIM':  upperlim =float (dial.upperlim)
	    'LOWERLIM':  lowerlim =float (dial.lowerlim)
	    'GENERIC':   generic  =string(dial.generic)
	    'TYPE':      type     =string(dial.type)
	    'FREQUENCY': frequency=float (dial.frequency)
	    'HISTORY':   history  =fix   (dial.history)
	    'DURATION':  duration =float (dial.duration)
	     ELSE:       elsa=elsa+','+tlist(k)+':dial.'+tlist(k)
	     ENDCASE
	endfor

	if keyword_set(nostart) then onoff=0
	DialClear,named
	ii=execute('d'+di+'={NAME:named,ORIGIN:name,GENERIC:generic,TYPE:type,INIT:init'+ $
	                   ',PLOT:plot ,UPPERLIM:upperlim,LOWERLIM:lowerlim,WUPDATE:wupdate'    + $
	                   ',ONOFF:onoff,VALUE:value,ERROR:error,FREQUENCY:frequency,DURATION:duration' +$
	                   ',HISTORY:history,PROX:[-1L,0],PROS:[-1L,0],NUMBER:number,UNIT:unit,PATH:pth'+$
	                     elsa +'}')

	if (wupdate gt 0) then begin
		ii=execute('w'+di+'=0')
		CLEARPAR, dnum,di
		w_tit    (dnum)=named  +' dial'
		other_tit(dnum)=type   +' (type) <- '+generic
		y_tit    (dnum)=unit
	endif
	ii=execute('w'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('x'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('y'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('e'+strtrim(string(dnum+70),2)+'=0')

	if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
	SetDuduch, "_read", generic, PROX & ii=execute('d'+di+'.PROX=PROX')
	SetDuduch, "_send", generic, PROX & ii=execute('d'+di+'.PROS=PROX')
	CD,mee

  endif
  if geo_isw then begin
			widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
			P_GEO_DISPLAY, newed, dnum ,-2

			DialTag, d=dnum, TAG='ONOFF'  , GET=onoff
			DialTag, d=dnum, TAG='ONOFF'  , SET=onoff
			DialTag, d=dnum, TAG='HISTORY', GET=history
			DialTag, d=dnum, TAG='HISTORY', SET=history
			endif

  if geo_w(1,dnum) gt 0 then P_GEO_DISPLAY, newed, geo_w(1,dnum) ,-1 ,DNUM=dnum

  if geo_cur le 0 then geo_cur=dnum ; To prevent problems in DialControl & DialNewValue
  geo_w(6,dnum)=1
 endif
endif
end

pro SetDuduch, proo, generic, PROX
;** *********
;**
common dialshare2

PROX=[-1L,0]
	  proc  =findfile ("dial_"+generic+proo+".pro" ,count=nn)
	  if nn eq 0 then begin
	   prof =findfile ("dial_"+generic+proo+".prox",count=nn)
	   if nn gt 0 then begin
		idx=where(duduch3 eq generic+proo) & idx=idx(0)
		if idx eq -1 then begin              idx=n_elements(proxcod)
		   COMMSI,"dial_"+generic+proo+".prox",  MACRO=tmpcod
		   nn     =n_elements(tmpcod)
		   duduch3=[duduch3,generic+proo,string(idx),string(idx+nn-1)]
		   proxcod=[proxcod,tmpcod]
		   PROX   =[idx,idx+nn-1L]
		endif else PROX=[long(duduch3(idx+1)),long(duduch3(idx+2))]
	   endif
	  endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialOn, dial, d=dnum
;******* ******
;**
;** Check for a User interrupt

common dialshare2
common c_geo

R=1
if geo_isw then begin
	if geo_onbas(1) gt 0 then begin
	   evv=widget_event(geo_onbas(1),/nowait,bad_id=ii)
	   if evv.id    eq  geo_onbas(1) then begin geo_stat =evv.select & R=geo_stat
	                                            geo_timon(0)=systime(1)*1000  &  endif
	endif
	if R then begin
	   if n_elements(dnum) ne 1 then dnum=geo_cur
	   if n_tags(dial)     gt 1 then dnum=dial.number
	   if (dnum ge 1) and (dnum le (size(geo_w))(2)) then begin
	     evv=widget_event(geo_w(3,dnum),/nowait,bad_id=ii)
	     if evv.id    eq  geo_w(3,dnum) then DialTag, d=dnum, tag='ONOFF', set=evv.select
	     DialTag ,d=dnum,tag='ONOFF', get=R
	   endif
	endif
endif
return,R
end

;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
pro WebFTP, file ,open=opn ,ifopn=ifopn ,check=check
;** ******
common c_geweb
common c_geUnit, gew_unit, gew_tftp ,gew_chk

;TEST FOR FTP AND BARNS ENABLE
if n_elements (gew_unit)  eq 0 then begin
   if sys_dep ('MACHINE') eq 'unix' then gew_unit= 0 else gew_unit=-1
   if sys_dep ('VERSION') lt 5.2    then gew_unit=-1
   bb=findfile(expand_path('~/.ssh')+'/*',count=n)  & if n lt 1 then gew_unit=-1
   gew_chk=0 & gew_tftp= dblarr(2)
endif else if keyword_set(opn) then begin if gew_unit lt 0 then gew_unit=0 & gew_chk=0 & endif

gew_unit=-1 ;Barns now is inside ILL

if gew_unit ge 0 then begin line=' ' & u=0
   on_ioerror,misftp
   if gew_unit gt 0 then begin now=systime(1) & delt=now-gew_tftp(0)
;   TEST TIME-TO-TIME FOR PIPE CONNECTION (OR INPUT COMMAND)
    if keyword_set(check) or (delt gt 7.) then begin
       if delt le 7. then begin if check eq 2 then gew_chk=0 & ok=1 & endif else ok=0
       s=fstat(gew_unit) & six=6
       if s.size gt six then begin ok=1
          while s.size gt six do begin readf,gew_unit,line & s=fstat(gew_unit)
	   if strpos(line,'Timeout')  ge 0 then begin s.size=0 & ok=0 & WebFTP_close & endif else $
	   if strpos(line,'by peer')  ge 0 then begin s.size=0 & ok=0 & WebFTP_close & endif else $
	   if strpos(line,gew_pth(3)) ge 0 then if (strpos(line,'Fetching') lt 0) and (strpos(line,'Removing') lt 0) then begin
	                                        printf, gew_unit,'get '+gew_pth(1)+gew_pth(3)+' '+gew_pth(1)+gew_pth(3)
                                                printf, gew_unit,'rm  '+gew_pth(1)+gew_pth(3) & gew_chk=2 & endif
          endwhile
          if ok eq 1 then begin if keyword_set(check) then begin
	                           if check eq 2 then gew_chk=0 $  ;RESET by webon_macro
				   else begin check=gew_chk        ;WILL BE THERE NEXT TIME IF gew_chk eq 2
	                                      if gew_chk eq 2 then begin gew_chk=1 & check=0 & endif
                                              if gew_chk eq 0 then printf, gew_unit,'dir '+gew_pth(1) & endelse
	                        endif
				printf, gew_unit,'pwd' & gew_tftp(0)=now & endif
       endif else check=gew_chk
       if ok eq 0 then if now-gew_tftp(1) gt 60*6. then gew_tftp(1)=now else $
                       if now-gew_tftp(1) gt 60*4. then WebFTP_close    else $
		       if now-gew_tftp(1) lt 20*1. then begin print,'No response from Ftp '+!stime & gew_tftp(1)=now-20 & endif
    endif
   endif
;  OPEN FIRST OR BROKEN CONNECTION
   if gew_unit eq 0 then begin
      if keyword_set(ifopn) then return
;     openr ,u,gew_pth(2),/get_lun & readf ,u,line & free_lun,u
;     openw ,u,'~/.netrc',/get_lun & printf,u,line & free_lun,u
;     spawn,'chmod 600 ~/.netrc' & openr ,u,'~/.netrc',/get_lun,/DELETE
      spawn,['sftp','arthur@barns'],unit=gew_unit,/noshell
      printf, gew_unit,'cd '+ gew_pth(0)
      printf, gew_unit,'pwd' & wait,2 & s=fstat(gew_unit) & six=6
      ok=1
      if gew_tftp(0) eq 0 then begin jj=5 & ok=0 ;FIRST TIME OPENED
         while (s.size le six) and (jj gt 0) do begin wait,1 & jj=jj-1 & s=fstat(gew_unit) & endwhile
         if s.size gt six then begin
            while s.size gt six do begin readf,gew_unit,line & s=fstat(gew_unit) & endwhile
            if strpos(line,strmid(gew_pth(0),0,strlen(gew_pth(0))-1)) ge 0 then begin
               printf, gew_unit,'pwd' & print,'Ftp reactivated '+!stime & ok=1 & endif
         endif
      endif                                      ;-----------------
      gew_tftp(0:1)=systime(1)
      if not ok then begin WebFTP_close & gew_unit=-1 & endif
      if u gt 0 then free_lun,u & u=0
   endif

;  SEND THE FILE
   if n_elements(file) eq 1 then printf, gew_unit,'put '+gew_pth(0)+file+ ' '+file
   return

   misftp: WebFTP_close & if u gt 0 then free_lun,u & if gew_tftp(0) eq 0 then gew_unit=-1
endif
end

pro WebFTP_close
;** ************
common c_geUnit
if n_elements(gew_unit) eq 1 then if gew_unit gt 0 then begin
   print,'Ftp canceled '+!stime
   if sys_dep('VERSION') lt 5.4 then free_lun,gew_unit else ii=execute('free_lun,gew_unit,/force')
   gew_unit=0
endif
end

pro dial_webon_macro,D
;** ****************
;**
nn =1 & WebFtp,CHECK=nn
if  nn eq 1 then bid=FINDFILE(D.webpth,count=nn)
IF  nn gt 0 then begin wline=[''] & value=['']
    on_ioerror,misopn
    OPENR,u,D.webpth,/GET_LUN,/DELETE
	on_ioerror,misread
	line=''
	WHILE (not EOF(u)) do begin READF,u,line & wline=[wline,line] & ENDWHILE
	misread:  on_ioerror,misopn
	FREE_LUN ,u
	WebFtp,CHECK=2
	IF n_elements(wline) gt 2 then if wline(1) eq D.pwd then begin
		wline=wline(2:*)
		XICUTER,' ;--->WebOn '+!stime+' {'+wline(0)+'...}'
		CATCH,stat & if stat ne 0 then begin print,!err_string & return & endif
		FOR i=0,n_elements(wline)-1 do $
			IF wline(i) ne D.pwd then begin line=strtrim(wline(i),2)

			   if strpos(line,'ii=barns_i') ge 0 then jj=EXECUTE(line) $
			   else if line gt ' '	then begin XICUTER,(line+'') & value=[value,line]
			        endif
			ENDIF
		XICUTER,' ;---> '
		if n_elements(value) gt 1 then value=value(1:n_elements(value)-1)
		WebDo,'log',value,12
	ENDIF
	DialModValue,value, TAG='VALUE'
    misopn:
endif else if D.value(0) ne '' then DialModValue,[''], TAG='VALUE'
end

function dial_webon
;******* **********
;**
return,{NAME:"webon",PLOT:0,HISTORY:0,VALUE:[''],FREQUENCY:3,WEBPTH:'',PWD:'',WUPDATE:-1}
end

pro WebOn, PATH=wpth ,PASSWORD=pass, PASSWD=pasw
;** *****
common c_geo
common c_geweb

catch,stat & if stat ne 0 then return

if n_elements(gew_pwd) ne 1 then       gew_pwd= ''
if n_elements(   pass) eq 1 then begin gew_pwd=pass & ii=execute('geokey,gew_pwd') & endif
if n_elements(   pasw) eq 1 then begin gew_pwd=pasw & ii=execute('geokey,gew_pwd') & endif
Mach=strupcase(getenv('HOST')) & id=strpos(Mach,'.')
if id gt 0 then Mach=strmid(Mach,0,id)
dvd=sys_dep('DIVIDER')
if n_elements(gew_pth) lt 2 then begin gew_pth=['','','','.geo_webon.txt']
		if Mach eq "" then begin F='C:\User\Didier\geoport\' & Mach='pcRichard'
		endif         else       F='/home/cs/lambda/geoport/'
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(0)=F+Mach
		gew_pth(2)=F+'.bArns'
		F=F+'WebGeorge'+dvd
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(1)=F+Mach+dvd else gew_pwd=''
endif

if n_elements(wpth) eq 1 then gew_pth(0)=  wpth
nld=strlen(gew_pth(0))-1
if nld gt 0 then if strmid(gew_pth(0),nld,1) eq dvd then gew_pth(0)=strmid(gew_pth(0),0,nld)

if gew_pth(0) gt ' ' then begin
 gew_pth(0)=gew_pth(0)+dvd
 on_ioerror,misopn
 openw,u,gew_pth(0)+'geo_d_0.web',/get_lun & free_lun,u

    list=findfile(gew_pth(0)+'geo_d_*',count=nn)
    if  nn gt 0 then bid=sys_dep('DELIST',list)

    par1 =''
    if Mach ne '' then begin
	catch,stat
	if stat eq 0 then ii=execute('par1=dial_pad_init_'+(Mach)+'(dummy)') else catch,/cancel
    endif

    WebFTP,/open

    sz=SIZE(par1)
    if  sz(0) lt 2 then ii=execute("par1=dial_pad_init()") & sz=SIZE(par1)
    if (sz(0) eq 2) and (sz(1) eq 5) then begin
	  openw,u,gew_pth(0)+'dial_pad.web',/get_lun
	  printf,u,'# George Instrument PAD'
	  printf,u,'# ',strtrim(string(sz(2)),2),' * 5 entries (label command flag program check)'
	  printf,u,'# First 5 lines for input text, others for buttons'
	  printf,u,'# '
	  for j=0,sz(2)-1 do for i=0,sz(1)-1 do printf,u,par1(i,j)
	  free_lun,u
	  WebFTP, 'dial_pad.web' & endif

 if sys_dep('MACHINE')  eq  'vms' then gew_v=';1' else gew_v=''
 gew_act=100 & gew_snd=['-'] & gew_err='-'
 tvlct,gew_r,gew_g,gew_b,/get
 if    gew_pwd gt ' ' then begin list=findfile(gew_pth(1)+gew_pth(3),count=nn)
				 if  nn gt 0 then bid=sys_dep('DELIST',list)
				 DialInit ,"webon",d=12
				 DialTag  ,"webon",tag="WEBPTH",set=gew_pth(1)+gew_pth(3)
				 DialTag  ,"webon",tag="PWD"   ,set=gew_pwd
				 DialStart,"webon" & endif
 geo_web=1
 WebDo,"sta","on",0
 return
 misopn: ;DialErrMes
endif
gew_pth='' & gew_pwd= ''
end

pro WebOff
;** ******
common c_geo
common c_geweb
if geo_web gt 0 then WebDo,"sta","off",0
geo_web=0
gew_pth='' & gew_pwd= '' & DialClear,"webon" & WebFTP_close
end

pro WebMess, val
;** *******
WebDo, 'log', val, 9
end

pro WebDo, flag, val, dnum, matx
;** *****
common c_geo
common dialshare2
common c_geweb

if geo_web eq 0 then return
on_ioerror,misopn
flg=flag
case flg of
'act':gew_act=100 + 100-val
'err':gew_err=val
'snd':gew_snd=val
'pth':begin   val=gew_pth(0) & return & end
'fil':WebFTP, val
'log':begin fifi='geo_d_'+strtrim(dnum,2)+'Lhtm.web'+gew_v
		openw,u,gew_pth(0)+fifi,/get_lun
		printf,u,'<html><head></head><body><b>'
		if dnum eq 12 then printf,u,'<h3>Command executed:</h3><br>'
		for i=0,n_elements(val)-1 do printf,u,'<nobr>'+val(i)+'<br>'
		printf,u,'</body></html>'  & printf,u,''
		flush,u & free_lun,u
		WebFTP, fifi
      end
;'dws':return ;nfs problem for big files
 else:begin ds=strtrim(dnum,2)			;'gif' 'dws' ('val' 'wks')
       now=systime(1)
       nel=n_elements(geo_timon)-1
       onf=1     &  if dnum gt 0 then ii=execute('onf =d'+ds+'.onoff')
       if (now-geo_timon(nel-dnum) ge 3.) or (flg eq 'val') or (not onf) then begin ;Care 3. le that for history!!!!!!

	freq=0   &  if dnum gt 0 then ii=execute('freq=d'+ds+'.frequency')
	dur =0   &  if dnum gt 0 then ii=execute('dur =d'+ds+'.duration')
	his =0   &  if dnum gt 0 then ii=execute('his =d'+ds+'.history')
	nam ='z' &  if dnum gt 0 then ii=execute('nam =d'+ds+'.name')
	if (not onf) then nam=nam+'_stopped'
	ifopn=0
	dws =flg
	if flg eq 'dws' then begin flg='gif' & if not val then begin DialWSet & geo_act=1 & endif else ifopn=1 & endif
	if flg eq 'gif' then begin r=0       & matx=tvrdd(r,g,b) & endif
	if flg eq 'val' then flg='gif'
	if flg eq 'gif' then if sys_dep('VERSION') ge 5.4 then  flg='png'

	img=n_elements(matx)
	if img gt 1 then $
	   if flg ne 'wks' then begin fifi='geo_d_'+ds+'.'+flg+gew_v
	    if n_elements(r) le 1 then $
	         WRITE_KIF,gew_pth(0)+fifi,matx,gew_r,gew_g,gew_b,transparent=0 $
	    else WRITE_KIF,gew_pth(0)+fifi,matx, r,g,b,transparent=0
	    WebFTP, fifi, IFOPN=ifopn
	   endif
	if dws eq 'dws' then flg=dws

	fifi='geo_d_'+ds+'.web'+gew_v
	openw,u,gew_pth(0)+fifi,/get_lun
	printf,u, nam,gew_act,geo_freq,geo_lim
	printf,u, freq,dur,his,' '+flg
	printf,u, val
	if gew_err    ne '' then begin printf,u,'err:'+gew_err & gew_err=''   & endif
	if gew_snd(0) ne '' then begin printf,u,'snd:'+gew_snd & gew_snd=[''] & endif
	flush,u & free_lun,u
	WebFTP, fifi, IFOPN=ifopn

       endif
      end
endcase
misopn:
end
;************************************ END WEB MODULES *************************
;************************************ END WEB MODULES *************************

pro P_GEO_EVENT, ev, uv
;** ***********
;**
;** Widget events handler
@lamp.cbk
common c_geo

if uv(1) eq 667 then begin geo_stat  =ev.select  & uv(1)=666                        ;on/off General
                           geo_w(8,*)=0 & endif
case uv(1) of
	614: begin                                                                  ;Mad command
		widget_control,uv(3),bad_id=ii,get_value=comm
		comm=strtrim(comm(0),2)
		if strpos(strupcase(comm),'CTRL:') ne 0 then comm='Ctrl:'+comm
		XICUTER,comm
	     end
	660: if geo_act ne ev.select then begin geo_act=ev.select                   ;plot Activity
	        if geo_act gt 0 then P_GEO_DISPLAY,did_win0,0,0 $
			        else P_GEO_DISPLAY,did_win0,1,0
	     endif
	665: DialTag, d=uv(2), tag='ONOFF', set=ev.select                           ;on/off on Dials
	666: begin                                                                  ;Change frequency ?
		widget_control,uv(2),get_value=bid
		on_ioerror,mis666
		geo_freq=(float(bid(0))>0.) & duduch1=geo_freq
		bid=0
		widget_control,uv(4),get_value=bid,bad_id=ii                        ;Change duration  ?
		on_ioerror,misbid
		geo_lim =(float(bid(0))>0.) & duduch2=geo_lim & misbid:
                geo_timon(0)=systime(1)*1000
		P_GEO_TIMER, {id:uv(3)}
		mis666:
	     end
	670: begin case uv(2) of
	     1:  begin dnum=uv(3)                                                   ;Reset
	               pth   =''   & DialTag,d=dnum,tag="PATH"  ,get=pth
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               origin=''   & DialTag,d=dnum,tag="ORIGIN",get=origin
	               DialInit, origin, d=dnum, path=pth ,new=named
	                            DialTag,d=dnum,tag="ONOFF",set=onoff
	               end
	     2:  DialTag,d=uv(3),tag="HISTORY",set=0                                ;History off
	     3:  DialTag,d=uv(3),tag="HISTORY",set=1                                ;History on
	     4:  begin DialTag,d=uv(3),tag="NAME",get=named                         ;Clear history file
	               bid=sys_dep('DELET',"dial_"+named+".his")
	               end
	     5:  begin dn=uv(3) & dw=geo_w(13,dn)                                   ;large dial
		       keep_w=!D.window
	               if dw gt 0 then begin ii=execute('wset,dw')
	                                     if ii ne 1  then dw=0 else wshow,dw & endif
	               DialTag,d=uv(3),tag="WUPDATE",get= wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=(wupd<1)

	               if dw le 0 then begin DialTag,d=dn,tag="NAME" ,get=named
		                               if geo_w(1,dn) gt 0 then P_GEO_DISPLAY, 'Large '+named,geo_w(1,dn),-1
	                                     WINDOW,xsize=geo_bxy(0)*2,ysize=geo_bxy(1)*2,title=named,/FREE
	                                     dw=!D.Window & endif
	               geo_w(13,dn)=dw
		       if keep_w gt 0 then wset,keep_w
	         end
	     6:  begin di=strtrim(string(uv(3)),2)                                  ;Properties list
	               tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
		       if geo_lead gt 0 then begin b0=widget_base(title="Dial "+di+" properties",resource_name="lamp")
						   b1=widget_base(b0,/column,resource_name="geo") & endif
	               for k=0,n_elements(tlist)-1 do begin
			   DialTag,d=uv(3),tag=tlist(k),get=V & tag='d'+di+'.'+tlist(k)
	                   CASE tlist(k) of
	                   'ERROR':
	                   'PROX':
	                   'PROS':
	                   'PWD':
	                    ELSE:   if geo_lead gt 0 then begin sz=SIZE(V)
			    		if sz(sz(0)+1) eq 8 then V='is a structure' $
			    		else if sz(sz(0)+2) gt 1 then begin  V=strtrim(string(sz(1)),2)
							if sz(0) gt 1 then V=V+','+strtrim(string(sz(2)),2)
							if sz(0) gt 2 then V=V+','+strtrim(string(sz(3)),2)
							if sz(0) gt 3 then V=V+',..'
							V='size('+V+')'
					endif else      V= strtrim(string(V(0)),2)
			    		b2=widget_base (b1,/row)
					bb=widget_label(b2,value=tag+"=",font=ft_b_normal)
					bb=widget_label(b2,value=V      ,font=ft_b_normal)
				    endif else print, tag+'= ',V
	                   ENDCASE
	               endfor
		       if geo_lead gt 0 then widget_control,b0,group_leader=geo_lead,/realize
	         end
	     7:  if ev.TYPE eq 0 then begin
	               di=strtrim(string(uv(3)),2) & N=0 & wupd=0				;plot in main window
	               geo_info(5)=did_win0							;case main window changed
	               DialTag,d=uv(3),tag="WUPDATE",get=wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=2
	               ii=execute('N=n_elements(D'+di+'.VALUE)')
	               if N  gt 1 then begin
	                  DialTag,d=uv(3),tag="XVALUE",get=XX
	                  DialTag,d=uv(3),tag="YVALUE",get=YY
	                  ii=execute('P_GEO_DISPLAY, D'+di+', D'+di+'.VALUE, error=D'+di+'.ERROR, X=XX, Y=YY')
	               endif
	               if ev.PRESS eq 2 then DialTag,d=uv(3),tag="WUPDATE",set=1 ;middle
	               if ev.PRESS eq 1 then DialTag,d=uv(3),tag="WUPDATE",set=0 ;left
		 endif
	     8:        DialClear,d=uv(3)                                            ;Remove the dial
	     else:
	     endcase
	     if (uv(2) ge 80) and (uv(2) le 95) then begin
			widget_control,ev.id,get_value=fq & DialTag,d=uv(3),tag="FREQUENCY",set=float(fq(0))
			;widget_control,uv(4),set_value='Own Frequency='+fq
			DialTag,d=uv(3),tag="ONOFF",get=V & if V eq 1 then DialTag,d=uv(3),tag="ONOFF",set=1
	     endif
	     end
	671: begin  DialTag,d=uv(3),tag="PLOT",set=uv(2)
	            if uv(2) eq -2 then if geo_w(1,uv(3)) gt 0 then P_GEO_DISPLAY,'no Plot',geo_w(1,uv(3)),-1, DNUM=uv(3)
	     end
	else:
endcase
end

pro P_GEO_TIMER, ev
;** ***********
;**
;** Timer handler

common dialshare2
common c_geo

begtim=systime(1)
if ev.id eq geo_onbas(3) then begin
;  GENERAL TIMER
   if geo_lim gt 0  then if (begtim*1000 - geo_timon(0) gt geo_lim*1000) then DialsFrequency,/STOP
   if geo_stat      then begin
	 P_GEO_RETIM ,ev.id, geo_freq
	 Pn=((size(geo_w))(2))-1
	 dnum =0
	 R    =1
	 for i=1,Pn do if geo_w(6,i) eq 1 then begin

	   di   =strtrim(string(i),2)
	   onoff=0 & ii=execute('if n_tags(d'+di+') gt 1 then onoff=d'+di+'.ONOFF else geo_w(6,i)=0')
	   if onoff then begin
	    freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    if   freq le 0 then begin
	      if dnum eq 0 then P_GEO_STATUS, 0,"Loop",begtim  else   R=DIALON(d=(i+0))

	      if geo_stat  then if R then begin dnum=i
	                                        P_GEO_STATUS, dnum, "This" ,2
		                                DIALMACRO,  d=dnum, Si=di
	    					freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    					if freq gt 0 then P_GEO_RETIM ,geo_w(11,dnum), freq
	      endif
	    endif else if abs(geo_w(12,i)) eq 2 then  DialStart,d=(i+1-1)
	   endif else geo_w(8,i)=0
	 endif
	 if   dnum  gt 0   then P_GEO_STATUS, (geo_freq+0), "EndL" ,begtim
	 totim=geo_freq-(systime(1)-begtim)
	 if totim lt 0 then if geo_freq gt 0 then P_GEO_RETIM ,ev.id, totim ;GIVE TIME FOR OTHERS.
   endif
endif else begin

;  SPECIFIC TIMER
   widget_control,ev.id,get_uvalue=dnum
   di   = strtrim(string(dnum),2)
   freq = 0 & ii=execute('freq =d'+di+'.FREQUENCY')
   durat= 0 & ii=execute('durat=d'+di+'.DURATION')
   if durat gt 0 then if (begtim*1000 - geo_timon(dnum) gt durat*1000) then DialStop, d=dnum
   onoff= 0 & ii=execute('onoff=d'+di+'.ONOFF')
   if freq gt 0 then if onoff then begin
		P_GEO_RETIM ,ev.id,  freq
		P_GEO_STATUS, 0   , "Loop", begtim
		P_GEO_STATUS, dnum, "This" ,1
		DIALMACRO  ,d=dnum, Si=di
		P_GEO_STATUS, freq, "EndL" ,begtim
		fruq=freq & ii=execute('freq =d'+di+'.FREQUENCY')
		if freq ne fruq then P_GEO_RETIM ,ev.id,  freq $
		else begin
		  totim=(geo_freq*geo_stat)+freq - (systime(1)-begtim)
		  if totim lt 0 then P_GEO_RETIM ,ev.id, totim              ;GIVE TIME FOR OTHERS.
		endelse
   endif    else geo_w(8, dnum)=0
endelse
end

pro P_GEO_RETIM, id,freq
;** ***********
;**
;** RE-TIMER
			widget_control,bad_id=ii,id,/CLEAR_EVENTS
if freq gt 0 then	widget_control,bad_id=ii,id, TIMER=freq	else $
if freq lt 0 then	widget_control,bad_id=ii,id, TIMER=0.05<(-freq)
end

pro P_GEO_STATUS, dnum, way , flgtim
;** ************
;**
;** Display a scheme for the timer process

common dialshare2
common c_lamp_info
common c_geo
common c_geweb
common c_geostat,kpstr

if way eq "Loop" then       geo_seq=flgtim
if way eq "This" then       geo_w(12,dnum)=flgtim
if geo_isw then begin

   if geo_act eq 0 then begin keep_w=!D.window & wset,did_win0
   case way of

	"Loop":
	"This":     begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	            end

	"Get":      begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	                  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=120
	            end

	"GetOk":          plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0

	"GetNone":  begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Bad new Value !!!'
			  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0
	            end

	"Send":     begin if dnum gt 0 then $
			   if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
			  plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=120
	            end

	"SendOk":   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0

	"SendNone": begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Send Control error-code !!!'
			   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0
	            end

	"EndL":     begin device,copy=[0,0      ,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
	                  geo_info(4)= 0
				idx=where(geo_w(8,*) gt 0)
				totim= ((systime(1)-flgtim)*1000+geo_w(9,0))>1
				now  =   systime(1)
				if idx(0) ge 0 then begin
				   for i= 0,n_elements(idx)-1 do if geo_w(12,idx(i)) gt 0 then begin

				       j=idx(i)
				       geo_w(8 ,j)=(geo_w(8 ,j)*100./totim)>1
				       geo_w(9 ,j)=(geo_w(9 ,j)*100./totim)
				       geo_w(10,j)=(geo_w(10,j)*100./totim)
				       geo_w(12,j)=-geo_w(12,j)

				       endif else geo_w(8:10)=1

				   P_GEO_DISPLAY, idx ,dnum,totim
				   if geo_web then begin
				      if dnum gt 0 then ppm=long(dnum*1000*100./totim)<100 else ppm=100
				      WebDo,'act',ppm
				      endif
				endif
				device,copy=[0,0,geo_info(0)/2+30,geo_info(1)*2/3,geo_info(0)/2-32,geo_info(1)/3-2,geo_alp(4)]
				geo_w(9,0) =(systime(1)-now)*1000
	            end
	else:
	endcase
	if keep_w gt 0 then wset,keep_w

   endif else if geo_act gt 0 then begin di=string(dnum)
   case way of

	"Loop":      kpstr=''
	"This":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	                    di=strtrim(di,2) &  name="" & ii=execute('name=d'+di+'.NAME')
						wupd="" & ii=execute('wupd=d'+di+'.WUPDATE')
	             if wupd gt 0 then sws='W' else sws='D'
	             if wupd ge 0 then begin kpstr=kpstr+' ('+sws+di+')'+name
	             widget_control,l_message,bad_id=ii,set_value='............ Dial '+name+' running ...'
		     endif & endif
		     end
	"Get":      ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' requesting ...'
	"GetOk":    ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"GetNone":  ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad request !!!'
	"Send":     ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' sending control ...'
	"SendOk":   ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"SendNone": ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad control !!!'
	"EndL":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	               if kpstr gt ' ' then begin
	                  totim= ((systime(1)-flgtim)*1000)>1
	                  ppm  =long(dnum*1000*100./totim)
	                  if ppm lt 100 then miss=' mis:'+string(long(totim-dnum*1000)/1000.)+' sec' else miss=''
	                  widget_control,l_message,bad_id=ii,set_value=kpstr+string(ppm<100)+'%'+miss
	                  if geo_web then WebDo,'act',ppm<100
                       endif
	             endif
		     end
	else:
   endcase
   endif
endif
end

pro P_GEO_DISPLAY, D, W ,totim  ,error=E ,X=XXX ,Y=YYY ,histo=histo ,DNUM=dnum
;** *************
;**
;** Dial   display -> D=dial      ,  W=workspace
;** Scheme display -> D=dial index,  W=frequence,  totim= time
;** Backgr display -> D=did_win0  ,  W=big arrow,  totim= 0
;** Backgr reset   -> D=did_win0  ,  W=1        ,  totim= 0
;** Backgr erase   -> D=did_win0  ,  W=0        ,  totim= 0
;** di     xyouts  -> D=di        ,  W=winID    ,  totim=-1
;** Dial big name  -> D=name      ,  W=dnum     ,  totim=-2
;** c_did  info    -> D=return [] ,  W=0        ,  totim=-3

common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common c_draw ; rx,rz,nlv,styles(0,0),styles(1,0)
common c_did  ;[did_x,did_y,did_wd]
common c_geo
common c_geweb

	keep_w=!D.window
	if n_elements(totim)  eq 0 then begin

			dw  =geo_w(13,D.NUMBER)
			if  (D.WUPDATE eq 2)  then begin if dw gt 0 then              ii=execute('wdelete,dw')
							 dw=geo_info(5)
							 geo_w(13,D.NUMBER)=0       & ii=execute('wset   ,dw')
			endif else if dw gt 0 then begin ii= execute('wset, dw')    & if ii ne 1  then    dw=0
							 geo_w(13,D.NUMBER)=dw      & endif
			trap_current=dw
			stime=strmid(!stime,12,8)
			sz =SIZE(W) & upl=D.UPPERLIM & lwl=D.LOWERLIM
			if sz(sz(0)+2) eq 1 then begin
			   if (D.PLOT le 0) or (upl le lwl) or (dw gt 0) then begin
				if  (dw le 0) or (geo_web) then begin
				     wset,geo_alp(1) & erase
				     xyouts,3,3,strtrim(string(W(0)),2), charsize=1.,/device
				     xyouts,3,geo_bxy(1)-10,D.NAME     , charsize=1.,/device
				     wset  ,geo_w(1,D.NUMBER)
				     device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				     if geo_web then WebDo,'gif',W(0),D.number
				     endif
				if  (dw gt 0) then begin
				     if geo_web then wset,dw & erase
				     xyouts,9,9,strtrim(string(W(0)),2), charsize=3.,charthick=3,font=-1,/device
				endif
			   endif else begin
				wset,geo_w(1,D.NUMBER)
				on_ioerror,notan & res=0
				res=fix(float(upl-W(0))/(upl-lwl) * geo_bxy(0))
				device,copy=[res,0,geo_bxy(0),geo_bxy(1)-3,0,3,geo_alp(0)]
				notan: if res eq 0 then erase
				xyouts,3,geo_bxy(1)-23,strtrim(string(W(0)),2),charsize=1.,/device
			        xyouts,3,geo_bxy(1)-10,D.NAME,charsize=.6,/device
				if geo_web then WebDo,'gif',W(0),D.number
			   endelse

			endif else if sz(0) eq 1 then begin
			   if n_elements(xxx) ne sz(1) then xxx=indgen(sz(1))
			   if keyword_set(histo) then velu=       strtrim(string(W(sz(1)-1)),2) $
			   		   else begin mox =max(W) & velu= 'Max:'  +strtrim(string(mox),2)     + $
					   				  ' at X:'+strtrim(string(xxx(!C)),2)
					   endelse
			   if (dw le 0) or (geo_web)   then begin
			      wset,geo_alp(1)
			      if upl le lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1,yrange=[lwl,upl]
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,D.NAME+'='+velu+'  ',charsize=.6,/device $
			                       else xyouts,3,geo_bxy(1)-10,velu+'      '       ,charsize=.6,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				if geo_web then WebDo,'gif',W(n_elements(W)-1),D.number
				endif
			   if (dw gt 0)  then begin
				if geo_web then wset,dw
			      erase
			      velu=velu+' Updated:'+stime
			      if n_elements(E) eq n_elements(W) then sym=4 else sym=10
			      if upl le lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,yrange=[lwl,upl],$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if n_elements(E) eq n_elements(W) then errplot,xxx,W-E,W+E
			   endif

			endif else if sz(0) eq 2 then begin
			   if (n_elements(xxx) ne sz(1)) and (n_elements(xxx) ne sz(1)*sz(2)) then xxx=indgen(sz(1))
			   if (n_elements(yyy) ne sz(2)) and (n_elements(yyy) ne sz(1)*sz(2)) then yyy=indgen(sz(2))
			   congw='w' & congx=',xxx' & congy=',yyy' & qq=128L
			   if upl gt lwl then congw='w>lwl<upl'
			   if (sz(sz(0)+2) gt qq*qq) and (D.PLOT ne 0) then begin
			   	                                 congw= 'congrid('+congw+',qq<sz(1),qq<sz(2))'
			   	if n_elements(xxx) eq sz(1) then congx=',congrid(xxx,qq<sz(1))'          else $
								 congx=',congrid(xxx,qq<sz(1),qq<sz(2))'
			   	if n_elements(yyy) eq sz(2) then congy=',congrid(yyy,qq<sz(2))'          else $
								 congy=',congrid(yyy,qq<sz(1),qq<sz(2))'
			   endif
			   if D.PLOT eq 0 then mmx=max(W)
			   if (dw le 0) or (geo_web)  then begin
			      wset,geo_alp(1)
			      if D.PLOT eq 0 then begin
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',geo_bxy(0),geo_bxy(1))+1)>1)') $
					       else ii=execute('tvscl,      CONGRID('+congw+',geo_bxy(0),geo_bxy(1))      ')
			      endif else $
			      if D.PLOT ne 2 then ii=execute($
				'shade_surf,'+congw+congx+congy+',xstyle=4,ystyle=4,zstyle=4,xmargin=[0,0],ymargin=[0,0],az=rz,ax=rx') $
			                      else ii=execute($
				'contour,'   +congw+congx+congy+',xstyle=4,ystyle=4,/fill   ,xmargin=[0,0],ymargin=[0,0],nlevels=nlv')
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,    D.NAME,    charsize=1.,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
			      if geo_web then WebDo,'gif',0,D.number
			      endif
			   if (dw gt 0) then begin
			   	titil=D.NAME+' updated:'+stime
				if geo_web then wset,dw
			      ;sxx=[1,round(sz(1)/4),round(sz(1)/2),round(sz(1)*3/4),sz(1)] & sxx=strtrim(string(sxx),2)
			      ;syy=[1,round(sz(2)/4),round(sz(2)/2),round(sz(2)*3/4),sz(2)] & syy=strtrim(string(syy),2)
			      if D.PLOT eq 0 then begin
				dxsiz=!D.x_size & xo=40 & xf=10
				dysiz=!D.y_size & yo=40 & yf=20
				if (sz(1) eq sz(2)) and (D.WUPDATE eq 2) then begin
				   if dxsiz gt dysiz then dxsiz=dysiz else dysiz=dxsiz
				endif
				erase
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf)+1)>1),xo,yo') $
					       else ii=execute('tvscl,     (CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf))     ,xo,yo')
				ii=execute('plot,W,charsize=1.2 ,xrange=[xxx(0),xxx(sz(1)-1)],yrange=[0,sz(2)-1]'+$
				           ',/nodata,position=[xo,yo,dxsiz-xf-1,dysiz-yf-1],/noerase,/device,title=titil')
			      endif else $
			      if D.PLOT ne 2 then begin
				surfbody=congw+congx+congy+',az=rz,ax=rx,xticks=4,yticks=4,zticks=1,title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
			 	surfkey ='' & surf='surface,'
				if styles(0,0) eq 4 then surfkey =''             else $
				if styles(0,0) eq 5 then surfkey =',/lego'       else $
				if styles(0,0) eq 6 then surfkey =',/horizontal'      $
				                    else surf    ='shade_surf,'
				ii=execute( surf+surfbody+surfkey )
			      endif else begin
				surfbody=congw+congx+congy+',xticks=4,yticks=4,zticks=2,xmargin=[10,1],ymargin=[4,2],title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
				surf    ='contour,'
				if styles(1,0) ne 1 then surfkey =',/fill,nlevels=nlv' $
				                    else surfkey =',c_colors=(indgen(nlv)+1)*(180/nlv)+50,nlevels=nlv'
				ii=execute( surf+surfbody+surfkey )
			      endelse
			   endif
			endif

	endif else if totim gt 0 then begin

		if W gt 0 then ppm=long(W*1000*100./totim)<100 else ppm=100
		wset,geo_alp(4) & trap_current=geo_alp(4)
		nk =n_elements(D)
		YYt=reform(geo_w(8 ,D))
		YYl=reform(geo_w(10,D))
		YYm=reform(geo_w(9 ,D))+YYl

		if  nk eq 1 then begin
		    YYt=[YYt,0] & YYm=[YYm,0] & YYl=[YYl,0] & D=[D,0] & endif
		sx ='d'+strtrim(string(D),2)
		if  nk eq 1 then begin nk =2  & sx(1)='  '  & endif
		ttl=    strtrim(string(round(totim/10.)/100.),2)+' Elapse sec.'

		if nk gt 8 then begin
		plot, YYl,xmargin=[2,2],ymargin=[2,2],charsize=.8,font=0,yrange=[0,100],$
		          psym=10,xticks=nk-1,xtickname=sx,title=ttl,ystyle=4,xthick=2,linestyle=1

		oplot,YYm,psym=10,linestyle=2
		oplot,YYt,psym=10,linestyle=0
		if ppm lt 100 then begin YYl(*)=ppm & oplot,YYl,thick=2 & endif

		endif else begin
		YP =[[YYl],[YYm],[YYt]]
		sy =['Command    ','Request  ','Macro']
		sz =[ ' ' , strtrim(string(ppm),2)+'%' ]
		w4d=bytscl(YP,min=0,max=100)>20
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],xticks=nk-1,xtickname=sx,shades=w4d,$
		        title=ttl,/lego,charsize=1.2,font= 0,yticks=2,ytickname=sy,zticks=1,ztickname=sz

		if ppm lt 100 then begin
		YP(*)=ppm
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],/lego,/noerase,$
		        xstyle=4,ystyle=4,zstyle=4,charsize=1.2,font= 0
		endif
		endelse

	endif else if totim eq 0 then begin
		if n_elements(w) gt 1 then begin
		    wset,geo_alp(4) & erase
		    wset,geo_alp(3) & erase
		    wset,geo_alp(0) & erase & tv,W
		endif else begin
		 wset,D
		 if (n_elements(w) eq 1) and (w(0) le 0) then begin
		 ;if w(0) eq 0 then did_fu=0 else did_fu=1
		 endif else begin
		  erase
		 ;did_fu=1
		  inf=2.4
		  eng=sys_dep('MACHINE') & if (eng eq 'win') then inf=3. else if (eng eq 'mac') then inf=1.5
		  geo_info(3)= geo_info(1)-geo_bxy(1)-10
		  geo_info(2)= geo_info(0)-geo_bxy(0)-10
		  wdt=20 & cz=(geo_info(0)/341.33*2) & ct=round(cz) & cz=cz<inf
		  xyouts,wdt-4,14,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,13,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,10,"Values REQUEST ",font=-1,charsize=cz,charthick=ct,/device,color=255,width=wdt
		  wdt=geo_info(0)*wdt
		  wdt=geo_info(0)-1-wdt-20
		  xyouts,wdt-4,44,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,43,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,40,"COMMAND Control",font=-1,charsize=cz,charthick=ct,/device,color=255

		  xf1=(geo_info(0)*2/3) - ((geo_info(0)*2/3)-(geo_bxy(0)/2+20))/4
		  xf2=(geo_info(0)  /3) - ((geo_info(0)  /3)-(geo_bxy(0)/2+20))/4
		  yf1=70 + ((geo_info(3)-10)-(70))/4
		  yf2=40 + ((geo_info(3)-10)-(40))/4
		  plots,[xf1,geo_info(0)*2/3], [yf1,70],thick=2.,/device,color=255
		  plots,[xf2,geo_info(0)  /3], [yf2,40],thick=2.,/device,color=255
		 endelse
		endelse
	endif else if totim eq -1 then begin

		wset,W   &  erase
		xyouts,3,geo_bxy(1)-9,D,charsize=1,/device
		if n_elements(dnum) eq 1  then dw  =geo_w(13,dnum) else dw=0	    ;Delete the large Dial plot.
		if dw gt 0 then begin ii=execute('wdelete,dw')  & geo_w(13,dnum)=0 & endif

	endif else if totim eq -2 then begin

		wset, geo_alp(3)
		device,copy=[0,0, geo_bxy(0),geo_bxy(1)/2, 0,W*25]
		xyouts,0,W*25+1, D ,font=-1,charsize=1.5,charthick=2,/device,color=255

	endif else if totim eq -3 then D=[did_x,did_y,did_wd]

	if keep_w gt 0 then wset,keep_w
end

function P_GEO_Ndials & return,20 & end
;******* ************

pro GEORGEO, init=init, construct=base, timer=bs1, freq=freq, command=intxt, nowin=nowin, lim=lim, duduch=prox
;** *******
;**
;** Construct the base then initiate george (lamp startup)
;** handle a command line for instrument control (from dons)

@lamp.cbk
common c_geo
common c_geweb

	if n_elements(intxt) eq 1 then begin
	   comm=strtrim(intxt,2)
	   if strpos(strupcase(comm),'CTRL:') eq 0 then begin intxt=';' & ln=strlen(comm)
	   		comm=strmid(comm,5,ln)
			typ='PAD' & gen=geo_par2(3)
			if (geo_par2(4) eq '1') then check=1 else check=0
			if strpos(comm,'G:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								gen  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								typ  ='WEB'        & endif
			if strpos(comm,'T:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								typ  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								endif
			if strpos(comm,'K:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								check=strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								on_ioerror,mischk  & check=float(check)
								mischk:            & endif
			comm=str_sep(comm, '<br>') & if n_elements(comm) eq 1 then comm=comm(0)

			d0={GENERIC:gen,NAME:geo_par2(0),TYPE:typ,PROS:long(geo_par2(5:6))} & R=0
			R = DialControl(comm,   d=0, check=check)
			if (R lt 0) or (R gt 1)    then begin print,'error-code '+string(R)
					if geo_web then WebDo,'err','error-code '+string(R) & ENDIF
	   endif
	   return
	endif else $
	if n_elements(base) eq 1 then begin
	   Pn     =P_GEO_Ndials()
	   geo_w  =lonarr(14,Pn+1)
	   geo_vis=Pn/2 -Pn/10
	   geo_bxy=[100,50]
	   if n_elements(geo_freq) eq 0 then begin geo_freq=0 & geo_lim=0 & endif
	   bid=widget_button(base,font=ft_biggest,value='....GET DIALS....',uvalue=[-88,380,0],resource_name="geo")
	   bas=widget_base (base,/column,y_scroll=fix(lamp_siz/2.1)<395)
	   for i=1,((size(geo_w))(2))-1 do begin
		di=strtrim(string(i),2)
		if sys_dep('VERSION') lt 4.0 then bod=widget_base(bas,/column) $
		else bod  =widget_base  (bas,/column,xsize=110)
		bud       =widget_base  (bod,/row)

		if i le geo_vis+4 then begin
	 	  byd     =widget_button(bud,value='d'+di                       ,font=ft_b_normal,menu=2,resource_name="geo")
			bed3   =widget_button(byd ,value='Large Dial'		,font=ft_normal,uvalue=[-88,670,5,i])
			bed1   =widget_button(byd ,value='Reset'		,font=ft_normal,uvalue=[-88,670,1,i])
			bed4   =widget_button(byd ,value='Properties'		,font=ft_normal,uvalue=[-88,670,6,i])
			bed8   =widget_button(byd ,value='Remove'		,font=ft_normal,uvalue=[-88,670,8,i])
			bed2   =widget_button(byd ,value='History is off'	,font=ft_normal,menu=2)
			  bed21=widget_button(bed2,value='Stop recording'	,font=ft_normal,uvalue=[-88,670,2,i])
			  bed22=widget_button(bed2,value='Start recording'	,font=ft_normal,uvalue=[-88,670,3,i])
			  bed23=widget_button(bed2,value='Clear History file'	,font=ft_normal,uvalue=[-88,670,4,i])
			if i le geo_vis  then begin
			bed5   =widget_button(byd ,value='Change Plot'		,font=ft_normal,menu=2)
			  bed51=widget_button(bed5,value='-2 (no plot)'         ,font=ft_normal,uvalue=[-88,671,-2 ,i,bed5])
			  bed51=widget_button(bed5,value='-1 (in W'+di+')'      ,font=ft_normal,uvalue=[-88,671,-1 ,i,bed5])
			  bed51=widget_button(bed5,value=' 0 (scalar,image)'    ,font=ft_normal,uvalue=[-88,671,0  ,i,bed5])
			  bed51=widget_button(bed5,value=' 1 (arrow,surface)'   ,font=ft_normal,uvalue=[-88,671,1  ,i,bed5])
			  bed51=widget_button(bed5,value=' 2 (contour)'         ,font=ft_normal,uvalue=[-88,671,2  ,i,bed5])
			  bed51=widget_button(bed5,value='10 (vector)'          ,font=ft_normal,uvalue=[-88,671,10 ,i,bed5])
			  bed51=widget_button(bed5,value='20 (  ..  )'          ,font=ft_normal,uvalue=[-88,671,20 ,i,bed5])
			  bed51=widget_button(bed5,value='30'                 ,font=ft_normal,uvalue=[-88,671,30 ,i,bed5])
			  bed51=widget_button(bed5,value='50'                 ,font=ft_normal,uvalue=[-88,671,50 ,i,bed5])
			  bed51=widget_button(bed5,value='100'                ,font=ft_normal,uvalue=[-88,671,100,i,bed5])
			  bed51=widget_button(bed5,value='200'                ,font=ft_normal,uvalue=[-88,671,200,i,bed5])
			  bed51=widget_button(bed5,value='500'                ,font=ft_normal,uvalue=[-88,671,500,i,bed5])
			bed6   =widget_button(byd ,value='Own Frequency'      ,font=ft_normal,menu=2)
			  bed61=widget_button(bed6,value='0.00'               ,font=ft_normal,uvalue=[-88,670,80,i,bed6])
			  bed61=widget_button(bed6,value=' .1 '               ,font=ft_normal,uvalue=[-88,670,81,i,bed6])
			  bed61=widget_button(bed6,value=' .5 '               ,font=ft_normal,uvalue=[-88,670,82,i,bed6])
			  bed61=widget_button(bed6,value='1   '               ,font=ft_normal,uvalue=[-88,670,83,i,bed6])
			  bed61=widget_button(bed6,value='2   '               ,font=ft_normal,uvalue=[-88,670,84,i,bed6])
			  bed61=widget_button(bed6,value='4   '               ,font=ft_normal,uvalue=[-88,670,85,i,bed6])
			  bed61=widget_button(bed6,value='10  '               ,font=ft_normal,uvalue=[-88,670,86,i,bed6])
			  bed61=widget_button(bed6,value='30  '               ,font=ft_normal,uvalue=[-88,670,87,i,bed6])
			  bed61=widget_button(bed6,value='60  '               ,font=ft_normal,uvalue=[-88,670,88,i,bed6])
			  bed61=widget_button(bed6,value='240 '               ,font=ft_normal,uvalue=[-88,670,89,i,bed6])
			  bed61=widget_button(bed6,value='600 '               ,font=ft_normal,uvalue=[-88,670,90,i,bed6])
			  bed61=widget_button(bed6,value='1800'               ,font=ft_normal,uvalue=[-88,670,91,i,bed6])
			  bed61=widget_button(bed6,value='3600'               ,font=ft_normal,uvalue=[-88,670,92,i,bed6])
			endif
		endif
		bidof=0
		if (i eq geo_vis+5) and (GEORGE eq 2) then begin
		 cap=0
		 eng=sys_dep('MACHINE') & if eng eq 'win' then cap=3 else if eng eq 'mac' then cap=-2

		 bs1_t =widget_label (bod,font=ft_b_normal,value ='General Freq.' , event_pro='P_GEO_TIMER')
		 bs1_f =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_freq),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bod,font=ft_b_normal,value='Duration:')
		 bs1_d =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_lim ),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bact  =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='no plot,resource_name="geo"')
		 widget_control,bact ,set_uvalue=[-88,660,0,0],set_button=1
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
		if i le geo_vis+4 then $
		   bidof  =widget_button(widget_base(bud,/nonexclusive),uvalue=[-88,665,i],$
						     value='on/off',font=ft_smaller)

		bedou     =widget_label (bud,value="", event_pro='P_GEO_TIMER',uvalue=i)

		geo_w(2 ,i)=bud
		geo_w(3 ,i)=bidof
		geo_w(4 ,i)=byd	;not used at this time!
		geo_w(7 ,i)=bed2
		geo_w(11,i)=bedou
		widget_control,bud  ,sensitive=0
		if i le geo_vis then geo_w(0,i)=widget_draw (bod,retain=2,xsize=geo_bxy(0),ysize=geo_bxy(1),$
							     /button_events,uvalue=[-88,670,7,i])
	   endfor

	endif else $
	if n_elements(bs1)  eq 1 then begin
		eng=sys_dep('MACHINE')
		if eng eq 'win' then begin cap= 3 & scheme=' SCHEME'        & reffre=' frequency:' & dur='Duration:'
		endif           else $
		if eng eq 'mac' then begin cap=-2 & scheme='SCHEME'         & reffre='freq:'      & dur='for:'
		endif           else begin cap= 0 & scheme=' SCHEME'        & reffre='frequency:' & dur='Duration:' & endelse

		if n_elements(lim)  eq 1 then geo_lim =lim  else geo_lim =0
		if n_elements(freq) eq 1 then geo_freq=freq else geo_freq=0
		vaf=strtrim(string(geo_freq),2) & vaf =" 0 "  &  geo_freq=0
		vad=strtrim(string(geo_lim ),2) & if geo_lim le 0 then vad=" "
		geo_onbas=[0L,0L,0L,0L]
		if GEORGE eq 1 then begin
		 bs1_1 =widget_label (bs1,font=ft_biggest ,value = scheme)
		 bs1_t =widget_label (bs1,font=ft_b_normal,value = reffre , event_pro='P_GEO_TIMER')

		 bs1_f =widget_text  (bs1,font=ft_propor  ,value=vaf,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_label (bs1,font=ft_smallest,value='seconds')
		 bs1_1 =widget_button(widget_base(bs1,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bs1,font=ft_normal  ,value='Duration:')
		 bs1_d =widget_text  (bs1,font=ft_propor  ,value=vad,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")

		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]

		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
	endif else $
	if n_elements(prox)  gt 1 then begin
		geo_par2=prox
		SetDuduch,"_send", geo_par2(3,0), prox
		geo_par2=[geo_par2,string(prox)]
	endif else $
	if keyword_set(init) then begin
		setcol,27
		geo_info =lonarr(6)
		P_GEO_DISPLAY, info,0 ,-3                      ;return [did_x,did_y,did_wd]
		geo_info(0)  = info(0) & geo_info(1)=info(1)   ;r=widget_info(did_wd,/geometry)
		geo_info(5)  = did_win0
		P    =geo_bxy(0)   & N=geo_bxy(1)/2
		for i=1,((size(geo_w))(2))-1 do   begin
		    if geo_w(0,i) gt  0  then begin
			   widget_control,bad_id=ii,geo_w(0,i),get_value=j
			   geo_w(1,i)=j
			   di=strtrim(string(i),2)
			   P_GEO_DISPLAY, 'd'+di, j ,-1
		    endif
		endfor
		geo_alp =lonarr(5)
		bid  =widget_base(map=0)
	        geo_alp(0)=widget_draw(bid,retain=2,xsize=2*P,ysize=2 *N)
	        geo_alp(1)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(2)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(3)=widget_draw(bid,retain=2,xsize=  P,ysize=21*N)
	        geo_alp(4)=widget_draw(bid,retain=2,xsize=geo_info(0)/2+30,ysize=geo_info(1)*2/3)
		widget_control,bid,group_leader=lamp_b1,/realize
		widget_control,geo_alp(0),get_value=j & geo_alp(0)=j
		widget_control,geo_alp(1),get_value=j & geo_alp(1)=j
		widget_control,geo_alp(2),get_value=j & geo_alp(2)=j
		widget_control,geo_alp(3),get_value=j & geo_alp(3)=j
		widget_control,geo_alp(4),get_value=j & geo_alp(4)=j
		bid=bindgen(P)*2+55
		bis=bytarr(P,N)  & for i=0,n-1,2 do bis(0,i)=bid
		bid=reverse(bid) & for i=1,n-2,2 do bis(0,i)=bid
		bis=bytscl (bis)
		for i=0,N-1 do bis(P-1-abs((N-1)/2-i)/2:P-1,i)=253*0

		P_GEO_DISPLAY, did_win0, bis ,0

		if GEORGE eq 1 then geo_act=0 else geo_act=1
		if GEORGE eq 1 then P_GEO_DISPLAY, did_win0, 1 ,0

		geo_stat=1 & geo_isw=1 & geo_cur=0 & geo_seq=.0D & geo_timon=dblarr(((size(geo_w))(2))*2)
		geo_lead=lamp_b1       & geo_web=0

		if dial_ini then begin
		 for i=1,((size(geo_w))(2))-1 do begin    di=strtrim(string(i),2)
		    named=''
		    ii=execute ('if n_tags(d'+di+') gt 1 then named=d'+di+'.NAME')
		    if named ne '' then begin
			 dnum =i
			 pth  ='' & DialTag,d=dnum, tag="PATH",get=pth
			 DialInit , named,  d=dnum, path=pth, /restore
		    endif
		 endfor
		endif  else dial_ini=1
	endif else $
	if keyword_set(nowin) then begin
		Pn       =P_GEO_Ndials()    ;
		geo_freq =0                 ;General Timer
		geo_timon=dblarr((Pn+1)*2)  ;Time on Timer start process
		geo_lim  =0                 ;General Timer limit
		geo_par2 =['','','','','','-1','0'] ;Contains "dial_pad_init" table
		dial_ini =1
		geo_stat =0                 ;General Timer is on or off
		geo_act  =0                 ;0:plot Activity  1:output strings
		geo_web  =0                 ;1:outputs for web mirror
		geo_alp  =[0L,0L,0L,0L,0L]  ;BaseId  for pixmap plotting
		geo_vis  =0                 ;Visible short Dials
		geo_w    =lonarr(14,Pn+1)   ;0:drawBase    1:drawId  2:sensBase  3:OnOffButton
		                            ;4:HiLightBase 5:previous active dial (geo_cur) 6:has a dial
		                            ;7:HistoryBase 8:time in Macro 9:time in Get 10:time in Send
		                            ;11:Specific timer base  12:in the general or spec loop(2,1)
		                            ;13:large drawId
		geo_info =lonarr(6)         ;0:draw.xsize  1:draw.ysize  4:last dial scheme  5:did_win0
		geo_bxy  =[0,0]             ;short drawBase size
		geo_isw  =0                 ;0 for noWindow
		geo_cur  =0                 ;Current active Dial
		geo_onbas=[0L,0L,0L,0L]     ;BaseId for text & on/off Timer button & limit & Timer
		geo_lead =lamp_b1           ;Group Leader
		geo_seq  =.0D               ;Current Time (double flt)
	endif
end

;	***************************
	     pro myhelp, TEXT
;	***************************

;This is effective when the string-array TEXT is more than one element.

text=['This text is printed when the user clicks on the first ? of lamp']

end

;
;				******************
;				*** Super_Plot ***
;				******************
; 			a graphical tool to compare scans
;
; 			Written by JOUFFREY Romuald
; 			August,September,October, November, ..., etc 1995
; 			(Hoping this Help...)
;
; V01.20 09/09/96

; Procedures of this file are :
;
; *************************** Procedures
; p_rom_super_event           Event Manager for Super_Plot
; p_rom_super_plot		Plots making procedure
; p_rom_super_select		plot Getting procedure
; p_rom_super_filter		filter/copy local workspaces for plotting
; p_rom_super_done		Done button was pushed
; p_rom_cleanup, id		called when window is killed to restore colors
; p_rom_redefine_slider
; p_rom_send_txt_wd
; ***************************** Widgets Creating Procedure
; superplot, widx	Create Super_plot Interface
;
; Little explanation on variables
; - Each Super_Plot Variable begins with s_
; - Local variables are normaly named
; - sw_ stands for Super_Plot Widgets identifier variables
; - sc_ stands for Super_Plot Commons
;
; The event procedure for superplot is called by the event_lamp_parser
; which gives it back the Uvalue as a parameter, so superplot interface
; is a real part of the whole Lamp package.


; *****************************************************************************
pro p_rom_super_event, event, test ;*******************************************
; *****************************************************************************
;
; Called when an event is generated by Super_Plot widgets tree
;

@lamp.cbk				; call back the lamp common block
common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common sc_superdid ,s_sym,s_err, $	; Array of boolean Set for psym , error
		s_lv,s_lx,s_lbx,s_lby   ; For live annotation
common sc_supordid ,s_xylv,s_xylw       ; For XY limits and there widgets + log10 + linear

common sc_superplot,s_wid,$		; # of the workspace processed (string)
		s_siz,    $		; The size of current workspace processed
		s_wset,   $		; # of the draw window
		s_hid,    $		; Array of boolean Set if hided
		s_scl,    $		; Array of boolean Set if scaled
		s_hid2,   $		; as s_hid but when s_cutall is set
		s_off_arr,$		; Array of idx
		s_num_wrk,$		; Array of workspace number
		s_cut,    $		; Array of boolean Set if cutting x
		s_cut_values, $		; Array of cutting values
		s_xcut,	  $		; Boolean set if cutting X
		s_filter, $		; Boolean set if filter is on
		s_color,  $		; Boolean set if colored mode
		s_show_err, $		; boolean set if show error is on
		s_normalize, $		; Boolean set if normalization is on
		s_cutall, $		; Boolean set if cutting apply to all
		s_psymb,  $		; Boolean set if plot symbol is on
		s_xmin,   $		; xmin range value (%)
		s_xmax,   $		; xmax range value (%)
		s_ctred,  $		; buffer for user color palet (red)
		s_ctgreen,$		; " (green)
		s_ctblue, $		; " (blue)
		s_scratio,$		; float (maximum scale ratio)
		s_printno,$		; int (number of next print)
		s_var1,   $
		s_var2,   $
		s_var3,   $
		s_var4,   $
		s_yscale, $		; Y scale percentage
		s_yoffset,$		; Y Offset percentage
		s_0,s_1,s_2,s_3,s_4,s_5,s_6, $	      ; local workspaces (data)
		s_e0,s_e1,s_e2,s_e3,s_e4,s_e5,s_e6, $ ; local errors
		s_x0,s_x1,s_x2,s_x3,s_x4,s_x5,s_x6, $ ; X vectors for data arrays
		s_p0,s_p1,s_p2,s_p3,s_p4,s_p5,s_p6, $ ; plotted local workspaces
		sw_id,    $		; widget id of multi_plot widget tree
		sw_drw,   $		; array of id widget draw  (0->5)
		sw_hid,   $		; array of id widget button(0->5)
		sw_lab,   $		; array of id widget label (0->5)
		sw_err      	; Widget of the 'Error message' label

;WIDGET_CONTROL, event.id, Get_UValue = test
siz_test = size(test)
t1 = test(0)				; always -88 (Lamp event)
IF siz_test(1) gt 1 then t2 = test(1)	; code of the event
IF siz_test(1) gt 2 then t3 = test(2)	; another code for the event
IF siz_test(1) gt 3 then t4 = test(3)	; id of cut slider
IF siz_test(1) gt 4 then t5 = test(4)	; id of cut label
IF siz_test(1) gt 5 then t6 = test(5)	; id of X Button
IF siz_test(1) gt 6 then t7 = test(6)	; id of Y Button
IF siz_test(1) gt 7 then t8 = test(7)	; id of cutting base
IF siz_test(1) gt 8 then t9 = test(8)	; id of Workspace slider

CASE t2 OF
    353:BEGIN ; *************************** Worspace Modification
	CASE t3 OF
	    0 : BEGIN ; ------------------------------------ Worspace slider moved
		    p_rom_super_select,test,2	; Process new selection
		END
	    1 : BEGIN ; ------------------------------------ Cut slider moved
		    p_rom_super_select,test,1	; Process new selection
		END
	    2 : BEGIN ; ------------------------------------ X Button Pushed
		    s_xcut = 1			; Set flag xcut on
		    p_rom_super_select,test,1	; Process new selection
		END
	    3 : BEGIN ; ------------------------------------ Y Button Pushed
		    s_xcut = 0			; Set flag xcut off
		    p_rom_super_select,test,1	; Process new selection
		END
	    ENDCASE
	END
    354:BEGIN ; *************************** Plotting parameters modification
	CASE t3 OF
	    0 : BEGIN ; ------------------------------------ XMin slider moved
		    old_s_xmin = s_xmin
		    s_xmin = event.value
		    s_var1 = 1 & s_var2 = 0
		    IF old_s_xmin ne s_xmin THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    1 : BEGIN ; ------------------------------------ XMax slider moved
		    old_s_xmax = s_xmax
		    s_xmax = event.value
		    s_var2 = 1 & s_var1 = 0
		    IF old_s_xmax ne s_xmax THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    2 : BEGIN ; --------------------------------- Y_scale slider moved
		    old_s_yscale = s_yscale
		    if s_yscale lt 0 THEN s_yscale = -(event.value) ELSE $
		    			  s_yscale = (event.value)
		    IF old_s_yscale ne s_yscale THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    3 : BEGIN ; --------------------------------- Y Offset slider moved
		    old_s_yoffset = s_yoffset
		    s_yoffset = event.value
		    IF old_s_yoffset ne s_yoffset THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    4 : BEGIN ; --------------------------------- Button one event
		    s_cutall = 3
		    FOR i=1,6 do BEGIN
			IF s_num_wrk(i) gt 0 then BEGIN   ; if a W is defined
			    wid = strtrim(string(s_num_wrk(i)),2)
			    V = s_cut_values(i)
			    siz=0 & res = execute('siz = Size(w' +wid+')')
			    IF siz(0) eq 2 THEN BEGIN ; IF WKS is bi-dimensional
				if s_cut(i) THEN BEGIN
				    didsx=0 & res = execute('didsx=size(x'+wid+')')
				    if didsx(0) ne 1 then st=V+1 else $
				      res=execute('st = x'+wid+'(V)')
				    ii = strmid(strtrim(string(st),2),0,5)
			 	    ss='W'+wid+' '+w_numor(FIX(wid))+' X='+ii
				ENDIF ELSE BEGIN
				    didsy=0 & res = execute('didsy=size(y'+wid+')')
				    if didsy(0) ne 1 then st=V+1 else $
				      res=execute('st = y'+wid+'(V)')
			 	    ii = strmid(strtrim(string(st),2),0,5)
				    ss='W'+wid+' '+w_numor(FIX(wid))+' Y='+ii
				ENDELSE
		            WIDGET_CONTROL, bad_id=j,sw_lab(i-1),Set_Value=ss
			    ENDIF ELSE ss='W'+wid+' '+w_numor(FIX(wid))
			ENDIF
		    ENDFOR
		    p_rom_super_select,test,1	; Process new selection
		END
	    5 : BEGIN ; --------------------------------- Button all event
		    s_cutall = 1
		    p_rom_super_select,test,1	; Process new selection
		END
	    6 : BEGIN ; --------------------------------- Button scale 0
		   s_yscale = -s_yscale
		   p_rom_super_plot,0	; Redraw
		END
	    7 : BEGIN ; --------------------------------- Just redraw
		   p_rom_super_plot,0	; Redraw
		END
	    ENDCASE
	END
    355:BEGIN ; *************************** Local W parameters modification
	; Here t4 is the number of processed local workspace
	CASE t3 OF

	    0 : BEGIN ; ------------------------- Keep Button Pushed
		    s_hid(0) = 1		        ; m_0 is now undrawable
		    s_hid(t4)= 0			; m_# t4 becomes drawable
		    s_sym(t4)=s_psymb			; psym  flag
		    s_err(t4)=s_show_err		; error flag
		    WIDGET_CONTROL, bad_id = i, sw_hid(t4-1), Set_Button=0
        	    s = strtrim(string(t4),2)	; t4 = # of local dataset
		    res = execute('s_' +s+ '=s_0')	; copy s_0 in s_i
		    res = execute('s_e'+s+ '=s_e0')	; copy s_e0 in s_ei
		    res = execute('s_x'+s+ '=s_x0')	; copy s_x0 in s_xi
		    i=0. & ii='' & V = 0
		    sw_scut=t5
		    WIDGET_CONTROL, bad_id=i,sw_scut,Get_Value = V & V=V-1
		    siz=0 & res = execute('siz = Size(w' +s_wid+')')
		    IF siz(0) eq 2 THEN BEGIN ; IF WKS is bi-dimensional
			IF s_xcut then BEGIN
			    didsx=0 & res = execute('didsx=size(x'+s_wid+')')
			    if didsx(0) ne 1 then i=V+1 else $
			      res=execute('i = x'+s_wid+'(V)')
			    ii = strmid(strtrim(string(i),2),0,5)
			    s='W'+s_wid+' '+w_numor(FIX(s_wid))+'X='+ii
			ENDIF ELSE BEGIN
			    didsy=0 & res = execute('didsy=size(y'+s_wid+')')
			    if didsy(0) ne 1 then i=V+1 else $
			      res=execute('i = y'+s_wid+'(V)')
			    ii = strmid(strtrim(string(i),2),0,5)
			    s='W'+s_wid+' '+w_numor(FIX(s_wid))+' Y='+ii
			ENDELSE
		    ENDIF ELSE s='W'+s_wid+' '+w_numor(FIX(s_wid))
		    s_cut_values(t4)=V		; store idx of cut for 'cut one' mode
		    s_cut(t4)=s_xcut		; store cutting axis
		    s_off_arr(t4)=V		; store idx of cut for plot idx
		    s_off_arr(0)=-1		; s_0 offset inactivated
		    s_num_wrk(t4)=FIX(s_wid)	; store number of kept workspace
		    s_num_wrk(0)=-1		; s_0 offset inactivated
		    WIDGET_CONTROL, bad_id=i, sw_lab(t4-1), Set_Value = s
		    p_rom_super_filter		; process filtering
		    p_rom_super_plot,0		; Redraw
		END
      	    1 : BEGIN ; ------------------------- Hide Button event
		    s_hid(t4) = event.select	; t4 = # of local dataset
		    i = strtrim(string(t4),2)
		    s_s = [0]
		    res = execute('s_s = SIZE(s_'+i+')')
		    IF s_s(0) ne 0 THEN BEGIN
			p_rom_super_plot,0	; Redraw
		    ENDIF
        	END
    	    2 : BEGIN ; ------------------------- Scale Button event
		    s_scl(t4) = event.select	; t4 = # of local dataset
		    p_rom_super_plot,0		; Redraw
		END
    	    3 : BEGIN ; ------------------------- Clean Out Button pushed
		    s_hid=[1,1,1,1,1,1,1]	; each plot is undrawable
		    s_0 = 0			; erase local workspace 0
		    s_siz = size(s_0)
		    s_1=s_0 & s_2=s_0 & s_3=s_0	; and 1 to 6
		    s_4=s_0 & s_5=s_0 & s_6=s_0
		    s_p1=s_0 & s_p2=s_0 & s_p3=s_0 ; Erase plotted Workspaces
		    s_p4=s_0 & s_p5=s_0 & s_p6=s_0
		    s_off_arr =[-1,-1,-1,-1,-1,-1,-1]
		    s_num_wrk =[-1,-1,-1,-1,-1,-1,-1]   ; Clear workspace number array
		    s_cut_values=[-1,-1,-1,-1,-1,-1,-1]	; Clear cutting values
		    FOR j=0,5 do BEGIN		; Reset widget values
			WIDGET_CONTROL, bad_id=i, sw_hid(j), Set_Button=0
			WIDGET_CONTROL, bad_id=i, sw_lab(j), Set_Value=' '
		    ENDFOR
		    s_xmin = 0 & s_xmax = 500
		    s_var1 = 0 & s_var2 = 0
		    s_yscale  =  s_scratio
		    s_yoffset =  0		; no yoffset
		    s_xylv(*) =  0		; For XY limits
		    WIDGET_CONTROL, bad_id=i,s_xylw(0), Set_Value = ""
		    WIDGET_CONTROL, bad_id=i,s_xylw(1), Set_Value = ""
		    WIDGET_CONTROL, bad_id=i,s_xylw(2), Set_Value = ""
		    WIDGET_CONTROL, bad_id=i,s_xylw(3), Set_Value = ""

		    WIDGET_CONTROL, bad_id=i, t4      , Set_Value = 0		;slider offset
		    WIDGET_CONTROL, bad_id=i, t5      , Set_Value = s_scratio	;slider yscale
		    WIDGET_CONTROL, bad_id=i, t6      , Set_Value = 0		;slider xmin
		    WIDGET_CONTROL, bad_id=i, t7      , Set_Value = 500		;slider xmax
		    WSET, s_wset
		    ERASE, 255			; Clear draw window
		END
    	    4 : BEGIN ; ------------------------- Normalize all Button event
		    s_normalize = event.select
		    p_rom_super_plot,0 		; Redraw
		END
	    5 : BEGIN ; ------------------------- Filter Button event
		    s_filter = event.select
		    p_rom_super_filter 		; process filtering or copy
		    p_rom_super_plot,0		; Redraw
		END
	    6 : BEGIN ; ------------------------- Colored Button event
		    s_color = event.select
		    IF s_color then BEGIN
			TVLCT, s_ctred, s_ctgreen, s_ctblue, /GET
			s_ddr	=[100,250, 20, 20,250, 5 ,250]
			s_ddg	=[100, 20,250, 20,250,250, 10]
			s_ddb	=[100, 20, 20,250, 20,250,250]
			TVLCT, s_ddr  , s_ddg    , s_ddb ,2
		    ENDIF ELSE BEGIN
			TVLCT, s_ctred, s_ctgreen, s_ctblue
		    ENDELSE
		    FOR j=0,5 do BEGIN
			WIDGET_CONTROL,bad_id=i,sw_drw(j) ,Get_Value = w
			wset, w
			IF s_color then ERASE, j+3 else BEGIN   ;j*(!D.n_colors/9)+7
			    erase, 255
			    PLOTS, 0,13, /Device
			    PLOTS, FIndGen(49), SIN(FIndGen(49)/7)*10+13, /Continue, Color = 1, LineStyle = j, /Device
			ENDELSE
		    ENDFOR
		    p_rom_super_plot,0		; Redraw
		END
	    7 : BEGIN ; ------------------------- Show errors Button event
		    s_show_err = event.select
		    p_rom_super_plot,0		; Redraw
		END
	    8 : BEGIN ; ------------------------- Plot Symbol Button event
		    s_psymb = event.select
		    p_rom_super_plot,0		; Redraw
		END
	    9 : BEGIN ; ------------------------- Log10 scaling
		    s_xylw(4) = event.select
		    p_rom_super_plot,0		; Redraw
		END
	  10  : BEGIN ; ------------------------- Linear X axis (index)
		    s_xylw(5) = event.select
		    p_rom_super_plot,0		; Redraw
		END
	    ENDCASE
	END
    356:BEGIN ; *************************** Others global events
	CASE t3 OF
	    0 : BEGIN ; ------------------------- Print Button Pushed
		    PsFile = 'super_p'	    ; construct PS filename
		    doit=0
		    FOR i=6,0,-1 do BEGIN
		    	IF NOT(s_hid(i)) and NOT(s_hid2(i)) then BEGIN
			    IF s_num_wrk(i) gt 0 THEN doit=s_num_wrk(i)
			ENDIF
		    ENDFOR
		    IF doit gt 0 THEN BEGIN
			PsFile=PsFile+STRTRIM(STRING(s_printno), 2)+'.ps'
		        PRINT, 'Print Generating : '+PsFile
			wplot = !D.name
			on_ioerror, iferr
		        set_plot,'PS' & sx=7. & sy=11.5
		        device, yoffset=sy-0.5,xoffset=.5,/inches,/Landscape
			device, filename=PsFile
			device, bits_per_pixel=8,/color
			p_rom_super_plot,1	; Redraw with print option
			ii=execute('P_DID_PS_HEADER,7.,doit,PsFile')
			s_printno=s_printno+1
			iferr :
			DEVICE,/close
			set_plot, wplot
		    ENDIF ELSE PRINT, string(7B)+'no print generated'
		 END
	    1 : p_rom_super_done		; DONE Button pushed

	    2 : BEGIN ; ------------------------- Motion event
	    		if trap_current eq s_wset then begin
			WSET,s_wset
			tmXYZ=CONVERT_COORD(event.X,event.Y,/dev,/to_data)
			XV=tmXYZ(0) & YV=tmXYZ(1) ;CURSOR,XV,YV ,/nowait,/data
			tx1='X='+strtrim(string(XV),2) & ty1='Y='+strtrim(string(YV),2)
			widget_control,bad_id=i,t4,set_value=tx1
			widget_control,bad_id=i,t5,set_value=ty1
			endif
		 END
	    3 : if n_elements(s_lv) gt 1 then BEGIN ; -------- Live Tools
			ii=execute('LIVE_LAMP_PLOT, 1, s_lx, s_lv, xrange=s_lbx, yrange=s_lby')
	  	 ENDIF
	    4 : BEGIN ; ------------------------- Png Button Pushed
		    PsFile = 'super_p'	    ; construct filename
		    doit=0
		    FOR i=6,0,-1 do BEGIN
		    	IF NOT(s_hid(i)) and NOT(s_hid2(i)) then BEGIN
			    IF s_num_wrk(i) gt 0 THEN doit=s_num_wrk(i)
			ENDIF
		    ENDFOR
		    IF doit gt 0 THEN BEGIN
			PsFile=PsFile+STRTRIM(STRING(s_printno), 2)+'.png'
		        PRINT, 'Generating : '+PsFile
			p_rom_super_plot,2	; Redraw with print option
			r=0 & buf=tvrdd(r,g,b)
			if n_elements(r) le 1 then tvlct ,r,g,b ,/get
			WRITE_KIF,PsFile,buf,r,g,b
			s_printno=s_printno+1
		    ENDIF ELSE PRINT, string(7B)+'no PNG generated'
		 END
	    ENDCASE
	END
    ENDCASE
END

; *****************************************************************************
pro p_rom_super_plot, psp ;****************************************************
; *****************************************************************************
;
; The plotting procedure
; psp stands for PoScript Printing=1 or PNG=2
; if psp eq 1 then p_rom_super_plot is used to print on Postcript device
;

@lamp.cbk
common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common sc_superdid			; Array of boolean Set for psym
common sc_supordid			; For XY limits and there widgets
common sc_superplot			; Call Back Super_Plot block

if s_xylw(5) then begin XMin=0 & XMax=n_elements(s_x0)-1
endif else XMin = Min(s_x0,Max=XMax)	; Default Values for XMin, XMax
           YMin = Min(s_0 ,Max=YMax)	; and YMin, Ymax

FOR i=1,6 do BEGIN			; For each local data set
    s_s=[0] & si= strtrim(string(i),2)
    res = execute('s_s = size(s_'+si+')')
    IF s_s(0) ne 0 THEN BEGIN
	tmp = 0.
	tmm = 0.
	si = strtrim(string(i),2)
	if s_xylw(5) then begin tmp=0 & res = execute('tmm=n_elements(s_x'+si+')-1')
	endif else res = execute('tmp = Min(s_x' +si+',max=tmm)')
	if XMin gt tmp then XMin = tmp	; Calculate XMin ...
	if XMax lt tmm then XMax = tmm	; Calculate XMax ...
	res = execute('tmp = Min(s_'  +si+',max=tmm)')
	if YMin gt tmp then YMin = tmp	; Calculate YMin ...
	if YMax lt tmm then YMax = tmm 	; Calculate YMax
    ENDIF
ENDFOR

; Limited values for YMin, Ymax, XMin, XMax
s_xylv(*)=0
on_ioerror,misbit
WIDGET_CONTROL,bad_id=i,s_xylw(0),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm1=float(bitx) else tm1=YMin
WIDGET_CONTROL,bad_id=i,s_xylw(1),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm2=float(bitx) else tm2=YMax
s_xylv(0)=tm1 & s_xylv(1)=tm2 & misbit:on_ioerror,misbot

WIDGET_CONTROL,bad_id=i,s_xylw(2),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm1=float(bitx) else tm1=XMin
WIDGET_CONTROL,bad_id=i,s_xylw(3),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm2=float(bitx) else tm2=XMax
s_xylv(2)=tm1 & s_xylv(3)=tm2 & misbot:

if s_xylv(1) gt s_xylv(0) then begin YMin=s_xylv(0) & YMax=s_xylv(1) & endif
if s_xylv(3) gt s_xylv(2) then begin XMin=s_xylv(2) & XMax=s_xylv(3) & endif

; ---------------------------------- if scale 0 button is set
if s_yscale lt 0 THEN BEGIN
    butscl0=1
    s_yscale=-s_yscale
ENDIF ELSE butscl0=0

; ---------------------------------- calculate correct XRange (sliders)
if (s_var1 eq 0) and (s_var2 eq 0) then BEGIN
    XMinP =XMin + (XMax-XMin)/500.*s_xmin
    XMaxP =XMax - (XMax-XMin)/500.*(500.-s_xmax)
    s_var3 = XMinP
    s_var4 = XMaxP
ENDIF

if s_var1 eq 1 then BEGIN
    XMinP =XMin + (s_var4-XMin)/500.*s_xmin
    s_var3 = XMinP
    XMaxP = s_var4
ENDIF
if s_var2 eq 1 then BEGIN
    XMaxP =XMax - (XMax-s_var3)/500.*(500.-s_xmax)
    s_var4 = XMaxP
    XMinP = s_var3
ENDIF


; ---------------------------------- calculate correct YRange
; gjk touched here!!!

  YMinP = YMin
  YMimi = YMin
  YMaxP = YMax

  if s_xylw(4) then begin
     YMinP=alog10(YMinP>1E-9)
     YMinP=YMinP>0
     YMimi=YMinP
     YMaxP=alog10(YMaxP>1E-8)
  endif

  if butscl0 eq 1 THEN YMinP = 0

  if s_normalize then begin
     YMinP=YminP/abs(YMaxP)
     YMaxP=1.1
  endif else begin
     YMaxP=YMaxP*1.1
  endelse
; gjk end of touch

; ---------------------------------- Calculate yoffset ...
IF s_yoffset ne 0 THEN BEGIN	; .. if offset slider not equal 0
    ; ------------------------------ Adapt array of offset on s_cutall
    ; --- woffarr is a local OFFSET Array declared for the process, it permit ...
    ; --- to preserve both s_off_arr (idx of cutting) and s_num_wrk (# of W)
    IF (s_cutall eq 1) then woffarr=s_num_wrk ELSE woffarr=s_off_arr
    IF s_normalize THEN yoffset = float(s_yoffset/100.)*float(s_yscale/s_scratio) $
    		   ELSE yoffset = float(s_yoffset/100.)*float(s_yscale/s_scratio)*(YmaxP-YminP)
    IF s_hid(0) then s_off_arr(0)=-1
    off_arr=woffarr
    woffarr2=intarr(n_elements(where(woffarr ge 0)), 2)
    woffarr2(*, 0)=woffarr(where(woffarr ge 0))
    woffarr2(*, 1)=indgen(n_elements(where(woffarr ge 0)))
    woffarr2(*,1)=woffarr2(SORT(woffarr2(*,0)),1)
    j=0				; replace data where it is greater or equal 0
    FOR i=0, 6 DO BEGIN
	IF off_arr(i) GE 0 THEN BEGIN
	    off_arr(i)=woffarr2(j, 1)
	    j=j+1
	ENDIF
   ENDFOR
   YMaxP = YMaxP + Max(off_arr)*yoffset; Adapt YMaxP with offset
ENDIF ELSE BEGIN			; s_yoffset = 0
    yoffset = 0.
    off_arr =[0,0,0,0,0,0,0]
ENDELSE

s_lx = s_x0
IF n_elements(s_x1) gt n_elements(s_lx) then s_lx = s_x1
if n_elements(s_x2) gt n_elements(s_lx) then s_lx = s_x2
if n_elements(s_x3) gt n_elements(s_lx) then s_lx = s_x3
if n_elements(s_x4) gt n_elements(s_lx) then s_lx = s_x4
if n_elements(s_x5) gt n_elements(s_lx) then s_lx = s_x5
if n_elements(s_x6) gt n_elements(s_lx) then s_lx = s_x6

; ---------------------------------- printing or not printing ?
subt='' & tit ='' & xtit='' & ytit=''
lwth=1
IF psp gt 0 THEN BEGIN           ; printing ...
    IF s_color THEN $
    styles=['Grey:','Red:','Green:','Blue:', 'Yel:','wBlue:','Pink:'] $
    else $
    styles=['Grey:','___','...','_ _', '._._.','..._','__ __']

    FOR i=0, 6 DO BEGIN
    IF NOT(s_hid(i)) and NOT(s_hid2(i)) THEN BEGIN
	IF s_num_wrk(i) gt 0 THEN BEGIN
	    st1= strtrim(string(s_num_wrk(i)),2)
	    IF s_cut(i) eq 1 then st2='x' ELSE st2='y'
	    st3= strtrim(string(s_cut_values(i)),2)
	    IF s_cut(i) eq 1 THEN $
	       str0='x'+strtrim(string(s_num_wrk(i)), 2)+'('+ $
		          strtrim(string(s_cut_values(i)), 2)+')' ELSE $
	       str0='y'+strtrim(string(s_num_wrk(i)), 2)+'('+ $
		          strtrim(string(s_cut_values(i)), 2)+')'
	    res=execute('str0='+str0)
	    st4= strtrim(string(str0),2)
	    xtit = x_tit    (s_num_wrk(i))
	    ytit = y_tit    (s_num_wrk(i))
	    if psp eq 2 then $
	    tit = w_tit    (s_num_wrk(i))
	    subt =subt +styles(i)+'W'+st1 + st2 + st4+'  '
	ENDIF
    ENDIF
    ENDFOR
ENDIF
IF psp ne 1 then  WSET, s_wset		   ; ... set the correct window to plot in

tvlct ,pos_r  ,pos_g ,pos_b ,/get
tmp=fix(pos_r)+pos_g +pos_b
pop=min(tmp) & ccol=!C
pup=max(tmp) & bcol=!C

;if s_color then ccol=1 else ccol=7

if psp eq 1 then begin if pop eq 0 then bcol=ccol
endif
; ---------------------------------- Do the plot without dataset with axis

s_lbx=[XMinP,XMaxP]
s_lby=[YMinP,YMaxP*(s_yscale/s_scratio)]
s_lv =0
s_lvd=0
s_lvc=0
trap_current=s_wset
PLOT, s_lx,XRange=s_lbx, YRange=s_lby, title = tit, SubTitle=subt, xtick_get=V, $
			XTitle=xtit, YTitle=ytit,/NoData, Background=bcol,color=ccol
if s_xylw(5) then $
PLOT, s_lx,XRange=s_lbx, YRange=s_lby, title = tit, SubTitle=subt, xtickv=s_lx(V), $
			XTitle=xtit, YTitle=ytit,/NoData, Background=bcol,color=ccol

; ---------------------------------- Plot local workspaces #1 to 6

FOR i=1,6 do begin
    s_s=[0] & si= strtrim(string(i),2)

    si2 = strtrim(string((i-1)*(s_color ne 1)),2)
    res = execute('s_s = size(s_'+si+')')
    c = (((i-1)*(!D.n_colors/9)+7)*FIX(s_color eq 1))>ccol

    IF s_s(0) ne 0 THEN $		; plot only not empty workspace
	IF not(s_hid(i)) and not(s_hid2(i)) THEN BEGIN ; and not hided workspace

	   ;gjk The following line makes a start on getting the normalisation correct
	    res =execute('s_lvd=s_p'+si)
	    if s_xylw(4) then s_lvd=alog10(s_lvd>1E-9)
	    YNor=max(s_lvd)

	    YNor = FLOAT(s_normalize ne 1)+YNor*FLOAT(s_normalize eq 1)
	   ; ------------------------------ Calculate scaling parameter
	   ; if local w isn't scaled, then yscale=s_scratio/s_yscale else yscale=1
	   ; this is to cancel the effect of YRange modified by s_yscale

	    yscale = FLOAT(s_scl(i) eq 1)+(s_yscale/s_scratio)*FLOAT(s_scl(i) ne 1)
	    Numerator  =      '/YNor-YMimi)*yscale)+yoffset*off_arr(i)'
	    s_lvd=(YMimi+(s_lvd/YNor-YMimi)*yscale)+yoffset*off_arr(i)
	    psymb=s_sym(i)*i & IF psymb GE 3 THEN psymb=psymb+1
	    IF psymb EQ 0 THEN psymb=!P.PSYM
	    if s_xylw(5) then s_xn='' else s_xn=', s_x'+si
	    st  = 'OPLOT'+s_xn+',s_lvd ,color=c, PSym=psymb, linestyle='+si2+',thick=lwth'
	    if (s_color) then c=i+2 else c=ccol
	    v=n_elements(s_lvd) & vl=400
	    IF psp eq 1 THEN lwth=3 else if v gt vl then lwth=1 else lwth=2
	    res = execute(st)
	    if (s_color) and (v le vl*(1+4*sqrt(psp))) then begin c=2 & lwth=1
	                                              res = execute(st) & c=i+2 & endif
	    if n_elements(s_lv) eq 1 then begin s_lv=s_lvd & s_lvc=s_lx(0)+n_elements(s_lx)
	    endif else begin s_lf=0 & res=execute('s_lf=s_x'+si+'(0)+n_elements(s_x'+si+')')
				if (size(s_lv))(1) eq n_elements(s_lvd) then $
				if s_lf eq s_lvc then s_lv=[[s_lv],[s_lvd]]
	    endelse
	    ; ------------------------------ Plotting corrected data versus errors
	    IF s_err(i) THEN BEGIN ee=0
		res = execute('ee=s_e'+si)
		res = execute('wmax=MAX(s_'+si+')')
		IF N_ELEMENTS(ee) LE 1 THEN BEGIN
		    res = execute('s_e'+si+'=SQRT(s_'+si+')')
		    res = execute('ee=s_e'+si)
		ENDIF
		IF MAX(ee)*(wmax+1) eq sqrt(wmax) THEN BEGIN
		    opp1='*(1+ee)'
		    opp2='*(1-ee)'
		ENDIF ELSE BEGIN
		    opp1='+ee'
		    opp2='-ee'
		ENDELSE
		if not s_xylw(4) then begin
			ee=ee/YNor
			keepcol=!P.COLOR & !P.COLOR=c
			st  = 'ERRPLOT'+s_xn+', s_lvd'+opp1+ ', s_lvd'+opp2
			res = EXECUTE(st)
			!P.COLOR=keepcol
		endif
	    ENDIF
	ENDIF
ENDFOR

; ---------------------------------- plot local workspace #0
IF s_siz(0) ne 0 THEN $
    IF NOT(s_hid(0)) and not(s_hid2(0)) THEN BEGIN

	s_lvd=s_p0
	if s_xylw(4) then s_lvd=alog10(s_lvd>1E-9)
	YNor=max(s_lvd)

	YNor = FLOAT(s_normalize ne 1)+YNor*FLOAT(s_normalize eq 1)
	s_lvd= YMimi+(s_lvd/YNor-YMimi)  +yoffset*off_arr(0)
	if s_xylw(5) then s_xn='' else s_xn=', s_x0'
	if (s_color) then c=2 else c=ccol
	st  = 'OPLOT'+s_xn+',s_lvd ,Thick=1+s_color,color=c, PSym=7*s_psymb'
	res = execute(st)

	if n_elements(s_lv) eq 1 then s_lv=s_lvd $
	else begin 	s_lf=s_x0(0) + n_elements(s_x0)
			if (size(s_lv))(1) eq n_elements(s_lvd) then $
			if s_lf eq s_lvc then s_lv=[[s_lv],[s_lvd]]
	endelse
	; ------------------------------ Plotting corrected data versus errors
	IF s_show_err THEN BEGIN
		IF N_ELEMENTS(s_e0) LE 1 THEN BEGIN
		   s_e0=SQRT(s_0)
		ENDIF
		wmax=MAX(s_0)
		ee=s_e0
		IF MAX(ee)*(wmax+1) eq sqrt(wmax) THEN BEGIN
		    opp1='*(1+ee)'
		    opp2='*(1-ee)'
		ENDIF ELSE BEGIN
		    opp1='+ee'
		    opp2='-ee'
		ENDELSE
		if not s_xylw(4) then begin
			ee=ee/YNor
			keepcol=!P.COLOR & !P.COLOR=2
			st  = 'ERRPLOT'+s_xn+', s_lvd'+opp1+ ', s_lvd'+opp2
			res = EXECUTE(st)
			!P.COLOR=keepcol
		endif
	ENDIF
    ENDIF

; ---------------------------------- reset y_scale if negative
IF butscl0 eq 1 THEN s_yscale=-s_yscale

END

; *****************************************************************************
pro p_rom_super_select,test, flg ;*********************************************
; *****************************************************************************
;
; Called when a NEW Workspace is selected
; (New Workspace number, Cutting Axis or Cutting Value)
; flag is gt 0 if a new workspace is invoked
; flag eq 2 if workspace slider was moved, to invoke new w in cuting all mode
;

@lamp.cbk			; call back the lamp common block
common sc_superplot		; Call Back Super_Plot block

sw_scut = test(3)	; id of cut slider
sw_lcut = test(4)	; id of cut label
sw_bty  = test(6)	; id of Y Button
sw_cutb = test(7)	; id of cutting base
sw_sw   = test(8)	; id of workspace slider

IF (flg eq 2 and s_cutall eq 1) or (flg gt 0 and s_cutall ne 1) THEN BEGIN
    WIDGET_CONTROL,bad_id=i,sw_sw,Get_Value = widx ; Get selected Workspace #
    s_wid= strtrim(string(widx),2)		; get new workspace #
    res =execute('s_siz=size(w' +s_wid +')' )
    ; --------- if W isn't correct
    IF (s_siz(0) lt 1) or (s_siz(0) gt 2) then BEGIN
	p_rom_send_txt_wd, sw_err, 'Mono or Bidimensional W only'
	print, string(7b)	; BELL to signify error
	s_hid(0) = 1		; s_0 becomes undrawable
    WIDGET_CONTROL, bad_id=i,sw_cutb, Sensitive=0
    ENDIF ELSE BEGIN
	IF flg eq 2 then p_rom_send_txt_wd, sw_err,'W'+s_wid+' '+strmid(w_tit(FIX(s_wid)),0,20)
        IF flg eq 2 then IF (s_siz(0) eq 2) THEN WIDGET_CONTROL, bad_id=i,sw_cutb, /Sensitive
	s_hid(0) = 0		; s_0 becomes drawable
    ENDELSE
ENDIF

IF s_cutall eq 1 THEN BEGIN
    IF flg gt 0 then wait,.6
    p_rom_send_txt_wd, sw_err,'Cut is applied on ALL W'
ENDIF

; ----------------------- Retrieve Cutting Value
WIDGET_CONTROL, bad_id=i, sw_scut, Get_Value = V & V=V-1

if s_hid(0) eq 0 then s_off_arr(0)=V
s_cut_values(0)=V
s_cut(0)=s_xcut
IF (s_cutall eq 1) THEN s_num_wrk(0)=FIX(s_wid)
s_num_wrk(0)=FIX(s_wid)
slide_max = 0

; ------------------------------- For all W if cutall is on (1 or 3)
; ------------------------------- For W#0 if cutall is off
s_e0=0
FOR j=0,6*FIX(s_cutall eq 1 or s_cutall eq 3) do BEGIN
    IF s_num_wrk(j) gt 0 then BEGIN   ; if a W is defined
        IF (s_cutall eq 0) or (s_cutall eq 3) THEN V=s_cut_values(j)
	wid = strtrim(string(s_num_wrk(j)),2)
	si =  strtrim(string(j),2)
	siz=0 & res = execute('siz = Size(w' +wid+')')
	IF siz(0) eq 1 THEN BEGIN		; wk has one dimension
	    IF NOT(s_cutall) THEN BEGIN
		WIDGET_CONTROL, bad_id=i, sw_lcut, Set_Value=''
		WIDGET_CONTROL, bad_id=i, sw_cutb, Sensitive = 0
	    ENDIF
	    res = execute('s_' +si+' = w'+wid)	; copy workspace array
	    res = execute('s_e'+si+' = e'+wid)	; copy error array
	    s_cut(j)=-1
	    res = execute('s_x'+si+' = x'+wid)
	    ss='W'+wid+' '+w_numor(FIX(wid))
	    nb_element=0 & res = execute('nb_element =n_elements(s_x'+si+')')
	    IF nb_element ne siz(1) THEN $
	    res = execute('s_x'+si+' = indgen(siz(1))')
        ENDIF ELSE BEGIN			; wk has two dimensions
	    cutx=s_xcut
	    IF (s_cutall eq 0 or s_cutall eq 3) then cutx = s_cut(j)
	    ; ------------------ Get correct Cut in correct W
	    s = 0.
	    didsx=0 & res = execute('didsx=size (x'+wid+')')
	    didsy=0 & res = execute('didsy=size (y'+wid+')')
	    didse=0 & res = execute('didse=size (e'+wid+')')
	    IF cutx THEN BEGIN
		smax=siz(1)-1  		; define new slider max
	        IF ((V ge siz(1)) AND s_cutall eq 1) then BEGIN
		    s_hid2(j)=1
		ENDIF ELSE BEGIN
		    s_hid2(j)=0
		IF V ge siz(1) then V=siz(1)-1
		if didsy(0) ne 2 then res = execute('s_x'+si+' = y'+wid) else $
				      res = execute('s_x'+si+' = reform(y'+wid+'(V,*))')
		nb_element=0 & res = execute('nb_element =n_elements(s_x'+si+')')
		IF nb_element ne siz(2) THEN $
		res = execute('s_x'+si+' = indgen(siz(2))')

		if didsx(0) ne 1 then st=V+1 else $
		  res=execute('st = x'+wid+'(V)')
		ii = strmid(strtrim(string(st),2),0,5)
		ss='W'+wid+' '+w_numor(FIX(wid))+' X='+ii
		res = execute('s_' +si+' = REFORM(w'+wid+'(V,*))')
		if didse(0) eq 2 then res = execute('s_e'+si+' = REFORM(e'+wid+'(V,*))')
		s = strtrim(string(st),2)+' '+x_tit(FIX(wid))
		ENDELSE
	    ENDIF ELSE BEGIN
		smax=siz(2)-1 		; define new slider max
	        IF ((V ge siz(2)) AND s_cutall eq 1) then BEGIN
		    s_hid2(j)=1
		ENDIF ELSE BEGIN
		    s_hid2(j)=0
		IF V ge siz(2) then V=siz(2)-1
		if didsx(0) ne 2 then res = execute('s_x'+si+' = x'+wid) else $
				      res = execute('s_x'+si+' = reform(x'+wid+'(*,V))')
		nb_element=0 & res = execute('nb_element =n_elements(s_x'+si+')')
		IF nb_element ne siz(1) THEN $
		res = execute('s_x'+si+' = indgen(siz(1))')

		if didsy(0) ne 1 then st=V+1 else $
		  res=execute('st = y'+wid+'(V)')
		ii = strmid(strtrim(string(st),2),0,5)
		ss='W'+wid+' '+w_numor(FIX(wid))+' Y='+ii
		res = execute('s_'+si+' = w'+wid+'(*,V)')
		if didse(0) ne 2 then res = execute('s_e'+si+' = e'+wid) else $
		                      res = execute('s_e'+si+' = e'+wid+'(*,V)')
		s = strtrim(string(st),2)+' '+y_tit(FIX(wid))
		ENDELSE
	    ENDELSE
            IF (s_cutall eq 0 or s_cutall eq 3) THEN BEGIN
	        WIDGET_CONTROL, bad_id=i, sw_lcut, Set_Value = s
		p_rom_redefine_slider, sw_scut, V+1, smax+1
	    ENDIF ELSE BEGIN
	    IF slide_max lt smax then slide_max = smax
	    IF j ne 0 THEN WIDGET_CONTROL,bad_id=i,sw_lab(j-1),Set_Value=ss
	    ENDELSE
	ENDELSE
    ENDIF
ENDFOR
IF (s_cutall eq 1) THEN BEGIN
    WIDGET_CONTROL, bad_id=i, sw_lcut, Set_Value = 'idx='+strtrim(string(V),2)
    WIDGET_CONTROL, bad_id=i, sw_cutb, /Sensitive
    WIDGET_CONTROL, bad_id=i, sw_scut, Set_Slider_Max = slide_max+1
ENDIF
p_rom_super_filter	; process filtering
p_rom_super_plot,0	; Redraw
if s_cutall eq 3 then s_cutall=0	; end of the redraw calculation
END

; *****************************************************************************
PRO p_rom_super_filter ;*******************************************************
; *****************************************************************************
;
; If filtering is on,  copy filtered s_# into s_p#
; If filtering is off, copy s_# in s_p#
;

common sc_superplot

FOR i=0,6 do BEGIN
    s_s=[0] & si= strtrim(string(i),2)
    IF s_filter then BEGIN
	res = execute('s_s = size(s_'+si+')')
	IF s_s(0) ne 0 THEN BEGIN
	    res = execute('s_p'+si+' = SMOOTH(MEDIAN(s_'+si+',3),3)')
	ENDIF
    ENDIF ELSE $
	    res = execute('s_p'+si+' = s_'+si)
ENDFOR
END

; *****************************************************************************
PRO p_rom_super_done ;*********************************************************
; *****************************************************************************
;
; Called when Done Button is pushed
;
@lamp.cbk
COMMON sc_superplot

IF s_color THEN $	; if color table has been saved
	TVLCT, s_ctred,s_ctgreen,s_ctblue ; restore old color table
if lamp_b1 gt 0 then WIDGET_CONTROL,bad_id=i,sw_id,map=0 ; Hide Super_Plot Window
if lamp_b1 le 0 then WIDGET_CONTROL,bad_id=i,sw_id,/destroy
return
END

; *****************************************************************************
PRO p_rom_cleanup, id
; *****************************************************************************
;
; Called when Superplot window is dying
;
common sc_superplot

IF s_color then TVLCT, s_ctred, s_ctgreen, s_ctblue
END

; *****************************************************************************
PRO p_rom_redefine_slider, wid, value, maxi ;**********************************
; *****************************************************************************
;
; Redefine slider MAXImum and slide VALUE for the WID slider
;
WIDGET_CONTROL, bad_id=i, wid, Set_Slider_Max = maxi
WIDGET_CONTROL, bad_id=i, wid, Set_Value = value
END

; *****************************************************************************
PRO p_rom_send_txt_wd, wid, str ;**********************************************
; *****************************************************************************
;
; Modifie STR value for the WID slider
;

WIDGET_CONTROL, bad_id=i, wid, Set_Value = str
END

; ****************************************************************************
pro suprplot, widx ;************************************************
; ****************************************************************************
;
; Create the Super_Plot interface.
; widx is an optional default workspace number (between 1 and lamp_sys)
;

@lamp.cbk				; call back the lamp common block
common sc_superdid			; Array of boolean Set for psym
common sc_supordid			; For XY limits and there widgets
common sc_superplot			; Call Back Super_Plot block

if (!D.flags and 65536)      eq 0 then print,'set_plot,"X" before using' else $
if xregistered('SUPER_PLOT') le 0 then BEGIN	; If Super_Plot doesn't exist..
    ii=execute("P_MUS,'mus_harp'")				; PLAY a tune
    ;*********************************************Create Widget tree

    ; -------------------------------------------- Variables initialisation
    s_xcut      = 0				; Cutting Y axis is default
    s_filter    = 0				; Filter Off is default
    s_color     = 0				; Black/White mode
    s_show_err  = 0				; Show errors is off
    s_normalize = 0				; Normalization Off
    s_cutall    = 0				; cutting doesn't apply to all
    s_psymb     = 0				; plot symbol (*) or not
    s_xmin      = 0				; No X scale
    s_xmax      = 500				; No X scale
    s_ctred     = 0				; red
    s_ctgreen   = 0				; green
    s_ctblue    = 0				; blue
    s_scratio   = 500.				; scale ratio range
    s_yscale    = s_scratio			; no scale is default
    s_printno   = 1				; next print number is 1
    s_lv	= 0				; plot array for live_plot
    s_var1	= 0
    s_var2	= 0
    s_var3	= 0
    s_var4	= 0
    s_yoffset   = 0				; no offset is default
    s_hid       =[1,1,1,1,1,1,1]		; Set all hided flags on
    s_scl       =[1,1,1,1,1,1,1]		; Set all scaled flags on
    s_sym       =[0,0,0,0,0,0,0]		; Set all psym to 0
    s_err       =[0,0,0,0,0,0,0]		; Set all show_error to 0
    s_hid2      =[0,0,0,0,0,0,0]		; No plot hided (cutall)
    s_off_arr   =[-1,-1,-1,-1,-1,-1,-1]		; Offsetarray Inactive
    s_num_wrk   =[-1,-1,-1,-1,-1,-1,-1]		; Clear workspace number array
    s_cut       =[0,0,0,0,0,0,0]		; cutting axis Y is default
    s_cut_values=[-1,-1,-1,-1,-1,-1,-1]		; Clear cutting values
    s_1=0    & s_2=s_1  & s_3=s_1		; Clear local Workspaces
    s_4=s_1  & s_5=s_1  & s_6=s_1
    s_p1=0   & s_p2=s_1 & s_p3=s_1		; Clear plotted Workspaces
    s_p4=s_1 & s_p5=s_1 & s_p6=s_1

    s_xylv=fltarr(4) & s_xylw=lonarr(6)		; For XY limits + Log10 + Linear

    np=6					; np=number of plots
    sw_lab=lonarr(np) & sw_hid=lonarr(np) & sw_scl=lonarr(np) & sw_drw=lonarr(np)

    IF N_ELEMENTS(widx) eq 0 then widx=0
    IF widx le 0 then s_wid='1' $
	ELSE s_wid= strtrim(string(widx),2)	; sw_wid=current workspace number
    res=execute('s_siz=size(w'+s_wid+')')
    if s_siz(0) eq 1 or s_siz(0) eq 2 then s_hid(0)=0

    ; Get correct slider cut max
    s=[0] & res = execute('s = size(y'+s_wid+')')
    if s(0) eq 2 then nb = s(2)-1 else nb = s(1)-1
    IF nb eq 0 then nb=1

    ; the whole lamp size depending modifications is here
    xsiz	=800				; Width of SuperPlot Draw
    if lamp_siz gt 900 then ysiz=480 else ysiz=380
    if lamp_siz lt 800 then BEGIN	; adapt help text to lamp size
	txt1 = 'Select Workspace you want to see, its cutting axis and cutting value.'
        txt2 = 'Fix it by pushing one of the "Keep as" buttons. Press "HELP" for more'
	xsiz=480 & ysiz=250		; adapt plotting window size
	txt3='Keep'			; adapt text button
	txt4='Hide' & txt5='Scale'
	txt6='Hi'   & txt7='Sc' & txt8='___________'
	sl_size=15
	sl_siz=xsiz
    ENDIF ELSE BEGIN
	txt1  = 'Select Workspace you want to see, its cutting axis and cutting value.'+ $
        	'Fix it by pushing one of the "Keep as" buttons. Press "HELP" for more'
	txt2  = ''
	txt3='Keep as'
	txt4='Hide' & txt5='Scale'
	txt6='Hide' & txt7='Scale' & txt8='________________'
	sl_size=16
	sl_siz=xsiz-100
    ENDELSE

    ; --------------------------------- Create SUPER_PLOT Interface

    sw_id	=WIDGET_BASE  (title='Lamp Super Plot Version Sep 1998',/column, $
				Resource_Name='lampdon')
    sw_l	=WIDGET_LABEL (sw_id,Value=txt1 ,Font=ft_smaller)
    if txt2 ne '' then sw_l=WIDGET_LABEL (sw_id,Value=txt2 ,Font=ft_smaller)
    sw_b00      =WIDGET_BASE  (sw_id  ,/Row)
    sw_b0	=WIDGET_BASE  (sw_b00 ,/Column, /Frame)
    sw_b1	=WIDGET_BASE  (sw_b0  ,/Row)
    sw_sw	=WIDGET_SLIDER(sw_b1,Title='',Minimum=1,Maximum=lamp_sys,Value=s_wid,$
    				Font=ft_b_normal, Xsize=sl_siz-300, YSize=sl_size)
    sw_err	=WIDGET_LABEL (sw_b1,Value='... Select your WorkSpace # ...',YSize=sl_size+15, $
				Resource_Name='discret', Font=ft_b_normal)
    sw_b2	=WIDGET_BASE  (sw_b0  ,/Row)
    sw_scut	=WIDGET_SLIDER(sw_b2,Title='',Minimum=0+1,Maximum=nb+1,/Drag,$
				Font=ft_b_normal,Xsize=sl_siz-300, YSize=sl_size)
    sw_bxy	=WIDGET_BASE  (sw_b2,/Row,/Exclusive)
    sw_btx	=WIDGET_BUTTON(sw_bxy ,Value='X',Font=ft_b_bigger,/No_Release)
    sw_bty	=WIDGET_BUTTON(sw_bxy ,Value='Y',Font=ft_b_bigger,/No_Release)
    sw_lcut	=WIDGET_LABEL (sw_b2,Value='Cut at:'         ,Font=ft_b_bigger)
    sw_lcutv	=WIDGET_LABEL (sw_b2,Value='----------------',Font=ft_b_normal, $
				Resource_Name='discret')
    sw_b        =WIDGET_BASE  (sw_b00, /Frame, /Column)
    sw_lbt      =WIDGET_LABEL (sw_b,Value='Apply cut to',Font=ft_normal)
    sw_bb       =WIDGET_BASE  (sw_b,/Exclusive,/Column)
    sw_btone    =WIDGET_BUTTON(sw_bb,Value='current W',Font=ft_smaller)
    sw_btall    =WIDGET_BUTTON(sw_bb,Value='ALL Wk.Sp.',Font=ft_smaller)

    sw_motio	=WIDGET_BASE  (sw_b00,/column)
    bid		=WIDGET_LABEL (sw_motio,Value='X & Y Cursor'   ,Font=ft_b_normal)
    sw_motx	=WIDGET_LABEL (sw_motio,Value='X= ................',Font=ft_normal)
    sw_moty	=WIDGET_LABEL (sw_motio,Value='Y= ................',Font=ft_normal)

    sw_b3	=WIDGET_BASE  (sw_id  ,/Column,Frame=2)
    sw_b31	=WIDGET_BASE  (sw_b3  ,/Row)

    FOR i=1,np do BEGIN
	sw_b311 	=WIDGET_BASE  (sw_b31, /Column, /Frame)
	sw_b312 	=WIDGET_BASE  (sw_b311,/Row)
	sw_bts		=WIDGET_BUTTON(sw_b312,Value=txt3 ,Font=ft_b_normal, $
				UValue=[-88,355,0,i,sw_scut])
 	sw_drw(i-1)	=WIDGET_DRAW  (sw_b312, XSize=xsiz/18+5, YSize=26)
	sw_b3111=WIDGET_BASE  (sw_b311,/Row, /NonExclusive)
	IF i eq 1 then BEGIN
	sw_hid(0)	=WIDGET_BUTTON(sw_b3111,Value=txt4 ,Font=ft_normal, $
				UValue=[-88,355,1,i], Resource_Name='discret')
	sw_scl(0)	=WIDGET_BUTTON(sw_b3111,Value=txt5 ,Font=ft_normal  , $
				UValue=[-88,355,2,i], Resource_Name='discret')
	ENDIF ELSE BEGIN
	sw_hid(i-1)	=WIDGET_BUTTON(sw_b3111,Value=txt6 ,Font=ft_normal, $
				UValue=[-88,355,1,i], Resource_Name='discret')
	sw_scl(i-1)	=WIDGET_BUTTON(sw_b3111,Value=txt7 ,Font=ft_normal  , $
				UValue=[-88,355,2,i], Resource_Name='discret')
	ENDELSE
	sw_lab(i-1)	=WIDGET_LABEL (sw_b311,Value=txt8, Font=ft_smaller)
    ENDFOR

    sw_b32	=WIDGET_BASE  (sw_b3    ,/Row)
    sw_b321	=WIDGET_BASE  (sw_b32   ,/Column)
    sw_ssc	=WIDGET_SLIDER(sw_b321  ,Title='' ,Minimum=1,Maximum=s_scratio,$
    				Value=s_scratio,/Suppress_Value,/Vertical,/Drag,$
				YSize=ysiz,XSize=sl_size)

    sw_draw	=WIDGET_DRAW  (sw_b32   ,Retain=2,Xsize=xsiz,Ysize=ysiz,/motion_events)
    sw_syoffset	=WIDGET_SLIDER(sw_b32   ,Title='' ,Minimum=0,Maximum=100,Value=0,/Drag,$
				/Suppress_Value,/Vertical,YSize=ysiz,XSize=sl_size)
    sw_b321	=WIDGET_BASE  (sw_b32   ,/Column)
    sw_b321	=WIDGET_BASE  (sw_b321  ,/Column,/frame)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='X & Y Ranges',Font=ft_b_normal)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='Y min',Font=ft_b_normal)
    s_xylw(0)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='Y max',Font=ft_b_normal)
    s_xylw(1)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='     ',Font=ft_b_normal)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='X min',Font=ft_b_normal)
    s_xylw(2)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='X max',Font=ft_b_normal)
    s_xylw(3)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)

    sw_b33	=WIDGET_BASE  (sw_b3    ,/Row)
    sw_basebt	=WIDGET_BASE  (sw_b33  , /NonExclusive)
    sw_btscl0	=WIDGET_BUTTON(sw_basebt, Value='', XSize=sl_size)
    sw_sxmin	=WIDGET_SLIDER(sw_b33,Title='X_min' ,Minimum=0,Maximum=499,/Drag, $
				Value=0 ,/Suppress_Value,Xsize=xsiz/2, $
				YSize=sl_size, Font=ft_b_normal)
    sw_sxmax	=WIDGET_SLIDER(sw_b33,Title='X_max' ,Minimum=1,Maximum=500,/Drag, $
				Value=500,/Suppress_Value,Xsize=xsiz/2, $
				YSize=sl_size, Font=ft_b_normal)
;    sw_basebt	=WIDGET_BASE  (sw_b33  , /NonExclusive)
;    sw_btidx	=WIDGET_BUTTON(sw_basebt, Value='idx');, XSize=sl_size)

    sw_b33	=WIDGET_BASE  (sw_b3   ,/row)
    sw_btco	=WIDGET_BUTTON(sw_b33  ,Value='Reset', Font=ft_b_normal, $
				UValue=[-88,355,3,sw_syoffset,sw_ssc,sw_sxmin,sw_sxmax])
    sw_btp	=WIDGET_BUTTON(sw_b33  ,Value='Print'    , Font=ft_b_normal, $
				UValue=[-88,356,0])
    sw_bta	=WIDGET_BUTTON(sw_b33  ,Value='Annot.' , Font=ft_b_normal)
    sw_b331	=WIDGET_BASE  (sw_b33  ,/Row, /NonExclusive)
    sw_btn	=WIDGET_BUTTON(sw_b331 ,Value='Norm', $
				Font=ft_b_normal,UValue=[-88,355,4])
    sw_btn	=WIDGET_BUTTON(sw_b331 ,Value='Log10', $
				Font=ft_b_normal,UValue=[-88,355,9])
    sw_btf	=WIDGET_BUTTON(sw_b331 ,Value='Filtr', $
				Font=ft_b_normal,UValue=[-88,355,5])
    sw_btc	=WIDGET_BUTTON(sw_b331 ,Value='Color', $
				Font=ft_b_normal,UValue=[-88,355,6])
    sw_pltsymb	=WIDGET_BUTTON(sw_b331 ,Value='Symb', $
				Font=ft_b_normal,UValue=[-88,355,8])
    sw_bterr	=WIDGET_BUTTON(sw_b331 ,Value='Err', $
				Font=ft_b_normal,UValue=[-88,355,7])
    sw_btidx	=WIDGET_BUTTON(sw_b331 ,Value='Linear', $
				Font=ft_b_normal,UValue=[-88,355,10])
    sw_btpng	=WIDGET_BUTTON(sw_b33  ,Value='Png', $
				Font=ft_b_normal,UValue=[-88,356,4])
    sw_bthelp	=WIDGET_BUTTON(sw_b33  ,Value='Help' ,$
 				Font=ft_b_normal,UValue=[-88,591,0])
    sw_btdone	=WIDGET_BUTTON(sw_b33  ,Value='Done' , $
				Font=ft_b_normal,UValue=[-88,356,1])
		 ii=execute('put_logo,sw_b33')

    ; ************Set UValues to permit widget id knowledge in parsed procedures
    WIDGET_CONTROL,bad_id=i,sw_sw ,Set_UValue= $
			[-88,353,0,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_scut ,Set_UValue= $
			[-88,353,1,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_btx ,Set_UValue= $
			[-88,353,2,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_bty ,Set_UValue= $
			[-88,353,3,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_btone ,Set_UValue= $
			[-88,354,4,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_btall ,Set_UValue= $
			[-88,354,5,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]

    ; --------------------------------- Set correct UValues
    WIDGET_CONTROL, bad_id=i, sw_sxmin   , Set_UValue=[-88,354,0,sw_sxmax]
    WIDGET_CONTROL, bad_id=i, sw_sxmax   , Set_UValue=[-88,354,1,sw_sxmin]
    WIDGET_CONTROL, bad_id=i, sw_ssc     , Set_UValue=[-88,354,2]
    WIDGET_CONTROL, bad_id=i, sw_syoffset, Set_UValue=[-88,354,3]
    WIDGET_CONTROL, bad_id=i, sw_btscl0  , Set_UValue=[-88,354,6,sw_btscl0]

    ; --------------------------------- Construct Widget Tree
    ii=execute("bid=sys_dep('DYNLAB', sw_id, 1)")
    WIDGET_CONTROL,bad_id=i,sw_id, Group_Leader=lamp_b1, /Realize & ii=execute('put_logo')
    ; --------------------------------- Get the Window id of draw widget
    WIDGET_CONTROL,bad_id=i,sw_draw,Get_Value =s_wset
    WIDGET_CONTROL,bad_id=i,sw_draw,Set_UValue=[-88,356,2,sw_motx,sw_moty]
    ; --------------------------------- Set correct UValue for Annotate Button
    if !version.release ge '5.1' then $
    WIDGET_CONTROL,bad_id=i,sw_bta,Set_UValue=[-88,356,3] else $
    WIDGET_CONTROL,bad_id=i,sw_bta,Set_UValue=[-88,346, s_wset ]
    ; --------------------------------- set cut 'Y' button on
    WIDGET_CONTROL,bad_id=i,sw_bty ,/Set_Button
    ; --------------------------------- set btone button on
    WIDGET_CONTROL,bad_id=i,sw_btone ,/Set_Button
    ; --------------------------------- set all SCALED Buttons to on
    FOR j=0,5 do WIDGET_CONTROL,bad_id=i,sw_scl(j) ,/Set_Button
    ; --------------------------------- Draw lines into widget draws
    FOR j=0,5 do BEGIN
	WIDGET_CONTROL,bad_id=i,sw_drw(j) ,Get_Value = w
	wset, w & erase, 255
	PLOTS, 0,13, /Device
	PLOTS, FIndGen(49), SIN(FIndGen(49)/7)*10+13, /Continue, Color = 1, $
		LineStyle = j, /Device
    ENDFOR

    ; --------------------------------- Send all Widget tree to Lamp Parser
    IF lamp_b1 gt 0  THEN $
    XMANAGER, 'SUPER_PLOT' ,sw_id,event_handler='LAMP_EVENT_PARSER', $
    					/Just_Reg, Cleanup='p_rom_cleanup'
    ; --------------------------------- END OF INTERFACE GENESIS

    ; --------------------------------- Generate a slider W event to
    ; --------------------------------- have a plot immediatly
    v = [-88,353,0,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    p_rom_super_select,v,1
    IF lamp_b1 le 0  THEN XMANAGER, 'SUPER_PLOT' ,sw_id,$
			  event_handler='LAMP_EVENT_PARSER',Cleanup='p_rom_cleanup'

ENDIF ELSE BEGIN
    ; if color mode is on, set best color table
    IF s_color THEN begin
    	s_ddr	=[100,250, 20, 20,250, 5 ,250]
    	s_ddg	=[100, 20,250, 20,250,250, 10]
    	s_ddb	=[100, 20, 20,250, 20,250,250]
    	TVLCT, s_ddr , s_ddg   , s_ddb ,2 & endif

    WIDGET_CONTROL,bad_id=i,sw_id,map=1	; and show existing Multi_Plot
ENDELSE
RETURN
END


PRO Build_MacFileListFromArray ,file_array ,macFile_List
;** **************************
;**

	; Entree :  ['toto', 'tata', 'titi']  			(IDL Array)
	; Sortie : "{file toto, file tata, file titi}	String

	macFile_List = ''
	FOR Index=0,n_elements(file_array)-1 DO BEGIN

		IF (INDEX EQ 0) THEN $
			macFile_List = 'file "' + file_array(Index) + '"' $
		ELSE $
			macFile_List = macFile_List + ', file "' + file_array(Index) + '"'

	END

	macFile_List = '{' + macFile_List + '}'

	return

END ; Build_MacFileListFromArray


PRO Build_MacFileListFromString ,file_list ,macFile_List
;** ***************************
;**

	; Entree : "toto tata titi"						String
	; Sortie : "{file toto, file tata, file titi}	String

	fileArray = str_sep(file_list, ' ')		; Found in IDL Lib

	Build_MacFileListFromArray, fileArray ,macFile_List
	return

END ; Build_MacFileListFromString

PRO Build_ToolServerFileListFromString, sourceFolder, file_list, toolServer_List
;** **********************************
;**

	; Entree : 'sourceFolder' 'toto tata titi'										String
	; Sortie : '\"sourceFolder:toto\" \"sourceFolder:tata\" \"sourceFolder:titi\"'	String

	fileArray = str_sep(file_list, ' ')		; Found in IDL Lib

	toolServer_List = ''
	FOR Index=0,n_elements(fileArray)-1 DO BEGIN

		toolServer_List = toolServer_List + '\"' + sourceFolder + fileArray(Index) + '\" '

	END

	return

END ; Build_ToolServerFileListFromString

PRO lamp_resource, txts
;** *************
;**
txts=[$
"*clientAutoPlace: off","",$

"Idl.visual:  PseudoColor",$
"Idl.retain:  2",$
"Idl.noBorder:True",$
"Idl.colors:  -18","",$

"Idl*Background:  		  paleturquoise",$
"Idl*Foreground:  		  black",$
"Idl*XmText*background:	  	  deepskyblue2",$
"Idl*XmList*background:	  	  deepskyblue3",$
"Idl*XmPushButton*background:	  paleturquoise2",$
"Idl*XmCascadeButton*background:   paleturquoise2",$
"Idl*XmToggleButton*selectColor:   deepskyblue4","",$

"Idl*Annotate*Background:     		paleturquoise",$
"Idl*IDL*Background:     		paleturquoise",$
"Idl*Xloadct*Background:     		paleturquoise","",$

"Idl*scan*Background:     		deepskyblue2",$
"Idl*scan*XmPushButton*background:   	paleturquoise2",$
"Idl*scan*XmPushButton*foreground:	deepskyblue4",$
"Idl*scan*XmCascadeButton*background:	paleturquoise2",$
"Idl*scan*XmCascadeButton*foreground:	deepskyblue4",$
"Idl*scan*XmToggleButton*selectColor:	paleturquoise2",""]
txts=[txts,$
"Idl*lamp*Background:     		paleturquoise",$
"Idl*lamp*XmLabel*foreground:	  	black",$
"Idl*lamp*spelab1*foreground:	  	white",$
"Idl*lamp*spelab2*foreground:	  	deepskyblue1",$
"Idl*lamp*spelab3*foreground:	  	deepskyblue2",$
"Idl*lamp*spelab4*foreground:	  	deepskyblue3",$
"Idl*lamp*spelab5*foreground:	  	deepskyblue4",$
"Idl*lamp*spelab6*foreground:	  	paleturquoise1",$
"Idl*lamp*spelab7*foreground:	  	paleturquoise2",$
"Idl*lamp*spelab8*foreground:	  	paleturquoise3",$
"Idl*lamp*spelab9*foreground:	  	lightblue1",$
"Idl*lamp*discret*Background:		paleturquoise",$
"Idl*lamp*discret*Foreground:		black","",""]
txts=[txts,$
"Idl*lamp*mic*Background: deepskyblue1",$
"Idl*lampmic*Background:  deepskyblue1",$
"Idl*lamp*did*Background: deepskyblue2",$
"Idl*lampdid*Background:  deepskyblue2",$
"Idl*lamp*don*Background: deepskyblue3",$
"Idl*lampdon*Background:  deepskyblue3",$
"Idl*lamp*ben*Background: deepskyblue4",$
"Idl*lampben*Background:  deepskyblue4",""]
txts=[txts,$
"Idl*lamp*mic*geo*Background:			lightblue1",$
"Idl*lamp*mic*geo*XmPushButton*background:	lightblue1",$
"Idl*lamp*mic*geo*XmPushButton*foreground:	deepskyblue4",$
"Idl*lamp*mic*geo*XmLabel*foreground:		deepskyblue4",$
"Idl*lamp*mic*geo*XmText*background:		lightblue1",$
"Idl*lamp*mic*geo*XmText*foreground:		deepskyblue4",$
"Idl*lamp*geo*Background:			lightblue1",$
"Idl*lamp*geo*foreground:			deepskyblue4",$
"Idl*lamp*geo*XmPushButton*background:		lightblue1",$
"Idl*lamp*geo*XmPushButton*foreground:		deepskyblue4",$
"Idl*lamp*geo*XmCascadeButton*Background:	lightblue1",$
"Idl*lamp*geo*XmCascadeButton*foreground:	deepskyblue4",$
"Idl*lamp*did*geo*Background:			lightblue1",$
"Idl*lamp*did*geo*foreground:			deepskyblue4",$
"Idl*lamp*did*geo*XmText*background:		lightblue1",$
"Idl*lamp*did*geo*XmText*foreground:		deepskyblue4",$
"Idl*lamp*don*geo*Background:			lightblue1",$
"Idl*lamp*don*geo*foreground:			deepskyblue4",$
"Idl*lamp*don*geo*XmText*background:		lightblue1",$
"Idl*lamp*don*geo*XmText*foreground:		deepskyblue4",""]
txts=[txts,$
"Idl*lamp*mic*discret*background:	  deepskyblue1",$
"Idl*lamp*mic*discret*foreground:	  deepskyblue4",$
"Idl*lamp*mic*XmPushButton*background:	  paleturquoise1",$
"Idl*lamp*mic*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lamp*mic*XmLabel*foreground:	  deepskyblue4",$
"Idl*lamp*mic*XmToggleButton*selectColor:  paleturquoise1",$
"Idl*lampmic*XmPushButton*background:	  deepskyblue4",$
"Idl*lampmic*XmPushButton*foreground:	  white",$
"Idl*lampmic*XmLabel*foreground:	  	  deepskyblue4",$
"Idl*lampmic*XmCascadeButton*background:	  deepskyblue2",$
"Idl*lampmic*XmCascadeButton*foreground:	  white",$
"Idl*lampmic*XmToggleButton*selectColor:   paleturquoise1",$
"Idl*lampmic*XmText*background:	  	  deepskyblue3",$
"Idl*lampmic*XmText*foreground:	  	  white",$
"Idl*lampmic*red*background:		  white",$
"Idl*lampmic*red*foreground:		  black",""]
txts=[txts,$
"Idl*lamp*did*discret*background:	  deepskyblue2",$
"Idl*lamp*did*discret*foreground:	  deepskyblue4",$
"Idl*lamp*did*XmPushButton*background:	  paleturquoise2",$
"Idl*lamp*did*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lamp*did*XmToggleButton*selectColor:  paleturquoise2",$
"Idl*lampdid*XmPushButton*background:	  paleturquoise2",$
"Idl*lampdid*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lampdid*XmCascadeButton*background:	  paleturquoise2",$
"Idl*lampdid*XmCascadeButton*foreground:	  deepskyblue4",$
"Idl*lampdid*XmToggleButton*selectColor:   deepskyblue4",""]
txts=[txts,$
"Idl*lamp*don*gordon*Background: 		deepskyblue4",$
"Idl*lamp*don*gordon*XmPushButton*background:	paleturquoise3",$
"Idl*lamp*don*gordon*XmPushButton*foreground:	deepskyblue4",$
"Idl*lamp*don*XmPushButton*background:	  deepskyblue4",$
"Idl*lamp*don*XmPushButton*foreground:	  paleturquoise",$
"Idl*lamp*don*XmCascadeButton*background:  deepskyblue4",$
"Idl*lamp*don*XmCascadeButton*foreground:  paleturquoise",$
"Idl*lamp*don*XmToggleButton*selectColor:  deepskyblue4",$
"Idl*lampdon*discret*background:	          deepskyblue3",$
"Idl*lampdon*discret*foreground:	          paleturquoise",$
"Idl*lampdon*XmPushButton*background:	  deepskyblue4",$
"Idl*lampdon*XmPushButton*foreground:	  paleturquoise",$
"Idl*lampdon*XmCascadeButton*background:	  deepskyblue4",$
"Idl*lampdon*XmCascadeButton*foreground:	  paleturquoise",$
"Idl*lampdon*XmToggleButton*selectColor:   deepskyblue4",""]
txts=[txts,$
"Idl*lamp*ben*XmLabel*foreground:	  paleturquoise3",$
"Idl*lamp*ben*foreground:		  white",$
"Idl*lamp*ben*discret*background:	  deepskyblue4",$
"Idl*lamp*ben*discret*foreground:	  paleturquoise3",$
"Idl*lamp*ben*XmPushButton*background:	  paleturquoise3",$
"Idl*lamp*ben*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lamp*ben*XmToggleButton*selectColor:  paleturquoise3",$
"Idl*lamp*ben*XmToggleButton*foreground:   paleturquoise3",$
"Idl*lampben*foreground:			  white",$
"Idl*lampben*XmPushButton*background:	  paleturquoise3",$
"Idl*lampben*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lampben*XmCascadeButton*background:	  paleturquoise3",$
"Idl*lampben*XmToggleButton*selectColor:   paleturquoise3",""]
txts=[txts,$
"Idl*lamptouch*Background:  		  paleturquoise",$
"Idl*lamptouch*Foreground:  		  black",$
"Idl*lamptouch*XmText*background:	  paleturquoise1",$
"Idl*lamptouch*XmList*background:	  deepskyblue3",$
"Idl*lamptouch*XmList*foreground:	  paleturquoise2",$
"Idl*lamptouch*XmPushButton*background:	  paleturquoise2",$
"Idl*lamptouch*XmCascadeButton*background: deepskyblue3",$
"Idl*lamptouch*XmCascadeButton*foreground: white",$
"Idl*lamptouch*XmToggleButton*selectColor: paleturquoise3",$
"Idl*lamptouch*discret*background:	  paleturquoise1",$
"Idl*lamptouch*discret*foreground:	  deepskyblue4",""]
return
end


FUNCTION sys_dep, flag, p1,p2,p3,p4
;******* *******
;**
common c_def,c_init,Lamp_Dir,LF,viewer,ziper,giftrans

os =!VERSION.OS
;Vs=(BYTE(!version.release))(0) - (BYTE('0'))(0)
Vs =fix(strmid(string(!version.release),0,1))
res=0
if !prompt eq 'I2M>' then matlab=1 else matlab=0

IF n_elements(c_init) eq 0 THEN BEGIN c_init=1 & viewer='' & Lamp_Dir='' & ziper=''
	CASE os of
		'MacOS': begin  LF = STRING(13B) & end
		'Win32': begin  & end
		'vms':   begin  ad='sys$login:lamp.resource' & a=findfile(ad,count=cnt)
		                if cnt eq 0 then begin lamp_resource,txts  & u=0 & n=n_elements(txts)-1
		                   ON_ioerror,misrsv & openw,u,ad,/get_lun & for i=0,n do printf,u,txts(i)
		                   free_lun,u & spawn, 'copy/noconf '+ad+' sys$login:decw$xdefaults.dat' & misrsv:
		                endif
		         end
		ELSE:    begin  spawn, 'unalias rm ; unalias cp ; unalias mv'
		                ad=expand_path('~')+'/.lamp.resource' & a=findfile(ad,count=cnt)
		                if cnt eq 0 then begin lamp_resource,txts  & u=0 & n=n_elements(txts)-1
		                     ON_ioerror,misrsu  & openw,u,ad,/get_lun & for i=0,n do printf,u,txts(i)
		                     free_lun,u & cnt=1 & misrsu:
		                endif
		                if (cnt ge 1) and (!D.name ne 'Z') and (!D.name ne 'TEK') then begin
				     scd='/usr/bin/X11/xrdb'     & bid=findfile(scd,count=cnt)
				     ;if cnt lt 1 then begin
				     ;scd='/usr/X11R6/bin/xrdb'   & bid=findfile(scd,count=cnt) & endif
				     if cnt lt 1 then begin
				     scd='/usr/openwin/bin/xrdb' & bid=findfile(scd,count=cnt) & endif

				     if  cnt ge 1 then spawn,  scd + ' -merge '+ad
				endif
		         end
	ENDCASE
END

CASE flag of

'ADDPATH': IF strpos(!path,p1) lt 0 then BEGIN CASE os of
      		'vms':   !path=p1+ ',' +!path
     		'MacOS': !path=p1+':,' +!path
      		'Win32': !path=p1+ ';' +!path
      		 ELSE:   !path=p1+ ':' +!path
	   ENDCASE
	   ENDIF

	   ;After Desktop is realized or Stop
	   ;---------------------------------
'AFTER' : BEGIN CASE os of
      		'Win32': if Vs eq 4 then DEVICE,main_window=0
      		 ELSE:
	   ENDCASE
	   END
'AFTES' : BEGIN CASE os of
      		'Win32': if Vs eq 4 then DEVICE,main_window=1
      		 ELSE:
	   ENDCASE
	   END

	   ;Remove all blanks from a string exept for Mac dossiers
	   ;------------------------------------------------------
'BLANKS' : BEGIN CASE os of
      		'MacOS' : res=strtrim    (p1,2)
      		'Win32' : res=strtrim    (p1,2)
      		'darwin': res=strtrim    (p1,2)
      		 ELSE:    res=strcompress(p1,/remove_all)
	   ENDCASE
	   END

	   ;Call a browser
	   ;--------------
'BROWSE' : BEGIN CASE os of
      		'vms':   begin  spawn,'netscape '+p1,/NOWAIT
			         end
      		'Win32': begin  IF !version.release ge '5.4' THEN $
				spawn,/nowait,/hide,'"c:\Program Files\internet explorer\iexplore.exe" '+p1
      		         end
      		'MacOS': begin  spawn, MACCREATOR='MOSS',  p1
      		         end
      		'darwin':begin  spawn,'open '+p1
      		         end
      		 ELSE:   begin  spawn,'netscape -install '+p1 +'&'
			 end
	   ENDCASE
	   END

	   ;Copy files in string p1 (separ. by blancs) from directory p2 to current directory
	   ;----------------------- ------------------ ----------------- --------------------
'COPY':    BEGIN CASE os of
		'vms':   begin
			 tmp=byte(strcompress(strtrim(p1,2)))
			 idx=where(tmp eq 32)
			 if idx(0) gt 0 then tmp(idx)=byte(',')
			 tmp=string(tmp)
      		 	 cd,current=mee
      		 	 if n_elements(p3) gt 0 then mee=mee+p3
			 spawn ,'copy/noconf '+p2+tmp+' '+mee+'*'
			 end
      		'Win32': begin
      		 	 cd,current=mee
      		 	 if n_elements(p3) gt 0 then mei=mee+'\'+p3 else mei=mee
			 IF !version.release ge '5.2' THEN BEGIN
			   files=str_sep(p1,' ') & mei=mei+'\'
			   for ip1 = 0, n_elements (files)-1 do begin
			     if files(ip1) gt ' ' then begin
			        binin =    read_binary(p2 + files(ip1))
			        on_ioerror,free
			        openw   , u, mei+files(ip1), /get_lun
			        writeu  , u, binin
			        free:free_lun, u
			     endif
			   endfor
			 ENDIF ELSE BEGIN
      		 	   cd,p2
      		 	   command_line='cp '+p1+' '+mei
      		 	   spawn, command_line
      		 	   cd,mee
			 ENDELSE
      			 end
      		'MacOS': begin
      			; Get the current dir
      			cd, CURRENT=toFolder
      			; We need to use ToolServer because of the unix WildCard character (*)
				Print, "SD :Copy From " + p2 + " " + p1 + " to folder " + toFolder

				; NOTE : WildCard can be very very slow (2 to 5 minutes) on NFS volume mount by "MacNFS" : Don't use it !

				; Translate unix WildCard (*) to ToolServer WildCard ()
				t1=strcompress(strtrim(p1,2))
				WHILE (STRPOS(t1, '*') NE -1) DO $
					STRPUT, t1, '', Index

				Build_ToolServerFileListFromString, p2, t1, toolServerFileList
				toolServerScript = "directory  " + toFolder + " ; " + $
									"duplicate -y " + toolServerFileList + " : ; " + $
									"setfile -t 'ZIVU' -c 'Gzip' .Z"

				script = [  'tell application "' + Lamp_Dir + 'Helpers:ToolServer:ToolServer"', $
							'      DoScript "' + toolServerScript + '"', $
							'end tell' ]

				DO_APPLE_SCRIPT, script
				; ToolServer ne renvoit pas de rsultat pour cette commande ?!?
				res = 1
      		 	 end
      		 ELSE:   begin
      		 	 cd,current=mee
      		 	 if n_elements(p3) gt 0 then mee=mee+'/'+p3
      		 	 spawn, 'cd '+p2 + '; cp '   + p1 + ' '+mee
      		 	 end
	   ENDCASE
	   END

	   ;Delete file p1
	   ;--------------
'DELET':   BEGIN ON_IOERROR,mis_opd
                 CASE os of
		'vms':   begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
      		'MacOS': begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
      		'Win32': begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
      		'Other': spawn,'rm -f '   +p1
      		 ELSE:   begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
	   ENDCASE
	   mis_opd:
	   END

	   ;Delete a file list p1
	   ;------------------ --
'DELIST':  BEGIN ON_IOERROR,mis_opdl
                 CASE os of
      		'vms':	 for i=0,n_elements(p1)-1 do begin
      				 OPENR ,out1,p1(i)    ,/get_lun,/DELETE & FREE_LUN,out1 & endfor
      		'MacOS': for i=0,n_elements(p1)-1 do begin
      				 OPENR ,out1,p1(i)    ,/get_lun,/DELETE & FREE_LUN,out1 & endfor
      		'Win32': for i=0,n_elements(p1)-1 do begin
      				 OPENR ,out1,p1(i)    ,/get_lun,/DELETE & FREE_LUN,out1 & endfor
      		 ELSE:   spawn, ['rm' ,'-f' , p1] ,/noshell
	   ENDCASE
	   mis_opdl:
	   END

	   ;List current directory, return a file ascending list
	   ;----------------------  ----------------------------
'DIR':     BEGIN CASE os of
		'vms':   p1=findfile(count=p2)
      		'Win32': begin
      			;CAG - due to the redirection problem in Win32 I am using IDL
      			 cd,current=mee
      			 p1=FINDFILE(mee+'\*',count=p2)
      			 end
       		'MacOS': begin
      			; NOTE : if we pass a non existent reference to the finder,
      			; we will end up in a "dialog with OK button" at the finder level
      			script = [  'tell application "Finder"',$
      						'   if  (exists folder "' + p1 + '") then',$
      						'      name of items in container "' + p1 + '"' + LF,$
      						'   else',$
      						'      set result to ""' + LF,$
      						'   end if' + LF,$
      				     	'end tell' ]
      			DO_APPLE_SCRIPT, script, RESULT=p1
      			res = p1
      			p2 = n_elements(p1)
      		 	end
       		 ELSE:   spawn, 'ls ' ,p1 ,count=p2
	   ENDCASE
	   END

	   ;List directories of current directory with modified date
	   ;---------------- -- ----------------- ---- -------- ----
'DIRD':    BEGIN CASE os of
		'vms':	 spawn,'dir/date' +p1+ '*.dir' ,res
      		'Win32': p3=0 ; CAG need to be implemented
       		'MacOS':
      		 ELSE:   spawn,'ls -ld '  +p1+ '*'    ,res
	   ENDCASE
	   END

	   ;Return the path divider
	   ;-----------------------
'DIVIDER': BEGIN CASE os of
		'vms':   res = ""
      		'Win32': res = "\"
      		'MacOS': res = ":"
      		 ELSE:   res = "/"
	   ENDCASE
	   END

	   ; For IDL versions 4.0.1 and newer, find all label widgets
	   ; rooted and the specified top level widget and set their
	   ; DYNAMIC_RESIZE property.
	   ;------------------------
'DYNLAB':  IF (Vs GE 4) THEN BEGIN

	   IF p2 gt 0 THEN IF !version.release ne '4.0' THEN $
	   CASE os of
      		'Win32':
		 ELSE:	 dynlabel_call, p1
	   ENDCASE

	   CASE os of
		'MacOS': begin	if n_elements(p3) ne 1 then p3=-15
				resizeButton_call, p1, p3
			 end
		 ELSE:
	   ENDCASE
	   ENDIF

	   ;RPC modules entries (ILL use only)
	   ;-------------------
'ENTRY':   BEGIN CASE os of
		'vms':   res='r_mic'
		'sunos': res='r_micc_'
      		'IRIX':  res='r_micc_'
      		'hp-ux': res='r_micc'
       		 ELSE:   res='r_micc'
	   ENDCASE
	   END

	   ;RPC modules (ILL use only)
	   ;-----------
'EXEC':    BEGIN CASE os of
		'sunos': res=p1+'/lamp_mac/r_mic_SUN.so'
      		'IRIX':  res=p1+'/lamp_mac/r_mic_SGI.so'
      		'hp-ux': res=p1+'/lamp_mac/r_mic_HP.so'
      		 ELSE:   res=''
	   ENDCASE
	   END

	   ;EXIT from Lamp application
	   ;--------------------------
'EXIT':    BEGIN CASE os of
		'MacOS': EXIT
		'Win32': EXIT
		 ELSE:	 EXIT
	   ENDCASE
	   END

	   ;Font for drawing area
	   ;---------------------
'FONTD':   BEGIN CASE os of
		'vms':   res='6x13bold'
		'MacOS': res='geneva*9'
		'darwin':res='-schumacher-clean-medium-r-normal--10-*-*-*-*-*-*-*'
		'Win32': res='arial*bold*12'
		 ELSE:	 res='-adobe-courier-medium-r-normal--12-120-*-*-*-*-*-*'
	   ENDCASE
	   END

	   ;Fonts for large(0) middle(1) and small(2) UIs
	   ;---------------------------------------------
'FONTS':   BEGIN
;	   Large UI
     	   propor0   = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   biggest0  = '-bitstream-charter-bold-r-normal--19-180-75-75-p-119-*-*'
     	   bigger0   = '-bitstream-charter-medium-r-normal--17-120-100-100-p-95-*-*'
     	   b_bigger0 = '-bitstream-charter-bold-r-normal--17-120-*-*-*-*-*-*'
     	   normal0   = '-bitstream-charter-medium-r-normal--15-140-75-75-p-84-*-*'
     	   b_normal0 = '-bitstream-charter-bold-i-normal--15-140-75-75-p-93-*-*'
     	   smaller0  = '-bitstream-charter-medium-r-normal--12-120-75-75-p-67-*-*'
     	   smallest0 = '-bitstream-charter-medium-r-normal--10-100-75-75-p-56-*-*'

;	   Middle UI
     	   propor1   = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   biggest1  = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   bigger1   = '-adobe-courier-medium-r-normal--14-140-*-*-*-*-*-*'
     	   b_bigger1 = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   normal1   = '-adobe-times-medium-i-normal--14-140-*-*-*-*-*-*'
     	   b_normal1 = '-adobe-times-bold-i-normal--14-140-*-*-*-*-*-*'
     	   smaller1  = '-adobe-times-medium-r-normal--12-120-*-*-*-*-*-*'
     	   smallest1 = '-adobe-times-medium-r-normal--10-100-*-*-*-*-*-*'

;	   Small UI
    	   propor2   = '-adobe-courier-bold-r-normal--10-100-*-*-*-*-*-*'
    	   biggest2  = propor2
    	   bigger2   = '-adobe-courier-medium-r-normal--10-100-*-*-*-*-*-*'
    	   b_bigger2 = propor2
    	   normal2   = bigger2
    	   b_normal2 = propor2
    	   smaller2  = propor2
    	   smallest2 = bigger2

    	   res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
    	        [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
    	        [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]

 	   CASE os of
		'vms':  begin res(*,0)=res(*,1)
			      res(1,0)='-adobe-times-bold-r-normal--18-180-*-*-*-*-*-*' & end
 		'sunos':begin res(*,0)=res(*,1)
			      res(1,0)='-adobe-times-bold-r-normal--18-180-*-*-*-*-*-*' & end
		'Win32':begin
     			propor0   = 'courier new*bold*14'
     	  		biggest0  = 'arial*bold*19'
     	   		bigger0   = 'arial *17'
     	   		b_bigger0 = 'arial*bold*17'
     	   		normal0   = 'arial *15'
     	   		b_normal0 = 'arial*bold*italic*15'
     	   		smaller0  = 'arial *12'
     	   		smallest0 = 'courier new*12'

                        biggest1  = 'arial*bold*15'
                        b_bigger1 = 'courier new*bold*16'
                        bigger1   = 'arial*bold*14'
                        propor1   = 'courier new*bold*14'
                        normal1   = 'arial*bold*11'
                        b_normal1 = 'arial*bold*14'
                        smaller1  = 'courier new*12'
                        smallest1 =  smaller1

                        biggest2  = 'courier new*bold*16'
                        b_bigger2 = 'courier new*bold*16'
                        bigger2   = 'arial*bold*14'
                        propor2   = 'arial*bold*14'
                        normal2   = 'arial*bold*11'
                        b_normal2 = 'arial*bold*14'
                        smaller2  = 'courier new*12'
                        smallest2 =  smaller2

    	   		res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
    	        	     [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
    	        	     [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]
      			end
      		'MacOS':begin
                        biggest0  = 'geneva*bold*12'
                        b_bigger0 = 'geneva*bold*11'
                        bigger0   = 'geneva*11'
                        propor0   = 'monaco*10'
                        normal0   = 'geneva*10'
                        b_normal0 = 'geneva*bold*10'
                        smaller0  = 'geneva*9'
                        smallest0 = 'geneva*7'

                        biggest1  = 'geneva*bold*12'
                        b_bigger1 = 'geneva*bold*11'
                        bigger1   = 'geneva*11'
                        propor1   = 'monaco*9'
                        normal1   = 'geneva*10'
                        b_normal1 = 'geneva*bold*10'
                        smaller1  = 'geneva*8'
                        smallest1 = 'geneva*7'

                        biggest2  = 'geneva*bold*11'
                        b_bigger2 = 'geneva*bold*10'
                        bigger2   = 'geneva*10'
                        propor2   = 'monaco*9'
                        normal2   = 'monaco*9'
                        b_normal2 = 'geneva*10'
                        smaller2  = 'geneva*8'
                        smallest2 = 'geneva*7'

    	   		res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
    	        	     [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
    	        	     [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]
      			end
               'darwin':begin ; Large UI
                        propor0   = '-schumacher-clean-bold-r-normal--14-140-75-75-c-80-iso646.1991-irv'
                        biggest0  = '-adobe-helvetica-bold-r-normal--18-180-75-75-p-103-iso8859-15'
                        bigger0   = '-adobe-helvetica-medium-r-normal--18-180-75-75-p-98-iso8859-15'
                        b_bigger0 = '-adobe-helvetica-bold-r-normal--14-140-75-75-p-82-iso8859-14'
                        normal0   = '-adobe-helvetica-medium-r-normal--14-140-75-75-p-77-iso8859-14'
                        b_normal0 = '-adobe-helvetica-bold-o-normal--14-140-75-75-p-82-iso8859-14'
                        smaller0  = '-adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-13'
                        smallest0 = '-adobe-helvetica-medium-r-normal--10-100-75-75-p-56-iso8859-10'
                             ; Middle UI
                        propor1   = '-schumacher-clean-bold-r-normal--10-100-75-75-c-60-iso646.1991-irv'
                        biggest1  = '-adobe-helvetica-medium-r-normal--10-*-*-*-*-*-*-*'
                        bigger1   = '-adobe-helvetica-medium-r-normal--10-*-*-*-*-*-*-*'
                        b_bigger1 = '-adobe-helvetica-bold-r-normal--10-*-*-*-*-*-*-*'
                        normal1   = '-adobe-helvetica-medium-r-normal--9-*-*-*-*-*-*-*'
                        b_normal1 = '-adobe-helvetica-bold-r-normal--9-*-*-*-*-*-*-*'
                        smaller1  = '-adobe-helvetica-medium-r-normal--8-*-*-*-*-*-*-*'
                        smallest1 = '-adobe-helvetica-medium-r-normal--8-*-*-*-*-*-*-*'
                             ; Small UI
                        propor2   = '-schumacher-clean-bold-r-normal--10-100-75-75-c-60-iso646.1991-irv'
                        biggest2  = propor2
                        bigger2   = '-schumacher-clean-medium-r-normal--10-100-75-75-c-50-iso646.1991-irv'
                        b_bigger2 = propor2
                        normal2   = bigger2
                        b_normal2 = propor2
                        smaller2  = propor2
                        smallest2 = bigger2

                        res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
                             [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
                             [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]
                        end
       		 ELSE:
	   ENDCASE
	   if matlab then begin
    	   		res=[['ft_propor','ft_biggest','ft_bigger','ft_b_bigger','ft_normal','ft_b_normal','ft_smaller','ft_smallest'],$
    	        	     ['ft_propor','ft_biggest','ft_bigger','ft_b_bigger','ft_normal','ft_b_normal','ft_smaller','ft_smallest'],$
    	        	     ['ft_propor','ft_biggest','ft_bigger','ft_b_bigger','ft_normal','ft_b_normal','ft_smaller','ft_smallest']]
	   endif
	   END

	   ;Environment variable p1: 'LAMP_DIR','USER','HOST','DISPLAY'
	   ;----------------------------------------------------------
'GETENV':  BEGIN res=''
           CASE os of
		'MacOS': begin
		            if (p1 eq 'LAMP_DIR') then begin i = strpos (strlowcase(!path),"lamp_mac")
				      if i le 0       then       i =rstrpos (strlowcase(!path),"lamp")+5
					if i eq 4       then begin i =findfile('lamp*.sav',count=nn)
		                             if nn gt 0 then begin cd,current=res
		                                        !path=res+':,'+res+':lamp_mac:,' +!path
					           endif else begin
		                                        i  = findfile(!Dir+   ':lamp*.sav',count=nn)
					                      if nn gt 0 then res = !Dir
					           endelse
			            endif else begin res=strmid (!path,0,i-1)
					                 i  =rstrpos( res ,",")
		                             if i ge 0 then  res=strmid ( res ,i+1,80)
					           i  = strpos   (strlowcase(!path),"lamp_mac")
					           if i lt 0 then !path=res+ ':,'+res+':lamp_mac:,' +!path
		                  endelse
					Lamp_Dir = res
		      	endif else if (p1 eq 'USER') then begin res=""

				;	script =['tell application "' + Lamp_Dir + 'Helpers:ToolServer:ToolServer"'+LF,$
				;		'DoScript "echo -n {user}"' + LF, $
				;		'end tell' ]
				;	DO_APPLE_SCRIPT, script, RESULT=res

		      	endif else if p1 eq 'HOST' then res = "" $
		      	else  if p1 eq 'LAMP_EXEC' then res = "" $
		      	else  if p1 eq 'DISPLAY'   then res = ":0"
		      	end
		'Win32': if p1 eq 'LAMP_DIR' then begin i  = strpos  (strlowcase(!path),"lamp_mac")
		                  if i le 0  then       i  =rstrpos  (strlowcase(!path),"lamp")+5
				  if i eq 4  then begin i  = findfile('..\lamp*.sav',count=nn)
							CD,current=mee
		                             if nn gt 0 then cd,'..' $
		                             else       i  = findfile(   'lamp*.sav',count=nn)
		                             if nn gt 0 then begin cd,current=res
		                                        !path=res+';'+res+'\lamp_mac;' +!path
					     endif else begin
		                                        i  = findfile(!Dir+   '\lamp*.sav',count=nn)
					                if nn gt 0 then res = !Dir $
							else begin
					                        i  = findfile(!Dir+'\..\lamp*.sav',count=nn)
					                        if nn gt 0 then begin
					                         cd,!Dir+'\..'  &   cd,current=res & endif
					                endelse
					     endelse
					     CD,mee
		                  endif else begin      res= strmid (!path,0,i-1)
		                                        i  = rstrpos( res ,";")
		                             if i ge 0  then res=strmid ( res ,i+1,80)
					     i  = strpos   (strlowcase(!path),"lamp_mac")
					     if i lt 0 then !path=!path+';'+res+';'+res+'\lamp_mac'
				 endelse
				 Lamp_Dir = res
		         endif else res = getenv(p1)
      	ELSE:    res = getenv(p1)
	   ENDCASE
	   END

	   ;Make transparent gif
	   ;--------------------
'GIFTRANS':BEGIN CASE os of
		'vms':
      		'Win32':
      		'MacOS':
      		 ELSE: begin if n_elements(giftrans) eq 0 then begin
				spawn,'whereis giftrans',ret
      		 	 	cnt=strpos(ret,'/giftrans')
      		 	 	if cnt(0) lt 0 then giftrans=0 else giftrans=1
			     endif
			     if giftrans then $
				spawn,'giftrans -t 0 '+P1+' > '+P1+'t; mv '+P1+'t '+P1
		       end
	   ENDCASE
	   END


	   ;Used for cd,res for home directory
	   ;----------------------------------
'HOME':    BEGIN CASE os of
		'vms':   res='sys$login:'
      		'Win32': cd , current=res
      		'MacOS': cd , current=res
      		 ELSE:   res=expand_path('~')
	   ENDCASE
	   END


	   ;Add LAMP_DIR and LAMP_DIR/lamp_mac to idl path
	   ;-------------------------------------------------
'IDLPATH': IF strpos(!path,p1) lt 0 then BEGIN
 		CASE os of
		'vms':   expa=expand_path('+'+strmid(p1,0,p2-1)+'.lamp_mac]')
		'MacOS': expa=expand_path('+'+p1+':lamp_mac:')
		'Win32': expa=expand_path('+'+p1+'\lamp_mac' )
		 ELSE:   expa=expand_path('+'+p1+'/lamp_mac' )
		ENDCASE
		CASE os of
		'vms':   !path=!path+','     +p1+',' +strmid(p1,0,p2-1)+'.lamp_mac]'+',sys$login:'+','+expa
		'MacOS':;!path=!path+','     +p1+':,'+p1+':lamp_mac:'     +','+expa
		'Win32':;!path=!path+';'     +p1+';' +p1+'\lamp_mac'      +';'+expa
		 ELSE:   !path=!path+':'     +p1+':' +p1+'/lamp_mac' +':~'+':'+expa
		ENDCASE
          ENDIF

	   ;Insert a sub_dir p2 in path p1
	   ;------------------------------
'INSUB':   BEGIN CASE os of
		'vms':   res =strmid(p1,0,strlen(p1)-1)+ '.' +p2 +']'
      		'Win32': res =       p1       +p2 +'\'
      		'MacOS': res =       p1       +p2 +':'
      		 ELSE:   res =       p1       +p2 +'/'
	   ENDCASE
	   END

	   ;Get graphic function number for GXinvert
	   ;----------------------------------------
'INVERT':  BEGIN CASE os of
		'vms':   res=10
      		'Win32': res=10
      		'MacOS': res= 6
      		 ELSE:   res=10
	   ENDCASE
	   END

	   ;Return machine type
	   ;-------------------
'MACHINE': BEGIN CASE os of
		'vms':   res='vms'
      		'Win32': res='win'
      		'MacOS': res='mac'
      		 ELSE:   res='unix'
	   ENDCASE
	   END

	   ;Show manual with a browser
	   ;--------------------------
'MANUAL' : BEGIN CASE os of
      		'vms':   begin  res='netscape [lamp.manual]front.htm'
					cdd=strmid(p1,0,strlen(p1)-1)+'.manual]'
					id=findfile(cdd+'front.htm',count=cnt)
					if (cnt eq 0) and (n_elements(p2) eq 1) then  begin
			                cdd=strmid(p2,0,strlen(p1)-1)+'.manual]'
			                id =findfile(cdd+'front.htm',count=cnt) & endif
		   			if  cnt gt 0 then begin res='netscape '+cdd+'front.htm'
					    spawn,res,/NOWAIT
					endif else res='http://www.ill.fr/data_treat/lamp/front.html'
			         end
      		'Win32': begin  res=p1+'\manual\front.htm'
					cdd=p1+'\manual\'
			    		id=findfile(cdd+'front.htm',count=cnt)
					if (cnt eq 0) and (n_elements(p2) eq 1) then  begin
			                cdd=p2+'\manual\'
			                id =findfile(cdd+'front.htm',count=cnt) & endif
		   	    		if  cnt gt 0 then begin res=cdd+'front.htm'
					endif else res='http://www.ill.fr/data_treat/lamp/front.html'
					IF !version.release ge '5.4' THEN $
					spawn,/nowait,'"c:\Program Files\internet explorer\iexplore.exe" '+res
      		         end
      		'MacOS': begin
      			    	res='MOSS'	; signature de l'application "NetScape"
      			    	cdd = p1+':manual:'
			    		id=findfile(cdd+'front.htm',count=cnt)
					if (cnt eq 0) and (n_elements(p2) eq 1) then  begin
			                cdd=p2+':manual:'
			                id =findfile(cdd+'front.htm',count=cnt) & endif
		   	    		if  cnt gt 0 then begin res=cdd+'front.htm'
					    spawn, MACCREATOR='MOSS', res
					endif else res='http://www.ill.fr/data_treat/lamp/front.html'
      		         end
      		 ELSE:   begin	res='http://www.ill.fr/data_treat/lamp/front.htm'
      				ic ='netscape'
      				spawn,'whereis netscape',ret
      				cnt=strpos(ret,'/netscape')
      				if cnt(0) lt 0 then begin
      		 		   spawn,'whereis mosaic',ret
      				   cnt=strpos(ret,'/mosaic')
      				   if cnt(0) ge 0 then ic ='mosaic' & endif
      				if cnt(0) lt 0 then begin
      		 		   spawn,'whereis mozilla',ret
      				   cnt=strpos(ret,'/mozilla')
      				   if cnt(0) ge 0 then ic ='mozilla'
      				   cnt=[0] & endif
				if os eq 'darwin' then ic ='open'
				if cnt(0) ge 0 then begin
				   if strpos(ic,'netscape') ge 0 then ic=ic+' -install'
		   		   cdd   =p1+'/manual/'
				   id=findfile(cdd+'front.htm',count=cnt)
				   if (cnt eq 0) and (n_elements(p2) eq 1) then begin
			               cdd=p2+'/manual/'
			               id =findfile(cdd+'front.htm',count=cnt) & endif
				   if cnt gt 0 then res=cdd+'front.htm'
				   spawn ,ic + ' ' + res + ' &'
				endif
			 end
	   ENDCASE
	   END

	   ;MAP or not MAP (some devices have problems to add widgets after realizing-> res=1)
	   ;--------------
'MAP':	   BEGIN CASE os of
      		'MacOS': res=1
      		'Win32': IF !version.release lt '5.1' THEN res=1
      		 ELSE:   res=0
	   ENDCASE
	   IF !version.release lt '3.6' THEN res=-1
	   IF res eq 0 THEN $
	      IF (Vs GE 4) THEN $
	   	   IF !version.release ne '4.0' THEN res=2
	   END

	   ;Create a directory
	   ;------------------
'MKDIR':   BEGIN CASE os of
			'vms':   spawn,'create/dir ' +p1
      		'MacOS': begin
      			; D'abord, verifier si c'est possible
      			ii=findfile(p1,count=cnt)

				; Si le dossier existe deja, on sort
      			if (cnt gt 0) then return, res

      			FileStart = RSTRPOS(p1, ':')+1
      			container = STRMID(p1,0,FileStart)
      			folderName = STRMID(p1, FileStart, 1000)

      			script = [  'tell application "Finder"', $
      						'	if not (exists folder "' + p1 + '") then', $
      						'    	make new folder at container "' + container + '" with properties {name:"' + folderName + '"}' + LF, $
      						'	end if' + LF, $
      				     	'end tell' ]
      			DO_APPLE_SCRIPT, script
      			res=1
      		 	end
      		'Win32': begin
      			 command_line='mkdir '+p1
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 res=execute('spawn, command_line'+key)
      			 end
      		 ELSE:   spawn,'mkdir '       +p1
	   ENDCASE
	   END

	   ;Return /home/sub_dir
	   ;--------------------
'NEWDIR':  BEGIN CASE os of
		'vms':   res = '[' +p1+ '.'  +p2 +']'
      		'Win32': begin cd,current=mee
		         res = mee +    '\'  +p2 & end
      		'MacOS': res =      p1+ ':'  +p2
      		 ELSE:   res = '~' +p1+ '/'  +p2
	   ENDCASE
	   END

	   ;Return  path/sub_dir/
	   ;---------------------
'NEWSUB':  BEGIN CASE os of
		'vms':   res =strmid(p1,0,strlen(p1)-1)+ '.' +p2 +']'
      		'Win32': res =       p1+ '\'  +p2 +'\'
      		'MacOS': res =       p1+ ':'  +p2 +':'
      		 ELSE:   res =       p1+ '/'  +p2 +'/'
	   ENDCASE
	   END

	   ;Start player p1 file_path is p2/p3
	   ;----------------------------------
'PLAY_ON': BEGIN CASE os of
		'vms':   begin p4=0
			 spawn, 'playaifc '+p2+p3,/NOWAIT
			 end
      		'Win32': p4=0 ;CAG I haven't got a sound card
      		'MacOS': begin
      			 script = [  'tell application "' + Lamp_Dir + 'Helpers:SoundMachine 2.1"', $
      						'    open file "' + p2 + ':' + p3 + '"' + LF, $
      				     	'end tell' ]
      			 DO_APPLE_SCRIPT, script
				p4=0
      			 res=1
      		 	 end
      		 ELSE:   spawn, p1+p2+'/'+p3+' &' ,PID=p4
	   ENDCASE
	   END

	   ;Kill player
	   ;-----------
'PLAY_OF': BEGIN CASE os of
		'vms':
      		'Win32':
      		'MacOS': begin
      			script = [  'tell application "' + Lamp_Dir + 'Helpers:SoundMachine 2.1"', $
      						'    quit', $
      				     	'end tell' ]
      			DO_APPLE_SCRIPT, script
      			res=1
      		 	end
      		 ELSE:   spawn, ['kill' , string(p4)] ,/noshell
	   ENDCASE
	   END

	   ;return "path_for_player"
	   ;------------------------
'PLAYER':  BEGIN CASE os of
		'vms':   res=getenv('playaifc')
      		'Win32': res=''
      		'MacOS': res='' ;res='SoundMachine 2.1'
		'IRIX':  begin   res=''
				 spawn,'whereis playaifc',str
				 if strpos(str(0),'/playaifc') gt 0 then res='playaifc -rq '
			 end
      		 ELSE:   res=getenv('playaifc')
	   ENDCASE
	   END


	   ;File extension fs problems (vms)
	   ;--------------------------
'POT':     BEGIN CASE os of
		'vms':   p1=p1+'.'
		 ELSE:
	   ENDCASE
	   END
'POT+':    BEGIN CASE os of
		'vms':begin
				j = STRPOS(p1, '.;')
		       	        if j gt 0 then   p1=STRMID(p1,0,j)+p2+'.' $
			        else     begin
					 if p3 eq 1 then begin
					    j =STRPOS(p1, ';')
				            if j gt 0 then p1=STRMID(p1,0,j)+p2 else p1=p1+p2
				         endif else begin
					    j =STRPOS(p1, '.')
				            if j gt 0 then p1=STRMID(p1,0,j+1)+p2
				         endelse
			        endelse
		      end
		 ELSE:p1=p1+p2
	   ENDCASE
	   END


	   ;Print a PS file p2 to a specified printer_name p1
	   ;-------------------------------------------------
'PRINT':   BEGIN CASE os of
		'vms':   spawn,'print/notify/queue='+p1+' '+p2
      		'Win32':begin kp=!D.name & set_plot,"WIN"
			      DEVICE,print_file=p2 & set_plot,kp & end
      		'MacOS':begin
      			;;Do you really want to choose a printer ???
      			;script = [  'tell application "Finder"',$
      			;	    'print file "' + p2 + '"'  ,$
      			;	    'end tell' ]
      			;DO_APPLE_SCRIPT, script, RESULT=res
			;HANSEN!!
      			lf=STRING(13B)
      			CD,CURRENT=current_directory
			if strpos(p2,':') lt 0 then p3=current_directory+p2 else p3=p2
      			PRINT,'print ',p3,' on ', p1
      			script=['tell application "Finder"'+lf+'copy file "'+p3+'" to item "'+p1+'"'+lf+'end tell']
      			PRINT,script
      			DO_APPLE_SCRIPT, script;, RESULT=res
      		 	end
		'linux':begin
			print,'lpr -P'+p1+' '+p2
			spawn,'lpr -P'+p1+' '+p2
			end
      		 ELSE:  begin
			 if strpos(p2,'_s.') gt 0 then print,'lp -c -d'+p1+' '+p2 $
						  else print,'lp -d'   +p1+' '+p2
			 if strpos(p2,'_s.') gt 0 then spawn,'lp -c -d'+p1+' '+p2 $
						  else spawn,'lp -d'   +p1+' '+p2
			end
	   ENDCASE
	   END

	   ;Print a file p1 to the default printer
	   ;--------------------------------------
'PRT_DEF': BEGIN CASE os of
		'vms':   spawn,'print '+p1
      		'Win32':begin kp=!D.name & set_plot,"WIN"
			      DEVICE,print_file=p1 & set_plot,kp & end
      		'MacOS':begin
      			;script = [  'tell application "Finder"', $
      			;	    'print file "' + p1 +'"'   , $
      			;	    'end tell' ]
      			;DO_APPLE_SCRIPT, script, RESULT=res
			;HANSEN!!
      			lf=STRING(13B)
      			CD,CURRENT=current_directory
			if strpos(p1,':') lt 0 then p3=current_directory+p1 else p3=p1
      			PRINT,'print ', p3
      			script = ['tell application "Finder"'+lf+'print file "'+p3+'"'+lf+'end tell']
      			PRINT,script
      			DO_APPLE_SCRIPT, script, RESULT=res
      		 	end
		'linux':spawn,'lpr '  +p1
      		 ELSE:  spawn,'lp '   +p1
	   ENDCASE
	   END

	   ;Color: type of visual
	   ;---------------------
'PSEUDO':  BEGIN CASE os of
      		'Win32':
      		'linux':;if (!D.name ne 'Z') and (!D.name ne 'TEK') then device, pseudo_color = 8
      		 ELSE:	 if (!D.name ne 'Z') and (!D.name ne 'TEK') then device, pseudo_color = 8
	   ENDCASE
	   if (!D.name ne 'Z') and (!D.name ne 'TEK') then device, decomposed   = 0
	   END

	   ;Byte Order compatibility
	   ;------------------------
'SWAPER':  BEGIN CASE os of
		'vms':   if (p1 eq 'uni') or (p1 eq 'mac') then res=1
      		'Win32': if (p1 eq 'uni') or (p1 eq 'mac') then res=1
		'linux': if (p1 eq 'uni') or (p1 eq 'mac') then res=1
      		'MacOS': if (p1 eq 'vms') or (p1 eq 'win') or (p1 eq 'lin') then res=1
      		 ELSE:   if (p1 eq 'vms') or (p1 eq 'win') or (p1 eq 'lin') then res=1
	   ENDCASE
	   END

	   ;Zip file p1
	   ;-------- --
'ZIP':    BEGIN CASE os of
		'vms':   res=0
      		'Win32': begin
      			 command_line='gzip -fq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 res=execute('spawn, command_line'+key)
      			 end
      		'MacOS': res=0
      		 ELSE:   begin	if ziper eq ''  then begin
				   spawn,'whereis zip',str
				   if strpos(str(0),'/zip') gt 0 then ziper='zip' else ziper='-'
				endif
				res=1
				if ziper ne '-' then begin
				   fzip=strmid(p1,0,strpos(p1,'.'))
				   if p2 ne '' then spawn, 'cd '+p2+' ; zip -mq ' +fzip+' ' +p1
				   if p2 eq '' then spawn,             'zip -mq ' +fzip+' ' +p1
				endif else res=0
			 end
	   ENDCASE
	   END

	   ;UnZip file p1
	   ;---------- --
'UNZIP':  BEGIN CASE os of
		'vms':   res=0
      		'Win32': begin	if ziper eq ''  then begin
				bid= findfile(!Dir+'\gzip.exe',count=nn)
				if nn gt 0 then ziper=!Dir+'\gzip' else ziper='gzip'
				endif
      			 command_line=ziper+' -dfq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 res=execute('spawn, command_line'+key)
      			 end
      		'MacOS': res=0
      		 ELSE:   begin	if ziper eq ''  then begin
				   spawn,'whereis unzip',str
				   if strpos(str(0),'/unzip') gt 0 then ziper='zip' else ziper='-'
				endif
				res=1
				if ziper ne '-' then spawn, 'cd '+p2+' ; unzip -qqux ' +p1 else res=0
			 end
	   ENDCASE
	   END

	   ;Compress file p1
	   ;-------- ---- --
'DO_Z':    BEGIN CASE os of
		'vms':   begin
			 spawn, 'compress -f '+p1
			 spawn, 'rename '+p1+'_Z '+p1+'Z' ,/NOWAIT
			 end
      		'Win32': begin
      			 command_line='gzip -fq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 ii=execute('spawn, command_line'+key)
      			 end
      		'MacOS':
      		 ELSE:   spawn, 'compress -f '   +p1
	   ENDCASE
	   END

	   ;UnCompress file p1
	   ;---------- -------
'UN_Z':    BEGIN CASE os of
		'vms':   spawn, 'gunzip -dfq '+p1
      		'Win32': begin	if ziper eq ''  then begin
				bid= findfile(!Dir+'\gzip.exe',count=nn)
				if nn gt 0 then ziper=!Dir+'\gzip' else ziper='gzip'
				endif
      			 command_line=ziper+' -dfq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 ii=execute('spawn, command_line'+key)
      			 end
      		'MacOS':begin
      			; 'LZIV' = signature de l'application "MacCompress3.2"
      			; spawn, MACCREATOR='LZIV', p1

      			script = [  'tell application "' + Lamp_Dir + 'Helpers:MacGzipPPC"',$
							'    open file "' + p1 + '"',$
							'end tell' ]

				DO_APPLE_SCRIPT, script

				; MacGzip works in the background
				; so we need to wait for the uncompressed files
				uncompressedFile = STRMID(p1, 0, STRLEN(p1)-2) ; Strip ".Z" suffixe
				dummy = FindFile(uncompressedFile, Count=AreYouThere)
				WHILE (AreYouThere EQ 0) DO BEGIN
					Print, "Waiting..."
					Wait, 0.5
					dummy = FindFile(uncompressedFile, Count=AreYouThere)
				ENDWHILE

				res=1

      		 	 end
      		 ELSE:   spawn, 'uncompress -f ' +p1
	   ENDCASE
	   END

	   ;UnCompress file list p1
	   ;---------- ------------
'UN_ZLIS': BEGIN CASE os of
		'vms':   BEGIN
			 ch=p1(0) & n=n_elements(p1)-1
			 if n gt 0 then for i=1,n do ch=ch+' '+p1(i)
			 spawn, 'gunzip -dfq '+ch
			 END
      		'Win32': begin	if ziper eq ''  then begin
				bid= findfile(!Dir+'\gzip.exe',count=nn)
				if nn gt 0 then ziper=!Dir+'\gzip' else ziper='gzip'
				endif
      			 command_line=ziper+' -dfq' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 for i=0,n_elements(p1)-1 do begin com_line=command_line+' "'+p1(i)+'"'
      			                          ii=execute('spawn, com_line'+key) & endfor
      			 end
      		'MacOS':begin
      			; Get the current dir
      			cd, CURRENT=homeFolder

				; Add path
				fileArray = homeFolder + p1

				lastFile = fileArray(n_elements(fileArray)-1)

      			; Prepare the file list in AppleScript format
      			Build_MacFileListFromArray, fileArray ,macFileList

      			; Print, "SD :UN_ZLIS :" + macFileList

      			script = [  'tell application "' + Lamp_Dir + 'Helpers:MacGzipPPC"',$
							'    open ' + macFileList + LF,$
							'end tell' ]

				; Print, "Quitting IDL..."

				DO_APPLE_SCRIPT, script

				; Print, "Returning..."

				; MacGzip works in the background
				; so we need to wait for the last uncompressed file
				lastFile = STRMID(lastFile, 0, STRLEN(lastFile)-2) ; Strip ".Z" suffixe
				dummy = FindFile(lastFile, Count=AreYouThere)
				WHILE (AreYouThere EQ 0) DO BEGIN
					Print, "Waiting..."
					Wait, 0.5
					dummy = FindFile(lastFile, Count=AreYouThere)
				ENDWHILE

				; Print, "OK"
				res=1

      		 	 end
      		 ELSE:   spawn,['uncompress','-f',p1],/noshell
	   ENDCASE
	   END

'DEMO':     if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/DEMO)<1')     else res=0
'STUDENT':  if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/STUDENT)<1')  else res=0
'RUNTIME':  if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/RUNTIME)<1')  else res=0
'EMBEDDED': if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/EMBEDDED)<1') else res=0
'VERSION':  res=float(!version.release)
'MATLAB':   res=matlab

	   ;Start a VIEWER (vrml file is lamp.wrl)
	   ;--------------------------------------
'VIEWER':  BEGIN CASE os of
		'vms':  begin if viewer eq ''  then begin
				 viewer=getenv('VrmlViewer')
				 if viewer eq '' then begin viewer='-'
				    print,string(7b)+'(no logical VrmlViewer) !!!' & endif
			      endif
			      res=1
			      if viewer ne '-' then begin
				 if n_elements(p1) eq 1 then spawn,'VrmlViewer '+p1,/NOWAIT
			      endif
			end
      		'Win32':res=1
      		'MacOS':res=1
      		 ELSE:  begin if viewer eq ''  then begin
				 spawn,'whereis webspace',str
				 if strpos(str(0),'/webspace') gt 0 then viewer='webspace -remote ' $
				 else begin spawn,'whereis modelviewer',str
				 if strpos(str(0),'/modelvie') gt 0 then viewer='modelviewer -remote ' $
				 else begin spawn,'whereis vrweb',str
				 if strpos(str(0),'/vrweb')    gt 0 then viewer='vrweb  -remote ' $
				 else begin spawn,'whereis ivview',str
				 if strpos(str(0),'/ivview')   gt 0 then viewer='ivview  '
				 endelse & endelse & endelse
				 if viewer eq '' then viewer=getenv('VrmlViewer')
				 if viewer eq '' then begin viewer='-'
				    print,string(7b)+'(webspace,modelviewer,vrweb,ivview,$VrmlViewer) not found !!!' & endif
			      endif
			      res=1
			      if viewer ne '-' then begin
				 if n_elements(p1) eq 1 then spawn,viewer+' '+p1+' &'
			      endif
			end
	   ENDCASE
	   END

ELSE:
ENDCASE

RETURN,res
END ; sys_dep


function logoidl,ab
;******* *******
;**
blnc=255B & noir=4B & vert=60B & viol=200B & jaun=85
a   = long(ab)  & b=long(ab)
w   = bytarr(a ,b)+blnc
idx =(indgen(a*(b/2))*2)
w(idx)  =vert
w(*,3)  =blnc & w(*,(b-2)/3+2)=blnc & w(*,(b-2)/3*2+1)=blnc & w(*,b-2)=blnc
w(1,*)  =blnc & w((a-2)/3,*)  =blnc & w((a-2)/3*2-1,*)=blnc & w(a-4,*)=blnc
w(*,b-1)=noir
w(0,*)  =noir
w(*,2)  =noir
w(a-3,*)=noir
w(*,0)  =0  & w(5:*,0)    =noir+35
w(*,1)  =0  & w(5:*,1)    =noir+35
w(a-1,*)=0  & w(a-1,0:b-6)=noir+35
w(a-2,*)=0  & w(a-2,0:b-6)=noir+35
w( 2       :(a-2)/3-1   ,  4         :(b-2)/3+1)=jaun
w((a-2)/3+1:(a-2)/3*2-2 , (b-2)/3*2+2: b-3)     =jaun
w((a-2)/3*2:(a-5)       , (b-2)/3+3  :(b-2)/3*2)=jaun
return,w
end

pro lampico, cocone, ldi=ldi
;**********
;**
if n_elements(ldi) eq 1 then cocone=logoidl(ldi) $
else begin
 cocone=[ $
 145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,144,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,140,132,136,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,137,128,130,125,128,136,144,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,141,139,128,129,125,128,124,126,122,128,138,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,142,130,127,131,125,127,124,125,122,123,118,116,118,131,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,142,132,127,127,125,129,122,127,120,120,116,115,115,112,118,105,115 ] & cocone=[cocone $
,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,135,130,127,127,125,128,122,127,120,124,116,120,112,112,109,105,105,105 ] & cocone=[cocone $
,100,103,108,119,136,144,143,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,139,128,129,125,128,122,126,122,120,119,116,123,112,118,109,105,105,113,99 ] & cocone=[cocone $
,94,94,94,94,94,94,98,124,128,142,141,145,145,145,145,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,142,137 ] & cocone=[cocone $
,127,129,125,127,124,125,122,123,118,116,115,112,116,109,105,105,102,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,102,105,105,108,112,119,116,118,123,123,128,133,136 ] & cocone=[cocone $
,136,142,140,140,140,140,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,144,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,132,127 ] & cocone=[cocone $
,130,125,129,122,125,120,123,116,121,115,112,118,105,105,105,112,94,94,94 ] & cocone=[cocone $
,94,94,94,94,96,105,105,105,110,112,115,116,119,120,122,124,125,127,129 ] & cocone=[cocone $
,129,130,131,132,133,134,134,135,135,137,140,142,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138,134,127,127 ] & cocone=[cocone $
,125,129,122,127,120,124,116,120,115,112,114,105,105,105,112,94,94,94,94 ] & cocone=[cocone $
,94,94,94,96,105,105,105,110,112,115,116,119,121,122,125,126,128,129,129 ] & cocone=[cocone $
,130,131,133,133,134,134,135,135,135,135,135,142,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,139,127,126,126,125 ] & cocone=[cocone $
,124,122,122,120,119,116,123,112,118,109,105,105,113,99,94,94,94,94,94 ] & cocone=[cocone $
,94,94,102,105,105,106,112,112,116,116,120,121,123,125,126,128,129,130,131 ] & cocone=[cocone $
,131,133,134,134,135,135,135,135,135,136,145,145,145,145,145,145,140,137,140 ] & cocone=[cocone $
,144,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,144,136,127,129,125,128,124 ] & cocone=[cocone $
,125,122,123,116,116,119,112,118,109,105,105,113,99,94,94,94,94,94,94 ] & cocone=[cocone $
,94,102,105,105,106,112,112,116,117,120,121,124,125,127,129,129,130,131,132 ] & cocone=[cocone $
,133,134,134,135,135,135,135,135,137,145,145,145,145,145,145,137,135,135,136 ] & cocone=[cocone $
,135,137,141,144,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,133,127,130,125,127,122,125 ] & cocone=[cocone $
,120,123,116,121,115,112,120,105,105,105,112,94,94,94,94,94,94,94,96 ] & cocone=[cocone $
,102,105,105,110,112,115,116,119,120,122,124,125,127,129,129,130,131,132,133 ] & cocone=[cocone $
,134,134,135,135,135,135,135,140,145,145,145,145,145,144,136,135,135,137,135 ] & cocone=[cocone $
,135,136,134,135,135,144,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,138,133,127,127,125,125,122,127,120 ] & cocone=[cocone $
,126,116,121,115,112,118,105,105,105,112,94,94,94,94,94,94,94,96,105 ] & cocone=[cocone $
,105,105,110,112,115,116,119,120,122,125,126,127,129,129,130,131,133,133,134 ] & cocone=[cocone $
,134,135,135,135,135,135,140,145,145,145,145,145,141,135,135,135,136,135,135 ] & cocone=[cocone $
,136,134,135,133,134,132,134,142,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,140,129,130,126,125,124,122,122,120,119 ] & cocone=[cocone $
,120,130,119,119,113,105,105,113,110,94,94,94,94,94,94,94,96,105,105 ] & cocone=[cocone $
,105,112,112,115,116,120,121,123,125,126,128,129,130,130,131,133,133,134,135 ] & cocone=[cocone $
,135,135,135,135,136,145,145,145,145,145,144,136,135,135,136,135,135,136,134 ] & cocone=[cocone $
,134,135,133,133,131,134,130,132,131,141,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,144,135,128,129,126,128,124,122,122,120,119,126 ] & cocone=[cocone $
,124,104,94,120,115,104,125,99,94,94,94,94,94,94,94,102,105,105,106 ] & cocone=[cocone $
,112,112,116,116,120,121,123,125,126,128,129,130,131,132,133,134,134,135,135 ] & cocone=[cocone $
,135,135,135,136,145,145,145,145,145,141,135,135,135,136,135,135,136,134,134 ] & cocone=[cocone $
,135,133,134,131,133,130,133,129,131,127,131,135,144,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,133,127,131,125,127,122,125,120,123,116,124,122 ] & cocone=[cocone $
,68,62,141,94,94,109,125,110,110,99,104,94,94,94,102,105,105,108,112 ] & cocone=[cocone $
,113,116,118,120,122,124,125,127,129,129,130,131,132,133,134,134,135,135,135 ] & cocone=[cocone $
,135,135,140,145,145,145,145,145,141,135,135,135,137,135,135,136,134,135,133 ] & cocone=[cocone $
,134,132,131,131,130,130,129,128,130,126,125,124,126,128,136,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,138,133,127,129,125,127,122,125,120,123,121,124,106,36 ] & cocone=[cocone $
,62,47,109,109,125,125,109,94,94,94,109,73,94,99,110,105,120,112,115 ] & cocone=[cocone $
,116,119,120,122,125,125,127,129,129,130,131,133,133,134,134,135,135,135,135 ] & cocone=[cocone $
,135,140,145,145,145,145,145,139,135,135,135,137,135,135,136,134,135,133,134 ] & cocone=[cocone $
,132,133,131,132,130,131,127,126,126,128,124,126,122,124,119,122,141,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,141,129,130,127,125,124,122,122,120,124,115,126,94,47,47 ] & cocone=[cocone $
,62,47,94,125,109,94,94,94,109,109,109,109,109,36,110,125,115,114,116 ] & cocone=[cocone $
,119,120,123,125,126,128,129,130,130,131,133,133,134,136,135,135,135,135,136 ] & cocone=[cocone $
,142,145,145,145,145,144,136,135,135,136,137,135,136,134,134,135,133,134,131 ] & cocone=[cocone $
,133,130,132,129,131,127,130,125,127,122,127,120,123,118,121,119,112,116,128 ] & cocone=[cocone $
,144,145,145,145,145,145,145,145,145,145,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,144,138,129,130,126,125,124,122,122,120,119,126,124,84,47,47,62 ] & cocone=[cocone $
,47,62,47,47,73,94,125,109,125,94,125,109,94,81,63,109,94,99,120 ] & cocone=[cocone $
,121,123,125,126,128,129,130,130,131,133,135,137,137,137,134,135,135,135,141 ] & cocone=[cocone $
,144,145,145,145,144,135,135,135,136,135,135,136,134,134,135,133,134,131,131 ] & cocone=[cocone $
,130,133,129,131,127,130,125,129,122,127,120,126,116,121,115,112,118,105,105 ] & cocone=[cocone $
,105,111,119,136,142,145,145,145,145,145,142,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,133,127,131,125,127,124,121,122,124,118,125,122,83,47,47,62,62 ] & cocone=[cocone $
,47,83,94,94,94,73,73,78,62,125,109,94,43,117,21,78,62,120,121 ] & cocone=[cocone $
,123,125,127,129,129,130,131,132,133,137,137,137,136,134,135,137,138,138,138 ] & cocone=[cocone $
,136,145,145,141,135,135,135,135,135,135,136,134,134,134,133,132,131,131,130 ] & cocone=[cocone $
,130,129,128,130,126,125,128,126,127,120,125,116,121,115,112,117,105,105,105 ] & cocone=[cocone $
,110,94,94,94,94,108,125,142,142,143,135,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,138,137,127,130,125,127,122,125,120,123,121,124,112,68,62,47,31,47,57 ] & cocone=[cocone $
,94,94,94,94,94,94,94,95,105,93,66,68,96,79,15,31,68,122,125 ] & cocone=[cocone $
,125,127,129,129,130,131,134,136,136,137,136,135,138,131,138,136,136,137,136 ] & cocone=[cocone $
,145,145,139,135,135,135,137,135,135,136,134,135,133,134,131,133,131,130,130 ] & cocone=[cocone $
,129,128,130,126,128,124,126,122,124,119,116,122,112,118,105,105,105,113,100 ] & cocone=[cocone $
,94,94,94,94,94,94,94,95,105,111,135,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,141 ] & cocone=[cocone $
,129,130,130,125,126,122,127,120,125,121,126,94,47,62,47,47,31,62,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,105,110,112,113,31,15,15,107,128,130 ] & cocone=[cocone $
,131,132,132,130,131,135,136,136,135,134,133,135,129,136,136,134,130,141,134 ] & cocone=[cocone $
,144,139,135,135,135,137,135,135,134,134,135,133,134,131,133,130,132,129,131 ] & cocone=[cocone $
,127,127,126,124,124,125,122,124,118,116,122,112,116,109,105,105,110,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,140,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138,129 ] & cocone=[cocone $
,130,126,125,124,122,122,120,119,126,122,99,47,62,62,47,62,73,94,94 ] & cocone=[cocone $
,94,94,94,94,94,100,105,105,105,112,112,115,69,15,0,31,137,137,135 ] & cocone=[cocone $
,133,134,134,133,135,136,135,133,132,131,127,104,137,135,132,130,126,131,141 ] & cocone=[cocone $
,135,135,135,136,135,135,136,134,134,136,133,134,131,133,130,132,129,131,127 ] & cocone=[cocone $
,130,125,127,122,127,120,126,116,121,112,112,120,105,105,105,110,94,94,94 ] & cocone=[cocone $
,94,94,94,94,94,98,105,105,140,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,130,128,130 ] & cocone=[cocone $
,126,128,124,126,122,124,118,125,122,73,47,47,62,31,47,83,94,94,94 ] & cocone=[cocone $
,94,94,94,94,102,105,105,108,112,113,116,112,5,0,0,94,141,141,121 ] & cocone=[cocone $
,131,131,126,134,135,133,129,128,99,99,61,137,134,130,130,122,100,100,135 ] & cocone=[cocone $
,135,135,137,135,135,136,134,134,134,133,132,131,131,133,133,129,130,127,130 ] & cocone=[cocone $
,125,129,122,127,120,125,116,121,115,112,117,105,105,105,110,94,94,94,94 ] & cocone=[cocone $
,94,94,94,94,102,105,119,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,141,137,127,130,125 ] & cocone=[cocone $
,127,122,125,122,119,118,125,112,68,62,47,62,47,57,83,94,94,94,94 ] & cocone=[cocone $
,94,94,95,105,105,105,108,112,114,116,121,65,15,0,15,141,94,94,141 ] & cocone=[cocone $
,94,99,101,133,131,128,99,83,62,91,137,135,130,127,121,106,66,136,137 ] & cocone=[cocone $
,138,139,139,136,136,134,134,134,133,132,131,133,136,135,135,128,130,126,125 ] & cocone=[cocone $
,124,126,120,124,122,116,120,112,112,109,105,105,105,100,94,94,94,94,94 ] & cocone=[cocone $
,94,94,95,102,105,119,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,139,130,127,130,125,129 ] & cocone=[cocone $
,122,127,120,125,116,123,116,68,62,47,47,47,47,94,94,94,94,94,94 ] & cocone=[cocone $
,94,95,105,105,105,110,112,115,116,119,121,31,0,15,15,94,125,141,109 ] & cocone=[cocone $
,94,62,37,121,109,83,62,75,136,136,133,132,128,117,110,112,138,138,138 ] & cocone=[cocone $
,138,138,138,134,134,135,133,134,131,133,134,134,132,141,133,127,126,128,124 ] & cocone=[cocone $
,125,122,124,118,116,122,112,118,109,105,105,110,95,94,94,94,94,94,94 ] & cocone=[cocone $
,94,95,105,105,136,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,144,129,130,126,125,128,122 ] & cocone=[cocone $
,125,120,125,116,120,97,47,62,47,47,62,67,94,94,94,94,94,94,94 ] & cocone=[cocone $
,100,105,105,105,112,112,116,116,120,123,93,15,0,15,78,94,94,94,94 ] & cocone=[cocone $
,94,62,47,94,62,61,121,137,135,132,129,125,115,68,122,138,137,138,138 ] & cocone=[cocone $
,135,137,137,127,136,133,134,131,133,135,132,127,118,129,121,125,127,128,134 ] & cocone=[cocone $
,127,127,118,116,115,112,116,105,105,105,110,94,94,94,94,94,94,94,94 ] & cocone=[cocone $
,98,105,105,140,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,134,131,130,126,128,124,126,122 ] & cocone=[cocone $
,124,118,116,122,112,118,15,47,47,62,88,94,94,94,94,94,94,94,100 ] & cocone=[cocone $
,105,105,107,112,113,116,116,120,121,119,42,0,0,47,47,47,0,15,62 ] & cocone=[cocone $
,109,62,94,46,135,136,137,133,132,130,122,103,84,122,138,135,136,137,133 ] & cocone=[cocone $
,132,133,131,127,133,134,131,132,134,131,124,112,68,94,76,129,129,127,129 ] & cocone=[cocone $
,131,129,123,115,112,112,105,105,105,114,94,94,94,94,94,94,94,94,100 ] & cocone=[cocone $
,105,113,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,137,127,127,125,124,124,126,122,124 ] & cocone=[cocone $
,118,116,122,112,116,105,46,31,47,83,94,94,94,94,94,94,95,105,105 ] & cocone=[cocone $
,105,108,112,114,116,118,120,122,122,114,0,0,15,44,39,41,15,31,31 ] & cocone=[cocone $
,78,31,75,135,137,137,135,130,130,121,106,68,137,136,133,134,133,131,128 ] & cocone=[cocone $
,120,115,94,131,132,131,133,134,130,123,107,36,47,94,113,131,124,90,109 ] & cocone=[cocone $
,109,65,112,112,109,105,105,105,100,94,94,94,94,94,94,94,95,102,105 ] & cocone=[cocone $
,119,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,142,133,127,130,125,129,122,127,120,125,116 ] & cocone=[cocone $
,121,112,112,120,105,105,105,52,83,94,94,94,94,94,94,95,105,105,105 ] & cocone=[cocone $
,108,112,114,116,119,120,122,125,122,90,0,0,71,127,109,78,78,94,60 ] & cocone=[cocone $
,75,135,135,136,136,134,132,128,116,110,91,135,134,133,127,131,116,109,75 ] & cocone=[cocone $
,93,55,61,130,133,133,134,129,121,100,47,47,47,101,127,119,94,47,78 ] & cocone=[cocone $
,94,87,118,109,105,105,105,100,94,94,94,94,94,94,94,95,105,105,131 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,144,130,127,127,125,129,122,127,120,125,116,120 ] & cocone=[cocone $
,115,112,109,105,105,105,100,94,94,94,94,94,94,94,100,105,105,105,112 ] & cocone=[cocone $
,112,116,116,120,121,122,125,126,120,38,0,15,99,78,94,94,61,120,135 ] & cocone=[cocone $
,135,135,137,135,133,132,125,115,58,90,132,132,131,127,109,57,76,119,129 ] & cocone=[cocone $
,111,37,69,134,133,133,127,118,73,47,47,62,112,127,119,47,62,47,78 ] & cocone=[cocone $
,75,116,105,105,105,110,94,94,94,94,94,94,94,94,98,105,105,140,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,134,131,130,126,128,124,126,124,124,124,116,120,112 ] & cocone=[cocone $
,112,109,105,105,105,100,94,94,94,94,94,94,94,100,105,105,105,112,112 ] & cocone=[cocone $
,116,116,120,121,123,125,127,128,129,5,0,78,94,31,76,119,135,135,135 ] & cocone=[cocone $
,135,136,135,134,130,124,109,84,115,132,124,121,99,62,90,134,134,133,124 ] & cocone=[cocone $
,80,15,106,132,131,123,121,68,47,47,44,112,129,112,52,62,62,47,47 ] & cocone=[cocone $
,104,105,105,105,110,94,94,94,94,94,94,94,94,100,105,110,140,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,144,144,135,128,129,125,128,124,126,122,124,118,116,122,112,116 ] & cocone=[cocone $
,109,105,105,110,99,94,94,94,94,94,94,95,102,105,105,108,112,114,116 ] & cocone=[cocone $
,118,120,122,124,125,127,128,129,130,43,62,61,119,134,135,135,135,135,135 ] & cocone=[cocone $
,137,139,132,130,121,102,73,133,131,121,83,62,105,136,134,134,135,130,118 ] & cocone=[cocone $
,37,31,133,130,123,103,57,47,62,56,131,124,102,52,47,62,31,47,97 ] & cocone=[cocone $
,105,105,105,110,94,94,94,94,94,94,94,95,100,105,119,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,141,132,127,130,125,129,124,123,122,123,118,116,115,112,116,105 ] & cocone=[cocone $
,105,105,110,94,94,94,94,94,94,94,95,105,105,105,108,112,114,116,118 ] & cocone=[cocone $
,120,122,124,125,127,129,129,130,131,117,46,134,134,135,135,135,135,135,139 ] & cocone=[cocone $
,145,145,125,120,94,57,115,94,115,137,120,135,136,134,135,134,132,127,106 ] & cocone=[cocone $
,0,50,130,122,100,47,47,62,89,126,123,94,47,47,47,62,53,109,105 ] & cocone=[cocone $
,105,105,100,94,94,94,94,94,94,94,95,105,105,127,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,133,127,125,129,122,127,120,125,116,120,115,112,111,105,105 ] & cocone=[cocone $
,105,109,94,94,94,94,94,94,94,95,105,105,105,110,112,115,116,120,121 ] & cocone=[cocone $
,122,125,126,127,129,129,130,131,132,133,134,134,135,135,135,135,135,142,145 ] & cocone=[cocone $
,145,145,127,73,62,31,90,135,135,135,135,134,134,135,133,134,132,121,60 ] & cocone=[cocone $
,31,78,121,90,47,62,47,85,127,116,89,62,47,31,47,58,121,117,105 ] & cocone=[cocone $
,102,99,94,94,94,94,94,94,94,95,105,105,132,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,134,122,127,120,125,116,120,112,112,109,105,105,105 ] & cocone=[cocone $
,100,94,94,94,94,94,94,94,100,105,105,105,112,112,116,116,120,121,122 ] & cocone=[cocone $
,125,126,128,129,130,130,131,133,133,134,134,135,135,135,135,135,142,145,145 ] & cocone=[cocone $
,145,145,144,60,60,135,135,135,135,136,134,134,136,133,135,131,133,114,5 ] & cocone=[cocone $
,31,123,68,31,62,44,112,127,112,52,62,47,47,31,78,110,141,94,115 ] & cocone=[cocone $
,99,104,94,94,94,94,94,94,100,105,109,140,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,142,125,116,116,112,110,109,105,105,113,100 ] & cocone=[cocone $
,94,94,94,94,94,94,94,100,105,105,106,112,113,116,117,120,121,124,125 ] & cocone=[cocone $
,127,128,129,130,130,131,133,134,134,135,135,135,135,135,137,145,145,145,145 ] & cocone=[cocone $
,145,141,135,135,135,136,135,135,136,134,134,135,133,134,131,133,128,100,0 ] & cocone=[cocone $
,0,94,47,47,44,131,121,112,52,62,47,47,47,109,94,94,109,141,94 ] & cocone=[cocone $
,78,68,109,104,94,94,94,100,105,113,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,141,123,116,105,105,105,110,94,94 ] & cocone=[cocone $
,94,94,94,94,94,95,105,105,105,108,112,114,116,118,120,122,124,125,127 ] & cocone=[cocone $
,128,129,130,131,132,133,134,134,135,135,135,135,135,137,145,145,145,145,145 ] & cocone=[cocone $
,141,135,135,135,136,135,135,136,134,135,134,134,132,133,131,132,126,55,31 ] & cocone=[cocone $
,47,78,62,69,126,123,94,52,47,62,31,47,125,94,141,141,125,109,94 ] & cocone=[cocone $
,94,94,78,57,89,95,105,105,127,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,131,118,114,94,94,94 ] & cocone=[cocone $
,94,94,94,94,95,105,105,105,110,112,115,116,119,120,122,124,126,127,129 ] & cocone=[cocone $
,129,130,131,132,133,134,134,135,135,135,135,135,141,145,145,145,145,145,138 ] & cocone=[cocone $
,135,135,135,135,135,135,135,134,135,133,134,132,133,131,132,130,131,26,62 ] & cocone=[cocone $
,94,78,85,126,121,89,62,47,47,47,31,109,109,125,94,94,141,109,125 ] & cocone=[cocone $
,109,94,62,15,68,105,105,132,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,139,122,111,105 ] & cocone=[cocone $
,94,94,94,98,105,105,105,110,112,116,116,120,121,122,125,126,127,129,129 ] & cocone=[cocone $
,130,131,133,133,134,134,135,135,135,135,135,142,145,145,145,145,145,136,135 ] & cocone=[cocone $
,135,135,135,135,136,134,134,136,133,135,131,134,131,131,130,131,128,56,31 ] & cocone=[cocone $
,31,94,120,105,84,62,47,47,47,78,94,94,94,109,94,94,94,125,125 ] & cocone=[cocone $
,109,78,47,0,55,109,140,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,128,117,118,105,106,112,112,116,116,120,121,123,125,126,128,129,130,130 ] & cocone=[cocone $
,131,133,134,134,135,135,135,135,135,136,142,145,145,145,145,141,135,135,135 ] & cocone=[cocone $
,135,135,135,136,134,134,135,133,134,131,133,130,133,129,132,127,127,125,13 ] & cocone=[cocone $
,108,125,120,63,47,47,47,62,62,15,47,47,31,47,0,31,47,94,109 ] & cocone=[cocone $
,109,78,47,0,110,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,141,145,145,139,137,137,131,133,132,129,131,132,132 ] & cocone=[cocone $
,133,134,134,135,135,135,135,135,137,145,145,145,145,145,141,135,135,135,136 ] & cocone=[cocone $
,135,135,136,134,135,134,134,134,133,132,130,133,129,132,127,127,125,128,122 ] & cocone=[cocone $
,122,120,124,116,31,47,62,62,31,15,0,15,0,0,15,0,0,0,0 ] & cocone=[cocone $
,31,47,15,39,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,142,141,138,135,135,139,145,145,145,145,145,141,135,135,135,137,135 ] & cocone=[cocone $
,135,136,134,135,133,134,132,133,131,132,130,131,128,129,126,128,124,126,122 ] & cocone=[cocone $
,120,119,116,123,53,47,70,23,15,0,15,0,0,47,0,78,94,141,94 ] & cocone=[cocone $
,62,31,31,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,136,135,135,135,135,135,136 ] & cocone=[cocone $
,135,134,134,133,134,132,133,131,132,130,131,128,129,125,128,124,125,120,123 ] & cocone=[cocone $
,118,116,122,112,110,109,105,105,0,15,0,0,15,0,47,94,109,94,141 ] & cocone=[cocone $
,125,62,80,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,139,135,136,135,135,136,134 ] & cocone=[cocone $
,134,135,133,134,131,133,130,130,129,132,127,130,125,127,122,127,120,123,116 ] & cocone=[cocone $
,121,115,112,118,105,105,105,112,83,0,31,15,0,31,94,109,125,141,109 ] & cocone=[cocone $
,78,96,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,142,139,137,134,134 ] & cocone=[cocone $
,135,133,134,131,133,130,133,129,132,127,127,125,129,122,127,120,123,116,121 ] & cocone=[cocone $
,115,112,118,105,105,105,112,94,94,94,41,0,0,0,78,78,109,141,63 ] & cocone=[cocone $
,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138 ] & cocone=[cocone $
,134,132,133,130,132,130,129,128,130,126,125,124,126,122,120,119,116,123,112 ] & cocone=[cocone $
,118,109,105,105,113,105,94,94,94,94,94,94,62,74,46,35,92,112,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,140,131,132,130,131,128,129,125,128,122,121,122,124,119,116,122,112,118 ] & cocone=[cocone $
,109,105,105,113,99,94,94,94,94,94,94,94,96,105,105,132,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,139,133,127,130,125,127,122,127,120,123,116,121,115,112,120,109 ] & cocone=[cocone $
,105,105,106,99,94,94,94,94,94,94,94,96,105,110,140,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,140,129,127,122,127,120,123,116,121,115,112,118,105,105 ] & cocone=[cocone $
,105,112,94,94,94,94,94,94,94,94,102,105,110,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,136,120,124,116,117,115,112,118,105,105,105 ] & cocone=[cocone $
,112,94,94,94,94,94,94,94,94,102,105,119,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,135,123,112,118,109,105,105,113,99 ] & cocone=[cocone $
,94,94,94,94,94,94,94,96,102,105,132,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,122,105,105,113,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,140,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,134,111,105,94 ] & cocone=[cocone $
,94,94,94,94,94,98,105,110,140,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,128,111,94,94,102,105,119,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,140,131,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145]

 cocone=reform(cocone,128,64)
endelse
return
end


pro Show_Version, wid, version, bil
;** ************
;**
@lamp.cbk
	version='18 Sep 2003 for idl 3.6.1 -> 6.0'

	if wid gt 0 then begin
	 bil=widget_base (wid,/row)
	 bid	=widget_label (bil  ,value='Version '+version            ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab1'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab2'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab3'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab4'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab5'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab6'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab7'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab8'   ,font=ft_smaller)
	 bid	=widget_label (bil  ,value='.',resource_name='spelab9'   ,font=ft_smaller)
	endif
end

;*			******************
;*			**              **
			  PRO LAMP_,just
;*			**              **
;*			******************


;**		LARGE ARRAY MANIPULATION PROGRAM
;**		----- ----- ------------ -------

;**	This module manages the LAMP application.
;**	It is written at ILL Grenoble (France ill.fr) by M. Ferrand  for data integrity
;**							 G. Kearley  for users  integrity
;**							 D. Richard  for project  integrity
;**							 B. Vettier  for excellent functions
;**							 R. Jouffrey for wonderfull superplot

;**	The LAMP package is distributed as "Shareware". If you find this application
;**	useful, you may register your copy simply by sending an electronic mail
;**	message to lamp@ill.fr. We would gratefully appreciate any feedback on the
;**	LAMP application.

;** Is LAMP already managed ...
;** -- ---- ------- -------
@lamp.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

  if n_elements(just)    le 0 then just=''
  if (!D.name eq 'TEK') and (just ne 'just')              then LAMP_B
  if n_elements(lamp_focus) eq 1 then if lamp_focus eq -1 then LAMP_B

  if n_elements(lamp_b1) gt 0 then ii=xregistered('LAMP') else ii=0
  if ii eq 0 then                  ii=xregistered('TOUCH')
  if ii eq 0 then                  ii=xregistered('TRIPX')
  if ii gt 0 then if just ne 'just' then ii=widget_info(lamp_b1,/realize)
  if ii gt 0 then begin if sys_dep('VERSION') le 5.0 then XMANAGER
  endif else begin

;***************************************
	if !D.name ne 'TEK' then ii=sys_dep('PSEUDO')
;***************************************
	!quiet=1
	p_screen
        if n_elements(lamp_dir) eq 0 then lamp_dir=sys_dep('GETENV','LAMP_DIR')

;** Workspaces
;** ----------
;** Wi	    = input data and manipulated data
;** wtb(i)  = 0 each time the contents of Wi is modified and set to 1 on display
;** wintb(i)= used by Scan

    w1 =0 & w2 =0 & w3 =0 & w4 =0 & w5 =0 & w6 =0 & w7 =0 & w8 =0 & w9 =0 & w10=0
    w11=0 & w12=0 & w13=0 & w14=0 & w15=0 & w16=0 & w17=0 & w18=0 & w19=0 & w20=0
    w21=0 & w22=0 & w23=0 & w24=0 & w25=0 & w26=0 & w27=0 & w28=0 & w29=0 & w30=0
    w31=0 & w32=0 & w33=0 & w34=0 & w35=0 & w36=0 & w37=0 & w38=0 & w39=0 & w40=0
    w41=0 & w42=0 & w43=0
    w_in =0 & w_out=0 & w_buf=0

    lamp_sys=40 ;Number of workspaces for the user. (check didline,gfit,inx,bens,touch_b,tripx for the future)
    wn      =lamp_sys+3+1

    wtb  =bytarr(wn) & wtb  (*)= 0
    wintb=intarr(wn) & wintb(*)=-1

    w_min  =fltarr(wn)
    w_max  =fltarr(wn)
    w_numor=strarr(wn) & w_numor(0)='lamp.ps'

;** Titles
;** ------
    x_tit    =strarr(wn)
    y_tit    =strarr(wn)
    z_tit    =strarr(wn)
    w_tit    =strarr(wn)
    other_tit=strarr(wn)
    head_tit =strarr(wn,10)

;** Pi	   = set of scalars used in interactive commands (data parameters)
;** --
    p0 =0 & p1 =0 & p2 =0 & p3 =0 & p4 =0 & p5 =0 & p6 =0 & p7 =0 & p8 =0 & p9 =0 & p10=0
    p11=0 & p12=0 & p13=0 & p14=0 & p15=0 & p16=0 & p17=0 & p18=0 & p19=0 & p20=0
    p21=0 & p22=0 & p23=0 & p24=0 & p25=0 & p26=0 & p27=0 & p28=0 & p29=0 & p30=0
    p31=0 & p32=0 & p33=0 & p34=0 & p35=0 & p36=0 & p37=0 & p38=0 & p39=0 & p40=0
    p41=0 & p42=0 & p43=0
    p_in =0 & p_out=0 & p_buf=0

    pv0 =0 & pv1 =0 & pv2 =0 & pv3 =0 & pv4 =0 & pv5 =0 & pv6 =0 & pv7 =0 & pv8 =0 & pv9 =0 & pv10=0
    pv11=0 & pv12=0 & pv13=0 & pv14=0 & pv15=0 & pv16=0 & pv17=0 & pv18=0 & pv19=0 & pv20=0
    pv21=0 & pv22=0 & pv23=0 & pv24=0 & pv25=0 & pv26=0 & pv27=0 & pv28=0 & pv29=0 & pv30=0
    pv31=0 & pv32=0 & pv33=0 & pv34=0 & pv35=0 & pv36=0 & pv37=0 & pv38=0 & pv39=0 & pv40=0
    pv41=0 & pv42=0 & pv43=0
    pv_in =0 & pv_out=0 & pv_buf=0

    if  n_elements(npars) eq 0 then npars=40
    par_txt=strarr(wn ,npars)
    par_txt_all=strarr(npars)

;** Motif
;** -----

    p_set_font,0

;   Stuff for data transformations
;** ----- --- ---- ---------------
    x0 =0 & x1 =0 & x2 =0 & x3 =0 & x4 =0 & x5 =0 & x6 =0 & x7 =0 & x8 =0 & x9 =0
    x10=0 & x11=0 & x12=0 & x13=0 & x14=0 & x15=0 & x16=0 & x17=0 & x18=0
    x19=0 & x20=0 & x21=0 & x22=0 & x23=0 & x24=0 & x25=0 & x26=0 & x27=0 & x28=0 & x29=0 & x30=0
    x31=0 & x32=0 & x33=0 & x34=0 & x35=0 & x36=0 & x37=0 & x38=0 & x39=0 & x40=0
    x41=0 & x42=0 & x43=0
    x_in =0 & x_out=0 & x_buf=0

    y0 =0 & y1 =0 & y2 =0 & y3 =0 & y4 =0 & y5 =0 & y6 =0 & y7 =0 & y8 =0 & y9 =0
    y10=0 & y11=0 & y12=0 & y13=0 & y14=0 & y15=0 & y16=0 & y17=0 & y18=0
    y19=0 & y20=0 & y21=0 & y22=0 & y23=0 & y24=0 & y25=0 & y26=0 & y27=0 & y28=0 & y29=0 & y30=0
    y31=0 & y32=0 & y33=0 & y34=0 & y35=0 & y36=0 & y37=0 & y38=0 & y39=0 & y40=0
    y41=0 & y42=0 & y43=0
    y_in =0 & y_out=0 & y_buf=0

    z0 =0 & z1 =0 & z2 =0 & z3 =0 & z4 =0 & z5 =0 & z6 =0 & z7 =0 & z8 =0 & z9 =0
    z10=0 & z11=0 & z12=0 & z13=0 & z14=0 & z15=0 & z16=0 & z17=0 & z18=0
    z19=0 & z20=0 & z21=0 & z22=0 & z23=0 & z24=0 & z25=0 & z26=0 & z27=0 & z28=0 & z29=0 & z30=0
    z31=0 & z32=0 & z33=0 & z34=0 & z35=0 & z36=0 & z37=0 & z38=0 & z39=0 & z40=0
    z41=0 & z42=0 & z43=0
    z_in =0 & z_out=0 & z_buf=0

    e0 =0 & e1 =0 & e2 =0 & e3 =0 & e4 =0 & e5 =0 & e6 =0 & e7 =0 & e8 =0 & e9 =0
    e10=0 & e11=0 & e12=0 & e13=0 & e14=0 & e15=0 & e16=0 & e17=0 & e18=0
    e19=0 & e20=0 & e21=0 & e22=0 & e23=0 & e24=0 & e25=0 & e26=0 & e27=0 & e28=0 & e29=0 & e30=0
    e31=0 & e32=0 & e33=0 & e34=0 & e35=0 & e36=0 & e37=0 & e38=0 & e39=0 & e40=0
    e41=0 & e42=0 & e43=0
    e_in =0 & e_out=0 & e_buf=0

    n0 =0 & n1 =0 & n2 =0 & n3 =0 & n4 =0 & n5 =0 & n6 =0 & n7 =0 & n8 =0 & n9 =0
    n10=0 & n11=0 & n12=0 & n13=0 & n14=0 & n15=0 & n16=0 & n17=0 & n18=0
    n19=0 & n20=0 & n21=0 & n22=0 & n23=0 & n24=0 & n25=0 & n26=0 & n27=0 & n28=0 & n29=0 & n30=0
    n31=0 & n32=0 & n33=0 & n34=0 & n35=0 & n36=0 & n37=0 & n38=0 & n39=0 & n40=0
    n41=0 & n42=0 & n43=0
    n_in =0 & n_out=0 & n_buf=0

    par1 =0 & par2 =0 & par3 =0 & par4 =0 & par5 =0 & par6 =0 & par7 =0 & par8 =0
    par9 =0 & par10=0 & par11=0 & par12=0 & par13=0 & par14=0 & par15=0 & par16=0
    par17=0 & par18=0 & par19=0 & par20=0 & par21=0 & par22=0 & par23=0 & par24=0
    par25=0 & par26=0 & par27=0 & par28=0 & par29=0 & par30=0 & par31=0 & par32=0
    par33=0 & par34=0 & par35=0 & par36=0 & par37=0 & par38=0 & par39=0 & par40=0
    par41=0 & par42=0 & par43=0

    Sna0 =0 & Sna1 =0 & Sna2 =0 & Sna3 =0 & Sna4 =0 & Sna5 =0 & Sna6 =0 & Sna7 =0 & Sna8 =0
    Sna9 =0 & Sna10=0 & Sna11=0 & Sna12=0 & Sna13=0 & Sna14=0 & Sna15=0 & Sna16=0 & Sna17=0
    Sna18=0 & Sna19=0 & Sna20=0 & Sna21=0 & Sna22=0 & Sna23=0 & Sna24=0 & Sna25=0 & Sna26=0
    Sna27=0 & Sna28=0 & Sna29=0 & Sna30=0 & Sna31=0 & Sna32=0 & Sna33=0 & Sna34=0 & Sna35=0
    Sna36=0 & Sna37=0 & Sna38=0 & Sna39=0 & Sna40=0

;   Stuff for DIALS
;** ----- --- -----
    d0 =0 & d1 =0 & d2 =0 & d3 =0 & d4 =0 & d5 =0 & d6 =0 & d7 =0 & d8 =0 & d9 =0
    d10=0 & d11=0 & d12=0 & d13=0 & d14=0 & d15=0 & d16=0 & d17=0 & d18=0
    d19=0 & d20=0 & d21=0 & d22=0 & d23=0
    dial_ini=0
    duduch1 =0
    duduch2 =0
    duduch3 =''
    proxcod =''
    if  n_elements(GEORGE) eq 0 then GEORGE=0

;   W info's
;** --------
    lamp_devps=''
    lamp_dvd  =sys_dep      ('DIVIDER')
    ihis      =0
    his_info  =0
    his       =strarr(wn+1) & his (*) =' ' & his (wn)='.'
    lims      =strarr(wn+1) & lims(*) =' ' & lims(wn)='.'
    histxt    =strarr(1)
    limtxt    =strarr(1)
    tolerance =0. & toler=0. & monimon=-1
    inst_value='    '
    inst_group=''
    cycle     ='  ????  '
    one=1 & two=0 & three=0 & alone=0

    if (just ne 'just') then begin

;** User Directory
;** ---- ---------
@dons.cbk
      basem=widget_base (title='Lamp',/column,resource_name='lamp')
      bidon=widget_label(basem,value='LARGE ARRAY MANIPULATION PROGRAM',font=ft_biggest)
      Show_Version,basem
      w0=2
      LOGO,w0 & pax1=size(w0)
      bidon=widget_base (basem,/row)
      bicon=widget_draw (bidon,retain=2,xsize=pax1(1),ysize=pax1(2)    ,colors=-30)
      bidon=widget_label(basem,value='                               ' ,font=ft_normal)
      basm1=widget_base (basem,       /column)
      basm2=widget_base (basem,       /column)
      basm3=widget_label(basem,value='______________________________________' ,font=ft_biggest)
      bid=sys_dep      ('DYNLAB',basem,1)
      widget_control,bad_id=ii  ,basem,/realize
      widget_control,bad_id=ii  ,bicon,get_value=pax4 & wset,pax4
      tvscl,w0,0,0 & pax2=0   &  pax3=pax1(1)

      lamp_user =''  & lamp_user =STRLOWCASE(sys_dep ('GETENV','USER'))
           host =''  &      host =STRLOWCASE(sys_dep ('GETENV','HOST'))
      cd,current=mee & sl=strlen(host)+1
      path='lambda'  & sp=strlen(path)+1
;           ******
      if (lamp_user eq path) or (rstrpos(mee,path) ge strlen(mee)-sp) or ((rstrpos(mee,host) ge (strlen(mee)-sl)>0 ) and (sl gt 2)) then begin
	mess=widget_label (basm1,value='Your name is the way to define your own directory',font=ft_bigger)
	namm=widget_text  (basm1,xsize=15,ysize=1,font=ft_biggest,/editable)
	rbut=widget_base  (basm1,/frame,/row)
	if sys_dep('MAP') ne -1 then $
	okbt=widget_button(rbut,value='OK',font=ft_bigger,resource_name='discret') else $
	okbt=widget_button(rbut,value='OK',font=ft_bigger)
 	print,string(7b)
	name='' & ii=0
	while (name eq '') and (ii eq 0) do begin
		widget_control,bad_id=ii,namm,/input_focus
		even=widget_event (basm1,bad_id=ii)
	        widget_control,bad_id=ii,namm,get_value=name
	        name=strupcase(strcompress(name(0),/remove_all))
	endwhile
	widget_control,bad_id=ii,basm1,sensitive=0
	if (name ne '') and (ii eq 0) then begin
		pwd=sys_dep      ('NEWDIR',lamp_user,name)
	   	stat=0 & ii=0
	   	catch,stat
	   	if (stat ne 0) and (ii eq 0) then begin
	   			  ii=1
	   			  bid=sys_dep      ('MKDIR',pwd)
	   			  catch,stat & if stat eq 0 then cd,pwd
	   	endif
	   	if stat eq 0 then cd,pwd & catch,/cancel
	endif
;	device,copy=[pax2,0,pax1(1),pax1(2),pax2+pax3,0,pax4] & pax2=pax2+pax3
      endif

;** Restore last session
;** ------- ---- -------
      fil=findfile('lamp.ses',count=true)
      if (true lt 1) then fil=findfile('lamp.ses.Z',count=true) else true=100
      if (true gt 0) and (ii eq 0) then begin
	mess =widget_label (basm2,value='Previous Session lamp.ses exists !!',font=ft_biggest)
	but  =widget_base  (basm2,/row)
	r_rm =widget_button(but ,value='Restore & Remove',font=ft_b_normal)
	r_kp =widget_button(but ,value='Restore & Keep'  ,font=ft_b_normal)
	rm   =widget_button(but ,value='Remove'          ,font=ft_b_normal)
	ign  =widget_button(but ,value='Ignore'          ,font=ft_b_normal)
 	print,string(7b)
        bid=sys_dep      ('DYNLAB',basm2,0)
	widget_control,bad_id=ii  ,basm2,/realize
	even=widget_event (basm2  ,bad_id=ok)
	widget_control,bad_id=ii  ,basm2,sensitive=0
	if ok eq 0 then begin
		if (even.id eq r_rm) or (even.id eq r_kp) then begin
        		widget_control,bad_id=ii,basm3,set_value='RESTORING lamp.ses ...'
			if true ne 100 then bid=sys_dep      ('UN_Z','lamp.ses.Z',lamp_dir)
						kpGEORGE=GEORGE
			catch,stat
	   		if stat eq 0 then begin RESTORE, 'lamp.ses'  &  GEORGE=kpGEORGE
						AFTER_RESTORE
			endif else print,"Bad version for file lamp.ses !!!" & catch,/cancel
    		endif
		if (even.id eq r_rm) or (even.id eq rm)   then $
	   		bid=sys_dep      ('DELET','lamp.ses')
	endif
;	device,copy=[pax2,0,pax1(1),pax1(2),pax2+pax3,0,pax4] & pax2=pax2+pax3
      endif else begin
		w1=shift(sin (dist(64)/15),-12,-12)*30    & w_tit(1)='w1=shift(sin (dist(64)/15),-12,-12)*30'
		x1=long (alog(findgen(64)+1.)*20) & y1=x1 & x_tit(1)='x1=long (alog(findgen(64)+1.)*20)'
		y_tit(1)='Y axis' & z_tit(1)='Counts' & other_tit(1)='Just an example'
      endelse

      if (lamp_siz ge 800) and (sys_dep('MACHINE') eq 'win' or $
				sys_dep('MACHINE') eq 'mac') then $
			SL_RESTSCAN,lamp_dir+lamp_dvd+'scan.exe' ,cnt
    endif

;** Developers
;** ----------
    lamp_b1    =0L
    lamp_act   =0
    lamp_focus =0
    lamp_entry =['',' ']
    l_message  =0L
    b_labins   =lonarr(9) & b_labins(*)=0
    jou_c      =['*******','SESSION','*******'] & jou_w=[' ',!stime,' ']
    last_form  =''
    path       =''
    my_path    =[path,'','',!D.NAME]

;** Data base directories
;** --------- -----------
    P_ENVI

;** Base Constitution
;** ---- ------------
    if (just ne 'just') then $
        widget_control,bad_id=ii,basm3,set_value='CREATING manipulation display TOOLS'

    if (just eq '') or (just eq 'lamp') then begin
	mbar=0L
	if sys_dep('VERSION') lt 4.0 then mkbar=0 else mkbar=1 ;& mkbar=0 ;;;for tests
	tit='LAMP '
	mmp =1
	if lamp_siz ge 600  then  if mkbar     then  mmp=0
	if sys_dep('MACHINE') eq 'mac'         then  mmp=1
	if sys_dep('MATLAB')  or (GEORGE eq 0) then  mmp=1
	if GEORGE eq 3 then begin GEORGE=2       &   mmp=1 & endif
	if GEORGE eq 1 then begin tit='GEORGE '  &   mmp=1 & endif

	if GEORGE eq 2 then tit='LAMP'
	tit      =tit+' ftp.ill.fr/pub/cs/lamp... (email:lamp@ill.fr)'
	tit      =tit+'     powered by Idl'
	if sys_dep('EMBEDDED') then tit=tit+' from Research Systems(www.rsinc.com)'
	if lamp_siz lt 600 then $
	 if not mkbar then $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column,$
				 x_scroll=590,y_scroll=lamp_siz-50) else $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column,$
				 x_scroll=590,y_scroll=lamp_siz-50,MBAR=mbar,rname_mbar='lampben')
	if lamp_siz ge 600 then $
	 if not mkbar then $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column) else $
	 lamp_b1  =widget_base  (title=tit,resource_name='lamp',kill_notify='P_DYING',/column,MBAR=mbar,rname_mbar='lampben')

	lamp_tmp1=widget_base  (lamp_b1  ,/row)
;don
	lamp_don   =lonarr(5)
	lamp_don(0)=widget_base (lamp_b1  ,/frame,resource_name='don',map=mmp)

	lamp_tmp2  =widget_base (lamp_tmp1,/column)

;ben
	lamp_ben   =lonarr(17)
	if GEORGE eq 2 then begin lamp_ben(0) =widget_base (lamp_tmp1   ,map=mmp)
				  lamp_ben(7) =widget_base (lamp_ben(0) ,/column,map=1)   & bas_ben=lamp_ben(7)
				  lamp_ben(8) =widget_base (lamp_ben(0) ,/column,map=0)   & endif

	if GEORGE ne 2 then begin lamp_ben(0) =widget_base (lamp_tmp1   ,map=mmp)
				  bas_ben     =widget_base (lamp_ben(0) ,/column)
				  lamp_ben(7) =bas_ben   &  lamp_ben(8) =bas_ben          & endif
				  
	if mbar   gt 0 then begin
				  lamp_ben(10)=widget_base (lamp_ben(0) ,/column,map=0)
				  lamp_ben(11)=widget_base (lamp_ben(10),/column,/frame,resource_name='ben')
				  mllab       =widget_label(lamp_ben(11),value='..MACROS LIST..',font=ft_propor)
				  endif
	ben_f=1
	if GEORGE ne 1  then begin
	  lamp_ben(2)=widget_base  (bas_ben ,/frame,resource_name='ben')
	  lamp_ben(1)=widget_base  (bas_ben)
	  ben_f=0
	endif
	if GEORGE ne 0  then begin
	  if lamp_siz ge 900 then lab='..Other functions..' else lab='....Other functions....'
	  if sys_dep('MACHINE')   eq  'mac'                 then lab='..Functions..'
	  if GEORGE eq 1 then bas_geo2   =widget_button(lamp_ben(8),value=lab,font=ft_b_normal,menu=2)
	  if GEORGE eq 1 then lamp_ben(2)=bas_geo2
	endif else bas_geo2=0
;micmac
	lamp_mac =widget_base (lamp_tmp2,/frame,resource_name='mic')
	lamp_ben(9)=lamp_mac
;did
	lamp_did   =lonarr(10)
	if  lamp_siz ge 900 then $
	sepdid	   =widget_draw (lamp_tmp2,xsize=600,ysize=4) else sepdid=0
	lamp_did(0)=widget_base (lamp_tmp2,/frame,resource_name='did')

	lamp_don(2)=lamp_ben(2)
	lamp_don(3)=lamp_did(0)

	if  lamp_siz ge 900 then $
	sepdon	   =widget_draw (lamp_tmp2,xsize=600,ysize=4) else sepdon=0

	widget_control,bad_id=ii,lamp_b1,default_font=ft_normal
	
;** Run  Selector Unit Creation
;** ---- -------- ---- --------
	if lamp_asite eq 'mic' then MIC,1

;** Workspace Manipulation Unit Creation
;** --------- ------------ ---- --------
	P_DON_CREATE ,(lamp_don(0))

;** File Selector Unit Creation
;** ---- -------- ---- --------
	P_MAC_CREATE ,(lamp_mac+0) ,mbar ,wread ,b33 ,b1,cque

;** Main Display Unit Creation
;** ---- ------- ---- --------
	P_DID_CREATE ,(lamp_did(0))

;** Specific Display Unit Creation
;** -------- ------- ---- --------
	P_BEN_CREATE ,(lamp_ben(2)),ben_f

;** General Functions Unit Creation
;** ------- --------- ---- --------
	P_FCT_CREATE ,(bas_ben), bas_geo2

;** Menu-bar Creation
;** -------- --------
	lamp_ben(15)=wread(0)
	lamp_ben(16)=wread(1)

	IF mbar gt 0 then begin	IF b33 gt 0 then widget_control,bad_id=i,b33, get_uvalue=uvbuti
	if n_elements(uvbuti) eq 0 then uvbuti=0
	Show_version,0,lamp_version
	Mfile	=widget_button(mbar,font=ft_propor,/menu,value='File')
	Mcustom	=widget_button(mbar,font=ft_propor,/menu,value='Customize')
	Medit	=widget_button(mbar,font=ft_propor,/menu,value='Edit')
	Minfo	=widget_button(mbar,font=ft_propor,/menu,value='Info')
	Mtool	=widget_button(mbar,font=ft_propor,/menu,value='Tools')
	Mwind	=widget_button(mbar,font=ft_propor,/menu,value='Lamp/Layout')
	Mhelp	=widget_button(mbar,font=ft_propor,/menu,value='Help')

	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='EXPORT workspace'               ,uvalue=[-88,370,0,0,0,0])
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='IMPORT file & workspace'        ,uvalue=[-88,380,0,0,0,0])
	Mfiler	=widget_button(Mfile	,font=ft_b_normal,value='Multiple READ (Selector access)',uvalue=uvbuti)
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='BROWSE selected instrument path',uvalue=[-88,562,0,wread(0),wread(1),-2,-2,0])
	Mfilec	=widget_button(Mfile	,font=ft_b_normal,value='Instrument CALIBRATION files'   ,uvalue=[-88,307,11])
	Mfilet	=widget_button(Mfile	,font=ft_b_normal,value='CATALOG of data runs'           ,uvalue=[-88,331,0])
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfilem	=widget_button(Mfile	,font=ft_b_normal,value='MAKE a User MACRO'              ,uvalue=[-88,203,0,0])
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='Save all'                       ,uvalue=[-88,397,0])
	Mfile1	=widget_button(Mfile	,value='--------')     & widget_control,Mfile1,sensitive=0
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='Save and exit'                  ,uvalue=[-88,307,12])
	Mfile1	=widget_button(Mfile	,font=ft_b_normal,value='Exit'                           ,uvalue=[-88,398,0])

	Mcustom1=widget_button(Mcustom	,font=ft_b_normal,value='COLORS table'                   ,uvalue=[-88,347,0])
	Mcustom1=widget_button(Mcustom	,font=ft_b_normal,value='PLOTTING preferences'           ,uvalue=[-88,360,0])
	Mcustom1=widget_button(Mcustom	,font=ft_b_normal,value='Default PRINTER (Unix)'         ,uvalue=[-88,360,0])
	Mcustom1=widget_button(Mcustom	,value='--------')     & widget_control,Mcustom1,sensitive=0
	Mcustomf=widget_button(Mcustom	,font=ft_b_normal,value='Update data FORMAT TABLE (instruments)'   ,uvalue=[-88,560,0,0,0,-1])
	Mcustomp=widget_button(Mcustom	,font=ft_b_normal,value='Update PATH for instruments data base'    ,uvalue=[-88,560,0,0,0,-1])
	Mcustomr=widget_button(Mcustom	,font=ft_b_normal,value='Template for READ IN procedures: read_tmp',uvalue=[-88,560,0,0,0,-1])
	Mcustomm=widget_button(Mcustom	,font=ft_b_normal,value='User macros LOCATION'           ,uvalue=[-88,560,0,0,0,-1])
	Mcustom1=widget_button(Mcustom	,value='--------')     & widget_control,Mcustom1,sensitive=0
	Mcustoms=widget_button(Mcustom	,font=ft_b_normal,value='How to implement "INSTRUMENT MACROS" layout',uvalue=[-88,596,0,0])

	Medit1	=widget_button(Medit	,font=ft_b_normal,value='COLORS table'                   ,uvalue=[-88,347,0])
	Medit1	=widget_button(Medit	,font=ft_b_normal,value='DATA PARAMETERS values'         ,uvalue=[-88,204,0,0])
	Meditc	=widget_button(Medit	,font=ft_b_normal,value='Instrument CALIBRATION'         ,uvalue=[-88,307,11])
	Medit1	=widget_button(Medit	,font=ft_b_normal,value='User batch files , MACROS'      ,uvalue=[-88,203,0,0])
	Medit1	=widget_button(Medit	,value='--------')     & widget_control,Medit1,sensitive=0
	Meditw1	=widget_button(Medit	,font=ft_b_normal,value='STORE  20 workspaces in   secondary memory' ,uvalue=[-88,572,0,1])
	Meditw2	=widget_button(Medit	,font=ft_b_normal,value='RESTORE   workspaces from secondary memory' ,uvalue=[-88,572,0,2])
	Meditw3	=widget_button(Medit	,font=ft_b_normal,value='EXCHANGE  workspaces with secondary memory' ,uvalue=[-88,572,0,3])
	Meditw4	=widget_button(Medit	,font=ft_b_normal,value='CLEAR all workspaces and  memories'         ,uvalue=[-88,572,0,4])

	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='JOURNAL of current session'     ,uvalue=[-88,396,0,0])
	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='DATA PARAMETERS'                ,uvalue=[-88,204,0,0])
	Minfo1	=widget_button(Minfo	,value='--------')     & widget_control,Minfo1,sensitive=0
	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='Internal ROUTINES (lamp)'       ,uvalue=[-88,203,0,1])
	Minfo1	=widget_button(Minfo	,font=ft_b_normal,value='Available User BATCH files'     ,uvalue=[-88,203,1,0])
	Minfo1	=widget_button(Minfo	,value='--------')     & widget_control,Minfo1,sensitive=0
	Minfor	=widget_button(Minfo	,font=ft_b_normal,value='Template for READ IN procedures',uvalue=[-88,560,0,0,0,-1])

	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='OVERPLOTTING (superplot)'       ,uvalue=[-88,352])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='SCROLL spectra within 2D,1D workspaces' ,uvalue=[-88,402,0])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='SECTOR integration (small 2D wksp)'  ,uvalue=[-88,401,0])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='RADIAL integration (small 2D wksp)'  ,uvalue=[-88,401,0])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='UNROLLING for integration (large 2D wksp)' ,uvalue=[-88,401,-1])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='TOMOGRAPHY'                          ,uvalue=[-88,401,-2])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='FITTING with GKfit (gauss,lorentz)'  ,uvalue=[-88,580,0,0])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='Qens_fit (gauss+lorentz+delta) for TOF '   ,uvalue=[-88,571,2])
								 widget_control,Mtool1,sensitive=0
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='Spectra GROUPING for TOF'            ,uvalue=[-88,403,0])
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='lampINX for TOF'                     ,uvalue=[-88,571,1])
	Mtool1	=widget_button(Mtool	,value='--------')     & widget_control,Mtool1,sensitive=0
;	Mtoolo	=widget_button(Mtool	,font=ft_b_normal,value='CRON tasks (toggle)')
	Mtool1	=widget_button(Mtool	,font=ft_b_normal,value='Multiple READ (Selector access)'     ,uvalue=uvbuti)
	Mtooln	=widget_button(Mtool	,font=ft_b_normal,value='Glory-Hole (scan)'                   ,uvalue=[-88,306,0,-1])
	
	Mwindf	=widget_button(Mwind	,font=ft_b_normal,value='Extend to classical Lamp')
	Mwindm	=widget_button(Mwind	,font=ft_b_normal,value='Light  configuration')
	Mwind1	=widget_button(Mwind	,value='--------')     & widget_control,Mwind1,sensitive=0
	Mwindl	=widget_button(Mwind	,font=ft_b_normal,value='LAMP   layout')
	Mwindg	=widget_button(Mwind	,font=ft_b_normal,value='GEORGE layout (dials)')
	Mwind1	=widget_button(Mwind	,value='--------')     & widget_control,Mwind1,sensitive=0
	Mwind1	=widget_button(Mwind	,font=ft_b_normal,value='DO input commands (...)'             ,uvalue=[-88,224])
	Mwindx	=widget_button(Mwind	,font=ft_b_normal,value='XBU input commands (...)'            ,uvalue=[-88,226])
	Mwind1	=widget_button(Mwind	,value='--------')     & widget_control,Mwind1,sensitive=0
	Mwinds	=widget_button(Mwind	,font=ft_b_normal,value='Help for INSTRUMENT MACROS',/menu)

	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='MANUAL  lamp/manual/front.html' ,uvalue=[-88,201,0,0])
	Mhelp1	=widget_button(Mhelp	,value='--------')     & widget_control,Minfo1,sensitive=0
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='List  of ROUTINES (Idl)'        ,uvalue=[-88,573,0,0])
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Language HELP (Idl)'            ,uvalue=[-88,573,0,0])
	Mhelp1	=widget_button(Mhelp	,value='--------')     & widget_control,Minfo1,sensitive=0
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Manipulation syntax overview'   ,uvalue=[-88,588,0,0])
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Reading into workspaces'        ,uvalue=[-88,586,0,0])
	Mhelp1	=widget_button(Mhelp	,font=ft_b_normal,value='Displaying workspaces'          ,uvalue=[-88,587,0,0])
	Mhelp1	=widget_button(Mhelp	,value='--------')     & widget_control,Minfo1,sensitive=0
	Mhelpc	=widget_button(Mhelp	,value='About Lamp',/menu)
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Start Lamp project: Apr 1994')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='This update: '+lamp_version)
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Kernel Design:')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Didier   Richard   (ILL scientific computing engineer)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Don      Kearley   (ILL scientist -->1999 DELFT)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Michel   Ferrand   (ILL scientist -->1998 CEA)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Scientific macros support:')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Ken      Andersen  (ISIS scientist -->2002 ILL)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Bob      Cubitt    (ILL  scientist    LSS)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Thomas   Hansen    (ILL  scientist    DIF)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Stephane Rols      (ANL  scientist -->2002 Montpellier Univ.)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        J.Ross   Stewart   (ILL  scientist    TOF)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Complementary development:')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Arne     Dallmeyer (Thesis   in 1994)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Benjamin Vettier   (Grenoble university in 1994)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Romuald  Jouffrey  (Grenoble university in 1995,96)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='        Philippe Cuerq     (Grenoble university in 1996)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='Mail: lamp@ill.fr')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='http://www.ill.fr/data_treat/lamp/front.html (The Lamp Book)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='http://www.ill.fr/YellowBook/D7/home/D7_george_book (George on D7)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value='http://barns.ill.fr         (The applications web server)')
	Mh	=widget_button(Mhelpc	,font=ft_propor,value=' ftp://ftp.ill.fr/pub/cs    (Take-away sources & runtimes)')
	lamp_ben(12)=Mwindl
	lamp_ben(13)=Mwindg
	lamp_ben(14)=Mwindm
	if mmp                 then widget_control,Mwindf  ,sensitive=0
	if lamp_siz lt 600     then widget_control,Mwindf  ,sensitive=0
	if lamp_siz lt 600     then widget_control,Mwindm  ,sensitive=0
	if lamp_siz lt 800     then widget_control,Mtooln  ,sensitive=0
	if (sys_dep('EMBEDDED')  or sys_dep('RUNTIME')) then runt=1 else runt=0
	if runt                then widget_control,Mfilem  ,sensitive=0
	if runt                then widget_control,Mcustomr,sensitive=0
	if runt                then widget_control,Mcustomm,sensitive=0
	if runt                then widget_control,Minfor  ,sensitive=0
	if cque     eq 0       then widget_control,Mwindg  ,sensitive=0
	if cque     eq 0       then widget_control,Mwindl  ,sensitive=0
	if GEORGE   eq 2       then widget_control,Mwindl  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mwindg  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mfiler  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustomf,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustomp,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustoms,sensitive=0
	if GEORGE   eq 1       then widget_control,Mcustomr,sensitive=0
	if GEORGE   eq 1       then widget_control,Minfor  ,sensitive=0
	if GEORGE   eq 1       then widget_control,Mwinds  ,sensitive=0
	if GEORGE   eq 0       then widget_control,Mwindx  ,sensitive=0

	P_LAMBDA,pathmac
	pathcal =sys_dep('INSUB',pathmac,'CALIBRATION') & calfile =findfile(pathcal+'*',count=cnt)
	if cnt      eq 0       then widget_control,Mfilec  ,sensitive=0
	if cnt      eq 0       then widget_control,Meditc  ,sensitive=0
	
	toufile =findfile(lamp_touch+lamp_dvd+'*',count=cnt)
	if cnt      eq 0       then widget_control,Mfilet  ,sensitive=0

	widget_control,Meditw1,set_uvalue=[-88,572,0,1,Meditw2,Meditw3]
	widget_control,Meditw2,sensitive=0
	widget_control,Meditw3,sensitive=0
	empty & sby=0 & sp=0
	if sys_dep('MACHINE') eq 'win' then begin sby=30 & sp=1 & endif

	gml=widget_info(lamp_b1    ,/geometry) & sty=gml.scr_ysize+2*gml.margin + sby
	gmm=widget_info(lamp_don(0),/geometry) & ssy=gmm.scr_ysize+2*gmm.margin & ssy=sty-ssy

	if not mmp then widget_control,lamp_b1,scr_ysize=ssy
	if not mmp then b_labins(6)=1
	
	fullist=[''] & MAC_LIST,n_em,fullist,maclist,THISFILE='A_List_*.prox'
	widget_control,Mwinds,set_uvalue=fullist
	if fullist(0) gt ' ' then begin
	   idx=sort(maclist) & maclist=maclist(idx) & fullist=fullist(idx)
	   idx=uniq(maclist) & maclist=maclist(idx) & fullist=fullist(idx)
	   for i=0,n_elements(maclist)-1 do $
	       bid =widget_button (Mwinds,font=ft_b_normal,value=maclist(i),uvalue=[-88,570,0,Mwinds,Mwindl,Mwindg,Mwindm,i])
	            widget_control,Mwinds,set_uvalue=fullist
		    lamp_did(6:9)=[Mwinds,Mwindl,Mwindg,Mwindm]
	endif else  widget_control,Mwinds,sensitive =0
	endif
;** Event Loop
;** ----- ----

	P_MUS,''
	widget_control,bad_id=ii,basem	,/destroy
	P_MUS,'mus_shot'

	bid=sys_dep      ('DYNLAB',lamp_b1,1)
	widget_control,bad_id=ii  ,lamp_b1 ,/realize

	IF mbar gt 0 then begin
	   gml=widget_info(lamp_b1    ,/geometry) & stx=gml.scr_xsize+2*gml.margin
	   gmd=widget_info(lamp_ben(0),/geometry) & ssx=gmd.scr_xsize+2*gmd.margin & ssx=stx-ssx
	   widget_control,lamp_ben(10),set_uvalue=[-99,0L,mllab,stx]
	   widget_control,Mwindm      ,set_uvalue=[-88,307,62,ssx,ssy,stx,sty,Mwindf,Mwindm]
	   widget_control,Mwindf      ,set_uvalue=[-88,307,61,ssx,ssy,stx,sty,Mwindf,Mwindm]

	   widget_control,Mwindl,set_uvalue=[-88,557,0,b1,cque,-1,Mwindl,Mwindg,Mwindm,ssx,stx]
	   widget_control,Mwindg,set_uvalue=[-88,557,0,b1,cque, 1,Mwindl,Mwindg,Mwindm,ssx,stx]
;	   widget_control,Mtoolo,set_uvalue=[-88,557,0,b1,cque, 1,Mwindl,Mwindg,Mwindm,ssx,stx]
	endif
	if not mmp then begin	 widget_control,bad_id=ii,lamp_b1,scr_xsize=ssx
				 widget_control,bad_id=ii,Mwindm     ,sensitive=0
				 endif

	P_AFTER_REALIZE_DID,sepben,sepdon,sepdid

	if GEORGE ne 0 then GEORGEO,  /init $
	else if (lamp_siz lt 800) then put_logo, /TIO

	if sys_dep('VERSION') lt 5.0 then XMANAGER, 'LAMP' ,lamp_b1  ,event_handler='LAMP_EVENT_PARSER',CLEANUP='P_DYING' $
      	else begin XMANAGER, 'LAMP' ,lamp_b1  ,event_handler='LAMP_EVENT_PARSER',CLEANUP='P_DYING',/just_reg
	     if not runt then widget_control, lamp_b1, set_uvalue=[-85,700,1], TIMER=1.
	     ii=execute('XMANAGER,/NO_BLOCK')
	endelse
    endif else begin
    	if lamp_asite eq 'mic'   then MIC,1
	if just       eq 'touch' then begin
	   TOUCH_B,1,'','+'
	   P_MUS,'' & widget_control,bad_id=ii,basem,/destroy & XMANAGER
	   if lamp_b1 eq -100  then  LAMP
	endif else $
	if just       eq 'tripx' then begin
	   ii=execute('TRIPX, /three_axis')
	   P_MUS,'' & widget_control,bad_id=ii,basem,/destroy & XMANAGER
	   if lamp_b1 eq -100  then  LAMP
	endif
    endelse

  endelse
; -------
; if just ne 'just'  then bid=sys_dep      ('EXIT')
end

pro P_LAYOUT, flag ,prox=fiprox
;** ********
;**
@lamp.cbk
ev=0
ii=execute("ev={WIDGET_BUTTON,id:0L,top:lamp_b1,handler:0L,select:1}") ;PB IDL36 IDL4

if n_elements(flag) eq 1 then case strlowcase(flag) of
  'george': begin ev.id=lamp_ben(13)          & end
  'lamp':   begin ev.id=lamp_ben(12)          & end
  'light':  begin ev.id=lamp_ben(14)          & end
  'full':   begin widget_control,bad_id=ii,lamp_ben(14),get_uvalue=uv
		  if ii eq 0 then ev.id=uv(7) & end
  'hide':   if lamp_b1  gt 0 then widget_control,bad_id=ii,lamp_b1,iconify=1
  'show':   if lamp_b1  gt 0 then widget_control,bad_id=ii,lamp_b1,iconify=0
   else:    if strpos(strlowcase(flag),'list_') ge 0 then begin
	     if lamp_did(6) gt 0 then begin widget_control,lamp_did(6),get_uvalue=fullist
   	      if fullist(0) gt ' ' then begin
		  pos=strpos(strlowcase(fullist),strlowcase(flag)) & idx=where(pos ge 0) & idx=idx(0)
		  if idx ge 0 then P_MAC_EVENT,ev,[-88,570,0,lamp_did(6:9),idx]
   	      endif
   	     endif
   	    endif
endcase
if ev.id gt 0 then LAMP_EVENT_PARSER, ev

if n_elements(fiprox) gt 0 then don_do_cmd, prox=fiprox
end

pro AFTER_RESTORE
;** *************
;**
@lamp.cbk
    	lamp_sys  = n_elements(w_min)-3-1
	lamp_b1   = 0L & p_screen	& p_set_font, 0
	lamp_act  = 0L & lamp_focus =0	& l_message  =0L
	b_labins  = lonarr(9)		& b_labins(*)=0L

	jou_c     =['*******','SESSION','*******'] & jou_w=[' ',!stime,' ']
	last_form =''
	path      ='' & my_path   =[path,'','',!D.NAME]
end

pro P_ENVI ,cust
;** ******
;**
;** Track environments and custome variables.
@lamp.cbk
    p_screen

    lamp_user ='' & lamp_user =STRLOWCASE(sys_dep      ('GETENV','USER'))
    lamp_dir  ='' & lamp_dir  =sys_dep      ('GETENV','LAMP_DIR' ) & lamp_dir=strtrim(lamp_dir,2)
    lamp_exec ='' & lamp_exec =sys_dep      ('GETENV','LAMP_EXEC')
    lamp_host ='' & lamp_host =sys_dep      ('GETENV','HOST')
    		 if lamp_host eq '' then lamp_host=getenv('SYS$NODE')
    		 if lamp_dir  eq '' then cd,current=lamp_dir
    j=STRPOS (lamp_host, ':') & if j ge 0 then lamp_host=STRMID(lamp_host,0,j)
    lamp_host =STRLOWCASE(lamp_host)

    lamp_dvd  =sys_dep      ('DIVIDER')
    lamp_6    =6
    lamp_proxy=''

    lamp_ins  =['demo']
    lamp_wrti =[' '] & lamp_wrtp =[' ']
    lamp_grp  =[' ']
    lamp_ali  =['Current Path']
    lamp_path =['']
    lamp_asite= 'rdfilter'
    lamp_fsite= ' '

    lamp_proc    =strarr(n_elements(lamp_ins))
    lamp_proc(*) ='rdid'
    lamp_proc(0) ='read_tmp'
    lamp_touch   ='demo/TOUCH_BASE'
    lamp_macro   ='~lambda/macros'

    lamp_data = lamp_path(0)
    lamp_cyc  = [0L,0L]
    cycle     =lamp_ali(lamp_cyc(0))
    path_for_online=lamp_path(lamp_cyc(0))

    nld=strlen(lamp_dir)
    if (lamp_dir ne '')   then begin
     if strmid (lamp_dir,nld-1,1) eq lamp_dvd then lamp_dir=strmid(lamp_dir,0,nld-1)
     bid=sys_dep      ('IDLPATH',lamp_dir,nld)
    endif

    if n_elements(cust) eq 0 then P_NEWCUST

;   if sys_dep('MACHINE') eq 'vms' then lamp_touch=' '

    idx =reverse(sort(lamp_grp))
    lamp_grp =lamp_grp (idx)
    lamp_ins =lamp_ins (idx)
    lamp_proc=lamp_proc(idx)

    if n_elements(lamp_ins) eq 2 then begin inst_value=lamp_ins(0) & inst_group=lamp_grp(0)
    endif else  for i=0,n_elements(lamp_ins)-1 do begin
    		    if strpos(strlowcase(lamp_ins(i)),lamp_host) ge 0 then begin
    		       inst_value=lamp_ins(i) & inst_group=lamp_grp(i)  &  endif
    		endfor

    if  strpos(!path,"home") lt 0 then  begin	ta=findfile('home') & l_me=''
					;if n_elements(ta) ge 1 then   l_me=expand_path('+home')
					;if n_elements(ta) ge 1 then   l_me=expand_path( 'home')
					 if l_me ne '' then bid=sys_dep ('ADDPATH',l_me)
					endif
    meed=sys_dep ('NEWSUB',sys_dep ('HOME'),'../DIALS')

    if  strpos(!path,"DIAL") lt 0 then  begin	ta=findfile(meed)   & l_me=''
					if n_elements(ta) gt 1 then   l_me=expand_path('+'+meed)
					if l_me ne '' then bid=sys_dep ('ADDPATH',l_me)
					endif
    lamp_macro=expand_path(lamp_macro)
    if (lamp_macro gt ' ') then  begin      ta=findfile(lamp_macro+lamp_dvd+'*') & l_me=''
					if n_elements(ta) gt 1 then   l_me=expand_path('+'+lamp_macro)
					if l_me ne '' then bid=sys_dep ('ADDPATH',l_me)
					                   bid=sys_dep ('ADDPATH',lamp_macro)
    endif
;** Local or Remote
;** ----- -- ------
        lamp_loc  =0
	disp  ='' &      disp =sys_dep      ('GETENV','DISPLAY')
	if disp			  eq '' then lamp_loc=1 else $
	if strpos(disp,':')       eq 0	then lamp_loc=1 else $
	if strpos(disp,lamp_host) eq 0  then lamp_loc=1
return
end

FUNCTION P_LAMBDA, dummy
;******* ********
;**
@lamp.cbk

rst=lamp_macro
idx=strpos(lamp_macro,'macros')
if  idx gt 0 then begin rst= strmid(lamp_macro,0,idx-1) +lamp_dvd
			if   lamp_dvd eq "" then rst=rst+"]"
             endif else if   lamp_dvd ne "" then rst=rst+lamp_dvd

if rst gt ' ' then if strmid(rst,strlen(rst)-1,1) ne lamp_dvd then rst=rst+lamp_dvd
bid= findfile   (rst+'*',count=n)
if n eq 0 then rst=''
return, rst
end
PRO P_LAMBDA, rst
;** ********
;**
rst=P_LAMBDA (dum)
end

function P_ONLYONE ,pth, lamp_dvd
;******* *********
;**
;** Choose path corresponding to the platform.
	npth=str_sep(pth,',')
	npdx=-1
	for k=0,n_elements(npth)-1 do begin npth(k)=strtrim(npth(k),2)
    		nld=strlen(npth(k))
		if (strpos(npth(k),lamp_dvd) ge 0) and (npdx lt 0) then npdx=k
     		if  strmid(npth(k),nld-1,1)  eq lamp_dvd then npth(k)=strmid(npth(k),0,nld-1)
	endfor
return, npth(npdx>0)
end

pro P_NEWCUST ,fromcust=fromcust
;** *********
;**
;** Update customisable tables.
@lamp.cbk

    datp      = ''    & init= 'init'
    stat=0 & catch,stat
    if stat  ne 0  then catch,/cancel else begin
			pth=sys_dep      ('NEWSUB',lamp_dir,'lamp_mac')
			t = findfile (pth + 'read_par.pro',count = exist)
			if (exist eq 0) then begin pth=!dir    +sys_dep("DIVIDER")
			t = findfile (pth + 'read_par.pro',count = exist) & endif
			if (exist eq 0) then begin status=23 & datp=0 & bid=0
			                ii=execute('bid=read_par("init","","",status,datp)')   & endif
			on_ioerror, mis_par & in=-1
			
			OPENR,in,pth+'read_par.pro',/get_lun
			on_ioerror, end_par
			      ligne=' '   & ttinst='' & ttproc ='' & ttgroup ='' & ttsymbol='' & ttpath=''
			      ttwall=''   & ttouch='' & ttmacro='' & ttaccess='' & ttsite  ='' & ttmagi='6'
			      ttpars='40'
			      WHILE not eof(in) DO begin
            		          readf,in,ligne
            		          IF (strpos(ligne,';exec') gt 0) THEN r=execute(ligne)
        		      ENDWHILE
        		end_par:  datp={a:ttinst,  b:ttproc,  c:ttgroup,  $
              				d:ttsymbol,e:ttpath,  f:ttouch,   $
              				g:ttmacro, h:ttaccess,i:ttsite,j:ttmagi,k:ttwall,l:ttpars}
			mis_par:if in gt 0 then FREE_LUN,in
		    endelse

    if n_tags(datp) gt 0 then  begin
    	    nins = datp.a
    	    nproc= datp.b
    	    ngrp = datp.c
	    lamp_wrti =[' '] & lamp_wrtp =[' ']
;**
    	    for i= 0,n_elements(nins)-1 do begin  pos=-1
	      if strpos(nins(i),'.') ne strlen(nins(i))-1 then begin
    	        for j=0,n_elements(lamp_ins)-1 do if lamp_ins(j) eq nins(i) then pos=j
    	    	if  pos ge 0 then begin
    	    	    lamp_proc(pos)=nproc(i)
    	    	    lamp_grp (pos)=ngrp (i)
    	    	endif else begin
    	    	    lamp_ins	  =[lamp_ins ,nins (i)]
    	    	    lamp_proc	  =[lamp_proc,nproc(i)]
    	    	    lamp_grp	  =[lamp_grp ,ngrp (i)]

    	    	    if n_elements(b_labins) gt 0 then if b_labins(0) gt 0 then begin
		       n  =n_elements(lamp_ins)-1
	               bid=widget_button(b_labins(0),font=ft_b_normal,value=lamp_ins(n),$
	               			 uvalue=[-88,560,0,b_labins(0) , b_labins(1),n,0,0])
		    endif
    	    	endelse
	      endif else begin lamp_wrti=[lamp_wrti,strmid(nins(i),0,strlen(nins(i))-1)]
	                       lamp_wrtp=[lamp_wrtp,nproc(i)] & endelse
    	    endfor
;**
    	    nali =datp.d
    	    npath=datp.e
    	    for i= 0,n_elements(nali)-1 do begin  pos=-1
    	        for j=0,n_elements(lamp_ali)-1 do if lamp_ali(j) eq nali(i) then pos=j
		npath(i)=P_ONLYONE(npath(i),lamp_dvd)
     	    	if  pos ge 0 then begin
    	    	    lamp_path(pos)=npath(i)
    	    	endif else begin
    	    	    lamp_ali	  =[lamp_ali ,nali (i)]
    	    	    lamp_path	  =[lamp_path,npath(i)]

    	    	    if n_elements(b_labins) gt 0 then if b_labins(1) gt 0 then begin
		       n  =n_elements(lamp_ali)-1
	               bid=widget_button(b_labins(1),font=ft_b_normal,value=lamp_ali(n),$
	               			 uvalue=[-88,561,0,b_labins(0) , b_labins(1),n,0,0])
		    endif
    	    	endelse
    	    endfor
;**
	    if keyword_set(fromcust) then RDSET,inst=inst_value
    	    lamp_touch=P_ONLYONE(datp.f,lamp_dvd)
    	    lamp_macro=P_ONLYONE(datp.g,lamp_dvd)
    	    lamp_asite=datp.h
    	    lamp_fsite=datp.i
    	    lamp_6    =long(datp.j)
    	    lamp_proxy=datp.k
	    if strpos(strupcase(lamp_fsite),'GEORGE') ge 0 then begin
	                                     GEORGE=1 & lamp_fsite=""
					     if strpos(strupcase(lamp_fsite),'LAMP') ge 0 then GEORGE=2
					     endif
	    npp	      =long(datp.l)<10000
	    if n_elements(par_txt) eq 0 then npars=npp else $
	    if npp gt  npars then begin nw=(size(par_txt))(1) & nww=(size(par_txt))(2)  & tmp=strarr(nw,npp)
					for i=0,nw-1 do   tmp(i,0:nww-1)=par_txt(i,*)   & par_txt    =tmp
    					tmp=strarr(npp) & tmp(0:nww-1)  =par_txt_all(*) & par_txt_all=tmp
					npars=npp & endif
    	    lamp_path(0)=''
    	    if n_elements(b_labins) gt 0 then if b_labins(2) gt 0 then $
    	    				 widget_control,bad_id=i,b_labins(2),set_value=lamp_fsite
    endif
return
end

pro P_SCREEN
;** ********
;**
@lamp.cbk
screen=[800,600]
if !D.name eq 'Z'    then screen=[1024,1280] else $
if !D.name ne 'TEK'  then device,get_screen_size=screen

   if (screen(0) ge 1024) then screen(1)=screen(1)>800
   if (screen(1) lt 800 ) and (screen(1) gt 750) then screen(1)=800
   if n_elements(lamp_ziz) eq 1 then screen(1)=min([screen(1),lamp_ziz])>480
   lamp_ziz=screen(1)
   lamp_siz=screen(1)

return
end

pro P_SET_FONT, n ,lamp_font
;** **********
;**
@lamp.cbk

    lamp_font = sys_dep('FONTS')
    fk=n
    if (lamp_ziz le 950 ) and (fk eq 0) then fk=1
    if (lamp_ziz lt 800 ) and (fk lt 2) then fk=2

    ft_propor    = lamp_font(0,fk)
    ft_biggest   = lamp_font(1,fk)
    ft_bigger    = lamp_font(2,fk)
    ft_b_bigger  = lamp_font(3,fk)
    ft_normal    = lamp_font(4,fk)
    ft_b_normal  = lamp_font(5,fk)
    ft_smaller   = lamp_font(6,fk)
    ft_smallest  = lamp_font(7,fk)


    if n_elements(lamp_b1) gt 0 then $
    if lamp_b1 gt 0 then widget_control,bad_id=ii,lamp_b1,default_font=ft_normal

    if n  eq 0 then lamp_siz=lamp_ziz else $
    if fk eq 1 then lamp_siz=900      else lamp_siz=780
return
end

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------



;*			******************************
;*			**                          **
			    PRO LAMP_EVENT_PARSER,ev
;*			**                          **
;*			******************************

;** User_Value for lamp's widgets having an event has the following structure:
;** [lampcode, sequence , 0 , 0 , 0 , 0 , 0 , 0 , 0]
;**     where:
;**  lampcode=-88  for widgets under lamp
;**          =-87  for widgets under scan
;**          =-86  for others  front windows
;**          =-85  lamp_b1 Timer
;**  sequence= 100 --> 199 for MIC   unit
;**	     = 200 --> 299 for DON   unit
;**	     = 300 --> 399 for DID   unit
;**	     = 400 --> 499 for BEN   unit
;**	     = 500 --> 599 for MAC   unit
;**	     = 600 --> 699 for GEO   unit
;**  others  = 7 free parameters

@lamp.cbk
	if ev.id gt 0 then begin  i=0
	   widget_control, ev.id ,bad_id=i, get_uvalue=uv

	   if i eq 0 then if n_elements(uv) gt 1 then begin

	         stat=0 & catch,stat
	         if stat  ne 0  then begin catch,/cancel
	         		catch,stat & if stat ne 0 then retall
				therror=strmid(!err_string,0,65)
	         		widget_control,bad_id=i,l_message,set_value=therror
	         		set_plot,my_path(3)
				P_MUS,'mus_cannon'
				if b_labins(6) then  if b_labins(7) gt 0 then $
				widget_control,bad_id=i,b_labins(7),set_value=therror
	         		return & endif

		 if  tag_names(ev,/structure_name) ne 'WIDGET_DRAW'  then  nodr=1 else nodr=0

		 if uv(0) eq -85  then begin if uv(2) ge 1 then widget_control,ev.id,TIMER=uv(2)
		    if uv(2) eq 1 then begin uv(2)=2  & widget_control,ev.id,set_uvalue=uv & retall & endif
		    if uv(2) eq 2 then begin uv(2)=0  & widget_control,ev.id,set_uvalue=uv
		    		print,'%Lamp successfully loaded' & print,''
		    		print,'Enter @lamp.cbk to define lamp variables at command line' & endif
		 endif else $
		 if uv(0) eq -87  then			       P_DID_EVENT,ev,uv  else $
		 if uv(0) eq -88  then  begin

		    if ( lamp_act eq 1) and (nodr)	     then P_DID_EVENT,ev,[-88,300]
		    if my_path(1) ne '' then if uv(1) ne 576 then P_SET_PATH

		    if (uv(1) ge 600)  and (uv(1) le 699) then P_GEO_EVENT,ev,uv $
		    else begin

		    if  nodr  then widget_control,/hourglass
		    if (uv(1) ge 100)  and (uv(1) le 199) then P_MIC_EVENT,ev,uv
		    if (uv(1) ge 200)  and (uv(1) le 299) then P_DON_EVENT,ev,uv
		    if (uv(1) ge 300)  and (uv(1) le 399) then P_DID_EVENT,ev,uv
		    if (uv(1) ge 400)  and (uv(1) le 499) then begin
		    					       P_BEN_EVENT,ev,uv
							       P_DID_SETWIN0
							       endif
		    if (uv(1) ge 500)  and (uv(1) le 599) then P_MAC_EVENT,ev,uv
		    if (uv(1) eq 222)  or  (uv(1) eq 342) or $
		    			   (uv(1) eq 422) then P_EXTEND   ,ev,uv

		    if lamp_b1 gt 0 then begin
			if (GEORGE eq 0) and (uv(1) ne 390) then that=lamp_b1 else that=long(lamp_don(0))
			evv=widget_event(that,/nowait,bad_id=i)
			widget_control,bad_id=i, that ,/clear_events
			if b_labins(8) gt 0 then begin
				evv=widget_event(b_labins(8),/nowait,bad_id=i)
				if i ne 0 then b_labins(8)=0 $
				          else widget_control,bad_id=i,b_labins(8),/clear_events
			endif
		    endif
		    endelse
		 endif
	   endif
	endif
return
end

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

pro	P_MAC_CREATE ,base ,mbar ,wread ,b33 ,b1,cque
;**	************
;**
@lamp.cbk
	b1   =	widget_base  (base,/column)
	b11  =  widget_base  (b1  ,/row)
;b11
	bid=' DATA COLLECTOR'
	btitl=	widget_label (b11 ,font=ft_biggest ,value=bid)
	bidon='' & CALL_PROCEDURE,'myhelp',bidon

	fhrt=findfile('myhelp.rt',count=nn) & if nn gt 0 then begin
          on_ioerror, mishlp & in=-1
	  OPENR,in,'myhelp.rt',/get_lun
	  line=''
	  WHILE not eof(in) DO begin readf,in,line & bidon=[bidon,'line'] & ENDWHILE
	  mishlp: if in gt 0 then FREE_LUN,in
	endif
	if n_elements(bidon) gt 1  then begin
	  bhelp=widget_button(b11 ,font=ft_b_normal  ,value='-Help-')
	  bidon=widget_label (b11 ,font=ft_biggest ,value='   ')
	endif else begin
	  bhelp=widget_button(b11 ,font=ft_normal  ,value='?')
	  bidon=widget_label (b11 ,font=ft_propor  ,value='        ')
	endelse
	cd,current =path
        pwd_l=  widget_label (b11 ,font=ft_b_normal,value=' Working path:  ')
	pwd_t=  widget_text  (b11 ,value=path,font=ft_b_bigger,xsize=24,ysize=1,/editable,$
										/all_events)
	sel    =[strlen(path),0]
 	my_path=[path,'',string(pwd_t),!D.NAME]

	laber=l_message
	cque =0
;b33
	if (n_elements(lamp_ins) le 1) or (lamp_asite eq 'customiz')  then text='Customize' $
	      else if lamp_siz ge 800 then text='Data...' else text='Data...'

	if GEORGE ne 0 then begin
	   bgeo2= laber

	   if GEORGE eq 1 then begin txt='Data' & map1=1 & map2=0 & b_labins(5)=1
	   endif          else begin txt='Pad'  & map1=0 & map2=1 & b_labins(5)=0 & endelse

	   aque = widget_base  (b1,/row)

	   if mbar eq 0 then begin
		bque = widget_button(aque ,font=ft_b_normal,value=txt)
		if sys_dep('MACHINE') eq 'win'  then val='  ' else val=' '
		bid  = widget_label (aque ,font=ft_propor  ,value=  val ) & endif

	   aque = widget_base  (aque )
;	   cque = widget_base  (aque ,/row,resource_name="geo",map=map1,frame=3)
	   cque = widget_base  (aque ,/row,resource_name="geo",map=map1)

	;	STACKER DATA ACCESS MODEL
;		b1= widget_base  (aque ,map=map2,/column,frame=3)
		b1= widget_base  (aque ,map=map2,/column)

	;	BESIDE  DATA ACCESS MODEL
	;	ttl='DATA Access....'
	;	if sys_dep('VERSION') lt 4.0 then $
	;	       ii=execute('b1=widget_base(title=ttl,/column,map=0,resource_name="lampmic"') $
	;	else   ii=execute('b1=widget_base(title=ttl,/column,map=0,resource_name="lampmic",tlb_frame_attr=8+2)')
	;	bu   = widget_base (b1 ,/row)
	;	put_logo,bu
	;	laber= widget_label(bu ,font=ft_b_normal,value='                  	',xsize=(lamp_siz/2)<600>300)
	;	Widget_Control, b1 ,group_leader=lamp_b1,/Realize & put_logo
	;	Xmanager,'Daccess' , b1 ,Event_Handler='LAMP_EVENT_PARSER',/just_reg

	  if mbar eq 0 then  widget_control,bque,set_uvalue=[-88,557,0,b1,cque,0]

	   dque = widget_base  (cque ,/column)
	   eque = widget_base  (dque ,/row)
	   bid  = widget_label (eque ,font=ft_b_bigger,value='COMMAND Control PAD')
	   bid  = widget_button(eque ,font=ft_b_bigger,value='?',uvalue=[-88,595,laber,0])
	   eque = widget_base  (dque ,/row)
	   bido = widget_text  (eque ,font=ft_propor  ,xsize=20,ysize=1,/editable)
	   bidu = widget_button(eque ,font=ft_b_bigger,value='Send')

	   ii   = findfile('dial_pad_init.prox',count=nn)
	   if  nn gt 0 then COMMSI,'dial_pad_init.prox', /EXEC $
	   else begin par1=''
		Mach=strlowcase(getenv('HOST')) & id=strpos(Mach,'.')
		if id gt 0 then Mach=strmid(Mach,0,id)
		if Mach ne '' then begin
		   catch,stat
	   	   if stat eq 0 then ii=execute('par1=dial_pad_init_'+(Mach)+'(dummy)') else catch,/cancel
	   	endif
	   	sz=SIZE(par1)
		if  sz(0) lt 2 then ii=execute("par1=dial_pad_init()")
	   endelse
	   sz=SIZE(par1)
	   if (sz(0) ne 2) or (sz(1) ne 5) then begin par1=strarr(5,17) & par1(*,*)='0'
	                                              par1(0,0)='' & par1(3,0)='lamp'  & endif
	   widget_control,bido,set_value=par1(0,0)
	   PROX=par1(*,0)
	   GEORGEO, duduch=PROX
	   uvv =[-88,540,0,cque]
	   widget_control,cque,set_uvalue=par1
	   widget_control,bido,bad_id=i,set_uvalue=[uvv,0,PROX,bido,0]
	   widget_control,bidu,bad_id=i,set_uvalue=[uvv,0,PROX,bido,0]

	   i=1 & k=0 & n_e=n_elements(par1)/5
	   par1=[[par1],['','','','','']]
	   while i  lt n_e do begin
		val=par1(0,i)
		j=k/2 & if j*2 eq k then dque = widget_base  (cque ,/column)
		eque  = widget_base  (dque ,/row)
		k=k+1
;**	level1
		if par1(2,i) eq '-' then begin
		  bid1= widget_button(eque ,font=ft_b_bigger,value=val ,menu=2)
		  i=i+1
		  while strpos(par1(0,i),'-') eq 0 do begin
		   val =strmid(par1(0,i),1,15)
;**	level2
		   if par1(2,i) eq '-' then begin
			bid2=widget_button(bid1 ,font=ft_b_bigger,value=val ,menu=2)
			i=i+1
			while strpos(par1(0,i),'--') eq 0 do begin
			  val =strmid(par1(0,i),2,15)
;**	level3
			  if par1(2,i) eq '-' then begin
				bid3=widget_button(bid2 ,font=ft_b_bigger,value=val ,menu=2)
				i=i+1
				while strpos(par1(0,i),'---') eq 0 do begin
				  val =strmid(par1(0,i),3,15)
				  SetDuduch,"_send", par1(3,i), PROX
				  bid4=widget_button(bid3 ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
				  i=i+1
				endwhile
			  endif else begin
				SetDuduch,"_send", par1(3,i), PROX
				bid3=widget_button(bid2 ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
				i=i+1 & endelse
			endwhile
		   endif else begin
			SetDuduch,"_send", par1(3,i), PROX
			bid2=widget_button(bid1 ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
			i=i+1 & endelse
		  endwhile
		endif else begin
		  SetDuduch,"_send", par1(3,i), PROX
		  bid = widget_button(eque ,font=ft_b_bigger,value=val,uvalue=[uvv,i,PROX,bido,i])
		  i=i+1 & endelse
	   endwhile
	endif
;b22
	if (lamp_siz ge 800) or (GEORGE ne 0) then $
	    laber=  widget_label (b1 ,font=ft_b_normal,value='Click below to access data from experiments',xsize=(lamp_siz*2/3)<600>300)
	    b_labins(7)=laber
;	b77=  widget_base  (b1  ,map=0)
	b88=  widget_base  (b1  ,/row)
	bac=  widget_button(b88 ,font=ft_b_normal,value=text)
	b33=  widget_base  (b88 ,/row, map=0)
;b44
	IF mbar eq 0 then begin
	  b44  =  widget_base  (b1  ,/row)
	  if GEORGE ne 0 then bid='IMPORT FILES, Workspaces' $
			 else bid='IMPORT FILES  or  RESTORE Workspaces'
	  butl =  widget_button(b44 ,font=ft_b_normal,value=bid)
	  buts =  widget_button(b44 ,font=ft_b_normal,value='EXPORT')
	  if (lamp_touch gt ' ') and (lamp_siz ge 800) then $
	    if sys_dep('MAP') ne -1 then $
	       butt =  widget_button(b44 ,font=ft_b_normal,value='Catalog...',uvalue=[-88,331,0],$
								resource_name='discret')  else $
	       butt =  widget_button(b44 ,font=ft_b_normal,value='Catalog...',uvalue=[-88,331,0])
	  if   sys_dep('MAP') ne -1 then $
	       butb =  widget_button(b44 ,font=ft_b_normal,value='Browse...'    , $
								resource_name='discret') else $
	       butb =  widget_button(b44 ,font=ft_b_normal,value='Browse...')
	     
	  widget_control,butl ,bad_id=i,set_uvalue=[-88,380,0    ,0,0,0,0,0,0]
	  widget_control,buts ,bad_id=i,set_uvalue=[-88,370,0    ,0,0,0,0,0,0]
	  
	  bs1f =widget_base  (b44,/row,/frame)
	  if sys_dep('MAP') ne -1 then $
	  bs1b1=widget_button(bs1f,font=ft_smaller ,value='<-',resource_name='discret') else $
	  bs1b1=widget_button(bs1f,font=ft_smaller ,value='<-')
	  wread=widget_label (bs1f,font=ft_b_normal,value='W1 ',xsize=29)
	  if sys_dep('MAP') ne -1 then $
	  bs1b2=widget_button(bs1f,font=ft_smaller ,value='->',resource_name='discret') else $
	  bs1b2=widget_button(bs1f,font=ft_smaller ,value='->')

	  widget_control, bs1b1  ,bad_id=i,set_uvalue=[-88,310,wread,0   ,0,0,0,0,0]
	  widget_control, bs1b2  ,bad_id=i,set_uvalue=[-88,311,wread,0   ,0,0,0,0,0]
	  widget_control, butb   ,bad_id=i,set_uvalue=[-88,562,0,0,wread ,-2,-2,0]
	  
	endif else begin butb=b88 & widget_control,butb,bad_id=i,set_uvalue=[-88,562,0,0,0 ,-1,-1,0] & endelse
	
	P_DATA_ACCESS, laber,b33,bac,butb,1
	
	if n_elements(lamp_wrd) ne 1 then lamp_wrd='W1'

	widget_control,butb ,bad_id=i,get_uvalue=uv & wread=[uv(3),uv(4)]
	widget_control,bhelp,bad_id=i,set_uvalue=[-88,586,laber,0,0,0,0,0,0]
	widget_control,pwd_t,bad_id=i,set_uvalue=[-88,576,laber,0,0,0,0,0,0],SET_TEXT_SELECT=sel

	widget_control,bac  ,bad_id=i,set_uvalue=[-88,558,laber,b33,bac,butb]
return
end

pro	P_MAC_EVENT  ,event ,uv
;**	************
@lamp.cbk

	if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value='                   '
	icoco=0

;**PAD  Control
	if uv(1) eq 540 then begin                              ;uv(3)=cque  uv(7)=widget_text
		widget_control,uv(3),get_uvalue=PadTab          ;uv(8)=idx in padtab
		ncomm=-1
		bito = 0
		if uv(4) le 0 then begin                        ;*Comes from input widget_text
			widget_control,uv(7),get_value =comm
			comm =comm(0) & ncomm=uv(8)             ;   will xecute the command
		endif else begin                                ;*Comes from button
		   if PadTab(2,uv(8)) eq "t" then begin         ;   Put command to widget_text
			widget_control,uv(7),set_value =PadTab(1,uv(8))
			widget_control,uv(7),get_uvalue=uvv & uvv(8)=uv(8)
			widget_control,uv(7),set_uvalue=uvv     ;   and put index in uv
		   endif else $
		   if (uv(4) ne 100) and $
		     (PadTab(2,uv(8)) eq "c") then begin k=uv(8);   Create a GUI-input command
		   	str8="PAD_" +strtrim  (string(k),2)
			if xregistered(str8) le 0 then begin
			   padr=str_sep    (PadTab(1,k),"<cr>")
			   padb=widget_base(title=PadTab(0,k),resource_name='lamp',/column)
			   for r=0,n_elements(padr)-1 do begin
			   	padt =str_sep      (Padr(r),"~")
			   	n    =n_elements   (padt)
			   	if (n/2)*2 ne n then padt=[padt,' ']
			   	n    =n_elements   (padt) & biti =lonarr(n)
			   	padg =widget_base  (padb,/row,resource_name='geo',/frame)
			   	for i=0,n-1,2 do begin
			     	  bid=widget_base  (padg,/column)
			     	  bil=widget_label (bid ,value=padt(i)  ,font=ft_b_bigger) & biti(i)=bil
			     	  bit=widget_text  (bid ,value=padt(i+1),font=ft_propor ,/editable,$
			     			    xsize=strlen(padt(i+1))+3) & biti(i+1)=bit
			   	endfor
			   if r eq 0 then bito=biti else bito=[bito,-1,-1,biti]
			   endfor
			   ivv  =uv & ivv(4)=100
			   padg =widget_base  (padb,/row,resource_name='geo') & put_logo,padg
			   bid  =widget_button(padg,value='SEND ->',font=ft_b_bigger,uvalue=ivv)
			   bid  =widget_button(padg,value=' CLOSE ',font=ft_b_bigger,uvalue=[-88,399,0])
			   err  =widget_label (padg,value='       ',font=ft_b_normal,xsize=250)
			   bito =[bito,err]
			   widget_control,padb,group_leader =lamp_b1,set_uvalue=bito,/realize & put_logo
			   XMANAGER, str8,padb,event_handler='LAMP_EVENT_PARSER',/just_reg
			endif
		   endif else begin
		   	ncomm=uv(8)				;   will execute the command
			if (uv(4) ne 100) then  comm =PadTab(1,uv(8)) $		;from button
			else begin    como='' & comm =[''] & r=0 & sep=''		;from GUI
				widget_control, event.top, get_uvalue=bito
				nbito= n_elements(bito)-1
				for j=1,nbito-1,2 do begin	 comi=''
		  		   if bito(j) gt 0 then begin
					widget_control,bad_id=ii,bito(j-1),get_value=labi
					widget_control,bad_id=ii,bito(j)  ,get_value=comu
					comi   = strtrim (comu(0),2)
					comm(r)= comm(r) +comi+' '
					if comi eq '' then ncomm=-1
					como   = como+sep+labi(0)+"~"+comi & sep="~"
		  		   endif else begin r=r+1  & sep=""
					comm   =[comm,'']  & como=como+"<cr>" & endelse
				endfor
				PadTab(1,uv(8))=como
				widget_control,uv(3)    ,set_uvalue=PadTab
				if ncomm lt 0 then txt='!!! Cmd is incomplete.' else txt='Sending ...'
				bito=bito(nbito)
				widget_control,bito,bad_id=ii,set_value =txt
			endelse
		   endelse
		endelse
		if ncomm ge 0 then begin                        ;*Executes the command
			d0={GENERIC:PadTab(3,ncomm),NAME:PadTab(0,ncomm),TYPE:'PAD',PROS:[uv(5),uv(6)]}
			on_ioerror, mischk & check=0. & check=float(PadTab(4,ncomm)) & mischk:
			R=0L & ii=execute('R = DialControl(comm,  d=0, check=check)')
			if (R lt 0) or (R gt 1) then txt="error-code "+string(R) else txt= '- Sent -'
			if bito gt 0 then widget_control,bito,set_value =txt     else print,txt+': '+comm
		endif
		endif

;**Lamp and George configuration
	if uv(1) eq 557 then begin widget_control,event.id,get_value=labbut
				   widget_control,bad_id=i,l_message,set_value=''
				   if n_elements(uv) gt 6 then idx=uv(5) else idx=0
				   if   idx eq 0 then begin
				    idx=strpos(strupcase(labbut),'PAD')
				    if  idx ge 0 then widget_control,event.id,set_value="Data" $
				                 else widget_control,event.id,set_value="Pad"
				   endif else begin
				    if  idx gt 0 then widget_control,uv(6),sensitive=1 else widget_control,uv(6),sensitive=0
				    if  GEORGE gt  0  then $
				    if  idx gt 0 then widget_control,uv(7),sensitive=0 else widget_control,uv(7),sensitive=1
				   endelse
				   if idx eq -1 then begin
					widget_control,bad_id=i,uv(4),map=0
					widget_control,bad_id=i,uv(3),map=1 & b_labins(5)=0
					if GEORGE       eq 2 then widget_control,bad_id=i,lamp_ben(8) , map=0
					                          widget_control,bad_id=i,lamp_ben(7) , map=1
					if lamp_ben(10) gt 0 then widget_control,bad_id=i,lamp_ben(10), map=0
					
					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_ben(0) , map=0
					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_b1     , scr_xsize=uv(9)
					if b_labins(6)  eq 1 then widget_control,bad_id=i,uv(8)       , sensitive=0
					
				   endif else begin
					widget_control,bad_id=i,uv(3),map=0
					widget_control,bad_id=i,uv(4),map=1 & b_labins(5)=1
					if GEORGE       eq 2 then widget_control,bad_id=i,lamp_ben(7) , map=0
					if GEORGE       eq 2 then widget_control,bad_id=i,lamp_ben(8) , map=1
					if lamp_ben(10) gt 0 then widget_control,bad_id=i,lamp_ben(10), map=0
					
					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_b1     , scr_xsize=uv(10)
					if b_labins(6)  eq 1 then widget_control,bad_id=i,lamp_ben(0) , map=1
					if b_labins(6)  eq 1 then widget_control,bad_id=i,uv(8)       , sensitive=1
				   endelse
				   endif
;**Data Access Creation
	if uv(1) eq 558 then begin if n_elements(lamp_ins) le 1 then customiz,1
				   P_DATA_ACCESS, uv(2),uv(3),uv(4),uv(5),0
				   widget_control,bad_id=i,uv(3),map=1 & endif
	if uv(1) eq 559 then begin if n_elements(lamp_ins) le 1 then customiz,1
				   P_DATA_ACCESS, uv(2),uv(3),uv(4),uv(5),2
				   widget_control,bad_id=i,uv(3),map=1 & endif
;**Change Instrument Name
	if uv(1) eq 560 then begin
	   if uv(5) ge 0 then begin
		inst_old  =strlowcase(inst_value)
		inst_value=lamp_ins(uv(5))
		inst_group=lamp_grp(uv(5))
		idx =where(lamp_entry eq inst_group)
		if idx(0) lt 0 then begin lamp_entry=[lamp_entry,inst_group]
				;plug_in
				VV=strtrim(string(sys_dep('VERSION')),2)
				VV=strmid (VV,0,1)+strmid (VV,2,1)
				plugpth=sys_dep ('NEWSUB',lamp_dir,'plug_in')
				plugfil=findfile(plugpth+'*'+strlowcase(inst_group)+'*'+VV+'*.rt',count=nn)
				if nn gt 0 then for i=0,nn-1 do begin
				   idx =where(lamp_entry eq plugfil(i))
				   if idx(0) lt 0 then begin lamp_entry=[lamp_entry,plugfil(i)]
					P_RESTORE,plugfil(i) ,rflg
					PRINT    ,plugfil(i) +' plug_in loaded ...'
					to_don_history,-1,0,plugfil(i) +' plug_in loaded ...'
				   endif
				endfor
		endif
		if uv(3) gt 0 then widget_control,uv(3)	,bad_id=i,set_value=inst_value
		if uv(7) gt 0 then widget_control,uv(7)	,bad_id=i,set_value=inst_value
		if lamp_cyc(1)  eq 0 then cycle = lamp_ali(lamp_cyc(0))
		p_ath=lamp_path(lamp_cyc(0))
		if  cycle ne 'Current Path' then $
		 if strpos(strlowcase(cycle),'cycle') lt 0   then begin
		      path_for_online=p_ath+lamp_dvd
		      strp=strpos(path_for_online,'(inst)')
		      if strp gt 0 then path_for_online=strmid(path_for_online,0,strp)+strlowcase(inst_value)+strmid(path_for_online,strp+6,50)
		      if strp gt 0 then if strpos(cycle,'On_Line') eq 0  then cycle=inst_value
		 endif else begin
			if lamp_cyc(1) gt 0 then begin  p_ath=path_for_online & n=strlen(inst_old)
					pos1 =strpos(p_ath,inst_old)
					if pos1 gt 0 then p_ath=strmid(p_ath,0,pos1-1)+strmid(p_ath,pos1+n,10)
			endif else p_ath=p_ath+lamp_dvd
			path_for_online=sys_dep('INSUB',p_ath,strlowcase(inst_value))
		 endelse
		to_don_history,-1,0,'RDSET,inst="'+inst_value+'"'
	   endif else  customiz,1
	endif
;**Change Cycle
	if uv(1) eq 561 then begin
		lamp_cyc=[uv(5),uv(7)]
		if uv(7) gt 0 then begin YT=strtrim(string(uv(7)),2)
					 if strlen(YT) eq 1 then YT='0'+YT
					 if strlen(YT) eq 2 then YT='0'+YT & cycle='Cycle '+YT
		endif else cycle  =lamp_ali(lamp_cyc(0))
		tmps=''
		if uv(4) gt 0 then widget_control,uv(4)	,bad_id=i,set_value=cycle
		if uv(6) gt 0 then widget_control,uv(6)	,bad_id=i,set_value=cycle
		path_for_online=''
		if  cycle ne 'Current Path' then $
		 if strpos(strlowcase(cycle),'cycle') lt 0    then begin
		      path_for_online=lamp_path(lamp_cyc(0))+lamp_dvd
		      strp=strpos(path_for_online,'(inst)')
		      if strp gt 0 then path_for_online=strmid(path_for_online,0,strp)+strlowcase(inst_value)+strmid(path_for_online,strp+6,50)
		      if strp gt 0 then if strpos(cycle,'On_Line') eq 0  then cycle=inst_value
		 endif else begin
		      p_ath =  lamp_path(lamp_cyc(0))+lamp_dvd
		      bid   = 'Connecting '+p_ath+' ...' & n=0
		      if uv(2) gt 0 then widget_control,bad_id=i,uv(2) ,set_value=bid else print ,bid
		      if uv(7) gt 0 then begin tmps=',cycle='+YT
			 bid  =where(lamp_ali eq 'archive') & bid=bid(0)
			 if bid ge 0 then p_arc =lamp_path(bid) else p_arc= '?'
			 p_ath=sys_dep ('INSUB',p_ath,YT)
			 bid  =FINDFILE(p_ath,count=n)
			 if n le 0 then bid  =FINDFILE(p_ath+'*',count=n)
			 if n le 0 then begin	 ;Last chance !!!
					if p_arc ne '?' then begin p_ath=sys_dep ('INSUB',p_arc+lamp_dvd,YT)
					   bid =  'Connecting the archive system ...'
			 		   if uv(2) gt 0  then widget_control,bad_id=i,uv(2) ,set_value=bid else print,bid
			 		   bid =FINDFILE(p_ath,count=n)
					endif
			 endif
			 if n gt 0 then if strpos(p_ath,p_arc) ge 0 then bid =FINDFILE('/CDBOX',count=n)
		      endif else begin  catch,stat & if stat eq 0 then begin cd,p_ath,current=mee & cd,mee & n=1 & endif
		      endelse
		      if n le 0 then bid='Connection failed !!!' else bid =''
		      if uv(2) gt 0  then widget_control,bad_id=i,uv(2)   ,set_value=bid else print,bid
		      path_for_online=sys_dep('INSUB',p_ath,strlowcase(inst_value))
		 endelse
		to_don_history,-1,0,'RDSET,base="'+lamp_ali(lamp_cyc(0))+'"'+tmps
	endif
;**Browse
	if uv(1) eq 562 then begin
		lamp_man=findfile(path_for_online,count=n)
		if n eq 0 then lamp_man=findfile(path_for_online+'*',count=n)
		uvv=uv & uvv(1)=563
		if n gt 0 then begin cd,path_for_online,current=mee & cd,mee,current=p_f_o
				     if strmid(p_f_o,strlen(p_f_o)-1,1) ne lamp_dvd then p_f_o=p_f_o+lamp_dvd
				     ln=strpos(strupcase(lamp_man(0)),strupcase(p_f_o))
				     if ln ge 0 then lamp_man=strmid(lamp_man,ln+strlen(p_f_o),30)
		endif
		if uv(5) gt 0 then widget_control,bad_id=i,uv(5),/destroy
		base =widget_base  (title='Select File to Read',resource_name='lamptouch',/column)
		uv(5)=base
		bid  =widget_label (base,value="PATH="+path_for_online,font=ft_b_normal)
		lab  =widget_base  (base,/row)
		lub  =widget_list  (lab ,value=lamp_man,xsize=15,ysize=15,font=ft_propor)
		lab  =widget_base  (lab ,/column)
		lib  =widget_base  (lab,/row) & put_logo,lib
		bid  =widget_label (lib,value="sub",font=ft_b_normal)
		lyb  =widget_text  (lib,xsize=8,ysize=1,font=ft_propor,/editable,uvalue=[-88,564,lub])
		lob  =widget_draw  (lab ,retain=2  ,xsize=192,ysize=192)
		lib  =widget_base  (lab,/row)
		bid  =widget_button(lib,value='Done'   ,font=ft_b_normal,uvalue=[-88,399,0])
		bid  =widget_button(lib,value='Refresh',font=ft_b_normal,uvalue=uv)
		
		widget_control,bad_id=i,event.id,set_uvalue=uv
		widget_control,bad_id=i,base,group_leader=lamp_b1,set_uvalue=uv(1),/realize & put_logo
		widget_control,bad_id=i,lob,get_value = loob
		uvv(6)=loob & uvv(7)=lyb
		widget_control,bad_id=i,lub,set_uvalue= uvv
		XMANAGER, 'BROWS' ,base ,event_handler='LAMP_EVENT_PARSER',/just_reg
	endif
	if uv(1) eq 563 then begin
		runtxt=lamp_man(event.index)  & uv(1)=577
		if strpos(runtxt,strlowcase(inst_value)+'_') eq 0 then begin ;(Sub dir)
		  uv(1)=564
		  uv(2)=event.id
		  event.id=uv(7)
		  widget_control,bad_id=i,uv(7),set_value=runtxt
		endif else begin
		  icoco =1
		  idx   =strpos(runtxt,'.Z')    & if idx gt 0 then runtxt=strmid(runtxt,0,idx)
		  widget_control,bad_id=i,uv(3),set_value=runtxt
		endelse
	endif
	if uv(1) eq 564 then begin
		widget_control,bad_id=i,event.id,get_value=newsub   &   newsub=strcompress(newsub(0),/remove_all)
		if newsub ne '' then begin l_man=findfile(sys_dep('INSUB',path_for_online,newsub)    ,count=n)
		      if n eq 0 then	   l_man=findfile(sys_dep('INSUB',path_for_online,newsub)+'*',count=n)
		      if n gt 2 then begin lamp_man=l_man
					   poth=path_for_online+newsub & ln=strpos(strupcase(lamp_man(0)),strupcase(poth))
					   if ln lt 0 then begin poth=path_for_online & ln=strpos(strupcase(lamp_man(0)),strupcase(poth)) & endif
					   if ln ge 0 then lamp_man=strmid(lamp_man,ln+strlen(poth),30)
					   surp=strmid(lamp_man(0),0,1) & if surp eq lamp_dvd then lamp_man=strmid(lamp_man,1,30)
					   widget_control,bad_id=i,uv(2),set_value=lamp_man
		      endif
		endif
	endif

;**Browse URL
	if uv(1) eq 567 then begin widget_control,uv(3),bad_id=ii,get_uvalue=url
	                           bid=sys_dep('BROWSE',url) & endif

;**More for Instrument specific
	if uv(1) eq 568 then begin widget_control,uv(3),bad_id=ii,get_uvalue=stuc
	if (xregistered('A_'+stuc.macro)) eq 0 then begin
		bas  =widget_base  (title=stuc.macro,/column,resource_name='lampmic')
		llg  =widget_base  (bas,/row) & put_logo,llg
		bid  =widget_label (llg,value=stuc.macro   ,font=ft_biggest)
		bid  =widget_label (llg,value=stuc.author  ,font=ft_b_normal)
		if stuc.link gt ' ' then begin
		  bod=widget_button(llg,value='Url'        ,font=ft_b_normal,/menu)
		  widget_control,bod,bad_id=ii,set_uvalue = stuc.link
		  bid=widget_button(bod,value=stuc.link    ,font=ft_b_normal,uvalue=[-88,567,0,bod])
		endif
		bid  =widget_label (bas,value=stuc.purpose ,font=ft_b_bigger)
		for i=1,n_elements(stuc.more)-1 do $
		bid  =widget_label (bas,value=stuc.more(i) ,font=ft_b_normal)
		bss  =widget_base  (bas,/row)
		txt  =widget_text  (bss,value=stuc.call    ,font=ft_propor,/editable,xsize=50,ysize=1)
		bid  =widget_button(bss,value='Do'         ,font=ft_b_normal,uvalue=[-88,214,20,txt,0])

		widget_control,bas,group_leader=lamp_b1,/realize
		if stuc.logo gt ' ' then put_logo, file=stuc.logo else put_logo
		XMANAGER,'A_'+stuc.macro,bas,event_handler='LAMP_EVENT_PARSER',/just_reg
	endif & endif

;**Run macro for Instrument specific
	if uv(1) eq 569 then begin
		CASE uv(3) of
		-1:  begin spec_wplot,event,runtxt
		     if runtxt gt '' then begin
			uv=[-88,579,b_labins(7),lamp_ben(15),lamp_ben(16)]
			widget_control,bad_id=i,uv(3),set_value=runtxt & endif
		     end
		ELSE:begin
		     catch,stat & ii=0
		     if  stat eq 0 then begin widget_control,uv(4),get_uvalue=run
		     			      idp=strpos(run,'.prox') & if idp gt 0 then run=strmid(run,0,idp)
		     			      if idp le 0 then ii=execute(run) else P_LAYOUT,prox=run & endif
		     catch,/cancel
		     if (stat ne 0) or (ii ne 1) then $
		     if (b_labins(6)) and (b_labins(7) gt 0 ) then widget_control,b_labins(7),bad_id=ii,set_value=!err_string $
		                                              else widget_control,l_message  ,bad_id=ii,set_value=!err_string
		     end
		ENDCASE
	endif

;**Instrument specific
	if uv(1) eq 570 then if n_elements(lamp_ben) ge 15 then $
	                        if lamp_ben(10) gt 0 then begin
		                    widget_control,bad_id=ii,lamp_ben(10), get_uvalue=bu
		                    widget_control,bad_id=ii,lamp_ben(7) , map=0
		if GEORGE eq 2 then widget_control,bad_id=ii,lamp_ben(8) , map=0
		                    widget_control,bad_id=ii,lamp_b1     , scr_xsize=bu(3)
		                    widget_control,bad_id=ii,lamp_ben(0) , map=1
		                    widget_control,bad_id=ii,lamp_ben(10), map=1
		if GEORGE eq 2 then widget_control,bad_id=ii,lamp_ben(13), sensitive=1
		                    widget_control,bad_id=ii,lamp_ben(14), sensitive=1
		                    widget_control,bad_id=ii,lamp_ben(12), sensitive=1
		if uv(3) gt 0 then uv7=uv(7) else uv7=uv(3)
		if (bu(0) ne uv7) or (uv7 lt 0) then begin
		   widget_control,bu(1),bad_id=ii,/destroy & bu(0) =uv7
		   bu(1)=widget_base(lamp_ben(11),/column,y_scroll =fix(lamp_siz/2.1)<435)
		   tmpbase=0 & P_messi,tmpbase,bu(1)
		   widget_control,lamp_ben(10),bad_id=ii,set_uvalue=bu
		   widget_control,bu(2) ,bad_id=ii, set_value='-------------'

		   CASE uv7 of
		   -1:	begin widget_control,bu(2) ,bad_id=ii, set_value='SPEC contents'
			spec_wlist,bu(1)
			end
		   ELSE:begin titl='MACROS LIST'
			if event.id gt 0 then widget_control,event.id    ,bad_id=ii, get_value=titl
			widget_control,bu(2)       ,bad_id=ii, set_value=strupcase(strmid(titl,0,15))
			widget_control,uv(3)       ,bad_id=ii,get_uvalue=fifis
			fifi=fifis(uv(7))
			topic='' & macr='' & purp='' & auth='' & coll='' & bmc=0 & more=[''] & icof='' & lnk=''
			on_ioerror,misfifi & lun=-1  & lin=''
			OPENR,lun,fifi,/get_lun
			while not eof(lun) do begin
			READF,lun,lin & lon=strlowcase(lin)

			if (strpos(lon,'topic:') ge 0) or (strpos(lon,'macro:') ge 0) then $
						   if n_elements(more) gt 1 then if bmc gt 0 then begin
						      widget_control,bmc,set_uvalue=$
						      {topic:topic,macro:macr,purpose:purp,author:auth,call:coll,more:more,logo:icof,link:lnk}
						      bid=widget_button(bmc  ,value='More...',font=ft_propor,uvalue=[-88,568,b_labins(7),bmc])
						      endif
			c=strpos(lon,'topic:')	 & if c ge 0 then begin topic=strmid(strtrim(strmid(lin,c+6,150),2),0,13)
						   if bmc gt 0 then $
						   bid  =widget_label (bu(1),value='---')
						   bid  =widget_label (bu(1),value=topic ,font=ft_b_normal)
						   macr='' & purp='' & auth='' & coll='' & bmc=0 & more=[''] & lnk='' & endif

			c=strpos(lon,'macro:')	 & if c ge 0 then begin
						   macr =strmid(strtrim(strmid(lin,c+6,150),2),0,13)
						   bmc  =widget_button(bu(1),value=macr  ,font=ft_b_normal,menu=2)
						   purp='' & auth='' & coll='' & more=[''] & lnk='' & endif

			c=strpos(lon,'purpose:') & if c ge 0 then begin purp =strmid(strtrim(strmid(lin,c+8,150),2),0,80)
						   if bmc gt 0 then  if purp gt ' ' then $
						   bid  =widget_button(bmc  ,value='Purpose: '+purp,font=ft_propor) & endif

			c=strpos(lon,'author:')	 & if c ge 0 then begin auth =strmid(strtrim(strmid(lin,c+7,150),2),0,80)
						   if bmc gt 0 then  if auth gt ' ' then $
						   bid  =widget_button(bmc  ,value='Author:  '+auth,font=ft_propor) & endif

			c=strpos(lon,'call:')	 & if c ge 0 then begin coll =strmid(strtrim(strmid(lin,c+5,150),2),0,80)
						   if bmc gt 0 then  if coll gt ' ' then $
						   bid  =widget_button(bmc  ,value='Call:    '+coll,font=ft_propor) & endif

			c=strpos(lon,'more:')	 & if c ge 0 then more=[more, strmid(strtrim(strmid(lin,c+5,150),2),0,80)]

			c=strpos(lon,'run:')	 & if c ge 0 then begin run  =strmid(strtrim(strmid(lin,c+4,150),2),0,150)
						   if bmc gt 0 then  if run gt ' ' then begin
						   widget_control,bmc,set_uvalue=run
						   bid  =widget_button(bmc  ,value='Run....',font=ft_propor,uvalue=[-88,569,b_labins(7),0,bmc])
						   endif & endif
						   
			c=strpos(lon,'logo:')	 & if c ge 0 then begin icof =strmid(strtrim(strmid(lin,c+5,60 ),2),0,40)
						   p=strpos(strlowcase(fifi),'a_list') & cof =''
						   if p gt 0 then cof=strmid(fifi,0,p) & icof=cof+icof & endif

			c=strpos(lon,'link:')	 & if c ge 0 then lnk=strmid(strtrim(strmid(lin,c+5,150),2),0,150)

			endwhile
						   if n_elements(more) gt 1 then if bmc gt 0 then begin
						      widget_control,bmc,set_uvalue=$
						      {topic:topic,macro:macr,purpose:purp,author:auth,call:coll,more:more,logo:icof,link:lnk}
						      bid=widget_button(bmc  ,value='More...',font=ft_propor,uvalue=[-88,568,b_labins(7),bmc])
						   endif

			misfifi:if lun gt 0 then FREE_LUN,lun
			end
		   ENDCASE
		   P_messi, tmpbase,bu(1)
		endif
	endif
;**LampINX
	if uv(1) eq 571	then if uv(2) eq 1 then inx $
			else if uv(2) eq 2 then qens_fit

;**Workspace operations.
	if uv(1) eq 572 then case uv(3) of
		1: begin W_store   ,/ALL
			 widget_control,uv(4),bad_id=ii,sensitive=1
			 widget_control,uv(5),bad_id=ii,sensitive=1
		   end
		2:	 W_restore ,/ALL
		3:	 W_exchange,/ALL
		4:	 W_clear   ,/ALL
		else:
		endcase
;**Idl help
	if uv(1) eq 573 then language_help

;**Create display function site UI.
	if uv(1) eq 574 then $
		 if lamp_fsite gt ' ' then  iii=execute(lamp_fsite) $
		 else widget_control,bad_id=i,l_message,set_value=  $
		 		    'Well, indeed, so, good .. need to be customized!'
;**Create access site UI.
	if uv(1) eq 575 then $
		 if lamp_asite gt ' ' then  iii=execute(lamp_asite) $
		 else widget_control,bad_id=i,uv(2)    ,set_value=  $
		 		    'Well, indeed, so, good .. need to be customized!'

;**Change Path
	if uv(1) eq 576 then if event.type lt 3 then begin my_path(1)='1'
			     if event.type eq 0 then if event.ch eq byte(10) then P_SET_PATH
			     endif
;**Get Run
	if (uv(1) eq 577) or (uv(1) eq 578) or (uv(1) eq 579) then begin

		widget_control,bad_id=i,uv(4),get_value=wnumber
		i =strpos (wnumber(0),'W')
		ws=strtrim(strmid(wnumber(0),i+1,4),2)
		wi=fix(ws)

		widget_control,bad_id=i,uv(3),get_value=runtxt
		runtxt=strtrim(strcompress(runtxt(0)),2)
		i =-1
		k =strpos(runtxt,'+') + $
		   strpos(runtxt,'-') + $
		   strpos(runtxt,':') + $
		   strpos(runtxt,'>')
		if k eq -4 then begin
		 i=strpos(runtxt,'.htm')
		 if i lt 0 then       i=strpos(runtxt,'LAMP.hdf')
		 if i lt 0 then       i=strpos(runtxt,'LAMP.xml')
		 if i lt 0 then       i=strpos(runtxt,'.nxs')
		 if i lt 0 then begin i=strpos(runtxt,'.hdf')
		                           ;if i gt 0 then if strlowcase(inst_group) ne 'nexus' then i=-1
					    endif
		 if i lt 0 then begin i=strpos(runtxt,'.xml')    & endif
		 if i lt 0 then begin i=strpos(runtxt,'.xdr')
		                            if i gt 0 then runtxt=strmid(runtxt,0,i)+'.htm'  & endif
		 if i lt 0 then begin i=strpos(runtxt,'.zip')
		                            if i gt 0 then runtxt=strmid(runtxt,0,i)+'.htm'  & endif
		 if i lt 0 then begin i=strpos(runtxt,'_LAMP')
		                            if i gt 0 then begin
				                           runtxt=strmid(runtxt,0,i)+'_LAMP'
		                                           bid   =sys_dep('POT',runtxt)      & endif
		 endif
		endif
		if i gt 0 then begin
		    j = strpos(runtxt,'{')
		    if (j gt 0) and (uv(1) eq 578) then begin
		 	k=strpos(runtxt,'}')
			strun =strtrim(string(strmid(runtxt,j+1,k-j-1)+1),2)
			runtxt=strmid (runtxt,0,j+1)+strun+'}'
        	    endif
		    READ_LAMP,runtxt, w=wi, path=path_for_online
		    widget_control,bad_id=i,uv(3),set_value=runtxt
		    if (uv(1) gt 577) then P_DID_EVENT,0,[-88,301,0,wi,0]
		    
		endif else begin  if (strpos(runtxt,'.gif') le 0) and $
		                     (strpos(runtxt,'.jpg') le 0) and $
		                     (strpos(runtxt,'.png') le 0) then GMY_run, uv,runtxt, wi $
		                  else READ_myGIF,path_for_online+runtxt,w=wi
		endelse
		if icoco eq 1 then begin wset,uv(6) & erase,255 & xx=1L & yy=1L & wr=1L
				   i=execute('xx = x' +ws) & i=execute('yy = y' +ws)
				   p_did_makeicon, ws,xx,yy, 192,192 ,0 ,wr ,'i'
		                  widget_control,bad_id=i,l_message,set_value='Read in W'+ws & endif
	endif
;**FIT
	if (uv(1) eq 580) then iii=execute('gfit')

;**Helps
	if (uv(1) ge 585) and (uv(1) le 598) then show_helps,uv
return
end

pro	GMY_run   ,uv ,runtxt ,wi
;**	*******
		 status=12
		 j = strpos(runtxt,'{')
		 if (j gt 0) and (uv(1) eq 578) then begin
		 	k=strpos(runtxt,'}')
			strun =strtrim(string(strmid(runtxt,j+1,k-j-1)+1),2)
			runtxt=strmid (runtxt,0,j+1)+strun+'}'
			widget_control,bad_id=i,uv(3),set_value=runtxt
        	 endif
        	 
		 i =rstrpos(runtxt,'.')
		 k = strpos(runtxt,'+') + $
		     strpos(runtxt,'-') + $
		     strpos(runtxt,':') + $
		     strpos(runtxt,'>')
		 
		 on_ioerror,misrun
		 if (i lt 0) or ((j gt 0) and (k gt -4)) then begin
		    if k gt -4 then begin
		         P_DID_GET_IT,runtxt              ,wi,status,uv ,'opr'
			 if ((uv(1) gt 577) and (status eq 0)) then P_DID_EVENT,0,[-88,301,0,wi,0]
		         return
		    endif
		    
		                         j =strpos(strupcase(runtxt),' SUMTO ')
		    if j lt 0 then begin j =strpos(runtxt,'>')
		       			 if j gt 0 then j=j+100 & endif
		    if j lt 0 then	 i =strpos(strupcase(runtxt), ' TO ')

		    if (i le 0) and (j le 0) then begin
		      k=0 & for i=0,strlen(runtxt)-1 do begin car   =strmid(runtxt,i,1)
		                if (car lt '0') or (car gt '9') then k=1   &  endfor
		      if k eq 0 then begin
		         run=float(runtxt)
		         run=long (run)
		         if (uv(1) eq 578) then begin
		 	     run   =run+1
		 	     runtxt=strtrim(string(run),2)
			     widget_control,bad_id=i,uv(3),set_value=runtxt
			     endif

		         status=1
		         P_DID_GET_IT,run              ,wi,status,uv ,'run'
			 
			 if ((uv(1) gt 577) and (status eq 0)) then P_DID_EVENT,0,[-88,301,0,wi,0]
		         return
		      endif
		    endif else if (uv(1) lt 578) then begin
		       cmd='w'+strtrim(string(wi),2)
		       if i gt 0 then begin
		          run1=float(strtrim(strmid(runtxt,0  ,i     ),2)) & run1=long (run1)
		          run2=float(strtrim(strmid(runtxt,i+4,lamp_6),2)) & run2=long (run2)
		          cmd =cmd+'=RDAND('
		       endif     else begin
		          run1=float(strtrim(strmid(runtxt,0  ,j),2))        & run1=long (run1)
		          if j lt 100 then k=6 else begin k=1 & j=j-100      & endelse
		          run2=float(strtrim(strmid(runtxt,j+k,lamp_6+1),2)) & run2=long (run2)
		          cmd =cmd+'=RDSUM('
		       endelse
		       cmd =cmd+strtrim(string(run1),2)+','+strtrim(string(run2),2)+',z0)'
		       z0  =-1
		       xicuter ,cmd
		       if z0 gt 0 then begin prt='Missing '  +string(z0)
			  if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value=prt else print,prt
 		       endif
		       return
		    endif
		 endif
		 misrun:
		 P_DID_GET_IT,runtxt,wi,status,uv ,'fil'
		 if ((uv(1) gt 577) and (status eq 0)) then P_DID_EVENT,0,[-88,301,0,wi,0]
end

pro	SHOW_HELPS, uv
;**	**********
@lamp.cbk

	 if uv(1) eq 585 then widget_control,bad_id=i,lamp_hlp,map=0 $
	 else begin
           iii=xregistered('HELPS')
	   if (iii gt 0) then begin
	   	widget_control,bad_id=i,lamp_hlp,get_uvalue=uval
	   	if uval eq uv(1) then widget_control,bad_id=i,lamp_hlp,map=1
	   	if uval ne uv(1) then widget_control,bad_id=i,lamp_hlp,/destroy
	   	if uval ne uv(1) then iii=0
	   endif
	   if (iii le 0) then begin
	    formu='' & formt='' & ttl=''

	    if uv(1) eq 586 then begin
	    			 ttl='READING INTO WORKSPACES'
				 if (not sys_dep('RUNTIME')) and (not sys_dep('EMBEDDED'))   then begin
				    iii= execute('myhelp_'+strlowcase(inst_value)+',formu')     & endif
				 if n_elements(formu) le 1 then iii= execute('myhelp,formu')
				 if n_elements(formu) le 1 then p_did_help,uv(1),formu,formt $
				 else ttl='MYHELP.PRO'
	    endif
	    if uv(1) eq 587 then begin
	    			 ttl='DISPLAYING THE WORKSPACES'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 588 then begin
	    			 ttl='A few TIPS (See INTERNAL in User Macros?)'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 589 then begin
	    			 ttl='CALLING OTHER DISPLAY FACILITIES'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 590 then begin
	    			 ttl='GK_FIT FITTING FACILITY'
	    			 gfit_help ,uv(1),formu,formt
	    endif
	    if uv(1) eq 591 then begin
	    			 ttl='SUPERPLOT : The Multipurpose Superpose Plotting Tool for Lamp'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 592 then begin
	    			 ttl='SELECTING RUNS'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 593 then begin
	    			 ttl='3 AXES FACILITY'
	    			 ii=execute('tx_help,uv(1),formu,formt')
	    endif
	    if uv(1) eq 594 then begin
	    			 ttl='SELECTING RUNS'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 595 then begin
	    			 ttl='PAD for Command Control'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) eq 596 then begin
	    			 ttl='HELP for Instrument macros'
	    			 p_did_help,uv(1),formu,formt
	    endif
	    if uv(1) gt 596 then return

	    lamp_hlp=widget_base   (title='Lamp helps those who help themselves',$
	    			    resource_name='lamptouch',/column)
	    lamp_hls=widget_base   (lamp_hlp,/column)
	    lab	    =widget_base   (lamp_hls,/row)
		     put_logo	   ,lab
	    lab	    =widget_label  (lab     ,value=ttl,font=ft_biggest)

	    if n_elements(formu) ne n_elements(formt) then $
		blab=widget_text   (lamp_hls,value=formu,xsize=80,ysize=30,font=ft_b_normal,/scroll)$
	    else for i=0,n_elements(formu)-1 do begin
	         blab=widget_base   (lamp_hls,/row)
	         lab=widget_label  (blab    ,value=formu(i)    ,font=ft_b_bigger)
	         lab=widget_label  (blab    ,value=formt(i)    ,font=ft_normal)
	    endfor

	    base_wel=widget_button (lamp_hlp,value='Hide'      ,font=ft_b_normal ,$
	   			    uvalue=[-88,585,0])
   	    bid=sys_dep      ('DYNLAB',lamp_hlp,0)
	    widget_control,bad_id=i,lamp_hlp,group_leader=lamp_b1,set_uvalue=uv(1),/realize & put_logo
	    XMANAGER, 'HELPS' ,lamp_hlp ,event_handler='LAMP_EVENT_PARSER',/just_reg
	   endif
	 endelse
return
end

pro	P_SET_PATH,ppth
;**	**********
@lamp.cbk
	   my_path(1)=''

	   if n_elements(ppth) eq 1 then  path=[ppth] $
	   else widget_control,long(my_path(2)),bad_id=i,get_value=path
	   path=path(0)
	   stat=0
	   catch,stat
	   if stat ne 0 then begin
	        catch,/cancel
		P_MUS,'mus_cannon'
	   	path=path+'???'
		if n_elements(ppth) eq 0 then $
	        widget_control,long(my_path(2)),bad_id=i,set_value=path,SET_TEXT_SELECT=[strlen(path),0]
 	        print,string(7b)+path
	   	return
	   	endif

	   if n_elements(ppth) eq 0 then DON_WRITE_PROG_MAC ,0
	   cd,path
	   if n_elements(ppth) eq 1 then $
		widget_control,long(my_path(2)),bad_id=i,set_value=path,SET_TEXT_SELECT=[strlen(path),0]
	   my_path(0)=path
	   DON_INIT_INST_MACS ,1
	   DON_INIT_PROG_MAC  ,1
return
end

pro	P_FCT_CREATE ,base ,bas_geo2
;**	************
@lamp.cbk
	if GEORGE eq 1	then   base0      =lamp_ben(2) $
	else		begin  lamp_ben(4)=widget_base(base ,/frame,resource_name='ben')
			       base0      =widget_base(lamp_ben(4),/column)
	endelse
	base1=widget_button(base0,font=ft_normal   ,value=lamp_fsite          ,uvalue=[-88,574,0,0])
	b_labins(2) =base1
	base1=widget_button(base0,font=ft_normal   ,value=' Load new Colors  ',uvalue=[-88,347])
	base1=widget_button(base0,font=ft_normal   ,value='     GK_Fit       ',uvalue=[-88,580,0,0])
	lamp_don   =[lamp_don,base1]
	base1=widget_button(base0,font=ft_normal   ,value='    SuperPlot     ',uvalue=[-88,352])
	lamp_don   =[lamp_don,base1]

	if GEORGE eq 2 then begin
	  ;base1=widget_button(bas_geo2,font=ft_normal   ,value=' Load new Colors  ',uvalue=[-88,347])     ;removed for george=2
	  ;base1=widget_button(bas_geo2,font=ft_normal   ,value='     GK_Fit       ',uvalue=[-88,580,0,0]) ;removed for george=2
	  ;base1=widget_button(bas_geo2,font=ft_normal   ,value='    SuperPlot     ',uvalue=[-88,352])     ;removed for george=2
	endif

	if GEORGE eq 1 then begin
	  bid=widget_button(base0,font=ft_normal   ,value='      ------      ')
;	  bid=widget_button(base0,font=ft_normal   ,value='   Dial Macros?   ',uvalue=[-88,203,0,0])
;	  bid=widget_button(base0,font=ft_normal   ,value='   The Journal    ',uvalue=[-88,396,0,0])
	  bid=widget_button(base0,font=ft_normal   ,value='   Data Params    ',uvalue=[-88,204,0,0])
	  if sys_dep('VERSION') ge 4.0 then widget_control,base0,/destroy
	endif

	if (lamp_siz ge 800) and (GEORGE ne 1) then begin
	if abs(sys_dep('MAP')) ne 1 then baba=base0 else baba=base
	brow =widget_base  (baba ,/row)
	lamp_don   =[lamp_don,brow]
	bs1bs=widget_button(brow ,font=ft_normal   ,value='SCAN W 1'          ,uvalue=[-88,306,0,0])
	if sys_dep('MAP') ne -1 then $
	bs1b1=widget_button(brow ,font=ft_normal ,value='<',resource_name='discret') else $
	bs1b1=widget_button(brow ,font=ft_normal ,value='<')
	if sys_dep('MAP') ne -1 then $
	bs1b2=widget_button(brow ,font=ft_normal ,value='>',resource_name='discret') else $
	bs1b2=widget_button(brow ,font=ft_normal ,value='>')
	widget_control,bad_id=i,bs1b1,set_uvalue=[-88,310,bs1bs,3,0,0,0,0,0]
	widget_control,bad_id=i,bs1b2,set_uvalue=[-88,311,bs1bs,3,0,0,0,0,0]
	endif

	if GEORGE eq 1 then begin GEORGEO, CONSTRUCT=base   &   base0=base & endif
	if GEORGE eq 2 then       GEORGEO, CONSTRUCT=lamp_ben(8)

	if GEORGE ne 1 then begin
	   lamp_ben(5)=widget_base  (base ,/frame,resource_name='ben')
	   base0=widget_base  (lamp_ben(5),/column)
	   if  (lamp_siz gt 950) or sys_dep('MATLAB') or $
	      ((lamp_siz ge 900) and (sys_dep('MACHINE') eq 'mac')) then begin
      		      w0=2 & LOGO,w0 & pax1=size(w0)
      		      lamp_ben(6)=widget_draw (base0,retain=2,xsize=pax1(1),ysize=pax1(2),/button_event)
	   endif else begin  lamp_ben(3)=widget_label(base ,font=ft_smallest,value=' ' )
			     if lamp_siz lt 800  then put_logo,base
	   endelse
	   base1=widget_button(base0,font=ft_normal,value='    The Manual    '     ,uvalue=[-88,201,0])
	endif

	  base1=widget_button(base0      ,font=ft_normal,value='SAVE this Session ',uvalue=[-88,397])
	  lamp_don   =[lamp_don,base1]
	  base1=widget_button(base0      ,font=ft_normal,value='  SWITCH  OFF    ' ,uvalue=[-88,398])
	if GEORGE eq 2 then begin
	  base1=widget_button(lamp_ben(8),font=ft_normal,value='SAVE this Session ',uvalue=[-88,397])
	  base1=widget_button(lamp_ben(8),font=ft_normal,value='  SWITCH  OFF    ' ,uvalue=[-88,398])
	endif
return
end

pro MIC ,nocre
;** ***
;**
@lamp.cbk
common okitis, yo

	if n_elements(yo)    eq 0 then begin
	        keep_p=path_for_online & keep_i=inst_value  & keep_c=cycle
	   	P_RESTORE,lamp_dir+lamp_dvd+'mics.exe' ,cnt & ii=execute("MICS")
	   	yo=1
		ii=execute("P_MIC_CREATE ,0 ,'just'")
	        path_for_online=keep_p & inst_value=keep_i & cycle=keep_c
	endif

	if n_elements(nocre) eq 0 then begin
           i=xregistered('MIC')
	   if i gt 0 then widget_control,bad_id=i,lamp_mic,map=1 $
	   else begin
	        lamp_mic =widget_base (title='LAMP Data Instrument Access',resource_name='lampmic')
	   	ii=execute("P_MIC_CREATE ,(lamp_mic+0)")
   		bid=sys_dep      ('DYNLAB',lamp_mic,1)
		widget_control,bad_id=i   ,lamp_mic,group_leader=lamp_b1,/realize
		XMANAGER, 'MIC' ,lamp_mic ,event_handler='LAMP_EVENT_PARSER',/just_reg
	   endelse
	endif
return
end

pro	P_MUS  ,file
;**	*****
;**
@lamp.cbk
common  c_mus  ,mus_driv,mus_id,mus_fils

        if n_elements(mus_driv) lt 1 then begin
	   mus_driv =  ''
	   mus_id   =  0
	   if lamp_loc eq 1 then begin
		mus_driv=sys_dep      ('PLAYER')
;		cd,lamp_dir,current=mee
;		mus_fils=findfile     ('mus_*')
;		cd,mee
	   endif
        endif

        if n_elements(b_labins) ge 4 then if b_labins(3) eq 2 then mus_driv=''
	if mus_driv ne '' then begin
	   if file  eq '' then begin if mus_id gt 0 then bid=sys_dep      ('PLAY_OF',0,0,0,mus_id)
	   			        mus_id =0
	   endif else bid=sys_dep      ('PLAY_ON',mus_driv,lamp_dir,file,mus_id)
	endif
	if strpos(file,'cannon') ge 0 then p_tremble
return
end

pro	MANUAL ,res
;**	******
;**
@lamp.cbk
	res=''
	if lamp_dir eq '' then man_dir=sys_dep('HOME') else man_dir=lamp_dir
	res=sys_dep      ('MANUAL',man_dir,lamp_macro)
	if l_message gt 0 then widget_control,bad_id=iii,l_message,set_value=$
			 'See '+res
end

pro	P_MESSI , base ,topb
;**	*******
;**
@lamp.cbk
map=abs(sys_dep('MAP'))
if map eq 0 then return

if map eq 1 then begin
   if base  le 0 then begin
	     base =widget_base  ( title='Lamp')
	     bid  =widget_label ( base,value='LAMP RECONSTRUCTION ...',font=ft_b_bigger)
	     widget_control,topb ,bad_id=i,map=0
	     widget_control,base ,group_leader=topb   ,bad_id=i,/realize
   endif   else  begin
	     widget_control,base ,bad_id=i,/destroy
	     widget_control,topb ,bad_id=i,map=1
   endelse
endif
if map eq 2 then begin
   if base  le 0 then begin
   	    base=1 &  widget_control,bad_id=i,topb,UPDATE=0
   endif else 	      widget_control,bad_id=i,topb,UPDATE=1
endif
return
end

pro 	dynlabel_call, w
;**	*************
        type = WIDGET_INFO(w, /TYPE)
;       IF ((type EQ 1) OR (type EQ 5)) THEN BEGIN
        IF ((type EQ 1))  THEN BEGIN
                WIDGET_CONTROL, /DYNAMIC_RESIZE, w
        ENDIF ELSE IF (type EQ 0) THEN BEGIN
                child = WIDGET_INFO(W, /CHILD)
                WHILE (child NE 0) DO BEGIN
                  DYNLABEL_CALL, CHILD
                  CHILD = WIDGET_INFO(CHILD, /SIBLING)
                ENDWHILE
        ENDIF
END

pro	resizeButton_call, w ,val
;**	*****************

        type = WIDGET_INFO(w, /TYPE)
        IF (type EQ 1) THEN BEGIN
            geo = WIDGET_INFO(w, /GEOMETRY)
            WIDGET_CONTROL, w, XSIZE=(geo.scr_xsize+val)>15

        ENDIF ELSE IF (type EQ 0) THEN BEGIN
            child = WIDGET_INFO(W, /CHILD)
            WHILE ( child NE 0 ) DO BEGIN
            	    resizeButton_call, child,val
            	    child = WIDGET_INFO(child, /SIBLING) & ENDWHILE
        ENDIF
END

pro	P_DYING,id
;**	*******
@lamp.cbk
	if l_message eq 0 then exok=1 else exok=0
	lamp_b1 =0 ;<---  IMPORTANT
	if GEORGE  ne 0 then WebOff
	P_MUS,'mus_cannon'
	DON_WRITE_PROG_MAC ,1
	DID_WRITE_JOURNAL
	wait,.3 & EMPTY
	if (sys_dep('EMBEDDED')  or sys_dep('RUNTIME')) then EXIT
	rout=[1L]
	if  sys_dep('VERSION') ge 5.1 then ii=execute('rout=widget_info(/managed)')
	if  rout(0)  gt 0 then exok=0 else exok=1
	if (sys_dep('MACHINE') eq 'unix') and (exok)    then EXIT
return
end

pro	P_LAMP_STOP
;**	***********
@lamp.cbk
@dons.cbk
	   stat=0
	   catch,stat
	   if stat eq 0 then widget_control,bad_id=i,lamp_b1,show=0
	   if stat eq 0 then bid=sys_dep('AFTES')
	   if stat eq 0 then print,string(7b),' Type RETALL & LAMP to continue'
	   if stat eq 0 then stop
return
end

pro	P_LAMP_INIT, lamp_ziz=lps, george=geo
;**	***********
@lamp.cbk
	if n_elements(lps) eq 1 then lamp_ziz =lps
	if n_elements(geo) eq 1 then george   =geo
return
end

pro	P_DO_THAT
;**	*********
;**
@lamp.cbk
 lamd_dir =           sys_dep('GETENV','LAMP_DIR' )
 lamd_wind=strlowcase(sys_dep('GETENV','LAMP_WIND'))

 while strpos(!path,'..') ge 0 do begin
    i1=strpos(!path,'..')
    if strpos(!path,'..\..') ge 0 then j1=5  else j1=2
    if strpos(!path,'../..') ge 0 then j1=5
    if i1 gt 0 then deb=strmid(!path,0,i1-1) else deb=''
    !path=deb+lamd_dir +strmid(!path,i1+j1,300)
 endwhile

 cd,current=mee
 if  strtrim  (!path,2)    eq '.'  then !path=mee else $
 while (strpos(!path,'.\') ge 0) or (strpos(!path,'./') ge 0) do begin
    i1= strpos(!path,'.\') & if i1 lt 0 then i1=strpos(!path,'./')
    if i1 gt 0 then deb=strmid(!path,0,i1-1) else deb=''
    !path=deb+ mee +strmid(!path,i1+1,300)
 endwhile

 if  strtrim  (!dir,2)     eq '.'  then !dir =mee

 catch,stat & if stat eq 0 then begin cd,!dir+sys_dep('DIVIDER')+".."         & cd,current=meelam
 				      cd,meelam+sys_dep('DIVIDER')+"lamp_mac" & cd,current=meemac
				      lamd_dir=meelam
				      bid=sys_dep("ADDPATH",meemac)
				      bid=sys_dep("ADDPATH",meelam) & lamp_dir=meelam
 				endif
 catch,stat & if stat eq 0 then begin pth=sys_dep("NEWSUB",lamd_dir,"work") & cd,pth & endif
 if sys_dep('MACHINE') eq 'unix' then cd,mee

 if strpos (!path,"lamp_mac") le 0 then begin
    pth  =sys_dep("NEWSUB" ,lamd_dir,"lamp_mac")
    bid  =sys_dep("ADDPATH",pth)
    endif

 if (!D.flags and 65536)   eq 0 then set_plot,'TEK' else $
 if strpos(lamd_wind,'nw') ge 0 then set_plot,'Z'
 if  sys_dep('STUDENT')                then lamp_ziz=600
 if (strpos(lamd_wind,'small'  ) ge 0) then lamp_ziz=480
 if (strpos(lamd_wind,'medium' ) ge 0) then lamp_ziz=600
 if (strpos(lamd_wind,'large'  ) ge 0) then lamp_ziz=800
 if (strpos(lamd_wind,'wide'   ) ge 0) then lamp_ziz=1024
 GEORGE=2
 if (strpos(lamd_wind,'lamp')    ge 0) then GEORGE  =0
 if (strpos(lamd_wind,'geo')     ge 0) then GEORGE  =1
 if (strpos(lamd_wind,'lampgeo') ge 0) then GEORGE  =2
 if (strpos(lamd_wind,'geolamp') ge 0) then GEORGE  =2
 if (strpos(lamd_wind,'full')    ge 0) then GEORGE  =3
end

pro     SL_RESTSCAN, file, cnt
;**     ***********
;**
@lamp.cbk
	P_RESTORE,file ,cnt
	if cnt eq 0  then  P_RESTORE,!dir+lamp_dvd+'lib'+lamp_dvd+'hook'+lamp_dvd+'scan.sav' ,cnt
	if cnt gt 0  then  begin
		   	sl_lampscan, 'test' ,did_scan,tso
		   	if did_scan ge 0 then ii=execute('scan,1') else cnt=0
      	endif
end
pro     SL_SCANLOAD, p1,p2
;**     ***********
;**
	if p1 eq -1 then begin
			   VV =strtrim(string(sys_dep('VERSION')),2)
			   VV =strmid (VV,0,1)+strmid (VV,2,1)
			   pth=sys_dep("NEWSUB" ,p2,"lamp_mac")
			   SL_RESTSCAN,pth+'scan'+VV+'.sav' ,cnt
			   if cnt le 0 then p1=-2 else p1=1
	endif
end
pro   LANGUAGE_HELP
;**   *************
	  if sys_dep('VERSION') ge 5.0 then ii=execute('online_help' ) $
	                               else ii=execute('man_proc,"?"')
end

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; Procedures for Mini-Lamp ****** END OF LAMP_UPD.PRO
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

pro	P_RESTORE,file,cnt	;******keep this side******
;**	*********

		cnt= 0
		i  = findfile(file,count=cnt)
		if cnt gt 0  then iii=EXECUTE('restore,file')
return
end

pro	P_DON_CREATE ,base
;**	************
@lamp.cbk
	base0=widget_base     (base ,/column)
	base1=widget_base     (base0,/row)
	btitl=widget_label    (base1,font=ft_biggest,value=' FORMULA ENTRY')
	bhelp=widget_button   (base1,font=ft_normal ,value='?'	      ,uvalue=[-88,201,0])
	bform=widget_text     (base1,font=ft_b_bigger,xsize=50,ysize=1,/editable,uvalue=[-88,200,0])
	bsav =widget_button   (base1,font=ft_normal ,value='Extend...',uvalue=[-88,222,0])
	l_message=widget_label(base0,font=ft_normal)
end

pro	P_DID_CREATE ,base
;**	************
@lamp.cbk
	bs0  =widget_base  (base ,/column)
	bs1  =widget_base  (bs0  ,/row) & base1=widget_base(bs1,/row)
	btitl=widget_label (base1,font=ft_biggest,value=' DISPLAY WORKSPACE')
	bhelp=widget_button(base1,font=ft_normal ,value='Extend...',uvalue=[-88,342,0])

	bsrow=widget_base  (bs0  ,/row)
	bsopt=widget_base  (bsrow,/column,/frame)
	baswb=widget_base  (bsrow)
	d_x  =512
	d_y  =256
	if lamp_siz gt  950 then d_y  =320
	if lamp_siz lt  800 then d_x  =300
	if lamp_siz lt  800 then d_y  =230
	bdraw=widget_draw  (baswb,xsize=d_x,ysize=d_y)
	lamp_wrd     =bdraw
	lamp_did(0:5)=[lamp_did(0),base1,bs1,bsrow,bsopt,bdraw]
end
pro	P_BEN_CREATE ,base,f
;**	************
@lamp.cbk
	base0=widget_base  (base ,/column)
	base1=widget_base  (base0,/row)
	btitl=widget_label (base1,font=ft_biggest,value=' DISPLAY')
	bhelp=widget_button(base1,font=ft_normal ,value='x',uvalue=[-88,422,0])
	btitl=widget_label (base0,font=ft_biggest,value=' FUNCTIONS')
end
pro	P_MIC_CREATE ,base,p2
;**	************
end
pro 	P_DID_PS_HEADER,p1,p2,p3
;**	***************
end
pro 	DID_PARAM_HTM  ,p1
;**	*************
end
pro	P_AFTER_REALIZE_DID, s1,s2,s3
;**	*******************
@lamp.cbk
	widget_control,lamp_wrd,bad_id=i,get_value=did_win0 & lamp_wrd='?'
	wset,did_win0 & erase,100
end
pro	P_DATA_ACCESS, p1,p2,p3,p4,p5
;**	*************
end
pro	CLEARPAR, p1,p2
;**	********
end
pro	MOVEPAR, p1,p2,p3,p4
;**	*******
end
pro	SETDATP, p1
;**	*******
end
pro	GETDATP, p1
;**	*******
end
pro	COMMSI,p1, exec=e
;**	*******
end
pro	SETCOL,  n
;**	******
	if (n ge 0) and (n lt 40) then loadct,n
end
pro	TO_DID_CUR, dummy
;**	**********
end
pro	P_DID_GETW_CUR,p1,p2
;**	**************
	p1=1 & p2='1'
end
pro 	P_DID_HELP, flg, formu,formt
;** 	**********
end
pro     DID_WRITE_JOURNAL
;**     *****************
end
pro     P_DID_SETWIN0
;**     *************
end
pro	PUT_LOGO       ,p1,TIO=p2 ,FILE=p3
;**     ********
end
pro     P_DID_GET_IT   ,p1,p2,p3,p4,p5
;**     ************
end
pro     P_MIC_GETRUN   ,p1,p2,status
;**     ************
	status=3
end
pro     P_MIC_SETRUN   ,p1,p2,p3,p4
;**     ************
end
pro     TO_DON_HISTORY ,p1,p2,p3
;**     **************
end
pro     MAC_LIST       ,p1,fl,p3,THISFILE=p4
;**     ********
	fl=[' ']
end
pro     SL_LAMPSCAN, flg,p1,p2,p3,p4,p5
;**     ***********
;**
	if flg eq 'test' then begin p1=-1 & p2=0 & endif
end
function SL_ZOOM, x,y,xd,yx
;******* *******
;** Scan function
return, -1
end
pro	P_ZOOM,  x,y,xd,yx,bb
;**	******
        bb=sl_zoom(x,y,xd,yx)
end
pro	P_MIC_EVENT  ,event ,uv
;**	************
end
pro	P_DON_EVENT  ,event ,uv
;**	************
@lamp.cbk
common  for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

	widget_control,bad_id=iii,l_message,set_value=' '
       ;if uv(1) eq 201 then if sys_dep('MAP') le 0 then man_proc,'' else online_help
	if uv(1) eq 200 then begin
           widget_control,event.id,get_value=formu & formu=strtrim(formu(0),2)
           wset,did_win0
	   stat=0 & ii=1
	   catch,stat
	   if  (stat eq 0)  and   (ii eq 1) then $
  		if strpos(formu,'$') eq 0  then spawn,strmid(formu,1,100) $
  		else begin 	        ii=execute(formu)
  				        widget_control,bad_id=iii,event.id ,set_value='' & endelse
	   if ii ne 1 or stat ne 0 then widget_control,bad_id=iii,l_message,set_value=!err_string
	endif
return
end

pro	P_DID_EVENT  ,event ,uv
;**	************
;**
@lamp.cbk

        CASE uv(1) of

	342:
;**	Load colors
;**	---- ------
	347:	begin
		i=xregistered('xloadct')
		if i lt 1 then xloadct,group=lamp_b1,/use_current
		end

;**	Multi_plot create
;**	---------- ------
	352:suprplot, 0

;**	Multi_plot event (353:slider_w_x_y 354:slider_range 355:keep etc. 356:buttons)
;**	---------- -----
	353:	p_rom_super_event, event,uv
	354:	p_rom_super_event, event,uv
	355:	p_rom_super_event, event,uv
	356:	p_rom_super_event, event,uv
;**	Exit
;**	----
	398:	widget_control,/reset
	else:	widget_control,l_message,set_value='!Not available from Mini_Lamp'
	ENDCASE
return
end
pro	P_BEN_EVENT  ,event ,uv
;**	************
@lamp.cbk
return
end
pro	P_EXTEND ,event ,uv
;**	********
@lamp.cbk
	if uv(1) eq 222 then begin
	   	P_RESTORE,lamp_dir+lamp_dvd+'dons.exe' ,cnt
		if cnt gt 0  then  begin
	           bastmp=0 & P_messi,bastmp,(lamp_b1+0)
	   	   widget_control,bad_id=i,lamp_don(0),/destroy
	   	   lamp_don(0) =widget_base  (lamp_b1 ,/frame,resource_name='don')
	   	   P_DON_CREATE ,(lamp_don(0))
   		   bid=sys_dep      ('DYNLAB',lamp_don(0),0)
	   	   P_messi,bastmp,(lamp_b1+0)
	   	endif
	endif	else $
	if uv(1) eq 342 then begin
	        P_RESTORE,lamp_dir+lamp_dvd+'dids.exe' ,cntd
	        if cntd gt 0  then begin
	           bastmp=0 & P_messi,bastmp,(lamp_b1+0)
	           widget_control,bad_id=i,lamp_did(1),/destroy
	           P_DID_CREATE ,lamp_did(0) ,lamp_did(2:5)
   		   bid=sys_dep      ('DYNLAB',lamp_did(0),1)
	   	   P_messi,bastmp,(lamp_b1+0)
	   	endif
		SL_RESTSCAN,lamp_dir+lamp_dvd+'scan.exe'    ,cnt
		P_RESTORE  ,lamp_dir+lamp_dvd+'touch_b.exe' ,cnt

		if cntd gt 0  then P_AFTER_REALIZE_DID ,0,0,0
	endif   else $
	if uv(1) eq 422 then begin
	   	P_RESTORE,lamp_dir+lamp_dvd+'bens.exe' ,cnt
	   	if cnt gt 0  then  begin
		   bastmp=0 & P_messi,bastmp,(lamp_b1+0)
	   	   widget_control,bad_id=i,lamp_ben(2),/destroy
	   	   P_BEN_CREATE ,(lamp_ben(1)),0
   		   bid=sys_dep      ('DYNLAB',lamp_ben(1),0)
	   	   P_messi,bastmp,(lamp_b1+0)
	   	endif
	endif
return
end
pro	DON_INIT_INST_MACS, flg
;**	******************
return
end
pro	DON_INIT_PROG_MAC , flg
;**	*****************
return
end
pro	DON_WRITE_PROG_MAC, flg
;**	******************
return
end
pro	DON_DO_CMD, prox=p
;**	******************
return
end
pro	XICUTER, cmd
;**	*******
return
end
pro	XICUTE , cmd
;**	******
return
end
pro	SET_HISTORY
;**	***********
return
end
pro	READ_DATA
;**	*********
return
end
pro	P_TREMBLE
;**	*********
return
end
pro	LOGO, w
;**	*****
w=congrid(dist(64),128,64)
return
end

;------------------------------------------------------------------------------
;                                    Upgrade LAMP
;------------------------------------------------------------------------------
pro upg_kill,id
;** ********
common desk,whatdo,b11
widget_control,bad_id=i,b11(0),map=1
end

pro upi,lodtx,out
;** ***
;**
k=0
p_set_font,k ,lamp_font
a0=widget_base  (title='Lamp Upgrade',/column,resource_name='lamp')
a1=widget_base  (a0,/row,resource_name='mic')
lb=widget_label (a1,value='If you are behind a FireWall, enter the FTP Proxy:',font=lamp_font(5,k))
px=widget_text  (a1,value=out,xsize=10,ysize=1,/editable,font=lamp_font(5,k))
a2=widget_base  (a0,/row)
bt=widget_base  (a2,/column,resource_name='did')
ct=widget_text  (a2,xsize=60,ysize=8,/scroll,resource_name='don',font=lamp_font(5,k))
uv=[lodtx(0:5),0,px,ct,a0] & uv(3)=10
uv(6)=1 & b1=widget_button(bt,value='Read last News',uvalue=uv,font=lamp_font(3,k))
uv(6)=2 & b2=widget_button(bt,value='Upgrade Lamp'  ,uvalue=uv,font=lamp_font(3,k))
uv(6)=3 & b3=widget_button(bt,value='Cancel'        ,uvalue=uv,font=lamp_font(3,k))

w0=2 & LOGO,w0 & pax1=size(w0)
b4=widget_draw  (widget_base(bt,/row),xsize=pax1(1),ysize=pax1(2),retain=2)

widget_control,bad_id=i,lodtx(5),map=0
widget_control,bad_id=i,a0,/realize
widget_control,bad_id=i,b4,get_value=jj & wset,jj & tvscl,w0,0,0

XMANAGER, 'LAMP_UPG',a0,event_handler='DESKTOP_EVENT',CLEANUP='UPG_KILL',/just_reg
end

function ulamp,p1,p2,p3
;******* *****
;**
;p1=1	--> res=-1	bad lamp_dir
;	    res=-2	write not allowed
;	    res=0	ok
;p1=2	--> res='?'	Problem with .netrc
;	    res='.'	Unable to get the file
;	    res=lampnews.txt
;p1=3	--> res='?'	Problem with .netrc
;	    res='.'	Unable to get the file
;	    res='ok'	Got lamp_light.tar.Z
;p1=4	--> res=-1	faile
;	    res=0	MAKE_LAMP.unix successful

;p2=''	    no firewall
;p2='fname' firewall internal name
;p3= lamp_dir

ON_IOERROR,mispriv

IF p1 eq 1 THEN BEGIN
   res=-1 & OPENR,lun,p3+'lamp.pro',/get_lun	      & FREE_LUN,lun
   res=-2 & OPENW,lun,p3+'wrtest'  ,/get_lun,/delete & FREE_LUN,lun & res=0

ENDIF ELSE IF (p1 eq 2) or (p1 eq 3) THEN BEGIN

   f=FINDFILE('~/.netrc',count=N1)
   IF N1 gt 0  then SPAWN, 'mv -f ~/.netrc ~/.netrc_lampsav'
   PAS=getenv('USER')+'@'+getenv('HOST')+'.lamp'
   ILL='ftp.ill.fr'

   IF p2 eq '' then TRG=ILL ELSE TRG=p2
   IF p2 eq '' then V1 ='machine '+ILL+' login anonymous'
   IF p2 ne '' then V1 ='machine '+p2 +' login anonymous@'+ILL
		    V1 = V1+' password '+PAS
   IF P1 eq 2  then V2 = 'lampnews.txt'
   IF P1 eq 3  then V2 = 'lamp_light.tar.Z'
   V3 =['get '+V2,'quit','','']
   VAR=[ V1 ,'macdef init','bin','cd pub/cs',V3]
;  VAR=[ V1 ,'macdef init','bin','cd to_ill/cs',V3]

   res='?' & OPENW ,lun,'~/.netrc',/get_lun
   FOR i=0,n_elements(VAR)-1 DO PRINTF,lun,VAR(i)  & FREE_LUN ,lun
   SPAWN, 'chmod 700 ~/.netrc'

   f=FINDFILE(V2,count=N3)
   if N3 gt 0 then   OPENR,lun,V2,/get_lun,/delete & FREE_LUN ,lun

   WIDGET_CONTROL,/hourglass
   SPAWN,'ftp '+TRG,unit=U  &  printf,U,'quit'
   ON_IOERROR,goon	    &  readf,U,res
   goon:free_lun,U

   if N1 gt 0  then spawn, 'mv -f ~/.netrc_lampsav ~/.netrc' else SPAWN, 'rm ~/.netrc'

   res='.' & f=FINDFILE (V2,count=N2)
   IF N2 gt 0 then BEGIN res='ok'
      IF P1 eq 2 then BEGIN
   	 SPAWN,'cat  '+V2+' ; rm '+V2  ,res
      ENDIF
      IF P1 eq 3 then BEGIN
   	 CD,current=mee
   	 SPAWN,'cd '+p3+' ; cp lamp_mac/read_par.pro lamp_mac/read_par.loc'
   	 SPAWN,'cd '+p3+' ; cp START_LAMP.unix START_LAMP.loc'
   	 SPAWN,'cd '+p3+' ; cd .. ; zcat '+mee+'/'+v2+' | tar xf - '
   	 SPAWN,'cd '+p3+' ; mv lamp_mac/read_par.loc lamp_mac/read_par.pro'
   	 SPAWN,'cd '+p3+' ; mv START_LAMP.loc START_LAMP.unix'
	 SPAWN,'rm '+V2
      ENDIF
   ENDIF
ENDIF ELSE IF p1 eq 4 THEN BEGIN res=0
   SPAWN,'cd '+p3+' ; source MAKE_LAMP.unix',res
   SPAWN,'echo "" > lamp.upg'
ENDIF

mispriv:return,res
end
;------------------------------------------------------------------------------
;                                      DESKTOP
;------------------------------------------------------------------------------

pro desktop_event, event
;** *************
;**
common desk,whatdo,b11

    stat=0 & catch,stat
    if stat  ne 0  then begin catch,/cancel & print,string(7b)+!err_string & return & endif

    lodtx=[0]
    widget_control,bad_id=i ,event.id,get_uvalue=lodtx
    if n_elements(lodtx) ge 5 then begin

	widget_control,bad_id=i ,lodtx(5),/clear_events
	widget_control,bad_id=i ,lodtx(4),set_value=' '
	widget_control,/hourglass

	CASE lodtx(3) OF

	1:   desktop_lamp,lodtx

	2:   begin desktop_tuch,tbas,lbas
		if (tbas gt ' ') then begin
		   maj_desktop, lodtx , ' Loading TOUCH BASE ...',0
	   	   P_RESTORE,lbas+'touch_b.exe' ,cnt
	   	   if cnt gt 0 then begin
	   	   	desktop_lamp,lodtx
	   	   endif else $
		   maj_desktop, lodtx , ' Sorry, TOUCH BASE is not available',0
		endif else $
		   maj_desktop, lodtx , ' Sorry, TOUCH BASE is not available',0
	     end
	3:   begin whatdo = lodtx(3)
		   MANUAL,res
		   if res eq '' then $
		      maj_desktop,lodtx, ' Sorry, no HTML BROWSER found in local/bin',0
	     end

	4:   begin whatdo = lodtx(3)  &  widget_control,bad_id=i,event.top,/destroy
		   			 widget_control,/reset & end

	5:   if whatdo ne -5 then begin
		 desktop_tuch,tbas,lbas
		 if (tbas gt ' ') then begin
		   maj_desktop, lodtx , ' Loading TOUCH UPDATE ...',0
		   lamp,'just'
		   maj_desktop, lodtx , ' TOUCH UPDATE running...',0
		   maj_desktop, lodtx , ' TOUCH UPDATE running...',0
		   whatdo = lodtx(3)
		   touch_u,1,lodtx(4),lodtx(1),lodtx(5)
		endif
	     endif

	6:   desktop_lamp,lodtx

	7:   begin whatdo = lodtx(3)
		   P_ENVI
		   desktop_tuch,tbas,lbas,lsiz,lins
		   TOUCH_X,lins,tbas,1
	     end

	8:   CUSTOMIZ,1

	9:   BEGIN desktop_tuch,tbas,lbas,lsiz,lins,out & UPI,lodtx,out & END

	10:  if lodtx(6) lt 3 then begin
		   desktop_tuch,tbas,lbas
		   out='' & widget_control,bad_id=i,lodtx(7),get_value=out
		   out=strtrim(out(0),2)
		   if lodtx(6) eq 1 then begin
			widget_control,bad_id=i,lodtx(8),set_value=['','Downloading the News ...']
			res=ulamp(2, out ,lbas)
			if n_elements(res) eq 1 then begin
			   if res eq '?' then res=['','!! Problem with .netrc file ...'] else $
			   if res eq '.' then res=['','!! Can"t download the news ...']
			endif else desktop_puch,out
			widget_control,bad_id=i,lodtx(8),set_value=res
		   endif
		   if lodtx(6) eq 2 then begin
			res=ulamp(1, out ,lbas)
			if res eq 0 then begin
			   widget_control,bad_id=i,lodtx(8),set_value=['','Downloading ...']
			   res=ulamp(3, out ,lbas)
			   if res eq 'ok' then begin
				desktop_puch,out
			        widget_control,bad_id=i,lodtx(8),set_value=['','Making LAMP ...']
				res=ulamp(4, out ,lbas)
				widget_control,/reset
			   endif else begin
			        if res eq '?' then res=['','!! Problem with .netrc file ...'] else $
			        if res eq '.' then res=['','!! Can"t download the upgrade ...']
				widget_control,bad_id=i,lodtx(8),set_value=res
			   endelse
			endif else begin
			   if res eq -1 then txt='!! Bad Lamp-directory '+lbas
			   if res eq -2 then txt='!! Your are not allowed to modify the lamp-directory ...'
			   widget_control,bad_id=i,lodtx(8),set_value=['',txt]
			endelse
		   endif
	     endif else widget_control,bad_id=i,lodtx(9),/destroy

	11:  desktop_lamp,lodtx

	-87: LAMP_EVENT_PARSER,event
	-88: LAMP_EVENT_PARSER,event
	else:
	endcase
    endif
return
end

pro desktop_tuch,tbas,lbas,lsiz,lins,out,geor
;** ************
;**
@lamp.cbk
tbas=lamp_touch+lamp_dvd
lbas=lamp_dir  +lamp_dvd
lsiz=lamp_ziz
lins=lamp_ins
out =lamp_proxy
if n_elements(GEORGE) eq 1 then geor=GEORGE else geor=2
end
pro desktop_puch,out, geo=geo
;** ************
;**
@lamp.cbk
if n_elements(geo) ne 1 then lamp_proxy=out else GEORGE=geo
end

pro desktop_lamp,lodtx
;** ************
;**
common desk,whatdo,b11
		if lodtx(2) gt 0 then begin
		   desktop_tuch,tbas,lbas,lsiz,lins,out,geor
		   if (lodtx(3) eq 11) then begin
		     desktop_puch,geo=1
		     lodtx(3)=1
		   endif else begin
		     maj_desktop, lodtx , ' Loading Image Processing modules ...',90
		     desktop_tuch,tbas,lbas
	   	     SL_RESTSCAN,lbas+'scan.exe' ,cnt
		     if cnt gt 0  then loadct,1
		     i= xregistered( 'TOUCH')
		     if (i gt 0) then TOUCH_DONE,0,0
		   endelse
		endif
		whatdo =lodtx(3) & widget_control,bad_id=i,b11(0),/destroy
return
end

pro desktop_kill, id
;** ************
;**
return
end

pro maj_desktop, lodtx , text , pcent
;** ***********
;**
common desk,whatdo,b11

if !D.name ne 'TEK' then begin

	if (pcent eq 70) then begin

	   desktop_tuch,tbas,lbas,lamp_siz
	   pixmap=0 & LOGO,pixmap
	   !order=1 & wset,lodtx(2)
	   if n_elements(pixmap) eq 1 then $
	   if lamp_siz  ge 800 then device,copy=[0,0,512,256,    0  ,  0  ,pixmap] $
		else device,copy=[0,0,300,150,(300-300)/2,(200-150)/2,pixmap]
	   !order=0
	endif

	widget_control,bad_id=ii,lodtx(1),set_value=text

	if ii ne 0 then exit

	wset,lodtx(0)
	if pcent le 100 then plots,[0,2*pcent-1],[9,9],color=120,/device,thick=5

	if pcent eq 100 then begin
	if b11(1) gt 0  then begin
	  whatdo=0
	  print,string(7b)
	  wset,lodtx(0) & erase
	  plots,indgen(200),sin(findgen(200)/10)*4+9,color=120,/device,thick=5
	  widget_control,bad_id=i ,b11(1)  ,sensitive=1
	  widget_control,bad_id=i ,lodtx(5),/clear_events
	  XMANAGER, 'LAMP_DESKTOP',lodtx(5),event_handler='DESKTOP_EVENT',CLEANUP='DESKTOP_KILL'
	  lodtx(0)=-whatdo


	  IF lodtx(0) EQ -1 THEN LAMP 		ELSE  $
	  IF lodtx(0) EQ -2 THEN LAMP,'touch'	ELSE  $
	  IF lodtx(0) EQ -6 THEN LAMP,'tripx'
	  bid=sys_dep      ('EXIT')
	endif else pcent=101
	endif

	if pcent eq 101 then begin
	   desktop_lamp,lodtx
	   lodtx(0)=-1
	   LAMP
	endif

endif else begin
	print,text & lodtx(0)=-1
endelse
return
end

pro desktop, lodtx ,menu=menu ,nomenu=nomenu
;** *******
;**
;**	 First window when LAMP is started.

common desk,whatdo,b11

if n_elements(lodtx) ne 6 then lodtx=lonarr(6)
if !D.name ne 'TEK' then begin

ii=xregistered('LAMP_DESKTOP')
if (ii le 0) or (lodtx(5) le 0) then begin

	P_ENVI
	P_MUS ,'mus_start'

	ii=sys_dep('PSEUDO')

	k=0
	p_set_font,k ,lamp_font
	ft_biggest  =lamp_font(1,k)
	ft_b_bigger =lamp_font(3,k)
	ft_normal   =lamp_font(4,k)
	ft_b_normal =lamp_font(5,k)
	ft_smaller  =lamp_font(6,k)
				      sizex=512   &   sizey=256
	desktop_tuch,tbas,lbas, lamp_siz
	if lamp_siz lt 800 then begin sizex=300   &   sizey=230 & endif

	b1	=widget_base  (title='Lamp Desktop',/column,resource_name='lamp',$
			     			    kill_notify='desktop_kill')
	row1=0L
	if keyword_set(menu) then begin
	row1	=widget_base  (b1   ,/row)
	but1	=widget_button(row1 ,value=' LAMP '		,font=ft_biggest)
	but6	=widget_button(row1 ,value=' GEORGE '		,font=ft_biggest)
	but2	=widget_button(row1 ,value=' TOUCH L. '		,font=ft_biggest)
;	but5	=widget_button(row1 ,value= 'INST'		,font=ft_biggest,menu=2)
	but5_4	=widget_button(row1 ,value= 'Customize'	,font=ft_b_bigger)
	but3	=widget_button(row1 ,value=' MANUAL '		,font=ft_b_bigger)
	but4	=widget_button(row1 ,value=' EXIT'		,font=ft_b_bigger)

;	but5_1  =widget_button(but5 ,value=' 3 AXES '		,font=ft_b_bigger)
;	but5_4  =widget_button(but5 ,value=' CUSTO Mize   '	,font=ft_b_bigger)
;	but5_3  =widget_button(but5 ,value=' TOUCH Manage '	,font=ft_b_bigger)
;	but5_2  =widget_button(but5 ,value=' TOUCH Update '	,font=ft_b_bigger)

	bid	=widget_label (b1   ,value=' '			,font=ft_biggest)
	endif
	
	row2	=widget_base  (b1   ,/row)

	lodtx(0)=widget_draw  (row2 ,xsize=200  ,ysize=20   ,retain=2,colors=-30)
	lodtx(1)=widget_label (row2 ,xsize=sizex-200,value=' '	,font=ft_b_normal)

	lodtx(4)=widget_label (b1   ,xsize=sizex    ,value=' '	,font=ft_b_normal)

	icon    =widget_draw  (b1   ,xsize=sizex,ysize=sizey,retain=2,/button_events)

	Show_Version,b1,version,bil

	but9	=widget_button(bil  ,value='NEWs !!!'		 ,font=ft_smaller)

	bid	=widget_label (b1   ,value='Didier RICHARD @ill.fr  -  Don KEARLEY @iri.nl  -  '+$
					   'Michel FERRAND @cea.fr' ,font=ft_smaller)
	bil	=widget_base  (b1   ,/row)
	bid	=widget_label (bil  ,value='ILL:'    			 ,font=ft_b_bigger)
	bid	=widget_label (bil  ,value='Institut-Laue-Langevin  Grenoble France'    $
							  		 ,font=ft_normal)
	bid	=widget_label (bil  ,value='(anonymous@ftp.ill.fr  /pub/cs/lamp...)'   $
							 		 ,font=ft_smaller)

   	bid=sys_dep('DYNLAB',b1,1)
	widget_control,bad_id=i   ,b1  ,/realize
	b11=[b1,row1]
	if row1 gt 0 then widget_control,bad_id=i   ,row1,sensitive=0
	widget_control,bad_id=i   ,lodtx(0),get_value =jj & lodtx(0)=jj & loadct,27
	widget_control,bad_id=i   ,icon    ,get_value =jj & lodtx(2)=jj
	bid=sys_dep('AFTER')
	if  sys_dep('MACHINE') ne 'unix' then $
	widget_control,bad_id=i,but9,sensitive=0
	lodtx(5)=b1
	lodtx(3)=0  &  widget_control,bad_id=i,icon  ,set_uvalue=lodtx
	
	if keyword_set(menu) then begin
	lodtx(3)=1  &  widget_control,bad_id=i,but1  ,set_uvalue=lodtx
	lodtx(3)=2  &  widget_control,bad_id=i,but2  ,set_uvalue=lodtx
	lodtx(3)=3  &  widget_control,bad_id=i,but3  ,set_uvalue=lodtx
	lodtx(3)=4  &  widget_control,bad_id=i,but4  ,set_uvalue=lodtx
;	lodtx(3)=5  &  widget_control,bad_id=i,but5_2,set_uvalue=lodtx
;	lodtx(3)=6  &  widget_control,bad_id=i,but5_1,set_uvalue=lodtx
;	lodtx(3)=7  &  widget_control,bad_id=i,but5_3,set_uvalue=lodtx
	lodtx(3)=8  &  widget_control,bad_id=i,but5_4,set_uvalue=lodtx
	lodtx(3)=11 &  widget_control,bad_id=i,but6  ,set_uvalue=lodtx
	endif
	lodtx(3)=9  &  widget_control,bad_id=i,but9  ,set_uvalue=lodtx
	lodtx(3)=1

	widget_control,/hourglass
endif
endif
return
end

;****************************** B.A.R.N.S interfaces **************************************
;****************************** B.A.R.N.S interfaces **************************************
;****************************** B.A.R.N.S interfaces **************************************
pro BARNS_R ,remove=rem
;** *******
@lamp.cbk
@dons.cbk
common  for_users
	fil=findfile('lamp.ses',count=true)
	if  true gt 0 then begin
			P_RESTORE, 'lamp.ses', cnt
			AFTER_RESTORE
			if keyword_set(rem) then bid=sys_dep('DELET','lamp.ses')
			print,'Previous Session is restored ....'
	endif
end
function BARNS_I	,val
;** **** *******
;**
common c_barns  ,wk_read ,wk_plot ,wk_year ,wk_raw ,wk_rot ,wk_repi ,wk_repc ,wk_reps $
		,wk_fu   ,wk_fil  ,wk_reg  ,wk_log ,wk_wr  ,wk_xr   ,wk_yr   ,wk_kef  $
		,wk_bx   ,wk_by   ,wk_bw   ,wk_fx  ,wk_fy  ,wk_fz   ,wk_px   ,wk_py   $
		,wk_pz   ,wk_save ,wk_fmt  ,wk_ins ,wk_cyc

eff=0
txt=strlowcase(val)
k  =strpos(txt,',	"')
if k gt 0 then begin
	if n_elements(wk_raw) eq 0 then begin
			 wk_raw =0		 & wk_fil ='Gif'	& wk_save= 1
			 wk_repi=''		 & wk_repc=''		& wk_plot='1'
			 wk_reps=''	 	 & wk_fu  =',/below'	& wk_fmt = 3
			 wk_reg =',regular=0'	 & wk_rot ='30'
			 wk_log =',log=0'        & wk_wr  = 0.
			 wk_xr	= [0.,0.]	 & wk_yr  = [0.,0.]	& wk_year=''
			 wk_bx  =  0		 & wk_by  =  0		& wk_bw  =0
			 wk_fx  =  0		 & wk_fy  =  0		& wk_fz  =0
			 wk_px  =  0		 & wk_py  =  0		& wk_pz  =0
			 wk_kef =  0		 & wk_ins = ''		& wk_cyc =''
			 endif
	eff=1
	txt=strmid(txt,0,k)	& cmd=strmid(val,k+2,100)
	ln =strlen(cmd)		& cmv=strmid(cmd,1,ln-2)

	CASE txt of
	"set_inst":if cmd ne wk_ins then begin XICUTER,'RDSET,inst='+cmd
			 wk_ins=cmd
			 cmv=strlowcase(cmv) & iii=EXECUTE('myinit_'+cmv)
			 hhh='' & iii=execute('myhelp_'+cmv+ ',hhh') & nn=n_elements(hhh)
			 if nn gt 1 then begin on_ioerror,misop      & u =0
					 openw ,u,'help_'+cmv+'.htm',/get_lun
					 printf,u,'<HTML><PRE>'
					 for i=0,nn-1 do printf,u,hhh(i)
					 printf,u,'</PRE></HTML>'
					 misop: if u gt 0 then free_lun,u & endif
	           endif
	"set_base":if wk_ins+wk_year+cmd ne wk_cyc then begin
			 wk_cyc =wk_ins +wk_year+cmd
			 IF strpos(cmd,'Cycle -') lt 0 then $
			 XICUTER	,'RDSET,base='+cmd else $
			 XICUTER	,'RDSET,base="C_Year '+wk_year+'",cycle='+strmid(wk_year,2,2)+strmid(cmv,7,1)
	           endif
	"set_year":	 wk_year	=	cmv
	;**********
	"do_filt" :begin on_ioerror,fsx_err  &  rdtmp=[0.,0.]	& reads	 , cmv+' 0 0',rdtmp
			 RDFILTER, xrange=rdtmp			& fsx_err:
			 if wk_fx eq 0 then RDFILTER,xrange=[0,0]
			 if wk_fy eq 0 then RDFILTER,yrange=[0,0]
			 if wk_fz eq 0 then RDFILTER,zrange=[0,0]
			 if wk_px eq 0 then RDFILTER,xproj = 0
			 if wk_py eq 0 then RDFILTER,yproj = 0
			 if wk_pz eq 0 then RDFILTER,zproj = 0
			 wk_kef=wk_fx + wk_fy + wk_fz + wk_px + wk_py + wk_pz
			 wk_fx =0 & wk_fy =0 & wk_fz =0 & wk_px =0 & wk_py =0 & wk_pz =0
			 end
	"r_scly"  :begin on_ioerror,fsy_err  &  rdtmp=[0.,0.]	& reads	 , cmv+' 0 0',rdtmp
			 RDFILTER, yrange=rdtmp			& fsy_err: & end
	"r_sclz"  :begin on_ioerror,fsz_err  &  rdtmp=[0.,0.]	& reads	 , cmv+' 0 0',rdtmp
			 RDFILTER, zrange=rdtmp			& fsz_err: & end
	"r_chkx"  :	 wk_fx = 1
	"r_chky"  :	 wk_fy = 1
	"r_chkz"  :	 wk_fz = 1
	"r_prjx"  :begin RDFILTER,/xproj & wk_px = 1 & end
	"r_prjy"  :begin RDFILTER,/yproj & wk_py = 1 & end
	"r_prjz"  :begin RDFILTER,/zproj & wk_pz = 1 & end
	;**********
	"do_read" :IF cmv gt " " then begin
			 IF wk_raw then RDSET,/raw else RDSET,/default
			 ffl=strpos(cmv,':')
			 if (wk_kef ge 1) or (ffl ge 1) then begin
						   if wk_raw then RDFILTER,monimod=2 $
			 				     else RDFILTER,monimod=1
			 		RDFILTER,selection=cmv,wksp=fix(wk_read)
			 endif else	GMY_run ,[0,0,0,0],cmv,     fix(wk_read)
			 wk_raw		=	0	 & wk_plot=wk_read  & ENDIF
	"r_raw"   :	 wk_raw		=	1
	"set_wks" :	 wk_read	=	cmv
	;**********
	"do_save" :	 WRITE_LAMP	,	cmv ,w=wk_save ,fmt=wk_fmt
	"s_wks"   :	 wk_save	=   fix(cmv)
	"s_fmt"   :	 wk_fmt		=   fix(cmv)
	;**********
	"do_plot" :begin wk_plot	=	cmv
			 if wk_bx eq 0 then wk_xr(*)=0. & if wk_by eq 0 then wk_yr(*)=0.
			 if wk_bw eq 0 then wk_wr   =0.
			 range=strcompress(',xrange=['+string(wk_xr(0))+','+string(wk_xr(1))+'],'+$
			 		    'yrange=['+string(wk_yr(0))+','+string(wk_yr(1))+'],'+$
			 		    'zlim='   +string(wk_wr),/remove_all)
			 cmd = 'SEEM, rot='+wk_rot +wk_reg +wk_fu +wk_log +range
			 XICUTER	,	cmd
			 if wk_fil eq 'Wrl'  then begin wk_reps=',/surface' & wk_repi='' & wk_repc=''
						  fil=',/vrml'  & endif else $
			 if wk_fil eq 'Ps'   then fil=',/pscript' else $
			 if wk_fil eq 'Java' then fil=',/htm'     else fil=''
			 cmd = 'SEE, w=' +wk_plot +wk_repi +wk_repc +wk_reps +fil
			 XICUTER	,	cmd
			 wk_repi	=	''		& wk_repc = ''
			 wk_reps	=	''		& wk_log  = ',log=0'
			 wk_reg		=	',regular=0'	& wk_wr   = 0.
			 wk_xr(*)	=	 0.		& wk_yr(*)= 0.
			 wk_bx		= 	 0		& wk_by   = 0	   & wk_bw = 0
		   end
	"d_fil"   :	 wk_fil		=	cmv
	"d_repi"  :	 wk_repi	=	',/image'
	"d_repc"  :	 wk_repc	=	',/contour'
	"d_reps"  :	 wk_reps	=	',/surface'
	"d_repr"  :	 wk_reg		=	',regular=1'
	"d_angl"  :begin on_ioerror,rot_err
			 wk_rot		=   	string(fix(cmv)) & rot_err: & end
	"d_befu"  :	 wk_fu		=	cmv
	"d_sclx"  :begin on_ioerror,chx_err
			 reads		,	cmv+' 0 0',wk_xr & chx_err: & end
	"d_scly"  :begin on_ioerror,chy_err
			 reads		,	cmv+' 0 0',wk_yr & chy_err: & end
	"d_sclw"  :begin on_ioerror,chw_err
			 reads		,	cmv+' 0 0',wk_wr & chw_err: & end
	"d_chkl"  :	 wk_log		=	',log=1'
	"d_chkx"  :	 wk_bx		=	1
	"d_chky"  :	 wk_by		=	1
	"d_chkw"  :	 wk_bw		=	1
	;**********
	"do_cmd"  :	 XICUTER	,	cmv
	"submit"  :CASE  cmv of
		   "The Journal": DID_WRITE_JOURNAL ,/htm
		   "Parameters" : DID_PARAM_HTM     ,wk_plot
		   "The Manual" :
		   else:
		   ENDCASE
	;**********
	"do_color":	 setcol		,   fix(cmv)
	;**********
	 else     :	 eff=0
	ENDCASE
endif
return,eff
end

PRO LAMP_B
;** ******
@lamp.cbk

if  b_labins(3) le 0 then begin
 if (strpos(strlowcase(sys_dep('GETENV','LAMP_WIND')),'nws') ge 0) or (!D.Name eq 'Z')  then begin
		  BARNS_R ,/remove & b_labins(3) = 2 & SET_PLOT,"Z"
 endif else begin BARNS_R	   & b_labins(3) = 1 & endelse
 P_DON_INIT_VAR
 P_DID_SETVAR
 P_DATA_IDOL
 RDFILTER
 GEORGEO,/nowin
 lamp_focus =-1
endif

if b_labins(3) eq 1 then begin
 print,' **********************'
 print,' * Remember INTERNALS *'
 print,' **********************'
 print,'Available Bases       : ',lamp_ali(*)+','
 print,''
 print,'To set your instrument : RDSET   ,inst="D20"'
 print,'To set your base       : RDSET   ,base="C_Year 1996" ,cycle=964'
 print,'To use tektro,Win,X,Mac: SET_PLOT,"TEK" or "WIN" or "X" or "MAC"'
 print,'Actual display is '+!D.Name+' , Instrument is '+inst_value+' , Base is '+path_for_online
 print,''
endif

CATCH,stat & if stat ne 0 then print,!err_string
text=''
	while (1) do begin
		ON_IOERROR,NO_MATTER
		READ,'Lamp> ',text    &  text=strtrim(text,2)
		NO_MATTER: IF text ne '' then begin ;if b_labins(3) eq 2  then print,'Barns-sent'
						     if not barns_i(text) then XICUTER,text
						    ;if b_labins(3) eq 2  then print,'Barns-done'
						     ENDIF
	endwhile
return
end

PRO RUNTIME
    pth=sys_dep('GETENV','LAMP_DIR')
    VV=strtrim(string(sys_dep('VERSION')),2)
    VV=strmid (VV,0,1)+strmid (VV,2,1)
    CD,current=mee
    dv=sys_dep('DIVIDER')
    if pth ne '' then begin if strlowcase(!dir) eq strlowcase(pth) then pth=pth+dv+'..'
    			    catch,stat & if stat eq 0 then CD,pth
			    cd,current=pth
                            catch,/cancel &  endif
    fl=findfile('update'+VV+'a.rt' ,count=cnt )
    if cnt eq 0 then begin  pth=!dir+dv+'..'+dv+'..'
			    fl=findfile(pth +dv+'update'+VV+'a.rt' ,count=cnt)
			    if cnt gt 0 then   CD, pth
			    cd,current=pth
    endif
    if cnt gt 0 then        bid=sys_dep('ADDPATH',pth)

;   RESTORE AVAILABLE COMPILED FILES.
;   --------------------------------
    NW=strpos(strlowcase(sys_dep('GETENV','LAMP_WIND')),'nw')
    if NW lt 0 then begin
       bload=widget_base (title='L.a.m.p.')
       widget_control,widget_label(bload,value=' Loading ... '),/realize
    endif
    fl=findfile('*'+VV+'a.rt' ,count=cnt )
    fs=findfile('*'+VV+'.sav' ,count=cnts)
    if cnts gt 0 then if cnt gt 0 then fl=[fl,fs] else fl=fs & cnt=cnt+cnts
    if cnt  gt 0 then begin
			CD,current=mpth
			ln=strpos(strupcase(fl(0)),strupcase(mpth))
			if ln ge 0 then ln=ln+strlen(mpth)
			for i=0,cnt-1 do begin
				if (strpos(strupcase(fl(i)),'LAMP'+VV) lt 0) then $
				if (NW lt 0) or ((strpos(strupcase(fl(i)),'SCAN'+VV) lt 0)  and  $
			                         (strpos(strupcase(fl(i)),'LIVE'+VV) lt 0)) then begin
			                          P_RESTORE,strmid(fl(i) ,ln,35) ,rflg
			                          PRINT    ,strmid(fl(i) ,ln,35) +' plug-in loaded ...'
			        endif
			endfor
    endif
    CD,mee & if NW lt 0 then widget_control,bload,/destroy
    
;   RUN SPECIFIC STARTUP.
;   --------------------
    P_DO_THAT
;   NO WINDOW OPTION.
;   ----------------
    if NW ge 0 then begin
       SET_PLOT,'TEK' & LAMP,'just' & LAMP_B
       endif    else    LAMP
    return
    end
PRO MAIN
    RUNTIME
    return
    end

PRO LAMP ,just ,NW=nw ,GEO=geo ,SMALL=small ,MEDIUM=medium ,LARGE=large ,WIDE=wide ,GEOLAMP=geolamp ,LAMPGEO=lampgeo ,ONLY=lamp ,FULL=full, MINI=mini
;** ****
@lamp.cbk
    !quiet=1
    if (sys_dep ('VERSION') ge 5.1) and (not keyword_set(mini)) then begin rout=['']
	ii=execute('rout=routine_info(/functions)') & dx=where(rout eq 'RLAMP')
	if dx(0) lt 0 then begin catch,stat
	 if stat eq 0 then RESOLVE_ROUTINE,['dons','dids','bens','scan'] else GEORGE=0 & endif
    endif    else  GEORGE=0
    if sys_dep ('MATLAB')        then GEORGE  =0
    if n_elements (GEORGE)  eq 0 then GEORGE  =2
    if keyword_set(LAMP)         then GEORGE  =0
    if keyword_set(GEO)          then GEORGE  =1
    if keyword_set(LAMPGEO)      then GEORGE  =2
    if keyword_set(GEOLAMP)      then GEORGE  =2
    if keyword_set(FULL)         then GEORGE  =3
    if  sys_dep   ('STUDENT')    then lamp_ziz=600
    if keyword_set(SMALL)        then lamp_ziz=480
    if keyword_set(MEDIUM)       then lamp_ziz=600
    if keyword_set(LARGE)        then lamp_ziz=800
    if keyword_set(WIDE)         then lamp_ziz=1024
    if (!D.flags and 65536) eq 0 then if (!D.Name ne 'Z') then set_plot,'TEK'
    if keyword_set(NW)           then LAMP_,   'just'
    if keyword_set(NW)           then LAMP_B    else   LAMP_,just
    return
    end
;;; ***************************************************************************
;;; ***			           SHARED FUNCTIONS			    ***
;;; ***************************************************************************

function NUMtSTR,x,y
;;;;; This function converts any number to a string, with `y' digits after
;;;;; the dot. `y' is always less than 7.
   temp=size(y)
   if ((temp(0) eq 0) and (temp(1) eq 1)) then y=4 $
   else y=max([0,min([y,6])])
   temp=size(x)
   res='0'
   if  (temp(0) eq 0) then $
   if ((temp(1) ge 2) and (temp(1) le 5)) then begin xx=long(x)
      
      if ((temp(1) eq 4) or (temp(1) eq 5)) then begin
	 temp=abs(round(10^y*(x-xx)))
	 xx  =xx+ float(temp)/10^y
	 xl  =long(xx)
	 temp=abs(round(10^y*(xx-xl)))
	 res =string(xl)
	 str =strcompress(('000000'+string(temp)),/remove_all)
	 leng=strlen(str)
	 str =strmid(str,leng-y,y)
	 if ((temp ge 1) and (str ne '')) then res=res+'.'+str
      endif else res=string(xx)
   endif
   return,strcompress(res,/remove_all)
end

function BEN_UNDEFINED,x
;;;;; Return ` if the variable `x' is undefined.
   temp=size(x)
   if (temp(0) ne 0) then return,0
   return,(temp(1) eq 0)
end

function BEN_READTEXT,widgetID
;;;;; This function reads the value of the widget_text `widgetID',
;;;;; and returns a float equal to this value.
   widget_control,bad_ID=bad,get_value=temp,widgetID
   if (bad ne 0) then return,0
   x=temp(0)
   if (strmid(x,0,1) eq '-') then begin
      sign=-1
      x=strmid(x,1,strlen(x)-1)
   end else sign=1
   return,(sign*float('0' + x))
end

function BEN_SELECTWID,base,i,n,labelID,wkn,comp
@lamp.cbk
;;;;; This function creates three widget_buttons, for workspace selection.
;;;;; The message ('Load', or 'Write') is determine by the parameter `n'.
;;;;; The user value of this widgets are 401, and (403+n). The '<-' and '->'
;;;;; buttons should call the BEN_CHANGE_WORKSPACE procedure, that will
;;;;; handle everything. Additionnal elements can be put in the user value
;;;;; of the center button by passing them in the `comp' parameter.
;;;;; The value returned by this function are the three buttons ID number.
   decr=widget_button(base,value="<-",font=ft_b_normal)
   load=widget_button(base,uvalue=[-88,(403+n),i,wkn,labelID,comp], $
      font=ft_b_normal)
   incr=widget_button(base,value="->",font=ft_b_normal)
   case n of
      0:    title="Load W"
      1:    title="Write to W"
      else: title="W"
   end
   if (wkn eq 0) then begin
      title=(' ' + title + ' ')
      widget_control,sensitive=0,load
   end else if (wkn ge 10) then title=(title + NUMtSTR(wkn,0)) $
   else title=(title + ' ' + NUMtSTR(wkn,0))
   widget_control,set_value=title,load
   widget_control,sensitive=(wkn gt 1),decr
   widget_control,sensitive=(wkn lt 20),incr
   widget_control,set_uvalue=[-88,401,i,0,load,decr,incr,n],decr
   widget_control,set_uvalue=[-88,401,i,1,load,decr,incr,n],incr
   return,[base,decr,load,incr]
end

function BEN_COMMANDS,base,i,masq,comp
@lamp.cbk
;;;;; This function creates the 'Done', workspace selection widgets, and
;;;;; 'help' buttons that are present at the top of the function windows.
;;;;; It also creates a widget_label. The `mask' parameter is an array
;;;;; used for preventing the function from creating the 'help' button,
;;;;; or the label. Those widget are created if the corresponding value
;;;;; (mask(0): help, mask(1): label) are set to 0. The default value is
;;;;; mask=[0,0]. The workspace selection widgets are created by calling
;;;;; the BEN_SELECTWID function.
;;;;; The returned value is an array of the widgets ID number.
   if BEN_UNDEFINED(masq) then masq=[0,0]
   if BEN_UNDEFINED(comp) then comp=[0]
   top=widget_base(base,/row)
   done=widget_button(top,value=" Done ",uvalue=[-88,400,i], $
      font=ft_b_normal)
   temp=widget_base(top,/row,/frame)
   if masq(0) then help=-1 $
   else help=widget_button(top,value='?',uvalue=[-88,402,1])
   if masq(1) then labelID=-1 $
   else labelID=widget_label(base,value="   You must load W ",font=ft_b_normal)
   if BEN_UNDEFINED(one) then wkn=0 else wkn=abs(one)
   slct=BEN_SELECTWID(temp,i,0,labelID,wkn,comp)
   return,[done,0,slct(0),slct(1),slct(2),slct(3),help,labelID]
end

pro BEN_CHANGE_WORKSPACE,uv
;;;;; This procedure should be called to handle the workspace selection
;;;;; widgets. Only the user value must be passed. Its form is:
;;;;; uv=[-88,4xx,x,{add/sub},{btn "Wxx"},{btn "<-"},{btn "->"},x]
;;;;; The currently selected workspace number is stored into the element
;;;;; number 3 of the center button.
   widget_control,get_uvalue=x,uv(4)
   if uv(3) then n=x(3)+1 $
   else n=x(3)-1
   widget_control,sensitive=(n ne 1),uv(5)
   widget_control,sensitive=(n ne 20),uv(6)
   x(3)=n
   widget_control,/sensitive,uv(4)
   case uv(7) of
      0:    str="Load W"
      1:    str="Write to W"
      else: str="W"
   end
   if ((n ge 1) and (n le 9)) then $
      widget_control,set_value=(str + " " + NUMtSTR(n,0)),set_uvalue=x,uv(4) $
   else if ((n ge 10) and (n le 20)) then $
      widget_control,set_value=(str + NUMtSTR(n,0)), set_uvalue=x,uv(4)
end

function BEN_WK_SIZE,x
;;;;; This function returns the size of the workspace Wx.
   common c_lamp_w,w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11, $
      w12,w13,w14,w15,w16,w17,w18,w19,w20
   wksize=0
   temp=execute("wksize=size(W" + NUMtSTR(x,0) + ")")
   return,wksize
end

pro BEN_READ_WK,x,work,wkx,wky,wkn,wkp,datpar
@lamp.cbk
;;;;; This procedure reads the LAMP workspace Wx, and all the linked data
;;;;; (eg Xx, Yx, PARx ...), and writes them in the parameter variables.
datpar=['','','']
   if ((x lt 0) or (x gt 20)) then return
   temp=execute("work=w"    + NUMtSTR(x,0))
   temp=execute("wkx=x"     + NUMtSTR(x,0))
   temp=execute("wky=y"     + NUMtSTR(x,0))
   temp=execute("wkn=n"     + NUMtSTR(x,0))
   temp=execute("wkp=p"     + NUMtSTR(x,0))
   temp=execute("datpar=par"+ NUMtSTR(x,0))
   datpar=[w_numor(x),string(x),his(x)]
end

pro BEN_WRITE_WK,x,work,wkx,wky,wkn,wkp,datpar
@lamp.cbk
;;;;; This procedure writes the parameters into LAMP variables,
;;;;; creating or replacing the workspace Wx and accompaying data.
   temp=execute("w" + NUMtSTR(x,0) + "=work")
   if BEN_UNDEFINED(wkx) then return
   temp=execute("x" + NUMtSTR(x,0) + "=wkx")
   if BEN_UNDEFINED(wky) then return
   temp=execute("y" + NUMtSTR(x,0) + "=wky")
   if BEN_UNDEFINED(wkn) then return
   temp=execute("n" + NUMtSTR(x,0) + "=wkn")
   if BEN_UNDEFINED(wkp) then return
   temp=execute("p" + NUMtSTR(x,0) + "=wkp")
   if BEN_UNDEFINED(datpar) then return
;  temp=execute("par" + NUMtSTR(x,0) + "=datpar")
   w_numor(x)=datpar(0)
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; DESKTOP EVENTS
;;; -+-+-+-+-+-+-+

function desk_name,i,test,string
;;;;; If (i lt 0), this function inits the commons, and returns the number
;;;;; of display function that it 'knows'. If (i ge 0), then this function
;;;;; returns, depending on the value of `test', the function `i' name, its
;;;;; event handler name...
   common c_ben,winList,maxWin,singleRun,topBase,regNames,winNames,winNum
   common ben_data,wk,benw,benx,beny,benn,benp,benpar
   if (i lt 0) then begin
      regNames=["desk","int","df","rgp"]
      winNames=["LAMP Desktop","Radial Integration ","Scroll Spectra", $
	 "Mask & Group"]
      maxWin=3
      temp=size(winNames)
      winNum=temp(1)
      winList=intarr(winNum,maxWin)
      singleRun=intarr(winNum)
      wk=0 & benw=0 & benx=0 & beny=0 & benn=0 & benp=0 & benpar=0
      return,winNum-1
   end
   if (i ge winNum) then return,"Unknown"
   case test of
      0:    return,("ben_" + regNames(i))
      1:    return,winNames(i)
      2:    return,(regNames(i) + "_event")
      3:    return,("ben_" + regNames(i) + "_create")
      4:    return,(regNames(i) + "_testModule('areYouHere')")
      else: return,regNames(i)
   end
end

function desk_winNum,str
;;; Given the ID string of a module (e.g. "df", "int"),
;;; returns the module number.
   common c_ben,winList,maxWin,singleRun,topBase,regNames
   temp=where(regNames eq str,count)
   if (count eq 0) then return,0 $
   else return,temp(0)
end

function desk_ismodule,x
;;;;; Calls the "testModule" function of the specified module, in order
;;;;; to check if the module really exists. The value returned by this
;;;;; function determines whether the display function `i' can only be
;;;;; run once, or not. Those values are stored in an array, for use
;;;;; by the desk_event procedure.
   common c_ben,winList,maxWin,singleRun
   on_error,3
   status=0
   catch,status
   if (status ne 0) then res=0
   test=0
   res=execute("test=" + desk_name(x,4))
   if (res eq 0) then print,("The '" + desk_name(x,1) + $
      "' function could not be found." + string(7b))
   singleRun(x)=test
   return,res
end

function desk_newWin,x
;;;;; This function `x' returns a number to open a new module `X'. It does
;;;;; NOT check if the function can be run several times or not.
;;;;; If the function `x' is not already running, the result is always 0.
   common c_ben,winList,maxWin
   i=xregistered(desk_name(x,0))
   if (i eq 0) then return,0
   for j=0,maxWin-1 do begin
      if (winList(x,j) eq 0) then return,j
      widget_control,bad_ID=bad,winList(x,j)
      if (bad ne 0) then return,j
   end
   return,maxWin
end

function desk_loadRequest,module,wkn,w,x,y,n,p,par
;;; This function is used by a module, to have another module
;;; load the data {w x y n p par} (wkn is the workspace number if needed).
;;; The function checks how many wanted modules are already opened;
;;; if all available modules (maxWin) are opened, the data are loaded
;;; in the first module.
   common ben_data,wk,benw,benx,beny,benn,benp,benpar
   common c_ben,winList,maxWin,singleRun,topBase
   success=1
   modNum=desk_winNum(module)
   m=desk_newWin(modNum)
   if ((m ge maxWin) or (singleRun(modNum) and (m gt 0))) then begin
      widget_control,bad_ID=bad,get_uvalue=vars,winList(modNum,0)
      if (bad ne 0) then return,0
      res=execute("success=" + module + "_loadRequest(vars,wkn,w,x,y,n,p,par)")
   end else begin
      wk=wkn & benw=w & benx=x & beny=y & benn=n & benp=p & benpar=par
      wind=0
      res=execute(desk_name(modNum,3) + ",topBase,modNum,m,wind,1")
      winList(modNum,m)=wind
   end
   if res then return,success
   return,-1
end

pro desk_event,ev,uv
;;;;; This procedure is called by the LAMP desktop display function buttons.
;;;;; It checks if the wanted function (uv(1)-400) is already running,
;;;;; via the desk_newWin function, and runs a new one, or unmap the running
;;;;; one, depending if it can be opened several times, and if the maximum
;;;;; windows are already opened.
   common c_ben,winList,maxWin,singleRun,topBase
   x=uv(1)-400
   if uv(2) eq -1 then WDIAG         else  $
   if uv(2) eq -2 then TOMOGRAPHY    else  $
   if (x eq 0)    then print,"HELP WANTED" $
   else begin
      m=desk_newWin(x)
      if ((m ge maxWin) or (singleRun(x) and (m gt 0))) $
      then widget_control,bad_ID=bad,/map,winList(x,0) $
      else begin
	 wind=0
	 temp=execute(desk_name(x,3) + ",topBase,x,m,wind,0")
	 winList(x,m)=wind
      end
   end
end

pro P_BEN_EVENT,ev,uv
;;;;; Executes a "xxx_event" procedure, where xxx is a function code.
   temp=execute(desk_name(uv(2)>0,2) + ",ev,uv")
end

pro P_BEN_CREATE,base,only
;;;;; Creation of the widget_buttons that call the display function.
;;;;; The procedure checks the presence of a function by calling the
;;;;; desk_ismodule function for every function. If a function appears
;;;;; to be absent, no button is created for it.
@lamp.cbk
   common c_ben,winList,maxWin,singleRun,topBase
   topBase=base
   if (not only) then begin
      desk=widget_base(base ,/column)
      header1=widget_base(desk,/row)
      header2=widget_base(desk,/row)
      title1=widget_label(header1,value=' DISPLAY',font=ft_biggest)
      title2=widget_label(header2,value=' FUNCTIONS',font=ft_biggest)
      help=widget_button(header1,value='?',uvalue=[-88,589,0])
   endif else desk=base
   btns=desk_name(-1)
   for i=1,btns do if desk_ismodule(i) then begin
      libel=desk_name(i,1)
      if strpos(libel,"Radial") ge 0 then begin
                 btn=widget_button(desk,value=libel,menu=2)
                 bid=widget_button(btn ,value="Using Sectors (up to [128,128] data)",uvalue=[-88,(400+i),0])
                 bid=widget_button(btn ,value="Unrolling Image (large data)",uvalue=[-88,(400+i),-1]) ;See WDIAG
                 bid=widget_button(btn ,value="Tomography",uvalue=[-88,(400+i),-2]) ;See TOMOGRAPHY
      endif else btn=widget_button(desk,value=libel,uvalue=[-88,(400+i),0])
      endif
end

;;; ***************************************************************************
;;; ***				  SCROLL SPECTRA			    ***
;;; ***************************************************************************


pro df_event,ev,uv
   widget_control,get_uvalue=varAccess,ev.top
   case uv(1) of
      400:  begin wait,.05 & widget_control,/destroy,ev.top & end
      401:  BEN_CHANGE_WORKSPACE,uv
      402:  df_help,ev.top
      403:  df_loadWorkspace,varAccess,uv(3),uv(4)
      406:  df_change_scale,varAccess,uv(3)
      407:  df_mini_event,varAccess,ev
      408:  df_slider_event,varAccess,ev.value
      409:  df_animate,varAccess,uv(3),ev.top
      410:  df_change_numb,varAccess,ev.value
      412:  df_psfile,varAccess,ev.top,uv(2)
      413:  df_select_sym,varAccess,uv(3),uv(4)
      414:  df_dialog_event,varAccess,ev,uv
      415:  df_toggle_load,varAccess,ev.select
      416:  df_draw_event,varAccess,ev
      417:  df_unzoom,varAccess,1,-1
      else: print,"DF_EVENT:",uv
   end
end

function df_testModule,x
;;;;; Returns 0, for `singleRun'. That means it can run several times.
   return,0
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; DEFILEMENT DE TOUS LES SPECTRES
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


pro df_animate,varAccess,x,base
;;;;; This procedure is called by the animation menu. Whether an animation
;;;;; is already running or not, it only changes the speed, or calls
;;;;; the df_animation_loop procedure.
   widget_control,get_uvalue=opt,varAccess.options
   opt.speed=x
   if (x lt 0) then opt.anim=1
   widget_control,set_uvalue=opt,varAccess.options
   if ((x ge 0) and opt.anim) then df_animation_loop,varAccess,base
end

pro df_animation_loop,varAccess,base
;;;;; This procedure contains the loop for the animation.
;;;;; This loop does several things: first, the user_value are read,
;;;;; so that the variables used for plotting are always updated.
;;;;; Then the plot is done; the number of curves shown on each
;;;;; images depends on the value of the 'number of plots' slider.
;;;;; At the end of the loop, another 'wait' loop is run, so the animation
;;;;; does not run too fast; the `speed' setting is used in this
;;;;; loop. The loop also contains a call to the widget_event procedure.
;;;;; So, during the animation, the user can change the speed, the xrange,
;;;;; the number or plots, or the displayed workspace. A test to check
;;;;; if the window has not been destroyed (eg, by using the 'Done' button)
;;;;; is done in the main loop.
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,/sensitive,IDs.stopMenu
   widget_control,sensitive=0,IDs.psBtn
   widget_control,sensitive=0,IDs.dfSlider
   opt.anim=0
   widget_control,set_uvalue=opt,varAccess.options
   wset,IDs.draw
   erase
   i=opt.disp
   window,0,xsize=cst.dimx,ysize=cst.dimx,/pixmap,retain=2
 ;DID!!^
   CATCH,stat
   IF stat eq 0 then begin  
   repeat begin
      widget_control,get_uvalue=temp,varAccess.datAccess
      widget_control,get_uvalue=data,temp.w
      widget_control,get_uvalue=datx,temp.x
      widget_control,get_uvalue=daty,temp.y
      widget_control,get_uvalue=dims,temp.dims
      widget_control,get_uvalue=rgs,varAccess.ranges
      widget_control,get_uvalue=lmt,varAccess.limits
      i=(i+dims(1)+2) mod (dims(1)+1)
      if (opt.scale le 1) then begin
	 r=round(rgs.xspec)
	 if (r(0) eq r(1)) then r=fix([rgs.xspec(0)-1,rgs.xspec(1)+1])
	 yrg=[min(lmt.minsp(r(0):r(1))),max(lmt.maxsp(r(0):r(1)))]
      end $
      else yrg=rgs.yspec
      
      wset,0 & trap_current=0

      plot,rgs.dxspec,yrg,/nodata,/device, $
	 xstyle=9,ystyle=9,xtitle=("Spectrum # " + NUMtSTR(1+i,0) + $
	 " - Value " + NUMtSTR(daty(i),1)),charsize=1.2,font=0, $
	 pos=[cst.borders(0),cst.borders(0),cst.borders(1),cst.borders(1)], $
	 yticklen=1.,ygridstyle=1
;DID!!^
      for j=0,(opt.num-1) do begin
	 ind=j+i-opt.num/2
	 if ((ind ge 0) and (ind le dims(1))) then $
	    if (ind eq i) then oplot,datx,data(*,ind), $
	       color=(130+3*opt.num-(20-opt.num)*j),psym=opt.sym $
	    else oplot,datx,data(*,ind),lineStyle=1, $
	       color=(130+3*opt.num-(20-opt.num)*j),psym=opt.sym
      end
      df_set_slider,varAccess,i
      widget_control,bad_ID=bad,base
      if (bad ne 0) then return
      wset,IDs.draw
      device,copy=[0,0,cst.dimx,cst.dimx,0,0,0]
      j=0
      repeat begin
	 temp=widget_event(/nowait)
	 widget_control,bad_ID=bad,get_uvalue=opt,varAccess.options
	 if (bad ne 0) then opt.anim=1
	 if opt.anim then j=opt.speed $
	 else j=j+1
	 wait,.05
      endrep until (j ge opt.speed)
   endrep until opt.anim
   ENDIF  else  opt.anim=1
   widget_control,bad_ID=bad,set_uvalue=opt,varAccess.options
   widget_control,bad_ID=bad,sensitive=0,IDs.stopMenu
   widget_control,bad_ID=bad,/sensitive,IDs.psBtn
   widget_control,bad_ID=bad,/sensitive,IDs.dfSlider
   widget_control,bad_ID=bad,/clear_events,base
   if (bad eq 0) then df_display,varAccess,i,0,1,-1
end


;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; ZOOM, RANGES MODIFICATION
;;; -+-+-+-+-+-+-+-+-+-+-+-+-

pro df_zoom,varAccess,test,add,xrg,yrg,minPix
;;;;; This procedure zooms, with an xrange of xrg, and an yrange or yrg if
;;;;; the autoscale variable is set to <no autoscale>. If test is set to 0,
;;;;; the xrg and yrg are given in 'mini' window coordinates; otherwise,
;;;;; the parameters are given in the main 'scroll' window corrdinates.
;;;;; If `add' is set to 1, then the current ranges are added to the zooms
;;;;; list, by calling df_add_zoom.
;;;;; The `minPix' parameter is only to be passed to the df_display procedure.
;;;;; Its purpose is to avoid recalculating a picture when it is already
;;;;; known somewhere; it is used in loops, when a pixmap is created before
;;;;; the loop, and df_zoom called in the loop.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=cst,varAccess.constants
   if add then df_add_zoom,varAccess,rgs.Xmini,rgs.Ymini
   if (opt.scale le 1) then temp=(xrg(0) eq xrg(1)) $
   else temp=((xrg(0) eq xrg(1)) or (yrg(0) eq yrg(1)))
   if temp then return
   if test then begin
      newrg=xrg*(rgs.dxspec(1)-rgs.dxspec(0)) + rgs.dxspec(0)
      rgs.yspec=[min(yrg),max(yrg)]
   end else begin
      rgs.Xmini=[max([0,min(xrg)]),min([cst.dimx,max(xrg)])]
      if (opt.scale ne 2) then rgs.Ymini=[0,cst.dimy] $
      else rgs.Ymini=[max([0,min(yrg)]),min([cst.dimy,max(yrg)])]
      newrg=(rgs.Xmini*(rgs.dxmini(1)-rgs.dxmini(0)))/cst.dimx+rgs.dxmini(0)
      rgs.yspec=(rgs.Ymini*(rgs.range(1)-rgs.range(0)))/cst.dimy+rgs.range(0)
   end
   newrg=[min(newrg),max(newrg)]
   temp=where((datx ge newrg(0)) and (datx le newrg(1)),found)
   if (found ge 0) then begin
      rgs.dxspec=newrg
      rgs.xspec=[min(temp),max(temp)]
   end
   if test then begin
      rgs.Xmini=(cst.dimx*(newrg-rgs.dxmini(0)))/ $
	 (rgs.dxmini(1)-rgs.dxmini(0))
      if (opt.scale ne 2) then rgs.Ymini=[0,cst.dimy] $
      else rgs.Ymini=(cst.dimy*(rgs.yspec-rgs.range(0)))/ $
	 (rgs.range(1)-rgs.range(0))
   end
   widget_control,set_uvalue=rgs,varAccess.ranges
   df_autoscale,varAccess,1
   df_display,varAccess,opt.disp,1,1,minPix
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; GESTION DE LA LISTE DES ZOOMS (+ APPEL A 'DF_ZOOM')
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

pro df_unzoom,varAccess,test,minPix
;;;;; This procedure calls the df_zoom procedure with the top element
;;;;; of the zooms list (a 'Last In First Out' stack) if test is set to 0.
;;;;; Otherwise, df_zoom is called with the full ranges.
;;;;; If the zooms list is used, then the top element is removed from
;;;;; the stack.
   widget_control,get_uvalue=zooms,varAccess.zooms
   widget_control,get_uvalue=cst,varAccess.constants
   temp=size(zooms)
   xrg=[0,cst.dimx]
   yrg=[0,cst.dimy]
   if test then df_zoom,varAccess,0,1,xrg,yrg,minPix $
   else begin
      if (temp(0) gt 1) then begin
	 xrg=zooms(0:1,temp(2)-1)
	 yrg=zooms(2:3,temp(2)-1)
	 zooms=zooms(*,0:temp(2)-2)
	 widget_control,set_uvalue=zooms,varAccess.zooms
      end
      df_zoom,varAccess,0,0,xrg,yrg,minPix
   end
end

pro df_add_zoom,varAccess,valx,valy
;;;;; Adds [valx,valy] to the zooms list. The zoom list is a 'Last In First Out'
;;;;; stack, of a maximum size of 'varAccess.constants.zoom_max' elements.
   widget_control,get_uvalue=zooms,varAccess.zooms
   widget_control,get_uvalue=cst,varAccess.constants
   temp=size(zooms)
   if (temp(2) ge cst.zoom_max) then begin
      temp=zooms(0)
      zooms=shift(zooms,0,-1)
      zooms(*,0)=temp
      zooms(*,cst.zoom_max-1)=[valx,valy]
   end $
   else zooms=[[zooms],[[valx,valy]]]
   widget_control,set_uvalue=zooms,varAccess.zooms
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; MINI PICTURE UPDATE
;;; -+-+-+-+-+-+-+-+-+-

pro df_update_mini,varAccess,pixWin,test,xrg,yrg
;;;;; This procedure copies the current spectrum in the mini window,
;;;;; and draws over it the 'selection' rectangle, defined by the
;;;;; coordinates xrg and yrg, if test is set to 1, or by the saved
;;;;; coordinates otherwise. If `pixWin' is less than 1, then it is assumed
;;;;; that no pixmap window is containing the desired plot, so it is
;;;;; created by calling df_makePix. If `pixWin' is greater or equal to 1,
;;;;; then the window `pixWin' is copied into the mini window.
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=IDs,varAccess.IDs
   if (pixWin le 0) then begin
      pixWin=1
      df_makePix,varAccess,pixWin,0
   end
   widget_control,get_uvalue=rgs,varAccess.ranges
   x=rgs.Xmini
   y=rgs.Ymini
   if test then begin
      x=[max([0,min(xrg)]),min([cst.dimx,max(xrg)])]
      y=[max([0,min(yrg)]),min([cst.dimy,max(yrg)])]
   end
   window,0,xsize=cst.dimx,ysize=cst.dimy,/pixmap,retain=2
   device,copy=[0,0,cst.dimx,cst.dimy,0,0,pixWin]
;;;;; The graphics function number 10 (=> GXinvert) is used for
;;;;; drawing the selection rectangle.
   invert=sys_dep      ('INVERT')
   device,get_graphics_function=temp,set_graphics_function=invert
   polyfill,[x(0),x(1),x(1),x(0)],[y(0),y(0),y(1),y(1)],/device
   device,set_graphics_function=temp
   wset,IDs.mini
   device,copy=[0,0,cst.dimx,cst.dimy,0,0,0]
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; MODIFYING THE SETTINGS
;;; -+-+-+-+-+-+-+-+-+-+-+

pro df_change_numb,varAccess,n
;;;;; This procedure is called by the 'number of plots' slider. It updates
;;;;; the variables 'options.num', the 'pos' array, and the display.
   widget_control,get_uvalue=opt,varAccess.options
   if (n eq opt.num) then return
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=cst,varAccess.constants
   opt.num=n
   pos=cst.dimx*rotate(indgen(7*n),2)/(7.0*n)
   widget_control,set_uvalue=opt,varAccess.options
   widget_control,set_uvalue=pos,varAccess.pos
   df_display,varAccess,opt.disp,1,0,-1
end

pro df_slider_event,varAccess,x
;;;;; Event sent by the scrolling slider. The 'options.disp' variable is
;;;;; modified by calling 'df_display', which also updates the display.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   df_display,varAccess,(dims(1)-x)>0,0,1,-1
end

pro df_set_slider,varAccess,x
;;;;; This procedure is used to set the scrolling slider to a given value.
;;;;; It is used in the 'df_animation_loop' procedure, for example.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,bad_ID=temp,set_value=long(dims(1)-x)>0,IDs.dfslider
end

pro df_change_scale,varAccess,type
;;;;; Updates the yrange and the display when the autoscale type is changed.
   widget_control,get_uvalue=opt,varAccess.options
   if (type ne opt.scale) then begin
      opt.scale=type
      widget_control,set_uvalue=opt,varAccess.options
      df_autoscale,varAccess,1
      df_display,varAccess,opt.disp,1,1,-1
   end
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; AUTOSCALE
;;; -+-+-+-+-

pro df_autoscale,varAccess,test
;;;;; This procedure calculates the new yrange, according to the
;;;;; current xrange, and to the autoscale type. If the autoscale is set
;;;;; to <all plots>, then the new yrange is not calculated, unless
;;;;; the `test' parameter is set to 1.
   widget_control,get_uvalue=opt,varAccess.options
   if ((opt.scale ne 1) and ((opt.scale gt 1) or (test eq 0))) then return
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=lims,varAccess.limits
   temp=round(rgs.xspec)
   if (temp(0) eq temp(1)) then temp=fix([rgs.xspec(0)-1,rgs.xspec(1)+1])
   temp=[max([0,temp(0)]),min([dims(0),temp(1)])]
   if (opt.scale eq 1) then begin
      arr=data(temp(0):temp(1),max([0,opt.disp-opt.num/2]): $
	 min([dims(1),opt.disp+(opt.num-1)/2]))
      rgs.yspec=[min(arr),max(arr)]
   end $
   else rgs.yspec=[min(lims.minsp(temp(0):temp(1))), $
      max(lims.maxsp(temp(0):temp(1)))]
   temp=data(*,opt.disp)
   if (rgs.yspec(0) eq rgs.yspec(1)) then rgs.yspec(0)=rgs.yspec(0)-0.01
   widget_control,set_uvalue=rgs,varAccess.ranges
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; 'DF_DRAW_EVENT' SUBROUTINES
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-

function df_zone,varAccess,y
;;;;; This function returns the number of the 'zone' containing
;;;;; the points at (x,`y'). If the points is not in any 'zone', then
;;;;; the returned value is -1.
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   found=-1
   for i=0,opt.num-1 do $
      if ((y le pos(7*i)) and (y ge pos(7*i+4))) then found=i
   temp=found+opt.disp-opt.num/2
   if ((temp ge 0) and (temp le dims(1))) then return,found $
   else return,-1
end

function df_correct,varAccess,x
;;;;; This function returns a corrected value of x, so that when plotting
;;;;; the selection rectangle, it is included in the axis.
   widget_control,get_uvalue=cst,varAccess.constants
   return,1.0*min([cst.borders(1),max([cst.borders(0),x])])
end

function df_selecty,varAccess,y0,y1
;;;;; This function returns data used when dragging the mouse in the
;;;;; scroll window, to draw the selection rectangle. It returns two
;;;;; values, r0 and r1; the selection rect will be of the form
;;;;; {x0,(zone_bottom + `r0'),x1,(zone_top - `r1')}.
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=opt,varAccess.options
   r0=0
   r1=0
   if (opt.scale eq 2) then begin
      temp=df_zone(varAccess,y0)
      if (temp ge 0) then begin
	 r0=y0-pos(7*temp+4)
	 r1=max([0,pos(7*temp)-max([pos(7*temp+4),y1])])
      end $
      else begin
	 temp=df_zone(varAccess,y1)
	 if (temp ge 0) then $
	    if (y1 gt y0) then $
	    r1=pos(7*temp)-max([pos(7*temp+4),y1]) $
	    else r0=y1-pos(7*temp+4)
      end
   end
   return,[r0,r1]
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; SCROLL WINDOW EVENT
;;; -+-+-+-+-+-+-+-+-+-

pro df_draw_event,varAccess,ev
;;;;; This procedure exits immediatly if the event is a release event.
;;;;; If an animation is running, the clicking in this window just stops
;;;;; the animation. Pressing the right mouse button calls the df_unzoom
;;;;; procedure. Dragging the mouse with the left mouse button draws a
;;;;; selection rectangle; when the mouse button is released, the df_zoom
;;;;; procedure is called. For drawing the selection rectangle, a pixmap
;;;;; of the displayed plots is first created; then, a loop reads the mouse
;;;;; position, and copies the pixmap into the picmap ID 0, and plots over
;;;;; this pixmap the selection rectangles. Then, the pixmap ID 0, is
;;;;; copied to the scroll window.
   if (ev.type ne 0) then return
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=rgs,varAccess.ranges
   if (opt.anim eq 0) then begin
      opt.anim=1
      widget_control,set_uvalue=opt,varAccess.options
      return
   end
   if (ev.press eq 1) then begin
      p0=[df_correct(varAccess,ev.x),ev.y]
      window,0,xsize=cst.dimx,ysize=cst.dimx,/pixmap,retain=2
      thePix=1
      df_makePix,varAccess,thePix,1
      wset,IDs.draw
      repeat begin
	 cursor,x,y,/device,/nowait
	 if (x lt 0) then begin
	    if opt.anim then $
	       device,copy=[0,0,cst.dimx,cst.dimx,0,0,thePix]
	    return
	 end
	 x0=df_correct(varAccess,x)
	 x=[p0(0),x0,x0,p0(0)]
	 y=df_selecty(varAccess,p0(1),y)
	 wset,0
	 device,copy=[0,0,cst.dimx,cst.dimx,0,0,1]
   	 invert=sys_dep      ('INVERT')
	 device,get_graphics_function=temp,set_graphics_function=invert
	 for i=0,(opt.num-1) do begin
	    ind=i+opt.disp-opt.num/2
	    if ((ind ge 0) and (ind le dims(1))) then begin
	       temp1=pos(7*i+4)+y(0)
	       temp2=pos(7*i)-y(1)
	       polyfill,x,[temp1,temp1,temp2,temp2],/device
	    end
	 end
	 device,set_graphics_function=3
	 wset,IDs.draw
	 device,copy=[0,0,cst.dimx,cst.dimx,0,0,0]
	 device,set_graphics_function=temp
      end until ((!err mod 2) eq 0)
      xrg=([p0(0),x0]-cst.borders(0))/(cst.borders(1)-cst.borders(0))
      temp=[y(0),pos(0)-pos(4)-y(1)]/(pos(0)-pos(4))
      yrg=(rgs.yspec(1)-rgs.yspec(0))*temp+rgs.yspec(0)
      df_zoom,varAccess,1,1,xrg,yrg,-1
   end
   if (ev.press eq 4) then df_unzoom,varAccess,0,-1
   widget_control,/clear_events,ev.top
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; MINI WINDOW EVENT
;;; -+-+-+-+-+-+-+-+-

pro df_mini_event,varAccess,ev
;;;;; This procedure quits if the event is not a <button pressed>.
;;;;; If the button is the right one, then the df_unzoom is called. Otherwise,
;;;;; a pixmap with the currently displayed spectrum is created. It is used
;;;;; in the loops that read the cursor position. If the pressed button is
;;;;; the center one, then the loop draws a rectangle of a constant size
;;;;; in pixmap ID 0, where the previous pixmap has been copied, then pixmap
;;;;; ID 0 is copied to the mini window, and the df_zoom procedure is called,
;;;;; so that moving the selection rect is updated in real time. If the
;;;;; pressed button is the right one, then the loop just draws a new selection
;;;;; rect, with the same method as above. In both case, the loop exits when
;;;;; the mouse button is released. The events are cleared at the end of
;;;;; the procedure, so pressing several buttons generates only one event,
;;;;; for the first button pressed.
   thePix=1
   if (ev.type ne 0) then return
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=IDs,varAccess.IDs
   df_makePix,varAccess,thePix,0
   if (ev.press eq 1) then begin
      x0=ev.x
      y0=ev.y
      p0=[x0,y0]
      wset,IDs.mini
      repeat begin
	 cursor,x,y,/device,/nowait
	 if (x lt 0) then $
	    if (x0 ge p0(0)) then x0=cst.dimx $
	    else x0=0 $
	 else x0=x
	 if (y lt 0) then $
	    if (y0 ge p0(1)) then y0=cst.dimy $
	    else y0=0 $
	 else y0=y
	 if (opt.scale le 1) $
	 then df_update_mini,varAccess,thePix,1,[p0(0),x0],[0,cst.dimy] $
	 else df_update_mini,varAccess,thePix,1,[p0(0),x0],[p0(1),y0]
      end until ((!err mod 2) eq 0)
      df_zoom,varAccess,0,1,[p0(0),x0],[p0(1),y0],thePix
   end
   if (ev.press eq 2) then begin
      if ((ev.x lt rgs.Xmini(0)) or (ev.x gt rgs.Xmini(1)) or $
	 (ev.y lt rgs.Ymini(0)) or (ev.y gt rgs.Ymini(1))) then return
      p0=[ev.x,ev.y]
      x=ev.x
      y=ev.y
      used1=rgs.Xmini
      used2=rgs.Ymini
      repeat begin
	 if (opt.scale le 1) $
	 then df_zoom,varAccess,0,0,(used1-p0(0)+x),[0,cst.dimy],thePix $
	 else df_zoom,varAccess,0,0,(used1-p0(0)+x),(used2-p0(1)+y),thePix
	 cursor,x,y,/device,/nowait
      end until ((!err mod 4) lt 2)
   end
   if (ev.press eq 4) then df_unzoom,varAccess,0,thePix
   widget_control,/clear_events,ev.top
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PIXMAP PLOTTING, SCROLL WINDOW DISPLAY UPDATE
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro df_makePix,varAccess,x,y
;;;;; This procedure creates a pixamp ID `x', and draws inside the
;;;;; plots corresponding to the scroll window (`y' set to 1),
;;;;; or to the mini window (`y' set to 0), according to the settings.
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=daty,temp.y
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=pos,varAccess.pos
   widget_control,get_uvalue=cst,varAccess.constants
   window,x,xsize=cst.dimx,ysize=cst.dimx,/pixmap,retain=2 & trap_current=x
   if y then $
      for i=0,(opt.num-1) do begin
	 ind=i+opt.disp-opt.num/2
	 if ((ind ge 0) and (ind le dims(1))) then begin
	    plot,rgs.dxspec,rgs.yspec,/nodata,/device,/noerase, $
	       xtitle=("Spectrum # " + NUMtSTR(1+ind,0) + " - Value " + $
	       NUMtSTR(daty(ind),1)),yticks=1+5/sqrt(opt.num), $
	       pos=[cst.borders(0),pos(7*i+4),cst.borders(1),pos(7*i)], $
	       charsize=1.2,font=0,xstyle=9,ystyle=9, $
	       xticklen=1. ,yticklen=1.,xgridstyle=1,ygridstyle=1
;DID!!^
	    oplot,datx,data(*,ind),psym=opt.sym, $
	       color=(130+3*opt.num-(20-opt.num)*i)
	 end
      end $
   else begin
      rgs.range=[min(data(*,opt.disp)),max(data(*,opt.disp))]
      if (opt.scale ne 2) then rgs.Ymini=[0,cst.dimy] $
      else rgs.Ymini=(cst.dimy*(rgs.yspec-rgs.range(0)))/ $
	 (rgs.range(1)-rgs.range(0))
      plot,rgs.dxmini,rgs.range,/nodata,pos=[0,0,cst.dimx,cst.dimy], $
	 /device,xstyle=5,ystyle=5
      oplot,datx,data(*,opt.disp),color=120
      widget_control,set_uvalue=rgs,varAccess.ranges
   end
end

pro df_display,varAccess,x,y,z,minPix
;;;;; This procedure displays the spectrum `x', if the displayed one is
;;;;; not the `x' one, or if `y' is set to 1. It modifies the variable
;;;;; settings.disp and after that, calls df_makePix to create the new
;;;;; plots picture; the pixmap is then copied into the scroll window.
;;;;; If z is set to 1, the mini window is also updated, by calling
;;;;; the procedure df_update_mini.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=opt,varAccess.options
   if (((x eq opt.disp) and (y eq 0)) or (x gt dims(1))) then return
   opt.disp=x
   widget_control,set_uvalue=opt,varAccess.options
   df_autoscale,varAccess,0
   if opt.anim then begin
      df_makePix,varAccess,0,1
      widget_control,get_uvalue=cst,varAccess.constants
      widget_control,get_uvalue=IDs,varAccess.IDs
      wset,IDs.draw
      device,copy=[0,0,cst.dimx,cst.dimx,0,0,0]
   end
   if z then df_update_mini,varAccess,minPix,0
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; LECTURE DES WORKSPACES DE LAMP
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

pro df_loadRange,varAccess,test,r1,r2,r3,r4,r5,r6,r7
;;;;; This procedure writes the parameters into user value of
;;;;; the correct widget_label; which params, and which widget_label
;;;;; is determined by the `test' parameter: when set to 0, the seven
;;;;; parameters r1 to r7 are stored as ranges, when set to 1, r1 and r2
;;;;; only are stored into varAccess.limits.
   case test of
      0:    widget_control,varAccess.ranges, $
	       set_uvalue={dxmini:r1,dxspec:r2, $
	       xmini:r3,ymini:r4,range:r5,xspec:r6,yspec:r7}
      1:    widget_control,varAccess.limits, $
		  set_uvalue={minsp:r1,maxsp:r2}
      else: return
   end
end

pro df_loadData,varAccess,w,x,y,n,p,par,dims
;;;;; Writes the parameters into the data widget user values.
;;;;; The purpose of this procedure is only to avoid to type
;;;;; several times the same commands.
   widget_control,get_uvalue=data,varAccess.datAccess
   widget_control,set_uvalue=w,data.w
   widget_control,set_uvalue=x,data.x
   widget_control,set_uvalue=y,data.y
   widget_control,set_uvalue=n,data.n
   widget_control,set_uvalue=p,data.p
   widget_control,set_uvalue=par,data.par
   widget_control,set_uvalue=dims,data.dims
end

function df_loadRequest,varAccess,wkn,w,x,y,n,p,par
;;;;; This procedure modifies all variables for loading new data.
;;;;; All the needed data are passed as parameters. The returned value
;;;;; is 0 if `w' does not meet the size requirements (ie two-dimensional
;;;;; array), otherwise, the result is 1.
;;;;; When loading new data, the ranges, the limit values must be modified;
;;;;; the options.disp might need to be changed too, if the new data contains
;;;;; less spectra than the currently displayed spectrum.
   wkSize=size(w)
   if (wkSize(0) ne 2) then return,0
   temp=size(x)
   if (temp(0) ne 1) or (temp(1) ne wksize(1)) then x=indgen(wksize(1))
   temp=size(y)
   if (temp(0) ne 1) or ((temp(0) eq 1) and (temp(1) ne wksize(2))) then y=indgen(wksize(2))
   temp=size(p)
   if (temp(0) ne 1) or (temp(1) ne 31) then p=fltarr(31)
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=rgs,varAccess.ranges
   widget_control,get_uvalue=cst,varAccess.constants
   df_loadData,varAccess,w,x,y,n,p,par,[wkSize(1)-1,wkSize(2)-1]
   df_numor,varAccess
   opt.disp=min([opt.disp,wkSize(2)-1])
   rgs.dxmini=[min(x),max(x)]
   rgs.dxspec=rgs.dxmini
   maxs=fltarr(wkSize(1))
   mins=fltarr(wkSize(1))
   for i=0,wkSize(1)-1 do maxs(i)=max(w(i,*))
   for i=0,wkSize(1)-1 do mins(i)=min(w(i,*))
   df_loadRange,varAccess,1,mins,maxs
   widget_control,set_slider_min=0                ,IDs.dfslider
   widget_control,set_slider_max=long(wkSize(2)-1),IDs.dfslider
   widget_control,set_uvalue=[[0,cst.dimx,0,cst.dimy]],varAccess.zooms
   widget_control,set_uvalue=opt,varAccess.options
   widget_control,set_uvalue=rgs,varAccess.ranges
   if opt.anim then begin
      df_set_slider,varAccess,opt.disp
      df_update_mini,varAccess,-1,0
      if opt.surf then df_surf,varAccess
   end
   widget_control,get_uvalue=opt,varAccess.options
   temp=opt.anim
   opt.anim=(opt.surf eq 0)
   widget_control,set_uvalue=opt,varAccess.options
   df_zoom,varAccess,0,0,[0,cst.dimx],[0,cst.dimy],-1
   widget_control,get_uvalue=opt,varAccess.options
   opt.anim=temp
   widget_control,set_uvalue=opt,varAccess.options
   return,1
end

pro df_loadWorkspace,varAccess,x,labID
;;;;; This procedure reads all the data linked to the LAMP workspace Wx,
;;;;; and calls the df_loadRequest. It also prints messages about the
;;;;; current status ("loading", or "invalid workspace").
   wksize=BEN_WK_SIZE(x)
;DID!!
   if (wkSize(0) lt 1) or (wkSize(0) gt 2) then begin
      widget_control,set_value=("'W" + NUMtSTR(x,0) + "' is invalid."),labID
      print,string(7b)
      return
   end $
   else widget_control,set_value=("Loading 'W" + NUMtSTR(x,0) + "'."),labID
   BEN_READ_WK,x,data,datx,daty,datn,datp,datpar
;DID!!
   if (wkSize(0) eq 1) then begin
   	data  =[[data],[data]]
   	datay =[1,1]
   	wkSize=size(data)
   endif

   temp=df_loadRequest(varAccess,x,data,datx,daty,datn,datp,datpar)
   if (temp eq 0) then begin
      widget_control,set_value=("Failed !"),labID
      print,string(7b)
   end else widget_control,set_value=" ",labID
end

pro df_toggle_load,varAccess,x
;;;;; This procedure modifies the options.surface variable, that sets
;;;;; whether a surface is plotted or not, when loading a workspace.
   widget_control,get_uvalue=opt,varAccess.options
   opt.surf=x
   widget_control,set_uvalue=opt,varAccess.options
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PLOT SYMBOL SELECTION
;;; SURFACE PLOT WHEN LOADING
;;; -+-+-+-+-+-+-+-+-+-+-+-+-

pro df_select_sym,varAccess,test,sym
;;;;; This procedure modifies the variable that hold the current
;;;;; plot symbol; then, the display is updated.
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.sym=sym $
   else opt.lines=-opt.lines
   if (opt.sym lt 10) then opt.sym=opt.lines*abs(opt.sym) $
   else opt.sym=10
   widget_control,set_uvalue=opt,varAccess.options
   df_display,varAccess,opt.disp,1,0,-1
end

pro df_surf,varAccess
;;;;; Simply plots a surface, using Xi and Yi, in the scroll window.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=daty,temp.y
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   wset,IDs.draw
   m=64.0
   shade_surf,data,datx,daty,pos=[m,m,cst.dimx-m,cst.dimx-m],/device
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; HELP
;;; -+-+

pro df_help,base
   print,"HELP WANTED"
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; POSTSCRIPT FILE
;;; -+-+-+-+-+-+-+-

pro df_psfile,varAccess,base,n
;;;;; This procedure creates and displays a dialog window, to enter
;;;;; the PostScript file name. A 'Cancel' button destroy the new
;;;;; window. The creation of the PS file is done in the df_dialog_event
;;;;; procedure.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=datpar,temp.par
   widget_control,get_uvalue=dims,temp.dims
   widget_control,get_uvalue=opt,varAccess.options
   if (datpar(0) eq '') then defName="Spectra#" $
   else defName=("N#" +      datpar(0)    + "_Spectra#")
;DID!!
;  else defName=("N#" + NUMtSTR(datpar,0) + "_Spectra#")
   if (opt.num eq 1) then defName=(defName + NUMtSTR(1+opt.disp ,0))  $
   else defName=(defName + NUMtSTR(1+max([0,opt.disp-opt.num/2]),0) + $
      "-" + NUMtSTR(1+min([dims(1),opt.disp+opt.num/2]),0))
   wind=widget_base(title="PS file name:",/column, $
      group_leader=base,uvalue=varAccess,resource_name="lampben")
   text=widget_text(wind,value=defName,/editable,xsize=32, $
      uvalue=[-88,414,n,0])
   subase=widget_base(wind,/row)
   label=widget_label(subase,value="'.ps' will be appended.   ")
   btn=widget_button(subase,value="Cancel",uvalue=[-88,414,n,2])
   btn=widget_button(subase,value=" OK ",uvalue=[-88,414,n,1,text])
   widget_control,/realize,wind
   widget_control,/input_focus,btn
   ;widget_control,/input_focus,text
   widget_control,set_text_select=[0,strlen(defName)],text
   xmanager,"ben_dfps",wind,event_handler="lamp_event_parser",/just_reg
end

pro df_dialog_event,varAccess,ev,uv
;;;;; This procedure is called by any widget of the PS file dialog, created
;;;;; by df_psfile. If the widget is the 'Cancel' button, then the window
;;;;; is simply destroyed. If it is the 'OK' button or the text widget,
;;;;; the content of the widget_text is read. If it is empty, then the
;;;;; procedure acts if the 'Cancel' button had been pressed. Otherwise,
;;;;; the plot is set to 'ps', and the file_name to it. The plot is done,
;;;;; and the file closed. After that, the previous plot device is restored.
;;;;; If an output error occurs, the current file is closed, and the device
;;;;; restored too, and an error string is displayed. In both case, the
;;;;; dialog window is destroyed.
   case uv(3) of
      0:    widget_control,get_value=psFile,ev.id
      1:    widget_control,get_value=psFile,uv(4)
      else: psFile=""
   end
   psFile=sys_dep      ('BLANKS',psFile(0))
   if (psFile eq '') then begin
      widget_control,/destroy,ev.top
      return
   end
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=data,temp.w
   widget_control,get_uvalue=datx,temp.x
   widget_control,get_uvalue=daty,temp.y
   widget_control,get_uvalue=dims,temp.dims
;DID!!
   widget_control,get_uvalue=datpar,temp.par
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=rgs,varAccess.ranges
   psFile=psFile + '.ps'
   wplot=!D.name
   err=1
   on_ioerror,iferr
   wmulti=!P.multi
   set_plot,'ps'
   if opt.num eq 1 THEN $
   device,yoffset=11.,xoffset=.5,/inches,/landscape $
   ELSE $
   device,xsize=7.5,ysize=10.,yoffset=.75,xoffset=.5,/inches,/portrait
   device,bits_per_pixel=8,/color
   !P.multi=[0,1,opt.num,0,0]
   device,filename=psFile
   for i=0,(opt.num-1) do begin
      ind=i+opt.disp-opt.num/2
      if ((ind ge 0) and (ind le dims(1))) then begin
	 plot,rgs.dxspec,rgs.yspec,/nodata,xstyle=9,ystyle=9,charsize=1.6,font=0, $
	    xtitle=("Spectrum # " + NUMtSTR(1+ind,0) + " - Value " + $
	    NUMtSTR(daty(ind),1)),yticks=1+5/sqrt(opt.num), $
	    xticklen=1.,yticklen=1.,xgridstyle=1,ygridstyle=1,color=128
;DID!!
	 oplot,datx,data(*,ind),psym=opt.sym,color=128
      end
   end
;DID!!
   if n_elements(datpar) lt 2 then widx=0 else widx=fix(datpar(1))

   IF opt.num eq 1 THEN p=7. ELSE p=10.
   P_DID_PS_HEADER, p ,widx ,psFile
   err=0
iferr : $
   if err eq 1 then device,/close_file
   set_plot,wplot
   !P.multi=wmulti
   if uv(3) then tID=uv(4) $
   else tID=ev.id
   if err then widget_control,set_value=("ERROR:" + !ERR_STRING),tID $
   else widget_control,set_value=('PS file : ' + psFile),tID
   wait,.05
   widget_control,/destroy,ev.top
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; DATA INITIALIZATION
;;; -+-+-+-+-+-+-+-+-+-

pro df_numor,varAccess
;;;;; This procedure displays the number numor in a label.
   widget_control,get_uvalue=temp,varAccess.datAccess
   widget_control,get_uvalue=datpar,temp.par
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=IDs,varAccess.IDs
   if (datpar(0) eq '') then temp=' ' $
   else temp=("Numor # " +      datpar(0)   )
;DID!!
;  else temp=("Numor # " + NUMtSTR(datpar,0))
   if n_elements(datpar) gt 1 then if datpar(2) ne '' then temp=strmid(datpar(2),0,52)
   widget_control,set_value=temp,IDs.numLab
   if (temp eq ' ') then temp='' $
   else temp=('  (' + temp + ')')
   widget_control,tlb_set_title=(cst.title + temp),IDs.numLab
end

pro df_initData,varAccess,request
;;;;; Fill the data variables, according to `request'. If `request' is
;;;;; set to 1, the scroll spectra window was opened because of a
;;;;; request from the desk; the function must start with the
;;;;; requested data, stored in the common `ben_data'. So, if `request'
;;;;; is set to 1, those data are loaded; if it is set to 0, default
;;;;; data are loaded, by calling `df_defaultData'.
   widget_control,get_uvalue=cst,varAccess.constants
   common ben_data,wk,w,x,y,n,p,par
   if request then begin
      wkSize=size(w)
      if (wkSize(0) eq 2) then begin
	 temp=size(x)
	 if (temp(0) ne 1) or (temp(1) ne wkSize(1)) then $
	    x=indgen(wksize(1))
	 temp=size(y)
	 if (temp(0) ne 1) or (temp(1) ne wkSize(2)) then $
	    y=indgen(wksize(2))
	 temp=size(p)
	 if (temp(0) ne 1) or (temp(1) ne 31) then $
	    p=fltarr(31)
	 df_loadData,varAccess,w,x,y,n,p,par,(wkSize(1:2)-1)
	 maxsp=fltarr(wkSize(1))
	 minsp=fltarr(wkSize(1))
	 for i=0,wkSize(1)-1 do maxsp(i)=max(w(i,*))
	 for i=0,wkSize(1)-1 do minsp(i)=min(w(i,*))
	 dxRg=float([min(x),max(x)])
	 widget_control,get_uvalue=opt,varAccess.options
	 temp=w(*,opt.disp)
	 df_loadRange,varAccess,0,dxRg,dxRg,[0,cst.dimx], $
	    [0,cst.dimy],[min(temp),max(temp)], $
	    [0,wkSize(1)-1],[min(minsp),max(maxsp)]
	 df_loadRange,varAccess,1,minsp,maxsp
      end else df_defaultData,varAccess
   end else df_defaultData,varAccess
end

pro df_defaultData,varAccess
;;; Inits the data when 'Scroll Spectra' is not called via 'request'
   widget_control,get_uvalue=cst,varAccess.constants
   dimx=63L
   dimy=63L
   data=dist(dimx+1,dimy+1)
   datx=indgen(dimx+1)
   df_loadData,varAccess,data,datx,indgen(dimy+1), $
      0,fltarr(31),0,[dimx,dimy]
   maxsp=fltarr(dimx+1)
   minsp=fltarr(dimx+1)
   for i=0,dimx do maxsp(i)=max(data(i,*))
   for i=0,dimx do minsp(i)=min(data(i,*))
   dxRg=float([min(datx),max(datx)])
   widget_control,get_uvalue=opts,varAccess.options
      temp=data(*,opts.disp)
   df_loadRange,varAccess,0,dxRg,dxRg,[0,cst.dimx],[0,cst.dimy], $
      [min(temp),max(temp)],[0,dimx],[min(minsp),max(maxsp)]
   df_loadRange,varAccess,1,minsp,maxsp
end

function df_inits,test,x
;;;;; This function returns some default value for the parameter
;;;;; settings, or constants of the program.
@lamp.cbk
   if lamp_siz lt 800 then xxx=384.0 else xxx=512.0
   if lamp_siz lt 800 then yyy= 64.0 else yyy= 64.0
   num=1
   case test of
      0:    res={dimx:xxx,dimy:yyy,zoom_max:16, $
		 borders:[yyy,xxx-32.0],title:x}
      1:    res={disp:0,num:num,sym:0,lines:-1,scale:1,anim:1,speed:3,surf:0}
      2:    res=[[0,xxx,0,yyy]]
      3:    res=xxx*rotate(indgen(7*num),2)/(7.0*num)
      else: res=0
   end
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; WIDGET CREATION
;;; -+-+-+-+-+-+-+-

pro ben_df_create,lamp,n,m,base,request
@lamp.cbk
   if (m eq 0) then winTitle=desk_name(n,1) $
   else winTitle=(desk_name(n,1) + " " + NUMtSTR(1+m,0))
   if (lamp_siz lt 1000) then begin
      base=widget_base(title=winTitle,/row,group_leader=lamp, $
	   resource_name='lampben')
      bas1=widget_base(base,/column)
      bas2=widget_base(base,/column)
      test=1
   end else begin
      base=widget_base(title=winTitle,/column,group_leader=lamp, $
	   resource_name='lampben')
      bas1=base & bas2=base
      test=0
   end

   constants=df_inits(0,winTitle)
   options  =df_inits(1)

;;;;; Creation of the first button row.
   if test then begin
      comID   =BEN_COMMANDS(bas1,n,[0,0])
      surfBase=widget_base (bas1,/nonexclusive)
      hint    =widget_base (bas1,/column,/frame)
      vars    =widget_base (bas1,/row)
   end else begin
      temp    =widget_base (bas1,/row)
      left    =widget_base (temp,/column)
      vars    =widget_base (temp,/column)
      comID   =BEN_COMMANDS(left,n,[0,0])
      surfBase=widget_base (left,/nonexclusive)
      hint    =widget_base (vars,/column,/frame)
   end

   surfBtn=widget_button(surfBase,uvalue=[-88,415,n,comID(4)], $
      value="Plot surface when loading workspace")
   numLab=widget_label  (bas1,value=" ",xsize=constants.dimx/(test+1),font=ft_b_bigger)

;;;;; Creation of the widget_label containing in their user value the
;;;;; variables used by the Scroll spectra function. Their IDs are stored
;;;;; in the top_level base user value.
   datAccess=widget_base(vars,/row)
   data	 =widget_label(datAccess,value="")
   datx	 =widget_label(datAccess,value="")
   daty	 =widget_label(datAccess,value="")
   datn	 =widget_label(datAccess,value="")
   datp	 =widget_label(datAccess,value="")
   datppp=widget_label(datAccess,value="")
   dims	 =widget_label(datAccess,value="")
   dat={w:data,x:datx,y:daty,n:datn,p:datp,par:datppp,dims:dims}
   widget_control,set_uvalue=dat,datAccess

   vars=widget_base(vars,/row)
   const =widget_label(vars,value="",uvalue=constants)
   opts	 =widget_label(vars,value="",uvalue=options)
   ranges=widget_label(vars,value="")
   zooms =widget_label(vars,value="",uvalue=df_inits(2))
   pos	 =widget_label(vars,value="",uvalue=df_inits(3))
   lmt	 =widget_label(vars,value="")
   IDs	 =widget_label(vars,value="")
   varAccess={datAccess:datAccess,constants:const,options:opts, $
      ranges:ranges,zooms:zooms,pos:pos,limits:lmt,IDs:IDs}
   widget_control,set_uvalue=varAccess,base

;;;;; All the 'variable widgets' are now created. The data is initialized
;;;;; by calling the df_initData procedure.
   df_initData,varAccess,request
   widget_control,get_uvalue=dims,dat.dims

;;;;; Creation of the 'hint' labels.
   temp=widget_label(hint,value="left button zooms")
   temp=widget_label(hint,value="right button unzooms")
   temp=widget_label(hint,value="center button moves selection")

;;;;; Creation of the mini draw window, that will show a miniature of
;;;;; the displayed spectrum, and of the scrolling window, with its
;;;;; slider, used as a scroll bar.
   mini=widget_draw(widget_base(bas2,/row,/frame),/button_events, $
      xsize=constants.dimx,ysize=constants.dimy,retain=2,uvalue=[-88,407,n])
   picts=widget_base(bas2,/row,/frame)
   draw=widget_draw(picts,xsize=constants.dimx,ysize=constants.dimx, $
      retain=2,uvalue=[-88,416,n],/button_events)
   dfslider=widget_slider(picts,min=0,max=long(dims(1)),value=long(dims(1)), $
      /vertical,/suppress_value,/drag,uvalue=[-88,408,n],ysize=constants.dimx)

;;;;; Creation of the 'number of plots' slider, the 'draw lines' slider,
;;;;; and the 'plot symbol' menu. The 'draw lines' has effect only when a
;;;;; symbol is chosen, to determine whether the points should be connected
;;;;; or not; if no plot is chosen, there is always lines between points...
   if test then begin
      temp=widget_slider(bas1,title="Number of plots",min=1,max=8, $
	                 value=options.num,/drag,uvalue=[-88,410,n])
      controls=bas1
      b_logo   =widget_base  (controls,/row)
		put_logo     ,b_logo
      drawlines=widget_button(widget_base(b_logo,/nonexclusive), $
			      value="Draw lines",uvalue=[-88,413,n,0,0])
      menus=widget_base(controls,/row)
      psBase=controls
   end else begin
      controls=widget_base(bas1,/row,space=16)
      left=widget_base(controls,/column)
      temp=widget_slider(left,title="Number of plots",min=1,max=8, $
			 value=options.num,/drag,uvalue=[-88,410,n])
      b_logo   =widget_base  (left,/row)
		put_logo     ,b_logo
      drawlines=widget_button(widget_base(b_logo,/nonexclusive), $
			      value="Draw lines",uvalue=[-88,413,n,0,0])
      menus=widget_base(left,/row,space=32)
      psBase=menus
   end
   symbol=widget_button(menus,value="Plot symbol",menu=2)
   temp=widget_button(symbol,value="< None >",uvalue=[-88,413,n,1,0])
   temp=widget_button(symbol,value=" +",uvalue=[-88,413,n,1,1])
   temp=widget_button(symbol,value=" *",uvalue=[-88,413,n,1,2])
   temp=widget_button(symbol,value=" .",uvalue=[-88,413,n,1,3])
   temp=widget_button(symbol,value=" X",uvalue=[-88,413,n,1,7])
   temp=widget_button(symbol,value="Histogram",uvalue=[-88,413,n,1,10])
   sub=widget_button(symbol,value="Other",/menu)
   temp=widget_button(sub,value="Diamond",uvalue=[-88,413,n,1,4])
   temp=widget_button(sub,value="Triangle",uvalue=[-88,413,n,1,5])
   temp=widget_button(sub,value="Square",uvalue=[-88,413,n,1,6])

;;;;; Creation of the 'animate' menu, that starts the animation, or
;;;;; modifies its speed. It also contains a 'stop' menu item, that
;;;;; is sensitive only when an animation is running.
   anim=widget_button(menus,value="Animate",menu=2)
   stopMenu=widget_button(anim,value="Stop",font=ft_b_normal, $
      uvalue=[-88,409,n,-1])
   temp=widget_button(anim,value="Slow",uvalue=[-88,409,n,15])
   temp=widget_button(anim,value="Normal",uvalue=[-88,409,n,7])
   temp=widget_button(anim,value="Fast",uvalue=[-88,409,n,2])
   psBtn=widget_button(psBase,value="To PS file...",uvalue=[-88,412,n])

;;;;; Creation of the ranges buttons. The 'full range' button has nothing
;;;;; to do with autoscale, but simply makes a total unzoom of the spectra.
   right=widget_base(controls,/column)
   fscl=widget_button(right,value="Full range",uvalue=[-88,417,n])
   scl=widget_base(right,/column,/frame)
   temp=widget_label(scl,value="Autoscale using:",font=ft_b_normal)
   temp=widget_base(scl,/exclusive,/column)
   scl0=widget_button(temp,value="All plots",uvalue=[-88,406,n,0])
   scl1=widget_button(temp,value="Displayed plots",uvalue=[-88,406,n,1])
   scl2=widget_button(temp,value="No Autoscale",uvalue=[-88,406,n,2])

;;;;; All the widgets are declared. According to the startup options,
;;;;; the toggle button states are modified, and widget IDs are stored.
   if options.surf then widget_control,/set_button,surfBtn
   temp=execute("widget_control,/set_button,scl" + NUMtSTR(options.scale,0))
   if (options.lines le 0) then widget_control,/set_button,drawlines
   widget_control,sensitive=0,stopMenu
   bid=sys_dep      ('DYNLAB',base,1)
   widget_control,/realize,base & put_logo
   widget_control,get_value=drawID,draw
   widget_control,get_value=minID,mini
   IDlist={mini:minID,draw:drawID,dfSlider:dfSlider, $
      stopMenu:stopMenu,psBtn:psBtn,numLab:numLab}
   widget_control,set_uvalue=IDlist,varAccess.IDs
   df_numor,varAccess
   df_change_numb,varAccess,options.num
   df_display,varAccess,options.disp,1,1,-1
   xmanager,desk_name(n,0),base,event_handler="lamp_event_parser",/just_reg
end

;;; ***************************************************************************
;;; ***			      RADIAL INTEGRATION			    ***
;;; ***************************************************************************

pro int_event,ev,uv
   widget_control,get_uvalue=varAccess,ev.top
   case uv(1) of
      400:  begin wait,.05 & widget_control,/destroy,ev.top & end
      401:  BEN_CHANGE_WORKSPACE,uv
      402:  int_help,varAccess,ev.top
      403:  int_loadWorkspace,varAccess,uv(3),uv(4)
      405:  int_plotMenu,varAccess,uv
      406:  int_updateRay,varAccess,ev,uv(3)
      407:  int_changeZone,varAccess,ev,uv(3),uv(4)
      408:  int_miniPix,varAccess,1
      409:  int_changeCenter,varAccess
      410:  int_zonePlot,varAccess,ev.select
      411:  int_updateRes,varAccess,uv(3),uv(4),uv(5)
      412:  int_updateMini,varAccess,ev,uv
      else: print,"INT_EVENT:",varAccess,uv
   end
end

function int_testModule,x
   return,0
end

pro int_help,base
   print,"HELP WANTED"
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PROCEDURES FOR DRAWING THE SELECTION PICTURE
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

function int_middle,varAccess,x,y
;;;;; This function returns the middle angle of x and y.
   if (x lt 0) then x=360.0 + x
   if (x gt y) then return,(180.0+(x+y)/2.0) $
   else return,(x+y)/2.0
end

pro int_poly,a1,a2,a3,c,c_x,c_y,r1,r2,deg2rad,test
;;;;; Procedure 'int_poly' draws the section enclosed in angles
;;;;; a1 and a3, and radia r1 and r2, in the current window.
   a12=int_middle(varAccess,a1,a2)
   a23=int_middle(varAccess,a2,a3)
   temp1=[a1,a12,a2,a23,a3]*deg2rad
   temp2=[a3,a23,a2,a12,a1]*deg2rad
   x=[r1*cos(temp1),r2*cos(temp2),r1*cos(a1*deg2rad)]
   y=[r1*sin(temp1),r2*sin(temp2),r1*sin(a1*deg2rad)]
   oplot,c_x+x,c_y+y,color=c,thick=2,psym=0
   oplot,c_x-x,c_y-y,color=c,thick=2,psym=0,lineStyle=2*test
end

pro int_drawAxes,varAccess
;;;;; This procedure updates the mini widget_draw.
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=pix,varAccess.pixmap
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=col,varAccess.colors
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=opt,varAccess.options
   c_x=set.cx+0.5
   c_y=set.cy+0.5
   if (dims.dim eq dims.dimx) $
   then c_y=c_y+(dims.dim-dims.dimy)/2.0*(dims.dimx/dims.dim) $
   else c_x=c_x+(dims.dim-dims.dimx)/2.0*(dims.dimy/dims.dim)
   cur=set.alpha
   window,0,xsize=cst.minSize,ysize=cst.minSize,/pixmap,retain=2 & trap_current=0
   tvscl,pix.img,pix.xmarg,pix.ymarg,order=0
   if ((pix.xmarg ne 0) or (pix.ymarg ne 0)) then begin
      x=pix.xmarg*[1,1,-1,-1,1]+[-1,-1,cst.minSize,cst.minSize,-1]
      y=pix.ymarg*[1,-1,-1,1,1]+[-1,cst.minSize,cst.minSize,-1,-1]
      plot,x,y,xrange=[0,cst.minSize],yrange=[0,cst.minSize], $
	 /device,/noerase,pos=[0,0,cst.minSize,cst.minSize], $
	 lineStyle=1,xstyle=5,ystyle=5,psym=0
   end
   temp=[-dims.dim,dims.dim]*sqrt(2)
   plot,[0,dims.dim],[0,dims.dim],/nodata,/noerase,/device, $
      xstyle=5,ystyle=5,pos=[0,0,cst.minSize,cst.minSize],psym=0
   for i=0,(set.zones-1) do begin
      if set.zones le 8 then $
      oplot   , cos(cur*cst.deg2rad)*temp+c_x,sin(cur*cst.deg2rad)* $
	        temp+c_y,color=col(i),thick=2,psym=0
      int_poly,(cur-set.beta),cur,(cur+set.beta),col(i), $
	        c_x,c_y,set.r1,set.r2,cst.deg2rad,opt.plotZone
      cur=cur+set.gamma
   end
   polyfill,c_x+set.mx*[-1,-1,1,1],c_y+set.my*[1,-1,-1,1],color=0
   wset,IDs.mini
   device,copy=[0,0,cst.minSize,cst.minSize,0,0,0]
end

pro int_miniPix,varAccess,test
;;;;; This function calculates an array, according to the
;;;;; options, of the same size as the mini widget_draw.
;;;;; This array is stored, so that, when changing the
;;;;; mini widget_draw, it can be used for `tvscl'.
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.logAspect=(opt.logAspect ne 1)
   xmarg=0
   ymarg=0
   if opt.logAspect then img=alog(1.0+data) $
   else img=data
   if (dims.dimx eq dims.dimy) then $
      if (((cst.minSize mod dims.dim) eq 0) or $
	 ((dims.dim mod cst.minSize) eq 0)) $ ;bug Ulong then miniPix=rebin(img,cst.minSize,cst.minSize,/sample) $
           then miniPix=congrid(img,cst.minSize,cst.minSize) $
      else miniPix=congrid(img,cst.minSize,cst.minSize) $
   else begin
      dx=cst.minSize & dy=cst.minSize
      if (dims.dimx gt dims.dimy) $
      then dy=round(cst.minSize*(dims.dimy/dims.dimx)) $
      else dx=round(cst.minSize*(dims.dimx/dims.dimy))
      miniPix=congrid(img,dx,dy)
      xmarg=round((cst.minSize-dx)/2.0)
      ymarg=round((cst.minSize-dy)/2.0)
   end
   uv={img:miniPix,xmarg:xmarg,ymarg:ymarg}
   widget_control,set_uvalue=uv,varAccess.pixmap
   widget_control,set_uvalue=opt,varAccess.options
   int_drawAxes,varAccess
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; 'PLOT' MENU EVENTS
;;; -+-+-+-+-+-+-+-+-+

function int_radial,win
;******* **********
@lamp.cbk
common didmod,IDdid ,wbuf,xbuf,ybuf,titx,tity

x20=xbuf & y20=ybuf & x_tit(20)=titx & y_tit(20)=tity
return,reform(wbuf)
end

pro int_plotMenu,varAccess,uv
;** ************
;**

   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=opt,varAccess.options
   if (uv(3) eq 0) then begin
      widget_control,get_uvalue=prev,varAccess.plots(uv(4))
      range=[min([set.r1,set.r2,prev.r(0)]),max([set.r1,set.r2,prev.r(1)])]
      int_updateRes,varAccess,uv(5),uv(6),uv(7)
      widget_control,get_uvalue=new,varAccess.plots(0)
      maxVal=max([max(prev.res),max(new.res)])
      widget_control,set_value=("Plotting..."),uv(5)
      int_plot,varAccess, new.res,round(range),opt.plotZone,1,maxVal  ,'X',uv(6),0
      int_plot,varAccess,prev.res,round(range),opt.plotZone,0,maxVal ,'X',uv(6),0
      widget_control,set_value=("Ready."),uv(5)
   end $
   else if (uv(3) eq 1) then begin
      widget_control,get_uvalue=IDs,varAccess.IDs
      widget_control,get_uvalue=temp,varAccess.plots(0)
      widget_control,set_uvalue=temp,varAccess.plots(uv(4))
      widget_control,/sensitive,IDs.menu(uv(4))
      widget_control,/sensitive,IDs.menu(uv(4)+2)
   end $
   else if (uv(3) eq 2) then begin
      widget_control,get_uvalue=toplot,varAccess.plots(uv(4))
;DID!!
;     odat=0 & range=0
;     temp=execute("odat=p"+NUMtSTR(uv(4),0))
;     temp=execute("range=p" + NUMtSTR(uv(4),0) + "r")
;     int_plot,varAccess,toplot.res,round(toplot.r),opt.plotZone,1,max(odat)      ,'X',uv(6),0
      int_plot,varAccess,toplot.res,round(toplot.r),opt.plotZone,1,max(toplot.res),'X',uv(6),0
   end $
   else if (uv(3) eq 3) then begin
;DID!!
      widget_control,get_uvalue=toplot,varAccess.plots(0)

      widget_control,get_uvalue=datpar,varAccess.datAccess.par
      widx=0 & cfil=''
      if n_elements(datpar) gt 1 then begin cfil=strtrim(datpar(0),2)
      					    widx=fix(datpar(1)) & endif
      psFile='radial'+cfil+'.ps'
      wplot=!D.name
      err=1
      on_ioerror,iferr
      if uv(6) eq 0 then begin
      	set_plot,'ps'
      	device,xsize=7.5,ysize=10.,yoffset=.75,xoffset=.5,/inches,/portrait
      	device,filename=psFile
      	device,bits_per_pixel=8,/color
	endif
      int_plot,varAccess,toplot.res,round(toplot.r),opt.plotZone,1,max(toplot.res),'PS',uv(6),0

      if uv(6) eq 0 then P_DID_PS_HEADER, 10. ,widx , psFile $
		    else XICUTE,'w20=int_radial(w'+strtrim(fix(widx),2)+') ;'+datpar(0)
      err=0
      iferr: if err eq 1 then device,/close_file
      set_plot,wplot
   end
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; SUB-PROCEDURES CALLED DURING INTEGRATION
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

function int_area,varAccess,bet1,bet2
;;;;; This function returns the minimum rectangle containing
;;;;; the sector between bet1 and bet2, and r1 and r2.
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   deg2rad=!pi/180.0
   r1=min([set.r1,set.r2],max=r2)
   temp=cos([bet1,bet2]*deg2rad)
   projx=[r1*temp,r2*temp]
   temp=sin([bet1,bet2]*deg2rad)
   projy=[r1*temp,r2*temp]
   left=min(projx)-1
   right=max(projx)+1
   top=max(projy)+1
   bottom=min(projy)-1
   if (bet1 lt 180) and (bet2 gt 180) then left=-(r2+1) $
   else if (bet1 gt bet2) then right=r2+1
   if (bet1 lt 90) and (bet2 gt 90) then top=r2+1 $
   else if (bet1 lt 270) and (bet2 gt 270) then bottom=-(r2+1)
   temp=round([max([0,left+set.cx]),min([dims.dimx-1,right+set.cx]), $
      max([0,bottom+set.cy]),min([dims.dimy-1,top+set.cy])])
   return,temp
end

function int_inZone,varAccess,x,y,a1,a2,r1,r2,mx,my
;;;;; This function tests if the point (x,y) is in the zone
;;;;; defined by the angles a1 and a2, and the radia r1 adn r2.
;;;;; It also verifies that (x,y) is not within the mask mx,my.
;;;;; If the point is in the zone and not masked, then the function
;;;;; returns the radius it belongs to; else, it returns -1.
   if ((abs(x) le mx) and (abs(y) le my)) then return,-1
   ray=round(sqrt(x^2+y^2))
   if ((ray lt r1) or (ray gt r2)) then return,-1
   angle=180.0*atan(y,x)/!pi
   if (angle lt 0) then angle=angle + 360.0
   if (a1 gt a2) then test=((angle lt a1) and (angle gt a2)) $
   else test=((angle lt a1) or (angle gt a2))
   if test then return,-1 $
   else return,ray
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; RADIAL INTEGRATION AND RESULT PLOTTING
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro int_updateRes,varAccess,labelID, logID ,didID
;;;;; This procedure first calls `int_changeCenter', to read the
;;;;; widget_text, in case the user forgot to type return to validate.
;;;;; Then the integration is done. When the result is obtained, it
;;;;; is plotted by calling the `int_plot' procedure.
   int_changeCenter,varAccess
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=data,varAccess.datAccess.w
   r1=min([set.r1,set.r2],max=r2)
   if (r1 eq r2) then if (r2 eq 0) then r2=1 else r1=r1-1
;   print,("alpha=" + NUMtSTR(set.alpha,0) + ", beta=" + $
;      NUMtSTR(set.beta,0) + ", r1=" + NUMtSTR(r1,0) + $
;      ", r2=" + NUMtSTR(r2,0))
   res=fltarr(2*dims.dim,2*set.zones)
   cur=set.alpha
   startTime=systime(1)
   for k=0,(set.zones-1) do begin
      if (labelID gt 0) then $
	 widget_control,set_value=("Sector #" + NUMtSTR(k+1,0)),labelID
      for p=0,1 do begin
	 numb=intarr(2*dims.dim)
	 sum=fltarr(2*dims.dim)
	 bet1=(cur-set.beta+360.0+p*180.0) mod 360
	 bet2=(cur+set.beta+p*180.0) mod 360
	 rect=int_area(varAccess,bet1,bet2)
	 for i=rect(0),rect(1) do $
	    for j=rect(2),rect(3) do begin
	       temp=int_inZone(varAccess,i-set.cx,j-set.cy, $
		  bet1,bet2,r1,r2,set.mx,set.my)
	       if (temp ge 0) then begin
		  sum(temp)=sum(temp)+data(i,j)
		  numb(temp)=numb(temp)+1
	       end
	    end
	 temp=where(numb eq 0,count)
	 if (count ne 0) then begin
	    numb(temp)=1
	    sum(temp)=-1
	 end
	 res(*,2*k+p)=sum/numb
      end
      cur=cur+set.gamma
   end
   int_time=systime(1)-startTime
   ;;; The current result is stored in plots(0)...
   widget_control,set_uvalue={res:res,r:[r1,r2]},varAccess.plots(0)
;  widget_control,/sensitive,IDs.menu(0)
   ;;; ... and then it is plotted.
   widget_control,bad_ID=bad,set_value=("Plotting..."),labelID
   int_plot,varAccess,res,round([r1,r2]),opt.plotZone,1,max(res) ,'X',0 ,didID
;;; !!!
;;;  TEST RADIES (A ENLEVER QUAND MEME, APRES...)
;;; !!!
;widget_control,bad_ID=bad,set_value=("RADIES..."),labelID
;res=fltarr(dims.dim,2*set.zones)
;cur=set.alpha
;startTime=systime(1)
;for k=0,(set.zones-1) do begin
;   for p=0,1 do begin
;      a1=(cur-set.beta+360.0+p*180.0) mod 360
;      a2=(cur+set.beta+p*180.0) mod 360
;      res(*,2*k+p)=radtst(data,set.cx,set.cy,r1,r2,a1,a2)
;   end
;   cur=cur+set.gamma
;end
;rad_time=systime(1)-startTime
;window,8,retain=2,title="Radies result",xsize=422,ysize=448
;maxVal=max(res)
;plot,[r1,r2],[0,maxVal],/nodata,xstyle=9,ystyle=9,color=0,background=255, $
;   xtitle='Radius (pixels)',ytitle='Mean value',pos=[.2,.1,.9,.9],charsize=1.2
;for k=0,(set.zones-1) do begin
;colors=120/max([1.0,(set.zones-1)])*indgen(set.zones)
;for k=0,(set.zones-1) do begin
;   oplot,res(*,2*k),color=colors(k),max_value=maxVal
;   oplot,res(*,2*k+1),color=colors(k),lineStyle=2, $
;end
;      thick=3,max_value=maxVal
;end
;if (int_time ge rad_time) then temp=[" ","*"] else temp=["*"," "]
;print,(temp(0) + " Intrad : " + NUMtSTR(int_time,2) + ' s')
;print,(temp(1) + " Radies : " + NUMtSTR(rad_time,2) + ' s')
;;; !!!
;;; !!!
   widget_control,bad_ID=bad,set_value=("Ready."),labelID
end

pro int_plot,varAccess,data,rays,test,new,maxVal ,XPS ,logID ,didID
;;;;; This procedure plots the data (result of an integration), with
;;;;; an xrange of `rays', and a maximum value equal to `maxVal'.
;;;;; If new is equal to 1, then the previous plot is erased. The
;;;;; `test' param is used to test if `data' is the major plot or not.
;;;;; This procedure is useful to plot several results, obtained with
;;;;; different angles and/or rays, in the same window.

common didmod,IDdid ,wbuf,xbuf,ybuf,titx,tity
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current


if n_elements(IDdid) eq 0 then IDdid=1
if didID ne 0 then IDdid=didID

   widget_control,get_uvalue=IDs   ,varAccess.IDs

;DID!! logID if =1 then output to a workspace

   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   if n_elements(datpar) gt 1 then mtit=datpar(0) else mtit=''

   temp=size(data)
   zones=temp(2)/2
   colors=120/max([1.0,(zones-1)])*indgen(zones)
   if XPS eq 'X' then wset,IDs.draw
   trap_current=IDs.draw
   
   modata=data
   if (rays(0) gt 0)	     then modata(0:rays(0)-1,*)		=1+maxVal
   temp=size(modata)
   if (rays(1) lt temp(1)-1) then modata(rays(1)+1:temp(1)-1,*) =1+maxVal

   if IDdid eq 1 then begin
     	ranx=rays
     	rany=[0,maxVal]+opt.logAspect*0.1
     	titx='Radius (pixels)'
   endif else begin
        div  =rays(1)-rays(0)+1
   	if (test and new) then begin
   		 didat=fltarr(zones*2+1)
   		 div  =rays(1)-rays(0)+1
      		 for k=0,(zones-1) do begin dat =modata(rays(0):rays(1),2*k)
      		 			    idx =where(dat lt 0,count)
      		 			    if count eq div then didat(k+1)=-1 else $
      		 			       didat(k+1)      = total(dat>0) / ((div-count)>1)
      		 			    dat =modata(rays(0):rays(1),2*k+1)
      		 			    idx =where(dat lt 0,count)
      		 			    if count eq div then didat(k+zones+1)=-1 else $
      		 			       didat(k+zones+1)= total(dat>0) / ((div-count)>1)  & endfor
     		 ranx =[1,zones*2]
   	endif else begin
   		 didat=fltarr(zones+1)
      		 for k=0,(zones-1) do begin dat =modata(rays(0):rays(1),2*k:2*k+1)
      		 			    idx =where(dat lt 0,count)
      		 			    if count eq 2*div then didat(k+1)=-1 else $
      		 			       didat(k+1)      = total(dat>0) /((2*div-count)>1) & endfor
     		 ranx =[1,zones]
   	endelse
   	maxd=max(didat)
     	rany=[0,maxd]+opt.logAspect*0.1
     	titx='Sectors'
   endelse

   tity='Mean value'

   if new and (not logID)  then begin
     if opt.logAspect ne 1 then begin
      if XPS eq 'X' then plot,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,color=0,$
      		xtitle=titx,ytitle=tity,pos=[.2,.1,.9,.9],background=255 $
      else		 plot,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,$
      		xtitle=titx,ytitle=tity,pos=[.2,.1,.9,.9],$
	        xticklen=1.,yticklen=1.,xgridstyle=1,ygridstyle=1,color=128
     endif else begin
      if XPS eq 'X' then plot_io,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,color=0,$
      		xtitle=titx,ytitle=tity+' LOG)',pos=[.2,.1,.9,.9],background=255 $
      else		 plot_io,ranx,rany,/nodata,xstyle=9,ystyle=9,title=mtit,$
      		xtitle=titx,ytitle=tity+' LOG)',pos=[.2,.1,.9,.9],$
	        xticklen=1.,yticklen=1.,xgridstyle=1,ygridstyle=1,color=128
     endelse
   endif

   if IDdid eq 1 then begin
    if (test and new) then begin
      if logID then begin  wbuf  =fltarr(rays(1)-rays(0),zones*2)
			   modata=modata(rays(0)+1:rays(1),*)
			   for k=0,(zones-1) do begin wbuf(0,k)      =modata(*,2*k)
						      wbuf(0,k+zones)=modata(*,2*k+1) & endfor
			   xbuf=findgen(rays(1)-rays(0))+rays(0)+1
			   ybuf=indgen (2*zones)+1 &  tity=tity+'/sectors'
      endif else begin
      	temp=where(modata lt 0,count)
      	if (count ne 0) then modata(temp)=2+maxVal
      	for k=0,(zones-1) do begin
	    oplot,modata(*,2*k)  ,color=colors(k),max_value=maxVal
	    oplot,modata(*,2*k+1),color=colors(k),max_value=maxVal,lineStyle=2,thick=3
      	endfor
      endelse
    endif else begin
      if logID then begin wbuf=fltarr (rays(1)-rays(0),zones)
			  xbuf=findgen(rays(1)-rays(0))+rays(0)+1
			  ybuf=indgen (zones) +1
			  if zones gt 1 then tity=tity+'/sectors' & endif
      for k=0,(zones-1) do begin
       datz=modata(*,2*k:2*k+1)
       temp=size(datz)
       for i=0,temp(1)-1 do $
	  if (datz(i,0) lt 0) then $
	     if (datz(i,1) lt 0) and (not logID) then datz(i,0)=2+maxVal $
	     else datz(i,0)=datz(i,1) $
	  else if (datz(i,1) ge 0) then datz(i,0)=(datz(i,0)+datz(i,1))/2.0
       if logID then wbuf(0,k)=datz(rays(0)+1:rays(1),0) else $
       if new   then oplot,datz(*,0),color=colors(k),max_value=maxVal $
      	        else oplot,datz(*,0),color=colors(k),max_value=maxVal,lineStyle=2,thick=2
      endfor
    endelse

   endif else begin
   	 if XPS eq 'X'then coco=0 else coco=128
         temp=where(didat lt 0,count)
         if (count ne 0) and (not logID) then didat(temp)=2+maxd
         if logID then begin wbuf=didat(1:*) & xbuf=findgen(ranx(1)-ranx(0)+1)+ranx(0)
			     ybuf=0          & endif else $
   	 if new then oplot,didat,color=coco,max_value=maxd $
   		else oplot,didat,color=coco,max_value=maxd,lineStyle=2,thick=2
   endelse
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; PARAMETER MODIFICATIONS
;;; -+-+-+-+-+-+-+-+-+-+-+-

pro int_updateMini,varAccess,ev,uv
;;;;; This procedure is called to respond to an event from
;;;;; an angle (alpha,beta or gamma) widget_slider.
   widget_control,get_uvalue=set,varAccess.settings
   if (uv(3) eq 0) then set.alpha=ev.value else $
   if (uv(3) eq 1) then begin
   			set.beta =ev.value
   			widget_control,uv(4),SET_SLIDER_MAX=(180/(ev.value>1))<36
   endif else begin
      set.gamma=ev.value
      uv(4)=set.gamma
      widget_control,set_uvalue=uv,ev.id
   endelse
   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_changeZone,varAccess,ev,gamID,openID
;;;;; Called when the '# of sectors' slider sends an event.
;;;;; If the value has not changed, the procedure return; if the
;;;;; new value is 2, then the gamma value stored in the gamma slider
;;;;; is restored. Then , Called when the '# of sectors' slider sends an event.
;;;;; If the value has not changed, the procedure return; if the
;;;;; new value is 2, then the gamma value stored in the gamma slider
;;;;; is restored. Then, the mini picture is updated.
   widget_control,get_uvalue=set,varAccess.settings
   if (ev.value eq set.zones) then return
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,set_uvalue=120/max([1.0,(ev.value-1)])* $
      indgen(ev.value),varAccess.colors
   set.gamma=180.0/ev.value
   set.zones=ev.value
   if (ev.value eq 2) then begin
      widget_control,/sensitive,gamID
      widget_control,get_uvalue=temp,gamID
      set.gamma=temp(4)
   end $
   else widget_control,sensitive=0,gamID
;DID!!
   widget_control,set_slider_max=round(90./ev.value),openID

   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_changeCenter,varAccess
;;;;; This procedure reads the four widget_texts, and updates
;;;;; the corresponding variables, and the mini picture.
;;;;; It is called by the 'updateRes' procedure, and when the
;;;;; return key is pressed within a widget_text.
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=set,varAccess.settings
   set.cx=BEN_READTEXT(IDs.cx)-1.0
   widget_control,set_value=NUMtSTR(set.cx+1.0,2),IDs.cx
   set.cy=BEN_READTEXT(IDs.cy)-1.0
   widget_control,set_value=NUMtSTR(set.cy+1.0,2),IDs.cy
   set.mx=BEN_READTEXT(IDs.mx)
   widget_control,set_value=NUMtSTR(set.mx,2),IDs.mx
   set.my=BEN_READTEXT(IDs.my)
   widget_control,set_value=NUMtSTR(set.my,2),IDs.my
   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_updateRay,varAccess,ev,x
;;;;; Updates the ray variables, and redraws the mini picture.
   widget_control,get_uvalue=set,varAccess.settings
   test=0
   if x then if (set.r2 eq ev.value) then test=1 else set.r2=ev.value $
   else if (set.r1 eq ev.value) then test=1 else set.r1=ev.value
   if test then return
   widget_control,set_uvalue=set,varAccess.settings
   int_drawAxes,varAccess
end

pro int_zonePlot,varAccess,test
;;;;; Called by the two-state button 'Separate symetrical sectors'
   widget_control,get_uvalue=opt,varAccess.options
   opt.plotZone=test
   widget_control,set_uvalue=opt,varAccess.options
   int_drawAxes,varAccess
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; LAMP-DATA LOADING
;;; -+-+-+-+-+-+-+-+-

function int_loadRequest,varAccess,wkn,w,x,y,n,p,par
;;;;; This function checks the size of the parameter `w'. If it
;;;;; is not a 2-dimension array, then it returns 0. If `w' is a
;;;;; 2-dimension array, it is loaded, and the radia, and center
;;;;; widgets and variables are modified. Then the mini picture
;;;;; is modified, and an integration is calculated.
   wkSize=size(w)
   if (wkSize(0) ne 2) then return,0
   widget_control,get_uvalue=oldims,varAccess.datAccess.dims
   int_loadData,varAccess,w,x,y,n,p,par,wkSize(1:2)
   ;int_numor,varAccess
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   wset,IDs.draw
   erase
   rapport=dims.dim/oldims.dim
   temp=1+round(sqrt(2)*dims.dim)
   set.r1=min([set.r1*rapport,temp])
   set.r2=min([set.r2*rapport,temp])
   widget_control,set_slider_max=temp,IDs.r1
   widget_control,set_value=set.r1,IDs.r1
   widget_control,set_slider_max=temp,IDs.r2
   widget_control,set_value=set.r2,IDs.r2
   set.cx=set.cx*float(wkSize(1))/oldims.dimx
   set.cy=set.cy*float(wkSize(2))/oldims.dimy
   widget_control,set_value=NUMtSTR(set.cx+1.0,2),IDs.cx
   widget_control,set_value=NUMtSTR(set.cy+1.0,2),IDs.cy
   widget_control,set_uvalue=set,varAccess.settings
   int_miniPix,varAccess,0
;  widget_control,sensitive=0,IDs.menu(0)
   widget_control,sensitive=0,IDs.menu(1)
   widget_control,sensitive=0,IDs.menu(2)
;DID!!   int_updateRes,varAccess,-1,-1,1
   return,1
end

pro int_loadData,varAccess,w,x,y,n,p,par,dims
;;;;; This procedure just writes its parameters in their
;;;;; appropriate place.
   widget_control,set_uvalue=w,varAccess.datAccess.w
   widget_control,set_uvalue=x,varAccess.datAccess.x
   widget_control,set_uvalue=y,varAccess.datAccess.y
   widget_control,set_uvalue=n,varAccess.datAccess.n
   temp=size(p)
   if (temp(0) ne 1) or (temp(1) ne 31) then p=fltarr(31)
   widget_control,set_uvalue=p,varAccess.datAccess.p
   widget_control,set_uvalue=par,varAccess.datAccess.par
   dims=float(dims)
   temp={dimx:dims(0),dimy:dims(1),dim:max(dims)}
   widget_control,set_uvalue=temp,varAccess.datAccess.dims
end

pro int_loadWorkspace,varAccess,k,labelID
;;;;; Tests if the workspace Wk has good dimensions. If it is
;;;;; the case, the procedure `int_loadRequest' is called. If the
;;;;; workspace does not fit dimension requirement, an error
;;;;; message is displayed in the widget_label `labelID'.
   temp=BEN_WK_SIZE(k)
   if (temp(0) ne 2) then begin
      widget_control,set_value=("'W" + NUMtSTR(k,0) + "' is invalid."),labelID
      print,string(7b)
      return
   end
   widget_control,set_value=("Loading 'W" + NUMtSTR(k,0) + "'."),labelID
   BEN_READ_WK,k,data,datx,daty,datn,datp,datpar
   temp=int_loadRequest(varAccess,k,data,datx,daty,datn,datp,datpar)
   widget_control,set_value="Ready.",labelID
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; INITIALIZATION OF DATA AND PROGRAM VARIABLES
;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

pro int_numor,varAccess
;;;;; The display of the numor is done only in the title bar,
;;;;; because there is no room left in the window !
;;;;; It is never used, because Px does not seem to contain
;;;;; the numor number.
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=cst,varAccess.constants
   if (datpar(0) le '') then res=cst.title $
   else res=(cst.title + '  (Numor #' +      datpar(0)    + ')')
;  else res=(cst.title + '  (Numor #' + NUMtSTR(datpar,0) + ')')
   widget_control,tlb_set_title=res,IDs.menu(0)
end

pro int_initData,varAccess,request
;;;;; Fill the data variables, according to `request'. If `request' is
;;;;; set to 1, the integration window was opened because of a
;;;;; request from the desk; the function must start with the
;;;;; requested data, stored in the common `ben_data'. So, if `request'
;;;;; is set to 1, those data are loaded; if it is set to 0, default
;;;;; data are loaded, by calling `int_defaultData'.
   widget_control,get_uvalue=cst,varAccess.constants
   common ben_data,wk,w,x,y,n,p,par
   if request then begin
      wkSize=size(w)
      if (wkSize(0) eq 2) $
      then int_loadData,varAccess,w,x,y,n,p,par,wkSize(1:2) $
      else int_defaultData,varAccess
   end else int_defaultData,varAccess
;;;;; The data is now stored. The startup settings can be declared.
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=set,varAccess.settings
   set.r1=dims.dim/6.0
   set.r2=dims.dim/2.0
   set.cx=(dims.dimx-1.0)/2.0
   set.cy=(dims.dimy-1.0)/2.0
   widget_control,set_uvalue=set,varAccess.settings
end

pro int_defaultData,varAccess
;;;;; This procedure is called to store the default data, when
;;;;; the integration function is not opened for a request.
   dimx=64.0
   dimy=64.0
   midx=(dimx-1.0)/2.0
   midy=(dimx-1.0)/2.0
   data=intarr(dimx,dimy)
   data(0:midx,0:midy)=0
   data(0:midx,midy+1:dimy-1)=1
   data(midx+1:dimx-1,midy+1:dimy-1)=2
   data(midx+1:dimx-1,0:midy)=3
   int_loadData,varAccess,data,indgen(dimx),indgen(dimy), $
      0,fltarr(31),0,[dimx,dimy]
end

function int_inits,test,x
;;;;; This function returns some default value for the parameter
;;;;; settings, or constants of the program.
@lamp.cbk
   if lamp_siz lt 800 then drS=384.0 else drS=448.0
   if lamp_siz lt 800 then miS=224.0 else miS=256.0
   initz=2.0
   case test of
      0:    res={minSize:miS,drawSize:drS,deg2rad:!pi/180, $
		 title:x}
      1:    res=120/max([1.0,(initz-1)])*indgen(initz)
      2:    res={logAspect:0,plotZone:0}
      3:    res={alpha:0.0,beta:30.0,gamma:180.0/initz,zones:initz, $
		 r1:0.0,r2:0.0,cx:0.0,cy:0.0,mx:0.0,my:0.0}
      else: res=0
   end
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;; WIDGET CREATION PROCEDURE
;;; -+-+-+-+-+-+-+-+-+-+-+-+-

pro ben_int_create,desk,n,m,base,request
@lamp.cbk
;;;;; Creation of the top-level base, and the top `command bar'.
   if (m eq 0) then winTitle=desk_name(n,1) $
   else winTitle=(desk_name(n,1) + " " + NUMtSTR(1+m,0))
   base=widget_base(title=winTitle,/column,group_leader=desk, $
	resource_name='lampben')
   topRow=widget_base(base,/row)
   comID=BEN_COMMANDS(topRow,n,[0,0])

;;;;; Creation of the widgets containing all the `common'
;;;;; variables used by the program. The IDs of those widgets
;;;;; are stored into the top-level base user-value.
   varBase  =widget_base(title=(winTitle + " vars"),map=0,group=base)
   datAccess=widget_base(varBase,/row)
   data	 =widget_label(datAccess,value="")
   datx	 =widget_label(datAccess,value="")
   daty	 =widget_label(datAccess,value="")
   datn	 =widget_label(datAccess,value="")
   datp	 =widget_label(datAccess,value="")
   datppp=widget_label(datAccess,value="")
   dims	 =widget_label(datAccess,value="")
   dat={w:data,x:datx,y:daty,n:datn,p:datp,par:datppp,dims:dims}
   constants=int_inits(0,winTitle)
   options=int_inits(2)
   set	 =widget_label(varBase,value="",uvalue=int_inits(3))
   opt	 =widget_label(varBase,value="",uvalue=options)
   cst	 =widget_label(varBase,value="",uvalue=constants)
   IDs	 =widget_label(varBase,value="")
   col	 =widget_label(varBase,value="",uvalue=int_inits(1))
   pix	 =widget_label(varBase,value="")
   p0	 =widget_label(varBase,value="",uvalue=0)
   p1	 =widget_label(varBase,value="",uvalue=0)
   p2	 =widget_label(varBase,value="",uvalue=0)
   varAccess={datAccess:dat,settings:set,options:opt,constants:cst, $
      IDs:IDs,colors:col,pixmap:pix,plots:[p0,p1,p2]}
   widget_control,set_uvalue=varAccess,base
   int_initData,varAccess,request
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=temp,varAccess.datAccess.dims
   dim=temp.dim

;;;;; The main draw window, to plot the integration result.
;;;;; If the screen ysize is lower than 900 pixels, then the window
;;;;; is created horizontal; otherwise, it has a more vertical aspect.
   if (lamp_siz lt 1000) then begin
      temp=widget_base(base,/row)
      settings=widget_base(temp,/row,/frame)
      result=widget_draw(temp,retain=2, $
	 xsize=constants.drawSize*(constants.drawSize/503.37),ysize=constants.drawSize)
   end else begin
      result=widget_draw(base,  xsize=constants.drawSize*(constants.drawSize/503.37),  $
      				ysize=constants.drawSize,retain=2)
      settings=widget_base(base,/row,/frame)
   end

;;;;; Creation of the column of sliders for setting angles and rays.
   sliders=widget_base(settings,/column,xsize=constants.minSize/2.0)
	   put_logo   ,widget_base(sliders,/row)
   asl=widget_slider(sliders,value=set.alpha,title="Total rotation", $
      min=0,max=90,       uvalue=[-88,412,n,0],/drag)
   gsl=widget_slider(sliders,value=set.gamma,title="Single rotation", $
      min=0,max=90,       uvalue=[-88,412,n,2,set.gamma],/drag)
   bsl=widget_slider(sliders,value=set.beta,title="Opening", $
      min=0,max=45,       uvalue=[-88,412,n,1,0L],/drag)
   zoneID=widget_slider(sliders,value=set.zones,title="# of sectors", $
      min=1,max=8,        uvalue=[-88,407,n,gsl,bsl],/drag)
   widget_control,bsl,set_uvalue=[-88,412,n,1,zoneID]
   r1ID=widget_slider(sliders,value=set.r1,title="Inner radius", $
      min=0,max=1+round(sqrt(2)*dim),uvalue=[-88,406,n,0],/drag)
   r2ID=widget_slider(sliders,value=set.r2,title="Outer radius", $
      min=0,max=1+round(sqrt(2)*dim),uvalue=[-88,406,n,1],/drag)

;;;;; The right column contains the mini draw window, where
;;;;; zones are represented, and the fields for center and
;;;;; mask settings, plus the plots buttons.
   others=widget_base(settings,/column)
   plots=widget_base(others,/row)
   mini=widget_draw(widget_base(others),retain=2, $
        xsize=constants.minSize,ysize=constants.minSize)

;;; Toggle button to set the mini to logAspect or not
   logBtn=widget_button(widget_base(plots,/nonexclusive), $
			value="Log aspect",uvalue=[-88,408,n,0])

   update=widget_button(plots,value="I(R)",uvalue=[-88,411,n,comID(7),logBtn,1], $
          font=ft_b_normal)
   update=widget_button(plots,value="I(S)",uvalue=[-88,411,n,comID(7),logBtn,2], $
          font=ft_b_normal)
;;; Creation of the 'plot' menu.
   menuID=intarr(5)
   menuID(0)=widget_button(plots      ,value="Plot",menu=2)
   temp     =widget_button(menuID(0)  ,value="Over last plot", $
      	     					uvalue=[-88,405,n,0,0,comID(7),logBtn,0])
   menuID(1)=widget_button(menuID(0)  ,value="Over plot #1", $
      	     					uvalue=[-88,405,n,0,1,comID(7),logBtn,0])
   menuID(2)=widget_button(menuID(0)  ,value="Over plot #2", $
      	     					uvalue=[-88,405,n,0,2,comID(7),logBtn,0])
   temp     =widget_button(menuID(0)  ,value="Into Mem 1",uvalue=[-88,405,n,1,1])
   temp     =widget_button(menuID(0)  ,value="Into Mem 2",uvalue=[-88,405,n,1,2])
   menuID(3)=widget_button(menuID(0)  ,value="Plot Mem 1",uvalue=[-88,405,n,2,1])
   menuID(4)=widget_button(menuID(0)  ,value="Plot Mem 2",uvalue=[-88,405,n,2,2])
;DID!!
   temp     =widget_button(menuID(0)  ,value=" ")
   temp     =widget_button(menuID(0)  ,value="To PS File...",uvalue=[-88,405,n,3,0,comID(7),0,0])
   temp     =widget_button(menuID(0)  ,value="To Wsp W20",uvalue=[-88,405,n,3,0,comID(7),1,0])

;;; Creation of the center and mask widget_texts.
   temp=widget_base(others,/row)
   temp_lab=widget_label(temp,value="Cx = ")
   cxID=widget_text(temp,value=NUMtSTR(set.cx+1.0,2),/editable, $
      /no_newline,uvalue=[-88,409,n],xsize=6,font=ft_b_bigger)
   temp_lab=widget_label(temp,value="Cy = ")
   cyID=widget_text(temp,value=NUMtSTR(set.cy+1.0,2),/editable, $
      /no_newline,uvalue=[-88,409,n],xsize=6,font=ft_b_bigger)
   temp=widget_base(others,/row)
   temp_lab=widget_label(temp,value="Mask X:")
   mxID=widget_text(temp,value=NUMtSTR(set.mx,2),uvalue=[-88,409,n], $
      /editable,/no_newline,xsize=5,font=ft_b_bigger)
   temp_lab=widget_label(temp,value=" Y:")
   myID=widget_text(temp,value=NUMtSTR(set.my,2),uvalue=[-88,409,n], $
      /editable,/no_newline,xsize=5,font=ft_b_bigger)
   plotBtn=widget_button(widget_base(others,/nonexclusive), $
      value="Separate Symetrical Sectors",uvalue=[-88,410,n])

;;;;; All the widgets have been declared. The two-state buttons
;;;;; are now set to their correct value, widget IDs are stored,
;;;;; some widgets are made non-sensitive (the plot menu), and
;;;;; the xmanager is called.
   bid=sys_dep      ('DYNLAB',base,1)
   widget_control,/realize,base & put_logo
   widget_control,set_button=options.plotZone,plotBtn
   widget_control,set_button=options.logAspect,logBtn
   widget_control,get_value=minID,mini
   widget_control,get_value=drawID,result
   uv={menu:menuID,cx:cxID,cy:cyID,mx:mxID,my:myID, $
      r1:r1ID,r2:r2ID,draw:drawID,mini:minID}
   widget_control,set_uvalue=uv,varAccess.IDs
   for i=1,4 do widget_control,sensitive=0,menuID(i)
   int_numor,varAccess
   int_miniPix,varAccess,0
   widget_control,set_value="<- You must load W",comID(7)
   xmanager,desk_name(n,0),base,event_handler="lamp_event_parser",/just_reg
end


;;; ***************************************************************************
;;; ***				 SPECTRA GROUPING			    ***
;;; ***************************************************************************

pro rgp_event,ev,uv
   widget_control,get_uvalue=varAccess,ev.top
   case uv(1) of
      400:  begin wait,.05 & widget_control,/destroy,ev.top & end
      401:  BEN_CHANGE_WORKSPACE,uv
      402:  rgp_help,varAccess,ev.top
      403:  rgp_loadWorkspace,varAccess,uv(3),uv(4)
      404:  rgp_writeWorkspace,varAccess,uv(3)
      405:  rgp_mask_event,varAccess,ev
      406:  rgp_toggleBtn,varAccess,ev.select,uv(3)
      407:  rgp_changeMax,varAccess,ev.value,ev.drag,uv(3),uv(4)
      408:  begin
      		rgp_writeMask,varAccess,uv(3)
      		widget_control,bad_id=i,ev.id,get_value=labut
      		labut=strlowcase(labut)
      		widget_control,bad_id=i,ev.id,set_value=labut
      	    end
      409:  begin
      		rgp_loadMask,varAccess,uv(3)
      		widget_control,bad_id=i,ev.id,get_value=labut
      		labut=strlowcase(labut)
      		widget_control,bad_id=i,ev.id,set_value=labut
      	    end
      410:  rgp_groupNum,varAccess,ev.value,1
      411:  rgp_writeWorkspace,varAccess,-1
      412:  rgp_toggleExport,varAccess,ev.select,uv(3),uv(4)
      else: print,"RGP_EVENT:",uv
   end
end

function rgp_testModule,x
;;;;; This function returns the value of 'singleRun' for the grouping
;;;;; function. Also it could be run several times, it is limited to
;;;;; only one value, because several ones should be confusing.
   return,1
end

pro rgp_help,varAccess,base
   print,"HELP WANTED"
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

function mask,x,apMask
@lamp.cbk
;;;;; This function is to be used as a macro; its syntax is:
;;;;;		  Wi=mask(Wj,m), or Wi=mas(j,m)
;;;;; where `m' is the number of a mask (from 1 to 4)
;;;;; The masks are stored into the 'rgp_lampmask' common.
   common rgp_lampmask,mask1,mask2,mask3,mask4
   temp=execute("destwk=w" + NUMtSTR(one,0))
   temp=size(x)
;;;;; If x is not a number, try the common variable `two'
;;;;; `two' contains a non-zero number when user calls `wi = mask(wj,m)'
   if ((temp(0) ne 0) or (temp(1) gt 4)) then wk=two $
   else wk=x
   if ((wk le 0) or (wk gt 20)) then return,destwk
   temp=BEN_WK_SIZE(wk)
   if (temp(0) ne 2) then return,destwk
   dimx=temp(1)
   dimy=temp(2)
   BEN_READ_WK,wk,work,datx,daty,datn,datp,datpar
   temp=execute("apMask=mask" + NUMtSTR(apMask,0))
   temp=size(apMask)
   if (temp(0) ne 1) then return,destwk
   maskSize=temp(1)
   if (dimy ne maskSize) then $
      if (dimy gt maskSize) then begin
	 expMask=intarr(dimy)
	 expMask(0:maskSize-1)=apMask
	 apMask=expMask
      end
   rgp_applyMask,work,daty,apMask,ind,res,resy
   if (ind lt 0) then return,destwk
   res=res(*,0:ind)
;  datp(30)=ind+1
   BEN_WRITE_WK,one,res,datx,resy(0:ind),datn,datp,datpar
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_loadMask,varAccess,x
;;;;; This porcedure is called by one of the 'load mask' button.
;;;;; It reads one of the four mask stored in the common, and
;;;;; uses it for the current mask. It calls the imask procedure
;;;;; that updates the display and the grouping. Then the infos
;;;;; about the spectra are updated too.
   common rgp_lampmask,mask1,mask2,mask3,mask4
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   newMask=''
   temp=execute("newMask=mask" + NUMtSTR(x,0))
   temp=size(newMask)
   if (temp(0) ne 1) then return
   last=-1
   cur=intarr(dims.x,dims.y)
   cur(*,*)=1
   for i=0,min([dims.y,temp(1)])-1 do cur(*,i)=newMask(i)
   widget_control,set_uvalue={cur:cur,last:-1},varAccess.mask
   rgp_imask,varAccess,[-1],0,0
   rgp_info,varAccess,1
end

pro rgp_writeMask,varAccess,x
;;;;; This procedure writes the current mask in the 'Mx' variable
;;;;; of the rgp_lampmask common.
   common rgp_lampmask,mask1,mask2,mask3,mask4
   widget_control,get_uvalue=mask,varAccess.mask
   temp=execute("mask" + NUMtSTR(x,0) +"=reform(mask.cur(0,*))")
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_numor,varAccess
;;;;; This procedure is called at startup, and when loading a new
;;;;; workspace, to display the numor in the window title and on
;;;;; a label.
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   widget_control,get_uvalue=IDs,varAccess.IDs
   if (datpar(0) eq '') then temp=' ' $
   else temp=datpar (0)

   widget_control,set_value=temp,IDs.numor
   if (temp eq ' ') then temp='' $
   else temp=('  (Numor:' + temp + ')')
   widget_control,tlb_set_title=(cst.title + temp),IDs.numor
end

pro rgp_loadData,varAccess,wkn,w,x,y,n,p,par,dims
;;;;; This procedure just writes its parameters in their
;;;;; appropriate place.
   widget_control,set_uvalue=w  ,varAccess.datAccess.w
   widget_control,set_uvalue=x  ,varAccess.datAccess.x
   widget_control,set_uvalue=y  ,varAccess.datAccess.y
   widget_control,set_uvalue=n  ,varAccess.datAccess.n
   temp=size(p)
   if (temp(0) ne 1) or (temp(1) ne 31) then p=fltarr(31)
   widget_control,set_uvalue=p,varAccess.datAccess.p
   widget_control,set_uvalue=par,varAccess.datAccess.par
   temp={x:dims(0),y:dims(1)}
   widget_control,set_uvalue=temp,varAccess.datAccess.dims
   varAccess.datAccess.wkn=wkn
end


function rgp_loadRequest,varAccess,wk,w,x,y,n,p,par
;;;;; This function is called by the desk, or by the 'loadWorkspace'
;;;;; procedure, to make its parameters the current data. First,
;;;;; the procedure checks the data is a 2-dimensional array, and
;;;;; then the other parameters are also checked, and replaced or
;;;;; modified if needed. All variables are updated if needed, and so
;;;;; is the display and the grouping.
;;;;; The value returned by this function is 1 if the data were
;;;;; correctly loaded, 0 if there was a problem, such as trying to
;;;;; load a 'bad sized' workspace.
   wksize=size(w)
   if (wksize(0) ne 2) then return,0
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   dims.x=wksize(1)
   dims.y=wksize(2)
   cur=intarr(dims.x,dims.y)
   cur(*,*)=1
   oldMax=max(data)
   temp=size(x)
   if ((temp(0) ne 1) or (temp(1) ne dims.x)) then x=indgen(dims.x)
   temp=size(y)
   if ((temp(0) ne 1) or (temp(1) ne dims.y)) then y=indgen(dims.y)
   temp=size(p)
   if ((temp(0) ne 1) or (temp(1) ne 31)) then begin
      p=fltarr(31)
      p(30)=dims.y
   end
;;;;; All the parameters have been checked. The data are stored,
;;;;; and some variables are modified.
   rgp_loadData,varAccess,wk,w,x,y,n,p,par,wkSize(1:2)
   temp=max(w)
   widget_control,get_uvalue=uv,IDs.maxSlider
   uv(3)=temp
   widget_control,set_uvalue=uv,IDs.maxSlider
   rgp_changeMax,varAccess,-1,1,temp,uv(4)
   widget_control,set_slider_max=max([2,dims.y/2]),IDs.gpSlider
   widget_control,sensitive=(dims.y ge 2),get_value=ng,IDs.gpSlider
   widget_control,set_uvalue={cur:cur,last:-1},varAccess.mask
;;;;; The numor, the infos, grouping and display are updated.
   rgp_numor,varAccess
   rgp_info,varAccess,0
   rgp_groupNum,varAccess,ng,0
   rgp_imask,varAccess,[-1],1,1
   return,1
end

pro rgp_loadWorkspace,varAccess,wk,labelID
;;;;; This procedure simply calls the loadRequest function, but it
;;;;; displays messages in its parent window if the loading failed.
   wksize=BEN_WK_SIZE(wk)
   if (wksize(0) ne 2) then begin
      widget_control,set_value=("'W" + NUMtSTR(wk,0) + "' is invalid."),labelID
      print,string(7b)
      return
   end
   widget_control,set_value=("Loading 'W" + NUMtSTR(wk,0) + "'."),labelID
   BEN_READ_WK,wk,w,x,y,n,p,par
   temp=rgp_loadRequest(varAccess,wk,w,x,y,n,p,par)
   widget_control,set_value=' ',labelID
end

pro rgp_writeWorkspace,varAccess,x
;;;;; This procedure first transforms the current data by applying
;;;;; the mask and grouping the spectra, and then output the result
;;;;; either to the LAMP workspace Wx if x is greater than 0, or to
;;;;; the 'Scroll Spectra' function.
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=datx,varAccess.datAccess.x
   widget_control,get_uvalue=daty,varAccess.datAccess.y
   widget_control,get_uvalue=datn,varAccess.datAccess.n
   widget_control,get_uvalue=datp,varAccess.datAccess.p
   widget_control,get_uvalue=datpar,varAccess.datAccess.par
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=grp,varAccess.groups
   widget_control,get_uvalue=mask,varAccess.mask
   if opt.mApply then $
   ;;;;; If the user wants to apply the mask, ...
      if opt.doGroup then begin
      ;;;; ... and also group the spectra.
	 work=data*mask.cur
	 temp=size(grp.index)
	 ind=temp(1)-1
	 res=fltarr(dims.x,ind)
	 for i=0,ind-1 do begin
	    temp=where(mask.cur(0,grp.index(i):grp.index(i+1)-1) ne 0,count)
	    if (count eq 1) then res(*,i)=work(*,grp.index(i)) $
	    else if (count gt 0) then $
	       res(*,i)=total(work(*,grp.index(i):grp.index(i+1)-1),2)/count
	 end
	 resy=grp.sinAver
	 newp=datp
;	 newp(30)=ind-1
      end else begin
      ;;; ... but not do the grouping, applyMask is called.
	 rgp_applyMask,data,daty,reform(mask.cur(0,*)),ind,res,resy
	 newp=datp
;	 datp(30)=ind+1
      end $
   else begin
      res=data
      resy=daty
      newp=datp
   end
   if (x gt 0) then begin
   ;;;;; If the output is a workspace, the workspace and its linked
   ;;;;; variables are stored, and the history is updated.
;DID!!
   if n_elements(datpar) ge 2 then from='w'+ strtrim(datpar(1),2) $
   			      else from='w'+ NUMtSTR(varAccess.datAccess.wkn,0)
   too='w'+ NUMtSTR(x,0)
   xicute,too+'=groupp('+from+')'

   BEN_WRITE_WK,x,res,datx,resy,datn,newp,datpar
   TO_DON_HISTORY,x,0,too + '=mask(' + from + ')'

   end else begin
   ;;;;; The procedure request a 'df' (ie Scroll Spectra) from the
   ;;;;; desk. If the 'Scroll Spectra' procedures are present, a new
   ;;;;; window will be opened with the parameters if possible, or
   ;;;;; the data will be loaded by an already opened window.
      temp=desk_loadRequest('df',varAccess.datAccess.wkn,res,datx,resy, $
	 datn,newp,datpar)
      if (temp eq 0) then print,"Failed."
   end
end

function groupp, w_in
;******* ******
;DID!!
	w_out=bytarr(2,2)
return, w_out
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_mask_event,varAccess,ev
;;;;; This is the procedure called by the widget_draw when the mouse is
;;;;; used inside it. It calls the imask procedure to modify the
;;;;; current mask, and to update everything.
   if (ev.type ne 0) then return
   widget_control,get_uvalue=dim,varAccess.datAccess.dims
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=mask,varAccess.mask
   spec=min([dim.y*(cst.dimy-cst.borm(3)-ev.y)/ $
      (cst.dimy-cst.borm(1)-cst.borm(3)),dim.y-1])
   if (ev.x gt (cst.dimx-cst.borm(2))) then return
   if ((mask.last lt 0) or (ev.press eq 1)) $
   then rgp_imask,varAccess,[spec],0,0 $
   else rgp_imask,varAccess,[spec,mask.last],0,0
   widget_control,get_uvalue=mask,varAccess.mask
   mask.last=spec
   widget_control,set_uvalue=mask,varAccess.mask
   rgp_info,varAccess,1
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_info,varAccess,test
;;;;; Called to update the two info labels. The first one contains info
;;;;; about the masked spectra. The second label is updated only if
;;;;; `test' is set to one, and contains info about the total number
;;;;; of spectra in the current data.
   widget_control,get_uvalue=msk,varAccess.mask
   widget_control,get_uvalue=IDs,varAccess.IDs
   temp=where(msk.cur(0,*) eq 0,count)
   case count of
      0:    temp='None masked.'
      1:    temp='One  masked.'
      else: temp=(NUMtSTR(count,0) + ' masked.')
   end
   widget_control,set_value=temp,IDs.info(1)
   if test then return
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   temp=('Dim='+NUMtSTR(dims.y,0))
   widget_control,set_value=temp,IDs.info(0)
end

pro rgp_changeMax,varAccess,x,drag,dataMax,labelID
;;;;; This procedure is called by the 'maximum value' slider, when it's
;;;;; moved. A value is displayed in a label beside the slider, to
;;;;; simulate a non-linear slider. The display is updated only when
;;;;; the slider is released (`drag' is set to 0).
   widget_control,get_uvalue=set,varAccess.settings
   if (x lt 0)  then begin x=set.maxVal & y=dataMax
   endif	else	   y=dataMax*(float(x)/100.0)^2
   widget_control,set_value=NUMtSTR(y,0),labelID
   if drag then return
   set.maxVal=y
   widget_control,set_uvalue=set,varAccess.settings
   rgp_imask,varAccess,[-1],0,1
end

pro rgp_toggleBtn,varAccess,x,test
;;;;; This procedure handles the two toggle buttons. It modifies the
;;;;; correct variable/uservalue.
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.hideMask=x $
   else opt.logAspect=x
   widget_control,set_uvalue=opt,varAccess.options
   rgp_imask,varAccess,[-1],0,1
end

pro rgp_toggleExport,varAccess,x,test,btnID
;;;;; This procedure modifies the variables concerning the output.
   widget_control,get_uvalue=opt,varAccess.options
   if test then opt.mApply=x $
   else opt.doGroup=x
;DID!
;  if test then widget_control,sensitive=x,btnID
   widget_control,set_uvalue=opt,varAccess.options
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_imask,varAccess,n,eras,redrw
;;;;; This procedure modifies the mask: it masks/unmasks the spectra
;;;;; n(0) to n(1), depending if n(0) is already maked or not. It then
;;;;; replots the column showing the mask, updates the data display
;;;;; if the opt.hideMask is set to 1. The new grouping is also
;;;;; calculated, and the new groups displayed on the right.
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=mask,varAccess.mask
   if ((n(0) ge 0) and (n(0) lt dims.y)) then begin
      if mask.cur(0,n(0)) then temp=0 else temp=1
      for i=min(n),max(n) do mask.cur(*,i)=temp
   end
   widget_control,set_uvalue=mask,varAccess.mask
   rgp_groupNum,varAccess,-1,0
   wset,IDs.mask
   if eras then erase
   if ((opt.hideMask eq 0) or redrw) then begin
      if opt.hideMask then temp=(data<set.maxVal) $
      else temp=(data<set.maxVal)*mask.cur
      if opt.logAspect then temp=alog(1+temp)
      tempx=cst.dimx-cst.borm(0)-cst.borm(2)
      tempy=cst.dimy-cst.borm(1)-cst.borm(3)
      temp=congrid(temp,tempx,tempy)

      tvscl,temp,cst.borm(0),cst.borm(1),order=opt.tvOrder
   end $
   else tempy=cst.dimy-cst.borm(1)-cst.borm(3)
   sSel=cst.borm(0)/3
   temp=110-39*mask.cur(0,*)
   tv,congrid(temp,cst.borm(0)-sSel,tempy),sSel,cst.borm(1),order=opt.tvOrder
   if (n(0) ge 0) then temp(n(0))=-1 $
   else if (mask.last ge 0) then temp(mask.last)=-1
   tv,congrid(temp,sSel,tempy),0,cst.borm(1),order=opt.tvOrder
   rgp_drawGroups,varAccess
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_applyMask,win,yin,cur,ind,res,resy
;;;;; This procedure applies the mask `cur' to the `Win' spectra, and
;;;;; also modifies the angles contained in `Yin'. The results are
;;;;; returned into `res' and `resy'.
   wkSize=size(win)
   ind=-1
   res=fltarr(wkSize(1),wkSize(2))
   resy=fltarr(wkSize(2))
   for i=0,wkSize(2)-1 do $
      if cur(i) then begin
	 ind=ind+1
	 res(*,ind)=win(*,i)
	 resy(ind)=yin(i)
      end
   if (ind lt 0) then return
   res=res(*,0:ind)
   resy=resy(0:ind)
end

pro rgp_groupNum,varAccess,n,disp
;;;;; This procedure calculates the groupings.
;;;;; The range of unmasked angles is searched, and then the list of
;;;;; the sinus of the half-angles is divided into `n' parts, which
;;;;; are of the same width. If a part is empty, ie it does not include
;;;;; any spectrum, it is removed. In a part, the `average' angle is
;;;;; set to the mean value of its limits, and not to the mean of
;;;;; the angles corresponding to the spectra. The 'grouped' spectrum
;;;;; is the average of all the included spectra.
   widget_control,get_uvalue=set,varAccess.settings
   if (n lt 0) then n=set.ngroups $
   else if (set.ngroups eq n) then return $
   else set.ngroups=n
   widget_control,get_uvalue=mask,varAccess.mask
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=daty,varAccess.datAccess.y
   msk=reform(mask.cur(0,*))
   temp=where(msk ne 0,usedCount)
   if (usedCount le 0) then return
   widget_control,set_uvalue=set,varAccess.settings
   sinList=1000*sin(!pi*msk*daty/360.0)
   temp=where((daty eq 0) and (msk ne 0),count)
   if (count gt 0) then begin
      minSub=min(temp)
      infVal=0
   end else begin
      minSub=min(where(sinList gt 0))
      infVal=sinList(minSub)
   end
   aver=(max(sinList,maxSub)-infVal)/n
   index=intarr(n+1)
   sinAver=(360.0/!pi)*asin(aver/1000*(findgen(n)+0.5))
   index(0)=minSub
   for i=1,n-1 do begin
      infVal=infVal + aver
      temp=where(sinList gt infVal,count)
      if (count ne 0) then index(i)=min(temp) $
      else index(i)=index(i-1)
   end
   index(n)=maxSub+1
   ind=0
   ;;;;; The empty parts are now removed.
   for i=1,n do $
      if (index(i) ne index(ind)) then begin
	 ind=ind+1
	 index(ind)=index(i)
	 sinAver(ind-1)=sinAver(i-1)
      end
   if (ind eq 0) then return
   index=index(0:ind)
   sinAver=sinAver(0:ind-1) + min(daty) ;DID!
   ;;;;; The info label is updated.
   if (ind eq 1) then res='One group.' $
   else res=(NUMtSTR(ind,0) + ' groups.')
   temp=n-ind
   if (temp ne 0) then begin
      if (temp eq 1) then temp='(-1)' $
      else temp=('(-'+NUMtSTR(temp,0) + ')')
      res=(res + temp)
   end
   widget_control,set_value=res,IDs.info(2)
   widget_control,set_uvalue={index:index,sinAver:sinAver},varAccess.groups
   ;;;;; The display is updated if `disp' is set to 1.
   if disp then rgp_drawGroups,varAccess
end

pro rgp_drawGroups,varAccess
;;;;; This procedure just draws the left-most ribbon in the display
;;;;; area, to represent the current groups.
   widget_control,get_uvalue=cst,varAccess.constants
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=grp,varAccess.groups
   widget_control,get_uvalue=msk,varAccess.mask
   widget_control,get_uvalue=IDs,varAccess.IDs
   widget_control,get_uvalue=opt,varAccess.options
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   tempy=cst.dimy-cst.borm(1)-cst.borm(3)
   if (set.ngroups gt 0) then begin
      res=110+intarr(1,dims.y)
      temp=size(grp.index)
      for i=1,temp(1)-1 do begin
	 col=35+ 36*(-1)^i
	 for j=grp.index(i-1),grp.index(i)-1 do $
	    if msk.cur(0,j) then res(0,j)=col
      end
   end else begin
      res=intarr(cst.borm(2),cst.borm(2))
      for i=0,cst.borm(2)-1 do begin
	 res(i,i)=1
	 res(i,cst.borm(2)-i-1)=1
      end
   end
   wset,IDs.mask
   tv,congrid(res,cst.borm(2),tempy),cst.dimx-cst.borm(2), $
      cst.borm(1),order=opt.tvOrder
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro rgp_initData,varAccess,request
;;;;; Fill the data variables, according to `request'. If `request' is
;;;;; set to 1, the function window was opened because of a
;;;;; request from the desk; the function must start with the
;;;;; requested data, stored in the common `ben_data'. So, if `request'
;;;;; is set to 1, those data are loaded; if it is set to 0, default
;;;;; data are loaded, by calling `rgp_defaultData'.
   widget_control,get_uvalue=cst,varAccess.constants
   common ben_data,wk,w,x,y,n,p,par
   if request then begin
      wkSize=size(w)
      if (wkSize(0) eq 2) $
      then rgp_loadData,varAccess,wk,w,x,y,n,p,par,wkSize(1:2) $
      else rgp_defaultData,varAccess
   end else rgp_defaultData,varAccess
;;;;; The data is now stored. The startup settings can be declared.
   widget_control,get_uvalue=dims,varAccess.datAccess.dims
   widget_control,get_uvalue=data,varAccess.datAccess.w
   set={maxVal:100L,ngroups:max([2,dims.y/2])}
   mask={cur:(intarr(dims.x,dims.y)+1),last:-1}
   widget_control,set_uvalue=set,varAccess.settings
   widget_control,set_uvalue=mask,varAccess.mask
end

pro rgp_defaultData,varAccess
;;;;; This procedure is called to store the default data, when
;;;;; this function is not opened for a request.
   dimx=64
   dimy=64
   data=dist(dimx,dimy)
   rgp_loadData,varAccess,0,data,indgen(dimx),indgen(dimy), $
      0,fltarr(31),0,[dimx,dimy]
end

function rgp_inits,test,x
;;;;; This function is used for variable initialization.
@lamp.cbk
if lamp_siz lt  800 then xxx=384. else xxx=512.
if lamp_siz lt 1000 then yyy=320. else yyy=384.
if lamp_siz lt  800 then yyy=256. else yyy=384.
   case test of
      0:    res={dimx:xxx   ,dimy:yyy*3 ,borm:[24,0,24,0],title:x}
      1:    res={logAspect:1,hideMask:0,tvOrder:1,mApply:1,doGroup:0}
      else: res=0
   end
   return,res
end

;;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

pro ben_rgp_create,desk,n,m,base,request
@lamp.cbk
;;;;; This the procedure called by the LAMP Desktop to create a new
;;;;; window. `n' is the item 2 of the widgets user value. Is is used
;;;;; by P_BEN_EVENT to select which function the incoming events must
;;;;; be sent too. `m' is used only for the title. `base' is an output
;;;;; variable, used to return the new window ID number. If the window
;;;;; is created to respond to another function request, then `request'
;;;;; is set to 1, so the function will inits its data using the
;;;;; variables stored in the 'ben_data' common.
   if (m eq 0) then winTitle=desk_name(n,1) $
   else winTitle=(desk_name(n,1) + ' ' + NUMtSTR(1+m,0))
   base=widget_base(title=winTitle,/column,group_leader=desk, $
		    resource_name="lampben")
   topRow=widget_base(base,/row)
   comID=BEN_COMMANDS(topRow,n,[0,0])
   widget_control,set_value="<-- You must load W",comID(7)
;;;;; Creation of the widget_label containing all the variables.
   datAccess=widget_base(topRow,/row)
   data	 =widget_label(datAccess,value="")
   datx	 =widget_label(datAccess,value="")
   daty	 =widget_label(datAccess,value="")
   datn	 =widget_label(datAccess,value="")
   datp	 =widget_label(datAccess,value="")
   datppp=widget_label(datAccess,value="")
   dims	 =widget_label(datAccess,value="")
   dat={w:data,x:datx,y:daty,n:datn,p:datp,par:datppp,dims:dims,wkn:0}
   constants=rgp_inits(0,winTitle)
   options=rgp_inits(1)
   set	 =widget_label(topRow,value="")
   opt	 =widget_label(topRow,value="",uvalue=options)
   cst	 =widget_label(topRow,value="",uvalue=constants)
   IDs	 =widget_label(topRow,value="")
   mask	 =widget_label(topRow,value="")
   grp	 =widget_label(topRow,value="")
   varAccess={datAccess:dat,settings:set,options:opt,constants:cst, $
      IDs:IDs,mask:mask,groups:grp}
   widget_control,set_uvalue=varAccess,base
;;;;; Initialization of the data, by calling 'initData'
   rgp_initData,varAccess,request
   widget_control,get_uvalue=set,varAccess.settings
   widget_control,get_uvalue=data,varAccess.datAccess.w
   widget_control,get_uvalue=dims,varAccess.datAccess.dims

;;;;; Creation of the output (to a workspace or the 'Scroll Spectra'
;;;;; function) widgets, and the masks input/output.
   temp=widget_base(base,/row)
   left=widget_base(temp,/column,space=8)
   right=widget_base(widget_base(temp,/column),/row)
   output=widget_base(left,/column,/frame)

   temp=widget_base    (base,/row)
   numorID=widget_label(temp,value='__________'		,font=ft_b_bigger)
   info   =intarr(3)
   info(0)=widget_label(temp,value='_________'		,font=ft_propor)
   info(1)=widget_label(temp,value='_______________'	,font=ft_propor)
   info(2)=widget_label(temp,value='_______________'	,font=ft_propor)

;DID!
;  xopt=widget_base (output,/nonexclusive,/row,space=32)
;  applyBtn=widget_button(xopt,value="Apply mask")
   ropt=widget_base (output,/row)
   bido=widget_label(ropt  ,value='OUTPUT',font=ft_b_normal)
   xopt=widget_base (ropt  ,/nonexclusive)
   groupBtn=widget_button(xopt,value="Group spectra",uvalue=[-88,412,n,0,0])
;  widget_control,set_uvalue=[-88,412,n,1,groupBtn],applyBtn

   out=widget_base(output,/row)
   temp=widget_label(temp,value='')
   out=widget_base(out,/column)
   output=BEN_SELECTWID(widget_base(out,/row),n,1,0,0,0)
   useDF=widget_button(out,uvalue=[-88,411,n], $
      value=("Export to '" + desk_name(desk_winNum('df'),1) + "'"))
;   numor=widget_label(left,value=' ')
   right1=widget_base(right,/column)
   temp=widget_label(right1,value='Load mask')
   for i=1,3 do $
      temp=widget_button(right1,value=("M" + NUMtSTR(i,0)), $
      uvalue=[-88,409,n,i])
   right2=widget_base(right,/column)
   temp=widget_label(right2,value='Save mask in')
   for i=1,3 do $
      temp=widget_button(right2,value=("M" + NUMtSTR(i,0)), $
      uvalue=[-88,408,n,i])

;;;;; Creation of the spectra display, and the options widgets.
   visual=widget_base(base,/column,/frame)
;DID!
   imask=widget_draw(widget_base(visual),/button_events,retain=2  , $
      xsize=constants.dimx,ysize=constants.dimy,uvalue=[-88,405,n], $
      x_scroll_size=constants.dimx,y_scroll_size=constants.dimy/3)
   opts=widget_base(visual,/row)
	put_logo   ,opts
   togs=widget_base(opts,/row,/nonexclusive)
   hidMask=widget_button(togs,value="Hide mask",uvalue=[-88,406,n,1])
   logBtn=widget_button(togs,value="Log aspect",uvalue=[-88,406,n,0])
   maxDat=max(data)
   maxSlider=widget_slider(opts,title="Maximum value",/suppress_value, $
      /drag,value=set.maxVal)
   slidLab=widget_label(opts,value=NUMtSTR(maxDat,0))
   widget_control,set_uvalue=[-88,407,n,maxDat,slidLab],maxSlider

;;;;; Creation of a slider widget to select the desired number of
;;;;; groups; below this slider, three info widget_label are created.
   gpSlider=widget_slider(base,value=set.ngroups,uvalue=[-88,410,n], $
      min=1,max=set.ngroups,title="Number of groups",/drag)

;;;;; All the widgets are declared. They are now realized, and the
;;;;; widgets IDs are stored. The toggle buttons states are set to
;;;;; their default value, according to the "rgp_inits' function
;;;;; result. The data is displayed, and the groups calculated.
   bid=sys_dep      ('DYNLAB',base,1)
   widget_control,/realize,base & put_logo
   widget_control,get_value=maskID,imask
   if options.logAspect then widget_control,/set_button,logBtn
   if options.hideMask then widget_control,/set_button,hidMask
   if options.doGroup then widget_control,/set_button,groupBtn
;DID!
;  if options.mApply then widget_control,/set_button,applyBtn $
;  else widget_control,sensitive=0,groupBtn
   widget_control,set_uvalue={mask:maskID,maxSlider:maxSlider, $
      gpSlider:gpSlider,numor:numorID,info:info},varAccess.IDs
   rgp_numor,varAccess
   rgp_info,varAccess,0
   rgp_changeMax,varAccess,-1,1,maxDat,slidLab
   rgp_groupNum,varAccess,set.ngroups,0
   rgp_imask,varAccess,[-1],1,1
   xmanager,desk_name(n,0),base,event_handler="lamp_event_parser",/just_reg
end

pro bens
;** ****
return
end
;                  FILE : DESCRIPT.PRO
;                 --------------------           

;PARAMETERS RECIEVED ---->    NAMEFILE, TBL (lonarr(8))
                                                           
;tbl(0) = x
;tbl(1) = y
;tbl(2) = z
;tbl(3) = type
;2        1  Byte               
;4        2  Integer 2          
;5       -2  Integer 2 unsigned 
;16       3  Integer 4 long      
;8        4  Floating point    
;32       5  complex             
;64       6  double precision   
;tbl(4) = format
;5        0  unformatted fortran       
;3        1  stream Vms binary          
;2        2  Tiff gp uncompressed
;6        3  CCP4                     (unsensitive)
;0        4  stream unix, fixed vms
;7        5  Mar image plate
;1        6  Formatted ascii
;4        7  Formatted ix,iy,value    (unsensitive)
;8        8  Formatted value,ix,iy,iz (unsensitive)
;tbl(5) = swap
;         0   no swap
;         1   swap
;tbl(6) = record_size
;tbl(7) = start_record or Byte offset

;PARAMETERS RETURNED in P_ICK_RETURN : ok,namefile,tbl 
;                                      ok = 1 open file 
;                                      ok = 0 CANCEL)

;****************************************************************************
PRO DESCRIPT_EVENT, event
;****************************************************************************

common widg3,wstrec,getfil,xs,ys,zs,w_typ,w_swap,w_form,rsize,strec,apply,$
            typfil,formdata,rs_typfil,rs_formdata,ids_type,ids_form,ids_swap,$
            button_type,button_form,comment,val_type,val_form,base0
            
common values,namefile,tbl

		 stat=0 & catch,stat
	         if stat  ne 0  then begin catch,/cancel
	         		widget_control,bad_id=i,comment,set_value=strmid(!err_string,0,50)
	         		return & endif
	         		
widget_control,event.id,get_uvalue  =  uv               ; WIDGET UVALUE 

IF n_elements(uv) gt 1 then IF uv(1) eq 391 then begin  p_did_mvlog, event,uv
							return & endif
;-----------------------------------------------------------------------
;                     BUTTONS "FORMATS"
;-----------------------------------------------------------------------
if(uv eq 'BUTTON_FORM')then begin               
   tbl(4)  =  val_form(event.value)
   MOD_TITTLE,tbl(4)
endif
;------------------------------------------------------------------------
;                     BUTTONS type 
;------------------------------------------------------------------------
if(uv eq 'BUTTON_TYPE')then begin
   tbl(3) = val_type(event.value)
endif
;------------------------------------------------------------------------
;                     BUTTON  BYTE SWAP
;------------------------------------------------------------------------
if(uv eq 'SWAP') then begin
   widget_control,w_swap(0),get_value = swap
   tbl(5) = swap
endif         
;------------------------------------------------------------------------
;                    <CARRIAGE RETURN> IN FIELD NAMEFILE ?
;------------------------------------------------------------------------
if(uv eq 'CR') then return
;-------------------------------------------------------------------------
;                     BUTTON CANCEL
;-------------------------------------------------------------------------
if(uv eq 'CANCEL') then begin   
   widget_control,event.top,/destroy                                            
   P_ICK_RETURN,0,namefile,tbl
   return
endif
;-------------------------------------------------------------------------
;                     BUTTON READ
;-------------------------------------------------------------------------
if(uv eq 'READ')then begin;         
     widget_control,getfil,get_value = namefile         ; GET NAMEFILE
     namefile = strcompress(namefile(0))                                  
     VERIF_NAME,namefile,exist                          ; File exist and not blank ?
     if exist eq 0 then return
;........................ GET XSIZE
     widget_control,xs,get_value = ix                   ; GET XSIZE
     ix = ix(0)                                     
     ix = strtrim(ix(0),2)
     if(ix eq '')then ix ='1'                           ; Blank ?
     field = 'Dim X' & good = 0
     VERIF_CHAR,ix,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(0) = long(ix)
;........................ GET YSIZE
     widget_control,ys,get_value = iy                   ; GET YSIZE                                   
     iy = iy(0)
     iy = strtrim(iy(0),2)
     if(iy eq '')then iy = '1'                          ; Blank ?                                                                                         
     field = 'Dim Y' & good = 0                            
     VERIF_CHAR,iy,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(1) = long(iy)
;........................ GET ZSIZE
     widget_control,zs,get_value = iz                   ; GET ZSIZE                                   
     iz = iz(0)
     iz = strtrim(iz(0),2)
     if(iz eq '')then iz = '1';                         ; Blank ?                                              
     field = 'Dim Z' & good = 0    
     VERIF_CHAR,iz,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(2) = long(iz)
;.........................GET RECORD SIZE 
  widget_control,rsize,get_value = rs                   ; GET RECORD SIZE                                     
  rs = strtrim(rs(0),2)
  if(rs eq '')then rs = '0';                            ; Blank ?                                                                                             
     field = 'Record' & good =0                         
     VERIF_CHAR,rs,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
  tbl(6) = long(rs)                  
;........................ GET START RECORD 
  widget_control,strec,get_value = st                   ; GET START RECORD                                    
  st = strtrim(st(0),2)
  if(st eq '')then st = '1'                             ; Blank ?                                           
     field = 'Offset' & good =0
     VERIF_CHAR,st,field,good                           ; Alphabetic in filed ?
     if good eq 1 then return
     tbl(7) = long(st)

;......................... ALL IS GOOD ........ THEN
  widget_control,event.top,/destroy                     ; destroy base
  P_ICK_RETURN,1,namefile,tbl                          ; call p_ick_return
  return

ENDIF

END
;*********************************************************************************************************
;                           END EVENT PROCEDURE
;*********************************************************************************************************



;^^^^^^^^^^^^^^^^^^^^^^^^^^ CONTROL PROCEDURES ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

PRO VERIF_NAME,name,exist           ;EXIST FILE AND NOT BLANK ?
common widg3
if(name eq '')then begin;                                       
   widget_control,comment,set_value='fill up name of file area...'
   return
endif
b = findfile(name,count = exist);                                     
if(exist eq 0)then widget_control,comment,set_value = '****** FILE DOES NOT EXIST...... ' else $
                   widget_control,comment,set_value = '****** FILE EXISTS................'
return
end
;-----------------------------------------------------------------------------
PRO VERIF_CHAR,name,field,good      ;ALPHABETICS CHARACTERS IN NUMERICS FIELDS ?
common widg3
fl='!!!...Non Numeric character in '+field+' area...!!!'
  for i1 = 0,strlen(name)-1 do begin                                
       car = (strmid(name,i1,1))
       if ((car ge 'A') and (car le 'Z')) or ((car ge 'a') and (car le 'z')) then begin
          widget_control,comment,set_value=fl
          good=1
          return
       endif            
  endfor
  return
end
;-----------------------------------------------------------------------------
PRO MOD_TITTLE,num
common widg3
common values
if (num ne 5) and (num ne 2) then $
   widget_control,wstrec,set_value = 'Byte offset 1->n:' else $
   widget_control,wstrec,set_value = 'Starting record'
   
   if (num eq 0) 		then widget_control,bad_id=i,rsize,set_value='0'
   if (num eq 2) or (num eq 3)  then widget_control,bad_id=i,rsize,set_value='512'
   if (num eq 5) 		then widget_control,bad_id=i,rsize,set_value='-1'
   if (num eq 6) 		then widget_control,bad_id=i,rsize,set_value='1024'
   if (num eq 7) then begin	     widget_control,bad_id=i,xs   ,set_value='1200'
   				     widget_control,bad_id=i,ys   ,set_value='1200'
   				     widget_control,bad_id=i,zs   ,set_value='1'
   				     widget_control,bad_id=i,rsize,set_value='0'
   				     widget_control,bad_id=i,strec,set_value='2401'
   				     tbl(3)=5 & tbl(4)=0  &  endif
return
end
;^^^^^^^^^^^^^^^^^^^^^^^^^^ END CONTROL PROCEDURES ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^






;**********************************************************************************************************
PRO DESCRIPT,xnamefile,xtbl
;**********************************************************************************************************
@lamp.cbk
common widg3
common values
                              
if xregistered('descript') gt 0 then widget_control,bad_id=i,base0,map=1 $
else begin


namefile=xnamefile; 
tbl=xtbl

typfil   = strarr(7)
typfil   = ['Byte','Integer 2','Integer 2 unsigned','Integer 4 long',$
'Floating_point','Double_precision floating','Complex floating']
ids_type = intarr(7) ;                                                       ID type
but_type = intarr(7) ;                                                       
val_type = [2,4,5,16,8,32,64];                                               Values returned by type 
val_form = [5,3,2,6,0,7,1,4,8];						     Values returned by format
formdata = strarr(9)
formdata = ['Unformatted Fortran','Stream VMS binary','Tiff g.p Uncompressed ',$
'Ccp4 (.map binary)','Stream Unix , Fixed VMS','Mar image plate','Formatted Ascii',$
'Formatted ix,iy,value','Formatted val,ix,iy,iz']

ids_form = intarr(9) ;                                                       ID form
ids_swap = intarr(1) ;                                                       ID swap

;^^^^^^^^^^^^^^^^^^^^^^^^^ WIDGETS DESCRIPTION ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

base0   = widget_base (/column,title = 'Data description',resource='lampdid')

widget_control,bad_id = ii,base0,default_font = ft_propor;                  Install FONT 

bid	= widget_base (base0 ,/row)
	  put_logo    ,bid
COMMENT = widget_label(bid   ,value =string(replicate(32b,50)) )

base01  = widget_base (base0 ,/row)
chf     = widget_label(base01,value = 'File name :')
GETFIL  = widget_text (base01,/editable,value = strcompress(xnamefile),xsize = 45,uvalue = 'CR')

base02  = widget_base (base0 ,/row)
bid     = widget_label(base02,value = 'Dimensions:   X=')
XS      = widget_text (base02,/editable,value = strcompress(string(tbl(0))),xsize = 5,uvalue = 'CR')
bid     = widget_label(base02,value = 'Y=')
YS      = widget_text (base02,/editable,value = strcompress(string(tbl(1))),xsize = 5,uvalue = 'CR')
bid     = widget_label(base02,value = 'Z=')
ZS      = widget_text (base02,/editable,value = strcompress(string(tbl(2))),xsize = 5,uvalue = 'CR')

base03  = widget_base (base0, column = 2)

base031 = widget_base (base03 , /column,/frame)
W_TYP   = cw_bgroup   (base031, /column,/exclusive,typfil,uvalue = 'BUTTON_TYPE',$
				/no_release,ids = ids_type,label_top='DATA Type')

base032 = widget_base (base031, /column)
W_SWAP  = cw_bgroup   (base032, /row,/nonexclusive,'swap byte for Integers',$
					    ids = ids_swap,uvalue = 'SWAP',/frame)

base033 = widget_base (base03 , /column,/frame)
W_FORM  = cw_bgroup   (base033, /column,/exclusive,formdata,uvalue = 'BUTTON_FORM',$
				/no_release,ids = ids_form,label_top='DATA Format')


base4   = widget_base (base0,/row)
wstrec  = widget_label(base4, value = 'Byte offset 1->n:')
STREC   = widget_text (base4,/editable,xsize = 5,uvalue = 'CR',value = strcompress(string(tbl(7))))
w_rsize = widget_label(base4,value  = '[byte_recl](vms)')
RSIZE   = widget_text (base4,/editable,xsize = 5,uvalue = 'CR',value = strcompress(string(tbl(6))))

base41  = widget_base  (base0,/row)
CANCEL  = widget_button(base41,value = 'Cancel',uvalue = 'CANCEL')
bid     = widget_label (base41,value = 'or confirm characteristics pressing')
APPLY   = widget_button(base41,value = '    READ    ',uvalue = 'READ',/frame)

;^^^^^^^^^^^^^^^^^^^^^^^^^ END WIDGETS DESCRIPTION ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

bid=sys_dep      ('DYNLAB',base0,0)
WIDGET_CONTROL,group_leader=lamp_b1,/REALIZE,BASE0 & put_logo;               CREATE WIDGETS

widget_control,ids_form(3),sensitive = 0;                                    SET UNSENSITIVE BUTTONS FORM
widget_control,ids_form(7),sensitive = 0
widget_control,ids_form(8),sensitive = 0

but_type = where(val_type eq tbl(3)) & but_type=but_type(0)>0 ;              Corresponding buttons type
but_form = where(val_form eq tbl(4)) & but_form=but_form(0)>0 ;              Corresponding buttons type

widget_control,ids_type(but_type),set_button = 1   ;                         Set Buttons pushed with form and type recieved
widget_control,ids_form(but_form),set_button = 1
widget_control,ids_swap(0),       set_button = tbl(5)

VERIF_NAME,namefile

MOD_TITTLE,but_form

xmanager,'descript', base0,event_handler='descript_event',/just_reg

endelse
return
END

function logoidl,ab
;******* *******
;**
blnc=255B & noir=4B & vert=60B & viol=200B & jaun=85
a   = long(ab)  & b=long(ab)
w   = bytarr(a ,b)+blnc
idx =(indgen(a*(b/2))*2)
w(idx)  =vert
w(*,3)  =blnc & w(*,(b-2)/3+2)=blnc & w(*,(b-2)/3*2+1)=blnc & w(*,b-2)=blnc
w(1,*)  =blnc & w((a-2)/3,*)  =blnc & w((a-2)/3*2-1,*)=blnc & w(a-4,*)=blnc
w(*,b-1)=noir
w(0,*)  =noir
w(*,2)  =noir
w(a-3,*)=noir
w(*,0)  =0  & w(5:*,0)    =noir+35
w(*,1)  =0  & w(5:*,1)    =noir+35
w(a-1,*)=0  & w(a-1,0:b-6)=noir+35
w(a-2,*)=0  & w(a-2,0:b-6)=noir+35
w( 2       :(a-2)/3-1   ,  4         :(b-2)/3+1)=jaun
w((a-2)/3+1:(a-2)/3*2-2 , (b-2)/3*2+2: b-3)     =jaun
w((a-2)/3*2:(a-5)       , (b-2)/3+3  :(b-2)/3*2)=jaun
return,w
end

pro lampico, cocone, ldi=ldi
;**********
;**
if n_elements(ldi) eq 1 then cocone=logoidl(ldi) $
else begin
 cocone=[ $
 145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,144,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,140,132,136,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,137,128,130,125,128,136,144,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,141,139,128,129,125,128,124,126,122,128,138,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,142,130,127,131,125,127,124,125,122,123,118,116,118,131,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,142,132,127,127,125,129,122,127,120,120,116,115,115,112,118,105,115 ] & cocone=[cocone $
,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,135,130,127,127,125,128,122,127,120,124,116,120,112,112,109,105,105,105 ] & cocone=[cocone $
,100,103,108,119,136,144,143,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,139,128,129,125,128,122,126,122,120,119,116,123,112,118,109,105,105,113,99 ] & cocone=[cocone $
,94,94,94,94,94,94,98,124,128,142,141,145,145,145,145,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,142,137 ] & cocone=[cocone $
,127,129,125,127,124,125,122,123,118,116,115,112,116,109,105,105,102,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,102,105,105,108,112,119,116,118,123,123,128,133,136 ] & cocone=[cocone $
,136,142,140,140,140,140,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,144,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,132,127 ] & cocone=[cocone $
,130,125,129,122,125,120,123,116,121,115,112,118,105,105,105,112,94,94,94 ] & cocone=[cocone $
,94,94,94,94,96,105,105,105,110,112,115,116,119,120,122,124,125,127,129 ] & cocone=[cocone $
,129,130,131,132,133,134,134,135,135,137,140,142,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138,134,127,127 ] & cocone=[cocone $
,125,129,122,127,120,124,116,120,115,112,114,105,105,105,112,94,94,94,94 ] & cocone=[cocone $
,94,94,94,96,105,105,105,110,112,115,116,119,121,122,125,126,128,129,129 ] & cocone=[cocone $
,130,131,133,133,134,134,135,135,135,135,135,142,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,139,127,126,126,125 ] & cocone=[cocone $
,124,122,122,120,119,116,123,112,118,109,105,105,113,99,94,94,94,94,94 ] & cocone=[cocone $
,94,94,102,105,105,106,112,112,116,116,120,121,123,125,126,128,129,130,131 ] & cocone=[cocone $
,131,133,134,134,135,135,135,135,135,136,145,145,145,145,145,145,140,137,140 ] & cocone=[cocone $
,144,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,144,136,127,129,125,128,124 ] & cocone=[cocone $
,125,122,123,116,116,119,112,118,109,105,105,113,99,94,94,94,94,94,94 ] & cocone=[cocone $
,94,102,105,105,106,112,112,116,117,120,121,124,125,127,129,129,130,131,132 ] & cocone=[cocone $
,133,134,134,135,135,135,135,135,137,145,145,145,145,145,145,137,135,135,136 ] & cocone=[cocone $
,135,137,141,144,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,133,127,130,125,127,122,125 ] & cocone=[cocone $
,120,123,116,121,115,112,120,105,105,105,112,94,94,94,94,94,94,94,96 ] & cocone=[cocone $
,102,105,105,110,112,115,116,119,120,122,124,125,127,129,129,130,131,132,133 ] & cocone=[cocone $
,134,134,135,135,135,135,135,140,145,145,145,145,145,144,136,135,135,137,135 ] & cocone=[cocone $
,135,136,134,135,135,144,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,138,133,127,127,125,125,122,127,120 ] & cocone=[cocone $
,126,116,121,115,112,118,105,105,105,112,94,94,94,94,94,94,94,96,105 ] & cocone=[cocone $
,105,105,110,112,115,116,119,120,122,125,126,127,129,129,130,131,133,133,134 ] & cocone=[cocone $
,134,135,135,135,135,135,140,145,145,145,145,145,141,135,135,135,136,135,135 ] & cocone=[cocone $
,136,134,135,133,134,132,134,142,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,140,129,130,126,125,124,122,122,120,119 ] & cocone=[cocone $
,120,130,119,119,113,105,105,113,110,94,94,94,94,94,94,94,96,105,105 ] & cocone=[cocone $
,105,112,112,115,116,120,121,123,125,126,128,129,130,130,131,133,133,134,135 ] & cocone=[cocone $
,135,135,135,135,136,145,145,145,145,145,144,136,135,135,136,135,135,136,134 ] & cocone=[cocone $
,134,135,133,133,131,134,130,132,131,141,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,144,135,128,129,126,128,124,122,122,120,119,126 ] & cocone=[cocone $
,124,104,94,120,115,104,125,99,94,94,94,94,94,94,94,102,105,105,106 ] & cocone=[cocone $
,112,112,116,116,120,121,123,125,126,128,129,130,131,132,133,134,134,135,135 ] & cocone=[cocone $
,135,135,135,136,145,145,145,145,145,141,135,135,135,136,135,135,136,134,134 ] & cocone=[cocone $
,135,133,134,131,133,130,133,129,131,127,131,135,144,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,133,127,131,125,127,122,125,120,123,116,124,122 ] & cocone=[cocone $
,68,62,141,94,94,109,125,110,110,99,104,94,94,94,102,105,105,108,112 ] & cocone=[cocone $
,113,116,118,120,122,124,125,127,129,129,130,131,132,133,134,134,135,135,135 ] & cocone=[cocone $
,135,135,140,145,145,145,145,145,141,135,135,135,137,135,135,136,134,135,133 ] & cocone=[cocone $
,134,132,131,131,130,130,129,128,130,126,125,124,126,128,136,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,138,133,127,129,125,127,122,125,120,123,121,124,106,36 ] & cocone=[cocone $
,62,47,109,109,125,125,109,94,94,94,109,73,94,99,110,105,120,112,115 ] & cocone=[cocone $
,116,119,120,122,125,125,127,129,129,130,131,133,133,134,134,135,135,135,135 ] & cocone=[cocone $
,135,140,145,145,145,145,145,139,135,135,135,137,135,135,136,134,135,133,134 ] & cocone=[cocone $
,132,133,131,132,130,131,127,126,126,128,124,126,122,124,119,122,141,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,141,129,130,127,125,124,122,122,120,124,115,126,94,47,47 ] & cocone=[cocone $
,62,47,94,125,109,94,94,94,109,109,109,109,109,36,110,125,115,114,116 ] & cocone=[cocone $
,119,120,123,125,126,128,129,130,130,131,133,133,134,136,135,135,135,135,136 ] & cocone=[cocone $
,142,145,145,145,145,144,136,135,135,136,137,135,136,134,134,135,133,134,131 ] & cocone=[cocone $
,133,130,132,129,131,127,130,125,127,122,127,120,123,118,121,119,112,116,128 ] & cocone=[cocone $
,144,145,145,145,145,145,145,145,145,145,144,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,144,138,129,130,126,125,124,122,122,120,119,126,124,84,47,47,62 ] & cocone=[cocone $
,47,62,47,47,73,94,125,109,125,94,125,109,94,81,63,109,94,99,120 ] & cocone=[cocone $
,121,123,125,126,128,129,130,130,131,133,135,137,137,137,134,135,135,135,141 ] & cocone=[cocone $
,144,145,145,145,144,135,135,135,136,135,135,136,134,134,135,133,134,131,131 ] & cocone=[cocone $
,130,133,129,131,127,130,125,129,122,127,120,126,116,121,115,112,118,105,105 ] & cocone=[cocone $
,105,111,119,136,142,145,145,145,145,145,142,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,133,127,131,125,127,124,121,122,124,118,125,122,83,47,47,62,62 ] & cocone=[cocone $
,47,83,94,94,94,73,73,78,62,125,109,94,43,117,21,78,62,120,121 ] & cocone=[cocone $
,123,125,127,129,129,130,131,132,133,137,137,137,136,134,135,137,138,138,138 ] & cocone=[cocone $
,136,145,145,141,135,135,135,135,135,135,136,134,134,134,133,132,131,131,130 ] & cocone=[cocone $
,130,129,128,130,126,125,128,126,127,120,125,116,121,115,112,117,105,105,105 ] & cocone=[cocone $
,110,94,94,94,94,108,125,142,142,143,135,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,138,137,127,130,125,127,122,125,120,123,121,124,112,68,62,47,31,47,57 ] & cocone=[cocone $
,94,94,94,94,94,94,94,95,105,93,66,68,96,79,15,31,68,122,125 ] & cocone=[cocone $
,125,127,129,129,130,131,134,136,136,137,136,135,138,131,138,136,136,137,136 ] & cocone=[cocone $
,145,145,139,135,135,135,137,135,135,136,134,135,133,134,131,133,131,130,130 ] & cocone=[cocone $
,129,128,130,126,128,124,126,122,124,119,116,122,112,118,105,105,105,113,100 ] & cocone=[cocone $
,94,94,94,94,94,94,94,95,105,111,135,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,141 ] & cocone=[cocone $
,129,130,130,125,126,122,127,120,125,121,126,94,47,62,47,47,31,62,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,105,110,112,113,31,15,15,107,128,130 ] & cocone=[cocone $
,131,132,132,130,131,135,136,136,135,134,133,135,129,136,136,134,130,141,134 ] & cocone=[cocone $
,144,139,135,135,135,137,135,135,134,134,135,133,134,131,133,130,132,129,131 ] & cocone=[cocone $
,127,127,126,124,124,125,122,124,118,116,122,112,116,109,105,105,110,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,140,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138,129 ] & cocone=[cocone $
,130,126,125,124,122,122,120,119,126,122,99,47,62,62,47,62,73,94,94 ] & cocone=[cocone $
,94,94,94,94,94,100,105,105,105,112,112,115,69,15,0,31,137,137,135 ] & cocone=[cocone $
,133,134,134,133,135,136,135,133,132,131,127,104,137,135,132,130,126,131,141 ] & cocone=[cocone $
,135,135,135,136,135,135,136,134,134,136,133,134,131,133,130,132,129,131,127 ] & cocone=[cocone $
,130,125,127,122,127,120,126,116,121,112,112,120,105,105,105,110,94,94,94 ] & cocone=[cocone $
,94,94,94,94,94,98,105,105,140,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,130,128,130 ] & cocone=[cocone $
,126,128,124,126,122,124,118,125,122,73,47,47,62,31,47,83,94,94,94 ] & cocone=[cocone $
,94,94,94,94,102,105,105,108,112,113,116,112,5,0,0,94,141,141,121 ] & cocone=[cocone $
,131,131,126,134,135,133,129,128,99,99,61,137,134,130,130,122,100,100,135 ] & cocone=[cocone $
,135,135,137,135,135,136,134,134,134,133,132,131,131,133,133,129,130,127,130 ] & cocone=[cocone $
,125,129,122,127,120,125,116,121,115,112,117,105,105,105,110,94,94,94,94 ] & cocone=[cocone $
,94,94,94,94,102,105,119,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,141,137,127,130,125 ] & cocone=[cocone $
,127,122,125,122,119,118,125,112,68,62,47,62,47,57,83,94,94,94,94 ] & cocone=[cocone $
,94,94,95,105,105,105,108,112,114,116,121,65,15,0,15,141,94,94,141 ] & cocone=[cocone $
,94,99,101,133,131,128,99,83,62,91,137,135,130,127,121,106,66,136,137 ] & cocone=[cocone $
,138,139,139,136,136,134,134,134,133,132,131,133,136,135,135,128,130,126,125 ] & cocone=[cocone $
,124,126,120,124,122,116,120,112,112,109,105,105,105,100,94,94,94,94,94 ] & cocone=[cocone $
,94,94,95,102,105,119,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,139,130,127,130,125,129 ] & cocone=[cocone $
,122,127,120,125,116,123,116,68,62,47,47,47,47,94,94,94,94,94,94 ] & cocone=[cocone $
,94,95,105,105,105,110,112,115,116,119,121,31,0,15,15,94,125,141,109 ] & cocone=[cocone $
,94,62,37,121,109,83,62,75,136,136,133,132,128,117,110,112,138,138,138 ] & cocone=[cocone $
,138,138,138,134,134,135,133,134,131,133,134,134,132,141,133,127,126,128,124 ] & cocone=[cocone $
,125,122,124,118,116,122,112,118,109,105,105,110,95,94,94,94,94,94,94 ] & cocone=[cocone $
,94,95,105,105,136,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,144,129,130,126,125,128,122 ] & cocone=[cocone $
,125,120,125,116,120,97,47,62,47,47,62,67,94,94,94,94,94,94,94 ] & cocone=[cocone $
,100,105,105,105,112,112,116,116,120,123,93,15,0,15,78,94,94,94,94 ] & cocone=[cocone $
,94,62,47,94,62,61,121,137,135,132,129,125,115,68,122,138,137,138,138 ] & cocone=[cocone $
,135,137,137,127,136,133,134,131,133,135,132,127,118,129,121,125,127,128,134 ] & cocone=[cocone $
,127,127,118,116,115,112,116,105,105,105,110,94,94,94,94,94,94,94,94 ] & cocone=[cocone $
,98,105,105,140,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,134,131,130,126,128,124,126,122 ] & cocone=[cocone $
,124,118,116,122,112,118,15,47,47,62,88,94,94,94,94,94,94,94,100 ] & cocone=[cocone $
,105,105,107,112,113,116,116,120,121,119,42,0,0,47,47,47,0,15,62 ] & cocone=[cocone $
,109,62,94,46,135,136,137,133,132,130,122,103,84,122,138,135,136,137,133 ] & cocone=[cocone $
,132,133,131,127,133,134,131,132,134,131,124,112,68,94,76,129,129,127,129 ] & cocone=[cocone $
,131,129,123,115,112,112,105,105,105,114,94,94,94,94,94,94,94,94,100 ] & cocone=[cocone $
,105,113,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,137,127,127,125,124,124,126,122,124 ] & cocone=[cocone $
,118,116,122,112,116,105,46,31,47,83,94,94,94,94,94,94,95,105,105 ] & cocone=[cocone $
,105,108,112,114,116,118,120,122,122,114,0,0,15,44,39,41,15,31,31 ] & cocone=[cocone $
,78,31,75,135,137,137,135,130,130,121,106,68,137,136,133,134,133,131,128 ] & cocone=[cocone $
,120,115,94,131,132,131,133,134,130,123,107,36,47,94,113,131,124,90,109 ] & cocone=[cocone $
,109,65,112,112,109,105,105,105,100,94,94,94,94,94,94,94,95,102,105 ] & cocone=[cocone $
,119,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,142,133,127,130,125,129,122,127,120,125,116 ] & cocone=[cocone $
,121,112,112,120,105,105,105,52,83,94,94,94,94,94,94,95,105,105,105 ] & cocone=[cocone $
,108,112,114,116,119,120,122,125,122,90,0,0,71,127,109,78,78,94,60 ] & cocone=[cocone $
,75,135,135,136,136,134,132,128,116,110,91,135,134,133,127,131,116,109,75 ] & cocone=[cocone $
,93,55,61,130,133,133,134,129,121,100,47,47,47,101,127,119,94,47,78 ] & cocone=[cocone $
,94,87,118,109,105,105,105,100,94,94,94,94,94,94,94,95,105,105,131 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,144,130,127,127,125,129,122,127,120,125,116,120 ] & cocone=[cocone $
,115,112,109,105,105,105,100,94,94,94,94,94,94,94,100,105,105,105,112 ] & cocone=[cocone $
,112,116,116,120,121,122,125,126,120,38,0,15,99,78,94,94,61,120,135 ] & cocone=[cocone $
,135,135,137,135,133,132,125,115,58,90,132,132,131,127,109,57,76,119,129 ] & cocone=[cocone $
,111,37,69,134,133,133,127,118,73,47,47,62,112,127,119,47,62,47,78 ] & cocone=[cocone $
,75,116,105,105,105,110,94,94,94,94,94,94,94,94,98,105,105,140,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,134,131,130,126,128,124,126,124,124,124,116,120,112 ] & cocone=[cocone $
,112,109,105,105,105,100,94,94,94,94,94,94,94,100,105,105,105,112,112 ] & cocone=[cocone $
,116,116,120,121,123,125,127,128,129,5,0,78,94,31,76,119,135,135,135 ] & cocone=[cocone $
,135,136,135,134,130,124,109,84,115,132,124,121,99,62,90,134,134,133,124 ] & cocone=[cocone $
,80,15,106,132,131,123,121,68,47,47,44,112,129,112,52,62,62,47,47 ] & cocone=[cocone $
,104,105,105,105,110,94,94,94,94,94,94,94,94,100,105,110,140,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,144,144,135,128,129,125,128,124,126,122,124,118,116,122,112,116 ] & cocone=[cocone $
,109,105,105,110,99,94,94,94,94,94,94,95,102,105,105,108,112,114,116 ] & cocone=[cocone $
,118,120,122,124,125,127,128,129,130,43,62,61,119,134,135,135,135,135,135 ] & cocone=[cocone $
,137,139,132,130,121,102,73,133,131,121,83,62,105,136,134,134,135,130,118 ] & cocone=[cocone $
,37,31,133,130,123,103,57,47,62,56,131,124,102,52,47,62,31,47,97 ] & cocone=[cocone $
,105,105,105,110,94,94,94,94,94,94,94,95,100,105,119,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,141,132,127,130,125,129,124,123,122,123,118,116,115,112,116,105 ] & cocone=[cocone $
,105,105,110,94,94,94,94,94,94,94,95,105,105,105,108,112,114,116,118 ] & cocone=[cocone $
,120,122,124,125,127,129,129,130,131,117,46,134,134,135,135,135,135,135,139 ] & cocone=[cocone $
,145,145,125,120,94,57,115,94,115,137,120,135,136,134,135,134,132,127,106 ] & cocone=[cocone $
,0,50,130,122,100,47,47,62,89,126,123,94,47,47,47,62,53,109,105 ] & cocone=[cocone $
,105,105,100,94,94,94,94,94,94,94,95,105,105,127,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,133,127,125,129,122,127,120,125,116,120,115,112,111,105,105 ] & cocone=[cocone $
,105,109,94,94,94,94,94,94,94,95,105,105,105,110,112,115,116,120,121 ] & cocone=[cocone $
,122,125,126,127,129,129,130,131,132,133,134,134,135,135,135,135,135,142,145 ] & cocone=[cocone $
,145,145,127,73,62,31,90,135,135,135,135,134,134,135,133,134,132,121,60 ] & cocone=[cocone $
,31,78,121,90,47,62,47,85,127,116,89,62,47,31,47,58,121,117,105 ] & cocone=[cocone $
,102,99,94,94,94,94,94,94,94,95,105,105,132,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,134,122,127,120,125,116,120,112,112,109,105,105,105 ] & cocone=[cocone $
,100,94,94,94,94,94,94,94,100,105,105,105,112,112,116,116,120,121,122 ] & cocone=[cocone $
,125,126,128,129,130,130,131,133,133,134,134,135,135,135,135,135,142,145,145 ] & cocone=[cocone $
,145,145,144,60,60,135,135,135,135,136,134,134,136,133,135,131,133,114,5 ] & cocone=[cocone $
,31,123,68,31,62,44,112,127,112,52,62,47,47,31,78,110,141,94,115 ] & cocone=[cocone $
,99,104,94,94,94,94,94,94,100,105,109,140,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,142,125,116,116,112,110,109,105,105,113,100 ] & cocone=[cocone $
,94,94,94,94,94,94,94,100,105,105,106,112,113,116,117,120,121,124,125 ] & cocone=[cocone $
,127,128,129,130,130,131,133,134,134,135,135,135,135,135,137,145,145,145,145 ] & cocone=[cocone $
,145,141,135,135,135,136,135,135,136,134,134,135,133,134,131,133,128,100,0 ] & cocone=[cocone $
,0,94,47,47,44,131,121,112,52,62,47,47,47,109,94,94,109,141,94 ] & cocone=[cocone $
,78,68,109,104,94,94,94,100,105,113,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,141,123,116,105,105,105,110,94,94 ] & cocone=[cocone $
,94,94,94,94,94,95,105,105,105,108,112,114,116,118,120,122,124,125,127 ] & cocone=[cocone $
,128,129,130,131,132,133,134,134,135,135,135,135,135,137,145,145,145,145,145 ] & cocone=[cocone $
,141,135,135,135,136,135,135,136,134,135,134,134,132,133,131,132,126,55,31 ] & cocone=[cocone $
,47,78,62,69,126,123,94,52,47,62,31,47,125,94,141,141,125,109,94 ] & cocone=[cocone $
,94,94,78,57,89,95,105,105,127,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,131,118,114,94,94,94 ] & cocone=[cocone $
,94,94,94,94,95,105,105,105,110,112,115,116,119,120,122,124,126,127,129 ] & cocone=[cocone $
,129,130,131,132,133,134,134,135,135,135,135,135,141,145,145,145,145,145,138 ] & cocone=[cocone $
,135,135,135,135,135,135,135,134,135,133,134,132,133,131,132,130,131,26,62 ] & cocone=[cocone $
,94,78,85,126,121,89,62,47,47,47,31,109,109,125,94,94,141,109,125 ] & cocone=[cocone $
,109,94,62,15,68,105,105,132,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,139,122,111,105 ] & cocone=[cocone $
,94,94,94,98,105,105,105,110,112,116,116,120,121,122,125,126,127,129,129 ] & cocone=[cocone $
,130,131,133,133,134,134,135,135,135,135,135,142,145,145,145,145,145,136,135 ] & cocone=[cocone $
,135,135,135,135,136,134,134,136,133,135,131,134,131,131,130,131,128,56,31 ] & cocone=[cocone $
,31,94,120,105,84,62,47,47,47,78,94,94,94,109,94,94,94,125,125 ] & cocone=[cocone $
,109,78,47,0,55,109,140,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,128,117,118,105,106,112,112,116,116,120,121,123,125,126,128,129,130,130 ] & cocone=[cocone $
,131,133,134,134,135,135,135,135,135,136,142,145,145,145,145,141,135,135,135 ] & cocone=[cocone $
,135,135,135,136,134,134,135,133,134,131,133,130,133,129,132,127,127,125,13 ] & cocone=[cocone $
,108,125,120,63,47,47,47,62,62,15,47,47,31,47,0,31,47,94,109 ] & cocone=[cocone $
,109,78,47,0,110,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,141,145,145,139,137,137,131,133,132,129,131,132,132 ] & cocone=[cocone $
,133,134,134,135,135,135,135,135,137,145,145,145,145,145,141,135,135,135,136 ] & cocone=[cocone $
,135,135,136,134,135,134,134,134,133,132,130,133,129,132,127,127,125,128,122 ] & cocone=[cocone $
,122,120,124,116,31,47,62,62,31,15,0,15,0,0,15,0,0,0,0 ] & cocone=[cocone $
,31,47,15,39,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,142,141,138,135,135,139,145,145,145,145,145,141,135,135,135,137,135 ] & cocone=[cocone $
,135,136,134,135,133,134,132,133,131,132,130,131,128,129,126,128,124,126,122 ] & cocone=[cocone $
,120,119,116,123,53,47,70,23,15,0,15,0,0,47,0,78,94,141,94 ] & cocone=[cocone $
,62,31,31,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,136,135,135,135,135,135,136 ] & cocone=[cocone $
,135,134,134,133,134,132,133,131,132,130,131,128,129,125,128,124,125,120,123 ] & cocone=[cocone $
,118,116,122,112,110,109,105,105,0,15,0,0,15,0,47,94,109,94,141 ] & cocone=[cocone $
,125,62,80,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,139,135,136,135,135,136,134 ] & cocone=[cocone $
,134,135,133,134,131,133,130,130,129,132,127,130,125,127,122,127,120,123,116 ] & cocone=[cocone $
,121,115,112,118,105,105,105,112,83,0,31,15,0,31,94,109,125,141,109 ] & cocone=[cocone $
,78,96,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,142,139,137,134,134 ] & cocone=[cocone $
,135,133,134,131,133,130,133,129,132,127,127,125,129,122,127,120,123,116,121 ] & cocone=[cocone $
,115,112,118,105,105,105,112,94,94,94,41,0,0,0,78,78,109,141,63 ] & cocone=[cocone $
,128,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,138 ] & cocone=[cocone $
,134,132,133,130,132,130,129,128,130,126,125,124,126,122,120,119,116,123,112 ] & cocone=[cocone $
,118,109,105,105,113,105,94,94,94,94,94,94,62,74,46,35,92,112,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,140,131,132,130,131,128,129,125,128,122,121,122,124,119,116,122,112,118 ] & cocone=[cocone $
,109,105,105,113,99,94,94,94,94,94,94,94,96,105,105,132,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,139,133,127,130,125,127,122,127,120,123,116,121,115,112,120,109 ] & cocone=[cocone $
,105,105,106,99,94,94,94,94,94,94,94,96,105,110,140,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,140,129,127,122,127,120,123,116,121,115,112,118,105,105 ] & cocone=[cocone $
,105,112,94,94,94,94,94,94,94,94,102,105,110,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,136,120,124,116,117,115,112,118,105,105,105 ] & cocone=[cocone $
,112,94,94,94,94,94,94,94,94,102,105,119,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,135,123,112,118,109,105,105,113,99 ] & cocone=[cocone $
,94,94,94,94,94,94,94,96,102,105,132,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,122,105,105,113,99,94 ] & cocone=[cocone $
,94,94,94,94,94,94,96,105,105,140,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,134,111,105,94 ] & cocone=[cocone $
,94,94,94,94,94,98,105,110,140,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,128,111,94,94,102,105,119,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,140,131,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145 ] & cocone=[cocone $
,145,145,145,145,145,145,145,145,145,145,145,145,145,145]

 cocone=reform(cocone,128,64)
endelse
return
end
pro P_DID_SETVAR
;** ************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    common c_drow,	did_wc,did_we,did_win1,did_4dM,did_etc
    
    if n_elements(lamp_wrd) ne 1 then lamp_wrd=''
    did_repr=lonarr(20)  & did_repr(*)= 0
    did_inib=lonarr(3)   & did_inib(*)= 0
    did_surf=lonarr(2)	 & did_surf(*)= 0
    styles  =intarr(4,2)
    vfl     =lonarr(4)	 & vfl(*)     =-1
    vff     =fltarr(3)
    did_scan=0
    did_tio =0
    did_fu  =0
    flgsurf =0
    wbeside =0
    rx=60 & rz=20 & nlv=24 & smoo=1
    if (sys_dep('STUDENT') or sys_dep('RUNTIME')) then tcol=3 else tcol=1
    if (sys_dep('MACHINE') eq 'win')   then  tcol=3
    tcol=27
   !p.font  =0

    if sys_dep('VERSION') ge 5.0 then LIV_LAMP

    if n_elements(did_wd) eq 0 then begin did_wd=0 & did_we=0 & did_win0=0 & endif

    if b_labins(3) ne 0 then begin did_repr(2)=1 & did_x=512 & did_y=320 & vff(2)=1
	 if  b_labins(3) eq 2  then begin
	  styles(0,0)=3  & styles(1,0)= 1        & did_x=350 & did_y=230
	  if (did_wd eq 0) and (!D.name ne 'Z')  then begin
	    did_wb  =widget_base  (map=0)
	    did_wd  =widget_draw  (did_wb ,retain=2,xsize=did_x,ysize=did_y,colors=-30)
	    widget_control,bad_id=ii  ,did_wb ,/realize
	  endif
	 endif
	 P_AFTER_REALIZE_DID ,0,0,0
	 if  b_labins(3) eq 1 then begin styles(0,0)= 6 & styles(1,0)= 2 & endif
    endif     else begin did_repr(0)=1 & styles(0,0)= 3 & styles(1,0)= 0 & vff(2)=0  & endelse

    vff=[vff,did_repr(2),rz,did_fu,0,0,0,0,0,0,0,rx]
return
end

pro P_DID_CREATE ,base ,ready
;** ************
;**
;** Workspace display unit.
;**
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    common c_drow
    common c_plog,  win,sicon,pixlog
    
    P_DID_SETVAR

    if n_elements(ready) le 0 then begin
	bs0   =widget_base   (base   ,/column)
	bs1   =widget_base   (bs0   ,/row)
    endif else bs1 = ready(0)

	if (lamp_siz ge 800) and (GEORGE ne 1) then text=' DISPLAY WORKSPACE' else text=' DISPLAY'
	if sys_dep('MACHINE') eq 'win' then cap=1 else cap=0

	bs1_1  =widget_label (bs1   ,font=ft_biggest,value=    text)
	bhelp  =widget_button(bs1   ,font=ft_normal ,value='?',$
				     uvalue=[-88,587,0,0,0,0,0,0,0])

	bs1_2  =widget_label (bs1   ,font=ft_biggest ,value='  ')

	bs1b1  =widget_button(bs1   ,font=ft_smaller ,value='<-')
	did_wsc=widget_button(bs1   ,font=ft_propor  ,value='Plot W 1',$
				     uvalue=[-88,301,0,0,0,0,0,0,0])
	bs1b2  =widget_button(bs1   ,font=ft_smaller,value='->')
	widget_control,bad_id=i,bs1b1,set_uvalue=[-88,310,did_wsc,1,0,0,0,0,0]
	widget_control,bad_id=i,bs1b2,set_uvalue=[-88,311,did_wsc,1,0,0,0,0,0]

	bs1_3  =widget_label (bs1   ,font=ft_biggest,value=' ')

	if (GEORGE ne 1) then begin
	bs1_3  =widget_base  (bs1   ,/exclusive,/row)
	bs1_3e =widget_button(bs1_3 ,font=ft_b_normal,value='Below' ,/no_release,$
				     uvalue=[-88,302,0,0,0,0,0,0,0])
	did_inib(0)=bs1_3e
	bs1_3e =widget_button(bs1_3 ,font=ft_b_normal,value='Beside',/no_release,$
				     uvalue=[-88,303,0,0,0,0,0,0,0])
;jock	bs1_3  =widget_base  (bs1   ,/nonexclusive)
;jock	bs1_3e =widget_button(bs1_3 ,font=ft_normal  ,value='Be good',$
;jock				     uvalue=[-88,360,0,0,0,0,0,0,0])
	if sys_dep('MAP') ne -1 then $
	bs1_3  =widget_button(bs1   ,font=ft_normal,value='Options...',/menu,$
				     resource_name='discret') else $
	bs1_3  =widget_button(bs1   ,font=ft_normal,value='Options...',/menu)
	bs1_3t =widget_button(bs1_3 ,font=ft_normal,value='Titles...' ,uvalue=[-88,360,0,0,0,0,0,0])
	did_4dM=widget_button(bs1_3 ,font=ft_normal,value='4D object' ,/menu)
	did_4vM=widget_button(did_4dM,font=ft_normal,value='Vrml File',uvalue='Vrml')
	widget_control,did_4dM,sensitive=0
	if sys_dep('VERSION') ge 5.0 then $
	   bid =widget_button(bs1_3 ,font=ft_normal,value='Need Coffee!' ,uvalue=[-88,304,5,0])

	if lamp_siz ge 800 then text='Be print' else text='Print'
	if sys_dep('MAP') ne -1 then $
	bs1b   =widget_button(bs1   ,font=ft_normal,value=text,uvalue=[-88,350,0,0,0,0,0,0,0],$
				     resource_name='discret') else $
	bs1b   =widget_button(bs1   ,font=ft_normal,value=text,uvalue=[-88,350,0,0,0,0,0,0,0])

	endif
	if GEORGE ne 0 then GEORGEO, TIMER=bs1, freq=duduch1 ,lim=duduch2
	if GEORGE eq 1 then did_fu=1

;*******
	if n_elements(ready) le 0 then bsrow  =widget_base  (bs0   ,/row) $
				  else bsrow  =ready(1)
;*******
	if n_elements(ready) le 0 then bsopt  =widget_base  (bsrow ,/column) $
				  else bsopt  =ready(2)

	if abs(sys_dep('MAP')) eq 1 then option=1 else option=1
	bsoptff=bsopt
	if option then $
	bsoptf =widget_base  (bsoptff,/column,/frame) else bsoptf=bsoptff

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bsimage=widget_button(bsopt1 ,font=ft_b_normal ,value='Image  ',$
				      uvalue=[-88,320,0,0,0,0,0,0,0])
	did_inib(1)=bsimage
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bslevel=widget_button(bsopt1 ,font=ft_b_normal ,value='Contour',$
				      uvalue=[-88,321,0,0,0,0,0,0,0])

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bsurfac=widget_button(bsopt1 ,font=ft_b_normal ,value='Surface',$
				      uvalue=[-88,322,0,0,0,0,0,0,0])
	if sys_dep('MAP') ne -1 then $
	bsura1 =widget_button(bsopt0 ,font=ft_smaller  ,value='<',resource_name='discret') else $
	bsura1 =widget_button(bsopt0 ,font=ft_smaller  ,value='<')
	bsuraz =widget_text  (bsopt0 ,font=ft_b_normal ,value='+20',xsize=4+cap,ysize=1,/editable)
	if sys_dep('MAP') ne -1 then $
	bsura2 =widget_button(bsopt0 ,font=ft_smaller  ,value='>',resource_name='discret') else $
	bsura2 =widget_button(bsopt0 ,font=ft_smaller  ,value='>')
	did_repr(4) =bsuraz
	widget_control,bad_id=i,bsura1,set_uvalue=[-88,326,bsuraz,0,0,0,0,0,0]
	widget_control,bad_id=i,bsura2,set_uvalue=[-88,327,bsuraz,0,0,0,0,0,0]
;------
	bsopt0 =widget_base  (bsoptf  ,/row)
	bsopt1 =widget_base  (bsopt0  ,/nonexclusive)
	bsxy   =widget_button(bsopt1  ,font=ft_b_normal ,value='Range etc...')

	widget_control,bad_id=i  ,bsxy,set_uvalue=[-88,319 , bsxy,bsoptf,bsopt0]

	if (option) then begin
	  bsoptf =widget_base  (bsoptff,map=0,/column,/frame)
	  P_DID_CREATE_MORE , bsxy,bsoptf,bsopt0
	  widget_control,bad_id=i,bsxy,set_uvalue=[-88,319 , bsxy,bsoptf,0]
	endif
;*******allow restarting lamp after /reset.
	if n_elements(did_lamp) gt 1 then begin ii=execute('wset,did_pix>1')
	  if ii eq 0 then begin
	   did_lamp=0
	   did_pio =0
	   did_buf =0
	   sicon   =0
	   Snapix  =0
	   did_zoom_reset
	   p_did_save_reset
	  endif
	endif
;*******
	did_x  =512
	if (sys_dep('MACHINE') eq 'win') then did_y=256 else did_y=288
	if lamp_siz gt  950 then did_y  =320
	if lamp_siz lt  800 then did_x  =300
	if lamp_siz lt  800 then did_y  =230
	if n_elements(ready) le 0 then begin
	   junky   =widget_base  (bsrow)
	   did_wb  =widget_base  (junky,map=1)
	   did_wc  =widget_base  (junky,map=0)
	   did_wd  =widget_draw  (did_wb ,retain=2,xsize=did_x,ysize=did_y,colors=-30,$
					 /button_events,/motion_events)
	   did_we  =0L
	   etxt="did_we  =widget_draw  (did_wc , GRAPHICS_LEVEL=2,UVALUE='DRAW', RETAIN=0,"+ $
	                               "XSIZE=did_x, YSIZE=did_y,/BUTTON_EVENTS,/EXPOSE_EVENTS)"
	   if sys_dep('VERSION') ge 5.0 then ii=EXECUTE(etxt)
	   
	   if GEORGE ne 1 then widget_control,did_wd,draw_motion_events=1
	endif else $
	   did_wd  =ready(3)
	did_curw=10
return
end

pro P_DID_CREATE_MORE, bsxy,bsoptf,bsopt0
;** *****************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

	tmpbase=0    & P_messi , tmpbase,(lamp_b1+0)
	
	if GEORGE eq 1 then $
	bid = widget_button(widget_base(bsopt0  ,/nonexclusive) $
						,font=ft_normal   ,value='Be good' $
						,uvalue=[-88,360,0,0,0,0,0,0,0])   $
	else begin
	  bsbs   =widget_base  (bsopt0,/nonexclusive)
	  if sys_dep('MAP') ne -1 then $
	  bid    =widget_button(bsbs  ,font=ft_smallest,value='bg',uvalue=[-88,344,0],resource_name='discret') else $
	  bid    =widget_button(bsbs  ,font=ft_smallest,value='bg',uvalue=[-88,344,0])
	endelse
;------
	if sys_dep      ('MACHINE') eq 'win' then cap=1 else cap=0

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bstretc=widget_button(bsopt1 ,font=ft_normal ,value='X range',$
				      uvalue=[-88,325,0,0,0,0,0,0,0])
	bsminx =widget_text  (bsopt0 ,font=ft_propor ,value=' Min'  ,xsize=4+cap,ysize=1,$
				     /all_events,/editable)
	bsmaxx =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsminx,set_uvalue=[-88,330,bstretc,7,1,0,0,0,0]
	widget_control,bad_id=i,bsmaxx,set_uvalue=[-88,330,bstretc,7,1,0,0,0,0]

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bstretc=widget_button(bsopt1 ,font=ft_normal ,value='Y range',$
				      uvalue=[-88,329,0,0,0,0,0,0,0])
	bsminy =widget_text  (bsopt0 ,font=ft_propor ,value=' Min'  ,xsize=4+cap,ysize=1,$
				     /all_events,/editable)
	bsmaxy =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsminy,set_uvalue=[-88,330,bstretc,8,1,0,0,0,0]
	widget_control,bad_id=i,bsmaxy,set_uvalue=[-88,330,bstretc,8,1,0,0,0,0]

	bsmins=0
	bsmaxs=0
	if lamp_siz ge 800 then begin
	bsopt0 =widget_base  (bsoptf ,/row,map=0)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive)
	bstretc=widget_button(bsopt1 ,font=ft_normal ,value='S range',$
				      uvalue=[-88,318,0,0,0,0,0,0,0])
	bsmins =widget_text  (bsopt0 ,font=ft_propor ,value=' Min'  ,xsize=4+cap,ysize=1,$
				     /all_events,/editable)
	bsmaxs =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsmins,set_uvalue=[-88,330,bstretc,17,1,0,0,0,0]
	widget_control,bad_id=i,bsmaxs,set_uvalue=[-88,330,bstretc,17,1,0,0,0,0]
	did_inib(2)=bsopt0
	endif

	bsopt0 =widget_base  (bsoptf ,/row)
	bsopt1 =widget_base  (bsopt0 ,/nonexclusive,/row)
	bslog  =widget_button(bsopt1 ,font=ft_normal ,value='W log',$
				      uvalue=[-88,323,0,0,0,0,0,0,0])
	bsmaxb =widget_button(bsopt1 ,font=ft_normal ,value='W lim')
	bsmaxv =widget_text  (bsopt0 ,font=ft_propor ,value=' Maxi ',xsize=6+cap,ysize=1,$
				     /all_events,/editable)
	widget_control,bad_id=i,bsmaxb,set_uvalue=[-88,328,bsmaxv,0,0,0,0,0,0]
	widget_control,bad_id=i,bsmaxv,set_uvalue=[-88,330,bsmaxb,9,bsmaxv,0,0,0,0]
	P_messi , tmpbase,(lamp_b1+0)
	did_repr(10)=bsminx
	did_repr(11)=bsmaxx
	did_repr(12)=bsminy
	did_repr(13)=bsmaxy
	did_repr(15)=bsmins
	did_repr(16)=bsmaxs
return
end

function tvrdd,a,b,c,d
;******* *****
;**
	if (!D.Name eq 'WIN') or (!version.os eq 'darwin') then begin
		if n_elements(d) eq 1 then w=tvrd(a,b,c,d,/true) else w=tvrd(/true)
		w=color_Quan(w,1,a,b,c)
	endif else begin
		if n_elements(d) eq 1 then w=tvrd(a,b,c,d) else w=tvrd() & a=0
	endelse
return, w
end

;*************************************** Restore         *********************************
;*************************************** Restore         *********************************
;*************************************** Restore         *********************************
function P_ICK_LIST, pk_pthv, pk_flt,cnt
;******* **********
;**
	pk_list=''
	stat=0 & cnt=0
	catch,stat
	if stat eq 0 then begin
		cd,pk_pthv,current=mee
		pk_list=findfile(pk_flt,count=cnt)
		if strpos(pk_flt,'.hdf' ) ge 0 then begin
		   pk_more=findfile('*.nxs',count=cn2)
		   if cn2 gt 0 then pk_list=[pk_list,pk_more] & cnt=cnt+cn2
		   if cnt gt 0 then begin idx=where(strpos(pk_list,'.hdfimg') eq -1)
		                          if idx(0) ge 0 then begin pk_list=pk_list(idx) & cnt=n_elements(idx) & endif
		                          idx=where(strpos(pk_list,'.nxsimg') eq -1)
		                          if idx(0) ge 0 then begin pk_list=pk_list(idx) & cnt=n_elements(idx) & endif
		   endif
		endif
		if strpos(pk_flt,'_LAMP') ge 0 then begin
		   pk_more=findfile(pk_flt+'.hdf',count=cn2)
		   if cn2 gt 0 then pk_list=[pk_list,pk_more] & cnt=cnt+cn2
		   pk_more=findfile('*.xml',count=cn2)
		   if cn2 gt 0 then pk_list=[pk_list,pk_more] & cnt=cnt+cn2

		   pk_more=findfile('*.htm',count=cn2)
		   if cn2 gt 0 then $
		   for i=0L,cn2-1 do begin tmp=pk_more(i)
				j=    strpos(tmp,'.htm') & tmp=strmid(tmp,0,j)+'.zip'
				re=   findfile(tmp,count=cn3)
				if cn3 eq 0 then begin
				   tmp=strmid(tmp,0,j)+'.xdr'
				   re=findfile(tmp,count=cn3) & endif
				if cn3 gt 0 then begin
				   pk_list=[pk_list,pk_more(i)] & cnt=cnt+1 & endif
		   endfor
		endif
		cd,mee
	endif else begin
		catch,/cancel
		P_MUS,'mus_cannon'
	endelse
	if cnt gt 0 then begin
			 ln=strpos(strupcase(pk_list(0)),strupcase(pk_pthv))
			 if ln ge 0 then ln=ln+strlen(pk_pthv)
			 for i=long(0),cnt-1 do pk_list(i)=strmid(pk_list(i),ln,35)
	endif  else pk_list='No file '+pk_flt
return,pk_list
end

pro P_ICK_INIT,frm
;**
@lamp.cbk
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    i=xregistered('PICKDATA')
    if i le 0 then begin

	P_MUS,'mus_harp'
    	if n_elements(pk_sli) le 0 then pk_sli=1
    	if n_elements(pk_frm) le 0 then pk_frm=1
    	if pk_frm eq 0 then pk_frm =1
	pe='' & ii=sys_dep('POT',pe)
    	pk_hyst=''

    	pk_bxt =[ 'Lamp' , 'XY (Z)' , 'gel tif'  , 'Mar'   , 'Scan' , 'NeXus' , 'Other']
    	pk_ext =['_LAMP' , '*.*'    ,'.gel'      ,'.image' ,'.WIND' , '.hdf'  ,  pe+'*']

	IF (GEORGE ne 0) or (sys_dep('VERSION') lt 4.0) then begin j=5 & if GEORGE ne 0 then j=3
							     if n_elements(b_labins) ge 6 then $
							        if b_labins(5) eq 1 then pk_frm=j+1
							     pk_bxt(j)='Dial'  & pk_ext(j)='dial_*.pro*' & endif
    	pk_flt ='*' + pk_ext(pk_frm-1)

	pk_stak=lonarr(14+4)
    	pk_idx =-1
    	pk_img = 0
    	P_GET_DATAPATH ,pk_pthv

	pk_list=P_ICK_LIST(pk_pthv, pk_flt,cnt)

	if cnt eq 0 then pk_list='No '+pk_ext(pk_frm-1)+ ' Data in Path'

	if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

	pk_base=widget_base  (title='Lamp Pick Data',resource_name='lamptouch',/column)

	pk_p0  =widget_base  (pk_base,/row)
	pk_plab=widget_label (pk_p0  ,value='PATH:' ,font=ft_b_bigger)
	pk_path=widget_text  (pk_p0  ,value=pk_pthv ,font=ft_b_bigger,xsize=40,ysize=1,/editable)
	pk_butu=widget_button(pk_p0  ,value='Update',font=ft_b_normal) & put_logo,pk_p0

	if frm le 0 then begin
	   nxb=n_elements(pk_ext)
	   pk_x   =lonarr(nxb)
	   pk_p0b =widget_base  (pk_base,/row)
	   pk_plab=widget_label (pk_p0b ,value='FORMAT:',font=ft_b_bigger)
	   pk_p0b1=widget_base  (pk_p0b ,/row,/exclusive)
	   for j=0,nxb-1 do $
	   pk_x(j)=widget_button(pk_p0b1,value=pk_bxt(j),font=ft_b_normal)
	   endif

	pk_p1  =widget_base  (pk_base,/row)
	pk_p11 =widget_base  (pk_p1  ,/column)
	pk_root=widget_base  (pk_p11)
	pk_stak(14) =widget_base  (pk_root,map=1)
	 pk_lab     =widget_label (pk_stak(14),value='Files',font=ft_b_bigger)
	pk_stak(15) =widget_base  (pk_root,map=0,/row,uvalue='')
	 pk_lab     =widget_label (pk_stak(15),value='File',font=ft_b_bigger)
	 pk_lab     =widget_label (pk_stak(15),value='{'   ,font=ft_propor)
	 pk_stak(16)=widget_text  (pk_stak(15),value='1'   ,font=ft_propor,xsize=2+cap,ysize=1,/editable)
	 pk_lab     =widget_label (pk_stak(15),value='.'   ,font=ft_propor)
	 pk_stak(17)=widget_text  (pk_stak(15),value='1'   ,font=ft_propor,xsize=2+cap,ysize=1,/editable)
	 pk_lab     =widget_label (pk_stak(15),value='}'   ,font=ft_propor)
	pk_blis=widget_list  (pk_p11 ,value=pk_list,font=ft_b_normal ,ysize=10,xsize=13)
	pk_lab =widget_label (pk_p11 ,value='SnapShot' ,font=ft_b_bigger)
	pk_draw=widget_draw  (pk_p11 ,retain=2  ,xsize=192,ysize=192)

	pk_root    =widget_base  (pk_p1)
	pk_stak(3)=1
	pk_stak(0) =widget_base  (pk_root,/column,map=0)
	pk_lab     =widget_label (pk_stak(0),value='Ascii XY Organisation' ,font=ft_b_bigger)
	pk_stk     =widget_base  (pk_stak(0),/column,/frame)
	pk_lab     =widget_label (pk_stk    ,value=' ')
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value=' Headers'      ,font=ft_b_normal)
	 pk_stak(2)=widget_text  (pk_bid    ,value=' 0 ' ,xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' Step'         ,font=ft_b_normal)
	 pk_stak(3)=widget_text  (pk_bid    ,value=' 1 ' ,xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' max Pair'     ,font=ft_b_normal)
	 pk_stak(13)=widget_text (pk_bid    ,value='2000',xsize=5+cap,ysize=1,font=ft_propor,/editable)
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value='Contents:'     ,font=ft_b_normal)
	 pk_bid    =widget_base  (pk_bid    ,/column,/exclusive)
	   pk_bi   =widget_button(pk_bid    ,value='X , Y'         ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,0]) & widget_control,pk_bi,set_button=1
	   pk_bi   =widget_button(pk_bid    ,value='X , Y , E'     ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,1])
	   pk_bi   =widget_button(pk_bid    ,value='X , Y , Z'     ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,2])
	   pk_bi   =widget_button(pk_bid    ,value='X , Y , Z , V' ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,3])
	   pk_bi   =widget_button(pk_bid    ,value='V , X , Y , Z' ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,4])
	   pk_bi   =widget_button(pk_bid    ,value='W (m,n)'       ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,5])
	   pk_bi   =widget_button(pk_bid    ,value='W (m,n,f)'     ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,0,6])
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value='Read XY'       ,font=ft_b_normal)
	 pk_bid    =widget_base  (pk_bid    ,/row,/exclusive)
	   pk_bi   =widget_button(pk_bid    ,value='by pairs'      ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,1,0]) & widget_control,pk_bi,set_button=1
	   pk_bi   =widget_button(pk_bid    ,value='by n elements' ,font=ft_b_normal,/no_release,$
	                                    uvalue=[-88,387,1,1])
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value=' m='           ,font=ft_b_normal)
	 pk_stak(4)=widget_text  (pk_bid    ,value='  64  ',xsize=6+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' n='           ,font=ft_b_normal)
	 pk_stak(5)=widget_text  (pk_bid    ,value='  64  ',xsize=6+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' f='           ,font=ft_b_normal)
	 pk_stak(6)=widget_text  (pk_bid    ,value=' 1 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value='String_# between XY pairs: (a X b Y c Z d V)',font=ft_b_normal)
	pk_bid     =widget_base  (pk_stk    ,/row)
	 pk_lab    =widget_label (pk_bid    ,value=' a='           ,font=ft_b_normal)
	 pk_stak(7)=widget_text  (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' b='           ,font=ft_b_normal)
	 pk_stak(8)=widget_text  (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' c='           ,font=ft_b_normal)
	 pk_stak(9)=widget_text  (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)
	 pk_lab    =widget_label (pk_bid    ,value=' d='           ,font=ft_b_normal)
	 pk_stak(10)=widget_text (pk_bid    ,value=' 0 ',xsize=3+cap,ysize=1,font=ft_propor,/editable)

	pk_stak(1) =widget_base  (pk_root,/column)
	pk_lab     =widget_label (pk_stak(1),value='Header Contents',font=ft_b_bigger)
	pk_hed     =widget_text  (pk_stak(1),value=[ ' ',' ']       ,font=ft_b_normal,xsize=40,ysize=24,/scroll)

	pk_p2  =widget_base  (pk_base,/row)
	if GEORGE eq 1 then titi='DIAL to be used' else titi='WK_Space to use'
	pk_slid=widget_slider(pk_p2,title=titi               ,font=ft_b_normal,$
				    minimum=1,maximum=lamp_sys,value=pk_sli)
	pk_butg=widget_button(pk_p2,value='GET THE FILE'     ,font=ft_b_normal)
	pk_butc=widget_button(pk_p2,value=' DONE '           ,font=ft_b_normal)
	bidon  =widget_label (pk_p2,value='     '            ,font=ft_b_normal)
	pk_butd=widget_button(pk_p2,value='DELETE THE FILE'  ,font=ft_b_normal)
	pk_p3  =widget_label (pk_p2,value='                 ',font=ft_b_normal,xsize=120)
        bid=sys_dep      ('DYNLAB',pk_base,1)
	widget_control,bad_id=i,pk_base,group_leader=lamp_b1 ,/realize & put_logo

	widget_control,bad_id=i,pk_draw,get_value =  pixw
	if frm le 0 then begin
	   for j=0,nxb-1 do widget_control,bad_id=i,pk_x(j),set_uvalue=[-88,386,pk_blis,j+1]
	   widget_control,bad_id=i,pk_x(pk_frm-1),set_button=1
	   if pk_ext(pk_frm-1) eq '*.*'  then begin i1=1  & i2=0  & endif else begin i1=0  & i2=1  & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	   if pk_ext(pk_frm-1) eq '.hdf' then begin i1=14 & i2=15 & endif else begin i1=15 & i2=14 & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	   endif
	widget_control,bad_id=i,pk_path,set_uvalue=[-88,381,pk_blis]
	widget_control,bad_id=i,pk_blis,set_uvalue=[-88,382,pk_hed ,pixw,192,192]
	widget_control,bad_id=i,pk_butg,set_uvalue=[-88,383,pk_hed ,pk_p3,pk_slid,pixw,192,192,pk_stak(15)]
	widget_control,bad_id=i,pk_butc,set_uvalue=[-88,384,0]
	widget_control,bad_id=i,pk_butd,set_uvalue=[-88,385,pk_blis,pk_p3]
	widget_control,bad_id=i,pk_butu,set_uvalue=[-88,381,pk_blis]

	XMANAGER, 'PICKDATA'  ,pk_base ,event_handler='LAMP_EVENT_PARSER',/just_reg

    endif else begin widget_control,bad_id=i,pk_base,map=1
		     P_ICK_PTH ,[-88,381,pk_blis]
    endelse
return
end

pro P_ICK_FRM,ev,uv
;** *********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

	if ev.select eq 1 then begin
	   pk_frm=uv(3)
	   pk_flt='*' + pk_ext(pk_frm-1)
	   P_ICK_PTH,uv
	   if pk_ext(pk_frm-1) eq '*.*'  then begin i1=1  & i2=0  & endif else begin i1=0  & i2=1  & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	   if pk_ext(pk_frm-1) eq '.hdf' then begin i1=14 & i2=15 & endif else begin i1=15 & i2=14 & endelse
	   widget_control,bad_id=i,pk_stak(i1),map=0
	   widget_control,bad_id=i,pk_stak(i2),map=1
	endif
return
end
pro P_ICK_LST,ev,uv
;** *********
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    pk_idx=ev.index
    if pk_idx ge 0 then begin
	fil =pk_list(pk_idx)
	pk_hyst='' & w_buf=0
	pp2    =-2 & NXe='1' & NXd='1' & NXed=''

	if (pk_ext(pk_frm-1) eq '.hdf') or (pk_ext(pk_frm-1) eq '.xml') then begin
	 widget_control,pk_stak(16),bad_id=ii,get_value=NXe  &  NXe=strtrim(NXe(0),2)
	 widget_control,pk_stak(17),bad_id=ii,get_value=NXd  &  NXd=strtrim(NXd(0),2)
	 if (NXe gt '1') or (NXd gt '1') then NXed='{' +NXe+'.'+NXd+'}'
	endif
	 widget_control,pk_stak(15),bad_id=ii,set_uvalue=NXed

	if pk_ext(pk_frm-1) eq '_LAMP'  then p_did_restore_wrk,fil     ,pk_pthv,'0',pk_hyst,pp2

	if pk_ext(pk_frm-1) eq '.hdf'   then p_did_res_hdf    ,fil+NXed,pk_pthv,'0',pk_hyst,pp2
	if pk_ext(pk_frm-1) eq '.xml'   then p_did_res_hdf    ,fil+NXed,pk_pthv,'0',pk_hyst,pp2

	if (pk_ext(pk_frm-1) eq '.gel') or (pk_ext(pk_frm-1) eq '.image') or (pk_ext(pk_frm-1) eq '.WIND') $
	then if did_scan eq -1 then SL_SCANLOAD,did_scan,lamp_dir

	if pk_ext(pk_frm-1) eq '.gel'   then sl_lampscan, '.gel'   ,w_buf,pp2,pk_hyst,0, pk_pthv+fil

;	if pk_ext(pk_frm-1) eq '.image' then sl_lampscan, '.image' ,w_buf,pp2,pk_hyst,0, pk_pthv+fil

	if pk_ext(pk_frm-1) eq '.WIND'  then sl_lampscan, 'restore',w_buf,pp2,pk_hyst,0, pk_pthv+fil

	if !D.name ne 'Z' then wset,uv(3) else device,set_resolution=[uv(4),uv(5)] & erase
	u=-1
	if pk_ext(pk_frm-1) eq 'dial_*.pro*' then begin on_ioerror,misdial & str=''
					openr,u,pk_pthv+fil,/get_lun
					while (1) do begin str    = strarr(10)   & readf,u,str
					                   pk_hyst=[pk_hyst,str] & endwhile
					misdial: if u gt 0 then free_lun,u
					pk_hyst=[pk_hyst,str]
	endif
	if pk_ext(pk_frm-1) eq '*.*'    then begin on_ioerror,misread & str=strarr(10)
					openr,u,pk_pthv+fil,/get_lun
					readf,u,str
					misread: if u gt 0 then free_lun,u
					for i=0,9 do xyouts,2,173-(19*i),str(i),charsize=1.,/device,color=255

	endif else widget_control,bad_id=i,uv(2),set_value=pk_hyst

	in=-1
	pk_img=0
	on_ioerror,mispixf
	ext='img'

	i =findfile(pk_pthv+fil+'.Z',count=cnt)
	if cnt eq 1 then bid=sys_dep      ('UN_Z',pk_pthv+fil+'.Z',lamp_dir)

	i=  strpos(fil,'.htm') & ordur=0
	if i lt 0 then i=strpos(fil,'.xml')
	if i ge 0 then begin            fil=strmid(fil,0,i)
	                                res=findfile(pk_pthv+fil+'_s.png',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_i.png',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'-1.png',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_s.jpg',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_i.jpg',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'-1.jpg',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_s.gif',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'_i.gif',count=cnt)
	                                if  cnt eq 0 then $
	                                res=findfile(pk_pthv+fil+'-1.gif',count=cnt)
	                                if  cnt gt 0 then fil=res(0)
	endif     else begin            fii=fil & ii =sys_dep('POT+',fil,ext,1)
	                                res=findfile(pk_pthv+fil         ,count=cnt)
	                                if  cnt eq 0 then begin ext='png' & fil=fii
	                                                        ii =sys_dep('POT+',fii,ext,1)
	                                res=findfile(pk_pthv+fii         ,count=cnt) & endif
	                                if  cnt eq 0 then begin ext='jpg'
	                                                        ii =sys_dep('POT+',fil,ext,1)
	                                res=findfile(pk_pthv+fil         ,count=cnt) & endif
	                                if  cnt gt 0 then begin fil=res(0) & ordur=1 & endif
	endelse
	if NXed ne '' then cnt=0                          ;**Snap already in w_buf or other dataset
	if cnt  gt  0 then if pp2 eq 10 then READ_KIF,fil,w_buf $
	                                else READ_KIF,fil,w_buf,uv(4),uv(5) ;**pp2=10 -> (png,gif) else (img)
	mispixm:
	s=size(w_buf)
	if (s(1) eq uv(4)) and (s(2) eq uv(5)) then begin
		 worder=!order & !order=ordur
		 tvscl,w_buf   & !order=worder
		 pk_img=1
		 endif
	mispixf:if in gt 0 then free_lun,in
	p_did_setwin0
	w_buf=0
    endif
return
end
pro P_ICK_MICO, wkstring,xx,yy,uv,pp2
;** **********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

	if pk_img eq 0 then begin
	   fil =pk_list(pk_idx)

	   if pp2 eq 10 then ext='png' else ext='img'

	   i=  strpos(fil,'.htm')
	   if i lt 0 then i  =strpos(fil,'.xml')
	   if i ge 0 then fil=strmid(fil,0,i)+'-1.png' else ii =sys_dep('POT+',fil,ext,1)

	   kpDname=!D.name	; or pixmap in uv(5) but problems with true colors...
	   set_plot, 'Z' & device,set_resolution=[uv(6),uv(7)] & erase & w0=0
	   p_did_makeicon, wkstring,xx,yy, uv(6),uv(7) ,0 ,w0 ,'s'
	   worder =!order & !order=0
	   if strpos(fil,'img') gt 0 then !order=1
	   w0=tvrd(0,0,uv(6),uv(7))
	   !order =worder
	   set_plot,kpDname

	   if pp2 ne -10 then WRITE_KIF,pk_pthv+fil,w0,transparent=[0] ;**pp2=10 -> (png,gif) else (img)

	   p_did_setwin0
	endif
return
end

pro P_ICK_PTH ,uv
;** *********
;**
@lamp.cbk
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

	widget_control,bad_id=i,pk_path,get_value=pth
	pk_pthv=sys_dep      ('BLANKS',pth(0))
	if pk_pthv ne '' then begin
	   car=strmid(pk_pthv,strlen(pk_pthv)-1,1)
	   if (car ne lamp_dvd) then begin
			   pk_pthv=pk_pthv+lamp_dvd
			   widget_control,bad_id=i,pk_path,set_value=pk_pthv
			   endif
	endif
	pk_idx =-1

	pk_list=P_ICK_LIST(pk_pthv, pk_flt,cnt)

	widget_control ,bad_id=i,uv(2),set_value=pk_list

return
end
pro P_ICK_GET ,pth,filin,frm,info,uv
;** *********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    filin=''
    if pk_idx ge 0 then begin
	pth  =pk_pthv
	filin=pk_list(pk_idx)
	frm  =pk_ext(pk_frm-1)
	info =pk_hyst
	widget_control,bad_id=i,uv(4),get_value=pk_sli
    endif
return
end
pro P_ICK_DEL,uv
;** *********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

    if pk_idx ge 0 then begin
    	fild=pk_list(pk_idx)
	if fild ne '' then begin
		j=strpos(fild,'.htm') &  if j lt 0 then j=strpos(fild,'.xml')
		if j gt 0 then begin     tmp=strmid(fild,0,j)
		  res =FINDFILE (pk_pthv+tmp+'*.*',count=cnt)
		  for i=0L,cnt-1 do begin
			if strpos(res(i),tmp+'.htm')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'.xml')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'.xdr')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'.zip')   ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_i.gif') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_s.gif') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'-1.gif') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_i.png') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_s.png') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'-1.png') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_i.jpg') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'_s.jpg') ge 0 then bid=sys_dep('DELET',res(i))
			if strpos(res(i),tmp+'-1.jpg') ge 0 then bid=sys_dep('DELET',res(i))
		  endfor
		endif else begin
		  bid =sys_dep ('POT+' ,fild,'*' , 2)
		  fild=FINDFILE(pk_pthv + fild)
		  for i=0,n_elements(fild)-1 do bid=sys_dep('DELET',fild(i))
		endelse
	endif
	P_ICK_PTH,uv
    endif
return
end

pro P_GET_DATAPATH, pk_pthv
;** **************
;**
@lamp.cbk
    if  n_elements(pk_pthv) le 0 then pk_pthv=''
    if  pk_pthv eq '' then begin
	pk_pthv=getenv('LAMP_DATAPATH')
	if pk_pthv eq '' then cd,current = pk_pthv
	pk_pthv=sys_dep      ('BLANKS',pk_pthv)
	car=strmid(pk_pthv,strlen(pk_pthv)-1,1)
	if (car ne lamp_dvd) then pk_pthv=pk_pthv+lamp_dvd
    endif
return
end

pro P_ICK_SCAN, pp2,frm,wnumber,uv,hyst,fname,pth
;** **********
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
    common c_ick_scan,  c_pp2,c_frm,c_w,c_uv,c_hyst,tbl

if n_elements(tbl) le 1 then  tbl =[512,512,1, 5,0, 0, 0,1]
c_pp2=pp2 & c_frm=frm & c_w=wnumber & c_uv=uv & c_hyst=hyst
if did_scan eq -1 then SL_SCANLOAD, did_scan,lamp_dir
if did_scan ge  0 then ii=execute('descript,pth+fname,tbl')
return
end

pro P_ICK_RETURN,ok,filename,xtbl
;** ************
;**
@lamp.cbk
common c_ick_scan,c_pp2,c_frm,c_w,c_uv,c_hyst,tbl

if ok eq 1 then begin
	tbl=xtbl & xtbl=[xtbl,0]
	if  xtbl(3) eq 5 then begin xtbl(3)=4 & xtbl(8)=1 & endif
	flg='pass'
	i =execute( 'sl_lampscan, flg ,w' + c_w + ',c_pp2,0,xtbl, filename' )
	comhis='P_ICK_SCAN,-1,"'+c_frm+'","'+c_w+'",0,h,"'+filename+'",""'
	p_did_just_read, c_pp2,c_frm,c_w,c_uv,c_hyst,filename ,bidon ,comhis
endif
return
end

pro P_ICK_XY, ev, uv
;** ********
;**
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

if ev.select eq 1 then pk_stak(11+uv(2))=uv(3)
end
pro READ_LXY, pthfil,w=wi,status=pp2
;** ********
;**
@lamp.cbk
    common c_pick, pk_base,pk_path,pk_pthv,pk_flt ,pk_list,pk_idx,pk_sli,pk_frm,pk_ext,$
                   pk_hyst,pk_img ,pk_blis,pk_stak

head=0 & step=1 & mxi =2000 & m=1 & n=1 & f=1 & a=0 & b=0 & c=0 & d=0 & org=pk_stak(11) & pair=pk_stak(12)
ws  =strtrim(string(wi),2)  & strtit=['']

widget_control,bad_id=i,pk_stak(2) ,get_value=heas & on_ioerror,mish & head=long(heas(0))>0 & mish:
widget_control,bad_id=i,pk_stak(3) ,get_value=stes & on_ioerror,miss & step=long(stes(0))>1 & miss:
widget_control,bad_id=i,pk_stak(13),get_value=mxi  & on_ioerror,misx & mxi =long(mxi (0))>0 & misx:

widget_control,bad_id=i,pk_stak(4) ,get_value=ms   & on_ioerror,mism &    m=long(ms(0))>1   & mism:
widget_control,bad_id=i,pk_stak(5) ,get_value=ns   & on_ioerror,misn &    n=long(ns(0))>1   & misn:
widget_control,bad_id=i,pk_stak(6) ,get_value=fs   & on_ioerror,misf &    f=long(fs(0))>1   & misf:

widget_control,bad_id=i,pk_stak(7) ,get_value=as   & on_ioerror,misa &    a=long(as(0))>0   & misa:
widget_control,bad_id=i,pk_stak(8) ,get_value=bs   & on_ioerror,misb &    b=long(bs(0))>0   & misb:
widget_control,bad_id=i,pk_stak(9) ,get_value=cs   & on_ioerror,misc &    c=long(cs(0))>0   & misc:
widget_control,bad_id=i,pk_stak(10),get_value=ds   & on_ioerror,misd &    d=long(ds(0))>0   & misd:

ii=execute('READ_ORG, pthfil, w'+ws+',x'+ws+',y'+ws+',z'+ws+',e'+ws+', head,step,m,n,f,a,b,c,d' + $
                                    ',org,pair,mxi, status=pp2,ws=ws, strtit=strtit')
if ii eq 1 then begin nt=n_elements(strtit)
                      if nt gt 0 then w_tit(wi)    =strmid(strtit(0),0,80)
                      if nt gt 1 then x_tit(wi)    =strmid(strtit(1),0,80) else x_tit(wi)    ='X'    & y_tit(wi)='Y'
                      if nt gt 2 then other_tit(wi)=strmid(strtit(2),0,80) else other_tit(wi)=pthfil & endif
end
;*****************************************************************************************
;*****************************************************************************************
;*****************************************************************************************

pro	P_AFTER_REALIZE_DID ,sepben,sepdon,sepdid
;**	*******************
@lamp.cbk
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
        common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

	common c_drow
    
    	oo=n_elements(did_wd)
    	if oo eq 0 then P_DID_SETVAR
    	if oo eq 0 then P_DON_INIT_VAR

	if did_inib(0) gt 0 then widget_control,bad_id=i,did_inib(0),set_button=1
	if did_inib(1) gt 0 then widget_control,bad_id=i,did_inib(1),set_button=1
	i =0
	if sepdon gt 0 then begin widget_control,bad_id=i,sepdon ,get_value=j
				  if i eq 0 then begin wset,j & erase,50 & endif & endif

	if sepdid gt 0 then begin widget_control,bad_id=i,sepdid ,get_value=j
				  if i eq 0 then begin wset,j & erase,50 & endif & endif

	if (did_wd gt 0) or (!D.name eq 'Z') then loadct  , tcol
	ii=1
	if  did_wd gt 0 then widget_control,bad_id=ii,did_wd  ,get_value =did_win0
	if  did_we gt 0 then widget_control,bad_id=ii,did_we  ,get_value =did_win1

;	   Load Icones
;	   ---- ------
			   logo,3 & logo,4
	   if ii eq 0 then logo,1

	if did_wd  gt 0 then begin   catch,stat
	   if stat eq 0 then device ,font=sys_dep      ('FONTD') else catch,/cancel
	endif
	if lamp_focus gt 0 then widget_control,bad_id=i,lamp_focus,set_value='',/append,/no_newline,$
										/input_focus
	tso=0 & did_scan=-1
	if (!D.flags and 65536) ne 0 then sl_lampscan, 'test' ,did_scan,tso

	did_surf(0)= (tso and 1)

;	Set history
;	--- -------
	set_history
	kcol=tcol
	catch,stat
	if stat eq 0 then DON_INIT_PROG_MAC  ,-1 else catch,/cancel
	
	if kcol ne tcol then if (did_wd gt 0) or (!D.name eq 'Z') then loadct, tcol
	catch,stat
	if stat eq 0 then begin
	 if (not sys_dep('RUNTIME')) and (not sys_dep('EMBEDDED')) then begin
	  if  b_labins(3) ne 2 then CALL_PROCEDURE,'myinit'
	 endif
	 if  b_labins(3) ne 2 then CALL_PROCEDURE,'myinit_'+strlowcase(inst_value)
	endif
	catch,stat
	if stat eq 0 then begin
         na=FINDFILE('myinit.prox',count=nn)
         if nn gt 0 then begin
          on_ioerror, misini & in=-1
	  OPENR,in,'myinit.prox',/get_lun
	  line=''
	  WHILE (not eof(in)) DO begin readf,in,line & iii=EXECUTE(line) & ENDWHILE
	  misini: if in gt 0 then FREE_LUN,in
	  CD,current=mee
	  P_SET_PATH,mee
	 endif
	endif else catch,/cancel

	styles(2,0)=1

	!order  = 0
	!x.style= 1  &  !y.style= 1  &  !z.style= 1
	!x.range= 0  &  !y.range= 0  &  !z.range= 0
	!p.font = 0
	!p.color= 255
	!p.background= 0
	!p.position=[0,0,0,0]
return
end

pro logo ,flg
;** ****
@lamp.cbk
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
			
	scan_dir= lamp_dir & if scan_dir ne "" then scan_dir= scan_dir + sys_dep('DIVIDER')

;	Load Image (0) (1)show
;	---- -----
	if flg lt 2 then begin
	   if n_elements(did_lamp) le 1 then begin did_pix=0
		if (!D.flags and 65536) ne 0  then begin
      		did_pox=widget_base  (title='',map=0)
      		pix    =widget_draw  (did_pox,retain=2,xsize=512,ysize=256,colors=-30)
       		widget_control,did_pox,bad_id=i ,/realize
      		widget_control,pix,bad_id=i ,get_value=did_pix
		endif
		u=-1
		on_ioerror,misimg
		gif='lampIMG.'
		if n_elements(GEORGE) eq 1   then if (GEORGE eq 1) then gif='geoIMG.'
		if sys_dep('VERSION') ge 5.4 then gif=gif+'png' else gif=gif+'gif'
		wor=!order

		if sys_dep('STUDENT') then did_lamp=bytscl(sin(bytscl(indgen(300,150))/10.)) $
		else begin
		   did_lamp=bytarr(512-1,256)
		   bid=findfile(scan_dir+gif,count=cnt)
		   if cnt gt 0  then begin
		    READ_KIF,scan_dir+gif,did_lamp
		   endif else begin
		    if n_elements(did_icon) lt 128 then LAMPICO,did_icon
		    did_lamp=smooth (rebin(did_icon,512,256),3)
		    mx=max(did_lamp)
		    did_lamp=mx-did_lamp
		   endelse
		endelse
		p_screen & mini=0
        	if n_elements(b_labins) ge 4 then if b_labins(3) eq 2 then mini=1
		if lamp_siz lt 800 then mini=1
		if mini then did_lamp=congrid(did_lamp,300,150)

                LAMPICO,idlicon,ldi=35

		if (!D.flags and 65536) ne 0 then begin wset,did_pix & tvscl,did_lamp & endif
		if (!D.name   eq 'Z') then  begin device,set_resolution=[512,256] & tvscl,did_lamp & endif
;		if (sys_dep('RUNTIME') or sys_dep('EMBEDDED')) then $
		               tvscl,idlicon,0,(size(did_lamp))(2) - (size(idlicon))(2)
		if  sys_dep('STUDENT') then xyouts,100,75,'STUDENT Version',/device,color=0
		if n_elements(GEORGE)  eq 1 then if GEORGE eq 3 then begin
			xyouts,5  ,25,'GEORGE inside' ,/device,color=57,font=0
			xyouts,6  ,24,'GEORGE inside' ,/device,color=54,font=0 & endif

		misimg:if u gt 0 then free_lun,u
		!order=wor
		did_lamp=size(did_lamp)
	   endif
	   if flg eq 1 then begin
		p_did_setwin0 & erase,0
		s=did_lamp(2)
		k= (did_x/32)>1
		j= (did_y-s) /2
		if n_elements(GEORGE) eq 1 then if did_pix gt 0 then begin
		for i=did_x-k,0 ,-k  do device,copy=[0,0,did_x-i,s,i,j,did_pix]
					device,copy=[0,0,did_x-i,s,k,j,did_pix]
		for i=k-1,0 ,-1	     do begin  wait,.01
					device,copy=[0,0,did_x-i,s,i,j,did_pix] & endfor
		endif
	   endif
	endif

;	Load Icone (0) (2)export
;	---- -----
	if (n_elements(did_pio) eq 0) then did_pio=0
	if (did_pio(0) eq 0)  and (flg ne 4) then begin

		if (!D.flags and 65536) ne 0 then begin
      		did_poo=widget_base  (title='',map=0)
      		pio    =widget_draw  (did_poo,retain=2,xsize=128,ysize=64,colors=-30)
       		widget_control,did_poo,bad_id=i ,/realize
      		widget_control,    pio,bad_id=i ,get_value=did_pio
		endif
		u=-1
		on_ioerror,misicon
		if n_elements(did_icon) lt 128 then begin
		 did_icon=bytarr(128,64)
		 did_icon(*,*)=255
		 cnt=0 ;bid=findfile(scan_dir+'lampICO.jpg',count=cnt)
		 if cnt eq 0  then LAMPICO,did_icon  else $
		 READ_KIF,scan_dir+'lampICO.jpg',did_icon
		endif
		if (!D.flags and 65536) ne 0 then begin wset,did_pio & tvscl,did_icon,0,0 & endif
		misicon:if u gt 0 then free_lun,u
		did_icon(0,0)=max(did_icon)
	endif
	if  flg eq 0  then flg=did_pix  else $
	if  flg eq 2  then flg=did_icon else $
	if  flg eq 3  then begin  if n_elements(lamp_ben) ge 7 then if lamp_ben(6) gt 0 then begin
      			 	  widget_control, bad_id=ii ,lamp_ben(6),get_value=did_tio
				  did_pio=[did_pio,lamp_ben(6)] & endif
				  did_o=0
				  endif else $
	if (flg eq 3) or (flg eq 4) then if did_tio gt 0 then if did_o ne 1 then begin did_o=1 & keepw=!Window
					 wset,did_tio & device,copy=[0,0,128,64,0,0,did_pio(0)]
					 if keepw gt 0 then wset,keepw
	endif
return
end

pro put_logo, wid ,TIO=tio ,file=icofil
;** ********
;**
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
	common c_plog,  win,sicon,pixlog

	if !D.name ne 'Z' then begin
		if n_elements(wid) eq 1 then win=widget_Draw(wid,retain=2,xsize=64,ysize=32,/motion_event) $
		else begin
      		     widget_control,win,bad_id=i, get_value = wis
      		     widget_control,win,bad_id=i, set_uvalue=[-88,391,wis]
		     if n_elements(sicon) le 1   then begin
			if n_elements(did_icon) lt 128 then did_icon=bytarr(128,64)
			sicon=congrid(did_icon,64,32)
      			byd=widget_base  (title='',map=0)
      			bid=widget_draw  (byd,retain=2,xsize=64,ysize=64,colors=-30)
       			widget_control   ,byd,bad_id=i , /realize
      			widget_control   ,bid,bad_id=i , get_value=pixlog
			wset,pixlog  &    tvscl,sicon,0,0 & tvscl,sicon,0,32
		     endif
		     ok=0
		     if n_elements(icofil) eq 1   then begin
			bid=findfile(icofil,count=ok)
			if ok gt 0 then begin	bicon=bytarr(64,32) & READ_KIF,icofil,bicon
						bicon=congrid(bytscl(bicon),64,32)
						widget_control,win,bad_id=i,draw_motion_events=0
			endif
		     endif
		     keepw=!Window & wset,wis & if ok gt 0 then tvscl,bicon else tvscl,sicon
		     if keepw gt 0 then  wset,keepw
		     if keyword_set(tio) then did_tio=-wis
		endelse
	endif
end

pro p_did_mvlog, ev,uv
;** ***********
;**
	common c_plog,  win,sicon,pixlog

	if !D.name ne 'Z' then begin
	keepw=!Window    &  wset,uv(2)
	for i=2,32,2 do begin device,copy=[0,i,64,32,0,0,pixlog] & wait,.05 & endfor
	if keepw gt 0 then  wset,keepw
	endif
end

pro p_tremble
;** *********
;**
@lamp.cbk
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

if (lamp_b1 gt 0) and (n_elements(did_x) gt 0) and (!D.name ne 'Z') then begin
	if n_elements(did_buf) eq 0 then did_buf=0
	if did_buf eq 0  then begin

      		did_bif=widget_base  (title='',map=0)
      		buf    =widget_draw  (did_bif,retain=2,xsize=did_x,ysize=did_y)
       		widget_control,did_bif,bad_id=i ,/realize
      		widget_control,buf    ,bad_id=i ,get_value=did_buf

	endif

	keepd=!D.window
	if keepd gt 0 then begin
	   wset , did_buf
	   device,copy= [0,0,did_x,did_y,0,0,did_win0]
	   k=did_y/20 &  wset,did_win0 & erase
	   for i=k,0,-1  do device,copy=[0,0,did_x,did_y-i,0,i,did_buf]
	   wset , keepd
	endif
endif
return
end

function RDSTOP, a,b,ic, win=wit
;******* ******
;**
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
	stp=0
	if (n_elements(wit) eq 4) or (did_tio gt 0) then begin
	   if n_elements(wit) ne 4 then wit=[did_pio(1),did_tio,128,64]

	   if  ic  ne b then p=round(abs(b-a+1)/64.)>1 else p=1
	   t=long(ic-a+1)  & s=t/p & s=s*p
	   if  a eq ic  then begin
	     if a ne b then begin
	   	keepw=!Window   & if !D.name ne 'Z' then wset,wit(1)
		widget_control,wit(0),bad_id=ii,/clear_events & erase,255
		xyouts,(wit(2)-64)>1,(wit(3)/2-17)>1,'STOP',font=-1,charsize=2.,charthick=3.,/device,color=0
		if keepw gt 0 then if !D.name ne 'Z' then wset,keepw
	     endif
	   endif else begin keepw=0
		evv=widget_event(wit(0),/nowait,bad_id=ii) & widget_control,/hourglass
	   	if evv.id eq wit(0) then begin
	   	   keepw=!Window   & if !D.name ne 'Z' then wset,wit(1)
		   stp=1
		   erase ,255
		   device,copy=[0,0,128,64,0,0,did_pio(0)]
		   widget_control,wit(0),bad_id=ii,/clear_events
		   P_MUS,'mus_cannon'
		endif else if s eq t then begin
	   	   keepw=!Window   & if !D.name ne 'Z' then wset,wit(1)
		   t=fix(128.*(ic-a+1)/(b-a+1))>1
		   t=long(t*wit(2)/128.)
		   device,copy=[(128-t)>0,0,t<128,64,(t-128)>0,(wit(3)/2-32)>0,did_pio(0)]
		endif
		if keepw gt 0 then if !D.name ne 'Z' then wset,keepw
	   endelse
	endif

return, stp
end

pro RDSTAP, a,b,ic, res
;** ******
res=RDSTOP( a,b,ic)
end

pro p_did_getw_cur, widx, wnumb
;** **************
;**
	common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

	if n_elements(did_wsc) eq 1 then begin
		widget_control,bad_id=i,did_wsc,get_value=wnumb
		if i eq 0 then wnumb=strupcase(strtrim(wnumb(0),2))
		i =strpos(wnumb,'W')
		wnumb=strtrim(strmid(wnumb,i+1,4),2)
		widx   =fix(wnumb)
	endif else begin widx=1 & wnumb='1' & endelse
return
end

function sl_zoom, x,y,xd,yd
;******* *******
;**
	common	my_geto,go_v7,go_v2,go_v3,go_rql,go_rqm,go_x5,go_y5
;**
;**	Return -1 for none, 1 for left, -2 for middle, -3 for right button.

	ok=0  & ok2=0
	;wiwi=(sys_dep('MACHINE') eq 'win')
	if n_elements(go_v7) eq 0 then begin
	   go_v7= lonarr(7) & go_v2= lonarr(2) & go_y5= intarr(5)
	   go_v3= intarr(3) & go_x5= intarr(5) & endif

	go_x5(0)=x & go_x5(3)=x & go_x5(4)=x
	go_y5(0)=y & go_y5(1)=y & go_y5(4)=y
	xd=x & yd=y
	xp=x & yp=y

	device,set_graphics =6

	but=1 & bat=1
	while (xd ge 0) and (but ne 0) do begin
	   bat=but
	   if  (xd ne xp) or (yd ne yp) then begin
		if ok eq 1 then begin
		    if bat eq 2 then plots   ,go_x5,go_y5,/device, color=255 $
		    		else polyfill,go_x5,go_y5,/device, color=255
		    ok=0 &  endif
		xp=xd & yp=yd
		if bat eq 2 then sz=15 else sz=15
		if (xd-x gt sz) or (xd-x lt -sz) and  $
		   (yd-y gt sz) or (yd-y lt -sz) then begin
		    go_x5(1)=xd  &  go_x5(2)=xd
		    go_y5(2)=yd  &  go_y5(3)=yd
		    if bat eq 2 then plots   ,go_x5,go_y5,/device, color=255 $
		    		else polyfill,go_x5,go_y5,/device, color=255
		    ok=1 & ok2=1
		endif
	   endif
	   cursor  ,xd,yd,0,/device
	   but=!err & if  but lt 0 then but=-but & if (but eq 1) or (but eq 4) then but=5-but
	  ;if wiwi then if but eq 1 then but=2
	endwhile

	if ok eq 1 then if bat eq 2 then plots   ,go_x5,go_y5,/device, color=255 else $
			if bat eq 4 then polyfill,go_x5,go_y5,/device, color=255 else $
			if xd  lt 0 then polyfill,go_x5,go_y5,/device, color=255
	if xd lt 0 then ok=-1
	if ok eq 0 then if ok2 eq 1 then ok=-1
	if ok eq 1 then if bat eq 1 then ok=-3 else $
			if bat eq 2 then ok=-2

	device,set_graphics =3

return, ok
end

pro did_zoom_reset
;** **************
;**
    common c_titi,viex,xxs,yys,wt,xo,yo,zn,xn,but,redo,ok,w_suf
viex=0
end

pro did_zoom ,event,uv
;** ********
;** Draw event (zoom turn)
;**
;**uv:	 2:base	 3:wi	 4:draw	 5:wind	 6:x0	 7:y0	 8:bstx	 9:bsty	10:rgx	11:rgx	12:rgy	13:rgy
;**	14:surf	15:!ord	16:axy	17:labl	18:xof	19:yof	20:log	(12=-1 ->vector)

;**	type 0:pressed	 1:released	 2:motion
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff
    common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

    common c_titi,viex,xxs,yys,wt,xo,yo,zn,xn,but,redo,ok,w_suf

	if (!D.name ne 'Z') then $
	if (event.type eq 0) or (event.type eq 2) or (event.type eq 1) then begin
		x=event.x & y=event.y
		if (uv(14) eq 0) or (uv(12) lt 0) then begin	;no surf

		 ws =strtrim(string(uv(3)),2)
		 ssz=[0] & ii=execute( 'ssz=size(w'+ws+')' ) & if ssz(0) gt 2 then RETURN
		 if (trap_current ne uv(5)) and (uv(16) ne 1)  then  RETURN

		 if (event.type ne 1) then begin
		  bu=event.press & xd=0 & yd=0
		  wset,uv(5)
		  if (uv(17) eq l_message) and (did_tio gt 0) then oki=1 else oki=0
		  XV=0 & YV=0 & XG=0 & YG=0
		  if event.type eq 0 then begin if uv(12) lt 0 then begin
						  tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
						  XV=tmXYZ(0) & YV=tmXYZ(1) ;CURSOR,XV,YV ,/nowait,/data
						endif
						p_zoom, x,y,xd,yd,bb & wset,uv(5)
					  endif
		  if event.type eq 2 then begin   tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
						  XV=tmXYZ(0) & YV=tmXYZ(1) ;CURSOR,XV,YV ,/nowait,/data
						  bb=-9 & xd=x & yd=y & endif
;**		  Activate zoom
;**		  -------- ----
		  if (bb eq 1) or (bb eq -2) or (bb eq -3) or (bb eq -9) then begin ole=1
		  	vft=vfl
		  	xo =uv(6)
		  	xb =uv(18)
			vft(0)=round(uv(10) + (uv(11)-uv(10)) * (float((min([x,xd])-xo)) / (uv(8)-(xo+xb))) )
			flut  =      uv(10) + (uv(11)-uv(10)) * (float((max([x,xd])-xo)) / (uv(8)-(xo+xb)))
			if (vft(0) lt uv(10)) or (flut gt uv(11)) then ole=0
			vft(0)=vft(0)>0
			vft(1)=round(flut)
			if uv(16) eq 1 then begin XV=vft(0)-uv(10) & XG=vft(1)-uv(10) & endif
			vft(3)=0
			if  uv(12) ge 0 then begin
		  	 yo =uv(7)
		  	 yb =uv(19)
		  	 mx =max([y,yd]) & mn =min([y,yd])
		  	 if uv(15) eq 0 then begin i=uv(9)-mn & mn=uv(9)-mx & mx=i & endif $
		  		        else begin i=yo	      & yo=yb       & yb=i & endelse

			 vft(2)=round(uv(12) + (uv(13)-uv(12)) * (float((uv(9)-mx-yo)) / (uv(9)-(yo+yb))) )
			 flut  =      uv(12) + (uv(13)-uv(12)) * (float((uv(9)-mn-yo)) / (uv(9)-(yo+yb)))
			 if (vft(2) lt uv(12)) or (flut gt uv(13)) then ole=0
			 vft(2)=vft(2)>0
			 vft(3)=round(flut)
			 if uv(16) eq 1 then begin YV=vft(2)-uv(12) & YG=vft(3)-uv(12) & endif

			endif else if (trap_current eq uv(5)) and (uv(16) eq 0) then begin
				tmXYZ=CONVERT_COORD(xd,yd,/dev,/to_data)
				XG=tmXYZ(0) & YG=tmXYZ(1) ;CURSOR,XG,YG ,/nowait,/data
		    		if uv(20) eq 1 then begin YV=exp(YV) & YG=exp(YG) & endif
				XS =[0L] &  iii=execute( 'XS=n_elements(x'+ws+')-1' )
			      	ivf= 0L  &  iii=execute('ivf= where(X'+ws+' ge XV )') & ivf=ivf(0)>0<XS
			      	ivl= 0L  &  iii=execute('ivl= where(X'+ws+' ge XG )') & ivl=ivl(0)>0<XS
			      	if ivl  eq 0     then   ivl= uv(11)
				vft (0) =  min([ivf,ivl])   & vft (1) = max([ivf,ivl])
			endif	else begin XV=vft(0)-uv(10) & iii=execute('YV=w'+ws+'(XV)')
				           XG=vft(1)-uv(10) & iii=execute('YG=w'+ws+'(XG)')
			endelse
;**			Total
;**			-----
			if bb eq -3 then begin
			      trap_x1=vft(0) & trap_x2=vft(1) & trap_y1=vft(2) & trap_y2=vft(3)
			      trap_ws=ws
			      trapp  ,tot
			      avg= tot / ((vft(1)-vft(0))*(vft(3)-vft(2)))
			      tx1='  Total :  '   +strtrim(string(tot),2)
			      tx2=' Average : '   +strtrim(string(avg),2)
		     	      if oki eq 0 then   widget_control ,bad_id=i,uv(17),set_value=tx1+tx2 $
			      else begin wset,did_tio & erase,255 & xyouts,3,20, tx1,charsize=1.2,/device,color=120
						      	xyouts,3,3, tx2,charsize=1.2,/device,color=120 & endelse

;**			Motion
;**			------
			endif else if bb eq -9  then begin
			   if (uv(12) lt 0) and (ssz(2) ne 6) then if (YV lt w_min(uv(3))) or (YV gt w_max(uv(3))) then ole=0
			   if ole eq 1 then begin
			      IV=0
			      if uv(16) eq 1 then begin    XI=round(XV>0)+uv(10)
				    iii=execute('XV=X'+ws+'(XI)')
				    if uv(12) ge 0 then begin YI=round(YV>0)+uv(12)
		    				YS =[0] & ii=execute( 'YS=size(y'+ws+')' )
						if YS(0) eq 2 then begin XI=XI+ XI*YI & YI=XI & endif
						iii=execute('XV=X'+ws+'(XI)')
						iii=execute('YV=Y'+ws+'(YI)')
				    endif else  iii=execute('YV=W'+ws+'(XI)')

			      endif
			      tx1=' X='+strtrim(string(XV),2) & tx2=' Y='+strtrim(string(YV),2)
		     	      if oki eq 0 then   widget_control ,bad_id=i,uv(17),set_value=tx1+tx2 $
			      else begin did_o=0 & wset,did_tio & d =32
					 xd=(x+d*2-1) & if xd gt (did_x-1) then a=xd-(did_x-1)  else a=0
					 yd=(y+d-1)   & if yd gt (did_y-1) then b=yd-(did_y-1)  else b=0
					 xe=(x-d*2)   & if xe lt  0        then c=xe		else c=0
					 ye=(y-d-1)   & if ye lt  0        then d=ye		else d=0
					 xe=xe-a-c    & ye=ye-b-d & off=10
	   				 device,copy= [xe,ye,128,64 ,0,0,did_win0]
					 device,get_graphics=oldg,set_graphics=6
	   				 device,copy= [xe,ye,128,off,0,0,did_win0]
					 plots,[64,64]+a+c,[63,32+b+d],color=255,/device,psym=0
					 device,set_graphics=oldg
					 xyouts,2,1, tx1+tx2,/device,color=255
					 endelse
			   endif else LOGO,4
;**			Zoom
;**			----
			endif else begin
			      if (uv(12) lt 0) and (y lt yd) then begin vft(2)=0 & vff(1)=YG & endif
			      vfl= vft
			      uv =[-88,301,uv(2),uv(3)]
			endelse
;**		  Activate cursor position
;**		  -------- ------ --------
		  endif else begin
		    cursor,X,Y ,/nowait,/device
		    if (X ge 0) and (Y ge 0) then begin
		     xdv=x & ydv=y
		     XS =[0L] & ii=execute( 'XS=size(x'+ws+')' )
		        xo =uv(6)
		        yo =uv(7)
		  	xb =uv(18)
		  	yb =uv(19)
			XI =round( uv(10) + (uv(11)-uv(10)) * (float(X-xo) / (uv(8)-(xo+xb))) ) >0
			YI =0. & ii =execute( 'YI=w'+ws+'(XI)' )
;**		     For a vector
;**		     --- - ------
		     if (uv(12) lt 0) then begin
		    	if (trap_current eq uv(5)) and (uv(16) eq 0) then cursor,X,Y ,/nowait,/data $
		    	else begin	X=XI & Y=YI & endelse
		    	YC =Y
		  	D  =uv(10)
		  	YV =0. & XV =X
		  	IDX=[0L]
		  	if (XS(0) le 0) or (uv(16) eq 1) then begin
		  				X =round(X)>0
		  				if XS(0) gt 0 then ii=execute( 'XV=x'+ws+'(X)' ) $
		  				else XV=X
		  				ii=execute( 'YV =w'+ws+'(X)' )
		  	endif else begin 	ii=execute( 'IDX=where(x'+ws+' ge X)' )
		  		if ii eq 1 then ii=execute( 'X  =x'+ws+'(IDX(0))' )
		  		if ii eq 1 then ii=execute( 'YV =w'+ws+'(IDX(0))' )
		  		XV=X
		  	endelse
		  	if ii eq 1 then Y=YV
		  	Ym=w_min(uv(3)) & Ymx=w_max(uv(3))
		  	ii=execute( 'Ym =min(w'+ws+'(uv(10):uv(11)),max=Ymx)' )
		  	if uv(20) eq 1 then begin Ym=alog10(temporary(Ym) > 1E-9) & Y=alog10(temporary(Y) > 1E-9) & endif
			if (trap_current eq uv(5)) and (uv(16) eq 0) then begin
		  	   oplot,[X,X],[Ym,Y],linestyle=1,color=0
		  	   if bu ne 4 then $
		  	   xyouts,X,YC,'_x='+strtrim(string(XV),2),charsize=1.2,/data,color=0 else $
		  	   xyouts,X,YC,'_y='+strtrim(string(YV),2),charsize=1.2,/data,color=0
			endif else begin
			   XR =round( (XI-uv(10))*float((uv(8)-(xo+xb)))/(uv(11)-uv(10)) +xo ) >0
		    	   YR =round( (YV-Ym    )*float((uv(9)-(yo+yb)))/(Ymx   -Ym)     +yo ) >0
		  	   plots,[XR,XR],[yo,YR],linestyle=1,color=0,/device
		  	   if bu ne 4 then $
		  	   xyouts,XR,ydv,'_x='+strtrim(string(XV),2),charsize=1.2,/device,color=0 else $
		  	   xyouts,XR,ydv,'_y='+strtrim(string(YV),2),charsize=1.2,/device,color=0
			endelse
;**		     For an image
;**		     --- -- -----
		     endif else begin
		        if (uv(16) eq 0) then begin
					tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
					XG=tmXYZ(0) & YG=tmXYZ(1) & endif ;CURSOR,XG,YG ,/nowait,/data
		  	yo =uv(7)
		  	yb =uv(19)
		  	if uv(15) eq 0 then YI=Y else YI=uv(9)-Y
		  	if uv(15) eq 1 then begin i=yb & yb=yo & yo=i & endif
			YI =round (uv(12) + (uv(13)-uv(12)) * (float(YI-yo)/ (uv(9)-(yo+yb))) ) >0

			if (uv(16) eq 0) then begin  IDX=[XI] & IDY=[YI]
				if XS(0) eq 2 then ii=execute( 'IDX=where((x'+ws+' ge XG) and (y'+ws+' ge YG))')$
					      else ii=execute( 'IDX=where (x'+ws+' ge XG)' )
				if XS(0) ne 2 then ii=execute( 'IDY=where (y'+ws+' ge YG)' ) else IDY=IDX
				XI =IDX(0)>0
				YI =IDY(0)>0
			endif else if XS(0) eq 2 then begin XI=XI+ XI*YI & YI=XI & endif
			XV=XI & ii=execute( 'XV=x'+ws+'(XI)' )
			YV=YI & ii=execute( 'YV=y'+ws+'(YI)' )
			IV=0.
			if XS(0) eq 2   then ii=execute( 'IV =w'+ws +'(XI)' ) $
					else ii=execute( 'IV =w'+ws +'(XI,YI)' )
			tx1=' X='+strtrim(string(XV),2) & tx2=' Y=' +strtrim(string(YV),2)
							  tx3=' I=' +strtrim(string(IV),2)
			tx4=' in W'+ws+'('+strtrim(string(XI),2)+','+strtrim(string(YI),2)+')'

			;if trap_current ne uv(5) then begin tx1=' ' & tx2=' ' & tx3=' ' & endif
		     	if oki ne 0 then begin	wset,did_tio & erase,200
						xyouts,3,37, tx1,charsize=1.2,/device,color=50
					   	xyouts,3,20, tx2,charsize=1.2,/device,color=50 & did_o=0
					   	xyouts,3, 3, tx3,charsize=1.2,/device,color=50 & endif
			widget_control ,bad_id=i,uv(17),set_value=tx1+tx2+tx3+tx4
		     endelse ; End image and vector
		    endif    ; End X,Y >= 0
		  endelse    ; End cursor position
		 endif       ; End not type=1 (not release)
		endif else begin ;zoom_surf,event,uv, rx,rz,did_repr(4)
;Surface rotation
;****************
if n_elements(viex) eq 0 then  viex=0
if viex eq 0 then begin ok=0 & xxs=192 & yys=128
	bas=widget_base(map=0)
	pix=widget_draw(bas,xsize=xxs,ysize=yys,retain=2)
	widget_control, bas,/realize
	widget_control, pix, get_value=viex
	wt=dist(19)  &  wt(9,9)=wt(9,9)*2
	endif
wset,uv(5)
case event.type of
0:begin ;	button pressed
		but=event.press
		if but eq 1 then begin ok=1 & redo=0
			Xo=x & Yo=y   ;cursor, Xo,Yo ,/nowait,/device
			ws='Sna'+strtrim(string(uv(3)),2)   & wsz  =0L
			ii=execute('wsz=size('+ws+')') & w_suf=0L
			if (wsz(0) eq 2) or (wsz(wsz(0)+1) eq 8) then ii=execute('w_suf='+ws) ;2D or struc
			endif
		if but eq 2 then ok=0
		if but eq 4 then begin ok=0
			tmXYZ=CONVERT_COORD(x,y,/dev,/to_data)
			XV=tmXYZ(0) & YV=tmXYZ(1) & ZV=tmXYZ(2) ;CURSOR,XV,YV ,/nowait,/data
			endif
  end
1:begin ;	button released
		ok=0
		if but eq 1 then if redo then begin
			rx=long(xn) & rz=long(zn)
			if did_repr(4) gt 0 then widget_control,bad_id=i,did_repr(4),$
						       set_value=strtrim(string(rz),2)
			uv =[-88,301,uv(2),uv(3)]
		endif
  end
2:if ok then begin ;motion
		Xc=x & yc=y ;cursor,Xc,Yc ,/nowait,/device
		if (Xc ge 0) and (Yc ge 0) then begin
		  xt= (xc-xo)/1.5
		  yt=-(yc-yo)/1.5
		  if (xt ne 0) or (yt ne 0) then begin redo=1
			zn= (rz+xt)-long((rz+xt)/360)*360
			xn= (rx+yt)-long((rx+yt)/360)*360
			wset,viex & trap_current=viex
			if (size(w_suf))(0) gt 0 then begin
			   if (size(w_suf))(0) eq 2 then $
			           shade_surf,w_suf,az=zn,ax=xn,xstyle=4,ystyle=4,zstyle=4,subtitle='X--->' $
			   else begin ;->3D
			     if thresh ne w_suf.thresh then begin
				shade_volume,w_suf.w,thresh,vvv,ppp
				if n_elements(vvv) gt 1 then $
				w_suf={w:w_suf.w,thresh:thresh,v:vvv,p:ppp}
			     endif
			     if n_elements(w_suf.p) gt 3 then begin sz=size(w_suf.w)
				   scale3, xrange=[0,sz(1)-1], yrange=[0,sz(2)-1], zrange=[0,sz(3)-1],ax=0.,az=0.
				   t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , zn  , 0. ]
				   t3d,                   rot=[ xn , 0.  , 0. ]
				   t3d, tr=[+.5,+.5,+.5]
				   set_shading,reject=0 & tvscl,polyshade(w_suf.v,w_suf.p,/t3d) & set_shading,reject=1

				   if sys_dep('VERSION') lt 4.0 then begin xtit='x' & ytit='y'
				   endif                        else begin xtit='scan' & ytit='x' & endelse

				   surface,w_suf.v,xrange=[0,sz(1)-1], yrange=[0,sz(2)-1], zrange=[0,sz(3)-1],$
					   az=zn,ax=xn,xticks=1,yticks=1,zticks=1,/nodata,/noerase,xtitle=xtit,ytitle=ytit,$
					   title='rx:'+strtrim(round(xn),2)+' rz:'+strtrim(round(zn),2)
			     endif
			   endelse
			endif else shade_surf,wt   ,az=zn,ax=xn,xstyle=4,ystyle=4,zstyle=4,subtitle='X--->'
			wset,uv(5)
			DEVICE,copy=[0,0,xxs,yys,xo<(uv(8)-xxs),yo<(uv(9)-yys),viex]
		  endif
		endif
  endif
else:
endcase
		endelse
	endif
return
end
;*************************************** Process Events **********************************
;*************************************** Process Events **********************************
;*************************************** Process Events **********************************
pro P_DID_EVENT	,event,uv
;** ***********
;**
;** Event parser.
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff
    common c_drow

    if uv(1) eq 390 then did_zoom ,event,uv

;** Are there enought LUN left !!!!
;** -------------------------------
    fee=0 & catch,stat
    if stat ne 0  then fee=128 else begin get_lun,fee & free_lun,fee & endelse
    catch,/cancel & if fee ge 120 then for i=1,120 do   free_lun,i
    i=0
    on_ioerror,mis
    on_error  ,1
    ab=1

    if uv(0) eq -87 then begin
;**	Scan event
;**	---- -----
	if uv(1) eq 21 then begin
		windn=-1
		sl_lampscan, 'w_to_wind' , uv(2) , windn
		if windn ge 0 then begin
		   uv(1)=305
		   wintb(0)=-1
		   index=where(wintb eq windn , i )
		   if i ge 1 then scanum='w'+strtrim(string(index(0)),2) else begin scanum='w0'
		   							 w0=[0,0]
		   							 wintb(0)=  windn
		   							 wtb(0)=1 & endelse
		   endif
	endif else uv(1)=0

    endif

    caze=uv(1)
    if caze  eq 305 then caze=301
    if caze  eq 306 then caze=301
    if caze  eq 308 then begin ;**Tlb_size_events
		 widget_control,bad_id=ii ,event.id ,tlb_get_size=v2 
		 if (abs(uv(7)-v2(0)) gt 50) or (abs(uv(8)-v2(1)) gt 50) then begin
		 				 caze=301
						 uv=[-88,301,uv(2),uv(13)]  & endif
    endif


    case caze of

;**	Disactivate scan
;**	----------- ----
	300:begin
		sl_lampscan, 'send_event',-88
		p_did_setwin0
		set_xy
		!p.font = 0
	    end

;**	Display a workspace
;**	------- - ---------
	301:begin
		ab=0 & i=0
		wnumber='W'
		if (uv(1) eq 301) or (uv(1) eq 306)  then $
			if uv(3) eq -1 then widget_control,bad_id=i,did_wsc ,get_value=wnumber else $
			if uv(3) eq  0 then widget_control,bad_id=i,event.id,get_value=wnumber $
				       else wnumber='W'+strtrim(string(uv(3)),2)
		if uv(1) eq 305 then 	    wnumber=scanum
		if i eq 0 then wnumber=strupcase(strtrim(wnumber(0),2))
		i =strpos(wnumber,'W')
		wnumber=strtrim(strmid(wnumber,i+1,4),2)
		wi=fix(wnumber)
		if (wi ge 0) and (wi le lamp_sys) then begin
		    s =[0L,0L]
		    bb=execute( 's=size(w' + wnumber + ')' ) ;+newtypes*****
		    if  bb eq 1 then if (s(0) ge 1) and (s(0) le 3) and $
			                 ((s(s(0)+1) le 6) or (s(s(0)+1) ge 12) or (s(s(0)+1) eq 9)) then begin
			ab=1
			turn=0
			fu_out  =did_fu
			if (uv(1) eq 301) and (uv(2) eq  0 ) then p_did_makeSnap,wi
			if (uv(1) eq 305)  or (uv(1) eq 306) then fu_out=2 $
				      else if  uv(2) ne 0 then begin fu_out=1 & turn=uv(2) & endif
			if fu_out eq 2  then begin
			 if (lamp_act eq 0) then begin
			  if (did_scan eq -1) then begin SL_SCANLOAD,did_scan,lamp_dir
			                                 if (did_scan ge 0) then loadct,tcol & endif
			  if (did_scan ge  0) then begin
;			   call scan
;			   ---- ----
			   lamp_act=1
			   data='w' + wnumber
			   flg='scan'
			   pp2=wintb(wi)
			   pp3=wtb  (wi)
			   pp4=0
			   while pp4 ge 0 do begin
			     pp4=-1
			     sl_lampscan, 'set_size', 0,0,0, lamp_b1 ,wi

			     stat=0 & i=1
      			     catch,stat
      			     if (stat eq 0) and (i eq 1) then begin
      			         pp5=[w_tit(wi),x_tit(wi),y_tit(wi),z_tit(wi),other_tit(wi)]

			      if s(s(0)+1) le 6 then $ ;+newtypes*******
				 i =execute( 'sl_lampscan, flg ,'      +data+ ',pp2,pp3,pp4,pp5 ' ) else $
				 i =execute( 'sl_lampscan, flg ,float('+data+'),pp2,pp3,pp4,pp5 ' )

		    		 bb=execute( 's=size('+data+')' )
		    		 if s(0) eq 2 then if s(2) eq 1 then bb=execute(data+'=total('+data+',2)')
				 w_tit(wi)=strtrim(pp5(0),2) & x_tit(wi)=strtrim(pp5(1),2)
				 y_tit(wi)=strtrim(pp5(2),2) & z_tit(wi)=strtrim(pp5(3),2)
				 other_tit(wi)=strtrim(pp5(4),2)
			     endif
      			     if  i  ne 1 or stat ne 0 then begin
      			             catch,/cancel
			   	     if pp2 ge 0 then sl_lampscan,'purge',pp2
      			             pp2= -1
      			             pp4= -1
      		     		     print,string(7b),!err_string
			     endif
			     if wi gt 0 then begin
			        to_don_history, wi , -1 , ''
			        wintb(wi)=pp2
			        wtb  (wi)=1
			     endif
			     if pp4 ge 0 then begin
			   		pp2=pp4 & pp3=1 & wi=0 & w0='[0,0]' & data='w0'
			   		index=where(wintb eq pp2 , i )
			   		if i ge 1 then begin wi=index(0)
			   				     pp3=wtb(wi)
							     data='w'+ strtrim(string(wi),2)
							     endif
			     endif
			   endwhile
			   !p.font = 0
			   set_xy
			   p_did_setwin0
			 endif &   endif
			endif else begin
;			   call below or beside views
;			   ---- ----- -- ------ -----
				string_w=wnumber
				vff(2)=0
				p_did_drawidl,turn, string_w, s
				if did_repr(0) eq 1 then txt=' ,/image'    else $
				if did_repr(1) eq 1 then txt=' ,/contour'  else $
				if did_repr(2) eq 1 then txt=' ,/surface'  else txt=' '
				if did_fu      eq 0 then txt=txt+',/below' else txt=txt+',/beside'
				to_don_history,-1,0,'SEE ,w='+string_w    +txt
			endelse
			lamp_act=0
		    endif else if did_fu eq 0 then logo,1
		endif
	    end
;**	Below button
;**	----- ------
	302:begin
		did_fu =0
		p_did_setwin0
	    end
;**	Beside button
;**	------ ------
	303:begin
		did_fu = event.select
		p_did_setwin0
	    end

;**	Need tea or coffee!
;**	------------------
	304:begin l_mess=l_message
		pth=sys_dep('NEWSUB',lamp_dir,'lamp_mac')
		if b_labins(6) then if b_labins(7) gt 0 then l_mess=b_labins(7)
		if uv(2) eq  2  then wi=lamp_sys+1 else wi=0
		if uv(2) eq  2  then READ_LAMP,'teapot.hdf',w=wi, path=pth
		txt='liv_objet,wdraw=did_we,dim=[did_x,did_y],menubas=did_4dM,alter=did_wb,l_mess=l_mess,mytem=uv(2),wi=wi'
		if uv(2) eq  2  then WIDGET_CONTROL,event.id,set_value='Need Coffee!',set_uvalue=[-88,304,5,0]
		if uv(2) eq  5  then begin
		  t = findfile (pth + 'teapot.hdf',count =exist)
		  if exist gt 0 then WIDGET_CONTROL,event.id,set_value='Have Tea!'   ,set_uvalue=[-88,304,2,0]
		endif
		ii =EXECUTE(txt)
	    end

;**	Menu-bar
;**	---- ---
	307:case uv(2) of
		11: CALIBRATION
		12: begin SAVESESSION & p_did_event,0,[-88,398,0]    & end
		61: begin widget_control,bad_id=ii,lamp_b1    ,scr_xsize=uv(5)
		          widget_control,bad_id=ii,lamp_ben(0),map=1
			  widget_control,bad_id=ii,lamp_b1    ,scr_ysize=uv(6)
			  widget_control,bad_id=ii,lamp_don(0),map=1
			  widget_control,bad_id=ii,uv(7)      ,sensitive=0
			  widget_control,bad_id=ii,uv(8)      ,sensitive=1
			  b_labins(6)=0
			  end
		62: begin widget_control,bad_id=ii,lamp_don(0),map=0
			  widget_control,bad_id=ii,lamp_b1    ,scr_ysize=uv(4)
		          widget_control,bad_id=ii,lamp_ben(0),map=0
			  widget_control,bad_id=ii,lamp_b1    ,scr_xsize=uv(3)
			  widget_control,bad_id=ii,uv(7)      ,sensitive=1
			  widget_control,bad_id=ii,uv(8)      ,sensitive=0
			  b_labins(6)=1
			  end
		else:
	    endcase
	    
;**	Decrement Wsc
;**	--------- ---
	310:	begin
		 widget_control,bad_id=i,uv(2),get_value=wnumber & wnumber=wnumber(0)
		 i =strpos(wnumber,'W')
		 if i gt 0 then wf=strmid(wnumber,0,i) else wf=''
		 wn=strtrim(strmid(wnumber,i+1,4),2)
		 wi=fix(wn)-1
		 maxwi=20
		 if (wi lt  1) then wi=lamp_sys<maxwi
		 if (wi gt lamp_sys<maxwi) then wi=1
		 wnumber=strtrim(string(wi),2)
		 wn=wf+'W'+wnumber
		 if wi le 9 then wn=wn+' '
;		 if uv(3) eq 1 then wn='Plot '+wn
;		 if uv(3) eq 2 then wn='LOAD '+wn
;		 if uv(3) eq 3 then wn='SCAN '+wn
		 widget_control,bad_id=i,uv(2),set_value=wn
		 p_did_makeSnap,wi
		 if b_labins(6) then if b_labins(7) gt 0 then widget_control,bad_id=iii,b_labins(7),set_value=HIS(wi)
 		end
;**	Increment Wsc
;**	--------- ---
	311:	begin
		 widget_control,bad_id=i,uv(2),get_value=wnumber & wnumber=wnumber(0)
		 i =strpos(wnumber,'W')
		 if i gt 0 then wf=strmid(wnumber,0,i) else wf=''
		 wn=strtrim(strmid(wnumber,i+1,4),2)
		 wi=fix(wn)+1
		 maxwi=20
		 if (wi lt  1) then wi=lamp_sys<maxwi
		 if (wi gt lamp_sys<maxwi) then wi=1
		 wnumber=strtrim(string(wi),2)
		 wn=wf+'W'+wnumber
		 if wi le 9 then wn=wn+' '
		 widget_control,bad_id=i,uv(2),set_value=wn
		 p_did_makeSnap,wi
		 if b_labins(6) then if b_labins(7) gt 0 then widget_control,bad_id=iii,b_labins(7),set_value=HIS(wi)
		end
;**	Button  Raw
;**	------  ---
	312:	begin	monimon=-(event.select)
			if event.select then txt='/raw' else txt='/noraw'
			to_don_history,-1,0,'RDSET,'+txt
		end

;**	Button  More...
;**	------  -------
	319:	begin
		if uv(4) gt 0 then P_DID_CREATE_MORE, uv(2),uv(3),uv(4) $
		else widget_control,bad_id=i,uv(3) ,map=1
		widget_control,bad_id=i,uv(2) ,set_value='Regular Grid',set_uvalue=0
		widget_control,bad_id=i,uv(2) ,set_button=0,set_uvalue=[-88,324,0]
		end

;**	Button  Image
;**	------  -----
	320:	did_repr(0) =event.select
;**	Button  Contour
;**	------  -------
	321:	did_repr(1) =event.select
;**	Button  Surface
;**	------  -------
	322:	did_repr(2) =event.select

;**	Button  Log aspect
;**	------  ----------
	323:	did_repr(5) =event.select
;**	Button  Use Xi,Yi
;**	------  --- -----
	324:	did_repr(6) =event.select
;**	Button  X Stretch
;**	------  - -------
	325:	did_repr(7) =event.select
;**	Button  Y Stretch
;**	------  - -------
	329:	did_repr(8) =event.select

;**	Button  S Stretch
;**	------  - -------
	318:	did_repr(17)=event.select

;**	Button  Turn -angle
;**	------  -----------
	326:	p_did_drawidl, -1, 0,0
;**	Button  Turn +angle
;**	------  -----------
	327:	p_did_drawidl,  1, 0,0

;**	Button  Maxi value
;**	------  ---- -----
	328:	begin
		did_repr(9)=event.select
		if did_repr(9) eq 1 then did_repr(9)=uv(2)
		end

;**	Scale text imply set button
;**	----- ---- ----- --- ------
	330:	begin
		if did_repr(uv(3)) eq 0 then if event.type lt 3 then begin
			widget_control,bad_id=i,uv(2),set_button=1
			did_repr(uv(3))=uv(4)
		endif
		end


;**	Touch Base
;**	**********
	331:	begin p_set_font,1 & lamp_siz=lamp_siz<800
		      TOUCH_B   ,1 ,inst_value
		      p_set_font,0
		end
;**	Touch_base get catalog
;**	---------- --- -------
	332:	touch_list, event,uv
;**	Touch_base select experiment
;**	---------- ------ ----------
	333:	touch_exper,uv,event.index
;**	Touch_base select run
;**	---------- ------ ---
	334:	touch_run,  uv,event.value ,event.drag
;**	Touch_base representation
;**	---------- --------------
	335:	touch_mode, uv
;**	Touch_base done
;**	---------- ----
	336:	touch_done, event ,uv
;**	Touch_base done
;**	---------- ----
	337:	touch_restore, uv
;**	Touch_base color , draw_event ...
;**	---------- -----   ----------
	338:	touch_more, uv,event

;**	didline
;**	-------
	340:	pho_event, event ,uv
;**	inx
;**	---
	341:	inx_event, event ,uv

;**	342:    Do not use
;**	343:    Do not use

;**	Background
;**	----------
	344:    begin if event.select eq 1 then begin tvlct,255,255,255,0  & tvlct,0,0,0,255
	              endif		   else begin tvlct,0,0,0,0        & tvlct,255,255,255,255 & endelse
		end

;**	Print format
;**	------------
	345:    widget_control,bad_id=i,uv(3),set_uvalue=uv(2)

;**	Annotate
;**	--------
	346:	begin keepfont=!p.font & !p.font=-1 & if !D.name ne 'Z' then wset,uv(2)
		      ANNOTATE,COLOR_INDICES=shift(indgen(10)*22,5)
		     ;trap_current=uv(2)
		      that=lamp_don(0) & if b_labins(8) gt 0 then that=[that,b_labins(8)]
		      widget_control,bad_id=i,that,/clear_events
		      !p.font=keepfont & end

;**	Load colors
;**	---- ------
	347:	begin
		i=xregistered('xloadct')
		if i lt 1 then xloadct,group=lamp_b1,/use_current
		end

;**	Remove_event
;**	------------
	349:	begin wait,.3 & widget_control,bad_id=i,uv(2),/destroy & end

;**	Print_event
;**	-----------
	350:begin l_mess=l_message
		if b_labins(6) then if b_labins(7) gt 0 then l_mess=b_labins(7)

		keep_w  =!D.window
		keep_d  =!D.name
		keep_o  =!order
		keep_u  =did_fu
		modop   =1
		err	=1
		if (uv(3) eq 0) and (uv(4) gt 0) then begin
		           widx=uv(4) & wnumber=strtrim(string(widx),2) & modop=uv(6)>1
		           if modop eq 1 then out_file='lamp_w' +wnumber + '_cp.ps' $
		                         else out_file='lamp_w' +wnumber + '_cp.gif'
		endif else begin   p_did_getw_cur, widx, wnumber
		           l='_' & if did_repr(0) eq 1 then l=l+'i'
		                   if did_repr(1) eq 1 then l=l+'c'
		                   if did_repr(2) eq 1 then l=l+'s'
		           out_file='lamp_w' +wnumber +l+ '.ps'
			   ;Next line in comment means print screen
			   ;***************************************
			   if uv(3) ge 0 then begin modop=3  & w_numor(0)=out_file  & endif
			   if uv(3) le 0 then begin did_fu=0 & uv(6)=0 & uv(4)=widx & endif
			   endelse
		if !D.name ne 'Z' then $
		if uv(2)  gt 0 then wset,uv(2) else p_did_setwin0
		if uv(3)  gt 0 then begin widget_control,bad_id=i,uv(3),get_value= out_file
					  out_file=strtrim(out_file(0),2)
					  id      =strpos (out_file,'_h.')
					  if id lt 0 then id=strpos (out_file,'.')
					  if id gt 0 then  out_file=strmid (out_file,0,id)
					  widx    =uv(4)
					  if sys_dep('VERSION') ge 5.4 then kif='.png' else kif='.gif'
					  widget_control,bad_id=i,uv(7),get_uvalue=modop
					  if modop eq 1 then out_file = out_file+'_h.ps'
					  if modop eq 2 then out_file = out_file+  kif
					  if modop eq 3 then out_file = out_file+'.ps'
					  w_numor(0) =  out_file
					  did_fu=1
					  widget_control,bad_id=i,uv(3),set_value= out_file
				    endif
		if  (modop ne 3) and (uv(2) lt 0) then begin ;An object for GIF or Screen copy
		  if modop eq 2 then ps='GIF' else ps='SCREEN'
		  txt='liv_objet,WDRAW=-uv(2),PS=ps'
		  ii=EXECUTE(txt)
		endif else if modop ne 3 then begin
		  !order=0 & r=0
		  w0=tvrdd(r,g,b)
		  s =size(w0)
		  on_ioerror,misps_open

		  if modop eq 2 then begin if n_elements(r) le 1 then tvlct,r,g,b,/get
		  	WRITE_KIF,out_file,w0,r,g,b & err=0
			if l_mess gt 0 then widget_control,bad_id=i,l_mess  ,set_value= out_file+' updated ...'
		  endif
		  if modop eq 1 then begin

		    tvlct, cur_r, cur_g, cur_b, /get
		    if n_elements(r) le 1 then begin r=cur_r & g=cur_g & b=cur_b & endif
		    set_plot,'PS'
		    device,filename=out_file,bits_per_pixel=8,/color

		    pos_r=bytarr(256) & pos_g=bytarr(256) & pos_b=bytarr(256)
		    pos_r(0)=r    & pos_g(0)=g    & pos_b(0)=b
		    tvlct ,  pos_r    ,          pos_g    ,          pos_b
		    covec=indgen(n_elements(cur_r))

			 sx  =7.21 & sy=10.6 & bpi=300. & pi=90 & fx=1. & fy=1.
			 bord=0.5
			 lup =0.3
			 if s(1) le s(2) then begin
			    ix=float(s(1))/pi & iy=float(s(2))/pi
			 endif else begin
			    ix=float(s(2))/pi & iy=float(s(1))/pi & endelse
			 if ix gt sx then fx=sx/ix & if iy gt sy then fy=sy/iy
			 if fy lt fx then fx=fy    & ix=ix*fx  & iy=iy*fx

		    on_ioerror,misps_write

		    xo  =(sx-ix)/2 & yo=(sy-iy)/2

		    if s(1)  le s(2) then begin
			 if yo lt bord then yo=bord & if yo lt 0.8 then lup=0.1
			 if xo lt bord then xo=bord
			 device,/portrait       ,/inches,xoffset=xo       ,yoffset=yo
			 tv,w0      ,0    ,0        ,xsize=ix,ysize=iy    ,/inches
			 tvlct, cur_r, cur_g, cur_b
			 if uv(5) gt 1 then $
			 tv,covec   ,ix-1.,iy+lup   ,xsize=1.,ysize=0.25  ,/inches
			 p_did_ps_header, iy+lup , widx ,out_file
		    endif else begin
			 if xo lt bord then xo=bord & if xo lt 0.8 then lup=0.1
			 device,/landscape      ,/inches,xoffset=xo       ,yoffset=sy-yo
			 tv,w0      ,0    ,0        ,xsize=iy,ysize=ix    ,/inches
			 tvlct, cur_r, cur_g, cur_b
			 if uv(5) gt 1 then $
			 tv,covec   ,iy-1.,ix+lup   ,xsize=1.,ysize=0.25  ,/inches
			 p_did_ps_header, ix+lup , widx ,out_file
		    endelse
		    if l_mess gt 0 then widget_control,bad_id=i,l_mess  ,set_value= out_file+' updated ...'
		    err=0
		    misps_write: if err eq 1 then device,/close_file
		    set_plot,keep_d
		    tvlct ,  cur_r    ,          cur_g    ,          cur_b
		  endif

		  misps_open:   set_plot,keep_d
		  !order  =keep_o
		  if keep_w ge 0  then if !D.name ne 'Z' then wset,keep_w
		  if err    eq 1  then begin
				widget_control,bad_id=i,l_mess  ,set_value='Print write error !!!'
				P_MUS,'mus_cannon' & endif
		endif else begin
		;** POSTSCRIPT REPLOT
		  if uv(8) eq 0 then uv(8)=did_wd
		  widget_control,bad_id=ii,uv(8),get_uvalue=lov
		  if ii eq 0 then begin
		  ;** RESTORE ZOOM... LIMITS
			;lov: [-88,390, b_cur, fix(string_w), d_cur, w_cur, xo, yo,$
			;	bst_x, bst_y, vfl(0), vfl(1),vfl(2),vfl(3), isurf ,$
			;	w_order, axy, baslb, xof, yof, did_repr(5)]
		  	if n_elements(lov) gt 13 then vfl(0:3)=lov(10:13)
		  endif	  
		  styles(3,0)=1
		  p_did_event,0,[-88,301,uv(6),uv(4)]
		endelse
		did_fu=keep_u
	    end

;**	Multi_plot create
;**	---------- ------
	352:begin
		p_did_getw_cur, widx, wnumber
		suprplot, widx
	    end
;**	Multi_plot event (353:slider_w_x_y 354:slider_range 355:keep etc. 356:buttons)
;**	---------- -----
	353:	p_rom_super_event, event,uv
	354:	p_rom_super_event, event,uv
	355:	p_rom_super_event, event,uv
	356:	p_rom_super_event, event,uv

;**	TRIPX
;**	-----
	357:	ii=execute('tripx_event, event,uv')
	358:	ii=execute('tripx')

;**	TOMOGRAPHY
;**	----------
	359:    tomo_event_parser, event,uv

;**	Begood button
;**	------ ------
	360:begin p_did_getw_cur, widx, wnumber
		  p_set_font,1
		  p_did_create_begood, widx ,rx ,nlv ,smoo ,styles ,did_repr
		  p_set_font,0
		 ;widget_control,bad_id=i,event.id,set_button=0
	    end
;**	Begood updat
;**	------ -----
	361:	p_did_begood_updat
;**	Begood updat
;**	------ -----
	362:	p_did_begood_slide,event
;**	Begood done
;**	------ ----
	363:	p_did_begood_done, rx ,nlv
;**	Begood device for PS
;**	------ ------ --- --
	364:	p_did_begood_devps
;**	Begood view angle
;**	------ ---- -----
	365:	if uv(2) eq 0 then p_did_begood_ax, rx else p_did_begood_nlv, nlv
;**	Begood Surface style
;**	------ ------- -----
	366:	if uv(2) le 6 then styles(0,0)=uv(2) $
		else begin
		     if uv(2) eq 7 then if   event.select eq 1 then !P.psym=10 else !P.psym=0
		     if uv(2) eq 8 then smoo=event.select
		     if uv(2) eq 9 then did_repr(14)=event.select
		endelse
;**	Begood Contour style
;**	------ ------- -----
	367:	styles(1,0)=uv(2)
;**	Begood Scan preference
;**	------ ---- ----------
	368:	styles(uv(2),1)=event.select
;**	Begood Projection style
;**	------ ---------- -----
	369:	if event.select eq 1 then styles(2,0)=uv(2) else styles(2,0)=1

;**	Save workspace
;**	---- ---------
	370:begin
		p_did_getw_cur, widx, wnumber
		p_did_save_menu,widx
	    end
	371:p_did_save_list,event
	372:p_did_save_format,uv(2)
	373:p_did_save_filename,event
	374:p_did_save_work,event,uv ,0

;**	Diag UI.
;**	---- --
	378:wdiag_event, event,uv

;**	Phil filter UI.
;**	---- ------ --
	379:P_FIL_EVENT ,event,uv

;**	Restore workspace create widget
;**	------- --------- ------ ------
	380:P_ICK_INIT,0
;**	Restore workspace change path
;**	------- --------- ------ ----
	381:P_ICK_PTH,uv
;**	Restore workspace select
;**	------- --------- ------
	382:P_ICK_LST,event,uv
;**	Restore done button
;**	------- ---- ------
	384:	widget_control,bad_id=i,event.top,map=0
;**	Restore workspace remove
;**	------- --------- ------
	385:P_ICK_DEL ,uv
;**	Restore workspace change format
;**	------- --------- ------ ------
	386:P_ICK_FRM ,event,uv
;**	Restore XY change format
;**	------- --------- ------
	387:P_ICK_XY  ,event,uv
;**	Restore workspace read
;**	------- --------- ----
	383:begin P_ICK_GET,pth,fname,frm ,info ,uv
	      if fname ne '' then begin NXed=''
		     widget_control,bad_id=i,uv(8)   ,get_uvalue=NXed
		     widget_control,bad_id=i,uv(4)   ,get_value =iw
		     lamp_wrd='W'+strtrim(string(iw),2)
		     p_did_before_read, wnumber,uv(3)
		     pp2=-1 & hyst=''
		     comhis=''
;		Workspaces
		     if frm eq '_LAMP'  then begin
			comhis='READ_LAMP,"'+pth+fname+'",w='+wnumber
		        p_did_restore_wrk, fname,pth,wnumber,hyst,pp2
		     endif
;		NeXus
		     if (frm eq '.hdf') or (frm eq '.xml') then begin
			comhis='READ_LAMP,"'+pth+fname+NXed+'",w='+wnumber
		        p_did_res_hdf    , fname+NXed,pth,wnumber,hyst,pp2
		     endif
;		XY ascii
		     if frm eq '*.*'  then begin
			comhis='READ_LXY,"'+pth+fname+'",w='+wnumber
		        read_lxy, pth+fname,w=wnumber,status=pp2
		     endif
;		.gel
		     if frm eq '.gel'   then begin
			flg='.gel'
			comhis='sl_lampscan,"'+flg+'",w'+wnumber+'-1,0,0,"'+pth+fname+'"'
			i =execute( 'sl_lampscan, flg ,w' + wnumber + ',pp2,0,0, pth+fname' )
		     endif
;		.image
		     if frm eq '.image' then begin
			flg='.image'
			comhis='sl_lampscan,"'+flg+'",w'+wnumber+'-1,0,0,"'+pth+fname+'"'
			i =execute( 'sl_lampscan, flg ,w' + wnumber + ',pp2,0,0, pth+fname' )
		     endif
;		.SCAN
		     if frm eq '.WIND'  then begin
			flg='restore'
			comhis='sl_lampscan,"'+flg+'",w'+wnumber+'-1,0,0,"'+pth+fname+'"'
			i =execute( 'sl_lampscan, flg ,w' + wnumber + ',pp2,0,0, pth+fname' )
		     endif
;		.PICT
		     if frm eq '.PICT'  then begin
			colr=0 & colg=0 & colb=0
			comhis='READ_PICT,'+pth+fname+',w'+wnumber+'r,g,b'
			i =execute( 'READ_PICT, pth+fname, w' + wnumber + ', colr,colg,colb')
			tvlct,colr,colg,colb
		     endif
;		DIAL
		     if frm eq 'dial_*.pro*' then begin
			dname=strmid(fname,5,strpos(fname,'.')-5)
			comhis='DialInit, "'+dname+'", d='+wnumber+', path="'+pth+'"'
			i =execute( comhis )
			if i then pp2=0
		     endif
;		Others
		     if (frm eq '*') or (frm eq '.*')  then $
			    P_ICK_SCAN     , pp2,frm,wnumber,uv,hyst,fname ,pth $

		     else   p_did_just_read, pp2,frm,wnumber,uv,hyst,fname ,info ,comhis
	      endif
	    end

;**	LOGO event
;**	**********
	391:	  p_did_mvlog,  event,uv

;**	Calibration
;**	***********
	394:	  p_did_calev,  event,uv

;**	Journal
;**	*******
	395:	  p_did_journal_print,uv
	396:begin p_set_font,1
		  p_did_journal,event,uv
		  p_set_font,0 & end
;**	Save all
;**	********
	397:p_did_save_session

;**	Exit
;**	****
	398:begin
;	    DON_WRITE_PROG_MAC ,0
	    if lamp_b1 gt 0 then begin
	       if sys_dep ('MAP') gt 1 then if lamp_siz gt 1000 then begin
		  widget_control,bad_id=i,lamp_don(0),/destroy
		  widget_control,bad_id=i,lamp_ben(0),/destroy
		  widget_control,bad_id=i,lamp_ben(9),/destroy
		  LOGO,1 & endif
	       P_MUS,'mus_cannon'                       & l_message=0
	       if (george gt 0) then WebOff
	       widget_control,bad_id=i,lamp_b1,/destroy & lamp_b1  =0

;**	       In case P_DYING did'nt destroyed all the group at time.
	       rout=[1L]
	       if  sys_dep('VERSION') ge 5.1 then ii=execute('rout=widget_info(/managed)')
	       if  rout(0)  gt 0 then exok=0 else exok=1
	       if (exok) then EXIT
;	       widget_control,/reset
	    endif else exit
	    end

;**	Destroy
;**	*******
	399:begin wait,.3 & widget_control,bad_id=i,event.top,/destroy & end

	else:
	endcase

mis:
;if ab eq 0 then print,string(7b)

return
end

pro p_did_before_read, wnumber,laber
;** *****************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

		wnumber=lamp_wrd
		wnumber=strtrim(strmid(wnumber,1,2),2)
		did_curw=fix(wnumber)
		widget_control,bad_id=i,laber, set_value='Reading in '+'# '+wnumber
return
end
pro p_did_just_read, pp2,frm,wnumber,uv,hyst,fname ,info ,comhis
;** ***************
@lamp.cbk
 common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    		did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

	if pp2 ge 0 then  begin
		            if frm eq '_LAMP'  then wintb(did_curw)=-1 else wintb(did_curw)=pp2
		            if frm eq '.hdf'   then wintb(did_curw)=-1 else wintb(did_curw)=pp2
		            if frm eq '.xml'   then wintb(did_curw)=-1 else wintb(did_curw)=pp2
	                    if frm ne 'dial_*.pro*' then $
	                    if frm ne '*.*'         then $
			           ii=execute('P_ICK_MICO, wnumber,x'+wnumber+',y'+wnumber+',uv,pp2') $
	                    else   ii=execute('P_ICK_MICO, wnumber,x'+wnumber+',y'+wnumber+',uv,-10')
	endif

	if hyst ne '' then hyst=fname+' <-- '+hyst else hyst=fname
	p_did_after_read,  wnumber,uv(3), hyst ,pp2 ,comhis

	if (pp2 ge 0) and (frm ne '_LAMP') and (frm ne '.hdf') and (frm ne '*.*') $
			  and (frm ne 'dial_*.pro*') and (frm ne '.xml') then begin siz=0L
			i=execute('siz=size(w'+wnumber+')')
			siz1=siz(1) & if siz(0) gt 1 then siz2=siz(2) else siz2=1
			fixw=fix(wnumber)
			clearpar,fixw,wnumber
			x_tit    (fixw)=' X,Y -> '+strtrim(string(siz1),2)+','   + $
						   strtrim(string(siz2),2)
			z_tit    (fixw)=' Min='+strtrim(string(w_min(fixw)),2)+ $
					' Max='+strtrim(string(w_max(fixw)),2)
			other_tit(fixw)  =fname
			head_tit (fixw,2)=frm

		        if (frm eq '.gel')  or (frm eq '.image') or (frm eq '.WIND') or $
		           (frm eq '.PICT') or (frm eq '') then begin

			   other_tit(fixw) =other_tit(fixw) + x_tit(fixw) + z_tit(fixw)
			   n=n_elements(info)

			   if (frm eq '.gel')  then if n gt 1 then begin
			   	other_tit(fixw)=other_tit(fixw)+' created '+info(0)
			   	w_tit    (fixw)=info(1)
			   	endif
			   if (frm eq '.WIND') then if n ge 5 then begin
			   	tmp=strtrim(info(0),2) & if tmp ne '' then w_tit(fixw)=tmp
			   	tmp=strtrim(info(1),2) & if tmp ne '' then x_tit(fixw)=tmp
			   	tmp=strtrim(info(2),2) & if tmp ne '' then y_tit(fixw)=tmp
			   	tmp=strtrim(info(3),2) & if tmp ne '' then z_tit(fixw)=tmp
			   	tmp=strtrim(info(4),2) & if tmp ne '' then other_tit(fixw)=tmp
			   	endif
			endif
	endif
	if pp2 ge 0 then P_MUS,'mus_shot'
return
end
pro p_did_after_read, wnumber,laber,fname,pp2 ,comhis
;** ****************
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

		if pp2 ge 0 then begin
			   did_curw=fix(wnumber)
			   to_don_history, did_curw , 0 , comhis
			   if strpos(strupcase(comhis),'DIAL') ge 0 then tit='d' else tit='w'
			   widget_control,bad_id=i,laber, set_value=tit+wnumber+' loaded ...'

			   if wintb(did_curw) ge 0 then ii=execute("sl_lampscan,'purge',wintb(did_curw)")
			   wtb  (did_curw)=0
		endif else widget_control,bad_id=i,laber, set_value='No file restored !!!'
		print,string(7b)
return
end

pro write_ps
;** ********
    p_did_event,0,[-88,350,0,0,0,0,0,0,0]
end
pro p_did_ps_header, yo , widx ,out_file
;** ***************
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

		tvlct ,  cur_r,cur_g,cur_b ,/get
		loadct,1,ncolors=did_icon(0,0)+1,/silent
		keep_o  =!order
		!order  =0
		tv,did_icon,0    ,yo   ,xsize=1.,ysize=0.5   ,/inches
		tvlct ,  cur_r,cur_g,cur_b
		icl     =n_elements(cur_r)/2
;		icl     =2
		if widx gt 0 then begin titi=strmid(strtrim(w_tit(widx),2),0,55)
		   on_ioerror,misps
		   device,/helvetica,/bold
		   xyouts,0,-0.20*2540,   other_tit(widx),CHARSIZE =0.65,font=0,/device,color=icl
		   xyouts,1.5*2540 ,yo*2540  ,  titi     ,CHARSIZE =1.5 ,font=0,/device,color=icl
		   misps: print,string(7b)
		endif

		device,/close_file
		!order=keep_o

		txt=out_file+' created'
		if lamp_devps ne '' then begin
						kppw=!D.Name & if sys_dep('MACHINE') eq 'win' then set_plot,'WIN'
						dir=''
						;if strpos(out_file,lamp_dvd) lt 0 then begin
						;	cd,current=dir
						;	if strmid(dir,strlen(dir)-1,1) ne lamp_dvd then dir=dir+lamp_dvd
						;endif
						bid=sys_dep('PRINT',lamp_devps,dir+out_file)  &    set_plot,kppw
						txt=txt+' ,sent to '+lamp_devps
						endif
		if l_message gt 0 then widget_control,bad_id=ii,l_message  ,set_value=txt
		if b_labins(6)    then if b_labins(7) gt 0 then $
		                       widget_control,bad_id=ii,b_labins(7),set_value=txt
return
end

pro Launch, what
;***************
CASE strlowcase(what) of
"colors":	p_did_event,0,[0,347,0]
"scan":		p_did_event,0,[0,306,0,-1]
"superplot":	p_did_event,0,[0,352,0]
"gk_fit":	p_mac_event,0,[0,580,0]
"ben_int":	desk_event ,0,[0,401,0]
"ben_def":	desk_event ,0,[0,402,0]
"ben_rgp":	desk_event ,0,[0,403,0]
"wdiag":	desk_event ,0,[0,401,-1]
"tomo":		desk_event ,0,[0,401,-2]
"calib":	desk_event ,0,[0,307,0]
"inx":		desk_event ,0,[0,571,0]
"exit":		p_did_event,0,[0,398,0]
ELSE:
ENDCASE
end

pro SaveSession
    p_did_save_session & end
pro p_did_save_session
;** ******************
@lamp.cbk
@dons.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

	save,/variables,filename='lamp.ses'
	txt='Current Lamp Session is SAVED ....'
	if l_message gt 0 then begin  print,string(7b) & widget_control,bad_id=ii,l_message  ,set_value=txt
			  endif else  print,txt
	if b_labins(6)    then if b_labins(7) gt 0 then  widget_control,bad_id=ii,b_labins(7),set_value=txt
	P_MUS,'mus_shot'
	DID_WRITE_JOURNAL
return
end

pro did_set, text
;** *******
@lamp.cbk
@dons.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    i=execute(text)
return
end

pro p_did_setwin0, map=map
;** *************
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

catch,stat & if stat ne 0 then begin catch,/cancel & print,!err_string
		did_wd  =widget_draw  (did_wb ,retain=2,xsize=did_x,ysize=did_y,$
					 /button_events,/motion_events)
		if GEORGE ne 1 then widget_control,did_wd,draw_motion_events=1 & return
             endif
if !D.name eq 'Z' then begin device,set_resolution=[did_x,did_y] & erase
endif else if did_wd gt 0 then begin widget_control,did_wd  ,get_value=did_win0
			             if keyword_set(map) then WIDGET_CONTROL,did_wb ,bad_id=ii,MAP=1
			             WSET,did_win0   &  endif
return
end

pro to_did_cur,	wkspce
;** **********
;**
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    if strlen(wkspce) le 2 then bb=' ' else bb=''
    if n_elements(did_wsc) eq 1 then widget_control,bad_id=i,did_wsc,$
    						    set_value='Plot '+strupcase(wkspce)+bb

return
end

pro DECOR, cti_,ctj_,a1_,a2_,DIS_,PIXV_,PIXH_,shap,squa,LVu_,LVd_,LHl_,LHr_,FQ_,PHI_,DXT_,DYT_,FCTX_,FCTY_
;** *****
;**
common depli,cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar

WDIAG, /nw

cti=cti_ & ctj=ctj_
if n_elements(a1_)   eq 1 then a1=a1_		else a1=0.
if n_elements(a2_)   eq 1 then a2=a2_		else a2=360.
if n_elements(DIS_)  eq 1 then DIS=DIS_		else DIS=100.
if n_elements(PIXV_) eq 1 then PIXV=PIXV_	else PIXV=150.
if n_elements(PIXH_) eq 1 then PIXH=PIXH_	else PIXH=150.
if n_elements(LVu_)  eq 1 then LVu=LVu_		else LVu=0
if n_elements(LVd_)  eq 1 then LVd=LVd_		else LVd=0
if n_elements(LHl_)  eq 1 then LHl=LHl_		else LHl=0
if n_elements(LHr_)  eq 1 then LHr=LHr_		else LHr=0
if n_elements(FG_)   eq 1 then FQ=FQ_		else FQ=4
if n_elements(PHI_)  eq 1 then PHI=PHI_		else PHI=0
if n_elements(DXT_)  eq 1 then DXT=DXT_		else DXT=0.
if n_elements(DYT_)  eq 1 then DYT=DYT_		else DYT=0.
if n_elements(FCTX_) eq 1 then FCTX=FCTX_	else FCTX=-1.
if n_elements(FCTY_) eq 1 then FCTY=FCTY_	else FCTY=-1.
if n_elements(shap)  eq 1 then shape=shap	else shape=0
if n_elements(squa)  eq 1 then squar=squa	else squar=0

; then DEPLI,  area, ry1,ry2 ,arel,diam,xdiam,b_red, AV,AH
end

;*************************************** Process Display *********************************
;*************************************** Process Display *********************************
;*************************************** Process Display *********************************

pro FORCPLOT ,wi, w=wj ,image=im,contour=co,surface=su,vrml=vr,below=bl,beside=bs,pscript=ps,gif=gf,png=pg,htm=hm
    SEE	     ,wi, w=wj ,image=im,contour=co,surface=su,vrml=vr,below=bl,beside=bs,pscript=ps,gif=gf,png=pg,htm=hm & end
pro SEE      ,wi, w=wj ,image=im,contour=co,surface=su,vrml=vr,below=bl,beside=bs,pscript=ps,gif=gf,png=pg,htm=hm $
                       ,xypixels=sp, screen=sc, replot=rp
;** ***
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

wk=0 & if n_elements(wi) eq 1 then wk=wi else if n_elements(wj)  eq 1     then wk=wj $
					 else if alone gt 0 then wk=alone else wk=one>1
if (wk gt 0) and (wk le lamp_sys+3) then begin
	ws=strtrim(string(wk),2) & s=0L
	bb=execute( 's=size(w' + ws + ')' )
	keep_repr=did_repr & did_repr(0:2)=0
	keep_fu  =did_fu
	keep_st  =styles
	if vff(2) eq 1 then begin
				if vff(3) eq 0 then did_repr(0)=1
				if vff(3) eq 1 then did_repr(1)=1
				if vff(3) eq 2 then did_repr(2)=1
				did_repr(5)= vff(10)
				did_repr(6)= vff(12)
				did_fu	   = vff(5)
				endif
	if keyword_set(vr)	then begin su=1 & bs=1 & endif
	if keyword_set(im)      then did_repr(0)    =im
	if keyword_set(co)      then did_repr(1)    =co
	if keyword_set(su)      then did_repr(2)    =su
	if keyword_set(vr)      then did_repr(2)    =1
	if keyword_set(vr)      then styles(0,1)    =1
	if keyword_set(ps)      then styles(3,0)    =1
	if keyword_set(ps)      then w_numor(0)     ="lamp.ps"
	if keyword_set(gf)      then styles(3,0)    =2
	if keyword_set(pg)      then styles(3,0)    =4
	if keyword_set(hm)      then styles(3,0)    =3
	if keyword_set(sc)      then styles(3,0)    =5
	if keyword_set(bl)      then did_fu	    =0
	if keyword_set(bs)      then did_fu	    =1
	if n_elements (sp) eq 2 then did_repr(18)   =sp
	if keyword_set(rp) and (n_elements(wbeside) gt 1) then turn=wbeside(0) else turn=0
	if (!D.name ne 'Z')     then $
	if (!D.flags and 65536) eq 0 then did_fu=0 else if ((b_labins(3) eq 1) and (!D.name eq "X")) then did_fu=1

;	if ((did_fu eq 0) and (GEORGE ne 0)) then DialWSet

	p_did_drawidl, turn, ws, s

	did_repr=keep_repr  &  styles  =keep_st  &  did_fu  =keep_fu
endif
return
end

pro FORCSET ,image=im,contour=co,surface=su,rot=rot,below=bl,beside=bs,xrange=xr,yrange=yr,$
				 log=lg,zlim=zl,regular=rg,vrml=vr,view=va
    SEEM    ,image=im,contour=co,surface=su,rot=rot,below=bl,beside=bs,xrange=xr,yrange=yr,$
				 log=lg,zlim=zl,regular=rg,vrml=vr,view=va		   & end
pro SEEM    ,image=im,contour=co,surface=su,rot=rot,below=bl,beside=bs,xrange=xr,yrange=yr,$
				 log=lg,zlim=zl,regular=rg,vrml=vr,view=va
;** ****
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o

    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

vff(2)=1 & vff(3)=-1
if keyword_set(vr)	 then begin   su=1 & bs=1 & endif
if keyword_set(im)       then vff(3)  =0
if keyword_set(co)       then vff(3)  =1
if keyword_set(su)       then vff(3)  =2
if n_elements (rot) eq 1 then vff(4)  =rot
if keyword_set(bl)       then vff(5)  =0
if keyword_set(bs)       then vff(5)  =1
if n_elements (xr)  eq 2 then vff(6:7)=xr
if n_elements (yr)  eq 2 then vff(8:9)=yr
if n_elements (lg)  eq 1 then vff(10) =lg
if n_elements (zl)  eq 1 then vff(11) =zl
if n_elements (rg)  eq 1 then vff(12) =rg
if n_elements (va)  eq 1 then vff(13) =va
return
end

pro FORCPAR, param
;** *******
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
h=10 & m=did_y/h
n=n_elements(param)<m -1

if n gt 0 then begin
   y=did_y-h
   k=!window
   p_did_setwin0 & erase
   for i=0,n do begin xyouts,1,y,param(i),/dev,charsize=1.2,font=0  &  y=y-h & endfor
   if k gt 0 then if !D.name ne 'Z' then wset,k
endif
end

pro DRAWIND  ,xsiz,ysiz , DrawId=basw
;** *******
;**
@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

if  l_message le 0 then return

if (n_elements(xsiz) ne 1) then xsiz=512
if (n_elements(ysiz) ne 1) then ysiz=512
if (xsiz gt 0) and (ysiz gt 0) and (xsiz le 4000) and (ysiz le 4000)  then begin
	keep_rep =did_repr & did_repr(2)=1 & did_repr(6)=0 & did_repr(7)=0
	keep_fu  =did_fu   & did_fu     =1
	w0	 =[[xsiz,xsiz],[ysiz,ysiz]]

	p_did_drawidl,	0, '0' , size(w0) , DrawId=basw

	did_repr =keep_rep
	did_fu   =keep_fu
endif
return
end

pro p_did_rep, r,spc
;** *********
;**
;		r=0 image
;		r=1 image   +  surface
;		r=2 image   +  contour
;		r=3 image   +  contour   +  surface
;		r=4 contour +  surface
;		r=5 contour
;		r=6 surface

    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
		spc=0
		r  =0
		if (did_repr(0) eq 1) and (did_repr(1) eq 1) and (did_repr(2) eq 1) then r=3 else $
		if (did_repr(0) eq 1) and (did_repr(1) eq 1) then r=2 else $
		if (did_repr(0) eq 1) and (did_repr(2) eq 1) then r=1 else $
		if (did_repr(1) eq 1) and (did_repr(2) eq 1) then r=4 else $
		if (did_repr(1) eq 1) then r=5			      else $
		if (did_repr(2) eq 1) then r=6
		if (r eq 5) then spc=-10
		if (r eq 6) then spc= 10
return
end

pro p_did_drawidl,	turn,  string_w	, isiz , DrawId=basw
;** *************
;**
;** turn= 0	new plot
;** turn= 1	replot +10 degres
;** turn=-1	replot -10 degres
;** turn> 2	replot beside
;** turn<-2	replot LiveTools

@lamp.cbk
    common c_did,	did_x,did_y,did_wb,did_wd,did_wsp,did_fu,did_curw,did_wsc,did_tio,did_pio,$
    			did_repr,did_scan,did_surf,did_inib,did_icon,did_lamp,did_pix,did_buf,did_o
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff
    common c_drow
    common c_drow2, bas_x,bas14
;**
    common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
;**
    common c_codens,	zz,mx1,mx2,my1,my2,mz1,mz2,mxv2,cdbox,idn,CODENS
    trap_ws='0'
    redraw = 0 & errps=0
    bobol  = 0
    new    = 1
    off60  = 60
    off90  = off60*3/2
    p_did_rep,rrr,spc

    keeprp1=did_repr(1)

    if (turn lt -2)     and (turn gt -10000) then liveT=1  else liveT=0
    if (turn lt -10000) and (turn gt -20000) then liveC=1  else liveC=0
    if (turn lt -20000) and (turn gt -30000) then liveA=1  else liveA=0
    if (turn lt -30000) and (turn gt -40000) then begin rrr  =7 &  did_repr(1)=1  & endif
    if (turn eq  0)     or  (turn gt 2)      then $
                        if  (sys_dep('VERSION') ge 5.0) and (b_labins(3) eq 0) then begin
                        if (rrr eq 3) and (isiz(0) eq 1) then liveT=10
                        if (rrr eq 4) and (isiz(0) eq 1) then liveT=10
                        if (rrr eq 4) and (isiz(0) eq 2) and (did_fu eq 1) then liveC=1
                        if (rrr eq 2) and (isiz(0) eq 3) then liveA=1
                       ;if (rrr eq 3) and (isiz(0) eq 3) then liveT=10
                        endif
    if (turn lt -2)     then turn=0
    if styles(3,0) eq 1 then begin ps_ok =1	& styles(3,0)=0 & endif else ps_ok =0
    if styles(3,0) eq 2 then begin gif_ok=1	& styles(3,0)=0 & endif else gif_ok=0
    if styles(3,0) eq 3 then begin htm_ok=1	& styles(3,0)=0 & endif else htm_ok=0
    if styles(3,0) eq 4 then begin gif_ok=1	& styles(3,0)=0 & png_ok=1 & endif else png_ok=0
    if styles(3,0) eq 5 then begin scr_ok=1	& styles(3,0)=0 & endif else scr_ok=0

    if (turn gt  2) then fu_out=1  else fu_out=did_fu
    if (did_repr(18) gt 50) and (did_repr(19) gt 50) then fu_out=1
    
    if (turn eq  0) and (string_w eq '0') then wonly =[w0(0,0),w0(1,1)]  else wonly=[0,0]
    if (turn eq  0) or  (turn gt 2) then  begin
	wnumber=string_w
        idn    =fix(wnumber)
	if wonly(0) eq 0 then w0 =0
	uxy=0 & axy=0
	siz=isiz
	if (siz(1) eq 1) or (siz(2) eq 1) then  begin
			bb=execute( 'w' + wnumber + '=reform(w' + wnumber + ')' )
			bb=execute( 'siz=size(w' + wnumber + ')' ) & endif
	bb=execute( 'if n_elements(x'+wnumber+') gt 1 then x' + wnumber + ' =reform(x' + wnumber + ')' )
	bb=execute( 'if n_elements(y'+wnumber+') gt 1 then y' + wnumber + ' =reform(y' + wnumber + ')' )
	bb=execute( 'if n_elements(z'+wnumber+') gt 1 then z' + wnumber + ' =reform(z' + wnumber + ')' )
    endif else  if (n_elements(flgsurf) gt 1) and ((did_repr(2) eq 1) or (siz(0) eq 3))  then $
    		if  flgsurf(2) eq  idn then redraw=1
		
;Density points?
;***************
        sizx =[0L]  & i=execute('sizx=size(x'    + wnumber + ')' ) & CODENS= 0
        sizy =[0L]  & i=execute('sizy=size(y'    + wnumber + ')' )
        sizz =[0L]  & i=execute('sizz=size(z'    + wnumber + ')' )
	if (siz (0)  le 2) and (sizx(0) eq 1) and (sizy(0) eq 1) and (sizz(0) eq 1)  then $
        if (siz (1)  eq sizx(1)) and (siz (1)  eq sizy(1)) and (siz (1)  eq sizz(1)) then $ 
	if (siz (0)  eq 1) or (siz (2) le 3) then CODENS=-1
	
    flgsurf=0
    isurf  =0
    if CODENS eq -1 then isurf=1
    if  siz(0) gt 1 then if (did_repr(2)) or ((siz(0) eq 3) and ((did_repr(0) eq 0) and (did_repr(1) eq 1))) then isurf=1

;Z angle !
    if isurf then begin
			if vff(2) eq 1 then rx=vff(13)
			if vff(2) eq 1 then rz=vff(4)  else begin
				srz='+30' & rz=20
				if  l_message gt 0 then $
			    	    widget_control,bad_id=i,did_repr(4),get_value=srz else srz=string(vff(4))
				 srz=strcompress(srz(0),/remove_all)
				 deg=strpos(srz,'^')
				 if deg gt 0 then srz=strmid(srz,0,deg)
				 on_ioerror,misrz
				 rz=fix(srz)
				 if (turn eq 1) or (turn eq -1) then begin
				    rz=rz+ turn*10
				    if rz ge  360 then rz=rz-360
				    if rz le -360 then rz=rz+360
				    srz=strtrim(string(rz),2)+'^'
				    if l_message gt 0 then widget_control,bad_id=i,did_repr(4),set_value=srz
				 endif
				 misrz:
			endelse
    endif
;***
    if (turn eq 0) or (turn gt 2) or (redraw eq 1) then begin
;***
       bst_x=did_x  & bst_y=did_y

;Density points? or object? or standard plot?
;*************** ** ******* ** **************
	IF  b_labins(3) eq 0  then begin
	 if CODENS ne 0       then begin
	    DID_OBJET,idn,monobj
	    if monobj gt 0 then begin CODENS=monobj & liveT=0 & redraw=0 & endif
	 endif
	 if fu_out eq 0 then if (CODENS gt 0)     then $
			WIDGET_CONTROL,did_wb ,bad_id=ii,MAP=0 $ ;Case we come back from liv_objet (below)
	    else begin	WIDGET_CONTROL,did_wb ,bad_id=ii,MAP=1 & WIDGET_CONTROL,did_wc,bad_id=ii,MAP=0
	                WIDGET_CONTROL,did_4dM,bad_id=ii,sensitive=0  & endelse
	ENDIF
;********
       use_scan=0
           if (siz(0) gt 1) and (styles(2,0) eq 3)  then use_scan=1
           if (siz(0) eq 3) and (styles(2,0) eq 4)  then use_scan=1
           if (siz(0) eq 3) and (did_repr(2)+did_repr(1) eq 0)  then use_scan=1
	   if (siz(0) eq 2) and (did_repr(6) eq 0)  then $
			if  did_surf(0)  eq 1 then begin
	   				 if (rrr eq 5) and (styles(1,1)  eq 1) then use_scan=1
	   				 if (rrr eq 6) and (styles(0,1)  eq 1) then $
						    if sys_dep('VIEWER') eq 0  then use_scan=0 ;or = 1 !!!
			endif
       if (use_scan ne  0) then if (did_scan eq -1) then begin SL_SCANLOAD,did_scan,lamp_dir
			                                 if (did_scan ge 0) then loadct,tcol & endif
       if (did_scan lt  0) then use_scan=0

;      if (rrr eq 6) and (styles(0,1) eq 1) then $
       if ((rrr eq 1) or (rrr eq 3) or (rrr eq 4) or (rrr eq 6)) and (styles(0,1) eq 1) then $
		if (b_labins(3) eq 2) or (sys_dep('VIEWER') eq 1) then rrr=7

;Set below or beside !
;*** ***** ** ******
       if (htm_ok) or (liveT ne 0) or (liveC) or (liveA) or (rrr eq 7) then $
        if CODENS  ge 0 then begin
	               fu_out=0 & use_scan =0 & redraw=0 & endif
       if fu_out eq 0 then begin if (redraw eq 0) then LOGO,4
                                 if (liveT  eq 0) then p_did_setwin0
       endif else begin
            if n_elements(wbeside) le 1 then    redraw=0 $
             else if  redraw  eq 1  then begin   widget_control,bad_id=i,wbeside(0),map=1
            					 if i ne 0 then RETURN else if !D.name ne 'Z' then $
            					                              if wbeside(2) gt 0 then wset,wbeside(2)
       endif & endelse
       
      if (ps_ok) then if use_scan gt 0 then begin ps_ok=0 & scr_ok=1 & endif

;redraw=0
;******
       if redraw eq 0 then begin

	if use_scan eq 0 then begin
	   !p.background =0
	   !p.noerase =0
	   !p.color =255
	   !p.font =0
	   !order =0
	   !x.style= 1 & !y.style= 1 & !z.style= 1
	   !x.range= 0 & !y.range= 0 & !z.range= 0
	   !p.position=[0,0,0,0]     & !p.multi= 0
	   if (liveT ne 0) or $
	    (((did_repr(2) ne 1) or (siz(0) eq 1)) and (CODENS eq 0) and (siz(0) ne 3)) then begin
		if ps_ok then !p.title   ='' else !p.title   =strmid(w_tit(idn),0,100)
		if ps_ok then !p.subtitle='' else !p.subtitle=strmid(other_tit(idn),0,100)
		!x.title   =strmid(x_tit(idn),0,100)
		!y.title   =strmid(y_tit(idn),0,100)
		!z.title   =strmid(z_tit(idn),0,100)
		if (not ps_ok) then $
		if did_repr(5) eq 1 then if siz(0) lt 2 then !p.subtitle=!p.subtitle + ' Y=LOG10(f(x))' else $
						     	     !p.subtitle=!p.subtitle + ' Z=LOGn (z)'
	   endif
	endif
;Use true axis !
;*** **** ****
	xx=[1L] & yy=[1L] & zz=[1L] & ee=0 & nn=1 & vv=0
	if (sizx(0)  eq 0) or  (sizx(1) ne siz(1))   then i=execute('x'+ wnumber+'=lindgen(siz(1))+1')
	if (siz(0)   eq 3) then $
	if (sizz(0)  eq 0) then i=execute('z'+ wnumber+'=lindgen(siz(3))+1')
	if  CODENS   eq 0  then begin
	 if  siz(0)  eq 1  then i=execute('y'+ wnumber+'=y'+ wnumber+'(0)') else $
	 if (sizy(0) eq 0) or ((sizy(0) eq 1) and (sizy(1) ne siz(2)))$
			   or ((sizy(0) eq 2) and (sizy(2) ne siz(2)))      then $
			        i=execute('y'+ wnumber+'=lindgen(siz(2))+1')
	endif

	if (sys_dep('STUDENT')) and (rrr eq 0) and (fu_out eq 1)  then begin
	                                                           did_repr(1)=1 & rrr=5 & endif
	i =execute('xx= x'+wnumber) & sizx=size(xx)
	i =execute('yy= y'+wnumber) & sizy=size(yy)
	i =execute('zz= z'+wnumber) & sizz=size(zz)

	if did_repr(6) eq 1 then begin
		uxy=1
		if (rrr eq 0) and (siz(0) eq 2) then begin did_repr(1)=1 & rrr=2 & endif
	endif

	if ( (xx(1) -xx(0))*(siz(1)-1) eq xx(siz(1)-1)-xx(0)) then if (siz(0) gt 1) then $
	if ( (yy(1) -yy(0))*(siz(2)-1) eq yy(siz(2)-1)-yy(0)) then axy=1 else axy=0 else axy=1

;Use errors !
	if siz(0) eq 1 then begin sizee=[0L]
	   i = execute('sizee=size(e' + wnumber + ')' )
	   if (sizee(0) eq 1) and (sizee(1) eq siz(1)) then i=execute('ee= e'+wnumber)
	   endif
	if siz(0) eq 1 then begin siznn=[0L]
	   i = execute('siznn=size(n' + wnumber + ')' )
	   if (siznn(0) eq 1) and (siznn(1) eq siz(1)) then i=execute('nn= n'+wnumber)
	   endif
	if CODENS gt 0 then $
	if siz(0) eq 1 then begin sizvv=[0L]
	   i = execute('sizvv=size(pv'+ wnumber + ')' )
	   if (sizvv(0) eq 2) and (sizvv(1) eq 2)      then i=execute('vv=pv'+wnumber)
	   if (sizvv(0) eq 1) and (sizvv(1) eq siz(1)) then i=execute('vv=pv'+wnumber)
	   endif
;Stretch !
	keyrangx=''  & xl=0 & xf=0 & mx1=0 & mx2=0
	keyrangy=''  & yl=0 & yf=0 & my1=0 & my2=0
	keyrangz=''  & zl=0 & zf=0 & mz1=0 & mz2=0
	if vfl(0) ge 0 then begin xf=vfl(0) & xl=vfl(1) & if xl ge siz(1) then xl=siz(1)-1 & endif
	if vfl(2) ge 0 then begin yf=vfl(2) & yl=vfl(3) & if yl ge siz(2) then yl=siz(2)-1 & endif
;Stretch x !
	on_ioerror,misxrange
	if (((did_repr(7) eq 1) and (vfl(0) lt 0) and (did_repr(10) gt 0)) or (vff(6) ne vff(7))) then begin

	    if  sizx(0) le 1 then xw=0   else xw=siz(2)/2

	    mx2  =max(xx(*,xw),min=mx1) ;or xx(siz(1)-1) & xx(0)
	    kpmx1=mx1  & kpmx2=mx2

	    if vff(2) eq 1 then begin
		if vff(6) ne vff(7) then begin mx1=vff(6) & mx2=vff(7) & endif
	    endif else begin
	    	widget_control,bad_id=i,did_repr(10),get_value=smxr
				 smxr=STRLOWCASE(strcompress(smxr(0),/remove_all))
				 if   STRPOS(smxr,'min') lt 0   then mx1=float(smxr)
	    	widget_control,bad_id=i,did_repr(11),get_value=smxr
				 smxr=STRLOWCASE(strcompress(smxr(0),/remove_all))
				 if   STRPOS(smxr,'max') lt 0   then mx2=float(smxr)
	    endelse

	    if CODENS ne 0 then begin
	    	idx=where((xx ge mx1) and (xx le mx2)) & nidx=n_elements(idx)
	    	if (nidx gt 2) and (nidx lt n_elements(xx)) then begin
	    	    i =execute( 'w0= w'+wnumber +'(idx)') & siz=size(w0) & wnumber= '0'
		    MYREDUCE, idx, xx,yy,zz,ee,nn,vv
	    	    xl=0 & xf=0 & endif
	    endif else begin
		ivf= where(xx(*,xw) ge mx1 ,count1)
		     if count1 gt 0 then xf=ivf(0) else xf=0
		ivl= where(xx(*,xw) ge mx2 , count2)
		     if count2 gt 0 then xl=ivl(0) else xl=siz(1)-1
		if (count1 le 0) or (count2 le 0) or (siz(0) eq 1) then keyrangx=',xrange=[mx1,mx2]'
		if ((kpmx1 gt mx1) or (kpmx2 lt mx2)) and (siz(0) eq 1) then axy=0
	    endelse
	endif
	if (xl gt xf) and (xf ge 0) and (xl lt siz(1)) and ((xf ne 0) or (xl ne siz(1)-1)) then begin
		  if siz(0) eq 1 then i=execute( 'w0= w'+wnumber +'(xf:xl)'     )
		  if siz(0) eq 2 then i=execute( 'w0= w'+wnumber +'(xf:xl,*)'   )
		  if siz(0) gt 2 then i=execute( 'w0= w'+wnumber +'(xf:xl,*,*)' )
		  siz=size(w0)
		  wnumber= '0'
		  if sizx(0) eq 2 then xx=xx(xf:xl,*) else xx=xx(xf:xl)
		  if sizy(0) eq 2 then yy=yy(xf:xl,*)
		  if n_elements(ee) gt 1 then ee=ee(xf:xl)
		  vfl(0)=xf & vfl(1)=xl
		  set_xy
	endif else vfl(0)=-1
	misxrange:
	if vfl(0) lt 0 then begin vfl(0)=0 & vfl(1)=siz(1)-1 & endif

;Stretch y !
	if (((did_repr(8) eq 1) and (did_repr(12) gt 0)) or (vff(8) ne vff(9))) then begin
	    my1=w_min(idn)
	    my2=w_max(idn)
	    if (CODENS ne 0) or (siz(0)  ge 2)  then  begin
	       if sizy(0) le 1 then yw=yy else yw =reform(yy(siz(1)/2,*))
	       my1=min(yw,max=my2)  &    endif

	    if vff(2) eq 1 then begin
		if vff(8) ne vff(9) then begin my1=vff(8) & my2=vff(9) & endif
	    endif else begin
	    	on_ioerror,misyrange
	    	widget_control,bad_id=i,did_repr(12),get_value=smyr
				 smyr=STRLOWCASE(strcompress(smyr(0),/remove_all))
		 		 if   STRPOS(smyr,'min') lt 0 then my1=float(smyr)
	    	widget_control,bad_id=i,did_repr(13),get_value=smyr
				 smyr=STRLOWCASE(strcompress(smyr(0),/remove_all))
	    		 	 if   STRPOS(smyr,'max') lt 0 then my2=float(smyr)
	    	misyrange:
	    endelse
	endif
;	For Image
	if (siz(0) ge 2) or (CODENS ne 0) then begin

	if ((did_repr(8) eq 1) and (did_repr(12) gt 0)) or (vff(8) ne vff(9)) then if vfl(2) lt 0 then begin
	    if CODENS ne 0 then begin
		idx=where((yy ge my1) and (yy le my2)) & nidx=n_elements(idx)
		if (nidx gt 2) and (nidx lt n_elements(yy)) then begin
	    	    i=execute( 'w0= w'+wnumber +'(idx)') & siz=size(w0) & wnumber= '0'
		    MYREDUCE, idx, xx,yy,zz,ee,nn,vv
	    	    yl=0 & yf=0 & endif
	    endif else begin
		ivf= where(yw ge my1 , count)
		     if count gt 0 then yf=ivf(0) else yf=0
		ivl= where(yw ge my2 , count)
		     if count gt 0 then yl=ivl(0) else yl=n_elements(yw)-1
	    endelse
	endif
	if (yl gt yf) and (yf ge 0) and (((yl lt siz(2)) and ((yf ne 0) or (yl ne siz(2)-1))))$
		  then begin
		  if siz(0)  eq 2 then i=execute( 'w0= w'+wnumber +'(*,yf:yl)'   ) else $
		  if siz(0)  gt 2 then i=execute( 'w0= w'+wnumber +'(*,yf:yl,*)' )
		  siz=size(w0)
		  wnumber= '0'
		  if sizy(0) eq 2 then yy=yy(*,yf:yl) else yy=yy(  yf:yl)
		  if sizx(0) eq 2 then xx=xx(*,yf:yl)
		  vfl(2)=yf & vfl(3)=yl
		  set_xy
	endif else vfl(2)=-1
	if vfl(2) lt 0 then begin vfl(2)=0 & vfl(3)=siz(2)-1 & endif

;	For Vector
	endif else begin
	   if ((did_repr(8) eq 1) and (did_repr(12) gt 0)) or (vff(8) ne vff(9)) then begin
	       if (my1 lt w_max(idn)) and (my2 gt w_min(idn)) then keyrangy=',yrange=[my1,my2]'
	   endif else begin my1=w_min(idn)
	   		    my2=w_max(idn) & endelse

	   if vfl(2) ge 0  then begin my2=vff(1) & keyrangy=',yrange=[my1,my2]' &  endif
	   vfl(2)=-1
	   if (my1 lt w_min(idn)) or (my2 gt w_max(idn)) then axy=0
	endelse

;Stretch scan or z!
	on_ioerror,miszrange
	if  (siz(0) eq 3) or (CODENS ne 0) then begin
	 if (did_inib(2)  gt 0) then widget_control,bad_id=ii,did_inib(2),map=1 & did_inib(2)=0
	 if (did_repr(17) eq 1) and (did_repr(15) gt 0) then begin

	    mz2=max(zz,min=mz1)

	    	widget_control,bad_id=i,did_repr(15),get_value=smzr
				 smzr=STRLOWCASE(strcompress(smzr(0),/remove_all))
				 if   STRPOS(smzr,'min') lt 0   then mz1=float(smzr)
	    	widget_control,bad_id=i,did_repr(16),get_value=smzr
				 smzr=STRLOWCASE(strcompress(smzr(0),/remove_all))
				 if   STRPOS(smzr,'max') lt 0   then mz2=float(smzr)

	    if CODENS ne 0 then begin
		idx=where((zz ge mz1) and (zz le mz2)) & nidx=n_elements(idx)
		if (nidx gt 2) and (nidx lt n_elements(zz)) then begin
	    	    i=execute( 'w0= w'+wnumber +'(idx)') & siz=size(w0) & wnumber= '0'
		    MYREDUCE, idx, xx,yy,zz,ee,nn,vv
	    	    zl=0 & zf=0 & endif
	    endif else begin
		ivf= where(zz(*) ge mz1 ,count1)
		     if count1 gt 0 then zf=ivf(0) else zf=0
		ivl= where(zz(*) ge mz2 ,count2)
		     if  count2 gt 0 then zl=ivl(0) else zl=n_elements(zz)-1
	    endelse
	 endif
	endif
	if (zl gt zf) and (zf ge 0) and ((zl lt siz(3)) and ((zf ne 0) or (zl ne siz(3)-1)))$
		  then begin
		  i=execute( 'w0= w'+wnumber +'(*,*,zf:zl)' )
		  siz=size(w0)
		  wnumber= '0'
		  zz=zz(zf:zl)
		  set_xy
	endif
	miszrange:

;Beside construction !
       if (rrr eq 2) and (fu_out eq 1) and (siz(0) eq 2) then bobol=90

       if fu_out eq 1 then begin
	  if turn gt 2 then begin
		i =0 & widget_control,bad_id=i,turn, get_uvalue=uv ,tlb_get_size=v2

		if i eq 0 then begin v2=long(v2) & uv=long(uv)
			new=0
			bst_x=uv(5)-bobol & bst_y=uv(6)
			wbeside=[uv(2),uv(3),uv(4),bst_x,bst_y,uv(9),uv(12)]
			
			widget_control,bad_id=i,uv(10), get_value=rsz_x & rsz_l=bst_x
			widget_control,bad_id=i,uv(11), get_value=rsz_y & rsz_h=bst_y
			on_ioerror,misrsz & rsz_l=fix(rsz_x(0))+off90
			                    rsz_h=fix(rsz_y(0))+off90   & misrsz:

			if (rsz_l ne bst_x) or (rsz_h ne bst_y) then begin ;User changed size texts
				bst_x=rsz_l<3000>100 & xi=bst_x            ;***********************
				bst_y=rsz_h<2000>100 & yi=bst_y
				new=2
				wait,.3
				if (not ps_ok) then widget_control,bad_id=i,turn,/destroy

			endif else if (v2(0) ne uv(7)) or (v2(1) ne uv(8)) then begin ;User resized window
				bst_x=(bst_x+v2(0)-uv(7))>(v2(0)-30)                  ;**** ******* ******
				bst_x=(bst_x-bobol)>100
				bst_y=(bst_y+v2(1)-uv(8))>100
				xi=bst_x & yi=bst_y
				new=2
				wait,.3
				if (not ps_ok) then widget_control,bad_id=i,turn,/destroy
			endif
		endif
	  endif
	  if new ne 0 then begin
	       if new ne 2 then begin ymini=lamp_siz/2
		bst_x=512  & bst_y=ymini
		if wonly(0) ne 0 then begin bst_x=wonly(0) & bst_y=wonly(1)
		endif else $
		if (siz(0) ge 2) and (CODENS eq 0) then begin
		   bst_x=siz(1) & bst_y=siz(2) & maxvol=long(512)*512

		   bty  =bst_x/(bst_y*6) & if bty lt 1 then bty=1
		   btx  =bst_y/(bst_x*6) & if btx lt 1 then btx=1
		   bst_x=bst_x*btx	 & bst_y=bst_y*bty

		   if (did_repr(2)+did_repr(1) eq 0) and (siz(0) eq 3) then begin
		   	f=float(bst_x)/bst_y
		   	fi=round(sqrt(siz(3))/f) & fj=round(sqrt(siz(3))*f)

		   	if fi gt 1 then bst_x=bst_x*fi
		   	if fj gt 1 then bst_y=bst_y*fj
		   	while bst_x gt 640 do bst_x=bst_x-fi
		   	while bst_y gt 640 do bst_y=bst_y-fj
		   endif
		   maxi=4000
		   if bst_x gt maxi then begin bst_x=bst_x/(bst_x/maxi) & bst_y=bst_y/(bst_x/maxi) & endif
		   if bst_y gt maxi then begin bst_y=bst_y/(bst_y/maxi) & bst_x=bst_x/(bst_y/maxi) & endif

		   while bst_x*bst_y lt maxvol do begin bst_x=bst_x+siz(1)
		   					bst_y=bst_y+siz(2) & endwhile
		   while ((bst_x/bst_y gt 4) and (bst_x gt siz(1))) do bst_x=bst_x-siz(1)
		   while ((bst_y/bst_x gt 4) and (bst_y gt siz(2))) do bst_y=bst_y-siz(2)
		   if (did_repr(1) eq 1) or (did_repr(2) eq 1) then begin
		   	if bst_x lt 256 then bst_x=(256/bst_x) * bst_x
		   	if bst_y lt 256 then bst_y=(256/bst_y) * bst_y
		        if isurf then if bst_x lt bst_y then bst_x=bst_y
		   endif
		endif
		if (did_repr(18) gt 50) and (did_repr(19) gt 50) then begin
			bst_x=did_repr(18) & bst_y=did_repr(19)
			did_repr(18)=0 & did_repr(19)=0 & endif
		bst_x=bst_x+off90 & bst_y=bst_y+off90
		if bst_x gt 512  +off90 then xi=min([bst_x,lamp_siz]) else xi=bst_x
		if bst_y gt ymini+off90 then yi=min([ymini,lamp_siz]) else yi=bst_y
	       endif
	       
	       wbeside=[0,0,0,0,0,0,0]
	       if !D.name ne 'Z' then begin
		if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0
		ttl='Lamp ' + strtrim(his(fix(string_w)),2)
		basid=widget_base  (title=ttl,/column,resource_name='lampdid',map=0,/tlb_size_events)
		bas1 =widget_base  (basid    ,/row)
		bas11=widget_button(bas1,value='Remove'    ,font=ft_b_normal,uvalue=[-88,349,basid])
		bas12=widget_button(bas1,value='Color'     ,font=ft_b_normal,uvalue=[-88,347,basid])
		if wonly(0) eq 0 then $
		bas1r=widget_button(bas1,value='Replot'    ,font=ft_b_normal,$
						uvalue=[-88,301, basid,fix(string_w)])
		lue="" & basmo=0L
		if (sys_dep('VERSION') lt 5.0) or (wonly(0) ne 0) then $
		bas13=widget_button(bas1,value='Annotate'  ,font=ft_b_normal) $
		else begin
		basm =widget_button(bas1,value='LiveTools' ,font=ft_b_normal, menu=2)
		bas13=widget_button(basm,value='Annotate'  ,font=ft_b_normal)
		if siz(0) eq 3 then lue='Slicer' else if CODENS eq -1 then lue='Plot 3Dbox' $
		                                 else if CODENS gt  0 then lue='4D object' else lue='LiveTools'
		if (CODENS gt 0) then begin
		  basmo=widget_button(basm ,value=lue,font=ft_b_normal,/menu) & widget_control,basmo,sensitive=0
		  d_4vM=widget_button(basmo,font=ft_normal,value='Vrml File',uvalue='Vrml')
		endif else $
		  basmo=widget_button(basm,value=lue,font=ft_b_normal,uvalue=[-88,301,-basid,fix(string_w)])
		  
		if (siz(0) eq 2) and (CODENS eq 0) then $
		basma=widget_button(basm,value='LiveContour',font=ft_b_normal,$
						uvalue=[-88,301,-basid-10000,fix(string_w)])
		if (siz(0) eq 3) then $
		basma=widget_button(basm,value='Animation'  ,font=ft_b_normal,$
						uvalue=[-88,301,-basid-20000,fix(string_w)])
		if (siz(0) ge 2) and (CODENS eq 0) then $
		basma=widget_button(basm,value='Vrml file'  ,font=ft_b_normal,$
						uvalue=[-88,301,-basid-30000,fix(string_w)])
		endelse
		bas14=widget_button(bas1,value='Print to'  ,font=ft_b_normal)
		ttl='lamp_W'+string_w+'.ps    '
		bas15=widget_text  (bas1,value=ttl,font=ft_b_normal,xsize=11+cap,ysize=1,/editable)

		bas_x=widget_base  (bas1 ,/exclusive,/row,uvalue=3)
		biscr=widget_button(bas_x,value='screen',font=ft_smallest,/no_release,uvalue=[-88,345,1,bas_x])
		if wonly(0) eq 0 then begin
		  if (sys_dep('VERSION') ge 5.4) then kif='png' else kif='gif'
		  bid=widget_button(bas_x,value= kif    ,font=ft_smallest,/no_release,uvalue=[-88,345,2,bas_x])
		  byd=widget_button(bas_x,value='ps'    ,font=ft_smallest,/no_release,uvalue=[-88,345,3,bas_x])
		endif
		bas2 =widget_base  (basid,/row)
		      put_logo	   ,bas2
		bid  =widget_label (bas2,value='Size'				    ,font=ft_smaller)
		pixrx=widget_text  (bas2,value=strtrim(fix(bst_x-off90),2),xsize=6,ysize=1,/editable ,font=ft_smaller)
		bid  =widget_label (bas2,value='x'				    ,font=ft_smaller)
		pixry=widget_text  (bas2,value=strtrim(fix(bst_y-off90),2),xsize=6,ysize=1,/editable ,font=ft_smaller)
		baslb=widget_label (bas2,value=string(replicate(32b,40))                  ,xsize=270 ,font=ft_b_normal)

		if CODENS gt 0 then begin
		  etxt="basd= widget_draw(basid, GRAPHICS_LEVEL=2,UVALUE='DRAW', RETAIN=0 ,"+ $
			                 "XSIZE=bst_x+bobol, YSIZE=bst_y, /BUTTON_EVENTS  ,"+ $
			                 "/EXPOSE_EVENTS,/frame)"
			                                        ii=EXECUTE(etxt) & endif else $
		if (bst_x eq xi) and (bst_y eq yi) then $
	     		basd= widget_draw(basid,retain=2,/frame,xsize=bst_x+bobol,ysize=bst_y,$
	     							/button_event,/motion_event)  $
	     	else	basd= widget_draw(basid,retain=2,/frame, /button_event,/motion_event, $
			   		  xsize=bst_x+bobol,ysize=bst_y,x_scroll_size=xi,y_scroll_size=yi)
   		bid=sys_dep      ('DYNLAB',basid,0)
   		
		widget_control,bad_id=i,   basid,group_leader=lamp_b1, /realize & put_logo
		widget_control,bad_id=i,   basd , get_value=basw

		if CODENS gt 0 then basw=-basd
		if CODENS gt 0 then widget_control,bad_id=i, bas13, sensitive=0
		if wonly(0) eq 0 then $
		widget_control,bad_id=i, byd  , set_button=1
		widget_control,bad_id=i, bas13, set_uvalue=[-88,346,basw]
		widget_control,bad_id=i, bas14, set_uvalue=[-88,350,basw ,bas15,fix(string_w),siz(0),basid,bas_x,basd]
		widget_control,bad_id=i, basid, tlb_get_size=v2  &  v2=long(v2)
		widget_control,bad_id=i, basid, set_uvalue=[-88,308,basid,basd ,basw,bst_x+bobol,bst_y,$
								v2(0),v2(1),baslb,pixrx,pixry,basmo,fix(string_w)]

	        XMANAGER, 'Beside', basid, event_handler='LAMP_EVENT_PARSER',/just_reg
		wbeside=[basid,basd,basw,0,0,baslb,basmo]
	       endif
	       wbeside(3)=bst_x & wbeside(4)=bst_y
	  endif
	  if !D.name eq 'Z' then begin device,set_resolution=[bst_x+bobol,bst_y] & erase
	  endif else if wbeside(2) gt 0 then wset,wbeside(2)
	endif
;Large dimensions
	if (siz(0) ge 2) and (CODENS eq 0) then begin
	   xi=siz(1) & yi=siz(2)
;	   Image...
	   if   did_repr(0) eq 1 then  $
	        if  (xi gt bst_x) or (yi gt bst_y) then begin
			xo= float(xi)/bst_x
			yo= float(yi)/bst_y
			if yo ge xo then fx=yo else fx=xo
	        	if xo gt .5 then xi=fix(xi/fx)
	        	if yo gt .5 then yi=fix(yi/fx)
	        	endif
;	   Contour.
	   if  (did_repr(1) eq 1) or (did_repr(0)*did_repr(6)*uxy eq 1) then begin
			if use_scan eq 1 then maxvol=1000 else maxvol=512
			    xo=xi/maxvol
			    yo=yi/maxvol
			    if xo gt 0 then xi=xi/xo
			    if yo gt 0 then yi=yi/yo
	   endif
;	   Other...
	   if  (xi ge bst_x) and (yi ge bst_y) then begin
		xo=float(xi)/bst_x
		yo=float(yi)/bst_y
		if yo ge xo then fx=yo else fx=xo
		if use_scan eq 1 then maxvol=2000 else maxvol=1000
		if (xi gt maxvol) and (yi gt maxvol) $
				  and (did_repr(1)+did_repr(2) gt 0) then fx=fx*2
	        if xo gt .5 then xi=fix(xi/fx)
	        if yo gt .5 then yi=fix(yi/fx)
		endif

	   xi=xi>2
	   yi=yi>2

	   if  (xi ne siz(1)) or (yi ne siz(2)) then begin
		if wnumber eq '0' then st='temporary(w0)' $
		                  else st='w'+wnumber

	   	if siz(0) eq 2  then i = execute('w0=congrid('+st + ',xi,yi,/interp)' )
	   	if siz(0) eq 3  then i = execute('w0=congrid('+st + ',xi,yi,siz(3))' )

		if sizx(0) eq 2 then xx= congrid(temporary(xx),xi,yi,/interp) else if xi ne siz(1) then xx= congrid(xx,xi,/interp)
		if sizy(0) eq 2 then yy= congrid(temporary(yy),xi,yi,/interp) else if yi ne siz(2) then yy= congrid(yy,yi,/interp)

		siz=size(w0)
		wnumber= '0'
		endif
;	   Smooth Contour.
	   if  ((did_repr(1) eq 1) and (sizx(0) lt 2)) or (did_repr(0)*did_repr(6)*uxy eq 1) then $
	   	if (xi gt 50) and (yi gt 50) and (use_scan eq 0) then begin
		    if wnumber eq '0' then st='temporary(w0)' $
		                      else st='w'+wnumber
		    if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
		    i = execute('w0=smooth('+st + ',3'+edg+')' )
		    siz=size(w0)
		    wnumber= '0'
	       endif
	endif
;Max value !
	thresh=-99.
	mxv2  = 0.
	if (did_repr(9) gt 0) or (vff(2) eq 1) then begin mxv2=-99.
				 on_ioerror,mismx
				 if (l_message gt 0) and (vff(2) eq 0) then begin
				     widget_control,bad_id=i,did_repr(9),get_value=smxv & smxv=smxv(0)
				     mxv=0. & READS,smxv+' -99 -99 ' ,mxv,mxv2
				 endif else if vff(11) eq 0 then mxv=w_max(idn) else mxv=vff(11)
				 if CODENS gt 0 then  thresh=mxv else $
				 if mxv ne -99 then begin
				    thresh=mxv
				    if (siz(0) ne 3) or (not isurf) then begin
					if CODENS eq -1  then begin id=0L
					  if mxv2 ne -99 then begin mxv1=mxv
					  endif else begin mxv =(w_max(idn)-w_min(idn))/50.
							   mxv1=thresh-mxv & mxv2=thresh+mxv & endelse
					  i  =execute( 'id=where((w' + wnumber  +' le mxv2)'$
							  + 'and (w' + wnumber  +' ge mxv1))>0' )
					  i  =execute( 'w0=w' + wnumber  +'(id)' )
					  xx =xx(id)    & yy=yy(id) & zz=zz(id)
					  siz=size(w0) & wnumber= '0'
					endif else if siz(0) eq 1 then begin
					  if  keyrangy eq '' then $
					  if  mxv2 eq -99 then keyrangy=',yrange=[my1,mxv]' $
					                  else keyrangy=',yrange=[mxv,mxv2]'
					endif else begin
					  if wnumber eq '0' then st='temporary(w0)' $
					                    else st='w'+wnumber
					  if (mxv2 ne -99)  then $
						i  =execute( 'w0='+st +' > mxv < mxv2' ) $
					  else  i  =execute( 'w0='+st +' < mxv' )
					  if  keyrangz eq '' then begin
					   if mxv2  eq -99 then begin mxv2=mxv & mxv=w_min(idn) & endif
					   if (mxv2 gt w_max(idn)) or (mxv lt w_min(idn)) then  $
					   	!Z.range=[mxv,mxv2]
					  endif
					  siz=size(w0)
					  wnumber= '0'
					endelse
				    endif else if did_repr(5) eq 1 then thresh=alog(thresh)
				 endif
				 mismx:
	endif

;Stretch Z !
	if CODENS eq -1 then begin mx1=min(xx,max=mx2) & my1=min(yy,max=my2) & mz1=min(zz,max=mz2)
	   cdbox=[ [mx2,my2,mz1],[mx2,my1,mz1],[mx2,my1,mz2],[mx2,my2,mz2],[mx2,my2,mz1],[mx1,my2,mz1],$
		   [mx1,my2,mz2],[mx1,my1,mz2],[mx2,my1,mz2],[mx2,my2,mz2],[mx1,my2,mz2]] & endif

;Log !
	if (did_repr(5) eq 1) and (CODENS eq 0) then begin
		if wnumber eq '0'  then st='temporary(w0)' $
		                   else st='w'+wnumber
		if siz(0) eq 1     then i =execute( 'w0=alog10('+st +' > 1E-9)')  else $
		if w_min(idn) gt 0 then i =execute( 'w0=alog  ('+st +' )' )       $
				   else i =execute( 'w0=alog  ('+st +' > 0.001)')
		if n_elements(ee)  gt 1    then      ee=0

		siz=size(w0)
		wnumber= '0'

		if keyrangy ne '' then begin if siz(0) eq 1 then my1=alog10(my1 > 1E-9) else my1=alog(my1 > 0.001)
					     if siz(0) eq 1 then my2=alog10(my2 > 1E-9) else my2=alog(my2 > 0.001)
					     keyrangy=',yrange=[my1,my2]' & endif
	endif
;***
;end redraw=0
;**********
       endif else begin if fu_out eq 0 then bst_x=did_x else bst_x=wbeside(3)
			if fu_out eq 0 then bst_y=did_y else bst_y=wbeside(4) & endelse
;***
       l_mess=l_message
       if b_labins(6) then if b_labins(7) gt 0 then l_mess=b_labins(7)
;***
       on_ioerror,IfPsErr
       if (not htm_ok) and (not liveC) and (not liveA) then begin

	if fu_out eq 0 then b_cur=0         else b_cur=wbeside(0)
	if fu_out eq 0 then d_cur=did_wd    else d_cur=wbeside(1) & if (CODENS gt 0) and (fu_out eq 0) then d_cur=did_we
	if fu_out eq 0 then w_cur=did_win0  else w_cur=wbeside(2)
	if fu_out eq 0 then baslb=l_mess    else baslb=wbeside(5)
	xo=off60 & yo=off60 & xof=xo/2 & yof=yo/2
	w_order=0
;Plot
;----
	poskey  =',position=[xo,yo,bst_x-xof,bst_y-yof]*f_dps,/device'
	poskeyPS='' & f_dps=1
	wplot   =!D.name
	if (ps_ok) and (CODENS le 0) then begin
		x_sx =7.  & y_sy = 9.5  &  xoff=x_sx/15. & yoff=y_sy*3./40
		x_sps=x_sx & y_sps= y_sy
		if did_fu eq 0 then y_sps=y_sps/2. $
		else begin
			if bst_x+bobol ge bst_y then begin
				y_sps=x_sps*bst_y/bst_x
			endif else begin  tmp  =y_sps*bst_x/bst_y & ttm=(tmp-x_sps)>0
				x_sps=tmp-ttm & y_sps=y_sps-ttm   & endelse
		endelse
		poskeyPS=poskey
		psFile  ='lamp.ps'
		if strpos(w_numor(0),'.ps') gt 0 then psFile=w_numor(0) else psFile='lamp.ps'
		w_numor(0)=''
		errps =1
		nc =256
		keepcol=!P.COLOR
		popo   =!P.COLOR
		popi   =!P.BACKGROUND
		if b_labins(3) ne 1 then tvlct ,  cur_r    ,          cur_g    ,          cur_b ,/get
		set_plot,'PS'
		if b_labins(3) ne 1 then begin
			pos_r=congrid(cur_r,nc) & pos_g=congrid(cur_g,nc) & pos_b=congrid(cur_b,nc)
			popo=min(fix(pos_r)+fix(pos_g)+fix(pos_b))
			popo=!C
			popi=max(fix(pos_r)+fix(pos_g)+fix(pos_b))
			popi=!C
			endif

		!P.COLOR=popo
		!P.BACKGROUND=popi
		lan=0
		if (did_fu ne 0) and (bst_x+bobol ge bst_y) then begin lan=1
		  device,xsize=x_sps,ysize=y_sps, yoffset=y_sy+yoff ,xoffset=xoff ,/inches,/landscape & pdph= x_sps-xoff+.5
		endif else begin
   		  device,xsize=x_sps,ysize=y_sps, yoffset=yoff      ,xoffset=xoff ,/inches,/portrait  & Pdph= y_sps+.5
		endelse
   		device,bits_per_pixel=8,/color
		device,filename=psFile
		if b_labins(3) ne 1 then tvlct ,  pos_r    ,  pos_g    ,  pos_b

		f_dps  =min([x_sps/bst_x , y_sps/bst_y]) *2.4 * !d.x_px_cm
		;fifix  =bst_x*f_dps*2.512/300. & if fifix gt 1 then fifix=fix(fifix)
		;f_dps  =fifix*300. /2.512/bst_x
		dd1    =convert_coord([0,1,1.,0],[0.,0,1,1],/normal,/to_device)
		bst_x  =round(dd1(0,1)/f_dps) ;**bst_x=round((x_sps*2.4 * !d.x_px_cm)/f_dps)
		bst_y  =round(dd1(1,2)/f_dps) ;**bst_y=round((y_sps*2.4 * !d.x_px_cm)/f_dps)
	endif
	if wonly(0) eq 0 then $
	if CODENS ne 0 then begin
	 if (liveT ne 0) then begin  liveT=0
		if wnumber ne '0' then ii=execute('w0=w'+wnumber)
		ii=execute('live_lamp_dens, rrr, xx,yy,zz,w0, thresh=thresh, box=cdbox,'+ $
	                       'xrange=[mx1,mx2], yrange=[my1,my2], zrange=[mz1,mz2],ax=rx,az=rz')
			       
	 endif else if CODENS eq -1 then begin
	   if mx1 eq mx2 then mx2=max (xx ,min=mx1)
	   if my1 eq my2 then my2=max (yy ,min=my1)
	   scale3 ,             xrange=[mx1,mx2], yrange=[my1,my2], zrange=[mz1,mz2],ax=rx,az=rz
			;t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , rz , 0. ]
			;t3d,                   rot=[ rx , 0. , 0. ]
			;t3d, tr=[+.5,+.5,+.5]
	   surface,fltarr(2,2), xrange=[mx1,mx2], yrange=[my1,my2], zrange=[mz1,mz2],/nodata,/t3d
	   s =(50000./n_elements(xx)/6)>1
	   pk=4   &   if s lt 9 then pk=3   &   s=round(s/2)>1<3
	   if (thresh ne -99) and (mxv2 eq 0.) then plots,xx,yy,zz,psym=pk,symsiz=s,/t3d $
	   else begin
		if thresh ne -99 then begin ji=10. & mxv= (mxv2 - thresh)	     & p=thresh
		endif		 else begin ji=50. & mxv= (w_max(idn)-w_min(idn)) & p=w_min(idn) & endelse
		mxk=mxv /ji & if mxk eq 0 then ji=1
		              if mxk ne 0 then mxv=mxk
		col=220./ji
		for i=1,ji do begin id=0L
		    ii=execute('id=where((w'+wnumber+' ge p) and (w'+wnumber+' le p+mxv))')
		    if id(0) ge 0 then plots,xx(id),yy(id),zz(id),psym=pk,symsiz=s,/t3d,color=col*i
		    p =p+mxv
		    if RDSTOP(1,ji,(i)) then i=ji+1
		endfor
	   endelse
	   plots,cdbox,/t3d
	   
	 endif else begin
	 	if fu_out eq 0 then begin odim=[did_x,did_y]  & omen=did_4dM    & endif
	 	if fu_out ne 0 then begin odim=[bst_x,bst_y]  & omen=wbeside(6) & endif
	 	if rrr    eq 7 then begin ps='VRML' & rrr=6   & endif else ps='' ;but fu_out=0!!!!!
	 	if ps_ok       then begin ps='PS'   & ps_ok=0 & endif
	 	
		txt='liv_objet,WDRAW=d_cur,DIM=odim,MENUBAS=omen,L_MESS=baslb,WI=idn,PS=ps'+$
		             ',XX=xx,YY=yy,ZZ=zz,WW=w'+wnumber+',THRESH=thresh,REPR=did_repr,EE=ee,NN=nn,VV=vv'
		ii = EXECUTE(txt)
	 endelse
	endif else $
	if siz(0)   eq 1 then begin
		keepcol=!P.COLOR
		if not ps_ok then !P.COLOR=0
		keywrd=',yticklen=1.,ygridstyle=1,background=255,charsize=1.2'
		wnumbxy='w'+wnumber & wxx=''
		wxx='xx,'

		if liveT ne 0 then begin
			i=execute('live_lamp_plot,liveT,xx,'+wnumbxy +keyrangx+keyrangy)
		endif else if n_elements(ee) le 1 then begin
			i=execute(' plot,' + wxx+wnumbxy +keywrd+poskey+keyrangx+keyrangy)
		endif else begin
			m=max(ee) & mq=sqrt(w_max(idn))
			if  m*(w_max(idn)+1) eq mq then opp1='*(1+ee)' else opp1='+ee'
			if  m*(w_max(idn)+1) eq mq then opp2='*(1-ee)' else opp2='-ee'
			if bst_x/siz(1) gt 3 then keywrd=keywrd+',psym=2' $
					     else keywrd=keywrd+',psym=3'
			i=execute(' plot,' + wxx+wnumbxy +keywrd+poskey+keyrangx+keyrangy)

			if bst_x/siz(1) ge 6 then begin
			i=execute('oplot,' + wxx+wnumbxy+opp1+',linestyle=1')
			i=execute('oplot,' + wxx+wnumbxy+opp2+',linestyle=1')
			endif
			i=execute('errplot,' + wxx + wnumbxy+opp2+','+wnumbxy+opp1)
		endelse
		!P.COLOR=keepcol
;Display
;-------
	endif else begin
;	   Use Scan
;	   --- ----
	   if use_scan eq 1 then begin
	   			if fu_out eq 0 then $
	   			   sl_lampscan, 'set_size', bst_x     ,bst_y     ,d_cur,lamp_b1 ,0
	   			if fu_out ne 0 then $
	   			   sl_lampscan, 'set_size', wbeside(3),wbeside(4),d_cur,lamp_b1 ,0
	   			f_fg=[-1,-1]
	   			if did_repr(1) eq 1 then begin
	   				if styles(1,0) eq 1 then f_fg(1)=10 else $
	   				if styles(1,0) eq 2 then f_fg(1)=11
	   				endif
	   			if did_repr(2) eq 1 then begin
	   				if styles(0,0) eq 1 then f_fg(0)=1
;	   				if styles(0,0) eq 2 then f_fg(0)=8  else $
	   				if styles(0,0) eq 3 then f_fg(0)=7  else $
	   				if styles(0,0) eq 4 then f_fg(0)=3  else $
	   				if styles(0,0) eq 5 then f_fg(0)=4  else $
	   				if styles(0,0) eq 6 then f_fg(0)=3
	   				endif
				spm=4
	   			if (styles(2,0) eq 3) then if siz(0) eq 3 then spc=-30 $
	   								  else spm= 6  else $
	   			if (styles(2,0) eq 4)  and    siz(0) eq 3 then spc=-20
				if  spc ge 0 then spc=spc+spm else spc=spc-spm
				if  rz eq 0 then rz=-1

			   	sl_lampscan, 'set_params', rx,rz,nlv ,f_fg
				if rz eq -1 then rz=0
				flg='views'
			      if siz(siz(0)+1) le 6 then $ ;+newtypes*******
			   	i =execute( 'sl_lampscan, flg ,w' + wnumber + ',spc') else $
			        i =execute( 'sl_lampscan, flg ,float(w' + wnumber + '),spc')
				xo=0 & yo=0 & xof=0 & yof=0
				!p.font = 0
				w_order=!order
				set_xy
				!p.title=w_tit(idn)
				!p.subtitle=''
				if !D.name ne 'Z' then if w_cur gt 0 then wset,w_cur
				plot,[0,0],/nodata,xstyle=4,ystyle=4,/noerase
	   endif else $
	   if (siz(0) eq 2) or ((siz(0) eq 3) and (did_repr(2)+did_repr(1) eq 0)) then begin
;	   Use Idl
;	   --- ---

		if (siz(0) eq 3) then begin
					    i =execute('w0=total(w'+wnumber+ ',3)' )
					    siz=size(w0)
					    wnumber='0'
					    endif
		axkey=''
		wnumbxy=wnumber+',xx,yy'
	   	if  uxy eq 0  then begin if (rrr eq 0) or (axy ne 1) then wnumbxy=wnumber
					    xs=siz(1)-1. & ys=siz(2)-1.
					    xdx=[0,xs/4.,xs/2.,xs*3./4.,xs] & sxx=strarr(5)
					    ydx=[0,ys/4.,ys/2.,ys*3./4.,ys] & syy=strarr(5)
					    for i=0,4 do begin
						te=fix(xdx(i)) & td=round((xdx(i)-te)*10.)/10.
						a =string( xx(  te)*(1.-td) + xx(  (te+1)<xs)*td)
						j =strlen(a)-1 & while (j gt 0) and (j eq strpos(a,'0',j)) do j=j-1
						sxx(i)=strmid (a,0,j+1)
						sxx   =strtrim(sxx,2)
						te=fix(ydx(i)) & td=round((ydx(i)-te)*10.)/10.
						if (size(yy))(0) le 1 then $
						a =string( yy(  te)*(1.-td) + yy(  (te+1)<ys)*td) else $
						a =string( yy(0,te)*(1.-td) + yy(0,(te+1)<ys)*td)
						j =strlen(a)-1 & while (j gt 0) and (j eq strpos(a,'0',j)) do j=j-1
						syy(i)=strmid (a,0,j+1)
						syy   =strtrim(syy,2)  
					    endfor

					                        scalex=float([sxx(0),sxx(4)])
					    if !order eq 0 then scaley=float([syy(0),syy(4)])  $
					                   else scaley=float([syy(4),syy(0)])

					    if total(long(scalex)) eq total(scalex) then ent=1 else ent=0 ;!!!
					    typ=size(xx) & typ=typ(typ(0)+1)
					    if (typ le 3) and (rrr ne 0) and (axy eq 1) then begin
					    		sxx=round(float(sxx))
							tickx=',xticks=4,xtickv=sxx'
					    endif else	tickx=',xticks=4,xtickname=sxx'

					    if total(long(scaley)) eq total(scaley) then ent=1 else ent=0 ;!!!
					    typ=size(yy) & typ=typ(typ(0)+1)
					    if (typ le 3) and (rrr ne 0) and (axy eq 1) then begin
							syy=round(float(syy))
							ticky=',yticks=4,ytickv=syy'
					    endif else	ticky=',yticks=4,ytickname=syy'
					    
					    wnumbxy=wnumbxy+tickx+ticky
					    axkey  =axkey  +tickx+ticky
		endif

		noaxe=',xstyle=5,ystyle=5,zstyle=5'
		if did_repr(14) eq 1 then begin wnumbxy=wnumbxy+noaxe & noaxe='' & endif
		if did_repr(2)  eq 1 then begin
		 surfstyl='shade_surf' & surfkey=''
		 if styles(0,0) eq 1 then begin if redraw eq 0 then  i=execute('w4d=bytscl(w'+wnumber+')')
		 						     surfkey=',shades=w4d'  & endif
		 if styles(0,0) eq 2 then begin
		 			if redraw eq 0 then begin
		 			 siw=size(w10)
				         if siw(0) ne 2 then i=execute('w10=w'+wnumber) $
				         else if (siw(1) ne isiz(1)) and (siw(2) ne isiz(2)) then $
							 w10=congrid(temporary(w10),isiz(1),isiz(2))
					 w4d=w10(vfl(0):vfl(1) , vfl(2):vfl(3))
		 			 siw=size(w4d)
				         if (siw(1) ne siz(1)) and (siw(2) ne siz(2)) then $
							 w4d=congrid(temporary(w4d), siz(1), siz(2))
					 if (thresh ne -99)    then  w4d=temporary(w4d) < mxv
					 if (did_repr(5) eq 1) then  w4d=alog(temporary(w4d) > 0.001)
					 w4d=bytscl(temporary(w4d))
					endif
								     surfkey=',shades=w4d'  & endif
		 if styles(0,0) eq 4 then begin
		 				surfstyl='surface' & surfkey=''		    & endif
		 if styles(0,0) eq 5 then begin if redraw eq 0 then  i=execute('w4d=bytscl(w'+wnumber+')')
		 				surfstyl='surface' & surfkey=',/lego,shades= w4d' & endif
		 if styles(0,0) eq 6 then begin
		 				surfstyl='surface' & surfkey=',/horizontal' & endif

		 if ps_ok then axsup=',charsize=2. ,zticks=4,font=-1,xtitle=x_tit(idn),ytitle=y_tit(idn),ztitle=z_tit(idn)' $
		          else axsup=',charsize=1.2,zticks=3'
		 surfkey=surfkey+axsup
		 axkey  =axkey  +axsup

		 if siz(1)*siz(2) gt long(128)*64 then horz=',/horizontal' else horz=''

		 if ((rz ge -90.) and (rz le  90.)) or ((rz le -270.)  or (rz ge  270.)) then pvx=0 else pvx=1
		 if ((rz ge   0.) and (rz le 180.)) or ((rz le -180.))                   then pvy=0 else pvy=1
		 if ((rz ge   0.) and (rz le  90.)) or ((rz le -270.))                   then pvz=2 else $
		 if ((rz gt  90.) and (rz le 180.)) or ((rz le -180.) and (rz gt -270.)) then pvz=3 else $
		 if ((rz gt 180.) and (rz le 270.)) or ((rz le - 90.) and (rz gt -180.)) then pvz=0 else $
		 if ((rz gt 270.) and (rz lt 360.)) or ((rz lt    0.) and (rz gt - 90.)) then pvz=1 else pvz=2
		 
		;if ((pvz eq 2) or (pvz eq 1)) and (ps_ok) then axkey=axkey+',font=-1'
		endif
				winx=bst_x	   &   winy=bst_y
				if rrr eq 0 then begin winx=winx-off90 & winy=winy-off90 & endif
				xi= winx/siz(1)    &   yi=winy/siz(2)
				if (xi eq 0) then xi= -(float(siz(1))/winx)
				if (yi eq 0) then yi= -(float(siz(2))/winy)
				if  xi le -1 then fx= -1./xi else fx=xi
				if  yi le -1 then fy= -1./yi else fy=yi
				fm= min([fx,fy])
				if fu_out eq 0 then begin fx=fm & fy=fm & endif
				xi= fix(siz(1)*fx)
				yi= fix(siz(2)*fy)
				if xi/yi gt 4 then yi=xi/4 else $
				if yi/xi gt 4 then xi=yi/4

				if winx lt xi then xi=winx
				if winy lt yi then yi=winy
;		rrr=0 image
;		-----------
		if rrr eq 0 then  begin
				w_order=!order
				xo=(winx-xi)/2 + off60 & xof=bst_x-xi-xo	;prev 55
				yo=(winy-yi)/2 + off60 & yof=bst_y-yi-yo	;prev 45
						     rangex=[vfl(0),vfl(1)]-vfl(0)
				if w_order eq 0 then rangey=[vfl(2),vfl(3)]-vfl(2) $
						else rangey=[vfl(3),vfl(2)]-vfl(3)

				if total(long(scalex)+long(scaley)) eq total(scalex+scaley) then $
				   if axy eq 1 then wnumbxy=wnumber
				axy=1
				if ((xi ne siz(1)) or (yi ne siz(2))) then begin
					     if wnumber eq '0' then st='temporary(w0)' $
					     else st='w'+wnumber
					     if ((xi lt siz(1)) or (yi lt siz(2))) or ((fm ge 3) and (smoo eq 1)) then $
					          i= execute('w0=congrid('+st + ',xi,yi,/interp)' ) $
					     else i= execute('w0=congrid('+st + ',xi,yi)' )
					     ;if (fm ge 5) and (smoo eq 1) then begin
						;if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
						;i=execute('w0=smooth(temporary(w0),fix(fm-2)<9'+edg+')') & endif
				  if liveT ne 0 then $
				   i= execute('live_lamp_img,liveT,w0,xrange=scalex,yrange=scaley')  $
				  else begin erase
				   if not ps_ok then tvscl,w0,xo,yo $
				   		else tvscl,w0,xo*f_dps,yo*f_dps,xsize=(xi)*f_dps,ysize=(yi)*f_dps
				   i= execute('plot,w'+wnumbxy+ ',charsize=1.2 ,xrange=scalex,yrange=scaley'+  $
					      ',/nodata,position=[xo,yo,xo+xi-1,yo+yi-1]*f_dps ,/device,/noerase')
				  endelse
				endif else   begin
				  if liveT ne 0 then $
				   i= execute('live_lamp_img,liveT,w'+wnumber+',xrange=scalex,yrange=scaley')  $
				  else begin erase
				   if not ps_ok then didi="" else didi=",xsize=(xi)*f_dps,ysize=(yi)*f_dps"
				   i= execute('tvscl,     w'+ wnumber + ',xo*f_dps  , yo*f_dps'+didi )
				   i= execute('plot,w'+wnumbxy+ ',charsize=1.2 ,xrange=scalex,yrange=scaley'+  $
					      ',/nodata,position=[xo,yo,xo+xi-1,yo+yi-1]*f_dps,/noerase,/device')
				  endelse
				endelse
		endif

		if (liveT ne 0) and (rrr ge 1) then begin
				i=execute('live_lamp_surf,liveT,xx,yy,w'+ wnumber +$
					   ',az=rz,ax=rx,rrr=rrr,style=styles')
		endif else begin

;		rrr=1 image + surface
;		---------------------
		if rrr eq 1 then  begin
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/save,/nodata'+poskeyPS+noaxe )
				i=execute( 'contour   ,w' + wnumbxy + ',/fill' + $
						     ',/noerase,/t3d,zvalue=0.   ,nlevels=nlv'    +poskeyPS+noaxe )
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/noerase,' +$
									'bottom=80' +horz         +poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
				endif
;		rrr=2 image + contour
;		---------------------
		if rrr eq 2 then  begin
				i=execute( 'contour   ,w' + wnumbxy + ',/fill  ,nlevels=nlv' +poskey)
				if (fu_out eq 1) and (did_repr(14) eq 0) then begin
				   wmin =w_min(idn) & wmax=w_max(idn) & i=execute('wmin=min(w'+wnumber+',max=wmax)')
				   if did_repr(5) eq 1 then begin wmin=exp(wmin) & wmax=exp(wmax) & endif
				   bn2  =15 & bn1 =(bst_y-yof-yo)
				   bobo =findgen(bn1)/(bn1-1)*(wmax-wmin)
				   if did_repr(5) eq 1 then bobo=alog(bobo > 0.001)
				   bobox=fltarr(bn1,bn2)  & for i=0,bn2-1 do bobox(0,i)=bobo
				   posx =(bst_x-xof+bn2+bn2)
				   posy =(yo)
				   bobox=transpose(bobox)
				   if (    ps_ok) then tvscl,bobox,posx*f_dps,posy*f_dps,xsize=bn2*f_dps,ysize=bn1*f_dps
				   if (not ps_ok) then tvscl,bobox,posx*f_dps,posy*f_dps
				   wmix=wmax-wmin
				   xyouts,(posx+bn2+3)*f_dps, posy         *f_dps,strtrim(string(wmin)        ,2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+  bn1/4)*f_dps,strtrim(string(wmin+wmix/4.),2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+  bn1/2)*f_dps,strtrim(string(wmin+wmix/2.),2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+3*bn1/4)*f_dps,strtrim(string(wmax-wmix/4.),2),/device
				   xyouts,(posx+bn2+3)*f_dps,(posy+  bn1)  *f_dps,strtrim(string(wmax)        ,2),/device
				endif
				if uxy eq 0 then axy=1
				endif

;		rrr=3 image + contour + surface
;		-------------------------------
		if rrr eq 3 then  begin
				col=(indgen(nlv/2)+1)*10 + 50
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/save,/nodata'+poskeyPS+noaxe )
				i=execute( 'contour   ,w' + wnumbxy + ',/fill' + $
						     ',/noerase,/t3d,zvalue=0.   ,nlevels=nlv'    +poskeyPS+noaxe )
				i=execute( 'surface,   w' + wnumbxy + ',az=rz,ax=rx,/noerase,' +$
									'/t3d,bottom=80' +horz    +poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
				i=execute( 'contour   ,w' + wnumbxy + ',c_colors=col' +$
						     ',/noerase,/t3d,zvalue=1.   ,nlevels=nlv/2'  +poskeyPS+noaxe )
				endif
;		rrr=4 contour +  surface
;		------------------------
		if rrr eq 4 then  begin
				col=(indgen(nlv/2)+1)*10  + 50
				i=execute( surfstyl+ ',w' + wnumbxy + ',az=rz,ax=rx,/save'+surfkey+poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
				i=execute( 'contour   ,w' + wnumbxy + ',c_colors=col' +$
						     ',/noerase,/t3d,zvalue=1.   ,nlevels=nlv/2'  +poskeyPS+noaxe )
				endif
;		rrr=5 contour
;		-------------
		if rrr eq 5 then  begin
			if styles(1,0) eq 1 then begin
				c_lab=round(abs(sin(indgen(nlv)*!pi/2.)))
				c_lin=round(findgen(nlv)/(nlv-1)*5)
				c_ll =[1,4,3,2,5,0]
				for i=0,nlv-1 do c_lin(i)=c_ll(c_lin(i))
				i=execute( 'contour   ,w' + wnumbxy + ',/follow,nlevels=nlv,charsize=1.5,c_linestyle=c_lin'+$
					   ',font=-1,charthick=2.,c_labels=c_lab'+poskey)
			endif else begin
				col=(indgen(nlv)+1)*(180/nlv) + 50
				i=execute( 'contour   ,w' + wnumbxy + ',c_colors=col,nlevels=nlv' +poskey)
			endelse
			if uxy eq 0 then axy=1
		endif
;		rrr=6 surface
;		-------------
		if rrr eq 6 then  begin
				i=execute( surfstyl+ ',w' + wnumbxy + ',az=rz,ax=rx,/save'+surfkey +poskeyPS+noaxe )
				if did_repr(14) eq 0 then begin
				  i=execute('AXIS,xaxis=pvx,/t3d'+ axkey)
				  i=execute('AXIS,yaxis=pvy,/t3d'+ axkey)
				  i=execute('AXIS,zaxis=pvz,/t3d'+ axkey)
				endif
			    endif
;		rrr=7 VRML
;		----------
		if rrr eq 7 then  begin if uxy eq 1 then wnumbxy=wnumber+',xx,yy' else wnumbxy=wnumber
					if styles(0,0) eq 1 then pol=',/poly' else pol=''
					i=execute('matovr,w'+wnumbxy+pol)
					if b_labins(3) ne 2 then i=sys_dep('VIEWER','lamp.wrl')
					endif
		endelse
	   endif else if (siz(0) eq 3) and (did_repr(2)+did_repr(1) ge 1)  then begin
		kpcol=!p.color
		isurf =1
		if liveT ne 0 then begin
			i=execute('live_lamp_vol,liveT,w'+wnumber+',thresh=thresh,az=rz,ax=rx,rrr=rrr,name=w'+string_w)
		endif else begin

		if redraw eq 0 then begin
		   mini=w_min(idn) & maxi=w_max(idn)
		   if did_repr(5) eq 1   then begin i=execute( 'W0=w'+wnumber+'>0' )
		                                    wnumber='0' & maxi=max(W0,min=mini) & endif
		   if thresh      eq -99 then thresh=mini + (maxi-mini)/3.
		   v=0 & p=0
		   if rrr eq 7  then begin if styles(0,0) lt 4 then txt=',/poly' else  txt=''
				     i=execute( 'matovr,w' + wnumber + ' , iso=thresh'+txt)
				     if b_labins(3) ne 2 then i=sys_dep('VIEWER','lamp.wrl')
		   endif	else begin
				     if wnumber ne '0' then begin W0 =0 & i=execute( 'W0=float(w'+wnumber+')')
				                       endif else W0 =float(W0)
				     WT = total(W0) & WI = 0.

				     if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
				     if did_repr(6) eq 1 then begin
					i=execute('W0=smooth(temporary(W0),3'+edg+')')
					W0=W0*(WT/total(W0))
				     endif

				     if edg ne '' then begin
				     	i=execute('W0=transpose(W0,[2,0,1])')
					xtit=z_tit(idn) & ytit=x_tit(idn) & ztit=y_tit(idn) & xxr=zz & yyr=xx & zzr=yy
				     endif else begin
				        xtit=x_tit(idn) & ytit=y_tit(idn) & ztit=z_tit(idn) & xxr=xx & yyr=yy & zzr=zz
				     endelse
				     suz=size(W0)

				     shade_volume,W0,thresh,v,p
				     idx=  where (W0 ge thresh)
				     WN =  n_elements(idx)
				     WE =  n_elements(W0)
				     if WN gt 1 then begin WI=total(W0(idx))
							   if (did_repr(0) eq 0) and (did_repr(2) eq 1) then $
				     			   W0(idx)=-maxi*max([suz(1),suz(2),suz(3)]) & endif
				     WP0= (total(W0,3)>(mini*suz(3)))/suz(3)
				     WP1= (total(W0,2)>(mini*suz(2)))/suz(2)
				     WP2= (total(W0,1)>(mini*suz(1)))/suz(1)
				     W0 ={A:WP0,B:WP1,C:WP2,T:WT,N:WN,I:WI,E:WE,PXZ:total(WP0,2),PYZ:total(WP0,1),$
				          SIZ:suz,XTIT:xtit,YTIT:ytit,ZTIT:ztit,XXR:xxr,YYR:yyr,ZZR:zzr,TH:thresh}
				     endelse
		endif

		if n_elements(p) gt 3 then begin
		   tmp=fltarr(2,2)
		   col=(indgen(nlv/2)+1)*10 + 50
			scale3, xrange=[0,W0.siz(1)-1], yrange=[0,W0.siz(2)-1], zrange=[0,W0.siz(3)-1],ax=0.,az=0.
			t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , rz , 0. ]
			t3d,                   rot=[ rx , 0. , 0. ]
			t3d, tr=[+.5,+.5,+.5]
			kpn=!D.name
			if kpn ne wplot then set_plot,wplot
			set_shading,reject=0,values=[100,254]
			image=polyshade(v,p,/t3d,xsize=bst_x,ysize=bst_y)
			set_shading,reject=1
			if kpn ne wplot then set_plot,kpn
			!p.color=kpcol
			myproj,image,W0, smoo,f_dps, profile=did_repr(1), surf=did_repr(2)
			if did_repr(5) eq 1 then loo=' (Logn)' else loo=''
			other_tit(idn)='Threshold='+strtrim(string(thresh),2)+loo+'  Total volume:'+strtrim(string(W0.I),2)+loo + $
			               '  Npoints:'+strtrim(string(W0.N),2)
		endif

		endelse
	   endif
	endelse
       endif else begin
	  if wnumber  ne  '0'  then  w0=0
          if (htm_ok) then HtmW,idn, w0, xx, yy
          if (liveC)  then if siz(0) eq 2 then ii=execute('live_lamp_cont,w'+wnumber+',GROUP=lamp_b1,XX=xx,YY=yy,WI=idn'+ $
                                                             ',TIT=w_tit(idn),XTIT=x_tit(idn),YTIT=y_tit(idn)')
          if (liveA)  then if siz(0) eq 3 then ii=execute('live_lamp_anim,w'+wnumber+',GROUP=lamp_b1'+ $
							  ',TIT=w_tit(idn),smoo=smoo,surf=did_repr,az=rz,ax=rx')
       endelse

	if ps_ok then begin
		if (CODENS gt 0) then begin
			txt='liv_objet,WDRAW=d_cur,DIM=odim,MENUBAS=omen,L_MESS=baslb,WI=idn,PS="PS"'
			ii=EXECUTE(txt)
		endif else begin
			if b_labins(3) ne 1 then begin
				P_DID_PS_HEADER, pdph , idn ,psFile
				!P.COLOR=keepcol
				errps=0
			endif
			if errps eq 1 then begin errps=0 & device,/close_file & endif
			set_plot,wplot
			if  b_labins(3)  ne 1 then tvlct , cur_r , cur_g , cur_b
			widget_control,bad_id=i,l_mess,set_value= psFile+' updated ...'
		endelse
	endif
	IfPsErr:if errps eq 1 then begin errps=0 & device,/close_file & set_plot,wplot
			           if  b_labins(3)  ne 1 then tvlct , cur_r , cur_g , cur_b & endif

	if l_mess gt 0 then $
	if htm_ok	then widget_control,bad_id=i,l_mess,set_value='lamp.htm updated ...' else $
	if rrr eq 7	then widget_control,bad_id=i,l_mess,set_value='lamp.wrl updated ...'

	if (liveT eq 0) and (rrr ne 7) and (not htm_ok) and (not liveC) and (not liveA) then begin
	  if (CODENS eq -1) or (isurf) or (siz(0) eq 3)  then begin
		!p.title   =w_tit(idn)
		if (CODENS ne 0) or (isurf) then !p.subtitle=strmid(other_tit(idn),0,100)
		if (CODENS le 0) then plot,[0,0],/nodata,xstyle=4,ystyle=4,/noerase
	   	flgsurf    =[0,rz,idn]
		endif

	  if (not ps_ok) then begin
	     if (b_labins(3) ne 1) and (!D.name ne 'Z') then $
	     if (redraw eq 0) and (l_message gt 0) and (CODENS le 0) then begin
	      widget_control,bad_id=i,d_cur,set_uvalue=long ([-88,390,b_cur,fix(string_w),d_cur,w_cur,xo,yo,$
						       bst_x,bst_y,vfl(0),vfl(1),vfl(2),vfl(3),isurf,$
						       w_order,axy,baslb,xof,yof,did_repr(5)])

	      if ((did_fu eq 0) and (GEORGE ne 0)) then WebDo,'dws',1,0,0
	     endif
	  endif

	  trap_current=w_cur
	  trap_x1=vfl(0) & trap_x2=vfl(1) & trap_y1=vfl(2) & trap_y2=vfl(3) & trap_ws=string_w

	  if ((b_labins(3) eq 2) or (gif_ok)) then begin
		if (CODENS gt 0) then begin
			txt='liv_objet,WDRAW=d_cur,DIM=odim,MENUBAS=omen,L_MESS=baslb,WI=idn,PS="GIF"'
			ii=EXECUTE(txt)
		endif else begin
			r=0 & buf=tvrdd(r,g,b)
			if png_ok then giffile='lamp.png' else giffile='lamp.gif'
			if n_elements(r) le 1 then WRITE_KIF,giffile,buf else WRITE_KIF,giffile,buf, r,g,b
			if gif_ok then widget_control,bad_id=i,l_mess  ,set_value=giffile+' updated ...'
		endelse
	  endif
	  if scr_ok then begin
	     if fu_out eq 0 then  p_did_event,0,[-88,350,0,-1,0,0,0,0,0] $
	     else begin
	     	widget_control,bad_id=i, bas_x,get_uvalue=kuv		;actual modop (screen,gif,ps)
	     	widget_control,bad_id=i, bas_x,set_uvalue= 1		;set to screen
		widget_control,bad_id=i, bas14,get_uvalue=scr_uv	;get uv of "print to" button
		p_did_event,0 ,scr_uv
	     	widget_control,bad_id=i, bas_x,set_uvalue=kuv		;restore modop
	     endelse
	  endif
	  if fu_out eq 1 then begin
	     if  (not ps_ok) and (not gif_ok) and (not scr_ok) and ((b_labins(3) eq 0)   or $
	        ((!D.name eq "X") and  (b_labins(3) eq 1))) or (turn gt 2) then widget_control,bad_id=i,wbeside(0),map=1 $
	     else if (new ne 0)   and (!D.name ne 'Z')                     then widget_control,bad_id=i,wbeside(0),/destroy
	  endif
	endif

	vfl(*)     =-1
	did_repr(1)= keeprp1
	!p.title   =''
	!p.subtitle=''
	!x.title   =''
	!y.title   =''
	!z.title   =''
	!z.range   = 0
    endif
return
end

PRO myreduce, idx, xx,yy,zz,ee,nn,vv
;** ********
		    if n_elements(ee) eq n_elements(xx) then ee=ee(idx)
		    if n_elements(nn) eq n_elements(xx) then nn=nn(idx)
		    if (size(vv))(0)  eq 1 then $
		    if n_elements(vv) eq n_elements(xx) then vv=vv(idx)
	    	    xx=xx(idx) & yy=yy(idx) & zz=zz(idx)

		    if (size(vv))(0)  eq 2 then begin
		        for i=0,(size(vv))(2)-1 do begin idv=where(idx eq vv(0,i)) & vv(0,i)=idv(0)
			       if idv(0) ge 0 then begin idv=where(idx eq vv(1,i)) & vv(1,i)=idv(0)
			                                 if idv(0) lt 0 then vv(0,i)=-1  & endif
			endfor
			idv=where(vv(0,*) ge 0) & if idv(0) ge 0 then vv=vv(*,idv) else vv=0
		    endif
end

PRO myproj , image ,W0 ,smoo, f_dps, profile=profile, surf=surf
;** ******
;**
;**image= byte shaded volume
;**W0.A = total(data,3)
;**W0.B = total(data,2)
;**W0.C = total(data,1)
;**smoo = smooth flag 1 or 0
;**f_dps= 1 or PS factor

sizm= size(image)
x   =(size(W0.A))(1) & y=(size(W0.A))(2) & z=(size(W0.B))(2)
surface,image,xrange=[0,x], yrange=[0,y], zrange=[0,z],/nodata,/t3d,/sav,$
        xmargin=[0,0],ymargin=[0,0]

k=x & i=y & x=x-1 & y=y-1 & z=z-1   & ym1=1 & ym2=1 & ym3=1
M=0 & MM1=0 & MM2=0 & MM3=0 & dd1=0 & dd2=0 & dd3=0

 coom=[[0,0,0],[0,i,0],[k,i,0],[k,0,0]]

 dd1=round(convert_coord([0,0,x,x],[0,y,y,0],[0,0,0,0],/data,/t3d,/to_device)/f_dps)
 ya =dd1(1,2)  + dd1(1,1)
 yb =dd1(1,3)  + dd1(1,0)
 yc =dd1(1,0)  + dd1(1,1)
 yd =dd1(1,2)  + dd1(1,3)
 if (dd1(1,0) eq dd1(1,2)) or (dd1(0,0) eq dd1(0,2)) then $
 if (dd1(1,0) eq dd1(1,1)) or (dd1(0,0) eq dd1(0,1)) then ym1=0

if ya gt yb then $
 dd2=round(convert_coord([0,0,x,x],[i,i,i,i],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if ya le yb then $
 dd2=round(convert_coord([0,0,x,x],[0,0,0,0],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if (dd2(1,0) eq dd2(1,2)) or (dd2(0,0) eq dd2(0,2)) then $
if (dd2(1,0) eq dd2(1,1)) or (dd2(0,0) eq dd2(0,1)) then ym2=0
if  dd2(1,0) gt dd2(1,1) then up =1 else up =0 ;We may redo dd1 with z=[z,z,z,z]

if yd gt yc then $
 dd3=round(convert_coord([k,k,k,k],[0,0,y,y],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if yd le yc then $
 dd3=round(convert_coord([0,0,0,0],[0,0,y,y],[0,z,z,0],/data,/t3d,/to_device)/f_dps)
if (dd3(1,0) eq dd3(1,2)) or (dd3(0,0) eq dd3(0,2)) then $
if (dd3(1,0) eq dd3(1,1)) or (dd3(0,0) eq dd3(0,1)) then ym3=0

if (profile and (not surf))  then begin ym1=0 & ym2=0 & ym3=0 & endif

if ym1 then begin
 XX1=reform(dd1(0,*)) & YY1=reform(dd1(1,*))
 XI =[0,0,x,x]
 YI =[0,y,y,0]
 POLYWARP, XI, YI, XX1, YY1, 1, KX, KY
 MM1= POLY_2D(sqrt(W0.A), KX, KY,smoo,sizm(1),sizm(2),missing=0)
endif

if ym2 then begin
 XX2=reform(dd2(0,*)) & YY2=reform(dd2(1,*))
 XI =[0,0,x,x]
 YI =[0,z,z,0]
 POLYWARP, XI, YI, XX2, YY2, 1, KX, KY
 MM2= POLY_2D(sqrt(W0.B), KX, KY,smoo,sizm(1),sizm(2),missing=0)
endif

if ym3 then begin
 XX3=reform(dd3(0,*)) & YY3=reform(dd3(1,*))
 XI =[0,0,y,y]
 YI =[0,z,z,0]
 POLYWARP, XI, YI, XX3, YY3, 1, KX, KY
 MM3= POLY_2D(sqrt(W0.C), KX, KY,smoo,sizm(1),sizm(2),missing=0)
endif

if ym2 then M=fix(bytscl(MM2))
if ym3 then M=fix(bytscl(MM3))+M

idx=where(image ne 0)>0
if up then begin
	if (size(M))(0) eq 2 then M(idx)=image(idx) else M=image
	idx=where (MM1 ne 0)
	if idx(0) ge 0 then M(idx)=bytscl(MM1 (idx))
endif else begin
	if ym1 then M=M+bytscl(MM1)
	if (size(M))(0) eq 2 then M(idx)=image(idx) else M=image
endelse

if (size(M))(0) eq 2 then TVscl,M, xsize=sizm(1)*f_dps, ysize=sizm(2)*f_dps

!p.color=!p.color>250
if (up) then f=0 else f=z+1
plots,[0,k,k,0,0],[0,0,i,i,0],[f,f,f,f,f],/data,/t3d	;upper plan

bid=min(dd1(1,*),my) & cyc=coom(0:1,my)
oy=(my+1) mod 4      & coc=coom(0:1,oy)
ay=(my+2) mod 4      & cac=coom(0:1,ay)
uy=(my+3) mod 4      & cuc=coom(0:1,uy)
plots,[cyc(0),cyc(0)],[cyc(1),cyc(1)],[z+1,0],/data,/t3d	;three verticales
plots,[coc(0),coc(0)],[coc(1),coc(1)],[z+1,0],/data,/t3d
plots,[cuc(0),cuc(0)],[cuc(1),cuc(1)],[z+1,0],/data,/t3d

if up then f=z+1 else f=0
; plots,[cac(0),cac(0)],[cac(1),cac(1)],[z,0],/data,/t3d,linestyle=1	;back corners
; plots,[coc(0),cac(0),cuc(0)],[coc(1),cac(1),cuc(1)],[f,f,f],/data,/t3d,linestyle=1
; plots,[cuc(0),cyc(0),coc(0)],[cuc(1),cyc(1),coc(1)],[f,f,f],/data,/t3d

if ya gt yb then axis,0,0,f,xax=0,/data,/t3d,xrange=[W0.xxr(0),W0.xxr(x)],font=-1,charsize=2.5,xtitle=W0.xtit $
            else axis,0,i,f,xax=1,/data,/t3d,xrange=[W0.xxr(0),W0.xxr(x)],font=-1,charsize=2.5,xtitle=W0.xtit
if yd gt yc then axis,0,0,f,yax=0,/data,/t3d,yrange=[W0.yyr(0),W0.yyr(y)],font=-1,charsize=2.5,ytitle=W0.ytit $
            else axis,k,0,f,yax=1,/data,/t3d,yrange=[W0.yyr(0),W0.yyr(y)],font=-1,charsize=2.5,ytitle=W0.ytit

vert=coc ; if dd1(1,oy) lt dd1(1,uy) then vert=cuc
verv=[W0.zzr(0),W0.zzr(z/3),W0.zzr(z*2/3),W0.zzr(z)]
if ya gt yb then axis,vert(0),vert(1),0,zax=1,/data,/t3d,zrange=[W0.zzr(0),W0.zzr(z)],font=-1,charsize=2.5,zticks=3,ztickv=verv,ztitle=W0.ztit $
            else axis,vert(0),vert(1),0,zax=0,/data,/t3d,zrange=[W0.zzr(0),W0.zzr(z)],zticks=3,ztickv=verv,ztitle=W0.ztit

if (profile)  then begin
    px=W0.PXZ-min(W0.PXZ) & py=W0.PYZ-min(W0.PYZ)
    px=px/max(px)*z       & py=py/max(py)*z
    if ya gt yb then h=0 else h=i
    plots,indgen(k),intarr(k)+h,px,/t3d,/data
    if yd gt yc then h=0 else h=k
    plots,intarr(i)+h,indgen(i),py,/t3d,/data

    if up then h=0. else h=1.
    nlv=6 & col=(indgen(nlv)+1)*(255/nlv)
    contour,(W0.A<(W0.TH)),/t3d,nlevels=nlv,/noerase,zvalue=h,c_colors=col,xmargin=[0,0],ymargin=[0,0],$
                   xticks=1,yticks=1,xtickname=[' ',' '],ytickname=[' ',' ']
endif
end

pro setcol, n
;** ******
;**
    common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
    			wbeside,vfl,styles,w4d,smoo,vff

    if (n ge 0) and (n lt 40) then begin loadct,n & tcol=n & endif

return
end
pro trapx,w_res
;** ****  *****
    trap, w_res , 2
return
end
pro trapy,w_res
;** ****  *****
    trap, w_res , 1
return
end
pro trapt,w_res
;** ****  *****
    trap, w_res , 3
return
end
pro trapp,w_res
;** ****  *****
    trap, w_res , 4
return
end
pro trap, w_res ,flag
;** ****  *****  ****
;**
;** Get last zoomed workspace into w_res (c.a.d alone)
;** Flag=0 then return array
;** Flag=1 then return total(array,1)
;** Flag=2 then return total(array,2)
;** Flag=3 then return total(array)
;** Flag=4 then print  total(array)

@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current

    if (trap_x1 ge  0) or (trap_y1 ge 0) then $
    if  trap_ws gt '0' then begin
	if trap_x1 ge 0 then sx=strtrim(string(trap_x1),2) + ':' + $
				strtrim(string(trap_x2),2) $
			else sx='*'
	if trap_y1 ge 0 then sy=strtrim(string(trap_y1),2) + ':' + $
				strtrim(string(trap_y2),2) $
			else sy='*'

	siz=[0L] & ii=execute( 'siz=size(w'+trap_ws+')' )
	tx =''
	if siz(0) eq 1 then tx='('+sx+')'
 	if siz(0) eq 2 then tx='('+sx+','+sy+')'

	fl=0
 	nl=n_elements(flag) & if nl eq 1 then fl=flag

	if fl eq 4 then begin w_res=0.
	    ii=execute( 'w_res=total(w'+trap_ws+tx+')' )
	endif else if (alone gt 0) and (alone le lamp_sys) then begin
	    ws='W'+strtrim(string(alone),2)
	    xfor=ws +'=W'+trap_ws+tx & XICUTER,xfor
	    if fl gt 0 then begin
		if fl eq 1 then xicuter, ws +'=total('+ws+',1)'
		if fl eq 2 then xicuter, ws +'=total('+ws+',2)'
		if fl eq 3 then xicuter, ws +'=total('+ws+  ')'
	    endif
	endif
;	For xicute recursivity
	one=-1
	two= 0
   endif
return
end

pro positive, w_in
;** ********
;**
;** Transform an integer*2 unsigned array in a long positive one.
;** Call: W1 = POSITIVE ( W1 )

    s=size(w_in)
    if s(s(0)+1) eq 2 then begin

        index=where ( w_in lt 0 )

        w_in       =long  (temporary(w_in))

        if index(0) ge 0 then w_in(index)=65536+ w_in(index)

    endif
end

;*************************************** Process Create Multi  ***************************
;*************************************** Process Create Multi  ***************************
;*************************************** Process Create Multi  ***************************
pro p_did_multi_cre, widx
;** ***************
;**
;** Create the Multi_Plot interface.
return
end

;*************************************** Process Create begood ***************************
;*************************************** Process Create begood ***************************
;*************************************** Process Create begood ***************************

pro p_did_create_begood, widx ,rx ,nlv ,smoo ,styles ,did_repr
;** *******************
;**
;** Make a UI to change titles and general settings.
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

    i=xregistered('BEGOOD')
    if i le 0 then begin
	if widx le 0 then widx=1
	beg_wid=widx
	beg_t  =lonarr(5)
	if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

	beg_id	=widget_base  (title='Lamp Begood settings',/column,resource_name='lampdon')

;**	TITLES
	btmp0	=widget_base  (beg_id,/column,/frame)
	btmp	=widget_base  (btmp0 ,/row)
	bg_updat=widget_button(btmp  ,value='Update new titles',font=ft_b_normal  ,uvalue=[-88,361,0])
	bg_slid =widget_slider(btmp  ,title='WK_Space titles'  ,font=ft_b_normal,$
				      xsize=200,minimum=1,maximum=lamp_sys,value=beg_wid,uvalue=[-88,362,0])
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(0)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Main Title'       ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='w_tit(i)'         ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(1)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Sub Title'        ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='other_tit(i)'     ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(2)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='X   Title'        ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='x_tit(i)'         ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(3)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Y  Title'         ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='y_tit(i)'         ,font=ft_smallest)
	btmp	=widget_base  (btmp0 ,/row)
	beg_t(4)=widget_text  (btmp  ,xsize=30,ysize=1         ,font=ft_b_bigger,/editable,value=' ')
	btmp11	=widget_label (btmp  ,value='Z Title'          ,font=ft_b_normal)
	btmp11	=widget_label (btmp  ,value='z_tit(i)'         ,font=ft_smallest)

;**	GENERAL SETTINGS
	btmp0	=widget_base  (beg_id,/column,/frame)
	btmp11	=widget_base  (btmp0 ,/row)

	btmpa0	=widget_base  (btmp11,/column)
	btmp2t	=widget_base  (btmpa0,/row)
	btmp1t	=widget_label (btmp2t,value='GENERAL SETTINGS' ,font=ft_b_bigger)
	btmp10	=widget_base  (btmpa0,/column,/frame)
	btmp	=widget_label (btmp10,value='... SURFACE ...'  ,font=ft_b_normal)
	btmpb0  =widget_base  (btmp10,/column,/exclusive)
	btmps=lonarr(7)
	btmps(1)=widget_button(btmpb0,value='Shading based on intensities'  ,font=ft_normal,/no_release,$
							uvalue=[-88,366,1])
	btmps(2)=widget_button(btmpb0,value='Shading from Wk_Space W10 "'   ,font=ft_normal,/no_release,$
							uvalue=[-88,366,2])
	btmps(3)=widget_button(btmpb0,value='Shading from a light source'   ,font=ft_normal,/no_release,$
							uvalue=[-88,366,3])
	btmps(4)=widget_button(btmpb0,value='Wire mesh' 		    ,font=ft_normal,/no_release,$
							uvalue=[-88,366,4])
	btmps(5)=widget_button(btmpb0,value='Box style' 		    ,font=ft_normal,/no_release,$
							uvalue=[-88,366,5])
	btmps(6)=widget_button(btmpb0,value='Vectors' 			    ,font=ft_normal,/no_release,$
							uvalue=[-88,366,6])
	btmpr	=widget_base  (btmp10,/row)
	btmp	=widget_label (btmpr ,value='View Angle'       ,font=ft_normal)
	beg_view=widget_text  (btmpr ,value=strtrim(string(rx),2),/editable ,font=ft_b_normal,$
							uvalue=[-88,365,0]  ,xsize=4+cap,ysize=1)
	btmpn	=widget_base  (btmpr,/nonexclusive)
	btmpvr	=widget_button(btmpn ,value='VRML' 		,font=ft_normal,$
							uvalue=[-88,368,0])

	btmp10 =widget_base   (btmpa0,/row,/frame)
	btmp	=widget_label (btmp10,value='.. PLOT ..'  ,font=ft_b_normal)
	btmpb0  =widget_base  (btmp10,/nonexclusive,/row)
	btmphi  =widget_button(btmpb0,value='Histogram',font=ft_normal,uvalue=[-88,366,7])
	btmpna  =widget_button(btmpb0,value='noAxes'   ,font=ft_normal,uvalue=[-88,366,9])

	btmp0a	=widget_base  (btmp11,/column)
	btmp0i	=widget_base  (btmp0a,/row,/frame)
	btmp	=widget_label (btmp0i,value='... IMAGE ...'  ,font=ft_b_normal)
	btmpbi  =widget_base  (btmp0i,/nonexclusive)
	btmpsi  =widget_button(btmpbi,value='Smooth',font=ft_normal,uvalue=[-88,366,8])

	btmp01	=widget_base  (btmp0a,/column,/frame)
	btmp	=widget_label (btmp01,value='... CONTOUR ...'  ,font=ft_b_normal)
	btmp0b  =widget_base  (btmp01,/column,/exclusive)
	btmpct1	=widget_button(btmp0b,value='Using annotations ' 	    ,font=ft_normal,/no_release,$
							uvalue=[-88,367,1])
	btmpct2	=widget_button(btmp0b,value='Using colors lines'            ,font=ft_normal,/no_release,$
							uvalue=[-88,367,2])
	btmpr	=widget_base  (btmp01,/row)
	btmp	=widget_label (btmpr ,value='Levels nb'        ,font=ft_normal)
	beg_lev =widget_text  (btmpr ,value=strtrim(string(nlv),2),/editable,font=ft_b_normal,$
							uvalue=[-88,365,1]  ,xsize=4+cap,ysize=1)
	btmpn	=widget_base  (btmpr,/nonexclusive)
	btmpsp	=widget_button(btmpn ,value='Scan pref' 		    ,font=ft_normal,$
							uvalue=[-88,368,1])

	btmp01	=widget_base  (btmp0a,/column,/frame)
	btmp	=widget_label (btmp01,value='... PROJECTIONS ...'  	    ,font=ft_b_normal)
	btmp0b  =widget_base  (btmp01,/column,/exclusive)
	btmpp   =lonarr(5)
	btmpp(1)=widget_button(btmp0b,value='Frames' 		            ,font=ft_normal,$
							uvalue=[-88,369,1])
	btmpp(2)=widget_button(btmp0b,value='Using polygons'                ,font=ft_normal,$
							uvalue=[-88,369,2])
	btmpp(3)=widget_button(btmp0b,value='Sum dimensions (box)'          ,font=ft_normal,$
							uvalue=[-88,369,3])
	btmpp(4)=widget_button(btmp0b,value='Showing maximum values'        ,font=ft_normal,$
							uvalue=[-88,369,4])
	widget_control,btmpp(2),sensitive=0
	widget_control,btmpp(4),sensitive=0
;	btmp11	=widget_label (btmp0 ,value=' ')
	btmp11	=widget_base  (btmp0 ,/row)
	btmp	=widget_label (btmp11,value='Default PostScript DEVICE:'    ,font=ft_b_normal)
	beg_dev =widget_text  (btmp11,xsize=15,ysize=1, uvalue=[-88,364,0]  ,font=ft_b_bigger,/editable,$
							 value=lamp_devps)

	bg_done =widget_button(btmp11,value='Done'    , uvalue=[-88,363,0]  ,font=ft_b_bigger)
		 put_logo     ,btmp11

	p_did_begood_getitle

   	bid=sys_dep      ('DYNLAB',beg_id,0)
	widget_control,beg_id,group_leader=lamp_b1,/realize & put_logo

        if !P.psym eq 10    then widget_control,btmphi   ,bad_id=i,set_button=1
        if smoo    eq  1    then widget_control,btmpsi   ,bad_id=i,set_button=1
        ix=styles(0,0)>1<6    &  widget_control,btmps(ix),bad_id=i,set_button=1
        if did_repr(14)     then widget_control,btmpna   ,bad_id=i,set_button=1
        if styles(1,0) eq 1 then widget_control,btmpct1  ,bad_id=i,set_button=1
        if styles(1,0) eq 2 then widget_control,btmpct2  ,bad_id=i,set_button=1
        if styles(0,1) eq 1 then widget_control,btmpvr   ,bad_id=i,set_button=1
        if styles(1,1) eq 1 then widget_control,btmpsp   ,bad_id=i,set_button=1
        ix=styles(2,0)>1<4    &  widget_control,btmpp(ix),bad_id=i,set_button=1

	XMANAGER, 'BEGOOD' ,beg_id,event_handler='LAMP_EVENT_PARSER',/just_reg

    endif else widget_control,bad_id=i,beg_id,map=1
return
end

pro p_did_begood_getitle
;** ********************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,beg_t(0),set_value= w_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(1),set_value= other_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(2),set_value= x_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(3),set_value= y_tit	(beg_wid)
	widget_control,bad_id=i,beg_t(4),set_value= z_tit	(beg_wid)
return
end

pro p_did_begood_setitle
;** ********************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,beg_t(0),get_value= txt & w_tit    (beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(1),get_value= txt & other_tit(beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(2),get_value= txt & x_tit	   (beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(3),get_value= txt & y_tit	   (beg_wid)=txt(0)
	widget_control,bad_id=i,beg_t(4),get_value= txt & z_tit	   (beg_wid)=txt(0)
return
end

pro p_did_begood_updat
;** ******************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	p_did_begood_setitle
return
end

pro p_did_begood_slide,ev
;** ******************
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,ev.id,get_value=wi
	if beg_wid ne wi then p_did_begood_setitle
	beg_wid=wi
	p_did_begood_getitle
return
end

pro p_did_begood_nlv, nlv
;** ****************
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	level=12
	widget_control,bad_id=i,beg_lev,get_value=level
	slv=strcompress(level(0),/remove_all)
	on_ioerror,mislv
	nlv=fix(slv)
	mislv:
return
end


pro p_did_begood_ax, rx
;** ***************
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	angle=60
	widget_control,bad_id=i,beg_view,get_value=angle
	srx=strcompress(angle(0),/remove_all)
	on_ioerror,misrx
	rx=fix(srx)
	misrx:
return
end

pro p_did_begood_devps
;** ******************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev

	widget_control,bad_id=i,beg_dev,get_value=txt
	lamp_devps=strcompress(txt(0),/remove_all)
return
end

pro p_did_begood_done, rx ,nlv
;** *****************
@lamp.cbk
common c_begood,	beg_id,beg_wid,beg_t,beg_view,beg_dev,beg_lev
	p_did_begood_setitle
	p_did_begood_ax,  rx
	p_did_begood_nlv, nlv
	p_did_begood_devps
	widget_control,bad_id=i,beg_id,map=0
	widget_control,bad_id=i,beg_id,/destroy
return
end

;
;*************************************** Process Save Wi *********************************
;*************************************** Process Save Wi *********************************
;*************************************** Process Save Wi *********************************

pro p_did_save_reset
;** ****************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
sav_uv=0
end

pro p_did_save_menu,widx
;** ***************
;**
@lamp.cbk
;
; Make a menu list to save workspace
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
    common c_savt,	sav_tab ,sav_tap,sav_forp,sav_m

    if (sys_dep('VERSION') ge 5.4) then kif='Png' else kif='Gif'
    
    sav_tab=['hdf','xml','Ascii','xdr','F77','htm']
    sav_tap=['Tiff','Bmp',kif,'Pict'] ; sav_tap=['Tiff','Bmp','Gif','Jpeg','Pict']
    sav_tab=[sav_tab,lamp_wrti,sav_tap]   &   sav_tap=[lamp_wrtp,sav_tap]
    if n_elements(sav_forp) eq 0 then sav_forp=7
    if widx eq -1 then return

    P_GET_DATAPATH, sav_pthv

    i=xregistered('SAVE_MENU')
    if i gt 0 then widget_control,bad_id=i,(sav_b+0),/destroy
    n= n_elements(limtxt)
    if n gt 0 then begin
      sav_idx=-1
      if n_elements(sav_form) le 0 then sav_form=5
      dat=systime()
      sav_file=strmid(dat,8,2) + strmid(dat,4,3)
      sav_file=strcompress(sav_file,/remove_all)
      num=strcompress(w_numor(widx),/remove_all)
      if num ne '' then sav_file=num
      p_did_save_seq
      if sav_seq gt 0 then seq='_'+strtrim(string(sav_seq),2) else seq=''
      sav_b=widget_base  (title='Lamp Save a Workspace',/column,resource_name='lampdon')
      list =widget_list  (sav_b,font=ft_b_bigger,uvalue=[-88,371,0],$
      					        value=limtxt,ysize=n<17,/frame)
      btmp =widget_label (sav_b,value='           ')

      btmp =widget_base  (sav_b,/row)
      none =widget_button(btmp,uvalue=[-88,399,0],value= 'DONE ')
      s_ok =widget_button(btmp                   ,value=' SAVE ',font=ft_b_normal)
      bf   =widget_label (btmp,                   value='   Output File :')
      sav_f=widget_text  (btmp,font=ft_b_bigger, $
      			       uvalue=[-88,373,0],value=sav_file+seq,xsize=20,ysize=1,/editable)
      b_ico=widget_base  (sav_b,/row)
	    put_logo	 ,b_ico
      sav_l=widget_label (b_ico,font=ft_b_normal,value=string(replicate(95b,40)))

      form =widget_label (sav_b,value=' LAMP FORMAT (Web is default, hdf is NeXus)',font=ft_b_bigger)
      formb=widget_base  (sav_b,/row)
      form =widget_base  (formb,/row,/exclusive)
      bt   =lonarr(8)
      bt(0)=widget_button(form ,uvalue=[-88,372,0],/no_release,value='hdf'       ,font=ft_b_normal)
      bt(1)=widget_button(form ,uvalue=[-88,372,1],/no_release,value='xml'       ,font=ft_b_normal)
      bt(2)=widget_button(form ,uvalue=[-88,372,2],/no_release,value='Ascii')
      bt(3)=widget_button(form ,uvalue=[-88,372,3],/no_release,value='xdr (Bin)' ,font=ft_b_normal)
      bt(4)=widget_button(form ,uvalue=[-88,372,4],/no_release,value='F77')
      bt(5)=widget_button(form ,uvalue=[-88,372,5],/no_release,value='htm'       ,font=ft_b_normal)
      bt(6)=widget_button(form ,uvalue=[-88,372,6],/no_release,value='-->'       ,font=ft_b_normal)
      sav_m =widget_button(formb,uvalue=[-88,372,7],    menu=2 ,value=sav_tab(sav_forp))
      FOR i=7,n_elements(sav_tab)-1 do $
       ptmp=widget_button(sav_m,uvalue=[-88,372,i]            ,value=sav_tab(i)  ,font=ft_b_normal)

      btmp =widget_base  (sav_b,/row)
      lpth =widget_label (btmp,value=' Save Path:',font=ft_b_normal)
      bpth =widget_text  (btmp,value=sav_pthv,font=ft_b_bigger,xsize=40,ysize=1,/editable)

      bid=sys_dep      ('DYNLAB',sav_b,0)
      widget_control,sav_b,group_leader =lamp_b1,/realize & put_logo
      widget_control,bt(sav_form<6),bad_id=i,set_button=1
      if sys_dep('VERSION') lt 5.0 then widget_control,bt(0),bad_id=i,sensitive =0

      XMANAGER, 'SAVE_MENU' ,sav_b,event_handler='LAMP_EVENT_PARSER',/just_reg

      pixm =widget_base  (title='Save Icon',map=0)
      pixd =widget_draw  (pixm,retain=2,xsize=192,ysize=192)
      widget_control,pixm ,group_leader=sav_b ,/realize
      widget_control,pixd          ,bad_id=i  ,get_value=pixw

      widget_control,s_ok          ,bad_id=i,set_uvalue=[-88,374,bpth,pixw,192,192,pixm]

      if (widx gt 0) and (widx le lamp_sys) then begin sav_idx=0
						 for i=0,n_elements(limtxt)-1 do begin
	    						wi=fix(strmid(limtxt(i),1,2))
	    						if wi eq widx then sav_idx=i
	    					 endfor
						 widget_control,list,bad_id=i,SET_LIST_SELECT=sav_idx
      endif
    endif
return
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro write_kif,file,image,r,g,b ,TRANSPARENT=trans
;** *********
;**
;** Used for compatibilty with Idl versions.

catch,stat & if stat ne 0 then begin catch,/cancel & print,!err_string & return & endif

ver =sys_dep('VERSION') & png=0 & gif=0 & jpg=0 & img=0
fifi=strlowcase(file)
idx =strpos(fifi,'.gif')
if idx gt 0 then gif=1 else begin
	idx=strpos(fifi,'png')  & if idx gt 0 then png=1 else begin
		idx=strpos(file,'img') & if idx gt 0 then img=1 else jpg=1
		endelse & endelse

pnt =strmid(file,idx+3,5)

if (ver lt 5.2) and (png) then begin file=strmid(file,0,idx)+'jpg'+pnt & jpg=1 & png=0 & endif
if (ver ge 5.4) and (gif) then begin file=strmid(file,0,idx)+'.png'    & png=1 & gif=0 & endif

if jpg then write_jpeg,file,image
if png then if (ver lt 5.4) then imag2=reverse(image,2) else imag2=image
if png then if n_elements(trans) gt 0 then if n_elements(r) gt 1 then $
				           write_png ,file,imag2 ,r,g,b ,TRANSPARENT=[trans] else $
				           write_png ,file,imag2        ,TRANSPARENT=[trans] $
				      else if n_elements(r) gt 1 then $
				           write_png ,file,imag2 ,r,g,b else $
				           write_png ,file,imag2
				           
if gif then if n_elements(r)     gt 1 then write_gif ,file,image ,r,g,b $
				      else write_gif ,file,image
if img then begin
	      out=-1 & on_ioerror,mispixf
	      OPENW,out, file,/GET_LUN & WRITEU  ,out,image
	      mispixf:if out gt 0 then   FREE_LUN,out
endif
end

pro read_kif ,file,image ,sx,sy
;** ********
;**
;** Used for compatibilty with Idl versions.

catch,stat & if stat ne 0 then begin catch,/cancel & print,!err_string & return & endif

ver =sys_dep('VERSION') & png=0 & gif=0 & jpg=0 & img=0
fifi=strlowcase(file)
idx =strpos(fifi,'.gif')
if idx gt 0 then gif=1 else begin
	idx=strpos(fifi,'png')  & if idx gt 0 then png=1 else begin
		idx=strpos(file,'img') & if idx gt 0 then img=1 else jpg=1
		endelse & endelse

pnt =strmid(file,idx+3,5)

if (img) and (n_elements(sx) eq 0) then begin gif=1 & img=0 & endif
if (ver lt 5.2) and (png) then begin file=strmid(file,0,idx)+'jpg'+pnt & jpg=1 & png=0 & endif

if (ver ge 5.4) and (gif) then begin image=0 & print,'!! GIF read not implemented...' & return & endif
if (ver lt 5.2) and (png) then begin image=0 & print,'!! PNG read not implemented...' & return & endif

if jpg then read_jpeg,file,image,COLORS=!D.n_colors-1
if png then image=read_png(file)
if png then if (ver lt 5.4) then image=reverse(image,2)
if gif then read_gif ,file,image
if img then begin
	     in=-1 & on_ioerror,mispixm & image=bytarr(sx,sy)
	     OPENR,in,file,/GET_LUN     & READU   ,in,image
	     mispixm:if in  gt 0   then   FREE_LUN,in
endif
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro write_lamp,file, w=wi ,fmt=fmt ,format=format, path=patho
;** **********
;**
common c_savt,	sav_tab ,sav_tap, sav_forp,sav_m

auto=0
if (n_elements(wi) eq 1) and (n_elements(file) eq 1)  then $
if (wi gt 0)  and (file gt ' ')         then begin auto=1
					if n_elements(fmt)    eq 1 then p_did_save_format,fmt
					if n_elements(patho)  ne 1 then patho=""
					if n_elements(format) eq 1 then begin
					   p_did_save_menu,-1
					   idx=where(strlowcase(sav_tab) eq strlowcase(format))
					   if idx(0)  ge  0	   then p_did_save_format,idx(0)
					endif
					p_did_save_auto,wi,patho,file,auto & endif
if auto eq 0 then print,string(7b)+'file not saved ...!'
return
end

pro HtmW, wi ,w,x,y
;** ****
;**
@lamp.cbk
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
	if n_elements(w) gt 1 then begin
		kpw=0. & kpx=0. & kpy=0.  & ws=strtrim(string(wi),2)
		ii=execute('kpw=w'+ws)    & ii=execute('kpx=x'+ws)
		ii=execute('kpy=y'+ws)
		ii=execute('w'+ws+'=w') & ii=execute('x'+ws+'=x')
		ii=execute('y'+ws+'=y') & endif
	sav_form=5
	if (GEORGE ne 0) then WebDo,'pth',wpth
	if wpth eq '' then fif='lamp' else fif='geo_d_12htm.web'
	P_DID_SAVE_AUTO, wi,wpth,fif,1
	if (GEORGE ne 0) then WebDo,'fil',fif
	
	if n_elements(w) gt 1 then begin
		ii=execute('w'+ws+'=kpw') & ii=execute('x'+ws+'=kpx')
		ii=execute('y'+ws+'=kpy') & endif
end

pro p_did_WebIda, inst,year,cycl,runs,furm, patho, rep
;** ************
;**
@lamp.cbk
    common c_WebTouch , wtweb, wtinst, wtyear, wtcycl, wtfile, wtcn, wtrep, wtrop, wtroot, wtpath
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

	if n_elements(wtinst) eq 0 then begin	wtinst="" & wtyear="" & wtcycl="" & wtrop=""
	                                        wtfile="" & endif
	if (wtinst ne   inst) or (wtyear ne year) or (wtcycl ne cycl) then begin
		RDSET,  inst=inst, base="C_Year "+year, cycle=cycl
		wtinst =inst & wtyear=year & wtcycl=cycl & wtfile=inst+"_"+cycl+"_"
		endif

	for i=0,n_elements(runs)-1 do begin
		fils  = strtrim(string(runs(i)),2)
		status= 1
		catch,stat & if stat eq 0 then P_DID_GETRUN, runs(i) ,1, status else catch,/cancel
		to_don_history, 1,0,'W1=RDRUN('+fils+') ;'+inst+"_"+cycl
		if (status eq 0) then begin
			status=1
			px=strpos(fils,'.') & if px gt 0 then fils=strmid(fils,0,px)

			WRITE_LAMP,wtfile+fils, w=1 ,format=furm, path=patho
		endif
	endfor
end

pro p_did_WebTouch, inst,year,cycl,runs,prun, wi, rep
;** **************
;**
@lamp.cbk
    common c_WebTouch , wtweb, wtinst, wtyear, wtcycl, wtfile, wtcn, wtrep, wtrop, wtroot, wtpath
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

	if n_elements(wtinst) eq 0 then begin	wtinst="" & wtyear="" & wtcycl="" & wtrop="" & endif
	if (wtinst ne   inst) or (wtyear ne year) or (wtcycl ne cycl) then begin
		RDSET,  inst=inst, base="C_Year "+year, cycle=cycl
		wtinst =inst & wtyear=year & wtcycl=cycl & wtfile=inst+"_"+cycl+"_"
		wtpath ="/var/www/htdocs/BARNS/UserZone/Commons/TOUCH_BASE"
		wtpath =sys_dep ('NEWSUB',wtpath ,wtyear)	  & wtroot=wtyear
		ii=findfile(wtpath,count=cnt) & if cnt eq 0 then ii=sys_dep('MKDIR',wtpath)
		wtpath =sys_dep ('INSUB' ,wtpath ,wtinst)	  & wtroot=wtroot+"/"+wtinst+"/"
		ii=findfile(wtpath,count=cnt) & if cnt eq 0 then ii=sys_dep('MKDIR',wtpath)
		endif
	wtrep=rep
	path =wtpath
	chang=""
	wci  = wi & if wci le 0 then wci=1
	WS   ="w" + strtrim(string(wci),2) & sizw=[0L]
	tab=runs
	for j=1b,2 do begin
	if  tab(0) gt 0 then $
	for i=0,n_elements(tab)-1 do begin
		fils  = strtrim(string(tab(i)),2) ; or flto6(tab(i))
		file  = wtfile+fils
		status= 0
		cnti  = 0
		iii   = findfile(path+file+".htm",count=wtcn)
		fili  = file+"_"+wtrep
		if wtcn gt 0 then iii= findfile(path+fili+".png",count=cnti)
		if cnti eq 0 then begin
			if wi le 0 then begin 	status= 1
			   catch,stat & if stat eq 0 then P_DID_GETRUN, tab(i) ,wci, status else catch,/cancel
			   to_don_history, wci,0,WS+'=RDRUN('+fils+') ;'+inst+"_"+cycl
			endif
			if (status eq 0) and (wtrep ne "i") then begin
				ii=execute('sizw=size('+WS+')')
				if sizw(0) eq 1 then begin wtrep ="i" & chang =" i" & fili = file+"_"+wtrep & endif
				if sizw(0) eq 2 then if (wtrep eq 'pz') or (wtrep eq 'lz') then begin
				   			    wtrep ="i" & chang =" i" & fili = file+"_"+wtrep & endif
				if (wtrep eq "i") and (wtcn gt 0) then begin
						iii= findfile(path+fili+".png",count=cnti)
						if cnti gt 0 then status=-1 & endif
			endif
			if status eq 0 then begin
				if (wi le 0) and (wtrep ne wtrop) then begin
					if wtrep eq "s" then begin setcol,3  & tvlct,100,100,100,0 & endif else $
					if wtrep eq "c" then begin setcol,5  & tvlct,100,100,100,0 & endif $
					                else begin setcol,27 & tvlct,160,160,160,0 & endelse
					wtrop=wtrep & endif
				sav_form=5
				P_DID_SAVE_AUTO, wci,path,file,1
				endif
		endif
		if status gt 0 then fili=file+"_failed"
		if wi le 0 then print,"WT "+wtroot+fili+" complete ",j,chang
	endfor
	tab=prun
	endfor
	wtcn=0
end

pro p_did_save_auto, widx,path,file, auto
;** ***************
;**
;** auto =-1 auto save without  data (return -2 for 'imgR')
;** auto = 1 auto save with the data
@lamp.cbk
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

    if widx gt lamp_sys+3 then return
    sav_idx = widx
    for i =0,n_elements(limtxt)-1 do   begin
	wi=fix(strmid(limtxt(i),1,2))
	if wi eq widx then sav_idx=i & endfor
    sav_pthv= path
    sav_file= file
    if auto eq -1		 then sav_form=3
    if n_elements(sav_form) eq 0 then sav_form=5
    sav_seq = 0
    if n_elements(sav_uv) lt 6 then begin
	 sav_uv=[long(0),0,0,0,192,192]
	     if (!D.flags and 65536) ne 0 then begin
      		pixm  =widget_base  (title='Save Icon',map=0)
      		pixd  =widget_draw  (pixm,retain=2,xsize=sav_uv(4),ysize=sav_uv(5))
      		widget_control,pixm ,group_leader=lamp_b1 ,/realize
      		widget_control,pixd ,bad_id=i  ,get_value=pixw
      		sav_uv(3)=pixw
	     endif
    endif
    if !D.name eq 'Z' then device,set_resolution=[192,192]
    p_did_save_work, 0, sav_uv ,auto
return
end

pro p_did_save_work, event,uv ,auto
;** ***************
;**
;** auto = 0 save from interface
;** auto =-1 auto save without  data (return -2 for 'imgR')
;** auto = 1 auto save with the data
@lamp.cbk

    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
    common c_savt,	sav_tab ,sav_tap,sav_forp,sav_m
    common c_WebTouch , wtweb, wtinst, wtyear, wtcycl, wtfile, wtcn, wtrep, wtrop, wtroot, wtpath
;
; Save a workspace from menu list
on_ioerror,mis
out=-1

	if (sav_idx ge 0) and (sav_idx lt n_elements(limtxt)) then begin
	    wi=fix(strmid(limtxt(sav_idx),1,2))

	    if (wi ge 1) and (wi le lamp_sys) then begin
		if auto eq 0  then begin p_did_save_filename,0 & wtrep='-1' & endif
		if n_elements(wtcn) eq 0 then begin wtcn=0     & wtrep='-1' & endif
		wkstring=strtrim(string(wi),2)
		sizw=[0L] & sizx=[0L] & sizy=[0L] & sizp=[0L] & sizi=[0L] & sizn=[0L]
		i  =execute('sizw=size(w' + wkstring + ')' )
		i  =execute('sizx=size(x' + wkstring + ')' )
		i  =execute('sizy=size(y' + wkstring + ')' )
		i  =execute('sizp=size(p' + wkstring + ')' )
		i  =execute('sizi=size(e' + wkstring + ')' )
		i  =execute('sizn=size(n' + wkstring + ')' )

		if sizw(0) gt 0 then begin
		   if sav_form eq 5 then begin sav_form=3 & wtweb=1 & endif else wtweb=0
		   if (sizx(1) ne sizw(1))  then $
		   		i=execute('x'+wkstring+'=lindgen(sizw(1))+1')
		   if (sizy(sizy(0)+2) ne sizw(sizw(0)+2)) then $
		   if (sizy(1) ne sizw(2))  then $
		   if (sizy(2) ne sizw(2))  then $
		   		i=execute('y'+wkstring+'=lindgen(sizw(2))+1')
		   if  sizp(0) ne 1 then $
				i=execute('p'+wkstring+'=[0]')
		   if (sizi(0) lt 1) and (sizi(1) lt 1) then $
				i=execute('e'+wkstring+'=[0]')
		   if (sizn(0) lt 1) and (sizn(1) lt 1) then $
				i=execute('n'+wkstring+'=[0]')

		   fltr=''
		   if (not wtweb and strpos(sav_file,'_LAMP') lt 0) then fltr='_LAMP' else sav_seq=0

		   if auto eq 0 then begin
		      widget_control,/hourglass
		      widget_control,bad_id=i,uv(2),get_value=pth
		      sav_pthv=sys_dep      ('BLANKS',pth(0))
		      if sav_pthv ne '' then begin
		       car=strmid(sav_pthv,strlen(sav_pthv)-1,1)
		       if (car ne lamp_dvd) then sav_pthv=sav_pthv+lamp_dvd
		      endif
		      p_did_save_seq
		   endif
		   if sav_seq gt 0 then seq='_'+strtrim(string(sav_seq),2) else seq=''

;*****		   ***********************************************************Forms 0 1 2 3 4
		   if (sav_form le 4) then begin
			xx=[1L] & yy=[1L] & zz=[1L] & nn=[0L] & pv=[0L] & ee=[0L]
		   	i=execute('xx = x' +wkstring)
		   	i=execute('yy = y' +wkstring)
		   	i=execute('zz = z' +wkstring)
		   	i=execute('nn = n' +wkstring)
		   	sizn= size(nn)
		   	i=execute('pv = pv'+wkstring)
		   	i=execute('ee = e' +wkstring) & sizi=size(ee)
			sx=sizw(1)
			if sizw(0)  gt 1 then sy=sizw(2) else sy=long(1)
			if sizw(0)  gt 2 then sz=sizw(3) else sz=long(1)
			symod=sy

			if sav_form eq 0 then ext =fltr+'.hdf'
			if sav_form eq 1 then ext =fltr+'.xml'
			if sav_form eq 2 then ext =fltr+'ascii'
			if sav_form eq 3 then $
				if wtweb then ext =fltr+'.xdr' $
					 else ext =fltr+'xdr'
			if sav_form eq 4 then ext =fltr+'f77'

			if not wtweb then ii=sys_dep('POT',ext)
			doe=''
			if  sizi(sizi(0)+2) eq sizw(sizw(0)+2)	then begin c=0L & maxw=0.
				i  =execute('maxw=max(w' + wkstring + ',c)' ) & maxe=ee(c)
				sqr=sqrt(maxw)
				if  sqr          eq maxe then doe='sqrt(i)'       else $
				if  sqr/ maxw    eq maxe then doe='sqrt(i)/ i'    else $
				if  sqr/(maxw+1) eq maxe then doe='sqrt(i)/(i+1)' $
				else     if (not wtweb) or (auto eq 0) then doe='file'
			endif
;****			**********************Write data and header
			if wtcn eq 0 then begin

			if auto ge 0 then begin
;***		Data  file
			 if sav_form eq 4 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun,/F77 else $
			 if sav_form eq 3 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun,/XDR else $
			 if sav_form eq 2 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun      else $
		;	 if sav_form eq 1 then openw,out,sav_pthv+sav_file+seq+ext  ,/get_lun      else $
			 if sav_form eq 1 then begin & end
			 if sav_form eq 0 then begin & end

			 if sav_form gt 1 then begin
			 if sav_form ne 2 then i=execute('writeu,out,w' + wkstring)
			 if sav_form eq 2 then begin
			       if sy gt 1 then i=execute('printf,out,w' + wkstring) $
			       else begin      symod=0 &  ww=0.
			       		       if (sizi(1) ne sx) then ee=bytarr(sx)
			      		       i=execute('ww = w' +wkstring)
			      		       for i=0,sx-1 do printf,out,xx(i),ww(i),ee(i)
			       		       endelse
			  endif
			  free_lun,out
			 endif
			 if wtweb then begin  ii=sys_dep('ZIP',sav_file+seq+ext,sav_pthv)
					      if ii then  ext='.zip'   & endif
;***		Error file
			 if   sav_form gt 1 then begin
		   	 if   doe eq 'file' then $
		   	 if ((sav_form ne 2) or (sy gt 1)) $
		   	 		    and (sav_form ne 0) then begin  eet=ext+'_e'
			  if sav_form eq 4 then openw,out,sav_pthv+sav_file+seq+eet  ,/get_lun,/F77 else $
			  if sav_form eq 3 then openw,out,sav_pthv+sav_file+seq+eet  ,/get_lun,/XDR $
					   else openw,out,sav_pthv+sav_file+seq+eet  ,/get_lun
			  if sav_form ne 2 then i=execute('writeu,out,ee')
			  if sav_form eq 2 then i=execute('printf,out,ee')
			  free_lun,out
		   	 endif else doe=''

		   	 endif;sav_form gt 1
			endif ;auto ge 0
			;**********************End Write data
;***		Header file
			machine=sys_dep   ('MACHINE')
			if n_elements(histxt) gt sav_idx then histoire=histxt(sav_idx) else histoire=' '
			limxt  =limtxt(sav_idx)
		   	src    =head_tit  (fix (wkstring),2)

			out=-1
			if wtweb then exss=".htm" $
				 else begin exss=fltr & ii=sys_dep('POT',exss) & endelse

			if sav_form eq 3 then exs='png' else exs='img'

			if wtweb then begin exs='.png'
				if (sys_dep('VERSION') lt 5.4) and (!D.Name eq 'Z') then exs='.gif'
				if wtrep ne '-1' then exs="_"+wtrep+exs else exs=wtrep+exs
			endif else ii=sys_dep  ('POT',exs)

			if sav_form eq 1 then form='Binary'
			if sav_form eq 2 then form='Ascii'
			if sav_form eq 3 then form='XDR'
			if sav_form eq 4 then form='F77 unformatted'
			tiip=sizw(sizw(0)+1)
			case  tiip of	;+newtypes*****
			   1: tip='(1 )Byte'
			   2: tip='(2 )Short Integer'
			   3: tip='(3 )Long Integer'
			   4: tip='(4 )Floating'
			   5: tip='(5 )Double Floating'
			   6: tip='(6 )Complex'
			   7: tip='(7 )String'
			   8: tip='(8 )Structure'
			   9: tip='(9 )Double Complex'
			   10:tip='(10)Pointer'
			   11:tip='(11)Object'
			   12:tip='(12)Unsigned Integ'
			   13:tip='(13)Unsigned Long'
			   14:tip='(14)Long Int64'
			   15:tip='(15)Unsigned Int64'
			else:tip='(0) Undefined'
			endcase
      			npa=0L & npv=[0L]
      			bb=execute('npa=n_elements(p' +wkstring+')' )
      			bb=execute('npv=size      (pv'+wkstring+')' )
     			i  =0
       			bb=execute('for i=0,npa-1 do par_txt_all(i)=strtrim(par_txt(fix(wkstring),i))+string(p' $
      						   +wkstring + '(i))')
			if (sizn(0) eq 2) then if (sizn(1) eq sx) and (n_elements(nn) gt sx) then begin
				j=sizn(2)-1
				k=1
				for i=sizn(2)-1,1,-1 do if (k and max(nn(*,i)) eq 0) then j=j-1 else k=0
				if j lt sizn(2)-1 then  begin nn=nn(*,0:j) & sizn=size(nn) & endif
			endif
		   	ttl=w_tit     (fix (wkstring))
		   	ttx=x_tit     (fix (wkstring))
		   	tty=y_tit     (fix (wkstring))
		   	ttz=z_tit     (fix (wkstring))
		   	tto=other_tit (fix (wkstring))
			A_ac=""
			trf =""
			apl =""
			if wtweb then if (sy gt 1) and (sz le 1) then begin	A_type=strtrim(string(tiip)	,2)
										A_sx  =strtrim(string(sx )	,2)
										A_sy  =strtrim(string(sy )	,2)
										A_x0  =strtrim(string(xx(0))	,2)
										A_x1  =strtrim(string(xx(1))	,2)
										A_xn  =strtrim(string(xx(sx-1))	,2)
										A_y0  =strtrim(string(yy(0))	,2)
										A_y1  =strtrim(string(yy(1))	,2)
										A_yn  =strtrim(string(yy(sy-1))	,2)
										A_fl  =sav_file+seq+ext
									;	A_fl  =strmid(A_fl,strpos(A_fl,"/BARNS"),100)
										A_ac  ="Exec" & if sav_file eq 'lamp' then A_ac ="Start"
										A_wht ='300'  & if sav_file eq 'lamp' then A_wht='30'
			 apl='<APPLET Codebase= "http://barns.ill.fr/BARNS/GRAPH/V3D/classes/"' +$
			 ' Code="V3D.class" archive="V3D.jar" Width= '+A_wht+' Height= 70>'     +$
			 '<PARAM Name="Action"   Value="'+A_ac+'">'  +$
			 '<PARAM Name="User"     Value="$BarnsUser">'+$
			 '<PARAM Name="CGI"      Value="/cgi-bin/barns/nph-barns?Application=#WebLamp+-nws">'+$
 			 '<PARAM Name="File"     Value="'+A_fl+'">'  +$
			 '<PARAM Name="Format"   Value="xdr">'+$
			 '<PARAM Name="Type"     Value="'+A_type+'">'+$
			 '<PARAM Name="Title"    Value="'+ttl+'">'+$
			 '<PARAM Name="TitleX"   Value="'+ttx+'">'+$
			 '<PARAM Name="TitleY"   Value="'+tty+'">'+$
			 '<PARAM Name="SubTitle" Value="'+tto+'">'+$
			 '<PARAM Name="NbX"      Value="'+A_sx+'">'+$
			 '<PARAM Name="X0"       Value="'+A_x0+'">'+$
			 '<PARAM Name="X1"       Value="'+A_x1+'">'+$
			 '<PARAM Name="Xn"       Value="'+A_xn+'">'+$
			 '<PARAM Name="NbY"      Value="'+A_sy+'">'+$
			 '<PARAM Name="Y0"       Value="'+A_y0+'">'+$
			 '<PARAM Name="Y1"       Value="'+A_y1+'">'+$
			 '<PARAM Name="Yn"       Value="'+A_yn+'"></APPLET>'
			endif
			if wtweb then trf='<br>Get vrml !'+ $
					  '<br><a href="'+sav_file+seq+ ext+'" >Get Data (bin zipped) !</a>'+ $
					  apl+'<br><br><pre>'

			if sav_form gt 1 then begin
			openw,out,sav_pthv+sav_file+seq+exss,/get_lun

			printf,out,'<html><head><title>LAMP_FORMAT ' + systime()+'</title></head><body><img align =right src="'+sav_file+seq+fltr+exs+'"><b>'
			printf,out,' HEADER FILE written by the LAMP APPLICATION</b>'+trf
			printf,out,' '

			if auto ge 0 then  begin
			printf,out,' '
			printf,out,' DATA_FILE:      ' + sav_file +seq+ ext
			if src ne '' then $
			printf,out,' SOURCE:         ' + src
			endif

			if doe eq 'file' then if auto ge 0 then doe=sav_file +seq+ ext+'_e' else doe=''
			if doe ne ''     then begin
			printf,out,' ERRO_FILE:      ' + doe
			printf,out,' '
			endif

			printf,out,' HISTORY:        ' + histoire
			printf,out,' '
			printf,out,' X_SIZE:         ' + strtrim(string(sx)   ,2)
			printf,out,' Y_SIZE:         ' + strtrim(string(symod),2)
			printf,out,' Z_SIZE:         ' + strtrim(string(sz)   ,2)
			printf,out,' FORMAT:         ' + form
			printf,out,' TYPE:           ' + tip
			printf,out,' '

			if A_ac ne "Start" then begin

			printf,out,' MIN,MAX VALUES: ' + limxt
			printf,out,' '
			printf,out,' TITLES: ' + ttl
			if ttx ne '' then $
			printf,out,'      X: ' + ttx
			if tty ne '' then $
			printf,out,'      Y: ' + tty
			if ttz ne '' then $
			printf,out,'      Z: ' + ttz
			if tto ne '' then $
			printf,out,'  OTHER: ' + tto
			printf,out,' '
			printf,out,' PARAMETERS:'
			n=npa-1
			if n gt 0 then $
			printf,out,' ----------'
			if n gt 0 then for i=0,n do printf,out,' * '+  par_txt_all(i)
			printf,out,' '

			if npv(0) ge 1 then begin
			    tmp=strtrim(string(npv(1)),2)
			    if npv(0) gt 1 then tmp=tmp+' '+strtrim(string(npv(2)),2) else tmp=tmp+' 0'
			    if npv(0) gt 2 then tmp=tmp+' '+strtrim(string(npv(3)),2) else tmp=tmp+' 0'
			    printf,out,' VAR PARAM: nb='   +tmp
			    printf,out,' ---------                        (hidden)</pre><!--'
			    printf,out, pv
			    printf,out,'                                  --><pre>'
			endif

			if (long(xx(0)) eq xx(0)) and (xx(sx-1)-xx(0) eq sx-1) then begin
			    printf,out,' X_COORDINATES:'+string(xx(0))+' --> X size'
			    printf,out,' '
			endif else begin
			    sizx=size(xx) & if sizx(0) eq 2 then tmp=' bi_dim' else tmp=''
			    printf,out,' X_COORDINATES: '+ tmp
			    printf,out,' -------------                    (hidden)</pre><!--'
			    printf,out, xx
			    printf,out,'                                  --><pre>'
			endelse

			if (long(yy(0)) eq yy(0)) and (yy(sy-1)-yy(0) eq sy-1) and (sizw(0) gt 1) then begin
			    printf,out,' Y_COORDINATES:'+string(yy(0))+' --> Y size'
			    printf,out,' '
			endif else begin
			    sizy=size(yy) & if sizy(0) eq 2 then tmp=' bi_dim' else tmp='nb='+string(n_elements(yy))
			    printf,out,' Y_COORDINATES: '+ tmp
			    printf,out,' -------------                    (hidden)</pre><!--'
			    printf,out, yy
			    printf,out,'                                  --><pre>'
			endelse

			sizz=n_elements(zz)
			if (sizz gt 1) or (zz(0) ne 0) then begin
			 if sizz eq 1 then begin
			    printf,out,' Z_COORDINATES: '+string(zz(0))
			    printf,out,' '
			 endif else begin
			    printf,out,' Z_COORDINATES: nb='+string(sizz)
			    printf,out,' -------------                    (hidden)</pre><!--'
			    printf,out, zz
			    printf,out,'                                  --><pre>'
			 endelse
			endif

			if sizn(0) lt 1 then tmp='1' else tmp=strtrim(string(sizn(1)),2)
			if sizn(0) gt 1 then tmp=tmp+' '+strtrim(string(sizn(2)),2) else tmp=tmp+' 0'
			if sizn(0) gt 2 then tmp=tmp+' '+strtrim(string(sizn(3)),2) else tmp=tmp+' 0'
			printf,out,' MONITORS: nb='   +tmp
			printf,out,' --------                             </pre><!--'
			if (sizn(0) gt 2) or (sizn(0) le 1) then printf,out, nn $
			else		 for i=0,sizn(2)-1 do printf,out, nn(*,i)
			printf,out,'                                      --><pre>'

			if (not wtweb and auto eq 0) then begin

			printf,out,' MACHINE: ' + machine
			printf,out,'                                      </pre><!--'
			printf,out,' HOW TO READ THE DATA (example)'
			printf,out,' --------------------'
			printf,out,' USING IDL'
			printf,out,' ----- ---'
			if  symod    gt 0 then $
			printf,out,'        array = MAKE_ARRAY( xsize,ysize,zsize ,TYPE=code)'
			if  symod    eq 0 then $
			printf,out,'        array = MAKE_ARRAY( 3 , xsize ,TYPE=code)'
			printf,out,' '
			if (sav_form eq 1) or (sav_form eq 2) then $
			printf,out,'        OPENR,  unit, "'+sav_file+seq+ext +'" ,/GET_LUN'
			if  sav_form eq 3 then $
			printf,out,'        OPENR,  unit, "'+sav_file+seq+ext +'" ,/GET_LUN,/XDR'
			if  sav_form eq 4 then $
			printf,out,'        OPENR,  unit, "'+sav_file+seq+ext +'" ,/GET_LUN,/F77_UNFORMATTED'
			printf,out,' '
			if (sav_form ne 2)  then $
			printf,out,'        READU,  unit, array'
			if sav_form eq 2 then $
			printf,out,'        READF,  unit, array'
			printf,out,' '
			printf,out,' USING FORTRAN'
			printf,out,' ----- -------'
			if sav_form eq 2 then begin
			   if sy gt 1    then begin
			   	printf,out,'        REAL array(xsize,ysize,zsize)'
			   	printf,out,'        OPEN(unit=20,status="old",file="'+sav_file+seq+ext+'")'
			   	printf,out,'        READ(20,*) array'
			   endif else begin
			   	printf,out,'        REAL*4 x(xsize) , y(xsize) , e(xsize)'
			   	printf,out,'        OPEN(unit=20,status="old",file="'+sav_file+seq+ext+'")'
			   	printf,out,'        DO i=1,xsize'
			   	printf,out,'           READ(20,*) x(i),y(i),e(i)'
			   	printf,out,'        ENDDO'
			   endelse
			endif
			if (sav_form ne 2)   then begin
			   if tiip eq 1 then printf,out,'        BYTE array(xsize,ysize,zsize)'
			   if tiip eq 2 then printf,out,'        INTEGER*2 array(xsize,ysize,zsize)'
			   if tiip eq 3 then printf,out,'        INTEGER*4 array(xsize,ysize,zsize)'
			   if tiip eq 4 then printf,out,'        REAL*4 array(xsize,ysize,zsize)'
			   if tiip eq 5 then printf,out,'        DOUBLE PRECISION array(xsize,ysize,zsize)'
			   if tiip eq 6 then printf,out,'        COMPLEX array(xsize,ysize,zsize)'
			   if tiip eq 9 then printf,out,'        DOUBLE COMPLEX array(xsize,ysize,zsize)'
			   if sav_form eq 1 then printf,out,'        OPEN(unit=20,status="old",file="' $
			   			+sav_file+seq+ext+'",form="unformatted",' $
			   			+'recl=xsize*ysize*zsize,access="direct")'
			   if sav_form eq 3 then printf,out,'        OPEN(unit=20,status="old",file="' $
			   			+sav_file+seq+ext+'",form="xdr")'
			   if sav_form eq 4 then printf,out,'        OPEN(unit=20,status="old",file="' $
			   			+sav_file+seq+ext+'",form="unformatted")'

			   printf,out,'        READ(20) array'
			endif
			printf,out,'                                  --><pre>'
			endif		;not wtweb and auto eq 0

			endif		;A_ac="Start"

			printf,out,'</body></html>'
			free_lun,out
			out=-1
			endif		;sav_form gt 1
			endif		;wtcn eq 0
;****			**********************End Write data and header

;****			**********************Write Snapshot or HDF or XML file
			if (uv(3) gt 0) or (!D.name eq 'Z') then begin
;			Icone
;			-----
			kpDname=!D.name	;or pixmap in uv(3) but problems with true colors...
			set_plot, 'Z' & device,set_resolution=[uv(4),uv(5)]
			if auto ne -1 then erase
			if sav_form le 1 then wr=1 else  wr=0
			if wtrep eq '-1' then wttr='s' else wttr=wtrep

			p_did_makeicon, wkstring,xx,yy, uv(4),uv(5) ,auto ,wr ,wttr

			if auto ne -1 then begin worder=!order & !order=0
						 if (sav_form gt 1) and (not wtweb) then !order=1
						 wr=tvrd(0,0,uv(4),uv(5))
						 !order=worder & endif
			set_plot,kpDname
			
			if n_elements(wr) eq 1 then exs='imgR' else if sav_form eq 3 then exs='png' else exs='img'
			if wtweb then begin exs='.png'
				if (sys_dep('VERSION') lt 5.4) and (!D.Name eq 'Z') then exs='.gif'
				if wtrep ne '-1' then exs="_"+wtrep+exs else exs=wtrep+exs
			endif    else ii=sys_dep  ('POT',exs)
			ftxt=sav_pthv+sav_file+seq+fltr+exs

			if (sav_form le 1) then  begin fi=sav_file+seq+ext & ptfi=sav_pthv+fi
			    if sav_form eq 0 then pcm='write_hdf' else pcm='write_xml'
			    cmd= pcm +  ',ptfi,w'+wkstring+',xc=xx,yc=yy'              + $
			                ',zc=zz,e=ee,par_txt_all=par_txt_all'          + $
			                ',pr=p'+wkstring+',pv=pv,n=nn,w_tit=ttl'       + $
			                ',x_tit=ttx,y_tit=tty,z_tit=ttz,other_tit=tto' + $
			                ',SRC=src,HIST=histoire,LIM=limxt,MACH=machine'+ $
			                ',DOE=doe,SNAP=wr,DATE=head_tit(wi,4),FIFI=fi'
			    err=execute(cmd)
			endif else begin
			    if n_elements(wr) eq 1 then begin
				OPENW,out,ftxt,/get_lun,/XDR
				i=execute('WRITEU,out,fix(sx),fix(sy),fix(tiip),w' + wkstring)
				FREE_LUN,out   &  out=-1
				if save_form ne 3 then auto=-2
				if auto le -1 then bid=sys_dep('DO_Z',sav_pthv+sav_file+seq+fltr+exs,lamp_dir)
				auto=-2
			    endif else begin
				if (sav_form eq 3) then begin tvlct,r,g,b,/get
				                 WRITE_KIF,ftxt,wr,r,g,b, transparent=[0]
					         if (wtweb) and (strpos(ftxt,'gif') gt 0) then ii=sys_dep('GIFTRANS',ftxt)
				endif else begin WRITE_KIF,ftxt,wr
				if auto le -1 then bid=sys_dep('DO_Z',sav_pthv+sav_file+seq+fltr+exs,lamp_dir)
				endelse
			    endelse
			endelse
		        endif
;****			********************** End Write Snapshot or HDF or XML

		     if (auto eq 0) or ((sav_form ne 3) and (b_labins(3) ne 0)) then begin
			   text='W'+wkstring+ ' saved in '+sav_file+seq+ext
		           if wtweb then text=text + ' (& .htm)'
			   p_did_setwin0
			   if auto eq 0 then widget_control,bad_id=i,sav_l,set_value=text $
					else print ,text
			   text='WRITE_LAMP,"'+sav_pthv+sav_file+seq+'",w='+wkstring
			   to_don_history,-1,-1,text
		     endif
		   endif
;*****		   ***********************************************************End Forms 0 1 2 3 4
		   if (auto ge 0) and (sav_form ge 7)  then begin

		    proced=sav_tap(sav_form-6) & ptfi=sav_pthv+sav_file+seq & s=sizw(0) & err=88

		    if (proced eq 'Tiff') and (s eq 2) then begin ext='.tiff'
			  if sys_dep('VERSION') ge 5.2 then begin
				keywrd=',compression=1'
				tiip  =  sizw(sizw(0)+1) ;+newtypes*****
				if tiip  eq 2 then keywrd=keywrd+',/short'
				if tiip  eq 3 then keywrd=keywrd+',/long'
				if tiip  eq 4 then keywrd=keywrd+',/float'
				err=execute('write_tiff,ptfi+ext,w'+wkstring+keywrd )
			  endif else begin
				err=execute('write_tiff,ptfi+ext,bytscl(w'+wkstring +')')
				if err ne 1 then $
				err=execute('tiff_write,ptfi+ext,bytscl(w'+wkstring +')')
			  endelse
		    endif else $
		    if (proced eq 'Gif')  and (s eq 2) then begin
				if (sys_dep('VERSION') ge 5.4) then ext='.png' else ext='.gif'
				err=execute('WRITE_KIF ,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Bmp')  and (s eq 2) then begin ext='.bmp'
				err=execute('write_bmp ,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Jpeg') and (s eq 2) then begin ext='.jpg'
				err=execute('write_jpeg,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Png')  and (s eq 2) then begin ext='.png'
				err=execute('write_png ,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else $
		    if (proced eq 'Pict') and (s eq 2) then begin ext='.pict'
				err=execute('write_pict,ptfi+ext,bytscl(w'+wkstring +')')
		    endif else  begin ext=''
		     err=execute(proced+',ptfi,w'+wkstring+',xc=x'+wkstring+',yc=y'+wkstring+ $
		                 ',zc=z'+wkstring+',e=e'  +wkstring+',par_txt=par_txt(wi,*)'+ $
		                 ',pr=p'+wkstring+',pv=pv'+wkstring+',n=n'+wkstring         + $
		                 ',w_tit=w_tit(wi),x_tit=x_tit(wi),y_tit=y_tit(wi)'         + $
		                 ',z_tit=z_tit(wi),other_tit=other_tit(wi)')
		    endelse

		    if auto eq 0 then if err eq 1 then $
		    widget_control,bad_id=i,sav_l,set_value='W'+wkstring+' is saved in '+sav_file+seq+ext

		    if err eq 88 then begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Workspace not a 2D array!!!'
				print,string(7b)
		    endif
		   endif
		   if wtweb then sav_form=5

		endif else begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Workspace is not an array!!!'
				print,string(7b) & endelse
	    endif else begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Choose a Workspace !!!'
				print,string(7b) & endelse
	endif else begin
		   		if auto eq 0 then $
				widget_control,bad_id=i,sav_l,set_value=' Choose a Workspace !!!'
				print,string(7b) & endelse
return
mis:				if auto eq 0 then widget_control,bad_id=i,sav_l,set_value=!err_string $
					     else print,!err_string
				print,string(7b)
				if out gt 0 then free_lun,out
				auto=0
				if wtweb then sav_form=5
return
end

pro p_did_makeSnap, wi
;** **************
;**
@lamp.cbk
common c_did
common c_trap
	ws=strtrim(string(wi),2)
		if n_elements(Snapix) eq 0 then Snapix=0
		if Snapix eq 0 then begin
			aa=64L & bb=32L
      			byd=widget_base  (title='',map=0)
      			bid=widget_draw  (byd,retain=2,xsize=aa,ysize=bb * 21)
       			widget_control   ,byd,bad_id=i , /realize
      			widget_control   ,bid,bad_id=i , get_value=Snapix
      			byd=widget_base  (title='',map=0)
      			bid=widget_draw  (byd,retain=2,xsize=aa,ysize=bb)
       			widget_control   ,byd,bad_id=i , /realize
      			widget_control   ,bid,bad_id=i , get_value=Snapil
		endif
	ii=execute('p_did_makSnaps,w'+ws+', Sna'+ws+', Snapix, Snapil, did_tio, wi')
	trap_current=Snapil
end
pro p_did_makSnaps, w, s, Snapix, Snapil, dido, wi
;** **************
;**
aa=64L & bb=32L
kpwin=!window
if n_elements(s) eq 1 then begin
   if !D.name ne 'Z' then wset,Snapil & erase,255
   if n_elements(w) gt 1 then begin
	sz=size(w)
	if sz(0) eq 1 then begin s=congrid(w,sz(1)<100)
	                           plot,s,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4 & endif
	if sz(0) eq 2 then begin i=sz(1)<aa>(aa/2) & j=sz(2)<bb>(bb/2)
	                         s=congrid(w,i,j)
	                           tvscl,s,(aa-i)/2,(bb-j)/2 & endif
	if sz(0) eq 3 then begin i=sz(1)<aa>(aa/2) & j=sz(2)<bb>(bb/2) & k=sz(3)<40

				 if sys_dep('VERSION') ge 4.0 then ii=execute('s=transpose(congrid(w,i,j,k),[2,0,1])') $
				                              else s =congrid(w,i,j,k)

				 maxi=max (s,min=mini) & thresh=mini+(maxi-mini)/3.
				 shade_volume,s,thresh,v,p
				 if n_elements(p) gt 3 then begin
				   s={w:s,thresh:thresh,v:v,p:p}
				   scale3, xrange=[0,k-1], yrange=[0,i-1], zrange=[0,j-1],ax=0.,az=0.
				   t3d, tr=[-.5,-.5,-.5] ,rot=[ 0. , 20. , 0. ]
				   t3d,                   rot=[ 60., 0.  , 0. ]
				   t3d, tr=[+.5,+.5,+.5]
				   set_shading,reject=0 & tvscl,polyshade(v,p,/t3d) & set_shading,reject=1
				 endif else begin
	                           s=congrid(total(w,3),i,j)
 	                           tvscl,s,(aa-i)/2,(bb-j)/2 & endelse
	endif
  endif
  if !D.name ne 'Z' then begin wset,Snapix & device,copy=[0,0,aa,bb,0,bb*wi,Snapil] & endif
endif
if (dido ne 0) and (!D.name ne 'Z') then begin
	wset,abs(dido) & i=0 & j=0
	if dido gt 0 then begin i=32 & j=16 & erase,255 & endif
	device,copy=[0,bb*wi,aa,bb,i,j,Snapix]
endif
if kpwin gt 0 then if !D.name ne 'Z' then wset,kpwin
end

pro p_did_makefunc, w,w0, rep, ln
;** **************
;**
if (size(w))(0) lt 2 then rep='ln'
if (size(w))(0) eq 2 then if (rep eq 'pz') or (rep eq 'lz') then rep='i'

if rep eq 'px' then w0=      total(w,2)          else $
if rep eq 'py' then w0=      total(w,1)          else $
if rep eq 'pz' then w0=      total(w,3)          else begin ln=1
if rep eq 'lx' then w0=alog (total(w,2)>0 + 0.1) else $
if rep eq 'ly' then w0=alog (total(w,1)>0 + 0.1) else $
if rep eq 'lz' then w0=alog (total(w,3)>0 + 0.1) else $
if rep eq 'ln' then w0=alog (      w   >0 + 0.1) &  endelse
rep='i'
end

pro p_did_makeicon, wkstr,xx,yy, uv4,uv5 ,auto ,wr ,rup
;** **************
;**
;** auto = 0 save from interface
;** auto =-1 auto save without  data (no web)
;** auto = 1 auto save with the data
@lamp.cbk
common c_trap
		trap_current=!D.window
		ln=0   &  rep=rup  &  wkstring=wkstr  &  nlv=11 & sizw=[0L]

		i =execute('sizw=size(w'+wkstring+')') & if sizw(0) eq 1 then rup="i"

		if strlen(rep) gt 1 then begin
			i =execute('p_did_makefunc, w'+wkstring+',w0,rep,ln')
			wkstring='0' & endif
		i =execute('sizw=size(w'+wkstring+')')
		sx=sizw(1)
		if sizw(0)  gt 1 then sy=sizw(2) else sy=long(1)
		if sizw(0)  gt 2 then sz=sizw(3) else sz=long(1)

		xi=sx & yi=sy   & xo=sx*2/uv4 & yo=sy*2/uv5
		if yo ge xo then  fx=xo else fx=yo
		if fx gt 1  then  begin xi=(sx/fx)<uv4 & yi=(sy/fx)<uv5 & endif
		xo=(uv4-xi)/2 & yo=(uv5-yi)/2

		worder=!order & if not wr then !order=1

		if auto ne -1 then begin
		   if sz eq 1    then begin
			if sy eq 1 then begin
			      if n_elements(xx) gt 1 then $
			      	i=execute('plot,xx,w' + wkstring + ',xmargin=[5,0],ymargin=[3,0]') else $
			      	i=execute('plot   ,w' + wkstring + ',xmargin=[5,0],ymargin=[3,0]')
			endif
			if sy gt 1 then begin
			  if rep ne 's'   then begin tmw=0L
			    if rep eq 'c' then begin xi=sx<64  & yi=sy<64  & endif
			    if rep eq 'i' then begin xi=uv4 & yi=uv5
			                             if sy le sx/2 then yi=yi/2
			                             if sx le sy/2 then xi=xi/2
			                             xo=(uv4-xi)/2 & yo=(uv5-yi)/2 & endif
			    i=execute('tmw=congrid(w'+ wkstring + ',xi,yi,/interp)')
			    if ln eq 0 then begin
			       minx=min ( tmw ) & if minx le 0 then tmw=tmw-minx+0.1
			       tmw=alog  (temporary(tmw)) & endif
			    if sys_dep('VERSION') lt 4.0 then edg='' else edg=',/edge'
			    i=execute('tmw=smooth(temporary(tmw),4'+edg+')')
			    tmw=bytscl(temporary(tmw))
			  endif
			    if (n_elements(xx) eq sx) and (n_elements(yy) eq sy) and (rep ne 'i') then begin
			      if (sx ne xi) or (sy ne yi) then begin six=size(xx) & siy=size(yy)
				 if six(0)  eq  2  then tmx=congrid(xx,xi,yi) else tmx=congrid(xx,xi)
				 if siy(0)  eq  2  then tmy=congrid(yy,xi,yi) else tmy=congrid(yy,yi)
			      endif
			      if (sx ne xi) or (sy ne yi) then begin
			         if rep eq 'c' then contour,tmw,tmx,tmy,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4, $
			                                 c_colors=(indgen(nlv)+1)*(180/nlv) + 50 ,nlevels=nlv $
				 else $
			         i=execute('shade_surf,congrid(w' + wkstring + ',xi,yi,/interp)' +$
			      		   ',tmx,tmy    ,xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' )
			      endif else $
			         if rep eq 'c' then contour,tmw,xx,yy,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4, $
			                                 c_colors=(indgen(nlv)+1)*(180/nlv) + 50 ,nlevels=nlv $
				 else $
			         i=execute('shade_surf,w' + wkstring + ',xx,yy,xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' )

			    endif else begin
			      if rep eq 'c' then contour,tmw,xmargin=[0,0],ymargin=[0,0],xstyle=4,ystyle=4, $
			                                 c_colors=(indgen(nlv)+1)*(180/nlv) + 50 ,nlevels=nlv
			      if rep eq 'i' then tv,tmw,xo,yo else $
			      if (sx ne xi) or (sy ne yi) then $
			         i=execute('shade_surf,congrid(w' + wkstring + ',xi,yi,/interp)' +$
			      		   				     ',xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' ) $
			      else $
			         i=execute('shade_surf,w' + wkstring + ',      xmargin=[0,0]'+$
			      		   ',ymargin=[0,0],xstyle=4,ystyle=4,zstyle=4,ax=55.,az=30.' )
			    endelse
			endif
		   endif
		   if sz gt 1    then begin
			   if (xi gt 60) and (yi gt 60)   then begin
			      if (sx ne xi) or (sy ne yi) then $
			         i=execute('tvscl,congrid(total(w' + wkstring + ',3),xi,yi),xo,yo') else $
			         i=execute('tvscl,        total(w' + wkstring + ',3)       ,xo,yo')
			   endif else $
			         i=execute('tvscl,congrid(total(w' + wkstring + ',3),uv4,uv5)')
		   endif
		endif else begin
			minx=w_min(fix(wkstring))
			wks ='w' + wkstring
			wr  =0.
			if sz eq 1    then begin
			  tip =sizw(sizw(0)+1) ;+newtypes*****
			  if tip lt  2 then nbyt=sx*sy   else if tip eq  2 then nbyt=sx*sy*2 else $
			  if tip le  4 then nbyt=sx*sy*4 else if tip eq 12 then nbyt=sx*sy*2 else $
			  if tip eq 13 then nbyt=sx*sy*4 else nbyt=sx*sy*8
			  if (nbyt+3*2 ge long(uv4)*uv5) and (sy gt 1) then begin
			   if minx le 0 then i =execute( 'wr=alog('+wks+'-minx+0.1)' ) $
			         	else i =execute( 'wr=alog('+wks+')' )
			   if sy eq 1 then begin
;			         wt=congrid(wr,uv4,/interp)
;			         if n_elements(xx) gt 1 then $
;			      	    plot,congrid(xx,uv4),wt,xmargin=[5,0],ymargin=[3,0],ytitle='log' $
;			      	 else plot,		 wt,xmargin=[5,0],ymargin=[3,0],ytitle='log'
;				 wr     =tvrd(0,0,uv4,uv5)
;			      	 wr(0,0)=bytscl(congrid(wt,uv4,2))
			   endif else wr=bytscl(congrid(temporary(wr),uv4,uv5,/interp))
			  endif
			endif else begin
			   if sx gt sy then begin i=execute('wr=reform(w'+wkstring+',sx,sy*sz)')
		      	        		  mini=w_min(fix(wkstring))
		      	       			  maxi=w_max(fix(wkstring))
			   endif else begin
			        if (sy gt sz) and (sy ne sx) then j=2 else j=3
			        i  =execute('wr=total(w' + wkstring + ',j)')
		  	        maxi =max(wr,min=mini)
		      	        w_min(fix(wkstring))=mini
		      	        w_max(fix(wkstring))=maxi
			   endelse

			   sizw=size(wr) & sx=sizw(1) & sy=sizw(2) & tip=sizw(sizw(0)+1)
			   if tip lt  2 then nbyt=sx*sy   else if tip eq  2 then nbyt=sx*sy*2 else $
			   if tip le  4 then nbyt=sx*sy*4 else if tip eq 12 then nbyt=sx*sy*2 else $
			   if tip eq 13 then nbyt=sx*sy*4 else nbyt=sx*sy*8 ;+newtypes*****

;			   if (nbyt+3*2 ge long(uv4)*uv5) then begin
			       if mini le 0 then wr=alog(temporary(wr)-mini+0.1) $
			         	    else wr=alog(temporary(wr))
			       wr=bytscl(congrid(temporary(wr),uv4,uv5,/interp))
;			   endif
			endelse
		endelse
		!order=worder
return
end

pro p_did_save_format, form
;** *****************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
    common c_savt,	sav_tab ,sav_tap,sav_forp,sav_m

    sav_form=form
    if form eq 6 then sav_form=sav_forp
    if form gt 6 then begin sav_forp=form
                      widget_control,bad_id=i,sav_m,set_value=sav_tab(form) & endif
return
end

pro p_did_save_list, event
;** ***************
;**
@lamp.cbk
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv
	sav_idx=event.index
	if (sav_idx ge 0) and (sav_idx lt n_elements(limtxt)) then begin
	    wi=fix(strmid(limtxt(sav_idx),1,2))
	    if (wi ge 1) and (wi le lamp_sys) then begin
	    	num=strcompress(w_numor(wi),/remove_all)
	    	if num ne '' then begin
	    		widget_control,sav_f,bad_id=i,set_value=num
	    		sav_file=num
	endif & endif & endif
return
end

pro p_did_save_filename,event
;** *******************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

      widget_control,sav_f,bad_id=i,get_value=fname
      sav_file=sys_dep      ('BLANKS',fname(0))
      i=strpos(sav_file,'.')
      if i ge 0 then sav_file=strmid(sav_file,0,i)+'_'+strmid(sav_file,i+1,20)
return
end

pro p_did_save_seq
;** **************
;**
    common c_save,	sav_form,sav_idx,sav_f,sav_file,sav_l,sav_seq,sav_b,sav_pthv,sav_uv

      sav_seq=0
      k=0
      res=findfile(sav_pthv+sav_file+'*',count=k)

      i=0
      while k gt 0 do begin i=i+1 & res=findfile(sav_pthv+sav_file+'_'+strtrim(string(i),2)+'*',count=k)
      		   endwhile
      sav_seq=i
return
end

;*************************************** Process Restore Wi ******************************
;*************************************** Process Restore Wi ******************************
;*************************************** Process Restore Wi ******************************
function read_tmp, INST , PATH , FILENAME , STATUS , DATP
;******* ********
;**
 DATA=dist(40)         & STATUS=0 &  pall=INDGEN(40,6)
 xv  =INDGEN(40)*2 +15 & wt=' Template_read test '
 par =[3.0,5.5]        & xt=' This is the X axis '
 ptxt=['First  parameter','Second parameter' ]
 DATP={X:xv,W_TIT:wt,X_TIT:xt,P:par,PAR_TXT:ptxt,PV:pall}
 return,DATA
end

pro read_lamp,file, w=wi, path=pth
;** *********
;**
@lamp.cbk
auto=-1
if (n_elements(wi) eq 1) and (n_elements(file) gt 0) then $
if (wi gt 0) and (wi le lamp_sys+3) and (file(0) gt ' ')   then begin
						     if n_elements(pth) ne 1 then pth=''
						     ws=strtrim(string(wi),2) & fil=file
		   				     if (strpos(file(0),'_LAMP') lt 0) and $
						        (strpos(file(0),'.htm' ) lt 0) and $
						        (strpos(file(0),'.xml' ) lt 0) and $
						        (strpos(file(0),'.nxs' ) lt 0) and $
						        (strpos(file(0),'.hdf' ) lt 0)  then fil(0)=fil(0)+'_LAMP'
						     p_did_restore_wrk,fil,pth,ws,'',auto & endif
						     if strpos(fil(0),'{') gt 0 then file(0)=fil(0)
						     if (wi le lamp_sys) then $
						     to_don_history, wi,0,'READ_LAMP,"'+pth+file(0)+'",w='+ws
if auto lt 0 then print,string(7b)+'file not read ...!'
return
end

pro read_myGIF,file, w=wi
;** **********
;**
@lamp.cbk
	wstr='w'+strtrim(string(wi),2) & XICUTE, wstr+'=0'
	i=execute('READ_KIF,file,'+wstr)
	to_don_history, wi,0,'READ_KIF,'+file+', '+wstr
end

pro p_did_res_hdf,fil,pth,ws,hyst,rflag
;** *************
;** Read  HDF LAMP format
@lamp.cbk

if rflag eq -2 then look=1 else look=0
if strpos(strlowcase(fil),'.xml') gt 0 then xml=1 else xml=0
rflag=-1
ac   = 0
      i=strpos(fil,'{') & nimg=1
      if i gt 1 then begin j=strpos(fil,'}')
                     ac=1
                     if j gt i+1 then nimg=strmid(fil,i+1,j-i-1)
                     fil=strmid(fil,0,i)
                     endif
if look eq 1 then begin Data=-88
	if xml then read_xml,pth+fil, Data, SNAP=w_buf, IMG=nimg  $
	       else read_hdf,pth+fil, Data, SNAP=w_buf, IMG=nimg
	if n_elements(Data) gt 1 then begin hyst=Data & rflag=0 & endif
endif else  begin
      if xml then proc='read_xml' else proc='read_hdf'
      wi=fix(ws)
      p_txt=''
      ii=execute(proc+',pth+fil,w'+ws+',XC=x'+ws+',YC= y'+ws+',ZC=z'+ws+',E=e'+ws      + $
                      ',N= n'+ws+',PR=p'+ws+',PV=pv'+ws+',PAR_TXT=p_txt,W_TIT=wt,X_TIT=xt'+ $
                      ',Y_TIT=yt,Z_TIT=zt,OTHER_TIT=ot ,SOURCE=src, HIST=hyst, IMG=nimg')
      if ii eq 1 then begin
         par_txt(wi,*)='' & npar=n_elements(p_txt) & if npar gt npars then npar=npars
         rflag=0
         if npar gt 0 then for i=0,npar-1 do par_txt(wi,i)=p_txt(i)
         head_tit(wi,2)=src
         w_tit(wi)=wt & x_tit(wi)=xt & y_tit(wi)=yt & z_tit(wi)=zt & other_tit(wi)=ot
	 if src ne '' then if strlowcase(inst_value) ne strlowcase(src) then RDSET,inst=src
      endif
endelse
if not ac then fil=fil+'{1.1}'
if xml then if (rflag eq 0) then rflag=10
end

pro p_did_restore_wrk,fil,pth,wnumber,hyst,rflag
;** *****************
;** Read  LAMP  format
;** Incoming:   input filename 		= pth+fil
;**		workspace string number = wnumber

@lamp.cbk
if n_elements(fil) eq 2 then if strpos(fil(0),'{') lt 0 then fil=fil(0)+'{'+fil(1)+'}'

if strpos(strlowcase(fil),'.xml') ge 0 then begin p_did_res_hdf,fil,pth,wnumber,hyst,rflag & return & endif
if strpos(strlowcase(fil),'.hdf') ge 0 then begin p_did_res_hdf,fil,pth,wnumber,hyst,rflag & return & endif
if strpos(strlowcase(fil),'.nxs') ge 0 then begin p_did_res_hdf,fil,pth,wnumber,hyst,rflag & return & endif
;                          ****
if rflag eq -2 then look=1 else look=0
rflag=-1

;**Read Header
;****** ******
   standard=0
   unit=-1
   on_ioerror,pathread		& ok=0
   openr,unit,fil ,/get_lun	& ok=1
   pathread:  on_ioerror,endhead
   if ok eq 0 then openr,unit, pth+fil ,/get_lun
   standard=1

   keyw=['LAMP_FORMAT'   , 'DATA_FILE:'    , 'HISTORY:'   , 'X_SIZE:'    , 'Y_SIZE:'  , $
	 'Z_SIZE:'       , 'FORMAT:'       , 'TYPE:'      , 'PARAMETERS:', 'MONITORS:', $
	 'X_COORDINATES:', 'Y_COORDINATES:', 'TITLES:'    , 'VAR PARAM:' , 'MACHINE:' , $
	 'Z_COORDINATES:', 'ERRO_FILE:'    , 'SOURCE:']
   nkey=n_elements(keyw)-1

   data=''   & wyst='' & xsiz=0  & ysiz=0  & zsiz=0 & frmt=0  & tipe=0
   parm=0    & ttl ='' & moni=0  & cdnx=0  & cdny=0 & cdnz=0  & npar=0
   ttx =''   & tty ='' & ttz ='' & tto ='' & parv=0 & erro='' & sorc=''

   partx =['']
   hyst  =''
   line  =' '
   mach  ='uni'

   while (1) do begin
	readf,unit, line
	if look eq 1 then hyst=[hyst,line]

	n=-1 & r=-1
	while (n lt nkey) and (r lt 0) do begin
	       n=n+1
	       r=STRPOS(line,keyw(n))
	endwhile

	if r ge 0 then begin
	 r=STRPOS(line,':')
	 if r ge 0 then remi=strtrim( strmid(line,r+1,100) ,2)

	 CASE keyw(n) of
	'LAMP_FORMAT':   begin standard=1
			 end
	'DATA_FILE:':	 begin data= strtrim(remi,2)
			 end
	'ERRO_FILE:':	 begin erro= strtrim(remi,2)
			 end
	'HISTORY:':	 begin wyst= strtrim(remi,2)
			 end
	'SOURCE:':	 begin sorc= strtrim(remi,2)
			 end
	'X_SIZE:':	 begin xsiz= long(remi)
			 end
	'Y_SIZE:':	 begin ysiz= long(remi)
			 end
	'Z_SIZE:':	 begin zsiz= long(remi)
			 end
	'FORMAT:':	 begin if remi eq 'Binary' 		then frmt=1
			       if remi eq 'Ascii'  		then frmt=2
			       if remi eq 'XDR'    		then frmt=3
			       if remi eq 'F77 unformatted'	then frmt=4
			 end
	'TYPE:':	 begin if strmid(remi,2,1) eq ')' then r=1 else r=2 ;+newtypes*****
	        	       tipe=fix( strmid(remi,1,r) )
			 end
	'TITLES:':	 begin ttl = remi
			 	r=1
			 	while r ge 0 do begin
				    readf,unit, line
			 	    if look eq 1 then hyst=[hyst,line]
				    r=STRPOS(line,' X:')
				    if r ge 0 then    ttx=strtrim(strmid(line,r+3,80),2) $
				    else begin        r  =STRPOS(line,' Y:')
				     if r ge 0 then   tty=strtrim(strmid(line,r+3,80),2) $
				     else begin       r  =STRPOS(line,' Z:')
				      if r ge 0 then  ttz=strtrim(strmid(line,r+3,80),2) $
				      else begin      r  =STRPOS(line,' OTHER:')
				       if r ge 0 then tto=strtrim(strmid(line,r+7,80),2)
				    endelse & endelse & endelse
				endwhile
			 end
	'PARAMETERS:':	 begin
			 readf,unit, line
			 if look eq 1 then hyst=[hyst,line]
			 r=STRPOS(line,'--')
			 if r ge 0 then begin
			 	r=0 & npar=0
			 	while r ge 0 do begin
				    readf,unit, line
			 	    if look eq 1 then hyst=[hyst,line]
				    r=STRPOS(line,'* ')
				    if r ge 0 then begin   ip=STRPOS(line,'==')
					   if ip lt 0 then ip=STRPOS(line,'=' ) else ip=ip+1
				     if ip gt 0 then begin remi=         strmid(line,r+2,ip-r-1)
				    			   if npar eq 0 then partx=[remi] $
				    			 	        else partx=[partx,remi]
				    			   remi=strtrim(strmid(line,ip+1,15)   ,2)
				    			   if npar eq 0 then parm =[remi] $
				    			 	        else parm =[parm ,remi]
				    			   npar=npar+1
				     endif
				    endif
				endwhile
				on_ioerror,misfloat & parm=float(parm) & misfloat: on_ioerror,endhead
			 endif
			 end
	'VAR PARAM:':	 begin
			 r=STRPOS(remi,'nb=')
			 if r ge 0 then begin
			 	reads, strmid(remi,r+3,10)+'0 0 0' ,da1,da2,da3
			 	if da1 gt 0 then begin
			 	 if da2 gt 0 then if da3 gt 0 then parv=fltarr(da1,da2,da3) $
			 				    else parv=fltarr(da1,da2)    $
			 				    else parv=fltarr(da1)
			 	 readf,unit, line
			 	 readf,unit, parv
			 	 if look eq 1 then begin
					parv= reform(parv,1.*da1*(da2>1)*(da3>1))
					hyst= [hyst,line,string(parv,format='(10G)')]
			 	 endif
			 	endif
			 endif
			 end
	'MONITORS:':	 begin
			 r=STRPOS(remi,'nb=')
			 if r ge 0 then begin
			 	reads, strmid(remi,r+3,10)+'0 0 0' ,da1,da2,da3
			 	if da1 gt 0 then begin
			 	 if da2 gt 0 then if da3 gt 0 then moni=fltarr(da1,da2,da3) $
			 				    else moni=fltarr(da1,da2)    $
			 				    else moni=fltarr(da1)
			 	 readf,unit, line
			 	 readf,unit, moni
			 	 if look eq 1 then begin
					moni= reform(moni,1.*da1*(da2>1)*(da3>1))
					hyst= [hyst,line,string(moni,format='(10G)')]
			 	 endif
			 	endif
			 endif
			 end
	'X_COORDINATES:':if xsiz gt 0 then begin
			 r=STRPOS(remi,'->')
			 if r lt 0 then begin
			        r=STRPOS(remi,'bi_dim')
			 	if r lt 0 then cdnx=fltarr(xsiz) else cdnx=fltarr(xsiz,ysiz)
			 	readf,unit, line
			 	readf,unit, cdnx
			 	if look eq 1 then hyst=[hyst,line,string(cdnx,format='(10G)')]
			 endif else begin  da1=1L
				reads, strmid(remi,0,r-1)+' 1' ,da1
				cdnx=lindgen(xsiz)+da1
			 endelse & endif
	'Y_COORDINATES:':begin
			 r=STRPOS(remi,'->')
			 if r lt 0 then begin
			        r=STRPOS(remi,'bi_dim')
			 	if r lt 0  then begin r=STRPOS(remi,'nb=') & da1=0
				           if r ge 0 then reads,strmid(remi,r+3,20)+' 0',da1
				           if da1 le 0 then da1=ysiz>1
				           cdny=fltarr(da1)
				endif else cdny=fltarr(xsiz,ysiz>1)
			 	readf,unit, line
			 	readf,unit, cdny
			 	if look eq 1 then hyst=[hyst,line,string(cdny,format='(10G)')]
			 endif else begin  da1=1L
				reads, strmid(remi,0,r-1)+' 1' ,da1
				cdny=lindgen(ysiz>1)+da1
			 endelse  & end
	'Z_COORDINATES:':begin
			 r=STRPOS(remi,'nb=')
			 if r ge 0 then begin
			 	reads, strmid(remi,r+3,20)+' 1' ,da1
				cdnz=fltarr(da1>1)
			 	readf,unit, line & readf,unit, cdnz
			 endif else $
				reads,remi+' 0',cdnz
			 	if look eq 1 then hyst=[hyst,line,string(cdnz,format='(10G)')]
			 end
	'MACHINE:':	 mach=strmid(remi,0,3)

	'HOW TO READ':   while (1) do readf,unit, line

	 else:
	 endcase
	endif
   endwhile
   endhead:if unit gt 0 then free_lun,unit else return

;**Test Header
;****** ******
   pngr =-1
   rflag= 0
   zdel = 0
   j=strpos(fil,'.')
   if j gt 0 then jz ='Z' else jz='.Z'

   if (standard eq 0)              then  hyst=[hyst,' ??? Header file not readable ....'] else $
   if (xsiz le 0) and (ysiz le 0)  then  hyst=[hyst,' ??? Data size not specified .....'] else $
   if (frmt eq 0)                  then  hyst=[hyst,' ??? Data format not specified ...'] else $
   if (tipe le 0) or  (tipe ge 16) then  hyst=[hyst,' ??? Data type not specified .....'] else $ ;+newtypes*****
   if (data eq '')                 then  begin rflag=1
;   					hyst=[hyst,' ??? Data file not specified .....']
;					TOUCH_BASE   ???
;				     ***Try imgR
   					pngr=1 & j=strpos(fil,'.')
   					if j gt 0 then data=strmid(fil,0,j)+'imgR.' $
   						  else data=fil+'imgR'
   					if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						     else i=findfile(    data   ,count=cnt)
;				     ***Try xdr
   					if (cnt le 0) and (pth gt ' ') then begin
   					   pngr=-1
 					   k   =strlen(pth)
 					   ddir=strmid(pth,0,k-1)+'d'+strmid(pth,k-1,1)
					   data=strmid(fil,0,lamp_6)
   					   if j gt 0  then    data=data+'.'
   					   i   =findfile(ddir+data+jz ,count=cnt)
   					   if cnt gt 0 then frmt=3
   					   if cnt gt 0 then pth =ddir
   					endif
;				     ***Try png
   					if cnt le 0 then begin
   					   pngr=0
   					   if j gt 0 then data=strmid(fil,0,j)+'png.' $
   						     else data=fil+'png'
   					   if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						        else i=findfile(    data   ,count=cnt)
   					endif
;				     ***Try jpg
   					if cnt le 0 then begin
   					   pngr=0
   					   if j gt 0 then data=strmid(fil,0,j)+'jpg.' $
   						     else data=fil+'jpg'
   					   if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						        else i=findfile(    data   ,count=cnt)
   					endif
;				     ***Try img
   					if cnt le 0 then begin
   					   pngr=0
   					   if j gt 0 then data=strmid(fil,0,j)+'img.' $
   						     else data=fil+'img'
   					   if pth ne '' then i=findfile(pth+data+jz,count=cnt) $
   						        else i=findfile(    data   ,count=cnt)
   					endif
   					if cnt le 0 then rflag=-1
   endif else rflag=1

;**Read the Data
;****** *** ****
     if (look eq 0) and (rflag eq 1) then begin
        if frmt ne 3 then rflag=-1 else rflag=0
	on_ioerror, nofile
	unit=-1
	unet=-1
	ptd =pth

	i=findfile(pth+data,count=cnt)
	if cnt eq 0 then begin
	  i=findfile(data,count=cnt)
	  if cnt gt 0 then ptd='' else begin
	   i=findfile(pth+data+jz,count=cnt)
	   if cnt gt 0 then begin
	      i=strpos(strupcase(pth),'TOUCH')
	      if (i ge 0) or (pth ne '') then begin
		   bid =sys_dep      ('COPY',data+jz,pth)
		   zdel=1
		   ptd =''
	      endif
	      bid=sys_dep      ('UN_Z',ptd+data+jz,lamp_dir)
	   endif
	   if cnt eq 0 then begin
		i=findfile(data+'.',count=cnt)
		if cnt gt 0 then begin data=data+'.' & if erro ne '' then erro=erro+'.'
		endif else begin
			if frmt eq 0 then ext ='hdf'   else if frmt eq 1 then ext ='bin' else $
			if frmt eq 2 then ext ='ascii' else if frmt eq 3 then ext ='xdr' else $
			if frmt eq 4 then ext ='f77'
			i=strpos(fil,'.htm')
			if i gt 0 then begin data=strmid(fil,0,i)+'.xdr' & dat2=strmid(fil,0,i)+'.zip'
			                     if (findfile(pth+data))(0) eq '' then  data=dat2
			endif else data=fil+ext
			if erro ne '' then erro=data+'_e'
		endelse
	   endif
	  endelse
	endif

	i= strpos(data,'.zip')
	if i gt 0 then begin dat2=strmid(data,0,i)+'.xdr'
	                     re =findfile(ptd+dat2,count=cnt)
	                     if  cnt eq 0 then re=sys_dep('UNZIP',data,ptd) & data=dat2 & endif

	if (frmt eq 1) or (frmt eq 2)	then OPENR,  unit, ptd+data ,/GET_LUN
	if (frmt eq 3)			then OPENR,  unit, ptd+data ,/GET_LUN,/XDR
	if (frmt eq 4)			then OPENR,  unit, ptd+data ,/GET_LUN,/F77

	rflag=0
	doe=erro
	if erro ne '' then if strpos(doe,'sqrt(i)') ge 0 then erro='' else doe=''
	if erro ne '' then begin
	on_ioerror, noerro
	flge=0
	if (frmt eq 1) or  (frmt eq 2)	then OPENR,  unet, pth+erro ,/GET_LUN
	if (frmt eq 3) and (pngr ne 0)  then OPENR,  unet, pth+erro ,/GET_LUN,/XDR
	if (frmt eq 4)			then OPENR,  unet, pth+erro ,/GET_LUN,/F77
	flge=1
	noerro:if flge eq 0 then erro=''
	endif

	on_ioerror, enddata
	fil  =data

	if xsiz le 0 then xsiz=1
	if ysiz lt 0 then ysiz=1
	if pngr ne 0 then begin
	   if zsiz gt 1 then i=execute('w'+wnumber+'=MAKE_ARRAY( xsiz,ysiz,zsiz ,TYPE=tipe)' ) else $
	   if ysiz gt 1 then i=execute('w'+wnumber+'=MAKE_ARRAY( xsiz,ysiz      ,TYPE=tipe)' ) else $
	   if ysiz eq 1 then i=execute('w'+wnumber+'=MAKE_ARRAY( xsiz           ,TYPE=tipe)' ) else $
	   if ysiz eq 0 then i=execute('w'+wnumber+'=MAKE_ARRAY(  3  ,xsiz      ,TYPE=tipe)' )
	endif
	i=execute('x'     +wnumber+' =cdnx')
	i=execute('y'     +wnumber+' =cdny')
	i=execute('z'     +wnumber+' =cdnz')
	i=execute('e'     +wnumber+' =0   ')
	i=execute('n'     +wnumber+' =moni')
	i=execute('p'     +wnumber+' =parm')
	i=execute('pv'    +wnumber+' =parv')
	par_txt(fix(wnumber),*)=''
	if npar gt npars then npar=npars
	if npar gt 0 then for i=0,npar-1 do par_txt(fix(wnumber),i)=partx(i)
	w_numor  (fix(wnumber))  =''
	w_tit    (fix(wnumber))  =ttl
	x_tit    (fix(wnumber))  =ttx
	y_tit    (fix(wnumber))  =tty
	z_tit    (fix(wnumber))  =ttz
	other_tit(fix(wnumber))  =tto
	head_tit (fix(wnumber),*)=''
	head_tit (fix(wnumber),2)=sorc
	if sorc ne '' then if strlowcase(inst_value) ne strlowcase(sorc) then RDSET,inst=sorc

	if pngr lt 0 then begin
	   if  frmt ne 2 then i=execute('READU,  unit,w'+wnumber ) else $
	   if  frmt eq 2 then i=execute('READF,  unit,w'+wnumber )
	   if  erro ne '' then begin
	    i=execute('e'+wnumber+ '=w'+wnumber)
	    if frmt ne 2 then i=execute('READU,  unet,e'+wnumber ) else $
	    if frmt eq 2 then i=execute('READF,  unet,e'+wnumber )
	   endif
	endif else begin
	   if pngr eq 0 then begin
	   		     if frmt eq 3 then READ_KIF,pth+data,buf $
	   		                  else READ_KIF,pth+data,buf, 192,192
	   		     buf=float (buf)
	   		     if zsiz gt 1 then begin
	   		        if  xsiz gt ysiz then  ysiz=ysiz*zsiz else $
	   		        if (ysiz gt zsiz) and (ysiz ne xsiz) then ysiz=zsiz
	   		        zsiz=1
	   		     endif
	   		     i=execute('w'+wnumber+'=CONGRID(buf,xsiz,ysiz,/INTER)' )
	   endif else begin  bxs=fix(0) & bys=fix(0) & bts=fix(0)
	   		     READU, unit, bxs,bys,bts
	   		     i=execute('READU,  unit,w'+wnumber )
	   endelse
	endelse

	if doe ne '' then $
	if doe eq 'sqrt(i)'       then i=execute('e'+wnumber+' =sqrt(w'+wnumber+')')                else $
	if doe eq 'sqrt(i)/i'     then i=execute('e'+wnumber+' =sqrt(w'+wnumber+')/ w'+wnumber)     else $
	if doe eq 'sqrt(i)/(i+1)' then i=execute('e'+wnumber+' =sqrt(w'+wnumber+')/(w'+wnumber+'+1)')

	enddata:if  unit gt 0  then free_lun,unit

	if pngr lt 0 then $
	if ysiz eq 0 then if frmt eq 2  then begin
					i=execute('e'+wnumber+'=reform(w'+wnumber+'(2,*))' )
					i=execute('w'+wnumber+'=reform(w'+wnumber+'(1,*))' )
					endif
	res=sys_dep      ('SWAPER',mach)
	if (frmt eq 1) and (res eq 1) then begin ;+newtypes*****
				if tipe eq 2  then i=execute('BYTEORDER,w'+wnumber+',/SSWAP')   else $
				if tipe eq 3  then i=execute('BYTEORDER,w'+wnumber+',/LSWAP')   else $
				if tipe eq 12 then i=execute('BYTEORDER,w'+wnumber+',/SSWAP')   else $
				if tipe eq 13 then i=execute('BYTEORDER,w'+wnumber+',/LSWAP')   else $
				if tipe eq 14 then i=execute('BYTEORDER,w'+wnumber+',/L64SWAP') else $
				if tipe eq 15 then i=execute('BYTEORDER,w'+wnumber+',/L64SWAP')
				if erro ne '' then $
				if tipe eq 2  then i=execute('BYTEORDER,e'+wnumber+',/SSWAP') else $
				if tipe eq 3  then i=execute('BYTEORDER,e'+wnumber+',/LSWAP')
	endif

	nofile: if unit lt 0 then print,string(7b),'% File '+pth+data+' not found ...'
	if zdel eq 1 then bid =sys_dep      ('DELET',data)

     endif

  if rflag ge 0 then if frmt eq 3  then rflag=10
  if look  eq 0 then if hyst eq '' then hyst =strtrim(wyst,2) else print,string(7b),hyst

end

;*************************************** Data access ******************************
;*************************************** Data access ******************************
;*************************************** Data access ******************************

pro P_DATA_ACCESS, laber,b33,bac,butb, flag
;** *************
;**
;** Create Data Access buttons
@lamp.cbk

if b33 gt 0 then begin
   if flag ne 0 then begin
	  tmpbase=0    & P_messi , tmpbase,(lamp_b1+0)

	  P_DATA_IDOL
	  if lamp_siz ge 800 then bid = widget_label (b33     ,font=ft_b_normal,value='Ins:')
	  NEW=inst_value & IF strcompress(NEW) LE ' ' THEN NEW='New !!'
	  if sys_dep('MAP') ne -1 then $
	  b_labins(0)=widget_button(b33     ,font=ft_b_normal,value=NEW,menu=2,$
	  						      resource_name='discret') else $
	  b_labins(0)=widget_button(b33     ,font=ft_b_normal,value=NEW,menu=2)

	 ;if lamp_siz ge 900 then bid = widget_label (b33     ,font=ft_b_normal,value='Pth:')
	  if sys_dep('MAP') ne -1 then $
	  b_labins(1)=widget_button(b33     ,font=ft_b_normal,value=cycle     ,menu=2,$
	  						      resource_name='discret') else $
	  b_labins(1)=widget_button(b33     ,font=ft_b_normal,value=cycle     ,menu=2)

	  to_don_history,-1,0,'RDSET,base="'+cycle   ;+'",inst="'+inst_value+'"'

	  uval =[-88,560,laber,b_labins(0),b_labins(1)]
	  gcur =' '
	  entr1=b_labins(0)
	  for i=0,n_elements(lamp_ins)-1 do begin
	      if  gcur ne  lamp_grp(i) then begin
		  gcur  =  lamp_grp(i)
		  if gcur eq ' ' then entr1=b_labins(0) else $
		  entr1 =widget_button(b_labins(0),font=ft_b_normal,value=gcur,menu=2)
		  endif
	      bidon=widget_button(entr1  ,font=ft_b_normal,value=lamp_ins(i),uvalue=[uval,i,0,0])
	  endfor
	  bidon=widget_button(b_labins(0),font=ft_bigger ,value='CUSTOMIZE',uvalue=[uval,-1,0,0])

	  uval =[-88,561,laber,b_labins(0),b_labins(1)]
	  for i=0,n_elements(lamp_ali)-1 do begin
	      if strpos(strlowcase(lamp_ali(i)),'c_year') ge 0 then begin
		yr =strtrim(strmid(lamp_ali(i),7,15),2) & yr=strmid(yr,2,2)
		didon=widget_button(b_labins(1),font=ft_b_normal,menu=2		    ,value=lamp_ali(i))
		for j=1,5 do begin  yrs=yr+strtrim(string(j),2)
		  bid=widget_button(didon      ,font=ft_b_normal,uvalue=[uval,i,0,long(yrs)],value='Cycle '+yrs)
		endfor
	      endif else $
		bidon=widget_button(b_labins(1),font=ft_b_normal,uvalue=[uval,i,0,0]	    ,value=lamp_ali(i))
	  endfor

	  uvbuti=[-88,575,laber,0,b33,0,0,0,0]
	  P_MAC_COMPLETE, uvbuti ,butb
	  widget_control,bad_id=i,b33, set_uvalue=uvbuti

   	  bid=sys_dep      ('DYNLAB',b33,1)
	  P_messi , tmpbase,(lamp_b1+0)
   endif
   if ((flag eq 0) or (flag eq 2)) and (lamp_data ne 'hostvms') then begin
	  if lamp_siz ge 800 then text='Self...' else text='Self...'
	  widget_control,bad_id=i,b33, get_uvalue=uvbuti
	  widget_control,bad_id=i,bac ,set_value = text, set_uvalue=uvbuti
   endif
endif
return
end
pro	P_MAC_COMPLETE, uv ,butb
;**	**************
;**
@lamp.cbk
if uv(3) eq 0 then begin
	bsup =widget_base  (uv(4),/row)
	if lamp_siz ge 800 then bid = widget_label (bsup,font=ft_b_normal,value='File:')

	bnum =widget_text  (bsup,xsiz=14,ysize=1,font=ft_propor,/editable,value='Name')
	
	if sys_dep('MAP') ne -1 then $
	bget =widget_button(bsup,font=ft_b_normal,value='Read',resource_name='discret') else $
	bget =widget_button(bsup,font=ft_b_normal,value='Read')
	
	if sys_dep('MAP') ne -1 then $
	bnex =widget_button(bsup,font=ft_smaller ,value='+1',resource_name='discret') else $
	bnex =widget_button(bsup,font=ft_smaller ,value='+1')
	uv(3)=bnum
	if lamp_siz ge 800 then text='raw->' else text='raw'
	bidon=widget_base  (bsup,/nonexclusive)
	if sys_dep('MAP') ne -1 then $
	braw =widget_button(bidon,value=text,font=ft_smaller,resource_name='discret') else $
	braw =widget_button(bidon,value=text,font=ft_smaller)
	b_labins(4) =braw

	widget_control,butb,get_uvalue=uvb & wread=uvb(4)

	if uvb(5) ne -2 then begin
	 bs1f =widget_base  (bsup,/row,/frame)
	 if sys_dep('MAP') ne -1 then $
	 bs1b1=widget_button(bs1f,font=ft_smaller ,value='<',resource_name='discret') else $
	 bs1b1=widget_button(bs1f,font=ft_smaller ,value='<')
	 wread=widget_label (bs1f,font=ft_b_normal,value='W1 ',xsize=29)
	 if sys_dep('MAP') ne -1 then $
	 bs1b2=widget_button(bs1f,font=ft_smaller ,value='>',resource_name='discret') else $
	 bs1b2=widget_button(bs1f,font=ft_smaller ,value='>')

	 widget_control, bs1b1  ,bad_id=i,set_uvalue=[-88,310,wread,0   ,0,0,0,0,0]
	 widget_control, bs1b2  ,bad_id=i,set_uvalue=[-88,311,wread,0   ,0,0,0,0,0]
	endif
	
	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1
	
	widget_control, braw   ,bad_id=i,set_uvalue=[-88,312,0]
	widget_control, butb   ,bad_id=i,set_uvalue=[-88,562,uv(2),bnum,wread,-1,-1,0],sensitive=1
	widget_control, bget   ,bad_id=i,set_uvalue=[-88,577,uv(2),bnum,wread,0,0,0,0]
	if txev then $
	widget_control, bnum   ,bad_id=i,set_uvalue=[-88,577,uv(2),bnum,wread,0,0,0,0]
	widget_control, bnex   ,bad_id=i,set_uvalue=[-88,578,uv(2),bnum,wread,0,0,0,0]

	if n_elements(monimon) eq 0 then monimon=-1
	if monimon lt 0 then    widget_control,braw    ,bad_id=i,set_button=1
endif
return
end

pro P_DATA_IDOL
;** ***********
@lamp.cbk
    	if (lamp_data  eq 'hostvms') then begin
    				if lamp_exec ne '' then tmp=findfile(lamp_exec,count=j) else j=0
				if j le 0 then  lamp_data  =''
				if j gt 0 then  begin cycle='On_Line'
						inst_value = lamp_host
						lamp_exec  ='lamp_exec'
					;	lamp_entry ='r_mic'
						endif
    	endif else begin	j=0
				if lamp_exec gt ' '   then tmp=findfile(lamp_exec,count=j)
				if j le 0 then begin
				  lamp_exec=sys_dep      ('EXEC',lamp_dir)
				  if lamp_exec gt ' ' then tmp=findfile(lamp_exec,count=j)
				endif
				if j gt 0 then if lamp_cyc(0) eq 0 then begin
				  lamp_data ='idol'
				  lc  =where(lamp_ali eq 'On_Line') & lamp_cyc(0)=lc(0)>0
				  cycle     =lamp_ali(lamp_cyc(0))
				  if inst_value eq '' then inst_value='?Inst?'
				 ;lamp_entry=sys_dep      ('ENTRY')
				endif
    	endelse
end

pro	P_MAC_LABINS
;**	************
;**
@lamp.cbk
	   NEW=inst_value & IF strcompress(NEW) LE ' ' THEN NEW='New !!'
	   if b_labins(0) gt 0 then widget_control,b_labins(0),bad_id=i,set_value=NEW
	   if b_labins(1) gt 0 then widget_control,b_labins(1),bad_id=i,set_value=cycle
return
end

function flto6, run
;******* *****
;**
@lamp.cbk
    	file=strtrim(string(run),2) & ln=strlen(file)
    	while ln lt lamp_6 do begin file='0'+file & ln=ln+1 & endwhile
return, file
end

pro CALIBRATION ,FILE=file ,NOCAL=nocal ,LIST=list
;** ***********
@lamp.cbk
    ii=0 & ii=execute('ii=rdid()')
    if keyword_set(file)  then P_DID_CALOD, strlowcase(inst_value) ,file ,flg	else $
    if keyword_set(nocal) then P_DID_CALOD, strlowcase(inst_value)		else $
    if keyword_set(list)  then P_DID_CALOD, strlowcase(inst_value) ,/LIST	else $
    if b_labins(3) ge  1  then P_DID_CALOD, strlowcase(inst_value) ,/LIST	     $
			  else P_DID_CALIB, inst_value+'' , lamp_b1
return
end

function rlamp, inst,path,file,status,datp
;******* *****
;**
status=0
		 pp2=-1
		 p_did_restore_wrk, file,path,datp,'',pp2
		 if pp2 lt 0 then status=11
return,1
end

pro p_did_get_it, run,wi,status,uv ,run_fil
;** ************
;**
@lamp.cbk
    if uv(2) gt 0 then $
       if strpos(path_for_online,strlowcase(inst_value)) gt 0 then $
            widget_control,uv(2),bad_id=i,set_value='Checking '+path_for_online+' ...' $
       else widget_control,uv(2),bad_id=i,set_value='Reading ...'
    ran=run
    if run_fil eq 'run' then p_did_getrun, run,wi,status
    if run_fil eq 'fil' then p_did_getfil, run,wi,status
    if run_fil eq 'opr' then rdmulti     , run   ,status,uv(2),wi

    if status ne 0 then begin
		 	     errtxt=' Un_implemented status '+string(status)
	if status eq 1  then errtxt=' Client/server on local node not established'
	if status eq 2  then errtxt=' Client/server on router node not established'
	if status eq 3  then errtxt=' The local node cannot access the server node'
	if status eq 4  then errtxt=' The router node cannot access the server node'
	if status eq 5  then errtxt=' VME memory read error'
	if status eq 6  then errtxt=' No host defined'
	if status eq 7  then errtxt=' Sequence error in data transfer'
	if status eq 8  then errtxt=' Memory space or buffer too small'
	if status eq 9  then errtxt=' Parameter error'
	if status eq 10 then errtxt=' Router is busy with other transfer'
	if status eq 11 then errtxt=' Cant open the file'
	if status eq 12 then errtxt=' Syntax error'
	if status eq 13 then errtxt=' Data file incomplete'
	if status eq 14 then errtxt=' Bad instrument data definition'
	if status eq 23 then errtxt=' Internal error'
	if status eq 24 then errtxt=' Cant read the file'
	print,string(7b)
	if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value=errtxt else print,errtxt
    endif  else begin
	strun=strtrim(string(run),2) & stwi='w'+strtrim(string(wi),2)
	
	if uv(2) gt 0 then widget_control,uv(2),bad_id=i,set_value=strun+' may be plotted from '+stwi
	if uv(3) gt 0 then $
	widget_control,bad_id=i,uv(3),set_value=strun
	if run_fil eq 'run' then cmd="=RDRUN(" +strun+") ;.."  else $
	if run_fil eq 'fil' then cmd="=RDRUN(" +strun+") ;.."  else $
				 cmd="=RDOPR('" +strun+"') ;.."
	if run_fil ne 'opr' then RDSET,golast=[wi,wi]
	to_don_history, wi,0,stwi+ cmd+inst_value
    endelse
return
end

pro p_did_getfil, run,wi,full
;** ************
;**
i=strpos(run,'{') & nimg=0
if i ge 1 then begin j=strpos(run,'}') & m=0
                     if j gt i+1 then begin
                     	for k=i+1,j-1 do begin
				c=strmid(run,k,1)
				if ((c lt '0') or (c gt '9')) and (c ne ' ') then m=1
			endfor
                     	if m eq 0 then nimg=long(strmid(run,i+1,j-i-1))
                     endif
                     if m eq 0 then run=strmid(run,0,i) & endif

if nimg le 1 then p_did_getrun , run,wi,full,'file' $
             else p_did_getrun , run,wi,full,'file' ,FRAME=nimg

return
end

pro p_did_getrun, run,wi,full,fifi ,FRAME=nimg
;** ************
;**
@lamp.cbk
common rd_filter,filter_proc

full	=23
status  =14
wstr    =strtrim(string(wi),2)
inst_val=strlowcase(inst_value)

idx=where(lamp_ins eq inst_value) & idx=idx(0) > 0 & proced=lamp_proc(idx)
if (proced  gt ' ') and (proced ne 'ill') and ((proced ne 'mic') or (strpos(strupcase(run),'_LAMP') gt 0)) $
		    and (cycle  ne 'On_Line')  then begin
		 	  if strpos(strlowcase(cycle),'cycle') lt 0 then kc='' else kc='1'
			  if monimon lt 0 then km='1' else km='0'
    			  inst  =[inst_value,inst_group,km,kc]
    			  path  =path_for_online
    			  if n_elements(fifi) eq 0 then begin
    			  	 file  =flto6(run)
    			  	 if  strlowcase(proced) eq 'rlamp' then $
		   		     if (strpos(file,'_LAMP') lt 0) and $
				        (strpos(file,'.htm' ) lt 0) and $
				        (strpos(file,'.xml' ) lt 0) and $
				        (strpos(file,'.nxs' ) lt 0) and $
				        (strpos(file,'.hdf' ) lt 0) then file=file+'_LAMP'
    			  	 bid =sys_dep      ('POT',file)
    			  endif else file=run
			  ac=strpos(file,'{')
    			  if n_elements(nimg) eq 1 then if nimg gt 0 then file=[file,strtrim(string(nimg),2)]

	    		  iii   =execute( 'w'+wstr+'=0') & datp=wstr
	    		  clearpar, wi,wstr
    	    		  head_tit (wi,2)=inst_value
      	    		  w_numor  (wi)  =strtrim(string(run),2)

			  if (proced eq 'rlamp') or (strpos(strupcase(file(0)),'_LAMP') gt 0) then $
			  iii   =rlamp(inst,path,file,status,datp)                  else $
    			 ;iii   =execute( 'w'+wstr+'=call_function(proced,inst,path,file,status,datp)')
    			  iii   =execute( 'w'+wstr+'='+proced+'(inst,path,file,status,datp)')

	    		  if iii ne 1 then status=23 else if status  eq 0 then $
    	    		     iii =execute( 'if n_elements(w'+wstr+') eq 1 then if w'+wstr+' eq 0 then status=13' )

	    		 ;if (status eq 0) then begin
      	    		      one=wi
	    		      GETDATP,datp
	    		      if ac lt 0 then if strpos(file(0),'{') gt 0 then run=file(0)
    	    		 ;endif
endif  else $
if inst_val eq 'pn1'  then begin
    			  status=0
    			  file  =strtrim(string(run),2)
    			  one =wi & two=0
    			  iii =execute( 'w'+wstr+'=pn1(file)' )
    			  if iii ne 1 then status=11 else $
    			     iii =execute( 'if n_elements(w'+wstr+') eq 1 then status=w'+wstr )
endif  else $
if inst_val eq 'inx'  then begin
    			  status=0
    			  file  =strtrim(string(run),2)
    			  one =wi & two=0
    			  iii =execute( 'w'+wstr+'=inx_in(file)' )
    			  if iii ne 1 then status=11 else $
    			     iii =execute( 'if n_elements(w'+wstr+') eq 1 then status=w'+wstr )
endif  else $
if (cycle eq 'On_Line') then begin
			     RPCILL, inst_val,run,wi,wstr,status
endif else begin

;*******TOF LSS
;*******TOF LSS
	    mic,1
	    clearpar,  wi,wstr
    	    fil =flto6(run)

    	    pthv=path_for_online
	    bid =findfile(pthv+FIL+'.Z',count=cprs)
	    IF  cprs GT 0     THEN BEGIN
		IF pthv NE '' THEN bid=sys_dep      ('COPY',FIL+'.Z',pthv) ELSE cprs=0
			   bid=sys_dep      ('UN_Z',FIL+'.Z')    &   path_for_online=''
	    ENDIF


    	    bid =sys_dep('POT',fil)
	    file_found =[ path_for_online+fil ]
      	    w_numor(wi)=  strtrim(string(run),2)
	    nwk_select =  wi
	    swk_select =  wstr
	    status     =0
	    iii=execute('w'+wstr+'=0')
	    iii=execute('read_data')
	    if iii ne 1 then status=23 else $
    	       iii=execute( 'if n_elements(w'+wstr+') eq 1 then status=24' )

    	    path_for_online=pthv
	    IF cprs gt 0 THEN bid=sys_dep      ('DELET',FIL)
endelse

n=n_elements(filter_proc)
if (status eq 0) and (n gt 0)	then if filter_proc(0) ne '' $
				then for i=0,n-1 do CALL_PROCEDURE,filter_proc(i),wi
full=status
return
end

pro filterpro, name
;**
common rd_filter,filter_proc
filter_proc=name
end

pro clearpar, wi,wstr
;** ********
@lamp.cbk
    	        iii=execute('p' +wstr+'= 0') & iii=execute('pv'+wstr+'= 0')
    	        iii=execute('e' +wstr+'= 0')
     	        iii=execute('n' +wstr+'= 0') & iii=execute('x' +wstr+'= 0')
     	        iii=execute('y' +wstr+'= 0') & iii=execute('z' +wstr+'= 0')
     	        par_txt  (wi,*)	 ='' & w_numor(wi)	 =''
     	        w_tit    (wi)	 ='' & x_tit  (wi)='' & y_tit(wi)='' & z_tit(wi)=''
     	        other_tit(wi)	 =''
     	        head_tit (wi,*)  =''
return
end
pro movepar, wi,wsti,wo,wsto
;** *******
@lamp.cbk
	   if wi ne wo then begin
    	      iii=execute('p' +wsto+'= p' +wsti)
    	      iii=execute('pv'+wsto+'= pv'+wsti)
     	      iii=execute('e' +wsto+'= e' +wsti)
     	      iii=execute('n' +wsto+'= n' +wsti)
     	      iii=execute('x' +wsto+'= x' +wsti)
     	      iii=execute('y' +wsto+'= y' +wsti)
     	      iii=execute('z' +wsto+'= z' +wsti)

     	      par_txt  (wo,*)   =par_txt  (wi,*)
     	      w_numor  (wo)     =w_numor  (wi)
    	      w_tit    (wo)	=w_tit    (wi)
     	      x_tit    (wo)	=x_tit    (wi)
     	      y_tit    (wo)	=y_tit    (wi)
     	      z_tit    (wo)   	=z_tit    (wi)
     	      other_tit(wo)   	=other_tit(wi)
     	      head_tit (wo,*) 	=head_tit (wi,*)
     	   endif
return
end

pro take_w, wkp , w=wi
;** ******
@lamp.cbk
if n_elements(wi) ne 1  then $
if two gt 0 then wi=two else if alone gt 0 then wi=alone else wi=one
wkp=[0L]
if wi  gt 0 then if wi  lt n_elements(w_tit) then ii=execute('wkp=w'+strtrim(string(wi),2))
return
end

pro new_w , wkp
;** ******
end

pro give_w, wkp , w=wi
;** ******
@lamp.cbk

if n_elements(wi) ne 1  then $
if one gt 0 then wi=one else if alone  gt 0  then wi=alone else wi=two
if n_elements(wkp) eq 0 then wkp=0
if wi  gt 0 then if wi  lt n_elements(w_tit) then begin
		 ii=execute('w'  +strtrim(string(wi),2)+'=wkp')
		 to_don_history, wi,0,'NEW_w,w'+strtrim(string(wi),2) & endif
return
end

pro W_store    ,W=wii ,ALL=all
;** *******
lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then FOR i=1,lamp_sys do A_store, W=(i) $
else A_store, W=wii
end
pro W_restore  ,W=wii ,ALL=all
;** *********
lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then FOR i=1,lamp_sys do A_restore, W=(i) $
else A_restore, W=wii
end
pro W_exchange ,W=wii ,ALL=all
;** **********
lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then FOR i=1,lamp_sys do A_exchange, W=(i) $
else A_exchange, W=wii
end
pro W_clear    ,W=wii ,ALL=all
;** *******
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

lamp_sys=40 ;lamp.cbk missing
if keyword_set(ALL) then begin FOR i=1,lamp_sys do A_clear, W=(i)
	a=0 & b=0 & c=0 & d=0 & e=0 & f=0 & g=0 & h=0 & i=0 & j=0 & k=0 & l=0 & m=0
	n=0 & o=0 & p=0 & q=0 & r=0 & s=0 & t=0 & u=0 & v=0 & w=0 & x=0 & y=0 & z=0
endif else A_clear, W=wii
end

pro A_exchange ,W=wii
;** **********
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys<20) then begin
	ws=strtrim(string(wii),2)
	ii=execute('wst0=wst'+ws)
	if n_elements(wst0) le 1 then return
	ii=execute('pst0=pst'+ws)
	A_store,  W=wii
	A_restore,W=wii ,/TEMP & endif
end
pro A_store ,W=wii
;** *******
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys<20) then begin
	ws=strtrim(string(wii),2)
	ii=execute('wst'+ws+'=w'+ws)
	ii=execute('take_datp,pst'+ws+',W=wii') & endif
end
pro A_restore ,W=wii ,TEMP=temp
;** *********
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys<20) then begin
	ws=strtrim(string(wii),2)
	if keyword_set(temp) then wa='0' else wa=ws
	nel=0L & ii=execute('nel=n_elements(wst'+wa+')')
	if nel le 1 then return
	ii=execute('w'+ws+'=wst'+wa)
	ii=execute('give_datp,pst'+wa+',W=wii')
	to_don_history, wii,0,'W_restore ,W='+ws ,/nojournal & endif
end
pro A_clear ,W=wii
;** *******
@lamp.cbk
common W_stload, wst0 ,wst1 ,wst2 ,wst3 ,wst4 ,wst5 ,wst6 ,wst7 ,wst8 ,wst9 ,wst10,$
	         wst11,wst12,wst13,wst14,wst15,wst16,wst17,wst18,wst19,wst20
common P_stload, pst0 ,pst1 ,pst2 ,pst3 ,pst4 ,pst5 ,pst6 ,pst7 ,pst8 ,pst9 ,pst10,$
	         pst11,pst12,pst13,pst14,pst15,pst16,pst17,pst18,pst19,pst20

wst0=0 & pst0=0
if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys+3) then begin
	ws=strtrim(string(wii),2)
	if wii le 20 then ii=execute('wst'+ws+'=0')
	if wii le 20 then ii=execute('pst'+ws+'=0')
	ii=execute('W'  +ws+'=0')
	CLEARPAR,wii,ws & endif
end

pro   setdatp, datp
    take_datp, datp & return & end
pro take_datp, datp , w=wi ,second=second ,third=third ,fourth=eme4,fifth=eme5,sixth=eme6
;** *********
@lamp.cbk
common eme456,	fourth,fifth,sixth

if n_elements(wi) ne 1  then $
if two gt 0 then wi=two else if alone gt 0 then wi=alone else wi=one
if keyword_set(second)  then wi=two
if keyword_set(third)   then wi=three
if keyword_set(eme4)    then wi=fourth
if keyword_set(eme5)    then wi=fifth
if keyword_set(eme6)    then wi=sixth
datp={empty:0}
if wi  gt 0 then if wi  lt n_elements(w_tit) then begin
		 wstr=strtrim(string(wi),2)
		 ii=execute('datp={x:		x' +wstr  + $
		 		 ',y:		y' +wstr  + $
		 		 ',z:		z' +wstr  + $
		 		 ',e:		e' +wstr  + $
		 		 ',n:		n' +wstr  + $
		 		 ',p:		p' +wstr  + $
		 		 ',pv:		pv'+wstr  + $
		 		 ',w_tit:	w_tit(wi)'+ $
		 		 ',x_tit:	x_tit(wi)'+ $
		 		 ',y_tit:	y_tit(wi)'+ $
		 		 ',z_tit:	z_tit(wi)'+ $
		 		 ',other_tit:	other_tit(wi)'  + $
		 		 ',time:	head_tit (wi,4)'+ $
		 		 ',par_txt:	par_txt  (wi,*) }')
endif
return
end

pro   getdatp, datp
    give_datp, datp & return & end
pro give_datp, datp , w=wi ,second=second ,third=third ,fourth=eme4,fifth=eme5,sixth=eme6
;** *********
@lamp.cbk
common eme456,	fourth,fifth,sixth

if n_elements(wi) ne 1  then $
if one gt 0 then wi=one else if alone  gt 0  then wi=alone else wi=two
if keyword_set(second)  then wi=two
if keyword_set(third)   then wi=three
if keyword_set(eme4)    then wi=fourth
if keyword_set(eme5)    then wi=fifth
if keyword_set(eme6)    then wi=sixth
if wi  gt 0 then if wi  lt n_elements(w_tit) then begin
	    		if n_tags(datp) gt 0 then begin
			     wstr=strtrim(string(wi),2)
	    		     tlist=tag_names(datp)
	    		     for k=0,n_elements(tlist)-1 do begin
	    		         CASE tlist(k) of

	    		         'X':	 iii =execute('x' +wstr+'=datp.x' )
	    		         'Y':	 iii =execute('y' +wstr+'=datp.y' )
	    		         'Z':	 iii =execute('z' +wstr+'=datp.z' )
	    		         'E':	 iii =execute('e' +wstr+'=datp.e' )
	    		         'N':	 iii =execute('n' +wstr+'=datp.n' )
	    		         'PV':	 iii =execute('pv'+wstr+'=datp.pv')

	    		         'W_TIT':    w_tit(wi)      =string(datp.w_tit)
	    		         'X_TIT':    x_tit(wi)      =string(datp.x_tit)
	    		         'Y_TIT':    y_tit(wi)      =string(datp.y_tit)
	   			 'Z_TIT':    z_tit(wi)      =string(datp.z_tit)
	   			 'OTHER_TIT':other_tit(wi)  =string(datp.other_tit)
	   			 'TIME' :    head_tit (wi,4)=string(datp.time)

	   			 'P'	  :begin  j=n_elements(datp.p)       < npars
	   			 		  if j eq 1 then $
	   			 		  iii=execute ('p'+wstr+'=datp.p') else $
	   			 		  iii=execute ('p'+wstr+'=datp.p(0:j-1)')
	   			 	   end
	   			 'PAR_TXT':begin  j=n_elements(datp.par_txt) < npars
	   			 		  if j eq 1 then par_txt(wi,0)=datp.par_txt else $
	   			 		  for i=0,j-1 do begin
	   			 		  		 par_txt(wi,i)=datp.par_txt(i)
	   			 		  		 if strpos(par_txt(wi,i),'=') le 0 then $
	   			 		  		 par_txt(wi,i)=par_txt(wi,i)+'='
	   			 		  endfor
	   			 	   end
	   			  ELSE:
	   			  ENDCASE
	    		     endfor
			endif
endif
return
end

pro mod_datp,datp,tag,val
;** ********
sz=size(tag)
if (n_tags(datp) gt 0) and (sz(1) gt 0) and (sz(2) eq 1) and (n_elements(val) gt 0) then begin

	    		     x=0 & y=0 & z=0 & e=0 & n=0 & pv=0 & p=0      & par_txt=''
	    		     w_tit=''  & x_tit=''  & y_tit=''   & z_tit='' & other_tit='' & time=''
	    		     tlist=tag_names(datp)
	    		     for k=0,n_elements(tlist)-1 do begin
	    		         CASE tlist(k) of

	    		         'X':	 x =datp.x
	    		         'Y':	 y =datp.y
	    		         'Z':	 z =datp.z
	    		         'E':	 e =datp.e
	    		         'N':	 n =datp.n
	    		         'PV':	 pv=datp.pv

	    		         'W_TIT':    w_tit    =datp.w_tit
	    		         'X_TIT':    x_tit    =datp.x_tit
	    		         'Y_TIT':    y_tit    =datp.y_tit
	   			 'Z_TIT':    z_tit    =datp.z_tit
	   			 'OTHER_TIT':other_tit=datp.other_tit
	   			 'TIME' :    time     =datp.time

	   			 'P'	  :  p        =datp.p
	   			 'PAR_TXT':  par_txt  =datp.par_txt
	   			  ELSE:
	   			  ENDCASE
	    		     endfor

	    		     iii=execute(tag+'=val')
      			     DATP={X:x,Y:y,Z:z,E:e,N:n,PV:pv,W_TIT:w_tit,X_TIT:x_tit    ,$
      			     	   Y_TIT:y_tit,Z_TIT:z_tit,OTHER_TIT:other_tit,TIME:time,$
      			     	   P:p,PAR_TXT:par_txt}
endif
return
end

pro did_objet,wi,objout
;** *********
@lamp.cbk

objout=0
if (wi ge 1) and (wi le lamp_sys+3) and (sys_dep('VERSION') ge 5.1) then begin
	if strpos(strupcase(par_txt(wi,0)),'OBJECT:') eq 0  then begin
	   ii=execute('P=P'+strtrim(string(wi),2)+'(0)')
	   if (P ge 1) and (fix(P) eq P) then objout=P
endif & endif
end

pro set_suf ,input & RDSET,suffix=input & END
pro set_pref,input & RDSET,prefix=input & END
;** ********

pro RDSET , INST=inst , BASE=base  ,CYCLE=cyclo , TOLERANCE=tol ,STEP=step ,RAW=raw ,DEFAULT=def $
	  , DIR=dir   , NORAW=noraw,DIF=dif , LAST=lst , GOLAST=gol , PREFIX=prefx   ,SUFFIX=sufx
;** *****
;** set INST_VALUE , PATH_FOR_ONLINE , Other dependent parameters for read-in procedures
@lamp.cbk
common c_rdid , dzap, pzap, pzip, pzup
common c_rdid2, zapa, zape, zipi, zupo, zupe
common c_edf  , pref, suf

if keyword_set(inst) then begin
   ins=strlowcase(strtrim(inst,2))
   idx=where  (strlowcase(lamp_ins) eq ins) & idx=idx(0)
   if  idx ge 0 then P_MAC_EVENT  ,0 ,[-88,560,0,b_labins(0),b_labins(1),idx,0,0]
   endif
if keyword_set(base) then begin
   bas=strtrim(base,2)
   idx=where  (strlowcase(lamp_ali) eq strlowcase(bas)) & idx=idx(0)
   if n_elements(cyclo) ne 1 then cyclo=0
   if  idx ge 0 then P_MAC_EVENT  ,0 ,[-88,561,0,b_labins(0),b_labins(1),idx,0,long(cyclo)]
   endif
if keyword_set(raw)	 then begin if b_labins(4) gt 0 then widget_control,bad_id=ii,b_labins(4),set_button=1
				    monimon=-1 & endif
if (keyword_set(noraw) or $
    keyword_set(def))	 then begin if b_labins(4) gt 0 then widget_control,bad_id=ii,b_labins(4),set_button=0
				    monimon= 0 & endif
				    
if n_elements(lst)   eq 1 then  if (size(lst))(1)    eq 7 then if lst  gt ' ' then zapa=lst

if n_elements(gol)   eq 2 then  if  n_elements(zapa) eq 1 then if zapa gt ' ' then begin
				    ii=execute(zapa+',W'+strtrim(string(gol(1)),2)+',gol(0)') & zapa='' & endif

if n_elements(tol)   eq 1 then set_tolerance,tol
if n_elements(step)  eq 1 then pzip=step<10.>0.
if n_elements(dir)   eq 1 then pzup=dir
if n_elements(dif)   eq 1 then dzap=dif
if n_elements(prefx) eq 1 then pref=prefx
if n_elements(sufx)  eq 1 then suf =sufx
end

function rdsum, run1,run2 ,stati,datp=rdp ,W=wii ,COMPLEMENT=complement
;******* *****
;** read run1 sum to run2 from formula entry	!!! W21 is the temp workspace
@lamp.cbk
    wac=lamp_sys+1 &  was=strtrim(string(wac),2) & A_clear, W=wac
    stati=0 & status=-1
    if (n_elements(run1) eq 1) and (n_elements(run2) eq 1) then begin
    	if one le 0 then  one  =19
	if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then one=wii
	wi =one & ws =strtrim(string(wi),2)
	
	if keyword_set(complement) then begin bod=one & bid=two & XICUTE,'w'+was+'=w'+ws & one=bod & two=bid & endif
	
	if abs(run2-run1) ge 10 then begin
		p_did_getrun, run1 ,wi,stati & if stati ne 0 then return,0
		p_did_getrun, run2 ,wi,stati & if stati ne 0 then return,0
	endif
	for i=long(run1),run2 do begin
		p_did_getrun, i ,wi,status
		if status eq 0 then begin
			tt=tolerance
			if monimon lt 0 then W_ACCU, accu=wac , add=wi ,tolerance=tt ,/raw $
					else W_ACCU, accu=wac , add=wi ,tolerance=tt
			toler=tt
		endif else stati=i
		if RDSTOP(run1,run2,(i)) then i=run2+1
	endfor
	iii=execute('x'+ws+'=x'+was)
	iii=execute('n'+ws+'=n'+was)
	iii=execute('e'+ws+'=e'+was)
        other_tit(one)=other_tit(one)+' '+strtrim(string(run1),2)+'>'+strtrim(string(run2),2)
	if status eq 0 then RDSET,golast=[wi,wac]
   endif
if n_elements(rdp) gt 0 then begin tmp=two & two=one & take_datp,rdp & two=tmp & endif
tmp=0 & ii=execute('tmp=w'+was)
return,tmp
end

function rdrun, run ,stati,datp=rdp ,W=wii
;******* *****
;** read a run from formula entry
@lamp.cbk

   wtm=0L & run2=0
   if n_elements(stati) eq 1 then if stati gt run then begin
      run2=stati
      wtm =rdsum(run,run2,W=wii)
   endif

   if run2 eq 0 then begin
    stati=0
    if n_elements(run) eq 1 then begin
        if one le 0 then  one  =19
	if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then one=wii
	wi =one & ws =strtrim(string(wi),2)
	p_did_getrun, run,wi,status
	if status eq 0 then RDSET,golast=[wi,wi]
	if status eq 0 then iii=execute('wtm=w'+ws) else stati=run
    endif
   endif
if n_elements(rdp) gt 0 then begin tmp=two & two=one & take_datp,rdp & two=tmp & endif
return,wtm
end

function rdand, run1,run2 ,stati ,datp=rdp ,accu=accu ,flip=flip ,mon=monoto ,FRAME=rrun ,W=wii ,COMPLEMENT=complement
;******* *****
;** read run1 and to run2 from formula entry	!!! W21 is the temp workspace
@lamp.cbk
common keep_rd, sz,sn,tkx,tkz

   cool=1
   if (n_elements(w21) gt 1) and (lamp_sys gt 21) then begin cool=0 & was=strtrim(string(lamp_sys+1),2) & bod=one & bid=two & XICUTE,'w'+was+'=w21' & one=bod & two=bid & endif
;  Ken"s crack
   IF (inst_group EQ 'ISIS') THEN BEGIN
	ii=EXECUTE('w21=rdand_isis(run1,run2,flip=flip)')
	if ii eq 1 then begin tmp=w21 & if cool then w21=0 else begin bod=one & bid=two & XICUTE,'w21=w'+was & one=bod & two=bid & endelse
			      RETURN, tmp ;if rdand_isis not here then continue...
	ENDIF
   ENDIF
   w21=0 & x21=0 & n21=0 & e21=0 & stati=0
   if (n_elements(run1) eq 1) and (n_elements(run2) eq 1) then $
   if  run2 ge run1 then begin
        if one le 0 then  one  =19
	if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then one=wii
	wi =one & ws =strtrim(string(wi),2)
	status=0
	if n_elements(rrun)   eq 0 then rrun   =0
	if n_elements(monoto) ne 1 then monoto =monimon
	if not keyword_set(flip)   then flip   =1
	if     keyword_set(accu)   then begin J=0
			 bod=one & bid=two & XICUTE,'w21=w'+ws & one=bod & two=bid & sz21=size(w21)
			 mon= fltarr(sz21(sz21(0)))+n21(0)
	endif else begin J=flip
			 if rrun(0) then begin ruun=rrun(0) & nimg=run1 & endif else ruun=run1
			 if n_elements(rrun) eq 2 then $
				nimg=strtrim(string(rrun(1)),2)+'.'+strtrim(string(nimg),2)
			 p_did_getrun, ruun ,21,status, FRAME=nimg
			 sz =(size(w21))(0)     & sn =(size(n21))(0)  & tkx=0
			 if sz eq 1 then if n_elements(x21) eq n_elements(w21) then tkx=1
			 pv21=p21 & z21=z21(*,0)
			 if n_elements (z21) eq 1 then tkz=1 else tkz=0
			 mon= total  (n21(*,0))
			 if   keyword_set(complement)  then begin J=0
			      MOVEPAR, (wi),ws, 21,'21' & ii=execute('W21=W'+ws)
			      sz21=size(w21)
			      if sz lt sz21(0) then mon=fltarr(sz21(sz21(0))) else mon=0.
			      mon=mon+total(n21(*,0))
			      endif
	endelse

	if status eq 0 then $
	if run2-run1 ge 10 then begin
	   if J      eq 0  then p_did_getrun, (run1) ,wi,status
	   if status eq 0  then p_did_getrun, (run2) ,wi,status
	endif
	stati=status
		
	if status eq 0 then $
	for i=long(run1)+J,run2,flip do begin
		if rrun(0) then begin ruun=rrun(0) & nimg=i & endif else ruun=i
		if n_elements(rrun) eq 2 then $
				nimg=strtrim(string(rrun(1)),2)+'.'+strtrim(string(nimg),2)
		p_did_getrun, ruun ,wi,status, FRAME=nimg
		if status eq 0 then begin
			if sz  lt 1 then iii=execute('w21=[  w21  ,  w'+ws+'  ]')    else $
			if sz  eq 1 then iii=execute('w21=[ [w21] , [w'+ws+'] ]')    else $
			if sz  ge 2 then iii=execute('w21=[[[w21]],[[w'+ws+']]]')
			if sz  lt 1 then iii=execute('x21=[  x21  ,  x'+ws+'  ]')    else $
			if tkx eq 1 then iii=execute('x21=[ [x21] , [x'+ws+'] ]')
			if sz  eq 1 then iii=execute('y21=[  y21  ,  y'+ws+'  ]')
			if sz  eq 1 then       if n_elements(e21) gt 1 then $
			                 iii=execute('e21=[ [e21] , [e'+ws+'] ]')
			if sn  lt 2 then iii=execute('n21=[ [n21] , [n'+ws+'] ]')    else $
					 iii=execute('n21=[[[n21]],[[n'+ws+']]]')
			if tkz eq 1 then iii=execute('z21 =[ z21  ,  z'+ws+'(*,0)]') else $
					 iii=execute('z21=[ [z21] , [z'+ws+'(*,0)]]')
			iii=execute('mon =[  mon   , total(n'+ws+'(*,0)) ]')
			iii=execute('pv21=[ [pv21] , [p'+ws+'     ] ]')
		endif
		if RDSTOP(run1+J,run2,(i)) then i=run2+1
	endfor
	if monoto ge 0 then RDMONI,0, W21,E21,N21,mon>1,monoto

	iii=execute('n' +ws+'= n21')
	iii=execute('z' +ws+'= z21')
	iii=execute('e' +ws+'= e21')
	iii=execute('pv'+ws+'=pv21')
	if sz  lt  1 then if x21(0) ne x21(n_elements(x21)-1) then iii=execute('x'+ws+'=x21')
	if sz  eq  1 then if y21(0) ne y21(n_elements(y21)-1) then iii=execute('y'+ws+'=y21')
	if tkx eq  1 then begin sid=size (x21) & mid=sid(sid(0))
				if sid(0) eq 2 then if sid(2) eq (size(w21))(2) then begin
				   zid=total(x21( *,mid-1) - x21(*,0))
				   if zid ne 0 then begin          iii=execute('x'+ws+'=x21')
							    	   y21=transpose([[y21],[y21]])
							    	   y21=congrid  (  y21 ,sid(1),mid)
								   iii=execute('y'+ws+'=y21')
				endif & endif
	endif
	if sz lt  1 then if x_tit(wi) eq '' then x_tit(wi)='Run number'
	if sz eq  1 then if y_tit(wi) eq '' then y_tit(wi)='Run number'
	if sz eq  2 then if z_tit(wi) eq '' then z_tit(wi)='Run number'
	if (n_elements(accu) eq 0) and (status eq 0) then   RDSET,golast=[wi,21]
   endif

if n_elements(rdp) gt 0 then begin bid=two & two=one & take_datp,rdp & two=bid & endif
tmp=w21 & if cool then w21=0 else begin bod=one & bid=two & XICUTE,'w21=w'+was & one=bod & two=bid & endelse
return,tmp
end

function rdopr, text,stati,datp=rdp,W=wii
;******* *****
;**
@lamp.cbk

if one le 0 then  ones =19 else ones=one
if n_elements(wii) eq 1 then if (wii ge 1) and (wii le lamp_sys) then ones=wii
txt=text
rdmulti, txt,stati,0,ones
wt =0L
if stati   eq 0 then ii=execute('wt=w'+strtrim(string(ones),2)  )

if n_elements(rdp) gt 0 then begin tmp=two & two=one & take_datp,rdp & two=tmp & endif
return,wt
end

pro rdmulti, txt,status,labid,wi,monoto
;** *******
;**
;	!!! W21 or W22 or W23 is the temp workspace
@lamp.cbk

run_comd,txt,tbl,tbf
status=12
if txt ne '' then begin
	if n_elements(wi)     eq 0 then wi=one
	if n_elements(labid)  eq 0 then labid=0
	if n_elements(monoto) eq 0 then monoto=monimon
	nn=size(tbl)
	if nn(0) lt 2 then nn=1 else nn=nn(2)

        ws=strtrim(string(wi),2)
	ii=execute( 'w'+ws+'=0' )
	status=0
	lo =0
    	wac=lamp_sys+1 & if wi eq wac  then wac=wac+1
	was=strtrim(string(wac),2) & A_clear, W=wac

    	accu=',accu=ac,flip=op)' & ac=0
	mltr=(nn gt 1) or (tbl(0,0) gt 0)
	while  (status eq 0) and lo lt nn do begin
        	if (tbl(1,lo) ne 0) and (tbl(2,lo) ne 0) then begin
		    ru0 =tbl(0,lo)
        	    ru1 =tbl(1,lo)
		    rrun=tbl(3,lo) & if (rrun eq 0) and (tbf gt ' ') then rrun=tbf
		    
        	    if ru0 eq 0 then ru0=ru1 else if ru0 gt ru1 then ru1=ru0
        	    if tbl(2,lo) ge 1 then opr='+'  else  begin opr='-'
			if ru1 gt ru0 then begin		opr='-+'
				wau=lamp_sys+3 & wat=strtrim(string(wau),2)
				A_clear, W=wau & endif & endelse
		    run =ru0
		    if (ru1-ru0 ge 10) and (abs(tbl(2,lo)) lt 2) then begin
			p_did_getrun, (ru0) ,wi,status & if status ne 0 then return
			p_did_getrun, (ru1) ,wi,status & if status ne 0 then return
		    endif
        	    while  (status eq 0) and (run le ru1) do begin
	   	        op=abs(tbl(2,lo))
	   	        if op ge 2 then begin
	   	        	if labid gt 0 then $
	   	                widget_control,bad_id=i,labid,set_value='Reading '+string(ru0)+' to '+string(ru1)
	  			one=wi
				op =op-1
				nimg=rrun
				if tbl(4,lo) gt 0 then nimg=[string(rrun),string(tbl(4,lo))]

	   	        	ii =execute('w'+ws+'=RDAND(ru0,ru1,status ,mon=monoto,FRAME=nimg'+accu)
	   	        	run=ru1
				ac=1
	   	        endif else begin
	   	        	if labid gt 0 then $
	   	                widget_control,bad_id=i,labid,set_value='Reading '+string(run)+' ...'
				nimg=0
				if rrun then begin ruun=rrun & nimg=run & endif else ruun=run
						if tbl(4,lo) gt 0 then begin
						   nimg=strtrim(string(tbl(4,lo)),2)+'.'+strtrim(string(nimg),2)
						endif

	   	        	P_DID_GETRUN, ruun ,wi, status, FRAME=nimg

        	        	if  mltr then begin
				    tt=tolerance
				    if status ne 0 then status=0    else $
        	        	    if   opr eq '-'  then W_ACCU, accu=wac ,sub=wi  else begin
				    if monoto(0) lt 0 then $
				      if opr eq '-+' then W_ACCU, accu=wau ,add=wi ,tolerance=tt,/raw else $
        	        	      if opr eq '+'  then W_ACCU, accu=wac ,add=wi ,tolerance=tt,/raw
				    if monoto(0) ge 0 then $
				      if opr eq '-+' then W_ACCU, accu=wau ,add=wi ,tolerance=tt      else $
        	        	      if opr eq '+'  then W_ACCU, accu=wac ,add=wi ,tolerance=tt
				    endelse
				    toler=tt
        	        	endif
				if RDSTOP(ru0,ru1,(run)) then run=ru1+1
	   	        endelse
			if status eq 0 then run=run+1
        	    endwhile
		    if 	opr eq '-+'  then W_ACCU, accu=wac ,sub=wau
		    if  abs(tbl(2,lo)) lt 2 then  $
			if monoto(0) gt 0 then begin moni=monoto
;			   if monoto(0) eq 0 then moni=-(ru1-ru0+1) ;(IF /RAW !!!)
			   if mltr then ii=execute('RDMONI,1,W'+was+',E'+was+',N'+was+',N'+was+'(*,0)>1,moni') $
				   else ii=execute('RDMONI,1,W'+ws +',E'+ws +',N'+ws +',N'+ws +'(*,0)>1,moni')
			endif
        	endif
        	lo=lo+1
	endwhile
	if status ne 0  then begin ii=execute( 'w'+ws+'=0' )
			outext='% Restore '+string(run)+' failed ...'
	endif else begin
        	        if (nn gt 1) or ((tbl(0,0) gt 0) and (abs(tbl(2,0)) eq 1)) then $
			if (abs(tbl(2,0)) ne 2) then begin
        	           ii=execute( 'W'+ws+'=w'+was )
        	           ii=execute( 'X'+ws+'=x'+was )
        	           ii=execute( 'N'+ws+'=n'+was )
        	           ii=execute( 'E'+ws+'=e'+was )
			   if monimon   ge 0 then $
			   ii=execute( 'E'+ws+'=e'+was ) else ii=execute( 'E'+ws+'=0')
        	        endif
        	        other_tit(wi)=other_tit(wi)+' '+txt
			outext='Data restored in W'+ws
			RDSET,golast=[wi,wi]
	endelse
	if labid gt 0 then if wi le lamp_sys then widget_control,bad_id=i,labid,set_value=outext
endif
return
end

pro RDMONI,HZ, W21,E21,N21,moni,mol
;** ******
;** HZ=0 comes  from RDAND   (one count by spectra or frame)
;** HZ=1 comes  from RDMULTI (X monitor)
;** moni is the current monitor while mol is the new monitor.
	mon=moni
	if mol eq 0 then mol=round(total(mon)/n_elements(mon))*1.
	if mol lt 0 then mol=round(total(mon)/n_elements(mon))*1./(-mol)
	if (mon(0) ne mol(0)) or (mon(n_elements(mon)-1) ne mol(0)) then begin
	   if HZ then n21(*,0)=mol else n21=mol
	   mon=mol/mon & sz21=size(w21)
	   if  n_elements(w21) eq n_elements(E21)  then ero=1 else ero=0
	   if (n_elements(mon) ne sz21(1)) and HZ  then mon=mon(0)

	   if  sz21(0) le 1 then  begin	if ero then E21=E21*mon  else $
					if HZ  then E21=sqrt(w21)*mon & w21=w21*mon & endif

	   if  sz21(0) eq 2 then  begin	for i=0,sz21(2)-1 do if HZ then w21(0,i)  =(w21(*,i)  )*mon $
								   else w21(0,i)  =(w21(*,i)  )*mon(i)
			    if ero then for i=0,sz21(2)-1 do if HZ then E21(0,i)  =(E21(*,i)  )*mon $
								   else E21(0,i)  =(E21(*,i)  )*mon(i) & endif
	   if  sz21(0) eq 3 then  begin	for i=0,sz21(3)-1 do if HZ then w21(0,0,i)=(w21(*,*,i))*mon $
								   else w21(0,0,i)=(w21(*,*,i))*mon(i)
			    if ero then for i=0,sz21(3)-1 do if HZ then E21(0,0,i)=(E21(*,*,i))*mon $
								   else E21(0,0,i)=(E21(*,*,i))*mon(i) & endif
	endif
end

pro run_comd, text,tbl,tbf
;** ********
;**
;** Command analysis

text=text+"&"
ttt =[0L,0L,0L,0L,0L]
tbf =''
tbl =ttt & tbl(2)=1 & j =1 & run=''
on_ioerror,mis     & ok=0 & fil=0
for i=0,strlen(text)-1 do begin

    c =  strmid(text,i,1)
    case 1 of
    (c eq ' ') or (c eq '(') or (c eq ')'):
    (c eq '{') or (c eq '['):begin
			     if run ne ''  then  begin fil=0 & on_ioerror,misfil
			     	a=strmid(run,0,1)
				if (a ge '0') and (a le '9') then fil=long(run)
			     	misfil: if fil eq 0 then tbf=run
			        on_ioerror,mis & endif
			     run=''  & end 
    (c eq '}') or (c eq ']') or (c eq '&'):begin
    			     if run ne ''  then tbl(1  ,j-1)=long(run)
    			     if run ne ''  then tbl(3  ,j-1)=fil
    			     run='' & fil=0 & end
    (c eq '-') or (c eq '+') or (c eq ',') or (c eq ';'):begin
    			     if run ne ''  then tbl(1  ,j-1)=long(run)
    			     if run ne ''  then tbl(3  ,j-1)=fil
    			     run=''
    			     tbl=[[tbl],[ttt]]
    			     if (c eq '-') then tbl(2  ,j)=-1   else tbl(2,j)=1
    			     j  =j+1 & end
    (c eq '<') or (c eq '>') or (c eq ':'):begin
    			     if run ne ''  then tbl(0  ,j-1)=long(run)
    			     if run ne ''  then tbl(3  ,j-1)=fil
    			     if  c  eq ':' then tbl(2  ,j-1)=abs(tbl(2,j-1))+1
    			     run=''  & end
    (c eq '.'):              begin
			     if (fil eq 0) and (tbf eq '') then run=run+c $
			     else begin
    			     if run ne ''  then tbl(4  ,j-1)=long(run) & run=''
			     endelse
			     end
    else:		     run=run + c
    endcase
    endfor
nn=size(tbl)
if nn(0)    lt 2 then nn=1  else nn=nn(2)
if tbl(1,0) eq 0 then if nn gt 1 then begin tbl=tbl(*,1:*) & nn=nn-1 & endif
ok=1
mis:text=''
bo=0
if  ok eq 1 then $
for i=0,nn-1  do $
    if (tbl(1,i) ne 0) and (tbl(2,i) ne 0)  then begin
	if tbl(3,i) ne fil then  if bo eq 1 then text=text+'}'
    	if tbl(2,i) eq  1  then  if i  gt 0 then text=text+'+'
	if tbl(2,i) ge  2  then  if i  gt 0 then text=text+','
    	if tbl(2,i) le -1  then                  text=text+'-'
	if tbl(3,i) ne fil then  begin fil= tbl(3,i) & bo=0
	     if fil gt  0  then  begin bo = 1  & text=text+strtrim(string(fil),2)+'{' & endif
	endif
    	if tbl(0,i) ne  0  then  $
    	if tbl(4,i) eq  0  then text=text+strtrim(string(tbl(0,i)),2) $
    	else text=text+strtrim(string(tbl(4,i)),2)+'.'+strtrim(string(tbl(0,i)),2)
    	
	op=abs(tbl(2,i))
    	if tbl(0,i) ne  0  then  if op eq 1 then text=text+'>' $
					    else text=text+string(replicate(58b,op-1))
					    
    	if tbl(4,i) eq  0  then text=text+strtrim(string(tbl(1,i)),2) $
    	else text=text+strtrim(string(tbl(4,i)),2)+'.'+strtrim(string(tbl(1,i)),2)
    endif
if  bo eq 1  then text=text+'}'
if (tbf gt '') and (strpos(text,'{') lt 0) then text=tbf+'{'+text+'}'
return
end

pro set_tolerance,tt ,get=get ,tol=tol
;** *************
;**
@lamp.cbk
    if keyword_set(get) then   tt=tolerance else $
    if keyword_set(tol) then   toler=tol    else $
    if n_elements (tt)  eq 1 then tolerance=tt
end

pro W_ACCU, accu=wi , add=wj , sub=wk , combine=wl , tolerance=tt , ero=ero ,raw=raw
;** ******
;**
;** Operation on accumulator wi (add or subtract or combine)

@lamp.cbk

;CHECK FOR CONSISTENCIES
;***** *** *************
if n_elements(wi) eq 1 then if (wi ge 1) and (wi le lamp_sys+3) then begin

   wis= strtrim(string(wi),2)	& wiw='w'+wis & wix='x'+wis & win='n'+wis & wie='e'+wis

   wjn= n_elements(wj)		& wkn=n_elements(wk)	    & wln=n_elements(wl)

   if wjn+wkn+wln eq 1 then begin

      if wkn eq 1 then begin opr='-' & wj=wk & endif else $
      if wln eq 1 then begin opr='c' & wj=wl & endif else opr='+'
      if keyword_set(raw)  then rw=1 else rw=0

      if (wj ge 1) and (wj le lamp_sys+3) then begin

   	wjs= strtrim(string(wj),2)	& wjw='w'+wjs & wjx='x'+wjs & wjn='n'+wjs & wje='e'+wjs

   	swi=0L & ii=execute( 'swi=size('+wiw+')' ) & swj=0L & ii=execute( 'swj=size('+wjw+')' )
   	sxi=0L & ii=execute( 'sxi=size('+wix+')' ) & sxj=0L & ii=execute( 'sxj=size('+wjx+')' )
   	sni=0L & ii=execute( 'sni=size('+win+')' ) & snj=0L & ii=execute( 'snj=size('+wjn+')' )
   	sei=0L & ii=execute( 'sei=size('+wie+')' ) & sej=0L & ii=execute( 'sej=size('+wje+')' )

	if swi(swi(0)+2)  gt 1 then begin

;	DEFINE PARAMETERS IF NECESSARY (X,N,E).
;	****** ********** ** ********* *******
;I-x						ii=execute( wix+'=float('+wix+')')
	if swi(0) 	 gt 0 		  then  $
	   if  swi(1)    ne sxi(1)	  then  ii=execute( wix+'=findgen(swi(1))+1' )
;I-e
	ero=1 & oro=0
   	if sei(sei(0)+2) ne swi(swi(0)+2) then  if swi(0) eq 1 then $
   						ii=execute( wie+'=sqrt('+wiw+')' ) else ero=0 else oro=1 ;Errors where present
;I-n
	if (sni(0) gt 1) and (sni(1) ne swi(1)) then iro=0 else iro=1
	if iro eq 1 then begin
  	if sni(1)	 ne   swi(1)	  then  ii=execute( win+'=fltarr(swi(1))+'+win+'(0)>1' ) else $
        if sni(0)	 gt 1		  then  $
	   if  swi(0)    eq 1		  then  ii=execute( win+'=fltarr(swi(1))+total('+win+'(*,0))>1' )
	endif
   	ii=execute( 'sxi=size('+wix+')' )
	ii=execute( 'sni=size('+win+')' )
	ii=execute( 'sei=size('+wie+')' )
;J-x
	if swj(0) 	 gt 0 		  then  $
	   if  swj(1)    ne sxj(1)	  then  ii=execute( wjx+'=findgen(swj(1))+1' )
;J-e
	if ero eq 1 then begin
	   if swj(0) eq 1 then wjee=1  &  ii=execute('wjee='+wje)
   	   if sej(sej(0)+2) ne swj(swj(0)+2) then  if swj(0) eq 1 then $
   						   ii=execute( 'wjee=sqrt('+wjw+')' ) else ero=0
        endif
;J-n
	wjnn=1    &   ii=execute('wjnn=' +wjn)
	if iro eq 1 then begin
   	if snj(snj(0)+2) ne swj(swj(0)+2) then  $
   	   if  snj(1)    ne     swj(1)    then  ii=execute( 'wjnn=fltarr(swj(1))+'+wjn+'(0)>1' ) else $
           if  snj(0)	 gt 1		  then  $
	     if  swj(0)  eq 1		  then  ii=execute( 'wjnn=fltarr(swj(1))+total('+wjn+'(*,0))>1' )
	endif
   	ii=execute( 'sxj=size('+wjx+')' )
	ii=execute( 'snj=size('+wjn+')' )
	ii=execute( 'sej=size('+wje+')' )

;	DEFINE A TOLERANCE IF NOT
;	****** * ********* ** ***
   	if n_elements(tt) ne 1 then tt=0
	if tt le 0 then begin
		k1=1L & ii=execute( 'k1=n_elements('+wix+')-1' )
		k2=1L & ii=execute( 'k2=n_elements('+wjx+')-1' )
		ii=execute( 'k1=float(abs('+wix+'(k1-1)-'+wix+'(0)))/k1' )
   		ii=execute( 'k2=float(abs('+wjx+'(k2-1)-'+wjx+'(0)))/k2' )
		tt=min([k1,k2])/3
	endif

;	   MATRIX OPERATION
;	   ****** *********
	   if (swj(0) gt 1) or (not iro)  then begin
	   		if opr eq 'c' then opr='+'
	   		if opr eq '+' then begin
			  tst=1 & iii=execute('tst=('+wix+'(0) eq '+wjx+'(0)) and ('+wix+'(swi(1)-1) eq '+wjx+'(swj(1)-1))')
			  if (sxj(0) ne 1) or (tst) or (swj(2) ne swi(2)) or (not iro) then begin
			   iii=execute( wiw+'=float(' +wjw +')' +opr+wiw )
			   iii=execute( win+'=float(   wjnn  )' +opr+win )
			   iii=execute( wie+'=sqrt(float(' +wje+')^2'+opr+wie+'^2)' )
			   if (iro) and (tst) and (not rw) then begin m1=1.  & iii=execute('m1=total('+win+'(*,0))')
			        if m1 le 1 then iii=execute( win+'=0') ;$
				;else      begin iii=execute( wiw+'='+wiw+'/2') & iii=execute( win+'(*,0)='+win+'(*,0)/2')
				;		 iii=execute( wie+'='+wie+'/2') & endelse
			   endif

			  endif else begin
			   if ero eq 0 then begin tmerr=fltarr(swj(1))+1 & myerr='tmerr'
						  tme  =fltarr(swi(1))+1 & endif
			   if oro eq 1 then rw=0 ;Force physique calculation of accu
			   tmw=0 & tmx=0 & tmn=0 & rsw=0 & rse=0
			   for  i=0,swj(2)-1 do begin
				iii=execute('tmw=' +wiw+'(*,i)')  &  iii=execute('tmx=' +wix)
				iii=execute('tmn=' +win)
				if ero eq 1 then iii=execute('tme=' +wie+'(*,i)')
				if ero eq 1 then myerr=wje+'(*,i)'

	   			iii=execute( 'V_ACCU,opr,   tmw       ,  tmx  ,  tmn       ,  tme    ,'   $
	   						   +wjw+'(*,i),'+wjx+',  wjnn(*,0) ,'+myerr+', tt ,raw=rw')
				if i eq 0 then begin rsw=fltarr(n_elements(tmw),swj(2))
				                     if ero eq 1 then rse=rsw & endif
				rsw(*,i)=tmw
				if ero eq 1 then rse(*,i)=tme
			   endfor
			   iii=execute(wiw+'=rsw') & iii=execute(wix+'=tmx')
			   iii=execute(win+'=tmn') & iii=execute(wie+'=rse')
			  endelse

			endif
	   		if opr eq '-' then begin na=1. & ni =1.
	   		   iii=execute('na   =total(' +win +'(*,0))>1')
					ni   =total(     wjnn(*,0))>1
	   		   m  =na/ni
			   iii=execute( wiw+'='+wiw+opr+wjw+'*m' )
			   if ero eq 1 then iii=execute(wie+'=sqrt('+wie+'^2+'+wje+'^2*m)')
			endif

;	   VECTOR OPERATION
;	   ****** *********
	   endif else begin
			if oro eq 1 then rw=0  ;Force physique calculation of accu
	   		iii=execute( 'V_ACCU,opr,' +wiw+','+wix+','+win+'      ,'+wie+','   $
	   					   +wjw+','+wjx+',  wjnn(*,0)  ,  wjee , tt ,raw=rw')
	   endelse

	endif else begin oon=one & too=two & tee=three & alo=alone & ifi=ifixed & don_me_lastf, lfoo ,0
			 ifixed=0
			 XICUTE,wiw+'=float('+wjw+')'
			 one=oon & two=too & three=tee & alone=alo & ifixed=ifi & don_me_lastf, lfoo ,1
	endelse
      endif
   endif else begin
      bid=two & XICUTE,wiw+'=0' & two=bid & one=0
   endelse
endif
return
end

pro V_ACCU, ops ,wa,xa,na,ea, wi,xi,ni,ei , tt ,raw=raw
;** ******
;**
    if  ops eq 'c' then opr='-' else opr=ops

;   ADDITION : Accumulator  --> wa, xa, na, ea = counts, abcissa, monitors, errors
;   -------- : New spectrum --> wi, xi, ni, ei   tolerance is tt.

    if  opr eq '+' then begin
;	JOIN ACCU AND SPECTRUM
;	---- ---- --- --------
	if keyword_set(raw)  then rw=1 else rw=0
	xa =[xa,xi]	  & sa=n_elements(wa) & si=n_elements(wi)
	idx=sort(xa)	     & xa=xa(idx)
	wa =float([wa,wi])      & wa=wa(idx)
	na =double([na(*,0),ni]>1) & na=na(idx)
	ea =[ea,ei]    & ea=ea(idx)   & nn=n_elements(xa)
	if not rw then begin m1 =total (na)/nn & wa=wa/na*m1 & ea=sqrt(ea^2/na*m1) & na(*)=m1
	                     phy= 1   & endif ;Physique or not physique ????
	k  = 0

	for  i=1,nn-1 do begin

	     if (xa(i)-xa(k))  le tt  then begin
;	     MERGE TWO POINTS
;	     ----- --- ------
		 wp =wa(i) & ep=ea(i)

;		 INTERPOLATE IF POSSIBLE.
;		 ----------- -- --------
;		 if (xa(i) ne xa(k)) and (not rw) then begin ip=idx(i)-sa-1 ;index in xi if ip>0
;
;		  if ip    ge  0     then begin   if (xa(k) gt xi(ip)) then begin	   ;i is  new
;						  fac  =(xa(i)-xa(k))  /(xa(i)-xi(ip))
;						  fac  = fac<.5 & fac1=1.-fac
;						  wp   =(fac1)*wa(i)+ fac*wi(ip)/(ni(ip)>1)
;						  ep   =sqrt((fac1)*ea(i)^2+ fac*ei(ip)^2)
;					  	  endif
;		  endif else begin ip=idx(k)-sa
;
;		   if (ip ge 0) and (ip lt si-1)  then begin ip=ip+1			   ;k was new
;						  if (xi(ip) gt xa(i)) then begin
;						  fac  =(xa(i)-xa(k))  /(xi(ip)-xa(k))
;						  fac  = fac<.5 & fac1=1.-fac
;						  wa(k)=(fac1)*wa(k)+ fac*wi(ip)/(ni(ip)>1)
;						  ea(k)=sqrt((fac1)*ea(k)^2+ fac*ei(ip)^2)
;						  xa(k)= xa(i)
;						  endif
;		 endif & endelse & endif

		 idx(k)=0
		 if rw  then begin wa(k)= wa(k)+wp & na(k)=na(k)+na(i) & ea(k)=sqrt(ea(k)^2+ep^2)   ; raw addition !!

		 endif else if phy eq 0 then begin
	     	    na(k)= na(k)*2.
	     	    wa(k)= wa(k)+wp			; w = (wa+wi)
	     	    ea(k)= sqrt((ea(k)^2 + ep^2)/2.)	; e = sqrt((ea^2 + ei^2)/2)
		    
		 endif else if ep gt 0 then begin
		   if ea(k) le 0 then begin wa(k)=wp & ea(k)=ep
		   endif else begin
		    eak  =1./ea(k)^2 &  epk=1./ep^2 & apk=eak+epk & wap=wa(k)+wp & wfp4=wa(k)*wp*4 ;variables
		    wa(k)=(wa(k)*eak+wp*epk)  /apk	     ; w = ( wa/ea^2 + wi/ei^2 ) / ( 1/ea^2 + 1/ei^2)
		    ea(k)=1./sqrt(apk)		             ; e = 1/sqrt(1/ea^2 + 1/ei^2)
		    
		    wa(k)=wa(k) *  wap^2/wfp4               ; correct to keep same background * (wa+wi)^2/(wa*wi*4)
		    ea(k)=ea(k) *  wap  /sqrt(wfp4)         ; correct to keep same background * (wa+wi)  /sqrt(wa*wi*4)
		   endelse
		 endif
	     endif else begin
;	     OR MAKE A NEW POINT.
;	     -- ---- - --- -----
	      	 k= k+1
	      	 if k ne i then begin
	            xa(k)= xa(i) & idx(k)=idx(i)
	            wa(k)= wa(i) & ea (k)= ea(i)
		    if rw  then    na (k)= na(i)
	       	 endif
	     endelse
	endfor
	if k lt nn-1 then begin
	   xa= xa(0:k)  & wa=wa(0:k)
	   na= na(0:k)  & ea=ea(0:k)
	   if not rw then if phy eq 0 then begin wa= wa*m1/na & ea= sqrt(ea^2*m1/na) & na(*)=m1 & endif
	endif
    endif

;   SUBTRACTION
;   -----------
    if  opr eq '-' then begin
;	SORT
;	----
	idx=sort(xa)  & xa=xa(idx) & wa=wa(idx) & na=na(idx) & ea=ea(idx)
	idx=sort(xi)  & xi=xi(idx) & wi=wi(idx) & ni=ni(idx) & ei=ei(idx)

;	INTERPOLATE MISSING ABSCISSA
;	----------- ------- --------
	if ops ne 'c' then begin

	 m1 =total(na)/ n_elements(wa)
	 wa =float(temporary(wa))/(na>1)*m1
	 wp =float(wi)/(ni>1)*m1   & si=n_elements(wp)

	 yy =INTERPOL(wp, xi,xa)   & ea=ea/(na>1)* m1
	 yer=INTERPOL(ei/(ni>1)*m1 , xi,xa)

	 id1=where(xa lt xi(0))			& i1=n_elements(id1)
	 id2=where(xa gt xi(n_elements(xi)-1))	& i2=n_elements(id2)

	 nn =10<(si/3) & nn=nn>1
	 if i1 gt 1 then begin	ab =LADFIT(xi(0:nn),wp(0:nn))
				yy (id1)=ab(0)+ ab(1)*xa(id1)
				yer(id1)=max(abs(yy(id1)))/2    & endif
	 if i2 gt 1 then begin	ab =LADFIT(xi(si-nn-1:*),wp(si-nn-1:*))
				yy (id2)=ab(0)+ ab(1)*xa(id2)
				yer(id2)=max(abs(yy(id2)))/2    & endif

;	 NORMALIZE
;	 ---------
	 wa   = (wa-yy)
	 na(*)=  m1
	 ea   =  sqrt((ea^2 + yer^2))

;   COMBINE
;   -------
	endif else begin
	 id1=where(xa ge xi(0))			& id1=id1(0)>0<(n_elements(xa)-1)
	 id2=where(xa ge xi(n_elements(xi)-1))  & id2=id2(n_elements(id2)-1)>0<(n_elements(xa)-1)
	 m  =float(na(id1:id2))/(ni>1) & m1=m>1
	 yy =INTERPOL(wi*m1,xi,xa(id1:id2))
	 wa(id1:id2)=(wa(id1:id2)-yy)>0
	endelse
    endif
return
end

;************************************ JOURNAL *************************************
;************************************ JOURNAL *************************************
;************************************ JOURNAL *************************************

pro p_did_journal, event,uv
;** *************
;**
@lamp.cbk
    i=xregistered('JOURNAL')
    if i gt 0 then widget_control,bad_id=i,uv(2),/destroy

    base=widget_base  (title='Lamp Journal',/column,resource_name='lamptouch')
    tit =widget_label (base,value='JOURNAL OF CURRENT SESSION (lamp.jou)',font=ft_biggest)
    basc=widget_text  (base,value=jou_c+'            '+jou_w,font=ft_b_normal,xsize=80,ysize=20,/scroll)
    brow=widget_base  (base,/row,SPACE=30)
    prin=widget_button(brow,value='PRINT' ,uvalue=[-88,395,base,1,basc])
    cler=widget_button(brow,value='CLEAR' ,uvalue=[-88,395,base,2,basc])
    updt=widget_button(brow,value='UPDATE',uvalue=[-88,395,base,3,basc])
    done=widget_button(brow,value='CLOSE' ,uvalue=[-88,399])
	 put_logo     ,brow

    uv(2)=base
    widget_control,event.id   ,bad_id=i,set_uvalue=uv
    widget_control,lamp_don(0),bad_id=i,set_uvalue=basc

    bid=sys_dep      ('DYNLAB',base,0)
    widget_control,base,group_leader=lamp_b1,/realize & put_logo
    widget_control,basc,SET_TEXT_TOP_LINE=(n_elements(jou_c)-18)>0
    XMANAGER, 'JOURNAL' ,base,event_handler='LAMP_EVENT_PARSER',/just_reg
return
end

pro p_did_journal_print, uv
;** *******************
;**
@lamp.cbk

if uv(3) eq 1 then begin
    text=[''] & widget_control,bad_id=ii,uv(4),get_value=text
    ON_IOERROR,misopn
    OPENW ,out,'journal.print',/GET_LUN
    	ON_IOERROR,miswrt
    	for i=0,n_elements(text)-1 do PRINTF,out,text(i)
    	miswrt:FREE_LUN,out
	dir=''
	;cd,current=dir
	;if strmid(dir,strlen(dir)-1,1) ne lamp_dvd then dir=dir+lamp_dvd
	bid=sys_dep      ('PRT_DEF',dir+'journal.print')
    misopn:
endif
if uv(3) eq 2 then begin
    DID_WRITE_JOURNAL, /clear
    widget_control,bad_id=ii,uv(2),/destroy
endif
if uv(3) eq 3 then begin
    DID_WRITE_JOURNAL
endif
return
end

pro DID_WRITE_JOURNAL, jou ,htm=htm ,clear=clear ,check=check
;** *****************
;**
@lamp.cbk
common c_kpjou, kpjou
	out=-1
	on_ioerror, end_wr
	if n_elements(jou) gt 0 then begin
		if n_elements(kpjou) eq 0 then kpjou=[2,0]
		jj=n_elements(jou_c)
		kk=(jj-kpjou(1))<20 & if kk lt 0 then kk=jj
		if kk gt 0 then jou=jou_c(jj-kk-1:jj-1)+'            '+jou_w(jj-kk-1:jj-1)
		kpjou(1)=jj
	endif else if keyword_set(htm) then begin wpth=''
	        if (GEORGE ne 0) then WebDo,'pth',wpth
		if wpth eq '' then wpth='journal.htm' else wpth=wpth+'geo_d_12htm.web'
		OPENW,out,wpth,/get_lun
		PRINTF,out,'<html><pre>'
		for i= 0,n_elements(jou_c)-1 do PRINTF,out,jou_c(i)+'            '+jou_w(i)
		PRINTF,out,'</pre></html>'
	endif else begin
		j= n_elements(jou_c)-1 & k=j & ok=0
		if n_elements(kpjou) eq 0 then kpjou=[2,0]

		if (keyword_set(check)) and (j-kpjou(0) le 35) then return
		
		while (k gt 0) and (not ok) do begin
	   	if strpos(jou_c(k),'SESSION') eq 0 then ok=1 else k=k-1
		endwhile
		
		OPENW,out,'lamp.jou',/get_lun,/APPEND
		for i= k-1,j do PRINTF,out,jou_c(i)+'            '+jou_w(i)
		
		if (j gt 300) or (keyword_set(clear)) then begin & kpjou(0)=2
        	                 jou_c=[      '*******','SESSION','*******'] & jou_w=[      ' ',!stime,' ']
        	endif else begin jou_c=[jou_c,'*******','SESSION','*******'] & jou_w=[jou_w,' ',!stime,' ']
        	                 kpjou(0)=j+3 & endelse
	endelse
	end_wr: if out gt 0  then begin FREE_LUN,out & if (GEORGE ne 0) and keyword_set(htm) then WebDo,'fil','geo_d_12htm.web' & endif
return
end

pro DID_PARAM_HTM , nwk
;** *************
;**
@lamp.cbk
	on_ioerror, end_wr & out=-1  & wpth=''
	        if (GEORGE ne 0) then WebDo,'pth',wpth
		if wpth eq '' then wpth='param.htm' else wpth=wpth+'geo_d_12htm.web'
		OPENW,out,wpth,/get_lun
		pp =['0']
		bb =execute('pp=string(p'+nwk+')')
		PRINTF,out,'<html><b>Parameters from W'+nwk+'  '+w_numor(fix(nwk))+'</b></br><pre>'
		for i=0,n_elements(pp)-1 do PRINTF,out,par_txt(fix(nwk),i) + pp(i)
		PRINTF,out,'</pre></html>'
	end_wr: if out gt 0  then begin FREE_LUN,out & if (GEORGE ne 0) then WebDo,'fil','geo_d_12htm.web' & endif
return
end

pro p_did_help, flg, formu,formt
;** **********
;**
common dialshare2
	if flg eq 586 then begin
	   	formu=[      'Path is your PATH WORKING DIRECTORY you can change at any time.']
	   	formt=[      '']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'Click the "Data..." button to access your instrument data on site']
	   	formt=[formt,'']
	   	formu=[formu,'        ']
	   	formt=[formt,'you may have to customize the two ins: pull-down menus.']
	   	formu=[formu,'The READ button allows access  to data from several types.']
	   	formt=[formt,'']
	   	formu=[formu,'You have to adjust the Ins format type and its location (second Ins menu)']
	   	formt=[formt,'']
	   	formu=[formu,'then enter the Run number (or file_name{i.j}) and adjust W_space (W1).']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'The CUSTOMIZE entry in the Ins: menu is what you need to start with Lamp!']
	   	formt=[formt,'']
	   	formu=[formu,'If you click the "Self..." button then you can bring up']
	   	formt=[formt,'']
	   	formu=[formu,'YOUR special interface window for accessing your data.(See CUSTOMIZE)']
	   	formt=[formt,'']
	   	formu=[formu,'This is a programmed button, as an example you may']
	   	formt=[formt,'']
	   	formu=[formu,'associate the RDFILTER procedure which provides:']
	   	formt=[formt,'']
	   	formu=[formu,'        ']
	   	formt=[formt,'- X Y and Z scaling.']
	   	formu=[formu,'        ']
	   	formt=[formt,'- X Y and Z projections, consistencies']
	   	formu=[formu,'        ']
	   	formt=[formt,'- Do simple operations on several Runs as they are read in.']
	   	formu=[formu,'The IMPORT File entry  allows you to get']
	   	formt=[formt,'']
	   	formu=[formu,'files having format such as:']
	   	formt=[formt,'']
	   	formu=[formu,'        ']
	   	formt=[formt,'- LAMP format  - XY ascii files  - NeXus hdf files      .../...']
	   	formu=[formu,'The EXPORT button is the best way to save your WORKSPACES and']
	   	formt=[formt,'']
	   	formu=[formu,'their associated parameters,history,coordinates,titles.']
	   	formt=[formt,'']
	   	formu=[formu,'The LAMP format is quit clear: A header ascii file is produced']
	   	formt=[formt,'']
	   	formu=[formu,'containing the parameters, a litte snapshot file(192*192 bytes),']
	   	formt=[formt,'']
	   	formu=[formu,'and a data file:']
	   	formt=[formt,'BINARY for c & lamp , F77 for fortran , ASCII for suspicious , XDR']
      		formu=[formu,''] & formt=[formt,'']
		formu=[formu,'Choose NeXus standard hdf format for data interchange.']
	   	formt=[formt,'']

	endif else if flg eq 587 then begin
	   	formu=[formu,'To visualize a workspace you must click on the PLOT W n button.']
	   	formt=[formt,'']
	   	formu=[formu,'']
	   	formt=[formt,'You may have to adjust its number by pressing the neighbouring arrows.']
	   	formu=[formu,'']
	   	formt=[formt,'Plot result depends of a combination of Image,Contour,Suface radio buttons.']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'Data are plotted in the small drawing-window unless you press the BESIDE button.']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'A beside-drawing-window can be re_sized using the mouse, then']
	   	formt=[formt,'']
	   	formu=[formu,'when the new size is suitable press the REPLOT button']
	   	formt=[formt,'You may also use the X-Ysize fields.']
	   	formu=[formu,'']
	   	formt=[formt,'Each time you press the PLOT W n button you get a new window.']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The PRINT buttons produce a PostScript file.']
	   	formt=[formt,'If a PostScript Device is']
	   	formu=[formu,'']
	   	formt=[formt,'specified in the Titles... interface then print-out is automatic.']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The Options... button allows you to change:']
	   	formt=[formt,'Titles, surface aspects ...']

	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The W LOG button (seen after More... is pressed) associated with the']
	   	formt=[formt,'']
	   	formu=[formu,'IMAGE button is useful to check for backgrounds and detector problems.']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'The axis are labelled according to the values of the Workspaces"s']
	   	formt=[formt,'']
	   	formu=[formu,'coordinates. The REGULAR GRID option may imply an interpolation.']
	   	formt=[formt,'']
	   	formu=[formu,''] & formt=[formt,'----']

	endif else if flg eq 588 then begin
		if GEORGE eq 1 then begin
	   	formu=[formu,'LIST OF FUNCTIONS USED TO MANAGE THE DIALS:']
	   			formt=[formt,' ']
	   	formu=[formu,'DialTag   ,    "temp2",TAG="VALUE",GET=V']
	   			formt=[formt,'    Return V, the value of the tag  "VALUE" of dial "temp2"']
	   	formu=[formu,'DialTag   ,    "temp3",TAG="ONOFF",SET=1']
	   			formt=[formt,'    Set to 1  the value of the tag  "ONOFF" of dial "temp3"']
	   	formu=[formu,'DialStart ,    "temp3"']
	   			formt=[formt,'    A short  for previous call']
	   	formu=[formu,'DialStop  ,    "temp3"']
	   			formt=[formt,'    A short  too']
	   	formu=[formu,'D1.upperlim=   150.']
	   			formt=[formt,'    modify a property of DIAL 1 (Set upper limit for plotting)']
	   	formu=[formu,'DialInit,      "template4",[NEW="tmp4"]']
	   			formt=[formt,'    Initiate dial  "template4" from file:dial_template4.pro']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    (You may change its name to "tmp4" and use DialStart,"tmp4" to activate it)']
	   	formu=[formu,'DialMacro,     "template4"']
	   			formt=[formt,'    Force execution of DIAL_TEMPLATE4_MACRO']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    ("template4"  is keept inactive, ONOFF=0)']
	   	formu=[formu,'DialClear,     "template4"']
	   			formt=[formt,'    Suppress dial  "template4" from memory']
	   	formu=[formu,'WebOn  ,       [PATH="pth"],[PASSWD="pwd"]']
	   			formt=[formt,'    Output to the web (allow input if passwd is set)']
	   	formu=[formu,'WebOff            ']
	   			formt=[formt,'    Output to the web (allow input if passwd is set)']
	   	formu=[formu,'DialsFrequency,[GET=freq],[SET=.5],[/STOP],[DURATION=90.],[/START]']
	   			formt=[formt,' ']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    Set  or Get the general frequency value (time is in seconds)']
	   			formu=[formu,'                  ']
	   			formt=[formt,'    Stop or Start the general process, Set Time limit for the active process']
	   	formu=[formu,' ']
		formt=[formt,' ']
	   	formu=[formu,'FUNCTIONS USED EXCLUSIVELY INSIDE A DIAL-MACRO']
	   			formt=[formt,' ']
	   	formu=[formu,'R=DialOn ()']
	   			formt=[formt,'                 Return 0 if Dial has been interrupted (To be used inside loops)']
	   	formu=[formu,'DialWSet']
	   			formt=[formt,'                        Reserve central draw window for next plot']
	   	formu=[formu,'V=DialNewValue([/SETVALUE, COMMENT=txt])']
	   			formt=[formt,'    Get a new value from DIAL_"generic"_READ']
	   			formu=[formu,'                  ']
				formt=[formt,'    (a request is made to the instrument)(/SETVALUE means D.value is set to V)']
	   	formu=[formu,'C=DialControl ("command syntax",[CHECK=.5])']
	   			formt=[formt,'    Send a command to the instrument control']
	   			formu=[formu,'                  ']
				formt=[formt,'    (CHECK means check every .5 sec till the command is complete)']
	   	formu=[formu,'DialModValue,   V']
	   			formt=[formt,'     Set the new value for current dial if type or dimensions have changed']

		endif else begin

	   	formu=[formu,'RAW MANIPULATIONS']
	   			formt=[formt,'Set this mode to prevent Lamp from adjusting results as a']
	   			formu=[formu,'']
				formt=[formt,'                  function of monitors & operators.(see setmanip in INTERNAL)']
	   	formu=[formu,'INTERNAL MACROS']
	   			formt=[formt,'Access to the list by the "UserMacros" button.']
	   			formu=[formu,'IDL LANGUAGE:'] & formt=[formt,'']
	   	formu=[formu,'W4 = W1(0:35 , 5:40)']
	   	         	formt=[formt,'EXTRACT a sub-array']
	   	formu=[formu,'W4 = W1( *   ,  8)']
	   	           	formt=[formt,'EXTRACT all points at y = 8']
	   			formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'w4 = FLTARR(256,128)']
	   	           	formt=[formt,'CREATE an empty floating matrix']
	   	formu=[formu,'OPENR,L,"DON.DAT",/GET_LUN']
	   	           	formt=[formt,'OPEN the file containing the matrix']
	   	formu=[formu,'READF ,L, W4']
	   	           	formt=[formt,'READ the matrix from ASCII format or']
	   	formu=[formu,'READU ,L, W4']
	   	           	formt=[formt,'READ the matrix from BINARY format']
	   	           	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'W4 = TOTAL ( W1 )']
	   	           	formt=[formt,'Total INTEGRATION of W1 ']
	   	formu=[formu,'W4 = TOTAL ( W1 ,2)']
	   	           	formt=[formt,'Vector INTEGRATION of W1 :SUM the SECOND dimension']
	   	formu=[formu,'W4 = TOTAL ( W1 ,1)']
	   	           	formt=[formt,'Vector INTEGRATION of W1 :Y PROJECTION']
	   	           	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'W4 = CONGRID ( W1 ,100,50)']
	   	           	formt=[formt,'RESIZE W1 to a new matrix sized by 100*50']
	   	formu=[formu,'W1 = W1 > 2']
				formt=[formt,'Force any values in W1 to be >= 2']
	   	formu=[formu,'W4 = ALOG ( W1 + W2 + W3 + 1)']
	   	           	formt=[formt,'The LOGARITHMIC SUM of 3 WKspaces']
	   	           	formu=[formu,''] & formt=[formt,'----']
	   	formu=[formu,'W4 = [  W1  ,  W2  ,  W3  ]']
	   			formt=[formt,'JOIN workspaces into FIRST dimension']
	   	formu=[formu,'W4 = [ [W1] , [W2] , [W3] ]']
	   			formt=[formt,'into SECOND dimension']
	   	formu=[formu,'W4 = [[[W1]],[[W2]],[[W3]]]']
	   			formt=[formt,'into THIRD  dimension']
	   			formu=[formu,''] & formt=[formt,'---- See the IDL user"s guide ...']
		endelse
	endif else if flg eq 589 then begin
	   	formu=[formu,'SCROLL SPECTRA']
	   	formt=[formt,'This interface scrolls individual spectra within a workspace.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'It provides interactive zoom and animation.']
	   	formu=[formu,'RADIAL INTEGRATION']
	   	formt=[formt,'This interface defines sectors of integrations.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'MASK & GROUP']
	   	formt=[formt,'This interface regroups spectra within a workspace and']
	   	formu=[formu,'                           ']
	   	formt=[formt,'creates a mask which defines defective detectors.']
	   	formu=[formu,'GK_FIT']
	   	formt=[formt,'Calcutates gaussians & lorentz from a spectrum within a workspace.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'LOAD NEW COLORS']
	   	formt=[formt,'is used for colors adjustements and loading new tables.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'SCAN Wi']
	   	formt=[formt,'This interface provides interactive facilities such as:']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- SLICING.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- ZOOMING.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- INTEGRATING ZONES.']
	   	formu=[formu,'                           ']
	   	formt=[formt,'- FOURIER TRANSFORM.           ..../....']
	   	formu=[formu,'SUPER PLOT']
	   	formt=[formt,'Is usefull to compare spectra within one on several wkp.']
	   	formu=[formu,''] & formt=[formt,'']
	   	formu=[formu,'THE JOURNAL']
	   	formt=[formt,'The journal.']
	   	formu=[formu,'SAVE LAMP SESSION']
	   	formt=[formt,'Workspaces and parameters are saved for next lamp time.']
	   	formu=[formu,''] & formt=[formt,'']

endif else if flg eq 591 then begin

formu=[formu,'SuperPlot']
formt=[formt,' was written by JOUFFREY Romuald, on August 1995. Hope this Helps']
formu=[formu,'What is to be plotted :']
formt=[formt,'']
formu=[formu,'']
formt=[formt,'Adjust workspace number and cutting value with sliders, cutting axis with X or Y button.']

formu=[formu,'Manipulating local workspace plots :']
formt=[formt,'']
formu=[formu,'    "Keep as"']
formt=[formt,' Buttons allow you to keep a workspace in one of the six buffers']
formu=[formu,'']
formt=[formt,'            You can replace any kept workspace by any other, just click !']
formu=[formu,'    "Hide"']
formt=[formt,' temporarily hide a plot without losing it,'+ $
		' data are still processed, without be plotted']
formu=[formu,'    "Scale"']
formt=[formt,' temporarily disactivate scaling of '+ $
		'considered buffer, allowing to scale one plot versus another']
formu=[formu,'    Apply cut to "Current Workspace"']
formt=[formt,' cut is processed only on selected workspace']
formu=[formu,'                          "All Workspace"']
formt=[formt,' cut is processed on all kept workspaces']
formu=[formu,'    ']
formt=[formt,'                           You can change from on mode to the other, cuts are preserved for each']

formu=[formu,'Changing plotting parameters :']
formt=[formt,'']
formu=[formu,'    Bottom horizontal sliders']
formt=[formt,' permit to define X minimum and maximum Range']
formu=[formu,'    Left side slider']
formt=[formt,' defines Y axis scale ratio']
formu=[formu,'    Right side slider']
formt=[formt,' defines Y axis offset values']

formu=[formu,'Integrity of plots versus data :']
formt=[formt,' Beware of errors on plot interpretation']
formu=[formu,'']
formt=[formt,'     - when "normalize all" is set, the Y scale is'+ $
		' from 0 to 1. Each plot is normalized over its own range']
formu=[formu,'']
formt=[formt,'     - when the right side slider' + $
		' isn'+string(39B)+'t at the bottom, each plot has an Y incremental offset.']
formu=[formu,'']
formt=[formt,'     - when the XMin and XMax range sliders are not set to'+ $
		' minimum and maximum respectively.']
formu=[formu,'']
formt=[formt,'     - when the Filter button is set, smooth and median filters are'+ $
		' processed for plotting.']

formu=[formu,'Other Abilities :']
formt=[formt,'']
formu=[formu,'    "PRINT"']
formt=[formt,' Generate a PS file of the plotting window, you get what you see']
formu=[formu,'    "ANNOTATE"']
formt=[formt,' allows you to annotate the plotting window']

endif else if (flg eq 592) or (flg eq 594) then begin
	formu=[formu,'AVAILABLE OPERATORS between runs ']
	formt=[formt,' +   -   >   :']
	formu=[formu,'FRAME OPERATORS for runs or file ']
	formt=[formt,'{ +   -   >   : }']
	formu=[formu,'NO OPERATOR between alphabetic FileName ']
	formt=[formt,'']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'To select a  run  number     ']
	formt=[formt,' Enter only the run number ex: 211 ']
	formu=[formu,'To select and add three runs ']
	formt=[formt,' 211 + 214 + 218']
	formu=[formu,'To add a range of runs       ']
	formt=[formt,' 211 > 300']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'ALLOWED COMBINATIONS ']
	formt=[formt,' 205 + 211>300 + 315 - 316>318 - 321']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'To concatenate runs 211 to 300 and 303 to 314']
	formt=[formt,' 211:300 , 303:314']
	formu=[formu,'To concatenate every third runs  210 to 300']
	formt=[formt,' 210 ::: 300']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'Frame operations in run 211 and 214']
	formt=[formt,' 211{1>5 +7} + 214{1>6}']
	formu=[formu,'Frame operations in Nexus or Spec files ']
	formt=[formt,' File{1>5 +7.3}']
	formu=[formu,'']
	formt=[formt,'']
	IF flg eq 592 then begin
	formu=[formu,'TO STORE A RUN IN W1 USING THE MOUSE ']
	formt=[formt,' Click a SnapShot with the middle button']
	formu=[formu,'TO _ADD_ A RUN TO W1 USING THE MOUSE ']
	formt=[formt,' Click a SnapShot with the right  button']
	endif
	IF flg eq 594 then begin
	formu=[formu,'SCALING AND PROJECTIONS APPLY TO RUNS INDIVIDUALY']
	formt=[formt,' ']
	formu=[formu,'CONSISTENCY IS USED WITH CONCATENATION ']
	formt=[formt,' only']
	endif
endif else if (flg eq 595) then begin
	formu=[formu,'LIKEABLE URL: http://www.ill.fr/YellowBook/D7/home/D7_george_book.html']
	formt=[formt,'']
	formu=[formu,'THE PAD INTERFACE BUTTONS IS DESIGNED FROM A FILE.']
	formt=[formt,'']
	formu=[formu,'DEFAULT FILE:']
	formt=[formt,' lamp/lamp_mac/dial_pad_init.pro']
	formu=[formu,'WHERE TO PLACE YOUR dial_pad_init.pro FILE:']
	formt=[formt,' in the directory where you have your macros.']
	formu=[formu,'']
	formt=[formt,' Otherwise you may have a local dial_pad_init.prox file (see that one in /lamp_mac)']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'SOME WORDS about DIALS:']
	formt=[formt,' Dials are named Objects, designed to perform actions at a frequency time.']
	formu=[formu,'']
	formt=[formt,' A Dial consists of a set of own and general properties, plus a macro procedure.']
	formu=[formu,'']
	formt=[formt,' An object named "model" is placed in a file named "dial_model.pro"']
	formu=[formu,'']
	formt=[formt,' The minimum code for an object is:  (see lamp/lamp_mac/dial_template1.pro  for a more complete Dial)']
	formu=[formu,'    PRO dial_model_macro, Dial']
	formt=[formt,'    ;(The METHOD)']
	formu=[formu,'']
	formt=[formt,'    V=DialNewValue()            &   Dial.value=sqrt(V)']
	formu=[formu,'']
	formt=[formt,'    R=DialControl ("My wish")   &   end']
	formu=[formu,'    FUNCTION dial_model']
	formt=[formt,'    ;(The CONSTRUCTOR)']
	formu=[formu,'']
	formt=[formt,'    return, {NAME:"model", GENERIC:"interface", TYPE:"temperature" }   &   end']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'    DIAL "model" gets its value from function dial_interface_read']
	formt=[formt,' "interface" comes from the GENERIC tag value.']
	formu=[formu,'']
	formt=[formt,'    George hidden call is: v=dial_interface_read("temperature")    if DialNewValue() is used.']
	formu=[formu,'    DIAL "model" sends its command to function dial_interface_send']
	formt=[formt,' "interface" comes from the GENERIC value.']
	formu=[formu,'']
	formt=[formt,'    George hidden call is: errcod=dial_interface_send("temperature",0,"My wish","model")   if DialControl() is used.']
	formu=[formu,'']
	formt=[formt,'']
	formu=[formu,'SOME WORDS about PAD:']
	formt=[formt,' a generic value is associated to each button. George proceeds in the same way']
	formu=[formu,'']
	formt=[formt,'   as for Dials: errcod=dial_myface_send("PAD",0,"My wish","button label")']
	
endif else if (flg eq 596) then begin
	formu=[formu,'Very easy !!!  Check for the template file lamp/lamp_mac/A_List_oldTOF.prox']
	formt=[formt,'']
	formu=[formu,'You will be able to define the tags which describe your macros.']
	formt=[formt,'']
	formu=[formu,'Then put your file A_List_*.prox near your macros or in directory lamp/lamp_mac/']
	formt=[formt,'']
endif
return
end

pro dids
;** ****
return
end
pro live_lamp_dens, liveT, xx,yy,zz,w, thresh=thresh, box=cdbox, ax=rx,az=rz, xrange=bx, yrange=by, zrange=bz
;** **************
;**
if thresh ne -99 then begin & endif ;thresh already done !!!

if liveT ne 3 then $
PLOT_3DBOX, xx,yy,zz,psym=2, ax=rx,az=rz, xrange=bx, yrange=by, zrange=bz, $
		/solid_walls,color=80,background=255, gridstyle=0 $
else $
PLOT_3DBOX, xx,yy,zz,psym=2, ax=rx,az=rz, xrange=bx, yrange=by, zrange=bz, $
		/solid_walls,color=80,background=255, gridstyle=0, $
		/xy_plane, /xz_plane, /yz_plane
end

pro live_lamp_plot, liveT, xx,ww, xrange=bx, yrange=by
;** **************
;**
Vs=!version.release & if (sys_dep('MACHINE') ne 'win') and (Vs ge 6.0) then return
X=xx
W=ww
if n_elements(bx) ne 2 then begin mini=min(x ,max=maxi) & bx=[mini,maxi]
endif			else begin id=where((x ge bx(0)) and (x le bx(1))) & X=X(id) & w=w(id,*) & endelse
if n_elements(by) ne 2 then begin mini=min(w ,max=maxi) & by=[mini,maxi] & endif

z=size(w) & if z(0) eq 2 then k=(z(2)-1)<24 else k=0
if k eq 0 then begin
   if Vs lt 6.0 then $
        res=execute('LIVE_PLOT, W  , independent=X, xrange=bx, yrange=by, /indexed_color, error=bidon') $
   else res=execute('IPLOT  ,X, W  , xrange=bx, yrange=by')

endif else begin s=''
   if Vs lt 6.0 then begin
     for i=0,k do s=s+',w(*,'+string(i)+')'
     res=execute('LIVE_PLOT'+s+', independent=X, xrange=bx, yrange=by, /indexed_color, error=bidon')
   endif else begin
     for i=0,k do begin s='w(*,'+string(i)+')'
       if i eq 0 then res=execute('IPLOT  ,X, '+s+' , xrange=bx, yrange=by') $
                 else res=execute('IPLOT  ,X, '+s+' , xrange=bx, yrange=by,/overplot')
     endfor
   endelse
endelse
end

pro live_lamp_img, liveT, w, xrange=bx, yrange=by
;** *************
;**
Vs=!version.release & if (sys_dep('MACHINE') ne 'win') and (Vs ge 6.0) then return
if Vs lt 6.0 then res=execute('LIVE_IMAGE, w') $
             else res=execute('IIMAGE    , w')
end

pro live_lamp_surf, liveT, xx,yy,w, ax=rx,az=rz ,rrr=rrr, style=styles
;** **************
;** rrr=1 image+surface		rrr=2 image  +contour
;** rrr=3 image+surface+contour	rrr=4 surface+contour
;** rrr=5 contour			rrr=6 surface
;** rrr=7 vrml

Vs=!version.release & if (sys_dep('MACHINE') ne 'win') and (Vs ge 6.0) then return
if (size(x))(0) gt 1 then x=xx(*,0)		else x=xx
if (size(y))(0) gt 1 then y=reform(yy(0,*))	else y=yy

if (rrr eq 2) or (rrr eq 3) or (rrr eq 5) then begin
  if Vs lt 6.0 then res=execute('LIVE_CONTOUR, w, Xindependent=X, Yindependent=Y, /indexed_color, error=bidon') $
               else res=execute('ICONTOUR ,w,X,Y  ')
endif else begin
  if Vs lt 6.0 then res=execute('LIVE_SURFACE, w, Xindependent=X, Yindependent=Y, /indexed_color, error=bidon') $
               else res=execute('ISURFACE ,w,X,Y  ')
endelse
end

pro live_lamp_cont, w,GROUP=group, TIT=tit, XTIT=xtit, YTIT=ytit, XX=xx, YY=yy ,WI=idn
;** **************
;**
    ii=execute("livc_lamp, w,GROUP=group, TIT=tit, XTIT=xtit, YTIT=ytit, XX=xx, YY=yy ,WI=idn")
end

pro live_lamp_vol , liveT, w, ax=rx,az=rz ,rrr=rrr, thresh=thresh, name=str
;** **************
;**
Vs=!version.release & if (sys_dep('MACHINE') ne 'win') and (Vs ge 6.0) then return
pointr=ptr_new(w)
if Vs lt 6.0 then ii=execute("slicer3, pointr,data_names=str") $
             else ii=execute('IVOLUME ,w  ')
end

pro live_lamp_Anim, w, TITLE=tit, GROUP=group, smoo=smoo, surf=did_repr, az=rz,ax=rx ,regul=regul
;** **************
;**
surfc=0 & regul=0
if n_elements(smoo)     ne 1  then smoo=0
if n_elements(did_repr) gt 6  then begin surfc=did_repr(2) & regul=did_repr(6)
	;Care trap_current if surface mode !!!!!
endif
siz =size(w)  & sx=siz(1) & sy=siz(2) & nf=siz(3)
mini=min(w, max=maxi)
				winx=320	   &   winy=320
				xi= winx/siz(1)    &   yi=winy/siz(2)
				if (xi eq 0) then xi= -(float(siz(1))/winx) 
				if (yi eq 0) then yi= -(float(siz(2))/winy)
				if  xi le -1 then fx= -1./xi else fx=xi
				if  yi le -1 then fy= -1./yi else fy=yi

				fm=min([fx,fy])    & fx=fm & fy=fm

				xi= fix(siz(1)*fx) & yi= fix(siz(2)*fy)

				if xi/yi gt 4 then yi=xi/4 else if yi/xi gt 4 then xi=yi/4

				if winx lt xi then xi=winx   &  if winy lt yi then yi=winy

				ff=fix((float(xi)/sx)*(float(yi)/sy)/2)*smoo

;loadct,4,/silent

Xinteranimate,set=[xi,yi,nf], /cycle, mpeg_file="lamp.mpg", $
              /showload, /track, title=tit

ff=fix((float(xi)/sx)*(float(yi)/sy)/2)*smoo

for i=0,nf-1 do $
if (xi eq sx) and (yi eq sy) then $
     Xinteranimate, frame=i, image=bytscl(w(*,*,i), max=maxi, min=mini) $
else begin
     if ff lt 3 then $
     Xinteranimate, frame=i, image=bytscl(congrid(w(*,*,i),xi,yi), max=maxi, min=mini) else $
     Xinteranimate, frame=i, image=bytscl(smooth(congrid(w(*,*,i),xi,yi),ff<6), max=maxi, min=mini)
endelse

Xinteranimate, GROUP=group
end

pro liv_lamp
;** *********
end
;
;				******************
;				*** Super_Plot ***
;				******************
; 			a graphical tool to compare scans
;
; 			Written by JOUFFREY Romuald
; 			August,September,October, November, ..., etc 1995
; 			(Hoping this Help...)
;
; V01.20 09/09/96

; Procedures of this file are :
;
; *************************** Procedures
; p_rom_super_event           Event Manager for Super_Plot
; p_rom_super_plot		Plots making procedure
; p_rom_super_select		plot Getting procedure
; p_rom_super_filter		filter/copy local workspaces for plotting
; p_rom_super_done		Done button was pushed
; p_rom_cleanup, id		called when window is killed to restore colors
; p_rom_redefine_slider
; p_rom_send_txt_wd
; ***************************** Widgets Creating Procedure
; superplot, widx	Create Super_plot Interface
;
; Little explanation on variables
; - Each Super_Plot Variable begins with s_
; - Local variables are normaly named
; - sw_ stands for Super_Plot Widgets identifier variables
; - sc_ stands for Super_Plot Commons
;
; The event procedure for superplot is called by the event_lamp_parser
; which gives it back the Uvalue as a parameter, so superplot interface
; is a real part of the whole Lamp package.


; *****************************************************************************
pro p_rom_super_event, event, test ;*******************************************
; *****************************************************************************
;
; Called when an event is generated by Super_Plot widgets tree
;

@lamp.cbk				; call back the lamp common block
common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common sc_superdid ,s_sym,s_err, $	; Array of boolean Set for psym , error
		s_lv,s_lx,s_lbx,s_lby   ; For live annotation
common sc_supordid ,s_xylv,s_xylw       ; For XY limits and there widgets + log10 + linear

common sc_superplot,s_wid,$		; # of the workspace processed (string)
		s_siz,    $		; The size of current workspace processed
		s_wset,   $		; # of the draw window
		s_hid,    $		; Array of boolean Set if hided
		s_scl,    $		; Array of boolean Set if scaled
		s_hid2,   $		; as s_hid but when s_cutall is set
		s_off_arr,$		; Array of idx
		s_num_wrk,$		; Array of workspace number
		s_cut,    $		; Array of boolean Set if cutting x
		s_cut_values, $		; Array of cutting values
		s_xcut,	  $		; Boolean set if cutting X
		s_filter, $		; Boolean set if filter is on
		s_color,  $		; Boolean set if colored mode
		s_show_err, $		; boolean set if show error is on
		s_normalize, $		; Boolean set if normalization is on
		s_cutall, $		; Boolean set if cutting apply to all
		s_psymb,  $		; Boolean set if plot symbol is on
		s_xmin,   $		; xmin range value (%)
		s_xmax,   $		; xmax range value (%)
		s_ctred,  $		; buffer for user color palet (red)
		s_ctgreen,$		; " (green)
		s_ctblue, $		; " (blue)
		s_scratio,$		; float (maximum scale ratio)
		s_printno,$		; int (number of next print)
		s_var1,   $
		s_var2,   $
		s_var3,   $
		s_var4,   $
		s_yscale, $		; Y scale percentage
		s_yoffset,$		; Y Offset percentage
		s_0,s_1,s_2,s_3,s_4,s_5,s_6, $	      ; local workspaces (data)
		s_e0,s_e1,s_e2,s_e3,s_e4,s_e5,s_e6, $ ; local errors
		s_x0,s_x1,s_x2,s_x3,s_x4,s_x5,s_x6, $ ; X vectors for data arrays
		s_p0,s_p1,s_p2,s_p3,s_p4,s_p5,s_p6, $ ; plotted local workspaces
		sw_id,    $		; widget id of multi_plot widget tree
		sw_drw,   $		; array of id widget draw  (0->5)
		sw_hid,   $		; array of id widget button(0->5)
		sw_lab,   $		; array of id widget label (0->5)
		sw_err      	; Widget of the 'Error message' label

;WIDGET_CONTROL, event.id, Get_UValue = test
siz_test = size(test)
t1 = test(0)				; always -88 (Lamp event)
IF siz_test(1) gt 1 then t2 = test(1)	; code of the event
IF siz_test(1) gt 2 then t3 = test(2)	; another code for the event
IF siz_test(1) gt 3 then t4 = test(3)	; id of cut slider
IF siz_test(1) gt 4 then t5 = test(4)	; id of cut label
IF siz_test(1) gt 5 then t6 = test(5)	; id of X Button
IF siz_test(1) gt 6 then t7 = test(6)	; id of Y Button
IF siz_test(1) gt 7 then t8 = test(7)	; id of cutting base
IF siz_test(1) gt 8 then t9 = test(8)	; id of Workspace slider

CASE t2 OF
    353:BEGIN ; *************************** Worspace Modification
	CASE t3 OF
	    0 : BEGIN ; ------------------------------------ Worspace slider moved
		    p_rom_super_select,test,2	; Process new selection
		END
	    1 : BEGIN ; ------------------------------------ Cut slider moved
		    p_rom_super_select,test,1	; Process new selection
		END
	    2 : BEGIN ; ------------------------------------ X Button Pushed
		    s_xcut = 1			; Set flag xcut on
		    p_rom_super_select,test,1	; Process new selection
		END
	    3 : BEGIN ; ------------------------------------ Y Button Pushed
		    s_xcut = 0			; Set flag xcut off
		    p_rom_super_select,test,1	; Process new selection
		END
	    ENDCASE
	END
    354:BEGIN ; *************************** Plotting parameters modification
	CASE t3 OF
	    0 : BEGIN ; ------------------------------------ XMin slider moved
		    old_s_xmin = s_xmin
		    s_xmin = event.value
		    s_var1 = 1 & s_var2 = 0
		    IF old_s_xmin ne s_xmin THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    1 : BEGIN ; ------------------------------------ XMax slider moved
		    old_s_xmax = s_xmax
		    s_xmax = event.value
		    s_var2 = 1 & s_var1 = 0
		    IF old_s_xmax ne s_xmax THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    2 : BEGIN ; --------------------------------- Y_scale slider moved
		    old_s_yscale = s_yscale
		    if s_yscale lt 0 THEN s_yscale = -(event.value) ELSE $
		    			  s_yscale = (event.value)
		    IF old_s_yscale ne s_yscale THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    3 : BEGIN ; --------------------------------- Y Offset slider moved
		    old_s_yoffset = s_yoffset
		    s_yoffset = event.value
		    IF old_s_yoffset ne s_yoffset THEN BEGIN
			p_rom_super_plot,0 ; Redraw
		    ENDIF
		END
	    4 : BEGIN ; --------------------------------- Button one event
		    s_cutall = 3
		    FOR i=1,6 do BEGIN
			IF s_num_wrk(i) gt 0 then BEGIN   ; if a W is defined
			    wid = strtrim(string(s_num_wrk(i)),2)
			    V = s_cut_values(i)
			    siz=0 & res = execute('siz = Size(w' +wid+')')
			    IF siz(0) eq 2 THEN BEGIN ; IF WKS is bi-dimensional
				if s_cut(i) THEN BEGIN
				    didsx=0 & res = execute('didsx=size(x'+wid+')')
				    if didsx(0) ne 1 then st=V+1 else $
				      res=execute('st = x'+wid+'(V)')
				    ii = strmid(strtrim(string(st),2),0,5)
			 	    ss='W'+wid+' '+w_numor(FIX(wid))+' X='+ii
				ENDIF ELSE BEGIN
				    didsy=0 & res = execute('didsy=size(y'+wid+')')
				    if didsy(0) ne 1 then st=V+1 else $
				      res=execute('st = y'+wid+'(V)')
			 	    ii = strmid(strtrim(string(st),2),0,5)
				    ss='W'+wid+' '+w_numor(FIX(wid))+' Y='+ii
				ENDELSE
		            WIDGET_CONTROL, bad_id=j,sw_lab(i-1),Set_Value=ss
			    ENDIF ELSE ss='W'+wid+' '+w_numor(FIX(wid))
			ENDIF
		    ENDFOR
		    p_rom_super_select,test,1	; Process new selection
		END
	    5 : BEGIN ; --------------------------------- Button all event
		    s_cutall = 1
		    p_rom_super_select,test,1	; Process new selection
		END
	    6 : BEGIN ; --------------------------------- Button scale 0
		   s_yscale = -s_yscale
		   p_rom_super_plot,0	; Redraw
		END
	    7 : BEGIN ; --------------------------------- Just redraw
		   p_rom_super_plot,0	; Redraw
		END
	    ENDCASE
	END
    355:BEGIN ; *************************** Local W parameters modification
	CASE t3 OF
	; Here t4 is the number of processed local workspace
	    0 : BEGIN ; ------------------------- Keep Button Pushed
		    s_hid(0) = 1		        ; m_0 is now undrawable
		    s_hid(t4)= 0			; m_# t4 becomes drawable
		    s_sym(t4)=s_psymb			; psym  flag
		    s_err(t4)=s_show_err		; error flag
		    WIDGET_CONTROL, bad_id = i, sw_hid(t4-1), Set_Button=0
        	    s = strtrim(string(t4),2)	; t4 = # of local dataset
		    res = execute('s_' +s+ '=s_0')	; copy s_0 in s_i
		    res = execute('s_e'+s+ '=s_e0')	; copy s_e0 in s_ei
		    res = execute('s_x'+s+ '=s_x0')	; copy s_x0 in s_xi
		    i=0. & ii='' & V = 0
		    sw_scut=t5
		    WIDGET_CONTROL, bad_id=i,sw_scut,Get_Value = V & V=V-1
		    siz=0 & res = execute('siz = Size(w' +s_wid+')')
		    IF siz(0) eq 2 THEN BEGIN ; IF WKS is bi-dimensional
			IF s_xcut then BEGIN
			    didsx=0 & res = execute('didsx=size(x'+s_wid+')')
			    if didsx(0) ne 1 then i=V+1 else $
			      res=execute('i = x'+s_wid+'(V)')
			    ii = strmid(strtrim(string(i),2),0,5)
			    s='W'+s_wid+' '+w_numor(FIX(s_wid))+'X='+ii
			ENDIF ELSE BEGIN
			    didsy=0 & res = execute('didsy=size(y'+s_wid+')')
			    if didsy(0) ne 1 then i=V+1 else $
			      res=execute('i = y'+s_wid+'(V)')
			    ii = strmid(strtrim(string(i),2),0,5)
			    s='W'+s_wid+' '+w_numor(FIX(s_wid))+' Y='+ii
			ENDELSE
		    ENDIF ELSE s='W'+s_wid+' '+w_numor(FIX(s_wid))
		    s_cut_values(t4)=V		; store idx of cut for 'cut one' mode
		    s_cut(t4)=s_xcut		; store cutting axis
		    s_off_arr(t4)=V		; store idx of cut for plot idx
		    s_off_arr(0)=-1		; s_0 offset inactivated
		    s_num_wrk(t4)=FIX(s_wid)	; store number of kept workspace
		    s_num_wrk(0)=-1		; s_0 offset inactivated
		    WIDGET_CONTROL, bad_id=i, sw_lab(t4-1), Set_Value = s
		    p_rom_super_filter		; process filtering
		    p_rom_super_plot,0		; Redraw
		END
      	    1 : BEGIN ; ------------------------- Hide Button event
		    s_hid(t4) = event.select	; t4 = # of local dataset
		    i = strtrim(string(t4),2)
		    s_s = [0]
		    res = execute('s_s = SIZE(s_'+i+')')
		    IF s_s(0) ne 0 THEN BEGIN
			p_rom_super_plot,0	; Redraw
		    ENDIF
        	END
    	    2 : BEGIN ; ------------------------- Scale Button event
		    s_scl(t4) = event.select	; t4 = # of local dataset
		    p_rom_super_plot,0		; Redraw
		END
    	    3 : BEGIN ; ------------------------- Clean Out Button pushed
		    s_hid=[1,1,1,1,1,1,1]	; each plot is undrawable
		    s_0 = 0			; erase local workspace 0
		    s_siz = size(s_0)
		    s_1=s_0 & s_2=s_0 & s_3=s_0	; and 1 to 6
		    s_4=s_0 & s_5=s_0 & s_6=s_0
		    s_p1=s_0 & s_p2=s_0 & s_p3=s_0 ; Erase plotted Workspaces
		    s_p4=s_0 & s_p5=s_0 & s_p6=s_0
		    s_off_arr =[-1,-1,-1,-1,-1,-1,-1]
		    s_num_wrk =[-1,-1,-1,-1,-1,-1,-1]   ; Clear workspace number array
		    s_cut_values=[-1,-1,-1,-1,-1,-1,-1]	; Clear cutting values
		    FOR j=0,5 do BEGIN		; Reset widget values
			WIDGET_CONTROL, bad_id=i, sw_hid(j), Set_Button=0
			WIDGET_CONTROL, bad_id=i, sw_lab(j), Set_Value=' '
		    ENDFOR
		    s_xmin = 0 & s_xmax = 500
		    s_var1 = 0 & s_var2 = 0
		    s_yscale  =  s_scratio
		    s_yoffset =  0		; no yoffset
		    s_xylv(*) =  0		; For XY limits
		    WIDGET_CONTROL, bad_id=i,s_xylw(0), Set_Value = ""
		    WIDGET_CONTROL, bad_id=i,s_xylw(1), Set_Value = ""
		    WIDGET_CONTROL, bad_id=i,s_xylw(2), Set_Value = ""
		    WIDGET_CONTROL, bad_id=i,s_xylw(3), Set_Value = ""
		    
		    WIDGET_CONTROL, bad_id=i, t4      , Set_Value = 0		;slider offset
		    WIDGET_CONTROL, bad_id=i, t5      , Set_Value = s_scratio	;slider yscale
		    WIDGET_CONTROL, bad_id=i, t6      , Set_Value = 0		;slider xmin
		    WIDGET_CONTROL, bad_id=i, t7      , Set_Value = 500		;slider xmax
		    WSET, s_wset
		    ERASE, 255			; Clear draw window
		END
    	    4 : BEGIN ; ------------------------- Normalize all Button event
		    s_normalize = event.select
		    p_rom_super_plot,0 		; Redraw
		END
	    5 : BEGIN ; ------------------------- Filter Button event
		    s_filter = event.select
		    p_rom_super_filter 		; process filtering or copy
		    p_rom_super_plot,0		; Redraw
		END
	    6 : BEGIN ; ------------------------- Colored Button event
		    s_color = event.select
		    IF s_color then BEGIN
			TVLCT, s_ctred, s_ctgreen, s_ctblue, /GET
			s_ddr	=[100,250, 20, 20,250, 5 ,250]
			s_ddg	=[100, 20,250, 20,250,250, 10]
			s_ddb	=[100, 20, 20,250, 20,250,250]
			TVLCT, s_ddr  , s_ddg    , s_ddb ,2
		    ENDIF ELSE BEGIN
			TVLCT, s_ctred, s_ctgreen, s_ctblue
		    ENDELSE
		    FOR j=0,5 do BEGIN
			WIDGET_CONTROL,bad_id=i,sw_drw(j) ,Get_Value = w
			wset, w
			IF s_color then ERASE, j+3 else BEGIN   ;j*(!D.n_colors/9)+7
			    erase, 255
			    PLOTS, 0,13, /Device
			    PLOTS, FIndGen(49), SIN(FIndGen(49)/7)*10+13, /Continue, Color = 1, LineStyle = j, /Device
			ENDELSE
		    ENDFOR
		    p_rom_super_plot,0		; Redraw
		END
	    7 : BEGIN ; ------------------------- Show errors Button event
		    s_show_err = event.select
		    p_rom_super_plot,0		; Redraw
		END
	    8 : BEGIN ; ------------------------- Plot Symbol Button event
		    s_psymb = event.select
		    p_rom_super_plot,0		; Redraw
		END
	    9 : BEGIN ; ------------------------- Log10 scaling
		    s_xylw(4) = event.select
		    p_rom_super_plot,0		; Redraw
		END
	  10  : BEGIN ; ------------------------- Linear X axis (index)
		    s_xylw(5) = event.select
		    p_rom_super_plot,0		; Redraw
		END
	    ENDCASE
	END
    356:BEGIN ; *************************** Others global events
	CASE t3 OF
	    0 : BEGIN ; ------------------------- Print Button Pushed
		    PsFile = 'super_p'	    ; construct PS filename
		    doit=0
		    FOR i=6,0,-1 do BEGIN
		    	IF NOT(s_hid(i)) and NOT(s_hid2(i)) then BEGIN
			    IF s_num_wrk(i) gt 0 THEN doit=s_num_wrk(i)
			ENDIF
		    ENDFOR
		    IF doit gt 0 THEN BEGIN
			PsFile=PsFile+STRTRIM(STRING(s_printno), 2)+'.ps'
		        PRINT, 'Print Generating : '+PsFile
			wplot = !D.name
			on_ioerror, iferr
		        set_plot,'PS' & sx=7. & sy=11.5
		        device, yoffset=sy-0.5,xoffset=.5,/inches,/Landscape
			device, filename=PsFile
			device, bits_per_pixel=8,/color
			p_rom_super_plot,1	; Redraw with print option
			ii=execute('P_DID_PS_HEADER,7.,doit,PsFile')
			s_printno=s_printno+1
			iferr :
			DEVICE,/close
			set_plot, wplot
		    ENDIF ELSE PRINT, string(7B)+'no print generated'
		 END
	    1 : p_rom_super_done		; DONE Button pushed

	    2 : BEGIN ; ------------------------- Motion event
	    		if trap_current eq s_wset then begin
			WSET,s_wset
			tmXYZ=CONVERT_COORD(event.X,event.Y,/dev,/to_data)
			XV=tmXYZ(0) & YV=tmXYZ(1) ;CURSOR,XV,YV ,/nowait,/data
			tx1='X='+strtrim(string(XV),2) & ty1='Y='+strtrim(string(YV),2)
			widget_control,bad_id=i,t4,set_value=tx1
			widget_control,bad_id=i,t5,set_value=ty1
			endif
		 END
	    3 : if n_elements(s_lv) gt 1 then BEGIN ; -------- Live Tools
			ii=execute('LIVE_LAMP_PLOT, 1, s_lx, s_lv, xrange=s_lbx, yrange=s_lby')
	  	 ENDIF
	    4 : BEGIN ; ------------------------- Png Button Pushed
		    PsFile = 'super_p'	    ; construct filename
		    doit=0
		    FOR i=6,0,-1 do BEGIN
		    	IF NOT(s_hid(i)) and NOT(s_hid2(i)) then BEGIN
			    IF s_num_wrk(i) gt 0 THEN doit=s_num_wrk(i)
			ENDIF
		    ENDFOR
		    IF doit gt 0 THEN BEGIN
			PsFile=PsFile+STRTRIM(STRING(s_printno), 2)+'.png'
		        PRINT, 'Generating : '+PsFile
			p_rom_super_plot,2	; Redraw with print option
			r=0 & buf=tvrdd(r,g,b)
			if n_elements(r) le 1 then tvlct ,r,g,b ,/get
			WRITE_KIF,PsFile,buf,r,g,b
			s_printno=s_printno+1
		    ENDIF ELSE PRINT, string(7B)+'no PNG generated'
		 END
	    ENDCASE
	END
    ENDCASE
END

; *****************************************************************************
pro p_rom_super_plot, psp ;****************************************************
; *****************************************************************************
;
; The plotting procedure
; psp stands for PoScript Printing=1 or PNG=2
; if psp eq 1 then p_rom_super_plot is used to print on Postcript device
;

@lamp.cbk
common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common sc_superdid			; Array of boolean Set for psym
common sc_supordid			; For XY limits and there widgets
common sc_superplot			; Call Back Super_Plot block

if s_xylw(5) then begin XMin=0 & XMax=n_elements(s_x0)-1
endif else XMin = Min(s_x0,Max=XMax)	; Default Values for XMin, XMax
           YMin = Min(s_0 ,Max=YMax)	; and YMin, Ymax

FOR i=1,6 do BEGIN			; For each local data set
    s_s=[0] & si= strtrim(string(i),2)
    res = execute('s_s = size(s_'+si+')')
    IF s_s(0) ne 0 THEN BEGIN
	tmp = 0.
	tmm = 0.
	si = strtrim(string(i),2)
	if s_xylw(5) then begin tmp=0 & res = execute('tmm=n_elements(s_x'+si+')-1')
	endif else res = execute('tmp = Min(s_x' +si+',max=tmm)')
	if XMin gt tmp then XMin = tmp	; Calculate XMin ...
	if XMax lt tmm then XMax = tmm	; Calculate XMax ...
	res = execute('tmp = Min(s_'  +si+',max=tmm)')
	if YMin gt tmp then YMin = tmp	; Calculate YMin ...
	if YMax lt tmm then YMax = tmm 	; Calculate YMax
    ENDIF
ENDFOR

; Limited values for YMin, Ymax, XMin, XMax
s_xylv(*)=0
on_ioerror,misbit
WIDGET_CONTROL,bad_id=i,s_xylw(0),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm1=float(bitx) else tm1=YMin
WIDGET_CONTROL,bad_id=i,s_xylw(1),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm2=float(bitx) else tm2=YMax
s_xylv(0)=tm1 & s_xylv(1)=tm2 & misbit:on_ioerror,misbot

WIDGET_CONTROL,bad_id=i,s_xylw(2),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm1=float(bitx) else tm1=XMin
WIDGET_CONTROL,bad_id=i,s_xylw(3),get_value=bitx & bitx=strcompress(bitx(0),/remove_all)
if bitx ne "" then tm2=float(bitx) else tm2=XMax
s_xylv(2)=tm1 & s_xylv(3)=tm2 & misbot:

if s_xylv(1) gt s_xylv(0) then begin YMin=s_xylv(0) & YMax=s_xylv(1) & endif
if s_xylv(3) gt s_xylv(2) then begin XMin=s_xylv(2) & XMax=s_xylv(3) & endif

; ---------------------------------- if scale 0 button is set
if s_yscale lt 0 THEN BEGIN
    butscl0=1
    s_yscale=-s_yscale
ENDIF ELSE butscl0=0

; ---------------------------------- calculate correct XRange (sliders)
if (s_var1 eq 0) and (s_var2 eq 0) then BEGIN
    XMinP =XMin + (XMax-XMin)/500.*s_xmin
    XMaxP =XMax - (XMax-XMin)/500.*(500.-s_xmax)
    s_var3 = XMinP
    s_var4 = XMaxP
ENDIF

if s_var1 eq 1 then BEGIN
    XMinP =XMin + (s_var4-XMin)/500.*s_xmin
    s_var3 = XMinP
    XMaxP = s_var4
ENDIF
if s_var2 eq 1 then BEGIN
    XMaxP =XMax - (XMax-s_var3)/500.*(500.-s_xmax)
    s_var4 = XMaxP
    XMinP = s_var3
ENDIF


; ---------------------------------- calculate correct YRange
; gjk touched here!!!

  YMinP = YMin
  YMimi = YMin
  YMaxP = YMax

  if s_xylw(4) then begin
     YMinP=alog10(YMinP>1E-9)
     YMinP=YMinP>0
     YMimi=YMinP
     YMaxP=alog10(YMaxP>1E-8)
  endif

  if butscl0 eq 1 THEN YMinP = 0

  if s_normalize then begin
     YMinP=YminP/abs(YMaxP)
     YMaxP=1.1
  endif else begin
     YMaxP=YMaxP*1.1
  endelse
; gjk end of touch

; ---------------------------------- Calculate yoffset ...
IF s_yoffset ne 0 THEN BEGIN	; .. if offset slider not equal 0
    ; ------------------------------ Adapt array of offset on s_cutall
    ; --- woffarr is a local OFFSET Array declared for the process, it permit ...
    ; --- to preserve both s_off_arr (idx of cutting) and s_num_wrk (# of W)
    IF (s_cutall eq 1) then woffarr=s_num_wrk ELSE woffarr=s_off_arr
    IF s_normalize THEN yoffset = float(s_yoffset/100.)*float(s_yscale/s_scratio) $
    		   ELSE yoffset = float(s_yoffset/100.)*float(s_yscale/s_scratio)*(YmaxP-YminP)
    IF s_hid(0) then s_off_arr(0)=-1
    off_arr=woffarr
    woffarr2=intarr(n_elements(where(woffarr ge 0)), 2)
    woffarr2(*, 0)=woffarr(where(woffarr ge 0))
    woffarr2(*, 1)=indgen(n_elements(where(woffarr ge 0)))
    woffarr2(*,1)=woffarr2(SORT(woffarr2(*,0)),1)
    j=0				; replace data where it is greater or equal 0
    FOR i=0, 6 DO BEGIN
	IF off_arr(i) GE 0 THEN BEGIN
	    off_arr(i)=woffarr2(j, 1)
	    j=j+1
	ENDIF
   ENDFOR
   YMaxP = YMaxP + Max(off_arr)*yoffset; Adapt YMaxP with offset
ENDIF ELSE BEGIN			; s_yoffset = 0
    yoffset = 0.
    off_arr =[0,0,0,0,0,0,0]
ENDELSE

s_lx = s_x0
IF n_elements(s_x1) gt n_elements(s_lx) then s_lx = s_x1
if n_elements(s_x2) gt n_elements(s_lx) then s_lx = s_x2
if n_elements(s_x3) gt n_elements(s_lx) then s_lx = s_x3
if n_elements(s_x4) gt n_elements(s_lx) then s_lx = s_x4
if n_elements(s_x5) gt n_elements(s_lx) then s_lx = s_x5
if n_elements(s_x6) gt n_elements(s_lx) then s_lx = s_x6

; ---------------------------------- printing or not printing ?
subt='' & tit ='' & xtit='' & ytit=''
lwth=1
IF psp gt 0 THEN BEGIN           ; printing ...
    IF s_color THEN $
    styles=['Grey:','Red:','Green:','Blue:', 'Yel:','wBlue:','Pink:'] $
    else $
    styles=['Grey:','___','...','_ _', '._._.','..._','__ __']

    FOR i=0, 6 DO BEGIN
    IF NOT(s_hid(i)) and NOT(s_hid2(i)) THEN BEGIN
	IF s_num_wrk(i) gt 0 THEN BEGIN
	    st1= strtrim(string(s_num_wrk(i)),2)
	    IF s_cut(i) eq 1 then st2='x' ELSE st2='y'
	    st3= strtrim(string(s_cut_values(i)),2)
	    IF s_cut(i) eq 1 THEN $
	       str0='x'+strtrim(string(s_num_wrk(i)), 2)+'('+ $
		          strtrim(string(s_cut_values(i)), 2)+')' ELSE $
	       str0='y'+strtrim(string(s_num_wrk(i)), 2)+'('+ $
		          strtrim(string(s_cut_values(i)), 2)+')'
	    res=execute('str0='+str0)
	    st4= strtrim(string(str0),2)
	    xtit = x_tit    (s_num_wrk(i))
	    ytit = y_tit    (s_num_wrk(i))
	    if psp eq 2 then $
	    tit = w_tit    (s_num_wrk(i))
	    subt =subt +styles(i)+'W'+st1 + st2 + st4+'  '
	ENDIF
    ENDIF
    ENDFOR
ENDIF
IF psp ne 1 then  WSET, s_wset		   ; ... set the correct window to plot in

tvlct ,pos_r  ,pos_g ,pos_b ,/get
tmp=fix(pos_r)+pos_g +pos_b
pop=min(tmp) & ccol=!C
pup=max(tmp) & bcol=!C

;if s_color then ccol=1 else ccol=7

if psp eq 1 then begin if pop eq 0 then bcol=ccol
endif
; ---------------------------------- Do the plot without dataset with axis

s_lbx=[XMinP,XMaxP]
s_lby=[YMinP,YMaxP*(s_yscale/s_scratio)]
s_lv =0
s_lvd=0
s_lvc=0
trap_current=s_wset
PLOT, s_lx,XRange=s_lbx, YRange=s_lby, title = tit, SubTitle=subt, xtick_get=V, $
			XTitle=xtit, YTitle=ytit,/NoData, Background=bcol,color=ccol
if s_xylw(5) then $
PLOT, s_lx,XRange=s_lbx, YRange=s_lby, title = tit, SubTitle=subt, xtickv=s_lx(V), $
			XTitle=xtit, YTitle=ytit,/NoData, Background=bcol,color=ccol

; ---------------------------------- Plot local workspaces #1 to 6

FOR i=1,6 do begin
    s_s=[0] & si= strtrim(string(i),2)

    si2 = strtrim(string((i-1)*(s_color ne 1)),2)
    res = execute('s_s = size(s_'+si+')')
    c = (((i-1)*(!D.n_colors/9)+7)*FIX(s_color eq 1))>ccol

    IF s_s(0) ne 0 THEN $		; plot only not empty workspace
	IF not(s_hid(i)) and not(s_hid2(i)) THEN BEGIN ; and not hided workspace

	   ;gjk The following line makes a start on getting the normalisation correct
	    res =execute('s_lvd=s_p'+si)
	    if s_xylw(4) then s_lvd=alog10(s_lvd>1E-9)
	    YNor=max(s_lvd)

	    YNor = FLOAT(s_normalize ne 1)+YNor*FLOAT(s_normalize eq 1)
	   ; ------------------------------ Calculate scaling parameter
	   ; if local w isn't scaled, then yscale=s_scratio/s_yscale else yscale=1
	   ; this is to cancel the effect of YRange modified by s_yscale

	    yscale = FLOAT(s_scl(i) eq 1)+(s_yscale/s_scratio)*FLOAT(s_scl(i) ne 1)
	    Numerator  =      '/YNor-YMimi)*yscale)+yoffset*off_arr(i)'
	    s_lvd=(YMimi+(s_lvd/YNor-YMimi)*yscale)+yoffset*off_arr(i)
	    psymb=s_sym(i)*i & IF psymb GE 3 THEN psymb=psymb+1
	    IF psymb EQ 0 THEN psymb=!P.PSYM
	    if s_xylw(5) then s_xn='' else s_xn=', s_x'+si
	    st  = 'OPLOT'+s_xn+',s_lvd ,color=c, PSym=psymb, linestyle='+si2+',thick=lwth'
	    if (s_color) then c=i+2 else c=ccol
	    v=n_elements(s_lvd) & vl=400
	    IF psp eq 1 THEN lwth=3 else if v gt vl then lwth=1 else lwth=2
	    res = execute(st)
	    if (s_color) and (v le vl*(1+4*sqrt(psp))) then begin c=2 & lwth=1
	                                              res = execute(st) & c=i+2 & endif
	    if n_elements(s_lv) eq 1 then begin s_lv=s_lvd & s_lvc=s_lx(0)+n_elements(s_lx)
	    endif else begin s_lf=0 & res=execute('s_lf=s_x'+si+'(0)+n_elements(s_x'+si+')')
				if (size(s_lv))(1) eq n_elements(s_lvd) then $
				if s_lf eq s_lvc then s_lv=[[s_lv],[s_lvd]]
	    endelse
	    ; ------------------------------ Plotting corrected data versus errors
	    IF s_err(i) THEN BEGIN ee=0
		res = execute('ee=s_e'+si)
		res = execute('wmax=MAX(s_'+si+')')
		IF N_ELEMENTS(ee) LE 1 THEN BEGIN
		    res = execute('s_e'+si+'=SQRT(s_'+si+')')
		    res = execute('ee=s_e'+si)
		ENDIF
		IF MAX(ee)*(wmax+1) eq sqrt(wmax) THEN BEGIN
		    opp1='*(1+ee)'
		    opp2='*(1-ee)'
		ENDIF ELSE BEGIN
		    opp1='+ee'
		    opp2='-ee'
		ENDELSE
		if not s_xylw(4) then begin
			ee=ee/YNor
			keepcol=!P.COLOR & !P.COLOR=c
			st  = 'ERRPLOT'+s_xn+', s_lvd'+opp1+ ', s_lvd'+opp2
			res = EXECUTE(st)
			!P.COLOR=keepcol
		endif
	    ENDIF
	ENDIF
ENDFOR

; ---------------------------------- plot local workspace #0
IF s_siz(0) ne 0 THEN $
    IF NOT(s_hid(0)) and not(s_hid2(0)) THEN BEGIN

	s_lvd=s_p0
	if s_xylw(4) then s_lvd=alog10(s_lvd>1E-9)
	YNor=max(s_lvd)

	YNor = FLOAT(s_normalize ne 1)+YNor*FLOAT(s_normalize eq 1)
	s_lvd= YMimi+(s_lvd/YNor-YMimi)  +yoffset*off_arr(0)
	if s_xylw(5) then s_xn='' else s_xn=', s_x0'
	if (s_color) then c=2 else c=ccol
	st  = 'OPLOT'+s_xn+',s_lvd ,Thick=1+s_color,color=c, PSym=7*s_psymb'
	res = execute(st)

	if n_elements(s_lv) eq 1 then s_lv=s_lvd $
	else begin 	s_lf=s_x0(0) + n_elements(s_x0)
			if (size(s_lv))(1) eq n_elements(s_lvd) then $
			if s_lf eq s_lvc then s_lv=[[s_lv],[s_lvd]]
	endelse
	; ------------------------------ Plotting corrected data versus errors
	IF s_show_err THEN BEGIN
		IF N_ELEMENTS(s_e0) LE 1 THEN BEGIN
		   s_e0=SQRT(s_0)
		ENDIF
		wmax=MAX(s_0)
		ee=s_e0
		IF MAX(ee)*(wmax+1) eq sqrt(wmax) THEN BEGIN
		    opp1='*(1+ee)'
		    opp2='*(1-ee)'
		ENDIF ELSE BEGIN
		    opp1='+ee'
		    opp2='-ee'
		ENDELSE
		if not s_xylw(4) then begin
			ee=ee/YNor
			keepcol=!P.COLOR & !P.COLOR=2
			st  = 'ERRPLOT'+s_xn+', s_lvd'+opp1+ ', s_lvd'+opp2
			res = EXECUTE(st)
			!P.COLOR=keepcol
		endif
	ENDIF
    ENDIF

; ---------------------------------- reset y_scale if negative
IF butscl0 eq 1 THEN s_yscale=-s_yscale

END

; *****************************************************************************
pro p_rom_super_select,test, flg ;*********************************************
; *****************************************************************************
;
; Called when a NEW Workspace is selected
; (New Workspace number, Cutting Axis or Cutting Value)
; flag is gt 0 if a new workspace is invoked
; flag eq 2 if workspace slider was moved, to invoke new w in cuting all mode
;

@lamp.cbk			; call back the lamp common block
common sc_superplot		; Call Back Super_Plot block

sw_scut = test(3)	; id of cut slider
sw_lcut = test(4)	; id of cut label
sw_bty  = test(6)	; id of Y Button
sw_cutb = test(7)	; id of cutting base
sw_sw   = test(8)	; id of workspace slider

IF (flg eq 2 and s_cutall eq 1) or (flg gt 0 and s_cutall ne 1) THEN BEGIN
    WIDGET_CONTROL,bad_id=i,sw_sw,Get_Value = widx ; Get selected Workspace #
    s_wid= strtrim(string(widx),2)		; get new workspace #
    res =execute('s_siz=size(w' +s_wid +')' )
    ; --------- if W isn't correct
    IF (s_siz(0) lt 1) or (s_siz(0) gt 2) then BEGIN
	p_rom_send_txt_wd, sw_err, 'Mono or Bidimensional W only'
	print, string(7b)	; BELL to signify error
	s_hid(0) = 1		; s_0 becomes undrawable
    WIDGET_CONTROL, bad_id=i,sw_cutb, Sensitive=0
    ENDIF ELSE BEGIN
	IF flg eq 2 then p_rom_send_txt_wd, sw_err,'W'+s_wid+' '+strmid(w_tit(FIX(s_wid)),0,20)
        IF flg eq 2 then IF (s_siz(0) eq 2) THEN WIDGET_CONTROL, bad_id=i,sw_cutb, /Sensitive
	s_hid(0) = 0		; s_0 becomes drawable
    ENDELSE
ENDIF

IF s_cutall eq 1 THEN BEGIN
    IF flg gt 0 then wait,.6
    p_rom_send_txt_wd, sw_err,'Cut is applied on ALL W'
ENDIF

; ----------------------- Retrieve Cutting Value
WIDGET_CONTROL, bad_id=i, sw_scut, Get_Value = V & V=V-1

if s_hid(0) eq 0 then s_off_arr(0)=V
s_cut_values(0)=V
s_cut(0)=s_xcut
IF (s_cutall eq 1) THEN s_num_wrk(0)=FIX(s_wid)
s_num_wrk(0)=FIX(s_wid)
slide_max = 0

; ------------------------------- For all W if cutall is on (1 or 3)
; ------------------------------- For W#0 if cutall is off
s_e0=0
FOR j=0,6*FIX(s_cutall eq 1 or s_cutall eq 3) do BEGIN
    IF s_num_wrk(j) gt 0 then BEGIN   ; if a W is defined
        IF (s_cutall eq 0) or (s_cutall eq 3) THEN V=s_cut_values(j)
	wid = strtrim(string(s_num_wrk(j)),2)
	si =  strtrim(string(j),2)
	siz=0 & res = execute('siz = Size(w' +wid+')')
	IF siz(0) eq 1 THEN BEGIN		; wk has one dimension
	    IF NOT(s_cutall) THEN BEGIN
		WIDGET_CONTROL, bad_id=i, sw_lcut, Set_Value=''
		WIDGET_CONTROL, bad_id=i, sw_cutb, Sensitive = 0
	    ENDIF
	    res = execute('s_' +si+' = w'+wid)	; copy workspace array
	    res = execute('s_e'+si+' = e'+wid)	; copy error array
	    s_cut(j)=-1
	    res = execute('s_x'+si+' = x'+wid)
	    ss='W'+wid+' '+w_numor(FIX(wid))
	    nb_element=0 & res = execute('nb_element =n_elements(s_x'+si+')')
	    IF nb_element ne siz(1) THEN $
	    res = execute('s_x'+si+' = indgen(siz(1))')
        ENDIF ELSE BEGIN			; wk has two dimensions
	    cutx=s_xcut
	    IF (s_cutall eq 0 or s_cutall eq 3) then cutx = s_cut(j)
	    ; ------------------ Get correct Cut in correct W
	    s = 0.
	    didsx=0 & res = execute('didsx=size (x'+wid+')')
	    didsy=0 & res = execute('didsy=size (y'+wid+')')
	    didse=0 & res = execute('didse=size (e'+wid+')')
	    IF cutx THEN BEGIN
		smax=siz(1)-1  		; define new slider max
	        IF ((V ge siz(1)) AND s_cutall eq 1) then BEGIN
		    s_hid2(j)=1
		ENDIF ELSE BEGIN
		    s_hid2(j)=0
		IF V ge siz(1) then V=siz(1)-1
		if didsy(0) ne 2 then res = execute('s_x'+si+' = y'+wid) else $
				      res = execute('s_x'+si+' = reform(y'+wid+'(V,*))')
		nb_element=0 & res = execute('nb_element =n_elements(s_x'+si+')')
		IF nb_element ne siz(2) THEN $
		res = execute('s_x'+si+' = indgen(siz(2))')

		if didsx(0) ne 1 then st=V+1 else $
		  res=execute('st = x'+wid+'(V)')
		ii = strmid(strtrim(string(st),2),0,5)
		ss='W'+wid+' '+w_numor(FIX(wid))+' X='+ii
		res = execute('s_' +si+' = REFORM(w'+wid+'(V,*))')
		if didse(0) eq 2 then res = execute('s_e'+si+' = REFORM(e'+wid+'(V,*))')
		s = strtrim(string(st),2)+' '+x_tit(FIX(wid))
		ENDELSE
	    ENDIF ELSE BEGIN
		smax=siz(2)-1 		; define new slider max
	        IF ((V ge siz(2)) AND s_cutall eq 1) then BEGIN
		    s_hid2(j)=1
		ENDIF ELSE BEGIN
		    s_hid2(j)=0
		IF V ge siz(2) then V=siz(2)-1
		if didsx(0) ne 2 then res = execute('s_x'+si+' = x'+wid) else $
				      res = execute('s_x'+si+' = reform(x'+wid+'(*,V))')
		nb_element=0 & res = execute('nb_element =n_elements(s_x'+si+')')
		IF nb_element ne siz(1) THEN $
		res = execute('s_x'+si+' = indgen(siz(1))')

		if didsy(0) ne 1 then st=V+1 else $
		  res=execute('st = y'+wid+'(V)')
		ii = strmid(strtrim(string(st),2),0,5)
		ss='W'+wid+' '+w_numor(FIX(wid))+' Y='+ii
		res = execute('s_'+si+' = w'+wid+'(*,V)')
		if didse(0) ne 2 then res = execute('s_e'+si+' = e'+wid) else $
		                      res = execute('s_e'+si+' = e'+wid+'(*,V)')
		s = strtrim(string(st),2)+' '+y_tit(FIX(wid))
		ENDELSE
	    ENDELSE
            IF (s_cutall eq 0 or s_cutall eq 3) THEN BEGIN
	        WIDGET_CONTROL, bad_id=i, sw_lcut, Set_Value = s
		p_rom_redefine_slider, sw_scut, V+1, smax+1
	    ENDIF ELSE BEGIN
	    IF slide_max lt smax then slide_max = smax
	    IF j ne 0 THEN WIDGET_CONTROL,bad_id=i,sw_lab(j-1),Set_Value=ss
	    ENDELSE
	ENDELSE
    ENDIF
ENDFOR
IF (s_cutall eq 1) THEN BEGIN
    WIDGET_CONTROL, bad_id=i, sw_lcut, Set_Value = 'idx='+strtrim(string(V),2)
    WIDGET_CONTROL, bad_id=i, sw_cutb, /Sensitive
    WIDGET_CONTROL, bad_id=i, sw_scut, Set_Slider_Max = slide_max+1
ENDIF
p_rom_super_filter	; process filtering
p_rom_super_plot,0	; Redraw
if s_cutall eq 3 then s_cutall=0	; end of the redraw calculation
END

; *****************************************************************************
PRO p_rom_super_filter ;*******************************************************
; *****************************************************************************
;
; If filtering is on,  copy filtered s_# into s_p#
; If filtering is off, copy s_# in s_p#
;

common sc_superplot

FOR i=0,6 do BEGIN
    s_s=[0] & si= strtrim(string(i),2)
    IF s_filter then BEGIN
	res = execute('s_s = size(s_'+si+')')
	IF s_s(0) ne 0 THEN BEGIN
	    res = execute('s_p'+si+' = SMOOTH(MEDIAN(s_'+si+',3),3)')
	ENDIF
    ENDIF ELSE $
	    res = execute('s_p'+si+' = s_'+si)
ENDFOR
END

; *****************************************************************************
PRO p_rom_super_done ;*********************************************************
; *****************************************************************************
;
; Called when Done Button is pushed
;
@lamp.cbk
COMMON sc_superplot

IF s_color THEN $	; if color table has been saved
	TVLCT, s_ctred,s_ctgreen,s_ctblue ; restore old color table
if lamp_b1 gt 0 then WIDGET_CONTROL,bad_id=i,sw_id,map=0 ; Hide Super_Plot Window
if lamp_b1 le 0 then WIDGET_CONTROL,bad_id=i,sw_id,/destroy
return
END

; *****************************************************************************
PRO p_rom_cleanup, id
; *****************************************************************************
;
; Called when Superplot window is dying
;
common sc_superplot

IF s_color then TVLCT, s_ctred, s_ctgreen, s_ctblue
END

; *****************************************************************************
PRO p_rom_redefine_slider, wid, value, maxi ;**********************************
; *****************************************************************************
;
; Redefine slider MAXImum and slide VALUE for the WID slider
;
WIDGET_CONTROL, bad_id=i, wid, Set_Slider_Max = maxi
WIDGET_CONTROL, bad_id=i, wid, Set_Value = value
END

; *****************************************************************************
PRO p_rom_send_txt_wd, wid, str ;**********************************************
; *****************************************************************************
;
; Modifie STR value for the WID slider
;

WIDGET_CONTROL, bad_id=i, wid, Set_Value = str
END

; ****************************************************************************
pro suprplot, widx ;************************************************
; ****************************************************************************
;
; Create the Super_Plot interface.
; widx is an optional default workspace number (between 1 and lamp_sys)
;

@lamp.cbk				; call back the lamp common block
common sc_superdid			; Array of boolean Set for psym
common sc_supordid			; For XY limits and there widgets
common sc_superplot			; Call Back Super_Plot block

if (!D.flags and 65536)      eq 0 then print,'set_plot,"X" before using' else $
if xregistered('SUPER_PLOT') le 0 then BEGIN	; If Super_Plot doesn't exist..
    ii=execute("P_MUS,'mus_harp'")				; PLAY a tune
    ;*********************************************Create Widget tree

    ; -------------------------------------------- Variables initialisation
    s_xcut      = 0				; Cutting Y axis is default
    s_filter    = 0				; Filter Off is default
    s_color     = 0				; Black/White mode
    s_show_err  = 0				; Show errors is off
    s_normalize = 0				; Normalization Off
    s_cutall    = 0				; cutting doesn't apply to all
    s_psymb     = 0				; plot symbol (*) or not
    s_xmin      = 0				; No X scale
    s_xmax      = 500				; No X scale
    s_ctred     = 0				; red
    s_ctgreen   = 0				; green
    s_ctblue    = 0				; blue
    s_scratio   = 500.				; scale ratio range
    s_yscale    = s_scratio			; no scale is default
    s_printno   = 1				; next print number is 1
    s_lv	= 0				; plot array for live_plot
    s_var1	= 0
    s_var2	= 0
    s_var3	= 0
    s_var4	= 0
    s_yoffset   = 0				; no offset is default
    s_hid       =[1,1,1,1,1,1,1]		; Set all hided flags on
    s_scl       =[1,1,1,1,1,1,1]		; Set all scaled flags on
    s_sym       =[0,0,0,0,0,0,0]		; Set all psym to 0
    s_err       =[0,0,0,0,0,0,0]		; Set all show_error to 0
    s_hid2      =[0,0,0,0,0,0,0]		; No plot hided (cutall)
    s_off_arr   =[-1,-1,-1,-1,-1,-1,-1]		; Offsetarray Inactive
    s_num_wrk   =[-1,-1,-1,-1,-1,-1,-1]		; Clear workspace number array
    s_cut       =[0,0,0,0,0,0,0]		; cutting axis Y is default
    s_cut_values=[-1,-1,-1,-1,-1,-1,-1]		; Clear cutting values
    s_1=0    & s_2=s_1  & s_3=s_1		; Clear local Workspaces
    s_4=s_1  & s_5=s_1  & s_6=s_1
    s_p1=0   & s_p2=s_1 & s_p3=s_1		; Clear plotted Workspaces
    s_p4=s_1 & s_p5=s_1 & s_p6=s_1

    s_xylv=fltarr(4) & s_xylw=lonarr(6)		; For XY limits + Log10 + Linear

    np=6					; np=number of plots
    sw_lab=lonarr(np) & sw_hid=lonarr(np) & sw_scl=lonarr(np) & sw_drw=lonarr(np)

    IF N_ELEMENTS(widx) eq 0 then widx=0
    IF widx le 0 then s_wid='1' $
	ELSE s_wid= strtrim(string(widx),2)	; sw_wid=current workspace number
    res=execute('s_siz=size(w'+s_wid+')')
    if s_siz(0) eq 1 or s_siz(0) eq 2 then s_hid(0)=0

    ; Get correct slider cut max
    s=[0] & res = execute('s = size(y'+s_wid+')')
    if s(0) eq 2 then nb = s(2)-1 else nb = s(1)-1
    IF nb eq 0 then nb=1

    ; the whole lamp size depending modifications is here
    xsiz	=800				; Width of SuperPlot Draw
    if lamp_siz gt 900 then ysiz=480 else ysiz=380
    if lamp_siz lt 800 then BEGIN	; adapt help text to lamp size
	txt1 = 'Select Workspace you want to see, its cutting axis and cutting value.'
        txt2 = 'Fix it by pushing one of the "Keep as" buttons. Press "HELP" for more'
	xsiz=480 & ysiz=250		; adapt plotting window size
	txt3='Keep'			; adapt text button
	txt4='Hide' & txt5='Scale'
	txt6='Hi'   & txt7='Sc' & txt8='___________'
	sl_size=15
	sl_siz=xsiz
    ENDIF ELSE BEGIN
	txt1  = 'Select Workspace you want to see, its cutting axis and cutting value.'+ $
        	'Fix it by pushing one of the "Keep as" buttons. Press "HELP" for more'
	txt2  = ''
	txt3='Keep as'
	txt4='Hide' & txt5='Scale'
	txt6='Hide' & txt7='Scale' & txt8='________________'
	sl_size=16
	sl_siz=xsiz-100
    ENDELSE

    ; --------------------------------- Create SUPER_PLOT Interface

    sw_id	=WIDGET_BASE  (title='Lamp Super Plot Version Sep 1998',/column, $
				Resource_Name='lampdon')
    sw_l	=WIDGET_LABEL (sw_id,Value=txt1 ,Font=ft_smaller)
    if txt2 ne '' then sw_l=WIDGET_LABEL (sw_id,Value=txt2 ,Font=ft_smaller)
    sw_b00      =WIDGET_BASE  (sw_id  ,/Row)
    sw_b0	=WIDGET_BASE  (sw_b00 ,/Column, /Frame)
    sw_b1	=WIDGET_BASE  (sw_b0  ,/Row)
    sw_sw	=WIDGET_SLIDER(sw_b1,Title='',Minimum=1,Maximum=lamp_sys,Value=s_wid,$
    				Font=ft_b_normal, Xsize=sl_siz-300, YSize=sl_size)
    sw_err	=WIDGET_LABEL (sw_b1,Value='... Select your WorkSpace # ...',YSize=sl_size+15, $
				Resource_Name='discret', Font=ft_b_normal)
    sw_b2	=WIDGET_BASE  (sw_b0  ,/Row)
    sw_scut	=WIDGET_SLIDER(sw_b2,Title='',Minimum=0+1,Maximum=nb+1,/Drag,$
				Font=ft_b_normal,Xsize=sl_siz-300, YSize=sl_size)
    sw_bxy	=WIDGET_BASE  (sw_b2,/Row,/Exclusive)
    sw_btx	=WIDGET_BUTTON(sw_bxy ,Value='X',Font=ft_b_bigger,/No_Release)
    sw_bty	=WIDGET_BUTTON(sw_bxy ,Value='Y',Font=ft_b_bigger,/No_Release)
    sw_lcut	=WIDGET_LABEL (sw_b2,Value='Cut at:'         ,Font=ft_b_bigger)
    sw_lcutv	=WIDGET_LABEL (sw_b2,Value='----------------',Font=ft_b_normal, $
				Resource_Name='discret')
    sw_b        =WIDGET_BASE  (sw_b00, /Frame, /Column)
    sw_lbt      =WIDGET_LABEL (sw_b,Value='Apply cut to',Font=ft_normal)
    sw_bb       =WIDGET_BASE  (sw_b,/Exclusive,/Column)
    sw_btone    =WIDGET_BUTTON(sw_bb,Value='current W',Font=ft_smaller)
    sw_btall    =WIDGET_BUTTON(sw_bb,Value='ALL Wk.Sp.',Font=ft_smaller)

    sw_motio	=WIDGET_BASE  (sw_b00,/column)
    bid		=WIDGET_LABEL (sw_motio,Value='X & Y Cursor'   ,Font=ft_b_normal)
    sw_motx	=WIDGET_LABEL (sw_motio,Value='X= ................',Font=ft_normal)
    sw_moty	=WIDGET_LABEL (sw_motio,Value='Y= ................',Font=ft_normal)

    sw_b3	=WIDGET_BASE  (sw_id  ,/Column,Frame=2)
    sw_b31	=WIDGET_BASE  (sw_b3  ,/Row)

    FOR i=1,np do BEGIN
	sw_b311 	=WIDGET_BASE  (sw_b31, /Column, /Frame)
	sw_b312 	=WIDGET_BASE  (sw_b311,/Row)
	sw_bts		=WIDGET_BUTTON(sw_b312,Value=txt3 ,Font=ft_b_normal, $
				UValue=[-88,355,0,i,sw_scut])
 	sw_drw(i-1)	=WIDGET_DRAW  (sw_b312, XSize=xsiz/18+5, YSize=26)
	sw_b3111=WIDGET_BASE  (sw_b311,/Row, /NonExclusive)
	IF i eq 1 then BEGIN
	sw_hid(0)	=WIDGET_BUTTON(sw_b3111,Value=txt4 ,Font=ft_normal, $
				UValue=[-88,355,1,i], Resource_Name='discret')
	sw_scl(0)	=WIDGET_BUTTON(sw_b3111,Value=txt5 ,Font=ft_normal  , $
				UValue=[-88,355,2,i], Resource_Name='discret')
	ENDIF ELSE BEGIN
	sw_hid(i-1)	=WIDGET_BUTTON(sw_b3111,Value=txt6 ,Font=ft_normal, $
				UValue=[-88,355,1,i], Resource_Name='discret')
	sw_scl(i-1)	=WIDGET_BUTTON(sw_b3111,Value=txt7 ,Font=ft_normal  , $
				UValue=[-88,355,2,i], Resource_Name='discret')
	ENDELSE
	sw_lab(i-1)	=WIDGET_LABEL (sw_b311,Value=txt8, Font=ft_smaller)
    ENDFOR

    sw_b32	=WIDGET_BASE  (sw_b3    ,/Row)
    sw_b321	=WIDGET_BASE  (sw_b32   ,/Column)
    sw_ssc	=WIDGET_SLIDER(sw_b321  ,Title='' ,Minimum=1,Maximum=s_scratio,$
    				Value=s_scratio,/Suppress_Value,/Vertical,/Drag,$
				YSize=ysiz,XSize=sl_size)

    sw_draw	=WIDGET_DRAW  (sw_b32   ,Retain=2,Xsize=xsiz,Ysize=ysiz,/motion_events)
    sw_syoffset	=WIDGET_SLIDER(sw_b32   ,Title='' ,Minimum=0,Maximum=100,Value=0,/Drag,$
				/Suppress_Value,/Vertical,YSize=ysiz,XSize=sl_size)
    sw_b321	=WIDGET_BASE  (sw_b32   ,/Column)
    sw_b321	=WIDGET_BASE  (sw_b321  ,/Column,/frame)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='X & Y Ranges',Font=ft_b_normal)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='Y min',Font=ft_b_normal)
    s_xylw(0)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='Y max',Font=ft_b_normal)
    s_xylw(1)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='     ',Font=ft_b_normal)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='X min',Font=ft_b_normal)
    s_xylw(2)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)
    bidon	=WIDGET_LABEL (sw_b321  ,Value='X max',Font=ft_b_normal)
    s_xylw(3)	=WIDGET_TEXT  (sw_b321  ,Value=''     ,Font=ft_propor ,xsize=7,uvalue=[-88,354,7],/EDITABLE)

    sw_b33	=WIDGET_BASE  (sw_b3    ,/Row)
    sw_basebt	=WIDGET_BASE  (sw_b33  , /NonExclusive)
    sw_btscl0	=WIDGET_BUTTON(sw_basebt, Value='', XSize=sl_size)
    sw_sxmin	=WIDGET_SLIDER(sw_b33,Title='X_min' ,Minimum=0,Maximum=499,/Drag, $
				Value=0 ,/Suppress_Value,Xsize=xsiz/2, $
				YSize=sl_size, Font=ft_b_normal)
    sw_sxmax	=WIDGET_SLIDER(sw_b33,Title='X_max' ,Minimum=1,Maximum=500,/Drag, $
				Value=500,/Suppress_Value,Xsize=xsiz/2, $
				YSize=sl_size, Font=ft_b_normal)
;    sw_basebt	=WIDGET_BASE  (sw_b33  , /NonExclusive)
;    sw_btidx	=WIDGET_BUTTON(sw_basebt, Value='idx');, XSize=sl_size)

    sw_b33	=WIDGET_BASE  (sw_b3   ,/row)
    sw_btco	=WIDGET_BUTTON(sw_b33  ,Value='Reset', Font=ft_b_normal, $
				UValue=[-88,355,3,sw_syoffset,sw_ssc,sw_sxmin,sw_sxmax])
    sw_btp	=WIDGET_BUTTON(sw_b33  ,Value='Print'    , Font=ft_b_normal, $
				UValue=[-88,356,0])
    sw_bta	=WIDGET_BUTTON(sw_b33  ,Value='Annot.' , Font=ft_b_normal)
    sw_b331	=WIDGET_BASE  (sw_b33  ,/Row, /NonExclusive)
    sw_btn	=WIDGET_BUTTON(sw_b331 ,Value='Norm', $
				Font=ft_b_normal,UValue=[-88,355,4])
    sw_btn	=WIDGET_BUTTON(sw_b331 ,Value='Log10', $
				Font=ft_b_normal,UValue=[-88,355,9])
    sw_btf	=WIDGET_BUTTON(sw_b331 ,Value='Filtr', $
				Font=ft_b_normal,UValue=[-88,355,5])
    sw_btc	=WIDGET_BUTTON(sw_b331 ,Value='Color', $
				Font=ft_b_normal,UValue=[-88,355,6])
    sw_pltsymb	=WIDGET_BUTTON(sw_b331 ,Value='Symb', $
				Font=ft_b_normal,UValue=[-88,355,8])
    sw_bterr	=WIDGET_BUTTON(sw_b331 ,Value='Err', $
				Font=ft_b_normal,UValue=[-88,355,7])
    sw_btidx	=WIDGET_BUTTON(sw_b331 ,Value='Linear', $
				Font=ft_b_normal,UValue=[-88,355,10])
    sw_btpng	=WIDGET_BUTTON(sw_b33  ,Value='Png', $
				Font=ft_b_normal,UValue=[-88,356,4])
    sw_bthelp	=WIDGET_BUTTON(sw_b33  ,Value='Help' ,$
 				Font=ft_b_normal,UValue=[-88,591,0])
    sw_btdone	=WIDGET_BUTTON(sw_b33  ,Value='Done' , $
				Font=ft_b_normal,UValue=[-88,356,1])
		 ii=execute('put_logo,sw_b33')

    ; ************Set UValues to permit widget id knowledge in parsed procedures
    WIDGET_CONTROL,bad_id=i,sw_sw ,Set_UValue= $
			[-88,353,0,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_scut ,Set_UValue= $
			[-88,353,1,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_btx ,Set_UValue= $
			[-88,353,2,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_bty ,Set_UValue= $
			[-88,353,3,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_btone ,Set_UValue= $
			[-88,354,4,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    WIDGET_CONTROL,bad_id=i,sw_btall ,Set_UValue= $
			[-88,354,5,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]

    ; --------------------------------- Set correct UValues
    WIDGET_CONTROL, bad_id=i, sw_sxmin   , Set_UValue=[-88,354,0,sw_sxmax]
    WIDGET_CONTROL, bad_id=i, sw_sxmax   , Set_UValue=[-88,354,1,sw_sxmin]
    WIDGET_CONTROL, bad_id=i, sw_ssc     , Set_UValue=[-88,354,2]
    WIDGET_CONTROL, bad_id=i, sw_syoffset, Set_UValue=[-88,354,3]
    WIDGET_CONTROL, bad_id=i, sw_btscl0  , Set_UValue=[-88,354,6,sw_btscl0]

    ; --------------------------------- Construct Widget Tree
    ii=execute("bid=sys_dep('DYNLAB', sw_id, 1)")
    WIDGET_CONTROL,bad_id=i,sw_id, Group_Leader=lamp_b1, /Realize & ii=execute('put_logo')
    ; --------------------------------- Get the Window id of draw widget
    WIDGET_CONTROL,bad_id=i,sw_draw,Get_Value =s_wset
    WIDGET_CONTROL,bad_id=i,sw_draw,Set_UValue=[-88,356,2,sw_motx,sw_moty]
    ; --------------------------------- Set correct UValue for Annotate Button
    if !version.release ge '5.1' then $
    WIDGET_CONTROL,bad_id=i,sw_bta,Set_UValue=[-88,356,3] else $
    WIDGET_CONTROL,bad_id=i,sw_bta,Set_UValue=[-88,346, s_wset ]
    ; --------------------------------- set cut 'Y' button on
    WIDGET_CONTROL,bad_id=i,sw_bty ,/Set_Button
    ; --------------------------------- set btone button on
    WIDGET_CONTROL,bad_id=i,sw_btone ,/Set_Button
    ; --------------------------------- set all SCALED Buttons to on
    FOR j=0,5 do WIDGET_CONTROL,bad_id=i,sw_scl(j) ,/Set_Button
    ; --------------------------------- Draw lines into widget draws
    FOR j=0,5 do BEGIN
	WIDGET_CONTROL,bad_id=i,sw_drw(j) ,Get_Value = w
	wset, w & erase, 255
	PLOTS, 0,13, /Device
	PLOTS, FIndGen(49), SIN(FIndGen(49)/7)*10+13, /Continue, Color = 1, $
		LineStyle = j, /Device
    ENDFOR

    ; --------------------------------- Send all Widget tree to Lamp Parser
    IF lamp_b1 gt 0  THEN $
    XMANAGER, 'SUPER_PLOT' ,sw_id,event_handler='LAMP_EVENT_PARSER', $
    					/Just_Reg, Cleanup='p_rom_cleanup'
    ; --------------------------------- END OF INTERFACE GENESIS

    ; --------------------------------- Generate a slider W event to
    ; --------------------------------- have a plot immediatly
    v = [-88,353,0,sw_scut,sw_lcutv,sw_btx,sw_bty,sw_b2,sw_sw]
    p_rom_super_select,v,1
    IF lamp_b1 le 0  THEN XMANAGER, 'SUPER_PLOT' ,sw_id,$
			  event_handler='LAMP_EVENT_PARSER',Cleanup='p_rom_cleanup'

ENDIF ELSE BEGIN
    ; if color mode is on, set best color table
    IF s_color THEN begin
    	s_ddr	=[100,250, 20, 20,250, 5 ,250]
    	s_ddg	=[100, 20,250, 20,250,250, 10]
    	s_ddb	=[100, 20, 20,250, 20,250,250]
    	TVLCT, s_ddr , s_ddg   , s_ddb ,2 & endif

    WIDGET_CONTROL,bad_id=i,sw_id,map=1	; and show existing Multi_Plot
ENDELSE
RETURN
END
;=============================================================================================================
PRO CHRIS_EVENT, event
;=============================================================================================================
common chr1 ,comment,listd,listp,newdata,newproc,newpath,mnemo,lindex,lindex1 $
            ,last_list,lirinst,lirpath,ttinst,ttgroup,ttproc,ttpath,ttsymbol  $
            ,ttouch,ttmacro,touch,macros,access,site,actif,pth,base0,potn,magn,npar,wall
common didi1,WoR,worb,wort,txtr,txtw,deffont

		 stat=0 & catch,stat
	         if stat  ne 0  then begin catch,/cancel
	         		widget_control,bad_id=i,comment,set_value=strmid(!err_string,0,55)
	         		return & endif
	         		
widget_control,event.id,get_uvalue = uv                                          ;  WIDGET UVALUE ? 
widget_control,comment,set_value   = ''                                          ;  COMMENT area set with blank 

IF n_elements(uv) gt 1 then IF uv(1) eq 391 then begin  p_did_mvlog, event,uv
							return & endif
;-----------------------EXAMPLE------------------------------------------------------------------------------

IF (uv eq 'TEMPLATE')  then begin
	bib=widget_base (title = 'Lamp  template read_tmp.pro' ,resource_name='lamptouch')
	if n_elements(deffont) eq 1 then widget_control,bib,default_font=deffont 
	bob=widget_text (bib,value=txtr,xsize=95,ysize=30,/scroll)
	widget_control,  bib,group_leader=base0,/realize & endif
IF (uv eq 'TEMPLATE2') then begin
	bib=widget_base (title = 'Lamp  template write_tmp.pro',resource_name='lamptouch')
	if n_elements(deffont) eq 1 then widget_control,bib,default_font=deffont 
	bob=widget_text (bib,value=txtw,xsize=95,ysize=30,/scroll)
	widget_control,  bib,group_leader=base0,/realize & endif

IF (uv eq 'WoRtoggle') then begin wort=abs(wort-1) & widget_control,worb,set_value=WoR(wort) & endif
;---------------------- CARRIAGE RETURN ? --------------------------------------------------------------------

IF (uv eq 'CR')    then return                                                   ;  IF <CR> in input fields RETURN 

;---------------------- BUTTON ABORT -------------------------------------------------------------------------

IF (uv eq 'ABORT') then begin

    widget_control,event.top,/destroy                                            ;  ABORT SESSION?..destroy bases 
    return

ENDIF

;-------------INDEX IN DATATYPE LIST-------------------------------------------------------------------------- 

IF (uv eq 'INDEX_DATA') then begin

     widget_control,listp,set_list_select = -1                                   ;  SUPRESS INDEX IN OTHER LIST
     widget_control,newpath,set_value = ''                                       ;  PUT BLANK IN OTHER FIELDS
     widget_control,mnemo,set_value   = ''
     lindex = event.index                                                        ;  INDEX SELECTED ? 
     last_list = 1                                                               ;  LAST LIST SELECTED ? 
     IF (lindex eq 0) then return                                                ;  TOTAL SELECTED ? RETURN
     widget_control,NEWDATA,set_value = strmid(lirinst(lindex),0,10)             ;  SHOW SELECTED DATATYPE  
     widget_control,NEWPROC,set_value = strmid(lirinst(lindex),24,30)            ;  SHOW SELECTED PROCEDURE 

ENDIF

;-------------INDEX IN PATHLIST ------------------------------------------------------------------------------ 

IF (uv eq 'INDEX_PATH') then begin

     widget_control,listd,set_list_select = -1                                   ; EQUAL ABOVE..............
     widget_control,newdata,set_value = ''
     widget_control,newproc,set_value = ''
     lindex1 = event.index
     last_list = 2
     IF (lindex1 eq 0) then return
     widget_control,NEWPATH,set_value = strmid(lirpath(lindex1),20,100)
     widget_control,MNEMO,  set_value = strmid(lirpath(lindex1),0,14)

ENDIF

;-------------BUTTON REMOVE DATA------------------------------------------------------------------------------

IF (uv eq 'REM_DATA') then BEGIN
                                                                                 
     IF(lindex eq -1 or last_list eq 2 or last_list eq 0)then begin              ; if nothing selected    
        widget_control,comment,set_value = 'Select an Item before Remove...'     ; or concerns other list -> return
        return  
     ENDIF               

     IF (lindex eq 0) then return
     IF (lindex eq 1) then begin                                                 ; line 0 or DEMO cannot be removed.....
        widget_control,comment,set_value='DEMO cannot be removed...'
        widget_control,newdata,set_value = ''                             
        widget_control,newproc,set_value = ''
        return
     ENDIF

     widget_control,comment,set_value = strmid(lirinst(lindex),0,12)$
                  +'...Removed...' ;remove from list
     lirinst(lindex) = 'DELETED'                                                 ; flags items to be deleted
     ttinst(lindex)  = 'DELETED'
     ttproc(lindex)  = 'DELETED'
     ttgroup(lindex) = 'DELETED'

     lirinst = lirinst(where(lirinst ne 'DELETED'))                              ; does same lists minus item selected
     ttinst  = ttinst (where(ttinst ne  'DELETED'))     
     ttgroup = ttgroup(where(ttgroup ne 'DELETED')) 
     ttproc  = ttproc (where(ttproc ne  'DELETED'))     
                                                                                
     widget_control,listd,set_value = strmid(lirinst(0:*),0,32)                  ; Show new list until 30 car.
                                                                                 
     widget_control,newdata,set_value = ''                                       ; set entry fields with blank                            
     widget_control,newproc,set_value = ''

ENDIF

;------------BUTTON REMOVE PATH--------------------------------------------------------------------------------

IF (uv eq 'REM_PATH') then begin                                                 ; EQUAL ABOVE..... 

     IF(lindex1 eq -1 or last_list eq 1or last_list eq 0)then begin     
        widget_control,comment,set_value = 'Select an Item before Remove...'
        return
     ENDIF

     IF (lindex1 eq 0) then return

     IF (lindex1 eq 1) then begin                                    
        widget_control,comment,set_value = 'CURRENT PATH cannot be removed...'
        return
     ENDIF

     widget_control,comment,set_value = strmid(lirpath(lindex1),0,10)$
                                        + '...Removed...'
     lirpath (lindex1) = 'DELETED'
     ttpath  (lindex1) = 'DELETED'
     ttsymbol(lindex1) = 'DELETED'

     lirpath  = lirpath (where(lirpath  ne  'DELETED'))
     ttpath   = ttpath  (where(ttpath   ne  'DELETED'))
     ttsymbol = ttsymbol(where(ttsymbol ne  'DELETED'))

     widget_control,listp,set_value   = strmid(lirpath(0:*),0,50)                ; SHOW NEW LIST
     widget_control,newpath,set_value = ''
     widget_control,mnemo,set_value   = ''

ENDIF

;-----------BUTTON ADD DATA------------------------------------------------------------------------------------
IF (uv eq 'ADD_DATA') then BEGIN

      widget_control,newdata,get_value = ndata                                   ; GET DATATYPE 
      widget_control,newproc,get_value = prodata                                 ; GET PROCEDURE
      ndata   = ndata(0) 
      prodata = prodata(0)
      prodata = strlowcase(prodata);                                             ; SET PROCEDURE IN LOWERCASE                                        

      blanc   = strpos(prodata,'.pro')                                           ; ".PRO" EXISTS ?                    
      IF (blanc ne -1) then begin
         prodata=strtrim(strmid(prodata,0,blanc),2)                              ; REMOVE ".PRO"  
      ENDIF

      ndata   = strtrim(strcompress(ndata),2)                                    ; SUPRESS BLANKS IN 2 FIELDS 
      prodata = strtrim(strcompress(prodata),2)                                   
      IF (ndata eq '' or prodata eq '') then begin                               ; IF ONE NOT FILLED ? MESSAGE...
         widget_control,comment,set_value = $
           'COMPLETE fields DATATYPE and READ(write) BY before adding...' 
         return
      ENDIF

      blanc   = strpos(ndata,' ')                                                ; EXISTS GROUP ?
      tgroup  = " "
      IF (blanc ne -1) then begin
         tinst =  strtrim(strmid(ndata,0,blanc),2)                               ; EXTRACT DATATYPE & GROUP
         tgroup = strtrim(strmid(ndata,blanc,strlen(ndata)),2)  
      ENDIF else begin
         tinst  = strtrim(strmid(ndata,0,strlen(ndata)),2)
      ENDELSE
      IF wort then IF strpos(tinst,'.') ne strlen(tinst)-1 then tinst=tinst+'.'
      IF strpos(tinst,'.') eq strlen(tinst)-1 then rb='--Write_by> ' else rb='--Read_by-> '

      tproc   = strtrim(strmid(prodata,0,strlen(prodata)),2)                     ; EXTRACT PROCEDURE
      ndata   = tinst+' '+tgroup

      ex1 = 0 & ex2 = 0 & ex3 = 0 & ipos = 0 
      FOR i1  = 1,n_elements(ttinst)-1 DO begin                                  ; DATATYPE ALREADY EXISTS ?
         IF strupcase(ttinst(i1))eq strupcase(tinst) then begin
                              ex1 = 1 & ipos = i1
                              IF strupcase(ttgroup(i1))eq strupcase(tgroup) then ex2 = 1
                              IF strupcase(ttproc(i1))eq strupcase(tproc) then   ex3 = 1
         ENDIF
      ENDFOR

      IF (strlen(ndata) lt 12) then ndata = ndata+$                               ; DATATYPE MAXIMUM 12 CAR.
                      string(replicate(32b,12 -strlen(ndata)))  
      IF (strlen(ndata) ge 12) then ndata = strmid(ndata,0,12)           
      IF (strlen(tproc) ge 20) then tproc = strmid(tproc,0,20)          

      IF ex1 eq 0 and ex2 eq 0 and ex3 eq 0 then begin                            ; DATATYPE DOES NOT EXIST ?
          widget_control,comment,set_value = ndata+'...Added...'           
          lirinst = [lirinst,ndata+rb+tproc]                 	        	  ; INCREASE ARRAYS.....
          ttinst  = [ttinst,tinst]
          ttproc  = [ttproc,tproc]
          ttgroup = [ttgroup,tgroup]
          position= n_elements(lirinst)-1
          widget_control,listd,set_value    = strmid(lirinst(0:*),0,32)           ; <SHOW NEW LIST....
          widget_control,listd,set_list_top = (n_elements(lirinst)-4)>0           ; TOP OF LIST WITH NEW....
      endif

      IF ex1 eq 1 then begin                                                      ; DATATYPE EXISTS BUT MODIFIED
          widget_control,comment,set_value = ndata+'...Modified...'          
          lirinst (ipos)= ndata+rb+tproc                              		  ; MODIFY ARRAYS
          ttinst(ipos)  = tinst
          ttproc(ipos)  = tproc
          ttgroup (ipos)= tgroup
          widget_control,listd,set_value    = strmid(lirinst(0:*),0,32)           ; <SHOW NEW LIST....
          widget_control,listd,set_list_select = ipos                             ; SET POSITION WITH NEW....
      endif

      widget_control,newdata,set_value = ''                                       ; 2 FIELDS ARE FILLED WITH BLANKS...
      widget_control,newproc,set_value = ''

ENDIF 


;-----------BUTTON ADD PATH-------------------------------------------------------------------------------------
IF (uv eq 'ADD_PATH') then begin

  widget_control,newpath,get_value = pathn					  ; GET DATABASE 
  widget_control,mnemo,  get_value = symbol					  ; GET FULL PATH
  symbol = symbol(0) & pathn = pathn(0)
  symbol = strtrim(strcompress(symbol),2) & pathn = strtrim(strcompress(pathn),2)
      IF (symbol eq '' or pathn eq '') then begin                                 ; ONE FIELD NOT FILLED ? 
         widget_control,comment,set_value = $
            'COMPLETE fields DATABASE and PATH before adding...' 
         return
      ENDIF


      symbol  = strtrim(strmid(symbol,0,strlen(symbol)),2)
      pathn   = strtrim(strmid(pathn ,0,strlen(pathn)),2)      

      ex1 = 0 & ex2 = 0 & ipos = 0
      FOR i1  = 1,n_elements(ttpath)-1 DO begin                                   ; DATABASE ALREADY EXISTS ?
         IF strupcase(ttsymbol(i1))eq strupcase(symbol) then begin
                ex1 = 1 & ipos = i1
                IF strupcase(ttpath(i1))eq strupcase(pathn) THEN ex2 = 1
         ENDIF
      ENDFOR

      IF (strlen(symbol) lt 14) then symbol = symbol+$
           string(replicate(32b,14 -strlen(symbol)))                              ; COMPLETE DATABASE -> 20 CAR.  
      IF (strlen(symbol) ge 14) then symbol = strmid(symbol,0,14)


      IF ex1 eq 0 and ex2 eq 0  then begin                                        ; DATABASE NOT EXISTS ?
          widget_control,comment,set_value = symbol+'...Added...'          
          ttdata   = symbol+'----> '+pathn
          lirpath  = [lirpath,ttdata]                                             ; INCREASE ARRAYS
          ttpath   = [ttpath,strtrim(pathn,2)]
          ttsymbol = [ttsymbol,strtrim(symbol,2)]
      widget_control,listp,set_value   = strmid(lirpath(0:*),0,50)                ; SHOW NEW LIST
      widget_control,listp,set_list_top = (n_elements(lirpath)-4)>0                   ; TOP LIST WITH NEW
      endif

      IF ex1 eq 1  then begin                                                     ; DATABASE EXISTS BUT PATH MODIFIED
          widget_control,comment,set_value = symbol+'...Modified...'          
          lirpath (ipos)= symbol+'----> '+pathn                                   ; MODIFY ARRAYS
          ttpath(ipos)  = strtrim(pathn,2)
          ttsymbol(ipos)= strtrim(symbol,2)
      widget_control,listp,set_value   = strmid(lirpath(0:*),0,50)                ; SHOW NEW LIST
      widget_control,listp,set_list_select = ipos                                 ; HIGHTLIGHT NEW
      endif

      widget_control,newpath,set_value = ''
      widget_control,mnemo,  set_value = ''

ENDIF

;---------------------- BUTTON DONE (WRITES FUNCTION READ_PAR.PRO)----------------------------------------------------------
IF (uv eq 'DONE')  then begin;             

  valid = 0
  on_ioerror, err_write                                                           ;  ERROR ?

  openw,in ,pth+'read_par.pro',/get_lun                                        ;  WRITE NEW FILE
  Printf,in,"FUNCTION READ_PAR , inst ,path, filename, status, datp"
  Printf,in,';-----------------------------------------------------'
  Printf,in,''
  Printf,in,'CASE inst OF ';              <   
  Printf,in,''
  IF (n_elements(ttinst)gt 1) then begin                                          ;  WRITE "CASES OF" DATATYPES,PROCEDURES ....      
    FOR i = 1,n_elements(ttinst)-1 DO begin
     IF strpos(ttinst(i),'.') le 0 then begin
      n=fix(2-strlen(ttproc(i))/8) 
      if n eq 0 then n=1
      bl=string(replicate(9b,n))

      n=fix(1-strlen(ttinst(i)+ttgroup(i))/8)
      if n gt 0 then bl1=string(replicate(9b,n)) else bl1='' 
      Printf,in,"'"+ttinst(i)+"'"+string(9b)+": "+"RETURN,"+ ttproc(i)+bl+"(['"+ttinst(i)+"','"+ttgroup(i)+"']"+bl1+",path,filename,status,datp)"
     ENDIF
    ENDFOR
  ENDIF
  Printf,in,"'init'"+string(9b)+": BEGIN  Status=0"                                         ;  WRITE "CASE OF INIT"........
  Printf,in,''
;.........................................................................................................                                                                                  
  IF (n_elements(ttinst)eq 1) then Printf,in,"  ttinst   = ['demo']'",string(replicate(9b,4))+";exec"        ;  Concatenates DATATYPES
  IF (n_elements(ttinst)ge 1) then begin ;         
      FOR i = 1,n_elements(ttinst)-1 DO begin  
          IF( i eq 1) then Printf,in,"  ttinst   = ['"+ttinst(i)+"']"+string(replicate(9b,2))+";exec"  $
             else Printf,in,"  ttinst   = [ttinst,"+"'"+ttinst(i)+"']"+string(9b)+";exec"
      ENDFOR
  ENDIF
;.........................................................................................................                                                                                  
  Printf,in,''
  IF (n_elements(ttinst)eq 1) then Printf,in,"  ttproc   = ['read_tmp']",string(9b)+";exec";  Concatenates PROCEDURES
  IF( n_elements(ttproc)ge 1) then begin
      FOR i = 1,n_elements(ttproc)-1 DO begin                 
        IF(i eq 1)then Printf,in,"  ttproc   = ['"+ttproc(i)+"']"+string(9b)+";exec" $
          else Printf,in,"  ttproc   = [ttproc,"+"'"+ttproc(i)+"']"+string(9b)+";exec"                             
      ENDFOR
  ENDIF
;.........................................................................................................                                                                                  
  Printf,in,''
  IF (n_elements(ttinst)eq 1) then Printf,in,"  ttgroup  = [' ']"+string(replicate(9b,2))+";exec"            ;  Concatenates GROUPS
  IF (n_elements(ttgroup)ge 1) then begin 
      FOR i = 1,n_elements(ttgroup)-1 DO begin                    
        IF(i eq 1)then Printf,in,"  ttgroup  = ['"+ttgroup(i),"']"+string(replicate(9b,2))+";exec" $
          else Printf,in,"  ttgroup  = [ttgroup,"+"'"+ttgroup(i)+"']"+string(9b)+";exec"
      ENDFOR
  ENDIF
;.........................................................................................................                                                                                  
  Printf,in,''
      Printf,in,"  ttsymbol = ['Current Path']"+string(replicate(9b,3))+";exec"                              ;  Concatenates SYMBOLS
  IF (n_elements(ttsymbol)ge 2) then begin
      FOR i = 2,n_elements(ttsymbol)-1 DO begin
      if strlen(ttsymbol(i)) ge 14 then tabul=string(9b) else tabul=string(replicate(9b,2))
            Printf,in,"  ttsymbol = [ttsymbol,"+"'"+ttsymbol(i)+"']"+tabul+";exec"     
      ENDFOR
  ENDIF
;.........................................................................................................                                                                                  
  Printf,in,''
      Printf,in,"  ttpath   = ['.']"+string(replicate(9b,4))+";exec"                                         ;  Concatenates PATHS
  IF (n_elements(ttpath)ge 2) then begin
      FOR i = 2,n_elements(ttpath)-1 DO begin
      if strlen(ttpath(i)) ge 10 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,3))
            Printf,in,"  ttpath   = [ttpath,"+"'"+ttpath(i)+"']"+tabul+";exec"                             
      ENDFOR
  ENDIF
;.........................................................................................................                                                                                  
  widget_control,touch,get_value=touch_v                                          ;  Get TOUCH_BASE location (if empty then default)     
  touch_v = touch_v(0)
  if(touch_v eq '')then touch_v="/home/cs/TOUCH_BASE"
  touch_v = strtrim(strcompress(touch_v))
  Printf,in,''                                             
      ;if strlen(touch_v) ge 16 then tabul=string(replicate(9b,3)) else tabul=string(replicate(9b,2))
       Printf,in,"  ttouch   = '"+touch_v+"' ;exec"              
;.........................................................................................................                                                                                  
  widget_control,macros,get_value=macro_v                                         ;  Get USER_MACROS location (if empty then default)  
  macro_v = macro_v(0)
  macro_v = strtrim(strcompress(macro_v),2)        
  Printf,in,'';                                                    
      
     ;if strlen(macro_v) gt 16 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,3)) 
      Printf,in,"  ttmacro  = '"+macro_v+"' ;exec"            
;.........................................................................................................                                                                                  
  widget_control,access,get_value=access_v                                        ;  Get DATA_ACCESS location (if empty then default)   
  access_v  = access_v(0)
  access_v  = strlowcase(access_v)                                                ;  SET IN LOWERCASE
      blanc = strpos(access_v,'.pro');                    
      IF (blanc ne -1) then begin
         access_v = strtrim(strmid(access_v,0,blanc),2)                           ;  REMOVE ".PRO"  
      ENDIF
  access_v = strtrim(strcompress(access_v))       
  Printf,in,'';                                                    
      if strlen(access_v) gt 16 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,4)) 
      Printf,in,"  ttaccess = '"+access_v+"'"+tabul+";exec"            
;.........................................................................................................                                                                                  
  widget_control,site,get_value = site_v                                          ;  Get SITE_DISPLAY function (if empty then default)  
  site_v = site_v(0)
  site_v = strlowcase(site_v)                                                     ;  SET IN LOWERCASE  
  if(site_v eq '')then site_v = " "
      blanc = strpos(site_v,'.pro')                                               ;  REMOVE ".PRO"                   
      IF (blanc ne -1) then begin
         site_v = strtrim(strmid(site_v,0,blanc),2)                               
      ENDIF
  if(site_v ne ' ')then site_v =  strtrim(strcompress(site_v))                          
  Printf,in,'';                                                    
 
      if strlen(site_v) gt 12 then tabul=string(replicate(9b,2)) else tabul=string(replicate(9b,4)) 
      Printf,in,"  ttsite   = '"+site_v+"'"+tabul+";exec"            
  Printf,in,''; 
;.........................................................................................................                                                                                  
  widget_control,magn,get_value = magic
  magic  = strtrim(magic(0),2)
  if (magic lt '2') or (magic gt '9') then magic='6'
      Printf,in,"  ttmagi   = '"+magic +"' "+";exec" 
      Printf,in,''      
;.........................................................................................................                                                                                  
  widget_control,wall,get_value = fwall
  fwall  = strtrim(fwall(0),2)
      Printf,in,"  ttwall   = '"+fwall +"' "+";exec" 
      Printf,in,''      
;.........................................................................................................                                                                                  
  widget_control,npar,get_value =   npars
  on_ioerror,mispar   & npars =long(npars(0)) & mispar: on_ioerror,err_write
  npars=npars>40<10000 & npars=strtrim(string(npars),2)
      Printf,in,"  ttpars   = '"+npars +"' "+";exec" 
      Printf,in,''      
;.........................................................................................................                                                                                  
      Printf,in,"  datp     = {a:ttinst,  b:ttproc,  c:ttgroup,  $"               ; CREATE STRUCTURE DATP
      Printf,in,"              d:ttsymbol,e:ttpath,  f:ttouch,   $"
      Printf,in,"              g:ttmacro, h:ttaccess,i:ttsite,j:ttmagi,k:ttwall,l:ttpars}"
;.........................................................................................................                                                                                  
  Printf,in,''
  printf,in,"  return,0"
  Printf,in,''
  Printf,in,'         END'
  Printf,in,''
  Printf,in,'ELSE :'
  Printf,in,''
  Printf,in,'ENDCASE'
  Printf,in,''
  Printf,in,"Status = 14"
  Printf,in,''
  Printf,in,'return,0'
  Printf,in,''
  Printf,in,'END'
  Printf,in,''
  valid = 1
  FREE_LUN,in                                                                     ; END WRITE READ_PAR.PRO.......... 
  
  if actif eq 1 then begin P_NEWCUST, /fromcust
  			   n=n_elements(ttinst)
;  			   if n gt potn then i=sys_dep      ('POT','',n-1)
			   potn=n & endif
 
   err_write: if (valid eq 0) then widget_control,comment,set_value=$              ; TEST OF WRITING:
                pth+"READ_PAR.PRO : unable to write !!!"
  if(valid eq 1)then WIDGET_CONTROL,event.top,/DESTROY
  
ENDIF

END
;===============================================================================================================
;                                 END OF EVENT
;===============================================================================================================






;***************************************************************************************************************
;                                 BEGIN CUSTOMIZ
;***************************************************************************************************************

PRO CUSTOMIZ ,inter

@lamp.cbk
common chr1 ;comment,listd,listp,newdata,newproc,newpath,mnemo,lindex,lindex1 $
            ;last_list,lirinst,lirpath,ttinst,ttgroup,ttproc,ttpath,ttsymbol  $
            ;ttouch,ttmacro,touch,macros,access,site,actif,pth,base0,potn,magn,npar,wall
common didi1;WoR,worb,wort,txtr,txtw,deffont

if xregistered('CUSTOMIZ') gt 0 then widget_control,bad_id=i,base0,map=1 $
else begin

actif = n_elements(inter)
if n_elements(lamp_asite) gt 0 then if lamp_asite eq 'customiz' then actif=1
if n_elements(lamp_siz)   eq 0 then lamp_siz=800

if(actif ne 0) then pth=sys_dep      ('NEWSUB',lamp_dir,'lamp_mac') else pth=''
if(actif ne 0) then deffont=ft_propor

lirinst   =  ' '                                                
lirpath   =  ' '
ttinst    = [' ','demo']
ttgroup   = [' ',' ']
ttproc    = [' ','read_tmp']
ttsymbol  = [' ','Current Path']
ttpath    = [' ','.']                                                             ; CURRENT PATH IS SET....
ttouch    =  ' '
if sys_dep("MACHINE") eq "unix" then ttouch = '/home/cs/TOUCH_BASE'            ; DEFAULT TOUCH_BASE IS SET 
if sys_dep("MACHINE") eq "vms"  then ttouch = 'dka0:[lamp.demo.TOUCH_BASE]'
ttmacro   =  ''  	                                                    ; DEFAULT MACROS IS SET
if sys_dep("MACHINE") eq "unix" then ttmacro= '~lambda/macros'
if sys_dep("MACHINE") eq "vms"  then ttmacro= 'dka0:[macros]'
if sys_dep("MACHINE") eq "mac"  then ttmacro= 'disk:macros'
if sys_dep("MACHINE") eq "win"  then ttmacro= 'c:\lambda\macros'
ttaccess  =  'rdfilter'
WoR       = ['Read  by','Write by'] & wort=0
ttsite    =  'language_help'
ttmagi	  =  '6'
ttwall	  =  ''
ttpars	  =  '120'

last_list =  0                                                                    ; LAST LIST SELECTED
lindex    = -1                                                                    ; INDEX NEVER TOUCHED
lindex1   = -1
valid     =  0                                                                    ; PARAMETER I/O ERRORS

;--------------------READ FILE READ_PAR.PRO --------------------------------------
 
t = findfile (pth + 'read_par.pro',count = exist)
ptth=pth
if (exist eq 0) then begin pth=!dir    +sys_dep("DIVIDER")
t = findfile (pth + 'read_par.pro',count = exist) & endif
if (exist eq 0) then begin status=23 & datp=0
		if ptth ne '' then begin  t = findfile (ptth + '*',count = cnt)
		                          if cnt gt 0 then pth=ptth & endif
                ii=execute('bid=read_par("init","","",status,datp)')
                if status eq 0 then begin ttinst  =datp.a & ttproc  =datp.b & ttgroup=datp.c
                                          ttsymbol=datp.d & ttpath  =datp.e & ttouch =datp.f
                                          ttmacro =datp.g & ttaccess=datp.h & ttsite =datp.i
                                          ttmagi  =datp.j & ttwall  =datp.k & ttpars =datp.l
endif     &     endif
valid=2
on_ioerror, no_file & in=-1						; FLAG ERROR
   OPENR,in,pth+'read_par.pro',/get_lun                                        ; OPEN...                              
	ligne=' '
   	on_ioerror, end_file
        while (not EOF(in)) DO begin                                
            readf,in,ligne                                                        ; READ UNTIL END_OF_FILE...
            IF (strpos(ligne,';exec')   ge 0) THEN r=execute(ligne)               ; CAN TRANSLATE LINE IN ARRAY    
        ENDWHILE                                                                  ; END READ
        end_file:FREE_LUN,in                                                           ; CLOSE FILE

   valid=3
   
   on_ioerror, no_write & in=-1
   OPENW,in,pth+'read_par.pro',/APPEND,/get_lun
   	valid=1
   no_write:if in gt 0 then FREE_LUN,in

no_file:

IF (ttinst(0) ne ' ') then begin                                                  ; FIRST ELEMENT OF ARRAYS
       ttinst  = [' ',ttinst]                                                  ; IS ALWAYS A BLANK
       ttproc  = [' ',ttproc]
       ttgroup = [' ',ttgroup]
ENDIF

IF (ttpath(0) ne ' ') then begin                                                  ;   "   "    "                                         
       ttpath  = [' ',ttpath]                                               
       ttsymbol= [' ',ttsymbol]
ENDIF

;if (ttouch(0)   ne ' ') then ttouch  = ttouch(0)                                  ;   "   "    "
;if (ttmacro(0)  ne ' ') then ttmacro = ttmacro(0)
;if (ttaccess(0) ne ' ') then ttacces = ttaccess(0)
;if (ttsite(0)   ne ' ') then ttsite  = ttsite(0)

potn=n_elements(ttinst)
IF (potn ge 1) then begin                                           ; MAKES LIST OF DATATYPES
   FOR ij = 1,n_elements(ttinst)-1 DO begin
       l1 = strlen(ttinst(ij))
       l2 = strlen(ttgroup(ij))
       l3 = l1+l2+1
       if strpos(ttinst(ij),'.') ne strlen(ttinst(ij))-1 then rb='--Read_by-> ' else rb='--Write_by> '
       if l3 lt 12 then t1 = ttinst(ij)+' '+ttgroup(ij)+string(replicate(32b,12-(l3)))+$
                             rb+ttproc(ij) else t1 = ttinst(ij)+' '+ttgroup(ij)
       lirinst = [lirinst,t1]
   ENDFOR
ENDIF

IF (n_elements(ttpath) ge 1) then begin                                           ; MAKES LIST OF PATHNAMES
   FOR ij = 1,n_elements(ttpath)-1 DO begin
       l1 = strlen(ttsymbol(ij))
    if(l1 lt 14)then lirpath=[lirpath,ttsymbol(ij)+string(replicate(32b,14-l1))+$
          '----> '+ttpath(ij)]
    if(l1 eq 14)then lirpath=[lirpath,ttsymbol(ij)+'----> '+ttpath(ij)]
   ENDFOR
ENDIF


;-------------------TEXTS OF HELP------------------------------------------------------
explain1  = 'Enter label for datatype  to appear in LAMP menus in the field DATATYPE '   
explain1b = '      you   may enter  an optional  group   for datatype (label group)'   
explain2  = 'Enter name  of  procedure to read   datatype      in the field READ  BY'                                         
explain22 = 'Enter name  of  procedure to write  datatype      in the field WRITE BY'                                         
explain3  = 'Enter label for database  to appear in LAMP menus in the field DATABASE'
explain4  = 'Enter Path  to  database  to appear in LAMP menus in the field FULL PATH'

explain5  = 'Enter full path to the directory containing user macros and to the Catalog'
explain6  = 'Enter the name of procedure mapped to the Self... button '
explain7  = 'and one of the DISPLAY FUNCTIONS button'

;--------------------WIDGETS------------------------------------------------------------

base0        =  widget_base  (/column,title = 'Lamp  CUSTOMIZE',/frame,$
				      resource_name='lamptouch')

if actif ne 0 then widget_control,bad_id = ii,base0,default_font = deffont                       ; INSTALL FONT 

 base01      =  widget_base  (base0  ,/row)
  txt1       =  widget_label (base01 ,value = explain1)
 base01      =  widget_base  (base0  ,/row)
  txt1       =  widget_label (base01 ,value = explain1b)

 base01      =  widget_base  (base0  ,/row)
  txt2       =  widget_label (base01 ,value = explain2)
  template   =  widget_button(base01, value='(see  read_tmp)',uv='TEMPLATE')
 base01      =  widget_base  (base0  ,/row)
  txt2       =  widget_label (base01 ,value = explain22)
  template   =  widget_button(base01, value='(see write_tmp)',uv='TEMPLATE2')

 base01      =  widget_base  (base0  ,/row)
  txt3       =  widget_label (base01 ,value = explain3)  
 base01      =  widget_base  (base0  ,/row)
  txt4       =  widget_label (base01 ,value = explain4)  
  
base001      =  widget_base  (base0  ,/row)
  BUT_ABORT  =  widget_button(base001,value = 'ABORT' ,uvalue = 'ABORT')
		if (actif ne 0) then put_logo     ,base001
  BUT_DONE   =  widget_button(base001,value = 'APPLY ',uvalue = 'DONE',/frame)
  nul0       =  widget_label (base001,value = '   ')
  COMMENT    =  widget_label (base001,value = '   ',xsize=lamp_siz/2 + 30)
  nul0       =  widget_label (base001,value = ' ')

base1	     =  widget_base  (base0  ,/row)
  base11     =  widget_base  (base1  ,/column,/frame)
  LISTD      =  widget_list  (base11 ,value = lirinst,uvalue = 'INDEX_DATA',ysize = 7)
  base12     =  widget_base  (base1  ,/column,/frame)
  LISTP      =  widget_list  (base12 ,value = strmid(lirpath(0:*),0,50),$
                                           uvalue = 'INDEX_PATH',ysize = 7)
base2        =  widget_base  (base11 ,/row)
  n1         =  widget_label (base2  ,value = 'Datatype :')
  NEWDATA    =  widget_text  (base2  ,/editable,value = '',uvalue = 'CR',xsize = 10)         
  REM_DATA   =  widget_button(base2  ,value = 'Remove',uvalue = 'REM_DATA')
  ADD_DATA   =  widget_button(base2  ,value = 'Update',uvalue = 'ADD_DATA')
base21       =  widget_base  (base11 ,/row)
  worb       =  widget_label (base21 ,value = WoR(wort)+' :')
  NEWPROC    =  widget_text  (base21 ,/editable,value = '',uvalue = 'CR',xsize = 20)           
  toggle     =  widget_button(base21 ,value ='R<-->W', uvalue='WoRtoggle')

base3        =  widget_base  (base12 ,/row)
  n4         =  widget_label (base3  ,value = 'Database :')
  MNEMO      =  widget_text  (base3  ,/editable,value = '',xsize = 14,uvalue = 'CR')
  REM_PATH   =  widget_button(base3  ,value = 'Remove',uvalue = 'REM_PATH')
  ADD_PATH   =  widget_button(base3  ,value = 'Update',uvalue = 'ADD_PATH')

base31       =  widget_base  (base12 ,/row)
  n3         =  widget_label (base31 ,value = 'Full Path:')
  NEWPATH    =  widget_text  (base31 ,/editable,value = '',xsize = 40,uvalue = 'CR')

base350	     =  widget_base  (base0  ,/row)
bid	     =  widget_label (base350,value = 'Magic_number:')
magn	     =  widget_text  (base350,value =  ttmagi,xsize=4,ysize=1,/editable,uvalue = 'CR')
bid	     =  widget_label (base350,value = '(Char.lenght: accessing data by numor means'$
					     +' numor is in the filename)')
base350	     =  widget_base  (base0  ,/row)
bid	     =  widget_label (base350,value = 'FTP proxy (Firewall):')
wall	     =  widget_text  (base350,value =  ttwall,xsize=8,ysize=1,/editable,uvalue = 'CR')

bid	     =  widget_label (base350,value = '  -----  ')
bid	     =  widget_label (base350,value = 'Data Parameters maxi_length:')
npar	     =  widget_text  (base350,value =  ttpars,xsize=6,ysize=1,/editable,uvalue = 'CR')

base400      =  widget_base  (base0  ,/column,/frame)
base411      =  widget_base  (base400,/row)
  n24        =  widget_label (base411,value = 'User macros location:')
  MACROS     =  widget_text  (base411,/editable,xsize = 20,value = ttmacro,uvalue = 'CR')
  n25        =  widget_label (base411,value = 'TOUCH_BASE location :')
  TOUCH      =  widget_text  (base411,/editable,xsize = 20,value = ttouch ,uvalue = 'CR')
  txt5       =  widget_label (base400,value = explain5)

base500      =  widget_base  (base0 ,/column,/frame)
base511      =  widget_base  (base500 ,/row)
  n26        =  widget_label (base511,value = 'Procedure for Self... button:')
  ACCESS     =  widget_text  (base511,/editable,xsize = 10,value = ttaccess,uvalue = 'CR')
  n27        =  widget_label (base511,value = 'Procedure for site display function:')
  SITE       =  widget_text  (base511,/editable,xsize = 10,value = ttsite  ,uvalue = 'CR')

  txt6       =  widget_label (base500,value = explain6)
  txt7       =  widget_label (base500,value = explain7)

   		   if actif ne 0 then bid=sys_dep      ('DYNLAB',BASE0,0)
		   WIDGET_CONTROL,BASE0,/REALIZE & if (actif ne 0) then put_logo
leader=0
if  n_elements(lamp_b1) eq 1 then leader=lamp_b1
if (actif ne 0) and (leader gt 0) then WIDGET_CONTROL,BASE0,GROUP_LEADER=leader

one_error:
IF (valid eq 0)THEN widget_control,comment,set_value = 'problem reading '+pth+'READ_PAR.PRO'
IF(valid eq 1) THEN widget_control,comment,set_value = 'OK Reading '     +pth+'READ_PAR.PRO'
IF(valid eq 2) THEN widget_control,comment,set_value = pth+'READ_PAR.PRO is a new file....'
IF(valid eq 3) THEN widget_control,comment,set_value = pth+'READ_PAR.PRO access denied !!!'

XMANAGER,'CUSTOMIZ', BASE0,EVENT_HANDLER = 'CHRIS_EVENT',/just_reg

txtw=[$
"pro write_tmp, FileName , Data , XC=x, YC=y , ZC=z ,E=e , N=n      $",$
"                               , PR=p, PV=pv, PAR_TXT=p_txt        $",$
"                               , W_tit=wt   , X_tit=xt  , Y_TIT=yt $",$
"                               , Z_tit=zt   , OTHER_TIT=ot",$
";** *********",$
";**",$
";**	Standard call for a data-write procedure called by LAMP.",$
" ",$
";**	Keywords:",$
";**           XC       = [vector of x coordinates.]",$
";**           YC       = [vector of y coordinates.]",$
";**           ZC       = [vector of z coordinates.]",$
";**           W_TIT    =   main title",$
";**           X_TIT    = x axis title",$
";**           Y_TIT    = y axis title",$
";**           Z_TIT    = z axis title",$
";**           OTHER_TIT=    sub title",$
";**           N        = monitors",$
";**           PR       = vector of parameter values",$
";**           PAR_TXT  = string array of text associated to PR (same size)",$
";**           PV       = an array of any dimensions containing other parameter values",$
";**           E        = the errors associated to DATA (same size) or 0",$
" ",$
"CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif",$
"ON_IOERROR,mis",$
" ",$
"OPENW ,unit, FileName, /get_lun",$
" ",$
"WRITEU,unit, Data    ;Write the Data (and parameters in the way you want).",$
" ",$
"FREE_LUN,unit",$
"return",$
" ",$
"mis:print,!err_string",$
"end"]

txtr=[$
"function read_tmp, INST , PATH , FILENAME , STATUS , DATP",$
";******* ********",$
";**",$
";**	Standard call for a data-read function interfacing LAMP.",$
"",$
";**	Return of the function",$
";**	 DATA     is an array of any dimensions and type containing the data values (spectra).",$
"",$
";**	Input  parameters:",$
";**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).",$
";**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).",$
";**	 INST(2)  is '1' if raw  button is set.",$
";**	 PATH     is the full path where to find the data (string defined in customize tables).",$
";**	 FILENAME is the name of the data file.",$
";**             if FILENAME(1) exists, this is the requested image number in the file",$
";**                                    entered as  file.ext{3} (for image 3).",$
";**	Output parameters:",$
";**	 STATUS   is the returned error code you can choose from the following list:",$
";**           0 =' Successfull read'",$
";**           1 =' Client/server on local  node not established'",$
";**           2 =' Client/server on router node not established'",$
";**           3 =' The local  node cannot access the server node'",$
";**           4 =' The router node cannot access the server node'",$
";**           5 =' VME memory read error'",$
";**           7 =' Sequence error in data transfer'",$
";**           9 =' Parameter error'",$
";**           10=' Router is busy with other transfer'",$
";**           11=' Cant open the file or file not found'",$
";**           13=' Data file incomplete'",$
";**           14=' Bad instrument data definition'",$
";**           24=' Cant read the file'.",$
";**",$
";**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)",$
";**           DATP.X        = vector of x coordinates.",$
";**           DATP.Y        = vector of y coordinates.",$
";**           DATP.Z        = vector of z coordinates.",$
";**           DATP.W_TIT    =   main title",$
";**           DATP.X_TIT    = x axis title",$
";**           DATP.Y_TIT    = y axis title",$
";**           DATP.Z_TIT    = z axis title",$
";**           DATP.OTHER_TIT=    sub title",$
";**           DATP.N        = monitors",$
";**           DATP.P        = vector of parameter values, max dim is defined in customize.",$
";**           DATP.PAR_TXT  = string array of text associated to DATP.P (same size)",$
";**           DATP.PV       = an array of any dimensions containing other parameter values",$
";**           DATP.E        = the errors associated to DATA (same size)",$
";**           DATP.TIME     = string date of the experiment.",$
"",$
" DATA  =0",$
" STATUS=7",$
" CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif",$
"",$
" ON_IOERROR, no_file",$
" OPENR,unit, PATH+FILENAME,/get_lun                   ;Open the data file",$
"",$
"      ON_IOERROR, read_err",$
"      STATUS=13",$
"      DATA  =FLTARR(40,40)                            ;Make a floating array",$
"      READU,unit,DATA                                 ;Read the data",$
"      STATUS=0                                        ;Status is ok",$
";     ********",$
"          xv       =  INDGEN(40)*2 +15                ;Make X coordinates",$
"          wt       =' Template_read test '",$
"          xt       =' This is the X axis '",$
"          par      = [        3.0       ,        5.5        ]",$
"          ptxt     = ['First  parameter','Second parameter' ]",$
"          pall     =  INDGEN(40,6)",$
"",$
"      DATP={X:      xv,    $                          ;Pass into the DATP structure",$
"            W_TIT:  wt,    $                          ;those variables which were read-in",$
"            X_TIT:  xt,    $",$
"            P:      par,   $",$
"            PAR_TXT:ptxt,  $",$
"            PV:     pall   }",$
";     **********************",$
"",$
" read_err:  FREE_LUN,unit                             ;Free the unit number",$
" no_file:",$
"",$
" RETURN, DATA                                         ;Return the data values",$
";************",$
" END"]

IF ACTIF EQ 0 THEN XMANAGER
endelse
return
END
;***************************************************************************************************************
;                                       END CUSTOMIZ 
;***************************************************************************************************************
pro don_init_prog_mac ,flg
;** *****************
;**
@dons.cbk
@lamp.cbk

 common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
		wbeside,vfl,styles,w4d,smoo,vff

;Read in user command list
         on_ioerror, end_fc
	 in=-1
	 fifi='lamp.cds' & ii  = findfile(fifi,count=n)
	 if  n eq 0 then begin
	  CATCH,stat
	  if stat eq 0 then begin
	   hhm= sys_dep('HOME') & cd,hhm,current=mee & cd,mee,current=hmm
	   if strmid(hhm,strlen(hhm)-1,1) ne lamp_dvd then hhm=hhm+lamp_dvd
	   fifi=hmm+fifi & endif
 	 endif
         openr,in,fifi,/get_lun
	 n=n_elements(prog_mac)
         bstr=''
         for k=0,5 do begin
             readf,in,bstr
             prog_mac(k)=bstr
	     if flg eq 1 then $
	        if prog_txt(k) gt 0 then widget_control,prog_txt(k),bad_id=i,set_value=bstr
         endfor
         if flg eq -1 then begin
         	readf,in,bstr & bstr=''
         	readf,in,bstr & if bstr ne '' then lamp_devps=bstr
         	readf,in,bstr & bstr=''
         	readf,in,rx,rz,nlv,bstr
         	readf,in,bstr & bstr='' & s1=0 & s2=0 & s3=0 & s4=0
         	readf,in,s1,s2,s3,s4,bstr
         	styles(0,0)=s1 & styles(1,0)=s2 & styles(2,0)=s3 & !P.psym=s4
         	readf,in,bstr & bstr=''
         	readf,in,bstr & if strcompress(bstr) gt ' ' then begin
         				      inst_value=strtrim(bstr,2)
					      RDSET,inst=inst_value
         				     ;if b_labins(0) gt 0  then widget_control,bad_id=i,b_labins(0),set_value=inst_value
         				      endif
         	readf,in,bstr & bstr='' & s1=-1
         	readf,in,s1,bstr & if (s1 ge 0) and (s1 le 40) then tcol=s1
         	readf,in,bstr & bstr='' & s1=-1
         	readf,in,s1,bstr & if (s1 ge 0) then smoo=s1
		
         	readf,in,bstr
         	readf,in,bstr ;Free
         	readf,in,bstr ;Free
         	readf,in,bstr
		
         endif else for i=1,16 do readf,in,bstr
	 
         for k=6,n-1 do begin
             readf,in,bstr
             prog_mac(k)=bstr
         endfor
	 
end_fc:  if in gt 0 then free_lun,in

for i=0,n_elements(lamp_ins)-1 do if inst_value eq lamp_ins(i) then $
    				     inst_group =  lamp_grp(i)
return
end
;
;
pro p_don_init_var ,prog_base ,mess_base
;** **************
;**       Sets up variables
@lamp.cbk
@dons.cbk
	n=22
	if n_elements(prog_base) eq n then prog_txt =prog_base ;!!! why not
	prog_txt =lonarr(n) ;!!!
	
	if n_elements(mess_base) eq 1 then l_message=mess_base
	last_w  =1
	nwk     =1
	ifixed  =0
	formtxt =0
	his_info=0
	rawmanip=0
	mac_raw =0
	prog_mac=strarr(n_elements(prog_txt))
		prog_mac(0)='setcol,27'
		prog_mac(2)='w2=total(w1,2) ;X projection'
		prog_mac(3)='w3=w2-shift(w2,1) &  w3(0)=0'
		prog_mac(4)='x_tit(3)="Derivative" & x3=findgen(n_elements(w3))'
	don_init_prog_mac  ,1
return
end
;
pro p_don_create ,base
;** ************
;**       Sets up Formula windows etc

@lamp.cbk
@dons.cbk
;
	p_don_init_var

	formu =['Enter formula below','']
	umac='User'
	if GEORGE eq 1 then  begin dou  =" STATUS CONTROL" & formu(0)='' & umac='Dial'
	                     baso =widget_base(base  ,/row)
	                     baso1=widget_base(baso  ,/column)
	                     baso1=widget_base(baso1 ,/column)
	                     baso2=widget_base(baso  ,/column)
	                     baso2=widget_base(baso2 ,/column)
	                     basoo=widget_base(baso  ,/column)
	                     	basii=widget_base(basoo ,/row)
	                     	baso3=widget_base(basii ,/column)
	                     	basoL=widget_base(basoo)
	                     base =widget_base(map=0,group_leader=lamp_b1)
	endif     else       dou  =" MANIPULATIONS"
;
; Help and Macro buttons
;
; Text area for formula entry
;
	bar0        =widget_base(base   ,/row)
	bar001	    =widget_base(bar0   ,/column)
	macro_area_a=widget_base(bar0)

; First Column
; ***** ******
	bar01		=widget_base  (bar001 ,/row)
	bar1		=widget_base  (bar01  ,/column)

	bar1_1	=widget_base  (bar1   ,/row)
	btit1		=widget_label (bar1_1 ,font=ft_biggest,value=dou)
	bar1_x 	=widget_base  (bar1_1 ,/nonexclusive)
	if sys_dep('MAP') ne -1 then $
	mac_raw	=widget_button(bar1_x ,value='raw',font=ft_smaller,resource_name='discret') else $
	mac_raw	=widget_button(bar1_x ,value='raw',font=ft_smaller)
	bhelp		=widget_button(bar1_1 ,font=ft_normal ,value='?')

	if lamp_siz lt 900 then begin nbli1=2 & nbli2=2  & labx =350
	   formtxt	=widget_text  (bar1   ,font=ft_b_bigger,xsize=40,ysize=nbli1,/editable,value=formu)
	endif		   else begin nbli1=3 & nbli2=2  & labx =562
	   formtxt	=widget_text  (bar1   ,font=ft_b_bigger,xsize=40,ysize=nbli1,/editable,value=formu,/scroll)
	endelse
;
	bar2		=widget_base  (bar01 ,/column)
	mac_but	=widget_button(bar2   ,value=umac+' Macros?')
	idlbut	=widget_button(bar2   ,value='The Journal')
	lamp_don	=[lamp_don,idlbut]
	up_button	=widget_button(bar2   ,value='Data Params')
	lamp_don	=[lamp_don,up_button]
; *****
	l_message	=widget_label (bar001 ,font=ft_b_bigger ,xsize=labx,value='                 ')
; *****
	bar01		=widget_base  (bar001 ,/row)
	his_info	=widget_text  (bar01  ,font=ft_b_bigger ,xsize=40,ysize=nbli2,/scroll,$
					  value=lims(1:*))
	bar2		=widget_base  (bar01  ,/column)
	bar2_1	=widget_base  (bar2   ,/column,/exclusive)
	info_but	=widget_button(bar2_1 ,value='W Min,Max ' ,/no_release)
	his_but	=widget_button(bar2_1 ,value='W History ' ,/no_release)

; Second Column
; ****** ******
	prog_buttons
; Third Column
; ****** *****
	machin= sys_dep('MACHINE')
	if  not sys_dep('MATLAB') then $
	if ((lamp_siz ge 800) and (lamp_siz le 950) and (machin eq 'win')) or $
	   ((lamp_siz ge 800) and (GEORGE eq 1)) or $
	   ((lamp_siz ge 800) and (lamp_siz lt 900))                       then begin
;	   ((lamp_siz ge 800) and (lamp_siz lt 900) and (machin eq 'mac')) then begin
		   w0=2 & LOGO,w0 & pax1=size(w0)
		   if GEORGE eq 1 then bose=widget_base (basii,/column) $
		   else                bose=widget_base (bar0 ,/column)
		                       bose=widget_base (bose ,/frame,/row)
		                lamp_ben(6)=widget_draw (bose ,retain=2,xsize=pax1(1),ysize=pax1(2),/button_event)
	endif
;
; Controls
        widget_control,bhelp     ,bad_id=i,set_uvalue=[-88,588,0,0]
        widget_control,formtxt   ,bad_id=i,set_uvalue=[-88,200,0,0]
        widget_control,idlbut    ,bad_id=i,set_uvalue=[-88,396,0]
        widget_control,his_but   ,bad_id=i,set_uvalue=[-88,202,0,0]
        widget_control,mac_but   ,bad_id=i,set_uvalue=[-88,203,0,0]
        widget_control,up_button ,bad_id=i,set_uvalue=[-88,204,0,0]
        widget_control,info_but  ,bad_id=i,set_uvalue=[-88,207,0,0]
        widget_control,mac_raw   ,bad_id=i,set_uvalue=[-88,212,0]
        widget_control,his_info  ,bad_id=i,set_uvalue=[-88,215,0,0]
;;;;    widget_control,save_but  ,bad_id=i,set_uvalue=[-88,370,0,0]
     
	lamp_focus	=formtxt

	if GEORGE eq 1  then begin widget_control,base,/REALIZE
			XMANAGER, 'Don beside' ,base, event_handler='LAMP_EVENT_PARSER',/just_reg
			for k=0,2 do begin
				if prog_mac(k) eq '' then prog_mac(k)=' '
				baso11=widget_base  (baso1,/row)
				button=widget_button(baso11,value='Do')
				text  =widget_text  (baso11,value=prog_mac(k),font=ft_propor,/editable,xsize=30,ysize=1)
				widget_control,button,set_uvalue=[-88,214,0,text,0]   &   prog_txt(k)=text
				widget_control,text  ,set_uvalue=[-88,214,0,text,0]   &   endfor
			baso21 =widget_base   (baso2 ,/row)
			mac_but=widget_button (baso21,value='Macros' ,uvalue=[-88,203,0,0],font=ft_normal)
			idlbut =widget_button (baso21,value='Journal',uvalue=[-88,396,0,0],font=ft_normal)
			baso31 =widget_base   (baso3 ,/row) & k=3
				if prog_mac(k) eq '' then prog_mac(k)=' '
				text  =widget_text  (baso31,value=prog_mac(k),font=ft_propor,/editable,xsize=30,ysize=1)
				button=widget_button(baso31,uvalue=[-88,214,0,text,0],value='Do')
				widget_control,text ,   set_uvalue=[-88,214,0,text,0] &   prog_txt(k)=text
				;text   =widget_text   (baso21,value='Ctrl:'  ,font=ft_propor,/editable,xsize=30,ysize=1,resource_name="geo")
				;button =widget_button (baso21,value='Send'   ,uvalue=[-88,614,0,text,0])
				;widget_control,text   ,  set_uvalue=[-88,614,0,text,0]

			baso22 =widget_base   (baso2,/row)
			bhelp	 =widget_button (baso22,value='?'      ,uvalue=[-88,588,0,0],font=ft_normal)
			baso32 =widget_base   (baso3 ,/row) & k=4
				if prog_mac(k) eq '' then prog_mac(k)=' '
				text  =widget_text  (baso32,value=prog_mac(k),font=ft_propor,/editable,xsize=30,ysize=1)
				button=widget_button(baso32,uvalue=[-88,214,0,text,0],value='Do')
				widget_control,text ,   set_uvalue=[-88,214,0,text,0] &   prog_txt(k)=text

			baso23 =widget_base   (baso2,/row)
			bact   =widget_base   (baso23,/nonexclusive)
			bact   =widget_button (bact  ,value='Activity ->',uvalue=[-88,660,0,0],font=ft_normal)

			l_message=widget_label(basoL,font=ft_b_bigger ,xsize=labx<500,value='                 ')
	endif
return
end
;
pro prog_buttons
;** ************
;**
@lamp.cbk
@dons.cbk
	macro_area_b  =widget_base(macro_area_a,/column)
	if lamp_siz lt 900 then n=5 else n=6
	dou="Do" & uv=214 & prpt=''
	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1
	for k=0,n-1 do begin
	    if prpt ne '' then if strpos(prog_mac(k),':') ne 4 then prog_mac(k)=prpt
	    base  =widget_base   ( macro_area_b,/row)
	    if prog_mac(k) eq '' then prog_mac(k)=' '
	    if prpt ne '' then $
 	         text=widget_text( base,value=prog_mac(k),font=ft_propor,/editable,$
 	                           xsize=26,ysize=1,resource_name="geo")           $
	    else text=widget_text( base,value=prog_mac(k),font=ft_propor,/editable,$
 	                           xsize=26,ysize=1)
	    button=widget_button( base,value=dou)

	    widget_control,button,bad_id=i,set_uvalue=[-88,uv,k,text,0]
	    if txev then $
	    widget_control,text  ,bad_id=i,set_uvalue=[-88,uv,k,text,0]
	    prog_txt(k)=text
	endfor
	return
	end

pro don_do_cmd, prox=fiprox
;** **********
;**
@lamp.cbk
@dons.cbk
common c_dondo, bas,nbd,fullist

	nprox=n_elements(fiprox) & if nprox gt 0 then idpx=lonarr(nprox)-1
	if xregistered('DoCmd') ne 0 then if nprox gt 0 then widget_control,bas,/destroy
	if xregistered('DoCmd') eq 0 then begin
		bas=widget_base  (title='DO commands',/column,resource_name="lampmic") & nbd=0
		llg=widget_base  (bas,/row) & put_logo,llg
		bid=widget_button(llg,value='?',font=ft_b_normal,uvalue=[-88,588,0,0])
		bid=widget_label (llg,value='      More....',font=ft_b_normal)
		bid=widget_button(llg,value='+2',font=ft_b_normal,uvalue=[-88,224])
		b_labins(8)=bas
		fullist=[' ']
		MAC_LIST,n_em,fullist,maclist,THISFILE='*.prox'
		moclist=strlowcase(strmid(maclist,0,5))
		idx    =where((moclist ne 'dial_') and (moclist ne 'list_') and (moclist ne 'templ'))
		if idx(0) ge 0 then begin
		                        maclist =maclist(idx) & fullist=fullist(idx)
		   idx=sort(maclist) &  maclist =maclist(idx) & fullist=fullist(idx)
		   widget_control,llg,set_uvalue=maclist
		   bid=widget_label (llg,value='   '       ,font=ft_b_normal)
		   if nprox eq 0 then biron=1 else biron=0
		   bil=widget_button(llg,value='Prox files',font=ft_b_normal,uvalue=fullist,menu=2)
		   bir=widget_button(widget_base(llg,/nonexclusive),value='replace',font=ft_smallest,uvalue=[-88,225,-1,biron])
		   widget_control,bir,set_button=biron
		   for i= 0,n_elements(maclist)-1 do begin   uvprox=[-88,225,i,bil,llg,bas,bir]
		      bid=widget_button(bil,value=maclist(i),uvalue=uvprox,font=ft_b_normal)
		      if nprox gt 0 then begin idxpx=where(strlowcase(fiprox) eq maclist(i)) & if idxpx(0) ge 0 then idpx(idxpx(0))=i & endif
		   endfor
		endif
	endif
	if nbd lt n_elements(prog_txt)-1 then begin
	n=n_elements(prog_mac)
	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1
	for k=0,1 do begin
	 if nbd ge n  then val=' ' else val=prog_mac(nbd)
	 if val eq '' then val=' '
	 bdo=widget_base  (bas,/row)
	 txt=widget_text  (bdo,value=val,font=ft_propor,/editable,xsize=40,ysize=1)
	 tdo=widget_button(bdo,value='Do',font=ft_b_normal)
	 if txev then $
	 widget_control,txt,bad_id=i,set_uvalue=[-88,214,nbd<(n-1),txt,0]
	 widget_control,tdo,bad_id=i,set_uvalue=[-88,214,nbd<(n-1),txt,0]
	 if (nbd gt 6) and (nbd lt n) then prog_txt(nbd)=txt
	 nbd=nbd+1
	endfor
	endif

	if xregistered('DoCmd') eq 0 then begin
		widget_control  ,bas,group_leader=lamp_b1,/realize & put_logo
		XMANAGER,'DoCmd',bas,event_handler='LAMP_EVENT_PARSER',/just_reg
		if nprox gt 0 then for i=0,nprox-1 do if idpx(i) ge 0 then don_do_prox,0,[-88,225,idpx(i),uvprox(3:6)]
	endif
end

pro don_do_prox, event, uv
;** ***********
;**
@lamp.cbk
@dons.cbk
	if uv(2) lt 0 then begin
		widget_control,event.id,set_uvalue=[-88,225,-1,event.select] & return
		endif
	files=['']
	widget_control,uv(3) ,bad_id =ii,get_uvalue=files
	widget_control,uv(4) ,bad_id =ii,get_uvalue=filx
	
	on_ioerror,misfil
	OPENR,u,files(uv(2)),/get_lun
	on_ioerror,eoffil
	contain=strarr(600) & READF,u,contain
	eoffil: free_lun,u
	idx=where(contain gt ' ')
	if idx(0) eq -1 then return
	contain=strtrim(strcompress(contain(idx)),2)
	
	bax=widget_base  (title=files(uv(2)),/column,resource_name="lampmic")
	
	llg=widget_base  (bax,/row) & put_logo,llg
	widget_control,llg,set_uvalue=filx
	bid=widget_button(llg,value='Play all',font=ft_b_normal,uvalue=[-88,214,-1,0,bax])
	bid=widget_label (llg,value='   '     ,font=ft_b_normal)
	biron=1
	bil=widget_button(llg,value='Prox files',font=ft_b_normal,uvalue=files,menu=2)
	bir=widget_button(widget_base(llg,/nonexclusive),value='replace',font=ft_smallest,uvalue=[-88,225,-1,biron])
	widget_control,bir,set_button=biron
	for i= 0,n_elements(filx)-1 do bid=widget_button(bil,value=filx(i),uvalue=[-88,225,i,bil,llg,bax,bir],font=ft_b_normal)

	if lamp_siz lt 900 then cnt=19 else if lamp_siz lt 1300 then cnt=23 else cnt=27
	if n_elements(contain) le cnt   then $
	box=widget_base  (bax,/column)  else $
	box=widget_base  (bax,/column,y_scroll=long(cnt*31.58))
	
	if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1
	if sys_dep('VERSION') ge 4.0 then begin
		bdu=widget_base  (box,/row)
		txt=widget_text  (bdu,value='Just bidon',font=ft_propor,/editable,xsize=40,ysize=1)
		tdo=widget_button(bdu,value='Do',font=ft_b_normal)
		gml=widget_info(bdu,/geometry) & stx=gml.scr_xsize+2*gml.margin
		widget_control,bdu,/destroy
	endif else stx=350

	FOR i=0,n_elements(contain)-1 do begin
	    if strmid(contain(i),0,1) eq ';' then begin
		bid=widget_label (box,value=contain(i),font=ft_smaller,xsize=stx)
	    endif else begin
		bdo=widget_base  (box,/row)
		txt=widget_text  (bdo,value=contain(i),font=ft_propor,/editable,xsize=40,ysize=1)
		tdo=widget_button(bdo,value='Do',font=ft_b_normal)
		if txev then $
		widget_control,txt,set_uvalue=[-88,214,-1,txt,0]
		widget_control,tdo,set_uvalue=[-88,214,-1,txt,0]
		if n_elements(tot) eq 0 then tot=txt else tot=[tot,txt]
	    endelse
	ENDFOR
	if n_elements(bdo) eq 1 then begin
	   if n_elements(contain) le 10 then stxp=0 else stxp=35
	   widget_control,bax,set_uvalue=tot
	   widget_control,box,scr_xsize=stx+stxp

	   widget_control,uv(6),bad_id=ii,get_uvalue=biroff
	   if biroff(3) then widget_control,uv(5),bad_id=ii,/destroy
	   widget_control,bax,group_leader=lamp_b1,/realize  & put_logo
	   XMANAGER,'Prox_'+strtrim(string(uv(2)),2),bax,event_handler='LAMP_EVENT_PARSER',/just_reg
	endif
	return
misfil: print,!err_string
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pro	p_don_event  ,event,uv
;**	***********
;**
;
;  299     Destroy alert windows
       if uv(1) eq 299 then begin wait,.3 & widget_control,event.top,/destroy & endif
;
;  200     CR in formula entry
      if uv(1) eq 200 then form_in,event
;
;  201     IDL help
      if uv(1) eq 201 then MANUAL
;     if uv(1) eq 201 then if sys_dep('MAP') le 0 then man_proc,''
;     if uv(1) eq 201 then if sys_dep('MAP') le 0 then man_proc,'' $
;		      else spawn,'$IDL_DIR/bin/idlhelp&'
;
;  202     History
      if uv(1) eq 202 then history,event
;
;  203     Update macros
      if uv(1) eq 203 then macro_files,event,uv
;
;  204     Display user parameters
      if uv(1) eq 204 then par_disp,event
;
;  205     Update user parameters
      if uv(1) eq 205 then par_mod,event,uv(2),uv(3)
;
;  206     Update NWK
      if uv(1) eq 206 then nwk_mod,event,uv(2),uv(3),uv(4)
;
;  207     Update limits
      if uv(1) eq 207 then limits,event
;
;  210     Fire instrument macro
;     if uv(1) eq 210 then fire_inst_mac,event,uv(2)
;
;  211     Display *.pro file
      if uv(1) eq 211 then pro_list,event
;
;  212
      if uv(1) eq 212 then begin
	if event.select then	  setmanip,/raw	 else	   setmanip
	if event.select then txt="SETMANIP,/raw" else txt="SETMANIP,/noraw"
	to_don_history,-1,0, txt
      endif
;
;  213     Set up programable button window
      if uv(1) eq 213 then prog_buttons
;
;  214     Fire instrument macro
      if uv(1) eq 214 then fire_prog_mac,event,uv(2),uv(3),uv(4)
;
;  215     Set up current workspace
      if uv(1) eq 215 then set_cur_work,event
;
;  216     Create a .pro file
      if uv(1) eq 216 then pro_create ,uv
;
;  217     Compile a .pro file
      if uv(1) eq 217 then pro_compile
;
;  218     Show INTERNALS
      if uv(1) eq 218 then show_internal,uv
;
;  219     Create a .pro file
      if uv(1) eq 219 then pro_creater ,uv
;
;  222     DO not use
;
;  224     Create new DO command
      if uv(1) eq 224 then don_do_cmd
;
;  225     Create new DO prox window
      if uv(1) eq 225 then don_do_prox, event,uv
;
;  226     Create XBU dial window
      if uv(1) eq 226 then DialInit,'xbu'
;
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro setmanip,raw=raw,noraw=noraw
;** ********
;**
@dons.cbk
if keyword_set(raw) then rawmanip=1 else rawmanip=0
if mac_raw  gt 0    then widget_control,mac_raw,bad_id=ii,set_button=rawmanip
end

pro form_in,event
;** *******
;**
;FORMULA WINDOW
;
@lamp.cbk
@dons.cbk

;       Reads Formula Windows 
;

      widget_control,event.id,get_value=formu

      n        =n_elements (formu)-1
      formu(n) =strtrim    (formu(n),2)
      
      index    =where(formu ne '')
      if n_elements(index)  le n then formu=formu(index)
      nelement =n_elements (formu)-1
      if n gt nelement  then begin 
      			widget_control,event.id,set_value=formu(0:nelement)
      			widget_control,event.id,set_value='',/append,/no_newline,$
						set_text_top_line=nelement-1
			endif
      if nelement gt 20 then begin
      			widget_control,event.id,set_value=formu(nelement-10:nelement)
			widget_control,event.id,set_value='',/append,/no_newline,$
						set_text_top_line=10-1
			endif
      
if (last_form ne formu(nelement)) or  (nelement eq n) then begin
		 ifixed=1 & xfor=formu(nelement) & xfor=strtrim(xfor,2) & xicute,xfor & endif
return
end

pro form_out,outxt
;** ********
;**
@dons.cbk
	if formtxt gt 0 then begin
           widget_control,formtxt,bad_id=i,get_value=formu
           n=(n_elements(formu)-1) >0
	     formu=[formu((n-15)>0:n),outxt]
           n=(n_elements(formu)-1) >0
      	   widget_control,formtxt,bad_id=i,set_value=formu
           widget_control,formtxt,bad_id=i,set_value=''   ,/append,/no_newline,$
							   set_text_top_line=n
	endif else print,outxt
end

pro commsi ,file, params, macro=extxt, exec=exec
;** ******
;**
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
@lamp.cbk
on_ioerror,miscom
line='' & extxt='' & u=-1
OPENR,u,file,/get_lun
      while (not EOF(u)) do begin READF,u,line & extxt=[extxt,line] & endwhile
miscom:if u gt 0 then begin free_lun,u
		nn= n_elements(params)<(lamp_sys+3)
		if nn gt 0 then for ii=1,nn do begin
		    jj  =strtrim(string(ii),2)
		    xfor='par'+jj+'='+params(ii-1)
		    kk  =execute(xfor)
		endfor
		extxt= extxt(1:*)
		if keyword_set(exec) then COMMCA,extxt
		if nn gt 0 then for ii=1,nn do begin
		    jj  =strtrim(string(ii),2)
		    xfor=params (ii-1)+'=par'+jj
		    kk  =execute(xfor)
		endfor
       endif
end
pro commca ,extxt, prox
;** ******
;**
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
common c_lamp_par

	i1=0L & i2=n_elements(extxt)-1
	if n_elements(prox) eq 2 then if prox(0) ge 0 then begin i1=prox(0)
	                              i2=prox(1)  &  endif
	for kk=i1,i2 do begin xfor=extxt(kk) & jj=execute(xfor) & endfor
end

pro xicuter,intxt
;** *******
;**
@lamp.cbk
@dons.cbk
	ii=strpos(strlowcase(intxt),'passw')
	if formtxt gt 0 then if ii lt 0 then begin
           widget_control,formtxt,bad_id=i,set_value=intxt,/append
           widget_control,formtxt,bad_id=i,get_value=formu
           n=(n_elements(formu)-1) >0
           widget_control,formtxt,bad_id=i,set_value=''   ,/append,/no_newline,$
							   set_text_top_line=n
	endif
	ifixed=1 & xicute,intxt
return
end

pro xicute,intxt
;** ******
;**
@lamp.cbk
@dons.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

  on_ioerror, mis
  GEORGEO, COMMAND=intxt
      
  last_form=intxt & lwtxt=strlowcase(intxt)

  pvirg=strpos(intxt,';') & if pvirg lt 0 then pvirg=1000
  
  if pvirg             eq 0 then begin & endif else $

  if strpos(intxt,'$') eq 0 then begin
     len=strlen(intxt)
     if b_labins(3) ne 2 then spawn,strmid(intxt,1,len)

  endif else $
  if (strpos(intxt,'&') gt 0) and (strpos(intxt,'&') lt pvirg) and (strpos(lwtxt,'begin') lt 0) then begin
     com_split,last_form

  endif else $
  if strpos(intxt,'@') eq 0 then begin
     intxtp=strmid(intxt,0,pvirg)
     sep=str_sep(intxtp,',')
     sep=strtrim(sep,2)
     if  strpos (sep(0),'.')  lt 0 then file_name=sep(0)+'.prox' else file_name=sep(0)
     len=strlen (file_name) & file_name=strmid(file_name,1,len)
     if n_elements(sep) eq 1 then  com_file,file_name  $
                             else  begin to_don_history, -1,0, intxt
                                         commsi,file_name, sep(1:*), /EXEC  & endelse
  endif else $
  if strpos(intxt,'?') eq 0 then begin
;    if sys_dep('MAP') le 0 then man_proc,''
     if sys_dep('VERSION') ge 5.0 then online_help else $
     if sys_dep('MAP') gt 0 then spawn,'$IDL_DIR/bin/idlhelp&'

  endif else $
  if strpos(lwtxt,'retall')   eq 0 then begin		 & endif else $
  if       (lwtxt eq 'lamp')       then begin		 & endif else $
  if strpos(lwtxt,'saveses,') eq 0 then begin SaveSession  & endif else $
  if       (lwtxt eq 'save')       then begin SaveSession  & endif else $
  if       (lwtxt eq 'stop')       then begin P_LAMP_STOP  & endif else $
  if strpos(lwtxt,'sho')      eq 0 then begin show,intxt   & endif else begin

      if strpos(lwtxt,'exit')   eq 0 then DON_WRITE_PROG_MAC ,0

;**   Inspect line for "W" or "Dials"
;**   -------------------------------
      ii=strpos(intxt,';') & if ii gt 0 then intxt=strmid(intxt,0,ii)

      find_w1_w2, intxt ,line_2,one,two,three ,alone ,splitxyz ,opp_r
;     print,one,two,opp_r,three ,alone ,splitxyz
      if (one ge 0) and (one le lamp_sys+3) then begin
	 if (two lt 0) or (two gt lamp_sys+3) then two=0

     	 if one gt 0 then begin
;**	  SAVE one parameters
;**	  ---- --- ----------
	  one_str  =strtrim(string(one)  ,2)
	  two_str  =strtrim(string(two)  ,2)
	  three_str=strtrim(string(three),2)
	  
	  					MOVEPAR, (one),one_str, 0,'0'
	  
;**	  PUT two parameters in one
;**	  --- --- ---------- -- ---
     	  if two ne 0 then begin
     	   sz_two=[0L]
	   iii   =execute('sz_two=size(w' +two_str+')')

	   calc_e=0
	   rawraw=rawmanip
	   if strpos(last_form,';++') gt 0 then rawraw=0 else $
	   if strpos(last_form,';--') gt 0 then rawraw=1
	   if (not rawraw) then $
	   if  sz_two(sz_two(0)+2) gt 1 then $
	   if (three gt 0) and ((opp_r eq '+') or (opp_r eq '-') or (opp_r eq '*') or (opp_r eq '/')) then begin
	      sz_three=[0L] & iii=execute('sz_three=size(w' +three_str+')')
	      if sz_three(sz_three(0)+2) gt 1 then begin

;**		First if third W is here then update n,e
;**		----- -- ----- - -- ---- ---- ------ ---
		tix1=''   & tix2='' & tix3='E'+one_str & tix4='' & kp_n='' & kp_e=''
		nenn=1L   & iii=execute('nenn=n_elements(n'+two_str   +'(*,0))')
		nenk=1L   & iii=execute('nenk=n_elements(n'+three_str +'(*,0))')
		jjn =0.   & iii=execute('jjn =total(n'+two_str  +'(*,0))/nenn')
		jjk =jjn  & iii=execute('jjk =total(n'+three_str+'(*,0))/nenk')

		jje =1L   & iii=execute('jje=2*sz_two(sz_two(0)+2)-n_elements(e'+two_str+')-n_elements(e'+three_str+')')

		tsto=((opp_r eq '-') and (jjn ne jjk))
		tstn=((jjn le 1) and (jjk le 1)) or ((nenn eq 1) and (nenk eq 1))
		tstx=1L   & iii=execute('tstx=(x'+two_str  +'(0) eq x'+three_str+'(0)) and '     + $
					     '(x'+two_str  +'(n_elements(x'+two_str  +')-1)  eq '+ $
					      'x'+three_str+'(n_elements(x'+three_str+')-1)) and'+ $
					     '(sz_two(0) eq sz_three(0))')

;		Monitors are # or X different then W_ACCU is used
;		*************************** **** ****************
		if (( opp_r eq '+') or (opp_r eq '-')) and (splitxyz(0) ne 'yes') $
						       and ((not tstx) or (tsto)) then begin

		   if opp_r eq '+' then ads=      ',add='   else ads=',sub='

		   roaw='' ;if monimon lt 0 then roaw=',/raw'
		   tt  =tolerance
		   tix4=last_form
		   plac=0
		   if (sz_two(0) ne sz_three(0)) then begin
		      plac=1
		      tix4='; Incompatible dimensions ...'
		      if (sz_two(1) eq sz_three(1))   then begin
		      if (sz_two(0) eq 2) and (sz_three(0) eq 1) then $
		      			   tix4='W=w'+two_str+' & for i=0,'+strtrim(string(sz_two(2)-1),2)+ $
		      			        ' do w(*,i)=w'  +two_str+'(*,i) '+opp_r+' w'  +three_str+' & w'+one_str+'=W' $
		      else $
		      if (sz_two(0) eq 3) and (sz_three(0) eq 2) then $
		      			   tix4='W=w'+two_str+' & for i=0,'+strtrim(string(sz_two(3)-1),2)+ $
		      			        ' do w(*,*,i)=w'+two_str+'(*,*,i) '+opp_r+' w'+three_str+' & w'+one_str+'=W'
		      endif
		   endif else begin
		      if one eq two   then tix4='W_ACCU,accu='+  one_str+  ads  +three_str +',tol=tt'+roaw else $
		      if one eq three then begin
					   tix4='W_ACCU,accu='+three_str+  ads  +two_str	+',tol=tt'+roaw
					   if opp_r eq '-'  then tix4=tix4+'& w'+one_str+'=-w'+one_str
			        endif else tix4='W'+one_str+'=0'$
							   +' & W_ACCU,accu='+one_str+',add='+  two_str +',tol=tt' $
							   +' & W_ACCU,accu='+one_str+  ads  +three_str +',tol=tt'+roaw
		   endelse
		   toler=tt
		   oon=one & if one ne two then too=two else too=three
		   laa=last_form & ifixed=0

		   if  (plac) then begin
			 iii=EXECUTE(tix4)
			 if one ne two then MOVEPAR ,(two),two_str , (one),one_str
		   endif else begin
			 XICUTE, tix4
			 if (jjk+jjn gt 1) then tix4='N'+one_str+' average ... ' else tix4=''
			 if (jje eq 0)     then tix4=tix4+'E'+one_str+' evaluated ...'
			 if opp_r eq '-'   then $
			 if (jjk ne jjn)   and (not tstn) then tix4='n'+three_str+' and n'+two_str+' are different ...'
		   endelse
		   if l_message gt 0 then widget_control,bad_id=iii,l_message  ,set_value=tix4 else print,tix4
		   if b_labins(6)    then if b_labins(7) gt 0 then $
		                          widget_control,bad_id=iii,b_labins(7),set_value=tix4

		   last_w=oon & to_don_history, oon , too , laa+';W_ACCU'
		   RETURN
		endif else begin
;**		N..
		   if jjn gt 0 then begin
		      if  one ne two then kp_n='n0' else kp_n='n'+one_str+'(*,0)'
		      if (opp_r ne '-') then begin
			tix0= kp_n      +'=n'+two_str+'(*,0)'+opp_r+'n'+three_str+'(*,0)'
			tix1='n'+one_str+'=n'+two_str        +opp_r+'n'+three_str
			iii=execute(tix0) & if iii ne 1 then tix1=''
		      endif
		   endif
;**		E..
		   if jje eq 0 then begin
		      if one ne two then kp_e='e0' else kp_e=tix3
		      if (opp_r eq '+') then tix2='=SQRT( e'+two_str+'^2+e'+three_str+'^2)'
		      if (opp_r eq '-') then tix2='=SQRT( e'+two_str+'^2+e'+three_str+'^2)'
		      if (opp_r eq '*') then tix2='=SQRT((e'+two_str+'*w'+three_str+')^2+(e'+three_str+'*w'+two_str+')^2)'
		      if (opp_r eq '/') then tix2='=SQRT((e'+two_str+'/w'+three_str+')^2+(e'+three_str+'*w'+two_str+'/w'+three_str+'^2)^2)'
		      xfor=kp_e+tix2
		      iii=execute(xfor) & if iii ne 1 then tix2='' else if tix1 ne '' then tix1=tix1+' & '
		   endif
		endelse
		if tix1+tix2 ne '' then  calc_e=1
	      endif
	   endif
	   
	   if one ne two then begin 		MOVEPAR ,(two),two_str , (one),one_str
						if calc_e ne 0 then if tix1 ne '' then iii=execute('n'+one_str+'(*,0)='+kp_n)
						if calc_e ne 0 then if tix2 ne '' then iii=execute('e'+one_str+     '='+kp_e)
	   					endif
;**	  ELSE CLEAR one parameters
;**	  ---- ----- --- ----------
     	  endif else if strpos(lwtxt,'/compl') eq -1 then	CLEARPAR,(one),one_str

     	 endif
      if l_message gt 0 then widget_control,bad_id=iii,l_message  ,set_value=' '
      if b_labins(6)    then if b_labins(7) gt 0 then $
			     widget_control,bad_id=iii,b_labins(7),set_value=' '
      
      datpon=strpos(strlowcase(strcompress(last_form,/remove_all)),',datp')
      if datpon gt 0 then SETDATP,datp

      stat=0 & jjj=1
      on_error,1 & catch,stat
      xfor=last_form
      if (stat eq 0) and (jjj eq 1) then begin  ok=0
        if (sys_dep('VERSION') lt '5.3') then if (sys_dep('MACHINE') eq 'win') then $
        if (not sys_dep('EMBEDDED'))     then if (not sys_dep('RUNTIME')) then begin
      			on_ioerror,misexc & un=-1
      			openw ,un,'exelamp.pro',/get_lun
      			printf,un,'pro exelamp'		& printf,un,'@lamp.cbk'
      			printf,un,'common for_users'	& printf,un, xfor
      			printf,un,'end'			& free_lun,un & ok=1
      			resolve_routine,'exelamp' & exelamp & misexc:
      			endif
        if (not ok) then jjj=EXECUTE(xfor)     ;<--------------------
      endif
      if jjj ne 1 then print,!err_string
      if n_elements(one_str) eq 0 then one=0 ;Recursivity Problem ...

      if (stat ne 0) or  (jjj ne 1) then begin
      		     catch,/cancel
      		     catch,stat & if stat ne 0 then return
      		     P_MUS,'mus_cannon'
      		     therror=strmid(!err_string,0,65)
		     if l_message gt 0 then $
      			widget_control,bad_id=iii,l_message  ,set_value=therror $
		     else print,!err_string
		     if b_labins(6)    then if b_labins(7) gt 0 then $
			widget_control,bad_id=iii,b_labins(7),set_value=therror
      		     print,string(7b)
;**	  		ERROR RESTORE one parameters
;**	  		----- ------- --- ----------
     	 		if   one gt 0 then 	MOVEPAR, 0,'0' , (one),one_str
			if ((one gt 0) or (alone gt 0)) and (ifixed eq 1) then begin
         		     jou_c=[jou_c,last_form]
         		     jou_w=[jou_w,'??? '+!err_string]
         		endif
		     ifixed=0 & return
      endif else begin
      
      if datpon gt 0 then GETDATP,datp

;	 Place x,y title correctly when nb dimensions change.
;	 ----- --- ----- --------- ---- -- ---------- ------
     	 if (one gt 0) and (two gt 0) then begin
     	 	sz_one=[0L] & sz_err=[0L] & sz_mon=[0L] & sz_x=[0L] & sz_y=[0L]
		iii   =execute('if n_elements(w'+one_str+') gt 1 then w'+one_str+ '=reform(w' +one_str+ ',/overwrite)')
		iii   =execute('if n_elements(x'+one_str+') gt 1 then x'+one_str+ '=reform(x' +one_str+ ',/overwrite)')
		iii   =execute('if n_elements(y'+one_str+') gt 1 then y'+one_str+ '=reform(y' +one_str+ ',/overwrite)')
		iii   =execute('sz_one=size(w' +one_str+')')
		iii   =execute('sz_err=size(e' +one_str+')')
		iii   =execute('sz_mon=size(n' +one_str+')')
		iii   =execute('sz_x  =size(x' +one_str+')')
		iii   =execute('sz_y  =size(y' +one_str+')')
		
		if (sz_one(sz_one(0)+2) eq sz_x  (sz_x  (0)+2)) or $
		   (sz_one(1)		eq sz_x  (1))		then xko=0 else xko=1
		if (sz_one(sz_one(0)+2) eq sz_y  (sz_y  (0)+2)) or $
		   (sz_one(0) eq 1) or  $
		  ((sz_one(0) gt 1) and (sz_one(2) eq sz_y(1)))	then yko=0 else yko=1
		if  sz_one(sz_one(0)+2) eq sz_err(sz_err(0)+2)  then eer=0 else eer=1
		if  sz_one(sz_one(0)+2) eq sz_mon(sz_mon(0)+2)  then mon=0 else mon=1

;**		Then reform x,y,z,e,n with splitxyz
;**		---- ------ --------- ---- --------
		if splitxyz(0) eq 'yes' then begin
;**		X..
		   if splitxyz(1) ne '' then if xko eq 1 then begin
		   	svtwo=[0L] & iii=execute( 'svtwo=size(x' +two_str+')' )
			if sz_two(0) ge 1 then begin
			 if (svtwo(0) eq 0) or (svtwo(1) ne sz_two(1)) then $
			 iii=execute( 'x'+two_str+'=indgen(sz_two(1))+1' )
			 if  svtwo(0) gt 1 then $
			 iii=execute( 'x'+one_str+'=reform(x'+two_str+splitxyz(4)+')' ) else $
			 iii=execute( 'x'+one_str+'=   x'+two_str+'('+splitxyz(1)+')' )
			 iii=execute( 'sz_x  =size(x' +one_str+')')
			 if (sz_one(sz_one(0)+2) eq sz_x  (sz_x  (0)+2)) or $
		   	    (sz_one(1)		 eq sz_x  (1))		 then xko=0 else xko=1
		   	endif
		   endif
;**		Y..
		   if splitxyz(2) ne '' then if yko eq 1 then begin
		   	svtwo=[0L] & iii=execute( 'svtwo=size(y' +two_str+')' )
			if sz_two(0) ge 2 then begin
			 if (svtwo(0) eq 0) or $
			   ((svtwo(0) eq 1) and (svtwo(1) ne sz_two(2))) or $
			   ((svtwo(0) eq 2) and (svtwo(2) ne sz_two(2))) then $
			 iii=execute( 'y'+two_str+'= indgen(sz_two(2))+1' )
			 if  svtwo(0) gt 1 then $
			 iii=execute( 'y'+one_str+'=reform(y'+two_str+splitxyz(4)+')' ) else $
			 iii=execute( 'y'+one_str+'=   y'+two_str+'('+splitxyz(2)+')' )
			 iii=execute( 'sz_y  =size(y' +one_str+')')
			 if (sz_one(sz_one(0)+2) eq sz_y  (sz_y  (0)+2)) or $
		   	   ((sz_one(0) gt 1) and (sz_one(2) eq sz_y(1))) then yko=0 else yko=1
			endif
		   endif
;**		Z..		   
		   if splitxyz(3) ne '' then begin
		   	svtwo=[0L] & iii=execute( 'svtwo=size(z' +two_str+')' )
			if sz_two(0) ge 3 then begin
			 if (svtwo(0) eq 0) or (svtwo(1) ne sz_two(3)) then $
			 iii=execute( 'z'+two_str+'= indgen(sz_two(3))+1' )
			 iii=execute( 'z'+one_str+'= z'+two_str+'('+splitxyz(3)+')' )
			endif
		   endif
;**		E..		   
		   if (eer eq 1) and  (sz_err(0) eq sz_two(0)) then begin
		      ei1=max(sz_err(0:sz_err(0)) - sz_two(0:sz_two(0)),min=ei2)
		      if (ei1 eq 0) and (ei2 eq 0) then begin
		   	  iii=execute( 'e'+one_str+'=reform(e'+two_str+splitxyz(4)+')' )
			  iii=execute( 'sz_err=size( e'+one_str+')')
		          if sz_one(sz_one(0)+2) eq sz_err(sz_err(0)+2) then eer=0 else eer=1
		      endif
		   endif
;**		N..
		   if (mon eq 1) and  (sz_mon(0) eq sz_two(0)) then begin
		      ei1=max(sz_mon(0:sz_mon(0)) - sz_two(0:sz_two(0)),min=ei2)
		      if (ei1 eq 0) and (ei2 eq 0) then begin
		   	  iii=execute( 'n'+one_str+'=reform(n'+two_str+splitxyz(4)+')' )
			  iii=execute( 'sz_mon=size( n'+one_str+')')
		          if sz_one(sz_one(0)+2) eq sz_mon(sz_mon(0)+2) then mon=0 else mon=1
		      endif
		   endif
		endif

;**		Now check if TOTAL or slice was used
;**		--- ----- -- ----- -- ----- --- ----
;		---- X Y Z
		if (strpos(strcompress(lwtxt,/remove_all),'total(') gt 0) or (splitxyz(0) eq 'yes') then begin
		 if (sz_one(0) eq 2) and (sz_two(0) eq 3)  then begin
		     if sz_one(1) eq sz_two(1) then begin
		        if sz_one(2) eq sz_two(2) then begin
		        endif else if (sz_one(2) eq sz_two(3)) and (yko eq 1) then begin
		 	   iii=execute('y' +one_str+'= z' +two_str)
		 	   y_tit(one) = z_tit(two)
		        endif
		     endif else    if (sz_one(1) eq sz_two(2)) and (xko eq 1) then begin
		 	   iii=execute('x' +one_str+'= y' +two_str)
		 	   iii=execute('y' +one_str+'= z' +two_str)
		 	   x_tit(one) = y_tit(two)
		 	   y_tit(one) = z_tit(two)
		     endif
		     z_tit(one) ='Count'
		     iii=execute('z' +one_str+'= 0')
		 endif
;		 ---- X Y
		 if   (sz_one(0) eq 1) and (sz_two(0) gt 1) then begin   ;and (xko+yko ge 1)
		  y_tit(one) = 'Count'
		  if  (sz_x(0)   gt 1)         then iii=execute('x' +one_str+'= x' +one_str+'(*,0)')
		  if  (sz_one(1) eq sz_two(2)) then begin
		   if (sz_one(1) ne sz_two(1)) then begin
		 	 iii=execute('x' +one_str+'= y' +two_str)
			 if(sz_y(0)   gt 1)   then iii=execute('x' +one_str+'= reform(x' +one_str+'(0,*))')
		 	 x_tit(one) = y_tit(two)
		 	;if splitxyz(0) ne 'yes' then y_tit(one) = z_tit(two)
		   endif
		  endif else if sz_two(0) gt 2 then if (sz_one(1) eq sz_two(3)) then begin
		 	 iii=execute('x' +one_str+'= z' +two_str)
		 	 x_tit(one) = z_tit(two)       
		 	 y_tit(one) = 'Count'
		  endif
     	      	  z_tit(one)	=''
		  iii=execute('sz_x =size(x' +one_str+')')
     	      	  iii=execute('y' +one_str+'= [0]')
		 endif       
		endif
		if (strpos(strcompress(lwtxt,/remove_all),'total(') gt 0) then begin
;		 ---- E	
		 if (eer eq 1) and (sz_err(0) eq sz_one(0)+1) then begin
		  if sz_err(0) eq 1 then iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2  ))') else $
		  if sz_err(0) ge 2 then if sz_one(1) ne  sz_err(1) then $
		 			iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2,1))') else $
		 			if sz_one(1) eq  sz_err(1) then $
		 			iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2,2))') else $ 
		  if sz_err(0) eq 3 then if sz_one(2) ne  sz_err(3) then $
		 			iii=execute('e'+one_str+'=sqrt(total(e'+one_str+'^2,3))')
		 endif	
;		 ---- N	
		 if (mon eq 1) and (sz_mon(0) eq sz_one(0)+1) then begin
		  if sz_mon(0) eq 1 then iii=execute('n'+one_str+'=total(n'+one_str+'  )') else $
		  if sz_mon(0) ge 2 then if sz_one(1) ne  sz_mon(1) then $
;		 			iii=execute('n'+one_str+'=total(n'+one_str+',1)') else $
					iii=1 else $
		 			if sz_one(1) eq  sz_mon(1) then $
		 			iii=execute('n'+one_str+'=total(n'+one_str+',2)') else $ 
		  if sz_mon(0) eq 3 then if sz_one(2) ne  sz_mon(3) then $
		 			iii=execute('n'+one_str+'=total(n'+one_str+',3)')
		 endif
		endif
		
;**		Now check if TRANSPOSE was used
;**		--- ----- -- --------- --- ----
		tmptr=strcompress(lwtxt,/remove_all)
		if (strpos(tmptr,'=transpose(') gt 0) then begin
		   if sz_x(0)   gt 1 then iii=execute('x'+one_str+ '=reform(transpose(x' +one_str+ '),/overwrite)')
		   if sz_y(0)   gt 1 then iii=execute('y'+one_str+ '=reform(transpose(y' +one_str+ '),/overwrite)')
		   if sz_err(0) gt 1 then iii=execute('e'+one_str+ '=reform(transpose(e' +one_str+ '),/overwrite)')
		   tmp=0.  &  iii=execute('tmp= x' +one_str)
		   iii=execute('x' +one_str+'= y' +one_str)
		   iii=execute('y' +one_str+'= tmp')
		   tmp=x_tit(one)
		   x_tit(one)=y_tit(one) & y_tit(one) = tmp
		endif
	
		if calc_e ne 0 then begin	
		   if tix2  ne ''    then begin tix2=tix3+' evaluated'  & last_form=last_form+';E'+one_str  &    endif
		   if l_message gt 0 then widget_control,bad_id=iii,l_message  ,set_value=tix1+tix2 else print,tix1+tix2
		   if b_labins(6)    then if b_labins(7) gt 0 then $
		                          widget_control,bad_id=iii,b_labins(7),set_value=tix1+tix2
		endif
	 endif

;        Keep last workspace altered in last_w in common block
;        Update history if "wn=" found
         if (one ge 1) and (one le lamp_sys) then begin last_w=one
         					  his_mod,last_form,line_2
         endif else if alone gt 0 then begin
         		     one=alone & two=-1 & last_w=one
         		     his_mod,last_form,''
         		     one=0     & two= 0
         endif else if (one  ge  0) and (ifixed eq 1) then begin
         		     jou_c=[jou_c,last_form]
         		     jou_w=[jou_w,'']
         		     endif
      endelse
      endif
   endelse
ifixed=0
return
mis:		     therror=strmid(!err_string,0,65)
		     if l_message gt 0 then $
		     widget_control,bad_id=iii,l_message  ,set_value=therror $
		     else print,!err_string
		     if b_labins(6) then if b_labins(7) gt 0 then $
		     widget_control,bad_id=iii,b_labins(7),set_value=therror
		     print,string(7b)
		     ifixed=0
return
end

pro don_me_lastf, ici ,flg
;** ************
@dons.cbk
if flg then last_form=ici else ici=last_form
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro com_split,formi
;** *********
;**
@lamp.cbk
	form =formi & pe=strpos(form,'&')   & ifi=ifixed
	xfor =strmid (form,0,pe) & xfor=strtrim(xfor,2)	   & xicute,xfor  & ifixed=ifi
	xfor =strtrim(strmid(form,pe+1,strlen(form)-pe),2) & xicute,xfor
return
end

pro com_file,file_name
;** ********
;**
; Executes command file
common c_dondo, bas,nbd,fullist

         bstr=''
         on_ioerror, end_f & in=-1
	 
	 if strpos(strlowcase(file_name),'.prox') ge 0 then begin
	 	fifi=file_name
		bid=findfile(fifi,count=n_em)
		if n_em eq 0 then begin
		   if n_elements(fullist) eq 0 then MAC_LIST,n_em,fullist,maclist,THISFILE='*.prox'
		   idx=where(strpos(fullist,fifi) ge 0)
		   if idx(0) ge 0 then fifi=fullist(idx(0))
		endif
	 endif else fifi=file_name
	 
         openr,in,fifi,/get_lun
	 ok=1
	 CATCH,stat & if stat ne 0 then begin print,!err_string & ok=0 & endif
         while (ok) and (not eof(in)) do begin
          	readf,in,bstr
;		assume xicuter is recursive.
	  	bstr=strtrim(bstr,2) & xicuter ,bstr
		RDSTAP,1,50,1,res & if res then ok=0
         endwhile
 end_f:  if in gt 0 then free_lun,in else print,!err_string

return
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro history, event
;** *******
;**
@lamp.cbk
;HISTORY BUTTON     

      if event.select eq 1 then begin
	 widget_control,his_info,set_value=histxt
	 ihis=1
      endif
return
end
pro set_history
;** ***********
;**
@lamp.cbk
;SHOW HISTORY  
	DON_LIM_SENS & nh=n_elements(histxt)
	if his_info  gt 0 then widget_control,his_info,set_value=histxt else $
	if l_message le 0 then if nh gt 1 then for i=0,nh-2 do print,histxt(i)
return
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro limits, event
;** ******
;**
@lamp.cbk
;Info BUTTON     

      if event.select eq 1 then begin
	 widget_control,his_info,set_value=limtxt
	 ihis=0
      endif
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
pro macro_files,event, uv
;** ***********
;** Display macros
@lamp.cbk
@dons.cbk

prx =uv(2)
intn=uv(3)
curr_macr=''
n_emacs  =0
if prx then mac_list ,n_emacs, THISFILE='*.prox', /SET $
       else mac_list ,n_emacs, /SET

i=xregistered('mac_page')
if i eq 0 then begin
      script=strarr(1000)
      mac_help = widget_base  (title='Lamp Macro Information',/column,resource_name='lamptouch')

      mc_bar1  = widget_base  (mac_help ,/row)
;***      
      mc_bar11 = widget_base  (mc_bar1  ,/column)
		 put_logo     ,widget_base(mc_bar11,/row)
      header   = widget_label (mc_bar11 ,value='Select macro',font=ft_b_bigger)
      header   = widget_label (mc_bar11 ,value='to view     ',font=ft_b_bigger)
      mc_bidon = widget_label (mc_bar1  ,value='     '	     ,font=ft_b_bigger)
      
      mc_bar11 = widget_base  (mc_bar1  ,/column,/frame)
      mc_bar111= widget_base  (mc_bar11 ,/row)
      
      if GEORGE ne 0 then can='New:' else can='Create a new:'
      mc_bidon = widget_label (mc_bar111,value=can          	     ,font=ft_b_bigger)
	compp    ='Write new file'
      if (sys_dep('RUNTIME') or sys_dep('EMBEDDED')) then $
	  crea_but2= widget_button(mc_bar111,value='Batch file'      ,font=ft_b_bigger,uvalue=[-88,216,2,0]) $
      else begin
	  compp    ='Compile new file'
	  crea_but1= widget_button(mc_bar111,value='Macro'  	     ,font=ft_b_bigger,uvalue=[-88,216,1,0])
	  crea_but2= widget_button(mc_bar111,value='Batch'  	     ,font=ft_b_bigger,uvalue=[-88,216,2,0])
	  if GEORGE ne 0 then $
	  crea_but2= widget_button(mc_bar111,value='Dial'  	     ,font=ft_b_bigger,uvalue=[-88,216,3,0])
      endelse
      
      mac_file = widget_text  (mc_bar11 ,value=' ',xsize=18,ysize=1  ,font=ft_propor,/editable,uvalue=[0])

      mc_bar11 = widget_base  (mc_bar1  ,/column)
      done_but = widget_button(mc_bar11 ,value='Exit'		     ,font=ft_b_bigger)
      comp_but = widget_button(mc_bar11 ,value= compp                ,font=ft_b_bigger)
      mac_labl = widget_label (mc_bar11 ,value='                    ',font=ft_b_normal,xsize=200)
;***
      mc_bar2  = widget_base  (mac_help ,/row)
      if lamp_siz lt 900 then nl=30 else nl=35
	macdid   = widget_base  (mc_bar2  ,/column)
      macdd    = widget_button(macdid   ,value= "Internals"             ,font=ft_propor)
      mack     = widget_list  (macdid   ,ysize=n_emacs <nl ,value=macros,font=ft_propor)
      file_text= widget_text  (mc_bar2  ,xsize=80,ysize=30 ,value=script,font=ft_propor,$
      					/scroll,/editable)
      bid=sys_dep      ('DYNLAB',mac_help,1)
      widget_control,mac_help ,group_leader=lamp_b1,/realize & put_logo
      
      widget_control,mack     ,bad_id=i,set_uvalue=[-88,211,0,0,0,0,0,0,0]  
      widget_control,comp_but ,bad_id=i,set_uvalue=[-88,217,0,0,0,0,0,0,0]  
      widget_control,macdd    ,bad_id=i,set_uvalue=[-88,218,file_text,mac_file]  
      widget_control,done_but ,bad_id=i,set_uvalue=[-88,299,0,0,0,0,0,0,0]  

      XMANAGER, 'mac_page' ,mac_help,event_handler='LAMP_EVENT_PARSER',/just_reg
      widget_control,bad_id=i,file_text,set_value=''
      
      if intn then begin txti=""
	 internal,txti & widget_control,bad_id=ii,file_text,set_value=txti
      endif
      
endif else begin
      if not intn then widget_control,bad_id=i,mack     ,set_value=macros
      if not intn then widget_control,bad_id=i,file_text,set_value=''
      widget_control,bad_id=i,mac_help ,map=1
endelse

return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro mac_list,n_emacs ,mac_ful_out,macros_out, thisfile=thisfile ,set=setmacros
;** ********
;**
@lamp.cbk
@dons.cbk
; Set up macros

	mic_ful=['']   & macris=['']
	cd,current=mee & home=mee  & pmac=''
	lmac=sys_dep      ('NEWSUB',lamp_dir,'lamp_mac')
	
	hhm=sys_dep      ('HOME')
	cd,hhm
	cd,mee,current=home
		stat=0 & catch,stat
		if stat ne 0 then begin lamp_macro='' & pmac='' & submac=[''] & catch,/cancel
		endif else begin
			if lamp_macro ne '' then pmac=lamp_macro else pmac=lmac ;=sys_dep('NEWSUB',!Dir,'lib')
			bid=FINDFILE(pmac,count=nn)
			if nn eq 0 then pmac=lmac
			cd,pmac   & cd,mee,current=pmac
			submac =expand_path('+'+pmac,/array,count=nsub)
			if strmid(pmac  ,strlen(pmac)-1,1)   ne lamp_dvd then pmac  =pmac  +lamp_dvd
			if strmid(submac(0),strlen(submac(0))-1,1) ne lamp_dvd then submac=submac+lamp_dvd
		endelse

		stat=0 & catch,stat
		if stat ne 0 then begin lmac='' & catch,/cancel
		endif else begin
			cd,lmac  & cd,mee,current=lmac
			if strmid(lmac,strlen(lmac)-1,1) ne lamp_dvd then lmac=lmac+lamp_dvd
		endelse
	if strmid(mee  ,strlen(mee)-1,1)   ne lamp_dvd then mee  =mee  +lamp_dvd
	if strmid(home ,strlen(home)-1,1)  ne lamp_dvd then home =home +lamp_dvd
	
      if (sys_dep('RUNTIME') or sys_dep('EMBEDDED')) then xx='x' else xx='*'
;**	Current macros
	if n_elements(thisfile) eq 1 then file_names=mee + thisfile $
	                             else file_names=mee +'*.pro'+xx
	mac_all=findfile(file_names,count=n_files)
	if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(mee))
					   if ln ge 0 then ln=ln+strlen(mee)
					   macris =['-- USER --',strmid(mac_all,ln,30)]
					   mic_ful=['', mac_all]
					   n_files=n_files+1
	endif
	n_emacs=n_files
	
;**	Home macros
	if home ne mee then begin
	if n_elements(thisfile) eq 1 then file_names=home + thisfile $
	                             else file_names=home +'*.pro'+xx
	mac_all=findfile(file_names,count=n_files)
	if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(home))
					   if ln ge 0 then ln=ln+strlen(home)
		if n_emacs gt 0 then begin macris =[macris ,'','-- HOME --',strmid(mac_all,ln,30)]
					   mic_ful=[mic_ful,'','', mac_all]
					   n_files=n_files+1
		endif 		else begin macris =[           '-- HOME --',strmid(mac_all,ln,30)]
					   mic_ful=[           '', mac_all]
		endelse
		n_files=n_files+1
	endif
	n_emacs=n_emacs+n_files
	endif

;**	Lamp_macro macros
	if pmac ne '' then if pmac ne home then if pmac ne mee then begin
	 lsub = strlen(pmac)
	 okf  = intarr(nsub>1)
	 ok   =1
	 for i=0,nsub-1 do if (strpos(strlowcase(submac(i)),strlowcase(inst_value)) ge 0) or $
	                      (strpos(strlowcase(submac(i)),strlowcase(inst_group)) ge 0) or $
	                      (strpos(submac(i),lamp_dvd,lsub) lt 0) then begin ok=0 & okf(i)=1 & endif
	 if n_elements(thisfile) eq 1 then if strpos(thisfile,'A_') eq 0 then ok=1
	 for i=0,nsub-1 do begin
	  if (ok) or (okf(i)) then begin
	   if n_elements(thisfile) eq 1 then file_names=submac(i) + thisfile $
	                                else file_names=submac(i) +'*.pro'+xx
	   mac_all=findfile(file_names,count=n_files)
	   if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(submac(i)))
					   if ln ge 0 then ln=ln+strlen(submac(i))
					   MACP=strupcase(strmid(submac(i),lsub,18)) & if MACP eq "" then MACP="MACROS"
		if n_emacs gt 0 then begin macris =[macris ,'','-- '+MACP+' --',strmid(mac_all,ln,30)]
					   mic_ful=[mic_ful,'','', mac_all]
					   n_files=n_files+1
		endif           else begin macris =[           '-- '+MACP+' --',strmid(mac_all,ln,30)]
					   mic_ful=[           '', mac_all]
		endelse
		n_files=n_files+1
	   endif
	   n_emacs=n_emacs+n_files
	  endif
	 endfor
	endif
	
	if lmac ne pmac then if lmac ne home then if lmac ne mee then begin
	if n_elements(thisfile) eq 1 then file_names=lmac + thisfile $
	                             else file_names=lmac +'*.pro'+xx
	mac_all=findfile(file_names,count=n_files)
	if n_files gt 0 then begin
					   ln     =strpos(strupcase(mac_all(0)),strupcase(lmac))
					   if ln ge 0 then ln=ln+strlen(lmac)
		if n_emacs gt 0 then begin macris =[macris ,'','-- LAMP --',strmid(mac_all,ln,30)]
					   mic_ful=[mic_ful,'','', mac_all]
					   n_files=n_files+1
		endif 		else begin macris =[           '-- LAMP --',strmid(mac_all,ln,30)]
					   mic_ful=[           '', mac_all]
		endelse
		n_files=n_files+1
	endif
	n_emacs=n_emacs+n_files
	endif
	if n_elements(thisfile) eq 1 then begin
		mac_ful_out=[''] & macros_out=['No MacrosList has been found...']
		idx=where(mic_ful ne '')
		if idx(0) ge 0 then begin
			mic_ful=mic_ful(idx) & macris    =macris(idx)
			idx=uniq(macris,sort(macris)) & mic_ful=mic_ful(idx) & macris=macris(idx)
			mac_ful_out=mic_ful  & macros_out=macris
			for i=0,n_elements(idx)-1 do begin
				t=strpos(macros_out(i),'A_')+1 & if t eq 1 then t=t+1
				p=strpos(macros_out(i),'.') & if p le 0 then p=30
				macros_out(i)=strmid(macros_out(i),t,p-t)
			endfor
		endif
	endif
	if keyword_set(setmacros) then macros =macris
	if keyword_set(setmacros) then mac_ful=mic_ful
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro pro_list,event
;** ********
;**
@dons.cbk

      curr_macr=macros (event.index)
      file_name=mac_ful(event.index)
      
      ln=strpos(curr_macr,';')
      if ln gt 0 then curr_macr=strmid(curr_macr,0,ln)

      if file_name ne '' then begin
        on_ioerror, no_f
	in=-1 & k=0
        openr,in,file_name,/get_lun

        on_ioerror, end_f
        script= strarr(1000)
	bstr  = ''
        for k=long(0),999 do begin
            readf,in,bstr
            script(k)=bstr
        endfor
        on_ioerror, end_m
        while (1) do begin
            mors  = strarr(1000)
            readf , in,mors
            script=[script,mors] & k=k+1000
        endwhile
 end_m:     script=[script,mors] & k=k+1000
 	while script(k-1) eq '' do k=k-1
 end_f:
 no_f:  if in gt 0 then free_lun,in
	if in gt 0 then widget_control,bad_id=i,mac_file ,set_value=curr_macr
        if k  gt 0 then widget_control,bad_id=i,file_text,set_value=script(0:k-1)
	if k  gt 0 then widget_control,bad_id=i,mac_labl ,set_value=' ' $
		   else widget_control,bad_id=i,mac_labl ,set_value='Read error ...!'
      endif
return
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro pro_create ,uv
;** **********
;**
@lamp.cbk
@dons.cbk
	if xregistered('MacName') gt 0 then begin widget_control,macro_area_a,get_uvalue= bazar
	                                          widget_control,bazar,bad_id=ii,/destroy & endif	
	if uv(2) eq 1   then ctxt="macro"
	if uv(2) eq 2   then ctxt="batch"
	if uv(2) eq 3   then ctxt="dial"
	bazar =  widget_base  (title='Lamp Macro Name',/column,resource_name='lamptouch')
	put_logo,widget_base  (bazar,/row)
	bazr1 =  widget_base  (bazar,/row)
	bid   =  widget_label (bazr1,value='Enter the name of the '+ctxt,font=ft_b_normal)
	baz1  =  widget_text  (bazr1,value='my'+ctxt,xsize=15, /editable,font=ft_propor)
	if uv(2) eq 1   then begin
	 bazr2=  widget_base  (bazar,/row)
	 bazrb=  widget_button(bazr2,value='Create a function'          ,font=ft_b_normal,uvalue=[-88,219,0,baz1,bazar])
	 bazrb=  widget_button(bazr2,value='Create a procedure'         ,font=ft_b_normal,uvalue=[-88,219,1,baz1,bazar])
	endif
	if uv(2) eq 2   then begin
	 bazr2=  widget_base  (bazar,/row)
	 bazrb=  widget_button(bazr2,value='Create'                     ,font=ft_b_normal,uvalue=[-88,219,2,baz1,bazar])
	endif
	if uv(2) eq 3  then begin
	 bazr2=  widget_base  (bazar,/row)
	 bazrb=  widget_button(bazr2,value='Create a classical Dial'    ,font=ft_b_normal,uvalue=[-88,219,3,baz1,bazar])
	 bazrb=  widget_button(bazr2,value='Create a Dial for Pad'      ,font=ft_b_normal,uvalue=[-88,219,4,baz1,bazar])
	endif

	widget_control,bazar ,group_leader=lamp_b1,/realize & put_logo
	widget_control,macro_area_a,set_uvalue=bazar
	XMANAGER, 'MacName'  ,bazar,event_handler='LAMP_EVENT_PARSER',/just_reg
return
end

pro pro_creater ,uv
;** ***********
;**
@dons.cbk
	widget_control,uv(3),get_value=curr_macr & curr_macr=strcompress(strlowcase(curr_macr(0)),/remove_all)
	idx=strpos(curr_macr,'.')
	if idx ge 0 then curr_macr=strmid(curr_macr,0,idx)
	idx=strpos(curr_macr,'dial_')
	if idx ge 0 then curr_macr=strmid(curr_macr,idx+5,30)
	MacName=curr_macr
	if uv(2) le 1 then curr_macr=MacName+'.pro'
	if uv(2) eq 2 then curr_macr=MacName+'.prox'
	if uv(2) eq 3 then curr_macr='dial_'+MacName+'.pro'
	if uv(2) eq 4 then curr_macr='dial_'+MacName+'_send.pro'

	widget_control,bad_id=i,mac_file ,set_value= curr_macr ,set_uvalue=uv(2)
	widget_control,bad_id=i,file_text,set_value='',/input_focus
	widget_control,bad_id=i,mac_labl ,set_value=' '

	if uv(2) eq 0 then mactxt=["FUNCTION "+MacName+" ; , p1 , p2 ,p3 ...",";********",";**" $
	                          ,";** The call is w6="+MacName+"(...)","","Wout=0","return, Wout","end"]

	if uv(2) eq 1 then mactxt=["PRO "+MacName+" ; , p1 , p2 ,p3 ...",";***",";**" $
	                          ,";** The call is "+MacName+",...","","print,!stime","end"]

	if uv(2) eq 2 then mactxt=[";Enter lines of IDL commands below. THE CALL will be @"+MacName $
	                          ,";Use one line loops (ie FOR i=0,n DO BEGIN ... & ... & ENDFOR" $
	                          ,";Use variables a-z only (and w1,x1,y1,z1,n1,e1,p1,pv1,w_tit(1),x_tit(1)...)"]

	if uv(2) eq 3 then begin
			   mactxt=[";*********************","PRO dial_"+MacName+"_macro, D" $
	                          ,";*********************",";**" $
	                          ,";** Input D is the dial structure as defined by the function dial_"+MacName $
	                          ,";** This macro procedure is called by George every D.frequency seconds","","" $
	                          ,"    IF D.init eq 0 THEN BEGIN D.init=1 & ENDIF   ;Do your cooking","" $
	                          ,"    V=DialNewValue(TYPE='status',/setvalue)      ;Get status from Mad" $
				  ,"    IF V eq 'Burning' then C=DialControl('stop') ;Stop Mad command" $
				  ,"    IF V eq 'StandBy' then D.frequency=3         ;Change frequency","end","","","" $
	                          ,";*********************","FUNCTION dial_"+MacName $
				  ,";*********************",";**",";** The dial constructor" $
				  ,"","    return,{FREQUENCY:1.5}","end","","","" $
				  ,";****************************************** THAT's ALL ****************","","","" $
				  ,"","   ;Dial Variables (Defaulted if not present in return statement)","   ;--------------" $
				  ,"   ;GENERIC='mad'    ;connect to the mad-idl interface" $
				  ,"   ;TYPE='monitor'   ;then V=DialNewValue() stands for V=DialNewValue(TYPE='monitor')" $
				  ,"   ;ONOFF=0          ;state of the Dial 1=running" $
				  ,"   ;FREQUENCY=1.     ;the Dial macro is executed each frequency seconds. if =0 then the general frequency is used" $
				  ,"   ;VALUE=fltarr(64) ;value you assign to the Dial. This value is automaticaly plotted. put errors in ERROR var." $
				  ,"   ;PLOT=0           ;-2=none 0=plot 1=surface 2=contour n>2 means show vector of last n scalar values" $
				  ,"   ;INIT=0           ;may be used in "+MacName+"_macro when started or on reset" $
				  ,"   ;UPPERLIM=0.      ;upper limit of the plot (LOWERLIM for lower limit)" $
				  ,"   ;HISTORY=0        ;=1 to record values in file "+MacName+".his" $
				  ,"   ;DURATION=0       ;if >0 then Dial is stopped after running duration seconds" $
				  ,"   ;WUPDATE=0        ;=1 to automaticaly update corresponding workspace, =-1 silent!" $
				  ,"                     ;=2 to automaticaly update and plot workspace to the main window" $
				  ,"                     ;   0,1,2 are set by pressing the left,middle,right mouse button on the dial snapshot" $
				  ,"","   ;User Variables (Must be present in return statement to be available)","   ;-------------" $
				  ,"   ;XVALUE=fltarr(64);Abscissa of VALUE  (ordinates go in YVALUE)" $
				  ,"   ;X_TIT='I am X'   ;X axis title       (Y axis title go in Y_TIT)" $
				  ,"   ;...              ;etc" $
				  ,"","   ;return, {generic:GENERIC,type:TYPE,value:VALUE,frequency:FREQUENCY,init:INIT}",""]
		mactxt=[mactxt $
		,";***************************************************************************************" $
		,";** Usefull calls to be used in procedure dial_"+MacName+"_macro :" $
		,";** *************" $
		,";** V=DialNewValue([/SETVALUE],[COMMENT=txt]   ;Get a new value from DIAL_'generic'_READ" $
		,";**                [TYPE='monitor'])           (a request is made to the instrument)" $
		,";**                                            (/SETVALUE means D.value is set to V)" $
		,";** C=DialControl ('command syntax',[CHECK=.5]);Send a command to the instrument control" $
		,";**                                            (CHECK means check every .5 sec till the" $
		,";**                                             command  is complete)" $
		,";** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'" $
		,";**                                                                of  the dial 'temp2'" $
		,";** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'" $
		,";** DialStart ,    'temp3'                     ;A short  for previous call" $
		,";** DialStop  ,    'temp3'                     ;A short  too" $
		,";**" $
		,";** DialModValue,   V ,[tag='VALUE']           ;Set the new value for current dial or" $
		,";** D.value   =     V                          ;modify yourself the tag Value if type &" $
		,";**                                            ;dimensions don't change.(same for Error)" $
		,";** D.upperlim=   150.                         ;Set upper limit for plotting." $
		,";**" $
		,";** R=DialOn ()                                ;Return 0 if Dial has been interrupted" $
		,";**                                            (To use inside loops)" $
		,";** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:" $
		,";**                           ,[PATH=path ]                dial_template4.pro" $
		,";**                                            (You may change its name to 'tmp4' and" $
		,";**                                            (use DialStart,'tmp4' to activate it)" $
		,";** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO" $
		,";**                                            ('template4'  is keept inactive, ONOFF=0)" $
		,";** DialClear,     'template4'                 ;Suppress dial  'template4' from memory" $
		,";** DialWSet                                   ;Reserve central draw window for next plot" $
		,";**" $
		,";** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value" $
		,";**                [DURATION=90.] ,   [/START] ;              (time is in seconds)" $
		,";**                                            ;Stop or Start the general process" $
		,";**                                            ;Set  Time  limit for the active process"]
		endif
	if uv(2) eq 4 then mactxt=["FUNCTION dial_"+MacName+"_send, dummy1,dummy2, text, button",";*******",";**" $
	                          ,";** Called from the Pad, generaly to start and stop Dials","" $
                                  ,"Dials=strlowcase(strtrim(str_sep(text(0),'~'),2))","" $
				  ,"FOR i=0,n_elements(Dials)-1 DO BEGIN" $
                                  ,"    DialInit ,Dials(i)" $
	                          ,"    DialTag  ,Dials(i),tag='FREQUENCY',set=1.0" $
	                          ,"    DialStart,Dials(i)" $
				  ,"ENDFOR" $
	                          ,"","return,0","end","","","","","","" $
		,";***************************************************************************************","" $
		,";** Usefull calls to be used in procedure dial_"+MacName+"_send :" $
		,";** *************" $
		,";** DialTag   ,    'temp2',TAG='VALUE',GET=V   ;Return V,the value for the tag  'VALUE'" $
		,";**                                                                of  the dial 'temp2'" $
		,";** DialTag   ,    'temp3',TAG='ONOFF',SET=1   ;Set to 1 the value of  the tag  'ONOFF'" $
		,";** DialStart ,    'temp3'                     ;A short  for previous call" $
		,";** DialStop  ,    'temp3'                     ;A short  too" $
		,";**" $
		,";** DialInit,      'template4',[NEW='tmp4']    ;Initiate dial  'template4' from file:" $
		,";**                                                               dial_template4.pro" $
		,";**                                            (You may change its name to 'tmp4' and" $
		,";**                                            (use DialStart,'tmp4' to activate it)" $
		,";** DialMacro,     'template4'                 ;Force execution of DIAL_TEMPLATE4_MACRO" $
		,";**                                            ('template4'  is keept inactive, ONOFF=0)" $
		,";** DialClear,     'template4'                 ;Suppress dial  'template4' from memory" $
		,";** DialWSet                                   ;Reserve central draw window for next plot" $
		,";**" $
		,";** DialsFrequency,[GET=freq],[SET=.5],[/STOP] ;Set  or Get the general frequency value" $
		,";**                [DURATION=90.] ,   [/START] ;              (time is in seconds)" $
		,";**                                            ;Stop or Start the general process" $
		,";**                                            ;Set  Time  limit for the active process"]

widget_control,bad_id=ii,uv(4),/destroy
widget_control,bad_id=ii,file_text,set_value=mactxt
return
end

pro pro_compile
;** ***********
;**
@dons.cbk

widget_control,bad_id=i,mac_file ,get_value=curr_macr ,get_uvalue=typ
curr_macr=strlowcase(strtrim(curr_macr(0),2))

if curr_macr ne '' then begin
	widget_control,bad_id=i,file_text,get_value=new_macro
	
	bat=strmid (curr_macr,strpos(curr_macr,'.'),5)
	ran=long((systime(1)-(long(systime(1)/10000))*double(10000))*100)
	ran=strtrim(string(randomu(ran)),2) & ran=strmid(ran,strpos(ran,'.')+1,4)
	poc='n'+ran+curr_macr
	pac=strmid (poc,0,strpos(poc,'.'))

	!Error=0
	
	ON_IOERROR,mis_open & out2=-1
	OPENW ,out2,        curr_macr,/get_lun
	ON_IOERROR,mis_io
	for i=0,n_elements(new_macro)-1 do PRINTF,out2,new_macro(i)
	FREE_LUN,out2 & out2=-1
	
	DON_COMP, new_macro, bat

	P_MUS,'mus_shot'
	mac_list ,n_emacs, /set
	widget_control,bad_id=i,mack     ,set_value=macros
	
mis_io: if out2 gt 0 then free_lun,out2
	
mis_open:if !Error ne 0 then widget_control,bad_id=i,mac_labl ,set_value=!err_string  $
			else widget_control,bad_id=i,mac_labl ,set_value=curr_macr+' Created'

endif
return
end

pro don_comp, new_macro, bat
;** ********
;**
	resol =0
	if (not sys_dep("EMBEDDED")) and (not sys_dep("RUNTIME")) then resol=1
	if (resol eq 1)  and (sys_dep ('VERSION') ge 4.0)         then resol=2
	poc='lamp_tmp.pro'
	pac='lamp_tmp'
	if resol gt 0 then begin out1=-1
	   ON_IOERROR,mis_cmp
	   OPENW ,out1,poc,/get_lun
	   if bat ne '.pro' then PRINTF,out1,'pro '+pac
	   for i=0,n_elements(new_macro)-1 do PRINTF,out1,new_macro(i)
	   PRINTF,out1,''
	   if bat ne '.pro' then PRINTF,out1,'end' $
	   else begin	PRINTF,out1,'pro '+pac & PRINTF,out1,'end'
			endelse
	   PRINTF  ,out1,''
 	   FREE_LUN,out1 & out1=-1

	  if resol eq 1 then iii=EXECUTE   ( pac )
	  if resol eq 2 then RESOLVE_ROUTINE,pac

	  mis_cmp:if out1 gt 0 then free_lun,out2
	 ;OPENR ,out1,poc,/get_lun,/DELETE & FREE_LUN,out1 & out1=-1
	endif
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pro par_disp, event
;** ********
;**compile
@lamp.cbk
@dons.cbk
;USERPAR BUTTON     
;
; Construct the text
      if nwk le 0 then nwk=1

      par_txt_all(*)=''
      npa=0L
      bb=execute('npa=n_elements(p'+strtrim(string (nwk),2)+')' )
      i =0
      bb=execute('for i=0,npa-1 do par_txt_all(i)=strtrim(par_txt(nwk,i))+string(p' $
      						   +strtrim(string (nwk),2) + '(i))')

      up_t    =widget_base  (title='LAMP Instrument Parameters',/column,resource_name='lampdon')
      bar1    =widget_base  (up_t,/row)
	       put_logo	    ,widget_base(bar1,/column)
      donebut =widget_button(bar1,value='Write')
      abortbut=widget_button(bar1,value='Quit')
      up_slid =widget_slider(bar1,value=nwk,title='Workspace #',maximum=lamp_sys,$
								minimum=1,xsize=200)
      up_labl =widget_label (bar1,value='Numor #',xsize=8*10)
      mc_bidon=widget_label (bar1,value=' '	 ,xsize=4)
      up_win  =widget_text  (up_t,xsize=51,ysize=31,/scroll,/editable,font=ft_propor)
      bid=sys_dep      ('DYNLAB',up_t,0)
      widget_control,up_t,group_leader=lamp_b1,/realize & put_logo
      widget_control,up_win   ,bad_id=i,set_value =  par_txt_all
      widget_control,up_slid  ,bad_id=i,set_uvalue=[-88,206,up_win,up_slid,up_labl,0,0,0,0]
      widget_control,donebut  ,bad_id=i,set_uvalue=[-88,205,up_win,up_slid,up_labl,0,0,0,0]
      widget_control,abortbut ,bad_id=i,set_uvalue=[-88,299,0,0,0,0,0,0,0]

      XMANAGER, 'ups' ,up_t,event_handler='LAMP_EVENT_PARSER',/just_reg
      return
      end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pro par_mod,event,up_win,up_slid
;** *******
;**
@lamp.cbk
@dons.cbk
; DONE button in USERPAR display

      i=0
      widget_control,bad_id=i,up_slid,get_value=nwk
      if i eq 0 then begin
      	widget_control,bad_id=i,up_win, get_value=par_txt_all
      	n   =n_elements(par_txt_all)
      	junk=fltarr(n)
      	for j=0,n-1 do begin
          sht_txt=strtrim (par_txt_all(j))
          lnth=strlen(sht_txt)
;
;         Pick out number after '='

          npos   =rstrpos(sht_txt,'=')
          par_len=lnth-npos
          par_val=strmid(sht_txt,npos+1,par_len)
          junk(j)=float(par_val)
      	endfor

      	bb=execute('p' + strtrim(string(nwk),2) + '=junk' ) 

;	Destroy the evidence
      	wait,.3 & widget_control,event.top,/destroy
      endif
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pro nwk_mod,event,up_win,up_slid,up_labl
;** *******
;**
@lamp.cbk
@dons.cbk
;
;Changes current workspace
    widget_control,bad_id=i,up_slid,get_value=nwk
    widget_control,bad_id=i,up_labl,set_value=w_numor(nwk)

      par_txt_all(*)=''
      npa=0L
      bb=execute('npa=n_elements(p'+strtrim(string (nwk),2)+')' )
      i =0
      bb=execute('for i=0,npa-1 do par_txt_all(i)=strtrim(par_txt(nwk,i))+string(p' $
      						   +strtrim(string (nwk),2) + '(i))')
;
;   Update window text

    widget_control,bad_id=i,up_win,set_value=par_txt_all
return
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

function str_focc, s,c1,c2,c,f
;******* ********
;**
l=strlen(s) & occ=0
for i=f,l-1 do begin ch=strmid(s,i,1)
    if ch eq c  then if occ le 0 then return,i
    if ch eq c1 then occ=occ+1 else if ch eq c2 then occ=occ-1
endfor
return,-1
end

pro find_w1_w2, line,line_2,one,two,three ,alone ,splitxyz ,opp_r
;** **********
;**
common eme456,	fourth,fifth,sixth

;find first two workspaces on line
;must be an "="
;must be one "w" each side of "="

splitxyz=['no']
line_2  =''
opp_r   =''
one     =0
two     =0
three   =0 & fourth=0 & fifth=0 & sixth=0
alone   =0
ok3	=0

;find first "w"
;--------------
line =strcompress(line)
lnth =strlen(line)
pos_w=-1
ch1  ='a'
while ((ch1 lt '0') or (ch1 gt '9')) do begin
	pos_w=strpos(strlowcase(line),'w',pos_w+1)
	if pos_w lt 0 then RETURN
	ch1=strmid(line,pos_w+1,1)
endwhile

;find  ","
;--------
pos_v=strpos(line,',')

;find  "="
;--------
pos_e=strpos(line,'=')
if pos_v ge 0 then if pos_v lt pos_w then pos_e=-1
		   if pos_e lt pos_w then pos_e=-1

;find a lone "w"
;---- ---------
if pos_e le 0 then begin
	ch1=strmid(line,pos_w+1,1)
	if (ch1 ge '0') and (ch1 le '9') then begin
		ch2=strmid(line,pos_w+2,1)
		if (ch2 lt '0') or (ch2 gt '9') then alone=fix(ch1)   $
			   			else alone=fix(ch1+ch2)
	endif
	RETURN
endif

; is there a second "w" before the "="?
;--------------------------------------
line_t=strmid(line,pos_w+1,pos_e-(pos_w))
pos_t =strpos(strlowcase(line_t),'w')
if pos_t gt 0 then RETURN

;what follows first "w";Is it a number?
;--------------------------------------
ch1=strmid(line,pos_w+1,1)
if (ch1 lt '0') or (ch1 gt '9') then RETURN

;next;Try a case       (care wi(m,n)=x --> assume two=one to keep history)
;---------------
ch2=strmid(line,pos_w+2,1) & pd2=3
if ch2 eq ' ' then begin     pd2=4 & ch2=strmid(line,pos_w+3,1) & endif
case 1 of
  (ch2 eq ' '): one=fix(ch1)
  (ch2 eq '='): one=fix(ch1)
  (ch2 eq '+'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ;Compound operation
  (ch2 eq '-'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '*'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '/'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '^'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '#'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '<'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '>'): begin one=fix(ch1) & two=one & opp_r=ch2 & ok3=-1 & end ; ""
  (ch2 eq '('): begin one=fix(ch1) & two=one & end
  (ch2 eq '['): begin one=fix(ch1) & two=one & end
  (ch2 lt '0')  or (ch2 gt '9'): RETURN
  else:         begin one=fix(ch1+ch2)
		      ch3=strmid(line,pos_w+pd2,1)
		      if ch3 eq ' ' then ch3=strmid(line,pos_w+pd2+1,1)
		      if (ch3 eq '(') or (ch3 eq '[') then two=one
		      if (ch3 eq '+') or (ch3 eq '-') or (ch3 eq '*') or (ch3 eq '/') or (ch3 eq '^') or (ch3 eq '#') or $
		         (ch3 eq '<') or (ch3 eq '>') then begin two=one & opp_r=ch3 & ok3=-1 & endif
		end
endcase


; is there a "w" after the "="
;-----------------------------
;This is repeated until a "w" if followed by an number or eol
iquit=0 & pos_e1=pos_e
while (iquit eq 0) do begin
	line_2=strmid(line,pos_e,lnth-pos_e)
;	find second or third "w"
	pos_w =strpos(strlowcase(line_2),'w')
	if pos_w lt 0 then begin
		iquit=1
		RETURN
		endif

;	what follows second or third "w"
	ch1=strmid(line_2,pos_w+1,1)
;	Is it a number?
	if (ch1 ge '0') and (ch1 le '9') then begin

		ch2=strmid(line_2,pos_w+2,1)
		po3=pos_w+3
		case 1 of
	  	(ch2 eq ''):  if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
	  	(ch2 eq ' '): if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
		(ch2 eq '(') or (ch2 eq '['): begin po3=po3-1
			      if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
			      end
	  	else: 	      if (ch2 ge '0') and (ch2 le '9')  then begin
			      if two    eq 0 then two   =fix(ch1+ch2) else $
		              if three  eq 0 then three =fix(ch1+ch2) else $
		              if fourth eq 0 then fourth=fix(ch1+ch2) else $
		              if fifth  eq 0 then fifth =fix(ch1+ch2) else $
			      if sixth  eq 0 then sixth =fix(ch1+ch2)
			      endif else begin
			      if two    eq 0 then two   =fix(ch1) else $
		              if three  eq 0 then three =fix(ch1) else $
		              if fourth eq 0 then fourth=fix(ch1) else $
		              if fifth  eq 0 then fifth =fix(ch1) else $
			      if sixth  eq 0 then sixth =fix(ch1)
			      endelse
		endcase

;	Check for splitxyz
		pe=po3
		lp=pos_w+1
		chbrk=strmid(line_2,po3,1) & if chbrk eq '(' then chprbk=')'
		                             if chbrk eq '[' then chprbk=']'
		if (chbrk eq '(') or (chbrk eq '[') then $
		 if three gt 0 then pe=(str_focc(line_2,chbrk,chprbk,chprbk,po3+1)+1)>po3 else $
		 if ok3   eq 0 then begin
		   lp =str_focc(line_2,chbrk,chprbk,chprbk,po3+1)
		   
		   if (lp gt po3+1) then splitxyz=['yes','','','',strmid(line_2,po3,lp-po3+1)]
		    		   
		   fv =str_focc(line_2,'(',')',',',po3+1)
		    
;**		     SPLIT X
;**		     -------	    
		     if (fv lt 0) or (fv gt lp)   then ib=lp else  ib=fv
		     splitxyz(1)=strmid(line_2,po3+1,ib-po3-1)
		    
		     if fv gt 0 then begin
		        sv =str_focc(line_2,'(',')',',',fv+1)
		      
;**		        SPLIT Y
;**		        -------		    
		     	if (sv lt 0) or (sv gt lp) then ib=lp else  ib=sv
		     	splitxyz(2)=strmid(line_2,fv+1,ib-fv-1)
		      
		        if sv gt 0 then begin
		      	   tv =str_focc(line_2,'(',')',',',sv+1)
		      
;**		      	   SPLIT Z
;**		    	   -------		    
		     	   if (tv lt 0) or (tv gt lp) then ib=lp else  ib=tv
		     	   splitxyz(3)=strmid(line_2,sv+1,ib-sv-1)
		       endif
		    endif
;if splitxyz(0) eq 'yes' then print,splitxyz(1),'_',splitxyz(2),'_',splitxyz(3),'_',splitxyz(4)
		 endif
; is there a third "w" ?
;-----------------------
		if ok3 lt 0  then begin   if three gt 0 then begin
					    pe_l  =strcompress(strmid(line_2,pe,10),/remove_all)
					    if pe_l eq '' then begin
					       line_2=strmid(line,pos_e1,pos_e+pos_w-pos_e1+1)
					       if strpos(line_2,'+') ge 0 then opp_r=opp_r+'+'
					       if strpos(line_2,'-') ge 0 then opp_r=opp_r+'-'
					       if strpos(line_2,'/') ge 0 then opp_r=opp_r+'/'
					       if strpos(line_2,'*') ge 0 then opp_r=opp_r+'*'
					       if strpos(line_2,'#') ge 0 then opp_r=opp_r+'#'
					    endif
					    ok3=1
					  endif
		endif
		if ok3 eq 0 then ok3 =-1
		pos_e1=pos_e+lp
	endif
	pos_e=pos_e+pos_w+1
	if pos_e ge lnth then RETURN
endwhile
RETURN
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


pro to_don_history, did_one , did_two , line ,nojournal=nojournal
;** **************
;**
@lamp.cbk
@dons.cbk
	kp_one=one & kp_two=two
	one=did_one
	two=did_two
	if (not keyword_set(nojournal)) then ifixed=1 else ifixed=0
 	his_mod,  line , ''
	ifixed=0
	if did_one lt 0 then begin one=kp_one & two=kp_two & endif
 return
end

pro his_mod,line,line_2
;** *******
;**
;Modify history of one
@lamp.cbk
@dons.cbk

IF one ge 0 THEN BEGIN
dim=[0L,0L]
wkspce='w'+strtrim(string(one),2)
wkspac='w'+        string(one,format='(i2)')
i=execute('dim=size('+wkspce+')')
tipe=dim(dim(0)+1)
case tipe of 		;+newtypes*****
   1: lims(one)='Byte   '
   2: lims(one)='Integer'
   3: lims(one)='Long   '
   4: lims(one)='Float  '
   5: lims(one)='Double '
   6: lims(one)='Complex'
   7: lims(one)='String '
   8: lims(one)='Struct '
   9: lims(one)='Dcomplx'
   10:lims(one)='Pointer'
   11:lims(one)='Object '
   12:lims(one)='Uintegr'
   13:lims(one)='Ulong  '
   14:lims(one)='Int64  '
   15:lims(one)='Uint64 '
else: lims(one)='Undef  '
endcase
lims(one)=wkspac+': '+lims(one)

if dim(0) ge 1 then lims(one)=lims(one)+' dim = '   + strtrim(string(dim(1)),2)
if dim(0) ge 2 then lims(one)=lims(one)+' * '       + strtrim(string(dim(2)),2)
if dim(0) ge 3 then lims(one)=lims(one)+' * '       + strtrim(string(dim(3)),2)
if dim(0) ge 4 then lims(one)=lims(one)+' * '       + strtrim(string(dim(4)),2)

miny=0.
maxy=0.	;+newtypes*****
if ((tipe gt 0) and (tipe lt 7)) or (tipe eq 9) or ((tipe ge 12) and (tipe le 15)) then begin
  if dim(0) gt 0 then begin
    i=execute('maxy=max('+wkspce+',min=miny)')
    if sys_dep('MATLAB') then $
    i=execute('miny=min('+wkspce+')')
    if tipe eq 1 then begin miny=fix(miny) & maxy=fix(maxy) & endif

    lims(one)=lims(one)+' min='+strtrim(string(miny),2)+$
			' max='+strtrim(string(maxy),2)
  endif else begin
    i=execute('miny='+wkspce)
    if tipe eq 1 then miny=fix(miny)

    if miny ne 0 then lims(one)=lims(one)+' Scalar='+  strtrim(string(miny),2) $
		 else lims(one)=' '
  endelse
endif

w_min(one)=miny
w_max(one)=maxy

DON_LIM_SENS

if ihis eq 0 then begin
		  n=n_elements(limtxt)
		  i=0 & chk='w'+string(last_w,format='(i2)')
		  if n gt 1 then $
			for j=1,n-1 do if strmid(limtxt(j),0,3) eq chk then i=j
		  if his_info gt 0 then $
		  widget_control,bad_id=ii,his_info ,set_value=limtxt,   $
						     set_text_top_line=i $
		  else if l_message gt 0 then $
		  widget_control,bad_id=ii,l_message,set_value=lims(one) $
		  else print,lims(one)
		  endif
if two  lt 0 then begin
; update info only
endif else begin
;
; search for another wkspce after the =
   pos2=strpos(line_2,wkspce)
;
; when wkspce appears again append history
   if pos2 ge 0 then begin
      his(one)=line+' ... '+his(one)

; when wkspce appears again but not the same
   endif else if two gt 0 then begin
      his(one)=line+' ... '+his(two)

; when no second workspace just use line as history
   endif else begin
	his(one)=line
      if ((tipe  gt 0) and (tipe lt 7)) or (tipe eq 9) or ((tipe ge 12) and (tipe le 15)) then $
	if (dim(0) eq 0) and (miny eq 0) then his(one)=' '
   endelse
endelse

wtb(one)=0
if (one gt 0) and (one le lamp_sys) then begin i=execute('Sna'+strtrim(string(one),2)+'=0')
                                    if abs(sys_dep('MAP')) ne 1 then $
				      if ifixed ne 0 then to_did_cur , wkspce
endif
histxt=his(where(his ne ' '))
if ihis eq 1 then if his_info gt 0 then $
		  widget_control,bad_id=i,his_info ,set_value=histxt   $
		  else if l_message gt 0 then $
		  widget_control,bad_id=i,l_message,set_value=his(one) $
		  else print,his(one)
ENDIF

if ifixed eq 1 then begin
		  DID_WRITE_JOURNAL,/check & j=n_elements(jou_c)-1
		  if one lt  0 then begin one=0
		   i=strpos(strlowcase(line),'see')
		   if i ge 0 then i=strpos(strlowcase(jou_c(j)),'see') $
		             else i=strpos(strlowcase(line)    ,'passw')
		   if i lt 0 then begin jou_c=[jou_c,line]
					j=n_elements(line)  & lines=strarr(j)
					jou_w=[jou_w,lines]
		   endif else begin lines='' & line='' & endelse
		   
		  endif else begin
		   if b_labins(6) then if b_labins(7) gt 0 then if one gt 0 then begin
			     widget_control,bad_id=iii,b_labins(7),set_value=lims(one)
		   endif
                   if (one gt 0) and (two gt 0) then line=his(one)
		   jou_c=[jou_c,line]  & lines=';'+lims(one)
		   jou_w=[jou_w,lines] & endelse
		   
    i=xregistered('JOURNAL')
    if line ne ''  then  $
    if i gt 0 then begin widget_control,bad_id=i,lamp_don(0),get_uvalue=basc
    			 linn=n_elements(jou_c) & lnew=line+'            '+lines
			 if linn lt 10 then begin
			 	widget_control,bad_id=i,basc,set_value=jou_c+'            '+jou_w
			 endif else $
			 	widget_control,bad_id=i,basc,set_value=lnew,$
                                /append,SET_TEXT_TOP_LINE=(n_elements(jou_c)-18)>0
    endif
endif
end

pro DON_LIM_SENS
;** ************
;**
@lamp.cbk

limtxt=lims(where(lims ne ' '))

if n_elements(lamp_don) gt 2 then begin
 nl=n_elements(limtxt) & j=-1
 if (nl gt 1) and (lamp_don(1) eq 1) then begin lamp_don(1)=0 & j=1 & endif
 if (nl le 1) and (lamp_don(1) eq 0) and (n_elements(w1) lt 2) then begin lamp_don(1)=1 & j=0 & endif

 if GEORGE ne 1 then $
 if  j ge 0 then begin  for i=2,n_elements(lamp_don)-1 do $
		     widget_control,bad_id=ii,lamp_don(i),sensitive=j
 endif
endif
end
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
pro fire_prog_mac,event,num1,num2, prox
;** *************
;**
@dons.cbk
;
; Put programmed key macro command into formula window for last workspace

comy=[' ']
if prox eq 0 then begin
	widget_control,num2  ,bad_id=ii,get_value=comy & comy=comy(0)
	jj=strpos(strlowcase(comy),'passw')
	if jj ge 0 then widget_control,num2  ,bad_id=ii,set_value=""
	if jj lt 0 then if num1 ge 0 then prog_mac(num1)=comy
	xfor=strtrim(comy,2)  & xicuter,xfor
endif else begin
      widget_control,prox    ,bad_id=ii,get_uvalue=tot
;;    lab='Play all'
;;    widget_control,event.id,bad_id=ii, set_value='Stop!'
      nl=n_elements(tot)  & k=0
      CATCH,stat & if stat ne 0 then begin print,!err_string & k=nl & endif
      while (k lt nl) do begin
	widget_control,tot(k),bad_id=ii,get_value=comy
	k=k+1
;;	evv=widget_event(evv.top,/nowait) & widget_control,/hourglass
;;	if  evv.id ne 0 then k=nl else $          ; if RDSTOP(1,nl,(k)) then k=nl
	xfor=strtrim(comy(0),2) & xicuter,xfor
	RDSTAP,1,nl,(k),res & if res then k=nl
      endwhile
;;    widget_control,event.id,bad_id=ii, set_value=lab
endelse
return
end
;

pro don_write_prog_mac ,flg
;** ******************
;**
;** Write user command list and begood options
@dons.cbk
@lamp.cbk

 common c_draw,	w0,xx,yy,axy,uxy,wnumber,v,p,thresh,rx,rz,nlv,tcol,siz,flgsurf,$
		wbeside,vfl,styles,w4d,smoo,vff
    
	 n=n_elements(prog_mac)

	 if flg eq 0 then begin
	    for k=0,n-1 do begin
	     comy=[' ']
	     if prog_txt(k) gt 0 then begin
	     	widget_control,prog_txt(k),bad_id=i,get_value=comy
		
		if i ne 0 then prog_txt(k)=0 else prog_mac(k)=comy(0)
	     endif
	    endfor
	 endif

         on_ioerror, end_fc
	 bid=findfile('lamp.cds',count=cnt)
         if cnt gt 0 then bid=sys_dep('DELET','lamp.cds')
	 out=-1 & openw,out ,'lamp.cds',/get_lun
         for k=0,5 do printf,out,prog_mac(k)
         printf,out,' '
         printf,out,lamp_devps
         printf,out,' '
         printf,out,rx,rz,nlv,'   For rx ry nlv'
         printf,out,' '
         printf,out,styles(0,0),styles(1,0),styles(2,0),!P.psym,'   For styles !P.psym'
         printf,out,' '
         printf,out,inst_value
         printf,out,' '
         printf,out,tcol,'   For color table #'
         printf,out,' '
         printf,out,smoo,'   For smooth image '
         printf,out,' '
         printf,out,'Free line'
         printf,out,'Free line'
         printf,out,' '
	 
         for k=6,n-1 do printf,out,prog_mac(k)
	 
	 end_fc: if out gt 0  then free_lun,out
return
end

pro set_cur_work,event
;** ************
;**
@lamp.cbk
	w =event.index
	wk=strmid(limtxt(w),0,3)
	to_did_cur , wk
return
end

pro show,string_in
;** ****
;**
;
;Handles sho command
;
@lamp.cbk
@dons.cbk
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

     	rhs =' '
	moan='Cant show '
	stat=0 & jjj=1
	catch,stat

        if (stat ne 0) or  (jjj ne 1) then begin
		     catch,/cancel
		     P_MUS,'mus_cannon'
		     if l_message le 0 then print,moan+rhs else $
      		     widget_control,bad_id=iii,l_message,set_value=moan+rhs
      		     print,string(7b)
		     return
        endif else begin

	   string_in=strtrim(string_in,2)
	   coma=strpos(string_in,',')
	   if (coma le 0) then coma=strpos(string_in,' ')
	   fin =strlen(string_in)
	   lstr=fin-coma
	   if (coma le 0) or (coma eq fin-1) then return
	   rhs =strmid(string_in,coma+1,lstr)

	   abc=' '
	   xfor='abc='+rhs & jjj=execute(xfor)

	   icheck=n_elements(abc)
	   if icheck gt 1  then abc=reform(abc,icheck,/overwrite)
	   if icheck gt 10 then abc=abc(0:9)
 	   ans=string(abc)
	   
	   if GEORGE gt 0 then begin
		if icheck gt 10 then ans=['!first elements printed ...',ans]
		to_don_history,-1,0,ans
		WebDo,'log',['SHOW',ans],12
	   endif
	   if formtxt le 0 then begin
              if icheck eq 1 then  if l_message le 0 then print,ans else $
					widget_control,l_message,bad_id=iii,set_value=ans $
              else begin print,ans & ans='!first elements printed ...'
			 if l_message le 0 then print,ans else $
              		 widget_control,bad_id=iii,l_message,set_value=ans
              endelse
           endif else begin
	      if l_message le 0 then begin
		print,ans
		if icheck gt 10 then print,'Woops - Only first 10 elements given'
	      endif else begin
              	if (b_labins(6) and b_labins(7) gt 0) then $
              	widget_control,b_labins(7),bad_id=iii,set_value=ans(0) else $
              	widget_control,formtxt    ,bad_id=iii,set_value=ans,/append
              	widget_control,formtxt    ,bad_id=iii,set_value='' ,/append
	      	if icheck gt 10 then begin
		         i_bust='Woops - Only first 10 elements given'
      		         widget_control,bad_id=iii,l_message,set_value=i_bust
	      	endif else widget_control,bad_id=iii,l_message,set_value=' '
	      endelse
           endelse
endelse

return
end

pro show_internal,uv
;** *************
;**
txti="" & internal,txti & widget_control,bad_id=ii,uv(2),set_value=txti
                          widget_control,bad_id=ii,uv(3),set_value="internal.prox"
end

pro internal,txti
;** ********
;**
txti=[$
";       INTERNAL PROCEDURES AND FUNCTIONS accessible from command lines",$
";       -------- ---------- --- ---------         as from macros.",$
" ",$
";       DRAWIND     Draw    procedure         (window device)",$
";       SEE         Draw    procedure         (gif, png,  ps)",$
";       SEEM        Draw    procedure",$
";       P_SET_FONT  Draw    procedure         (window device)",$
";       SUPRPLOT    Draw    interface         (window device)",$
";       GFIT        Draw    interface         (window device)",$
";       DON_DO_CMD  Do      interface         (window device)",$
" ",$
";       POSITIVE    Convert procedure",$
";       W_ACCU      Add     procedure",$
" ",$
";       RDSET       Read    procedure",$
";       RDRUN       Read    function",$
";       RDSUM       Read    function",$
";       RDAND       Read    function",$
";       RDOPR       Read    function",$
";       CALIBRATION Read    function",$
";       RDFILTER    Read    interface",$
" ",$
";       READ_LAMP   Read    procedure",$
";       WRITE_LAMP  Write   procedure",$
";       SAVESESSION Write   procedure",$
" ",$
";       SHOW        Print   procedure",$
";       SETCOL      Color   procedure         (window device)",$
" ",$
";       TRAP        Scale   procedure         (window device)",$
";       TRAPX       Scale   procedure         (window device)",$
";       TRAPY       Scale   procedure         (window device)",$
";       TRAPT       Total   procedure         (window device)",$
" ",$
";       XICUTE      Lamp    procedure",$
";       SETMANIP    Lamp    procedure",$
" ",$
";       TAKE_DATP   param   procedure",$
";       GIVE_DATP   param   procedure",$
";       MOD_DATP    param   procedure",$
";       TAKE_W      param   procedure",$
";       GIVE_W      param   procedure",$
";       W_STORE     param   procedure",$
";       W_RESTORE   param   procedure",$
";       W_EXCHANGE  param   procedure",$
" ",$
";       MYINIT      init    procedure",$
";       MYHELP      init    procedure",$
";       P_LAYOUT    init    procedure",$
" ",$
" ",$
";pro    DRAWIND [,xsize] [,ysize] [,DrawId=drawid]",$
";***    *******",$
";**",$
";**     Creates a drawing window for plotting in user_macros (default size is 512*512).",$
";**     The  call is DRAWIND,600,600 ,DrawId=drawid         (drawid is returned).",$
" ",$
" ",$
";pro    SEE, W=i [,/Contour ,/Surface ,/Beside ,/Replot,/Screen,/Gif,/Png,/Ps ,XYpixels=[xsz,ysz] ]",$
";***    ***  ",$
";**",$
";**     Has the same function as the 'Plot Wi' button.",$
" ",$
" ",$
";pro    SEEM  [,/Beside ,/Below ,/Image ,/Contour ,/Surface ,Rot=angle",$
";***    ****   ,/Regular, Xrange=[x1,x2], Yrange=[y1,y2] ,/Log ,Zlim=max ]",$
";**",$
";**     SEEM replaces all buttons within DISPLAY WORKSPACE area.",$
" ",$
" ",$
";pro    P_SET_FONT ,size",$
";***    **********",$
";**",$
";**     Changes the look of next graphics interfaces. size is 0,1,2 for large,medium,small ",$
";**     The  call is P_SET_FONT ,2",$
" ",$
" "] & txti=[txti,$
";pro    SUPERPLOT",$
";***    *********",$
";**",$
";**     Interface for over_plotting workspaces.",$
" ",$
" ",$
";pro    GFIT",$
";***    ****",$
";**",$
";**     Interface for fitting.",$
" ",$
" ",$
";pro    DON_DO_CMD",$
";***    **********",$
";**",$
";**     Creates new Do command buttons.",$
" ",$
" ",$
";pro    POSITIVE, w_in",$
";***    ********",$
";**",$
";**     Transforms an integer*2 unsigned array in a long positive one.",$
";**     The  call is POSITIVE ,W1",$
" ",$
" ",$
";pro    W_ACCU, accu=i , add=j [, tolerance=t]",$
";***    ******",$
";**",$
";**     This procedure adds workspace number j to workspace accumulator number i.",$
";**     using the monitors Ni,Nj and propagating the errors EI,Ej.",$
";**     The tolerance is used for vectors; the default is MIN([step(Xi),step(Xj)])/3",$
";**     The call is   W_ACCU, accu=1         (for W1=0)",$
";**                   W_ACCU, accu=1 , add=3 (for W1=W1+W3  using N1,N3,X1,X3,E1,E3)",$
" ",$
" "] & txti=[txti,$
";pro    RDSET  , INST=inst  ,BASE=base [,CYCLE=965] [,STEP=.14553]  [,TOLERANCE=.2]",$
";***    *****              [,/RAW] [,/DEF] [,/DIR] [,/DIF] [,LAST=procedureName]",$
";**                        [,/SUFFIX=string] [,/PREFIX=string] ",$
";**",$
";**     This procedure changes the current instrument name and (or)",$
";**                            the current base access (see Customize).",$
";**     This procedure can also be used to change specific read-variables [STEP,TOL]." ,$
";**                              [/RAW] means do not use treatment in read operations.",$
";**                              [/DEF] means use specific treatment  during the read.",$
";**                              [/DIR] [DIF] [/SUF] [/PREF] specific use at ILL,ESRF.",$
";**                              [LAST=proc]  proc is the name of a procedure called by",$
";**                                           Lamp just after a multiple read (proc,j,data)",$
";**                                           j is worksp number & data is Wj values",$
";**     The  call is RDSET, INST='D20' , BASE='Current Path'",$
" ",$
" ",$
";function RDRUN  , runnumber [,DATP=datp] [,W=i]",$
";******** *****",$
";**",$
";**       This function reads the run number from the currently selected instrument.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       The  call is  W1 = RDRUN(1280)",$
" ",$
" ",$
";function RDSUM  , firstrun,lastrun [,DATP=datp] [,W=i] [,/COMPLEMENT]",$
";******** ***** ",$
";**",$
";**       This function reads and adds the run numbers range from the selected instrument.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       If COMPLEMENT is set then Wi is not erased before read",$
";**       The  call is  W1 = RDSUM(1280,1295)",$
" ",$
" ",$
";function RDAND  , firstrun,lastrun [,DATP=datp] [,W=i] [,/COMPLEMENT]",$
";******** ***** ",$
";**",$
";**       This function reads and joins the run numbers range from the selected instrument.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       If COMPLEMENT is set then Wi is not erased before read",$
";**       The  call is  W1 = RDAND(1280,1295)",$
" ",$
" "] & txti=[txti,$
";function RDOPR  , text [,DATP=datp] [,W=i]",$
";******** ***** ",$
";**",$
";**       This function reads specified runs and performs basic operations on them.",$
";**       If datp is set and non 0, all parameters are returned in datp (see READ_tmp.pro).",$
";**       If W is set to 1<i<20 then reading is made in workspace wi",$
";**       The  call is  W1 = RDOPR( ' 624 + 627>629 - 630>631 - 633 ' )",$
";**                     W2 = RDOPR( ' 624 : 627 ' )",$
";**",$
";**       Result of W1  is   624+ (627+628+629) - (630+631) -633",$
";**       Result of W2  is   [[624],[625],[626],[627]] the runs are joined..!",$
" ",$
" ",$
";pro      CALIBRATION [,FILE=file ,NOCAL=nocal ,LIST=list]",$
";**       ***********",$
";**",$
";**       This procedure sets or unsets calibrations.",$
";**       In   window mode the call is  CALIBRATION",$
";**       In   batch  mode the call is  CALIBRATION, file='calibration_file'",$
";**                                 or  CALIBRATION, /nocal [,/list]",$
" ",$
" ",$
";pro      RDFILTER  [,XRANGE =xrg   ,YRANGE=yrg ,ZRANGE=zrg ,XMASK=xtext ,YMASK=ytext $",$
";***      ********   ,MONIMOD=momod ,XPROJ=xproj ,YPROJ=yproj,ZPROJ=zproj,WKSP =wksp  $",$
";**                  ,MONIVAL=value ,SIGMA=sigma ,TOLERANCE=latol  , SELECTION =selec ]",$
";**",$
";**       This procedure creates a general window interface for the use of",$
";**       the  above function RDOPR.",$
";**       In batch mode, use the keywords. The call is:",$
";**       RDFILTER   ,XRANGE=[10,60] ,YMASK='0 12 27' ,/XPROJ ,WKSP=20 $",$
";**                  ,MONIMOD=3 ,MONIVAL=100000 ,SELECTION='104>122 + 127'",$
" ",$
" ",$
";pro      READ_LAMP ,  filename ,W=i, path=pth",$
";***      *********",$
";**",$
";**       This procedure reads the file 'filename' into workspace number i.",$
";**                                File  filename  is a LAMP_Format file.",$
" ",$
" ",$
";pro      WRITE_LAMP , filename ,W=i [,FORMAT='Bin'] [,FORMAT='Ascii']",$
";***      **********",$
";**",$
";**       This procedure writes workspace number i to the file 'filename'",$
";**                                File   is written in a LAMP_Format.",$
" ",$
" "] & txti=[txti,$
";pro      SAVESESSION",$
";***      ***********",$
";**",$
";**       This procedure saves all variables & workspaces in 'lamp.ses'.",$
" ",$
" ",$
";pro      SHOW   , variable",$
";***      **** ",$
";**",$
";**       This procedure prints the contents of the variable. If variable is an",$
";**            array then only first ten elements are shown.",$
";**       the  call is   SHOW, y1 ",$
" ",$
" ",$
";pro      SETCOL , number",$
";***      ******",$
";**",$
";**       This procedure loads the color table number. This number is the index of the",$
";**            table listed when 'Load new Colors' button is pressed.",$
";**       This number is saved when you exit from LAMP.",$
";**       The  call is  SETCOL, 27",$
" ",$
" ",$
";pro      TRAP   , workspace",$
";***      ****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace.",$
";**       To zoom an image you can drag the left button of the mouse.",$
";**       The call is  TRAP,  W3",$
" ",$
" ",$
";pro      TRAPX  , workspace",$
";***      *****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace",$
";**            and does the sum on the  X axis  into  that workspace.",$
";**       The call is  TRAPX, W4",$
" ",$
" ",$
";pro      TRAPY  , workspace",$
";***      *****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace",$
";**            and does the sum on the  Y axis  into  that workspace.",$
";**       The call is  TRAPY, W5",$
" ",$
" ",$
" ",$
";pro      TRAPT  , workspace",$
";***      *****",$
";**",$
";**       This procedure loads the last plotted image into the named workspace",$
";**            and totalizes   all elements into  that workspace.",$
";**       The call is  TRAPT, W6",$
" ",$
" ",$
" "] & txti=[txti,$
";pro      XICUTE  , formula",$
";***      ******",$
";**",$
";**       This procedure executes the string 'formula' using the Lamp passing rule",$
";**            as if you typed    the formula in the Formulae Entry.",$
";**       The call is  XICUTE, formula",$
" ",$
" ",$
" ",$
";pro      SETMANIP  [,/raw] [,/noraw]",$
";***      ********",$
";**",$
";**       When Lamp calculates a single operation between two workspaces (w1=w2+w3),",$
";**           it tries to adjust the result as a function of the monitors (n2 & n3)",$
";**           and coordinates (x2 & x3) then adjusts the resulting errors (e1).",$
";**       To  prevent Lamp from this extra charge, the call is SETMANIP,/raw",$
";**           to  ask Lamp for  an   extra again , the call is SETMANIP",$
";**",$
";**       Regardless  of this  status,  if Lamp sees  ;++ at the end of a command,",$
";**           it goes in extra for that command only, ;-- is for the opposite expect.",$
" ",$
" ",$
";pro      TAKE_DATP , datp [,W=i] [,/third][,/fourth,/fifth,/sixth]",$
";***      *********",$
";**",$
";**       This procedure allows you to access the following data parameters:",$
";**       datp.X , datp.Y , datp.Z , datp.E , datp.N , datp.PV , datp.W_TIT ....",$
";**       If called from a macro specified  by W3=MACRO(w6,w7)  then:",$
";**                 returned datp is that of w6 by default",$
";**                 returned datp is that of w7 if third is set",$
";**                 returned datp is that of Wi if W is set.",$
";**",$
";**       You can   modify all parameters ex: datp.X_TIT='this is the X axis'",$
";**       You can't modify the size of an array parameter.",$
" ",$
";pro      GIVE_DATP , datp [,W=i] [,/second][,/third,/fourth,/fifth,/sixth]",$
";***      *********",$
";**",$
";**       This procedure allows you to give data parameters back to lamp.",$
";**       If called from a macro specified  by W3=MACRO(w6,w7)  then:",$
";**                      given datp is for w3 by default",$
";**                      given datp is for w6 if second is set",$
";**                      given datp is for w7 if third  is set",$
";**                      given datp is for wi if W  is set.",$
" ",$
";pro      MOD_DATP , datp , tag , value",$
";***      ********",$
";**",$
";**       This procedure allows you to change the size of a parameter.",$
";**       The call is MOD_DATP, datp , 'X' , alog(indgen(50)+1)",$
";**                   MOD_DATP, datp , 'E' , sqrt(w)",$
" ",$
" ",$
" "] & txti=[txti,$
";pro      TAKE_W , variable ,W=i",$
";***      ******",$
";**",$
";**       This procedure gets workspace number i into variable.",$
" ",$
" ",$
" ",$
";pro      GIVE_W , variable ,W=i",$
";***      ******",$
";**",$
";**       This procedure puts variable into workspace number i.",$
" ",$
" ",$
" ",$
";pro      W_STORE    , W=i [,/ALL]",$
";***      *******",$
";**",$
";**       This procedure duplicates workspace number i and its parameters into memory.",$
";**       The call is W_STORE, W=3           (use /ALL to duplicate all workspaces)",$
" ",$
" ",$
";pro      W_RESTORE  , W=i [,/ALL]",$
";***      *********",$
";**",$
";**       This procedure retrieves  workspace number i and its parameters from memory.",$
";**       The call is W_RESTORE, W=3         (use /ALL to retrieve  all workspaces)",$
" ",$
" ",$
";pro      W_EXCHANGE , W=i [,/ALL]",$
";***      **********",$
";**",$
";**       This procedure exchanges  workspace number i and its duplicate   in  memory.",$
";**       The call is W_EXCHANGE, W=3        (use /ALL to exchange  all workspaces)",$
" ",$
" ",$
";pro      MYINIT",$
";***      ******",$
";**",$
";**       This procedure executes your code after lamp is loaded.",$
";**       You may also put some code in the file 'myinit.prox'.",$
" ",$
";pro      MYHELP",$
";***      ******",$
";**",$
";**       This procedure associates your help-text to the upper left ? of lamp.",$
" ",$
" "] & txti=[txti,$
";pro      P_LAYOUT , flag (or a Help-macros-file) [,prox=proxfile]",$
";***      ********",$
";**",$
";**       This procedure should be used as commands in MYINIT procedure.",$
";**       flag='george' , 'lamp' , 'light' , 'full' , 'hide' , 'show' FOR LAMP LAYOUT",$
";**       flag='List_oldTOF' TO LOAD 'A_List_oldTOF.prox' FOR MACROS LAYOUT",$
";**       prox=['file1','file2'] TO LOAD 'file1.prox' & 'file2.prox' IN DO COMMAND GUI",$
" ",$
" ",$
" "]
end


pro dons
;** ****
return
end

PRO Build_MacFileListFromArray ,file_array ,macFile_List
;** **************************
;**
	
	; Entree :  ['toto', 'tata', 'titi']  			(IDL Array)
	; Sortie : "{file toto, file tata, file titi}	String
		
	macFile_List = ''
	FOR Index=0,n_elements(file_array)-1 DO BEGIN
	
		IF (INDEX EQ 0) THEN $
			macFile_List = 'file "' + file_array(Index) + '"' $
		ELSE $
			macFile_List = macFile_List + ', file "' + file_array(Index) + '"'

	END
	
	macFile_List = '{' + macFile_List + '}'

	return
	
END ; Build_MacFileListFromArray


PRO Build_MacFileListFromString ,file_list ,macFile_List
;** ***************************
;**
	
	; Entree : "toto tata titi"						String
	; Sortie : "{file toto, file tata, file titi}	String
		
	fileArray = str_sep(file_list, ' ')		; Found in IDL Lib
	
	Build_MacFileListFromArray, fileArray ,macFile_List
	return

END ; Build_MacFileListFromString

PRO Build_ToolServerFileListFromString, sourceFolder, file_list, toolServer_List
;** **********************************
;**
	
	; Entree : 'sourceFolder' 'toto tata titi'										String
	; Sortie : '\"sourceFolder:toto\" \"sourceFolder:tata\" \"sourceFolder:titi\"'	String
		
	fileArray = str_sep(file_list, ' ')		; Found in IDL Lib
	
	toolServer_List = ''
	FOR Index=0,n_elements(fileArray)-1 DO BEGIN
	
		toolServer_List = toolServer_List + '\"' + sourceFolder + fileArray(Index) + '\" '

	END
	
	return
	
END ; Build_ToolServerFileListFromString

PRO lamp_resource, txts
;** *************
;**
txts=[$
"*clientAutoPlace: off","",$

"Idl.visual:  PseudoColor",$
"Idl.retain:  2",$
"Idl.noBorder:True",$
"Idl.colors:  -18","",$

"Idl*Background:  		  paleturquoise",$
"Idl*Foreground:  		  black",$
"Idl*XmText*background:	  	  deepskyblue2",$
"Idl*XmList*background:	  	  deepskyblue3",$
"Idl*XmPushButton*background:	  paleturquoise2",$
"Idl*XmCascadeButton*background:   paleturquoise2",$
"Idl*XmToggleButton*selectColor:   deepskyblue4","",$

"Idl*Annotate*Background:     		paleturquoise",$
"Idl*IDL*Background:     		paleturquoise",$
"Idl*Xloadct*Background:     		paleturquoise","",$

"Idl*scan*Background:     		deepskyblue2",$
"Idl*scan*XmPushButton*background:   	paleturquoise2",$
"Idl*scan*XmPushButton*foreground:	deepskyblue4",$
"Idl*scan*XmCascadeButton*background:	paleturquoise2",$
"Idl*scan*XmCascadeButton*foreground:	deepskyblue4",$
"Idl*scan*XmToggleButton*selectColor:	paleturquoise2",""]
txts=[txts,$
"Idl*lamp*Background:     		paleturquoise",$
"Idl*lamp*XmLabel*foreground:	  	black",$
"Idl*lamp*spelab1*foreground:	  	grey",$
"Idl*lamp*spelab2*foreground:	  	deepskyblue1",$
"Idl*lamp*spelab3*foreground:	  	deepskyblue2",$
"Idl*lamp*spelab4*foreground:	  	deepskyblue3",$
"Idl*lamp*spelab5*foreground:	  	deepskyblue4",$
"Idl*lamp*spelab6*foreground:	  	paleturquoise1",$
"Idl*lamp*spelab7*foreground:	  	paleturquoise2",$
"Idl*lamp*spelab8*foreground:	  	paleturquoise3",$
"Idl*lamp*spelab9*foreground:	  	lightblue1",$
"Idl*lamp*discret*Background:		paleturquoise",$
"Idl*lamp*discret*Foreground:		black","",""]
txts=[txts,$
"Idl*lamp*mic*Background: deepskyblue1",$
"Idl*lampmic*Background:  deepskyblue1",$
"Idl*lamp*did*Background: deepskyblue2",$
"Idl*lampdid*Background:  deepskyblue2",$
"Idl*lamp*don*Background: deepskyblue3",$
"Idl*lampdon*Background:  deepskyblue3",$
"Idl*lamp*ben*Background: deepskyblue4",$
"Idl*lampben*Background:  deepskyblue4",""]
txts=[txts,$
"Idl*lamp*mic*geo*Background:			lightblue1",$
"Idl*lamp*mic*geo*XmPushButton*background:	lightblue1",$
"Idl*lamp*mic*geo*XmPushButton*foreground:	deepskyblue4",$
"Idl*lamp*mic*geo*XmLabel*foreground:		deepskyblue4",$
"Idl*lamp*mic*geo*XmText*background:		lightblue1",$
"Idl*lamp*mic*geo*XmText*foreground:		deepskyblue4",$
"Idl*lamp*geo*Background:			lightblue1",$
"Idl*lamp*geo*foreground:			deepskyblue4",$
"Idl*lamp*geo*XmPushButton*background:		lightblue1",$
"Idl*lamp*geo*XmPushButton*foreground:		deepskyblue4",$
"Idl*lamp*geo*XmCascadeButton*Background:	lightblue1",$
"Idl*lamp*geo*XmCascadeButton*foreground:	deepskyblue4",$
"Idl*lamp*did*geo*Background:			lightblue1",$
"Idl*lamp*did*geo*foreground:			deepskyblue4",$
"Idl*lamp*did*geo*XmText*background:		lightblue1",$
"Idl*lamp*did*geo*XmText*foreground:		deepskyblue4",$
"Idl*lamp*don*geo*Background:			lightblue1",$
"Idl*lamp*don*geo*foreground:			deepskyblue4",$
"Idl*lamp*don*geo*XmText*background:		lightblue1",$
"Idl*lamp*don*geo*XmText*foreground:		deepskyblue4",""]
txts=[txts,$
"Idl*lamp*mic*discret*background:	  deepskyblue1",$
"Idl*lamp*mic*discret*foreground:	  deepskyblue4",$
"Idl*lamp*mic*XmPushButton*background:	  paleturquoise1",$
"Idl*lamp*mic*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lamp*mic*XmLabel*foreground:	  deepskyblue4",$
"Idl*lamp*mic*XmToggleButton*selectColor:  paleturquoise1",$
"Idl*lampmic*XmPushButton*background:	  deepskyblue4",$
"Idl*lampmic*XmPushButton*foreground:	  grey",$
"Idl*lampmic*XmLabel*foreground:	  	  deepskyblue4",$
"Idl*lampmic*XmCascadeButton*background:	  deepskyblue2",$
"Idl*lampmic*XmCascadeButton*foreground:	  grey",$
"Idl*lampmic*XmToggleButton*selectColor:   paleturquoise1",$
"Idl*lampmic*XmText*background:	  	  deepskyblue3",$
"Idl*lampmic*XmText*foreground:	  	  grey",$
"Idl*lampmic*red*background:		  grey",$
"Idl*lampmic*red*foreground:		  black",""]
txts=[txts,$
"Idl*lamp*did*discret*background:	  deepskyblue2",$
"Idl*lamp*did*discret*foreground:	  deepskyblue4",$
"Idl*lamp*did*XmPushButton*background:	  paleturquoise2",$
"Idl*lamp*did*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lamp*did*XmToggleButton*selectColor:  paleturquoise2",$
"Idl*lampdid*XmPushButton*background:	  paleturquoise2",$
"Idl*lampdid*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lampdid*XmCascadeButton*background:	  paleturquoise2",$
"Idl*lampdid*XmCascadeButton*foreground:	  deepskyblue4",$
"Idl*lampdid*XmToggleButton*selectColor:   deepskyblue4",""]
txts=[txts,$
"Idl*lamp*don*gordon*Background: 		deepskyblue4",$
"Idl*lamp*don*gordon*XmPushButton*background:	paleturquoise3",$
"Idl*lamp*don*gordon*XmPushButton*foreground:	deepskyblue4",$
"Idl*lamp*don*XmPushButton*background:	  deepskyblue4",$
"Idl*lamp*don*XmPushButton*foreground:	  paleturquoise",$
"Idl*lamp*don*XmCascadeButton*background:  deepskyblue4",$
"Idl*lamp*don*XmCascadeButton*foreground:  paleturquoise",$
"Idl*lamp*don*XmToggleButton*selectColor:  deepskyblue4",$
"Idl*lampdon*discret*background:	          deepskyblue3",$
"Idl*lampdon*discret*foreground:	          paleturquoise",$
"Idl*lampdon*XmPushButton*background:	  deepskyblue4",$
"Idl*lampdon*XmPushButton*foreground:	  paleturquoise",$
"Idl*lampdon*XmCascadeButton*background:	  deepskyblue4",$
"Idl*lampdon*XmCascadeButton*foreground:	  paleturquoise",$
"Idl*lampdon*XmToggleButton*selectColor:   deepskyblue4",""]
txts=[txts,$
"Idl*lamp*ben*XmLabel*foreground:	  paleturquoise3",$
"Idl*lamp*ben*foreground:		  grey",$
"Idl*lamp*ben*discret*background:	  deepskyblue4",$
"Idl*lamp*ben*discret*foreground:	  paleturquoise3",$
"Idl*lamp*ben*XmPushButton*background:	  paleturquoise3",$
"Idl*lamp*ben*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lamp*ben*XmToggleButton*selectColor:  paleturquoise3",$
"Idl*lamp*ben*XmToggleButton*foreground:   paleturquoise3",$
"Idl*lampben*foreground:			  grey",$
"Idl*lampben*XmPushButton*background:	  paleturquoise3",$
"Idl*lampben*XmPushButton*foreground:	  deepskyblue4",$
"Idl*lampben*XmCascadeButton*background:	  paleturquoise3",$
"Idl*lampben*XmToggleButton*selectColor:   paleturquoise3",""]
txts=[txts,$
"Idl*lamptouch*Background:  		  paleturquoise",$
"Idl*lamptouch*Foreground:  		  black",$
"Idl*lamptouch*XmText*background:	  paleturquoise1",$
"Idl*lamptouch*XmList*background:	  deepskyblue3",$
"Idl*lamptouch*XmList*foreground:	  paleturquoise2",$
"Idl*lamptouch*XmPushButton*background:	  paleturquoise2",$
"Idl*lamptouch*XmCascadeButton*background: deepskyblue3",$
"Idl*lamptouch*XmCascadeButton*foreground: grey",$
"Idl*lamptouch*XmToggleButton*selectColor: paleturquoise3",$
"Idl*lamptouch*discret*background:	  paleturquoise1",$
"Idl*lamptouch*discret*foreground:	  deepskyblue4",""]
return
end


FUNCTION sys_dep, flag, p1,p2,p3,p4
;******* *******
;**
common c_def,c_init,Lamp_Dir,LF,viewer,ziper,giftrans

os =!VERSION.OS
;Vs=(BYTE(!version.release))(0) - (BYTE('0'))(0)
Vs =fix(strmid(string(!version.release),0,1))
res=0
if (!prompt eq 'I2M>') or (strpos(!path,'matlablib') ge 0) then matlab=1 else matlab=0
if (!prompt eq 'I2S>') or (strpos(!path,'scilablib') ge 0) then scilab=1 else scilab=0

IF n_elements(c_init) eq 0 THEN BEGIN c_init=1 & viewer='' & Lamp_Dir='' & ziper=''
	CASE os of
		'MacOS': begin  LF = STRING(13B) & end
		'Win32': begin  & end
		'vms':   begin  ad='sys$login:lamp.resource' & a=findfile(ad,count=cnt)
		                if cnt eq 0 then begin lamp_resource,txts  & u=0 & n=n_elements(txts)-1
		                   ON_ioerror,misrsv & openw,u,ad,/get_lun & for i=0,n do printf,u,txts(i)
		                   free_lun,u & spawn, 'copy/noconf '+ad+' sys$login:decw$xdefaults.dat' & misrsv:
		                endif
		         end
		ELSE:    begin  spawn, 'unalias rm ; unalias cp ; unalias mv'
		                ad=expand_path('~')+'/.lamp.resource' & a=findfile(ad,count=cnt)
		                if cnt eq 0 then begin lamp_resource,txts  & u=0 & n=n_elements(txts)-1
		                     ON_ioerror,misrsu  & openw,u,ad,/get_lun & for i=0,n do printf,u,txts(i)
		                     free_lun,u & cnt=1 & misrsu:
		                endif
		                if (cnt ge 1) and (!D.name ne 'Z') and (!D.name ne 'TEK') then begin
				     scd='/usr/bin/X11/xrdb'     & bid=findfile(scd,count=cnt)
				     ;if cnt lt 1 then begin
				     ;scd='/usr/X11R6/bin/xrdb'   & bid=findfile(scd,count=cnt) & endif
				     if cnt lt 1 then begin
				     scd='/usr/openwin/bin/xrdb' & bid=findfile(scd,count=cnt) & endif

				     if  cnt ge 1 then spawn,  scd + ' -merge '+ad
				endif
		         end
	ENDCASE
END	

CASE flag of

	   ;Add p1 to idl path
	   ;------------------
'ADDPATH': IF strpos(!path,p1) lt 0 then BEGIN CASE os of
      		'vms':   !path=p1+ ',' +!path
     		'MacOS': !path=p1+':,' +!path
      		'Win32': !path=p1+ ';' +!path
      		 ELSE:   !path=p1+ ':' +!path
	   ENDCASE
	   ENDIF

	   ;After Desktop is realized or Stop
	   ;---------------------------------
'AFTER' : BEGIN CASE os of
      		'Win32': if Vs eq 4 then DEVICE,main_window=0
      		 ELSE:
	   ENDCASE
	   END
'AFTES' : BEGIN CASE os of
      		'Win32': if Vs eq 4 then DEVICE,main_window=1
      		 ELSE:
	   ENDCASE
	   END

	   ;Remove all blanks from a string exept for Mac dossiers
	   ;------------------------------------------------------
'BLANKS' : BEGIN CASE os of
      		'MacOS' : res=strtrim    (p1,2) 
      		'Win32' : res=strtrim    (p1,2) 
      		'darwin': res=strtrim    (p1,2) 
      		 ELSE:    res=strcompress(p1,/remove_all)
	   ENDCASE
	   END

	   ;Call a browser
	   ;--------------
'BROWSE' : BEGIN CASE os of
      		'vms':   begin  spawn,'netscape '+p1,/NOWAIT
			         end
      		'Win32': begin  IF !version.release ge '5.4' THEN $
				spawn,/nowait,/hide,'"c:\Program Files\internet explorer\iexplore.exe" '+p1
      		         end
      		'MacOS': begin  spawn, MACCREATOR='MOSS',  p1
      		         end
      		'darwin':begin  spawn,'open '+p1
      		         end
      		 ELSE:   begin  spawn,'netscape -install '+p1 +'&'
			 end
	   ENDCASE
	   END

	   ;Copy files in string p1 (separ. by blancs) from directory p2 to current directory
	   ;----------------------- ------------------ ----------------- --------------------
'COPY':    BEGIN CASE os of
		'vms':   begin
			 tmp=byte(strcompress(strtrim(p1,2)))
			 idx=where(tmp eq 32)
			 if idx(0) gt 0 then tmp(idx)=byte(',')
			 tmp=string(tmp)
      		 	 cd,current=mee
      		 	 if n_elements(p3) gt 0 then mee=mee+p3
			 spawn ,'copy/noconf '+p2+tmp+' '+mee+'*'
			 end
      		'Win32': begin
      		 	 cd,current=mee
      		 	 if n_elements(p3) gt 0 then mei=mee+'\'+p3 else mei=mee
			 IF !version.release ge '5.2' THEN BEGIN
			   files=str_sep(p1,' ') & mei=mei+'\'
			   for ip1 = 0, n_elements (files)-1 do begin
			     if files(ip1) gt ' ' then begin
			        binin =    read_binary(p2 + files(ip1))
			        on_ioerror,free
			        openw   , u, mei+files(ip1), /get_lun
			        writeu  , u, binin
			        free:free_lun, u
			     endif
			   endfor
			 ENDIF ELSE BEGIN
      		 	   cd,p2
      		 	   command_line='cp '+p1+' '+mei
      		 	   spawn, command_line
      		 	   cd,mee
			 ENDELSE
      			 end
      		'MacOS': begin
      			; Get the current dir
      			cd, CURRENT=toFolder
      			; We need to use ToolServer because of the unix WildCard character (*)
				Print, "SD :Copy From " + p2 + " " + p1 + " to folder " + toFolder
				
				; NOTE : WildCard can be very very slow (2 to 5 minutes) on NFS volume mount by "MacNFS" : Don't use it !
				
				; Translate unix WildCard (*) to ToolServer WildCard ()
				t1=strcompress(strtrim(p1,2))
				WHILE (STRPOS(t1, '*') NE -1) DO $
					STRPUT, t1, '', Index
				
				Build_ToolServerFileListFromString, p2, t1, toolServerFileList
				toolServerScript = "directory  " + toFolder + " ; " + $
									"duplicate -y " + toolServerFileList + " : ; " + $
									"setfile -t 'ZIVU' -c 'Gzip' .Z"
									 
				script = [  'tell application "' + Lamp_Dir + 'Helpers:ToolServer:ToolServer"', $
							'      DoScript "' + toolServerScript + '"', $
							'end tell' ]
							
				DO_APPLE_SCRIPT, script
				; ToolServer ne renvoit pas de rsultat pour cette commande ?!?
				res = 1 
      		 	 end
      		 ELSE:   begin
      		 	 cd,current=mee
      		 	 if n_elements(p3) gt 0 then mee=mee+'/'+p3
      		 	 spawn, 'cd '+p2 + '; cp '   + p1 + ' '+mee
      		 	 end
	   ENDCASE
	   END

	   ;Delete file p1
	   ;--------------
'DELET':   BEGIN ON_IOERROR,mis_opd
                 CASE os of
		'vms':   begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
      		'MacOS': begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
      		'Win32': begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
      		'Other': spawn,'rm -f '   +p1
      		 ELSE:   begin OPENR ,out1,p1,/get_lun,/DELETE & FREE_LUN,out1 & end
	   ENDCASE
	   mis_opd:
	   END

	   ;Delete a file list p1
	   ;------------------ --
'DELIST':  BEGIN ON_IOERROR,mis_opdl
                 CASE os of
;		'vms':   begin
;			 ch=p1(0)+';*' & n=n_elements(p1)
;			 if n gt 1 then for i=1,n-1 do ch=ch+','+p1(i)+';*'
;			 spawn,'delete '+ch ,/NOWAIT
;			 end
      		'vms':	 for i=0,n_elements(p1)-1 do begin
      				 OPENR ,out1,p1(i)    ,/get_lun,/DELETE & FREE_LUN,out1 & endfor
      		'MacOS': for i=0,n_elements(p1)-1 do begin
      				 OPENR ,out1,p1(i)    ,/get_lun,/DELETE & FREE_LUN,out1 & endfor
      		'Win32': for i=0,n_elements(p1)-1 do begin
      				 OPENR ,out1,p1(i)    ,/get_lun,/DELETE & FREE_LUN,out1 & endfor
      		 ELSE:   spawn, ['rm' ,'-f' , p1] ,/noshell
	   ENDCASE
	   mis_opdl:
	   END

	   ;List current directory, return a file ascending list
	   ;----------------------  ----------------------------
'DIR':     BEGIN CASE os of
;		'vms':   spawn, 'dir ',p1 ,count=p2
		'vms':   p1=findfile(count=p2)
      		'Win32': begin
      			;CAG - due to the redirection problem in Win32 I am using IDL
      			 cd,current=mee
      			 p1=FINDFILE(mee+'\*',count=p2)
      			 end
       		'MacOS': begin
      			; NOTE : if we pass a non existent reference to the finder,
      			; we will end up in a "dialog with OK button" at the finder level
      			script = [  'tell application "Finder"',$
      						'   if  (exists folder "' + p1 + '") then',$
      						'      name of items in container "' + p1 + '"' + LF,$
      						'   else',$
      						'      set result to ""' + LF,$
      						'   end if' + LF,$
      				     	'end tell' ]
      			DO_APPLE_SCRIPT, script, RESULT=p1
      			res = p1
      			p2 = n_elements(p1)
      		 	end
       		 ELSE:   spawn, 'ls ' ,p1 ,count=p2
	   ENDCASE
	   END

	   ;List directories of current directory with modified date
	   ;---------------- -- ----------------- ---- -------- ----
'DIRD':    BEGIN CASE os of
		'vms':	 spawn,'dir/date' +p1+ '*.dir' ,res
      		'Win32': p3=0 ; CAG need to be implemented
       		'MacOS':
      		 ELSE:   spawn,'ls -ld '  +p1+ '*'    ,res
	   ENDCASE
	   END

	   ;Return the path divider
	   ;-----------------------
'DIVIDER': BEGIN CASE os of
		'vms':   res = ""
      		'Win32': res = "\"
      		'MacOS': res = ":"
      		 ELSE:   res = "/"
	   ENDCASE
	   END

	   ; For IDL versions 4.0.1 and newer, find all label widgets
	   ; rooted and the specified top level widget and set their
	   ; DYNAMIC_RESIZE property.
	   ;------------------------
'DYNLAB':  IF (Vs GE 4) THEN BEGIN

	   IF p2 gt 0 THEN IF !version.release ne '4.0' THEN $
	   CASE os of
      		'Win32':
		 ELSE:	 dynlabel_call, p1
	   ENDCASE
	   
	   CASE os of
		'MacOS': begin	if n_elements(p3) ne 1 then p3=-15
				resizeButton_call, p1, p3
			 end
		 ELSE:
	   ENDCASE
	   ENDIF

	   ;RPC modules entries (ILL use only)
	   ;-------------------
'ENTRY':   BEGIN CASE os of
		'vms':   res='r_mic'
		'sunos': res='r_micc_'    
      		'IRIX':  res='r_micc_'
      		'hp-ux': res='r_micc'
       		 ELSE:   res='r_micc'   
	   ENDCASE
	   END
	   
	   ;RPC modules (ILL use only)
	   ;-----------
'EXEC':    BEGIN CASE os of
		'sunos': res=p1+'/lamp_mac/r_mic_SUN.so'  
      		'IRIX':  res=p1+'/lamp_mac/r_mic_SGI.so'  
      		'hp-ux': res=p1+'/lamp_mac/r_mic_HP.so'  
      		 ELSE:   res=''  
	   ENDCASE
	   END

	   ;EXIT from Lamp application
	   ;--------------------------
'EXIT':    BEGIN CASE os of
		'MacOS': EXIT
		'Win32': EXIT
		 ELSE:	 EXIT
	   ENDCASE
	   END

	   ;Font for drawing area
	   ;---------------------
'FONTD':   BEGIN CASE os of
		'vms':   res='6x13bold'
		'MacOS': res='geneva*9'
		'darwin':res='-schumacher-clean-medium-r-normal--10-*-*-*-*-*-*-*'
		'Win32': res='arial*bold*12'
		 ELSE:	 res='-adobe-courier-medium-r-normal--12-120-*-*-*-*-*-*'
	   ENDCASE
	   END

	   ;Fonts for large(0) middle(1) and small(2) UIs
	   ;---------------------------------------------
'FONTS':   BEGIN
;	   Large UI
     	   propor0   = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   biggest0  = '-bitstream-charter-bold-r-normal--19-180-75-75-p-119-*-*' 
     	   bigger0   = '-bitstream-charter-medium-r-normal--17-120-100-100-p-95-*-*'
     	   b_bigger0 = '-bitstream-charter-bold-r-normal--17-120-*-*-*-*-*-*'
     	   normal0   = '-bitstream-charter-medium-r-normal--15-140-75-75-p-84-*-*'
     	   b_normal0 = '-bitstream-charter-bold-i-normal--15-140-75-75-p-93-*-*'
     	   smaller0  = '-bitstream-charter-medium-r-normal--12-120-75-75-p-67-*-*'
     	   smallest0 = '-bitstream-charter-medium-r-normal--10-100-75-75-p-56-*-*'

;	   Middle UI
     	   propor1   = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   biggest1  = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   bigger1   = '-adobe-courier-medium-r-normal--14-140-*-*-*-*-*-*'
     	   b_bigger1 = '-adobe-courier-bold-r-normal--14-140-*-*-*-*-*-*'
     	   normal1   = '-adobe-times-medium-i-normal--14-140-*-*-*-*-*-*'
     	   b_normal1 = '-adobe-times-bold-i-normal--14-140-*-*-*-*-*-*'
     	   smaller1  = '-adobe-times-medium-r-normal--12-120-*-*-*-*-*-*'
     	   smallest1 = '-adobe-times-medium-r-normal--10-100-*-*-*-*-*-*'

;	   Small UI
    	   propor2   = '-adobe-courier-bold-r-normal--10-100-*-*-*-*-*-*'
    	   biggest2  = propor2
    	   bigger2   = '-adobe-courier-medium-r-normal--10-100-*-*-*-*-*-*'
    	   b_bigger2 = propor2
    	   normal2   = bigger2
    	   b_normal2 = propor2
    	   smaller2  = propor2
    	   smallest2 = bigger2
    	   
    	   res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
    	        [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
    	        [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]

 	   CASE os of
		'vms':  begin res(*,0)=res(*,1)
			      res(1,0)='-adobe-times-bold-r-normal--18-180-*-*-*-*-*-*' & end
 		'sunos':begin res(*,0)=res(*,1)
			      res(1,0)='-adobe-times-bold-r-normal--18-180-*-*-*-*-*-*' & end
		'Win32':begin
     			propor0   = 'courier new*bold*14'
     	  		biggest0  = 'arial*bold*19'
     	   		bigger0   = 'arial *17'
     	   		b_bigger0 = 'arial*bold*17'
     	   		normal0   = 'arial *15'
     	   		b_normal0 = 'arial*bold*italic*15'
     	   		smaller0  = 'arial *12'
     	   		smallest0 = 'courier new*12'

                        biggest1  = 'arial*bold*15'
                        b_bigger1 = 'courier new*bold*16'
                        bigger1   = 'arial*bold*14'
                        propor1   = 'courier new*bold*14'
                        normal1   = 'arial*bold*11'
                        b_normal1 = 'arial*bold*14'
                        smaller1  = 'courier new*12'
                        smallest1 =  smaller1

                        biggest2  = 'courier new*bold*16'
                        b_bigger2 = 'courier new*bold*16'
                        bigger2   = 'arial*bold*14'
                        propor2   = 'arial*bold*14'
                        normal2   = 'arial*bold*11'
                        b_normal2 = 'arial*bold*14'
                        smaller2  = 'courier new*12'
                        smallest2 =  smaller2

    	   		res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
    	        	     [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
    	        	     [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]
      			end 
      		'MacOS':begin
                        biggest0  = 'geneva*bold*12'
                        b_bigger0 = 'geneva*bold*11'
                        bigger0   = 'geneva*11'
                        propor0   = 'monaco*10'
                        normal0   = 'geneva*10'
                        b_normal0 = 'geneva*bold*10'
                        smaller0  = 'geneva*9'
                        smallest0 = 'geneva*7'

                        biggest1  = 'geneva*bold*12'
                        b_bigger1 = 'geneva*bold*11'
                        bigger1   = 'geneva*11'
                        propor1   = 'monaco*9'
                        normal1   = 'geneva*10'
                        b_normal1 = 'geneva*bold*10'
                        smaller1  = 'geneva*8'
                        smallest1 = 'geneva*7'

                        biggest2  = 'geneva*bold*11'
                        b_bigger2 = 'geneva*bold*10'
                        bigger2   = 'geneva*10'
                        propor2   = 'monaco*9'
                        normal2   = 'monaco*9'
                        b_normal2 = 'geneva*10'
                        smaller2  = 'geneva*8'
                        smallest2 = 'geneva*7'

    	   		res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
    	        	     [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
    	        	     [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]
      			end 
               'darwin':begin ; Large UI
                        propor0   = '-schumacher-clean-bold-r-normal--14-140-75-75-c-80-iso646.1991-irv'
                        biggest0  = '-adobe-helvetica-bold-r-normal--18-180-75-75-p-103-iso8859-15' 
                        bigger0   = '-adobe-helvetica-medium-r-normal--18-180-75-75-p-98-iso8859-15'
                        b_bigger0 = '-adobe-helvetica-bold-r-normal--14-140-75-75-p-82-iso8859-14'
                        normal0   = '-adobe-helvetica-medium-r-normal--14-140-75-75-p-77-iso8859-14'
                        b_normal0 = '-adobe-helvetica-bold-o-normal--14-140-75-75-p-82-iso8859-14'
                        smaller0  = '-adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-13'
                        smallest0 = '-adobe-helvetica-medium-r-normal--10-100-75-75-p-56-iso8859-10'
                             ; Middle UI
                        propor1   = '-schumacher-clean-bold-r-normal--10-100-75-75-c-60-iso646.1991-irv'
                        biggest1  = '-adobe-helvetica-medium-r-normal--10-*-*-*-*-*-*-*'
                        bigger1   = '-adobe-helvetica-medium-r-normal--10-*-*-*-*-*-*-*'
                        b_bigger1 = '-adobe-helvetica-bold-r-normal--10-*-*-*-*-*-*-*'
                        normal1   = '-adobe-helvetica-medium-r-normal--9-*-*-*-*-*-*-*'
                        b_normal1 = '-adobe-helvetica-bold-r-normal--9-*-*-*-*-*-*-*'
                        smaller1  = '-adobe-helvetica-medium-r-normal--8-*-*-*-*-*-*-*'
                        smallest1 = '-adobe-helvetica-medium-r-normal--8-*-*-*-*-*-*-*'
                             ; Small UI
                        propor2   = '-schumacher-clean-bold-r-normal--10-100-75-75-c-60-iso646.1991-irv'
                        biggest2  = propor2
                        bigger2   = '-schumacher-clean-medium-r-normal--10-100-75-75-c-50-iso646.1991-irv'
                        b_bigger2 = propor2
                        normal2   = bigger2
                        b_normal2 = propor2
                        smaller2  = propor2
                        smallest2 = bigger2

                        res=[[propor0,biggest0,bigger0,b_bigger0,normal0,b_normal0,smaller0,smallest0],$
                             [propor1,biggest1,bigger1,b_bigger1,normal1,b_normal1,smaller1,smallest1],$
                             [propor2,biggest2,bigger2,b_bigger2,normal2,b_normal2,smaller2,smallest2]]
                        end 
       		 ELSE:
	   ENDCASE
	   if matlab then begin
    	   		res=[['ft_propor','ft_biggest','ft_bigger','ft_b_bigger','ft_normal','ft_b_normal','ft_smaller','ft_smallest'],$
    	        	     ['ft_propor','ft_biggest','ft_bigger','ft_b_bigger','ft_normal','ft_b_normal','ft_smaller','ft_smallest'],$
    	        	     ['ft_propor','ft_biggest','ft_bigger','ft_b_bigger','ft_normal','ft_b_normal','ft_smaller','ft_smallest']]
	   endif
	   END

	   ;Environment variable p1: 'LAMP_DIR','USER','HOST','DISPLAY'
	   ;----------------------------------------------------------
'GETENV':  BEGIN res=''
           CASE os of
		'MacOS': begin
		            if (p1 eq 'LAMP_DIR') then begin i = strpos (strlowcase(!path),"lamp_mac")
				      if i le 0       then       i =rstrpos (strlowcase(!path),"lamp")+5
					if i eq 4       then begin i =findfile('lamp*.sav',count=nn)
		                             if nn gt 0 then begin cd,current=res 
		                                        !path=res+':,'+res+':lamp_mac:,' +!path
					           endif else begin
		                                        i  = findfile(!Dir+   ':lamp*.sav',count=nn)
					                      if nn gt 0 then res = !Dir
					           endelse
			            endif else begin res=strmid (!path,0,i-1)
					                 i  =rstrpos( res ,",")
		                             if i ge 0 then  res=strmid ( res ,i+1,80)
					           i  = strpos   (strlowcase(!path),"lamp_mac")
					           if i lt 0 then !path=res+ ':,'+res+':lamp_mac:,' +!path
		                  endelse
					Lamp_Dir = res
		      	endif else if (p1 eq 'USER') then begin res=""
		      				
				;	script =['tell application "' + Lamp_Dir + 'Helpers:ToolServer:ToolServer"'+LF,$
				;		'DoScript "echo -n {user}"' + LF, $
				;		'end tell' ]
				;	DO_APPLE_SCRIPT, script, RESULT=res
      						
		      	endif else if p1 eq 'HOST' then res = "" $
		      	else  if p1 eq 'LAMP_EXEC' then res = "" $
		      	else  if p1 eq 'DISPLAY'   then res = ":0"
		      	end
		'Win32': if p1 eq 'LAMP_DIR' then begin i  = strpos  (strlowcase(!path),"lamp_mac")
		                  if i le 0  then       i  =rstrpos  (strlowcase(!path),"lamp")+5
				  if i eq 4  then begin i  = findfile('..\lamp*.sav',count=nn)
							CD,current=mee
		                             if nn gt 0 then cd,'..' $
		                             else       i  = findfile(   'lamp*.sav',count=nn)
		                             if nn gt 0 then begin cd,current=res 
		                                        !path=res+';'+res+'\lamp_mac;' +!path
					     endif else begin 
		                                        i  = findfile(!Dir+   '\lamp*.sav',count=nn)
					                if nn gt 0 then res = !Dir $
							else begin
					                        i  = findfile(!Dir+'\..\lamp*.sav',count=nn)
					                        if nn gt 0 then begin
					                         cd,!Dir+'\..'  &   cd,current=res & endif
					                endelse
					     endelse
					     CD,mee
		                  endif else begin      res= strmid (!path,0,i-1)
		                                        i  = rstrpos( res ,";")
		                             if i ge 0  then res=strmid ( res ,i+1,80)
					     i  = strpos   (strlowcase(!path),"lamp_mac")
					     if i lt 0 then !path=!path+';'+res+';'+res+'\lamp_mac'
				 endelse
				 Lamp_Dir = res
		         endif else res = getenv(p1)
      	ELSE:    res = getenv(p1)
	   ENDCASE
	   END

	   ;Make transparent gif
	   ;--------------------
'GIFTRANS':BEGIN CASE os of
		'vms':
      		'Win32':
      		'MacOS':
      		 ELSE: begin if n_elements(giftrans) eq 0 then begin
				spawn,'whereis giftrans',ret
      		 	 	cnt=strpos(ret,'/giftrans')
      		 	 	if cnt(0) lt 0 then giftrans=0 else giftrans=1
			     endif
			     if giftrans then $
				spawn,'giftrans -t 0 '+P1+' > '+P1+'t; mv '+P1+'t '+P1
		       end
	   ENDCASE
	   END


	   ;Used for cd,res for home directory
	   ;----------------------------------
'HOME':    BEGIN CASE os of
		'vms':   res='sys$login:'
      		'Win32': cd , current=res
      		'MacOS': cd , current=res
      		 ELSE:   res=expand_path('~')
	   ENDCASE
	   END


	   ;Add LAMP_DIR and LAMP_DIR/lamp_mac to idl path
	   ;-------------------------------------------------
'IDLPATH': IF strpos(!path,p1) lt 0 then BEGIN
 		CASE os of
		'vms':   expa=expand_path('+'+strmid(p1,0,p2-1)+'.lamp_mac]')
		'MacOS': expa=expand_path('+'+p1+':lamp_mac:')
		'Win32': expa=expand_path('+'+p1+'\lamp_mac' )
		 ELSE:   expa=expand_path('+'+p1+'/lamp_mac' )
		ENDCASE
		CASE os of
		'vms':   !path=!path+','     +p1+',' +strmid(p1,0,p2-1)+'.lamp_mac]'+',sys$login:'+','+expa
		'MacOS':;!path=!path+','     +p1+':,'+p1+':lamp_mac:'     +','+expa
		'Win32':;!path=!path+';'     +p1+';' +p1+'\lamp_mac'      +';'+expa
		 ELSE:   !path=!path+':'     +p1+':' +p1+'/lamp_mac' +':~'+':'+expa
		ENDCASE
          ENDIF

	   ;Insert a sub_dir p2 in path p1
	   ;------------------------------
'INSUB':   BEGIN CASE os of
		'vms':   res =strmid(p1,0,strlen(p1)-1)+ '.' +p2 +']'
      		'Win32': res =       p1       +p2 +'\' 
      		'MacOS': res =       p1       +p2 +':' 
      		 ELSE:   res =       p1       +p2 +'/' 
	   ENDCASE
	   END
	   
	   ;Get graphic function number for GXinvert
	   ;----------------------------------------
'INVERT':  BEGIN CASE os of
		'vms':   res=10
      		'Win32': res=10
      		'MacOS': res= 6
      		 ELSE:   res=10
	   ENDCASE
	   END

	   ;Return machine type
	   ;-------------------
'MACHINE': BEGIN CASE os of
		'vms':   res='vms'
      		'Win32': res='win'
      		'MacOS': res='mac'
      		 ELSE:   res='unix'
	   ENDCASE
	   END

	   ;Show manual with a browser
	   ;--------------------------
'MANUAL' : BEGIN CASE os of
      		'vms':   begin  res='netscape [lamp.manual]front.htm'
					cdd=strmid(p1,0,strlen(p1)-1)+'.manual]'
					id=findfile(cdd+'front.htm',count=cnt)
					if (cnt eq 0) and (n_elements(p2) eq 1) then  begin
			                cdd=strmid(p2,0,strlen(p1)-1)+'.manual]'
			                id =findfile(cdd+'front.htm',count=cnt) & endif
		   			if  cnt gt 0 then begin res='netscape '+cdd+'front.htm'
					    spawn,res,/NOWAIT
					endif else res='http://www.ill.fr/data_treat/lamp/front.html'
			         end
      		'Win32': begin  res=p1+'\manual\front.htm'
					cdd=p1+'\manual\'
			    		id=findfile(cdd+'front.htm',count=cnt)
					if (cnt eq 0) and (n_elements(p2) eq 1) then  begin
			                cdd=p2+'\manual\'
			                id =findfile(cdd+'front.htm',count=cnt) & endif
		   	    		if  cnt gt 0 then begin res=cdd+'front.htm'
					endif else res='http://www.ill.fr/data_treat/lamp/front.html'
					IF !version.release ge '5.4' THEN $
					spawn,/nowait,'"c:\Program Files\internet explorer\iexplore.exe" '+res
      		         end
      		'MacOS': begin
      			    	res='MOSS'	; signature de l'application "NetScape"
      			    	cdd = p1+':manual:'
			    		id=findfile(cdd+'front.htm',count=cnt)
					if (cnt eq 0) and (n_elements(p2) eq 1) then  begin
			                cdd=p2+':manual:'
			                id =findfile(cdd+'front.htm',count=cnt) & endif
		   	    		if  cnt gt 0 then begin res=cdd+'front.htm'
					    spawn, MACCREATOR='MOSS', res
					endif else res='http://www.ill.fr/data_treat/lamp/front.html'
      		         end
      		 ELSE:   begin	res='http://www.ill.fr/data_treat/lamp/front.htm'
      				ic ='netscape'
      				spawn,'whereis netscape',ret
      				cnt=strpos(ret,'/netscape')
      				if cnt(0) lt 0 then begin
      		 		   spawn,'whereis mosaic',ret
      				   cnt=strpos(ret,'/mosaic')
      				   if cnt(0) ge 0 then ic ='mosaic' & endif
      				if cnt(0) lt 0 then begin
      		 		   spawn,'whereis mozilla',ret
      				   cnt=strpos(ret,'/mozilla')
      				   if cnt(0) ge 0 then ic ='mozilla'
      				   cnt=[0] & endif
				if os eq 'darwin' then ic ='open'
				if cnt(0) ge 0 then begin
				   if strpos(ic,'netscape') ge 0 then ic=ic+' -install'
		   		   cdd   =p1+'/manual/'
				   id=findfile(cdd+'front.htm',count=cnt)
				   if (cnt eq 0) and (n_elements(p2) eq 1) then begin
			               cdd=p2+'/manual/'
			               id =findfile(cdd+'front.htm',count=cnt) & endif
				   if cnt gt 0 then res=cdd+'front.htm'
				   spawn ,ic + ' ' + res + ' &'
				endif
			 end
	   ENDCASE
	   END

	   ;MAP or not MAP (some devices have problems to add widgets after realizing-> res=1)
	   ;--------------
'MAP':	   BEGIN CASE os of
      		'MacOS': res=1
      		'Win32': IF !version.release lt '5.1' THEN res=1
      		 ELSE:   res=0
	   ENDCASE
	   IF !version.release lt '3.6' THEN res=-1
	   IF res eq 0 THEN $
	      IF (Vs GE 4) THEN $
	   	   IF !version.release ne '4.0' THEN res=2
	   END

	   ;Create a directory
	   ;------------------
'MKDIR':   BEGIN CASE os of
			'vms':   spawn,'create/dir ' +p1
      		'MacOS': begin
      			; D'abord, verifier si c'est possible
      			ii=findfile(p1,count=cnt)
				
				; Si le dossier existe deja, on sort
      			if (cnt gt 0) then return, res
      			      			
      			FileStart = RSTRPOS(p1, ':')+1
      			container = STRMID(p1,0,FileStart)
      			folderName = STRMID(p1, FileStart, 1000)
			 	
      			script = [  'tell application "Finder"', $
      						'	if not (exists folder "' + p1 + '") then', $
      						'    	make new folder at container "' + container + '" with properties {name:"' + folderName + '"}' + LF, $
      						'	end if' + LF, $
      				     	'end tell' ]
      			DO_APPLE_SCRIPT, script
      			res=1
      		 	end
      		'Win32': begin
      			 command_line='mkdir '+p1
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 res=execute('spawn, command_line'+key)
      			 end
      		 ELSE:   spawn,'mkdir '       +p1
	   ENDCASE
	   END

	   ;Return /home/sub_dir
	   ;--------------------
'NEWDIR':  BEGIN CASE os of
		'vms':   res = '[' +p1+ '.'  +p2 +']'
      		'Win32': begin cd,current=mee
		         res = mee +    '\'  +p2 & end
      		'MacOS': res =      p1+ ':'  +p2
      		 ELSE:   res = '~' +p1+ '/'  +p2
	   ENDCASE
	   END

	   ;Return  path/sub_dir/
	   ;---------------------
'NEWSUB':  BEGIN CASE os of
		'vms':   res =strmid(p1,0,strlen(p1)-1)+ '.' +p2 +']'
      		'Win32': res =       p1+ '\'  +p2 +'\' 
      		'MacOS': res =       p1+ ':'  +p2 +':' 
      		 ELSE:   res =       p1+ '/'  +p2 +'/' 
	   ENDCASE
	   END

	   ;Start player p1 file_path is p2/p3
	   ;----------------------------------
'PLAY_ON': BEGIN CASE os of
		'vms':   begin p4=0
			 spawn, 'playaifc '+p2+p3,/NOWAIT
			 end
      		'Win32': p4=0 ;CAG I haven't got a sound card
      		'MacOS': begin
      			 script = [  'tell application "' + Lamp_Dir + 'Helpers:SoundMachine 2.1"', $
      						'    open file "' + p2 + ':' + p3 + '"' + LF, $
      				     	'end tell' ]
      			 DO_APPLE_SCRIPT, script
				p4=0
      			 res=1
      		 	 end
      		 ELSE:   spawn, p1+p2+'/'+p3+' &' ,PID=p4
	   ENDCASE
	   END

	   ;Kill player
	   ;-----------
'PLAY_OF': BEGIN CASE os of
		'vms':   
      		'Win32': 
      		'MacOS': begin
      			script = [  'tell application "' + Lamp_Dir + 'Helpers:SoundMachine 2.1"', $
      						'    quit', $
      				     	'end tell' ]
      			DO_APPLE_SCRIPT, script
      			res=1
      		 	end
      		 ELSE:   spawn, ['kill' , string(p4)] ,/noshell   
	   ENDCASE
	   END

	   ;return "path_for_player"
	   ;------------------------
'PLAYER':  BEGIN CASE os of
		'vms':   res=getenv('playaifc')
      		'Win32': res=''
      		'MacOS': res='' ;res='SoundMachine 2.1'
		'IRIX':  begin   res=''
				 spawn,'whereis playaifc',str
				 if strpos(str(0),'/playaifc') gt 0 then res='playaifc -rq '
			 end
      		 ELSE:   res=getenv('playaifc')
	   ENDCASE
	   END
	   

	   ;File extension fs problems (vms)
	   ;--------------------------
'POT':     BEGIN CASE os of
		'vms':   p1=p1+'.'
		 ELSE:
	   ENDCASE
	   END
'POT+':    BEGIN CASE os of
		'vms':begin
				j = STRPOS(p1, '.;')
		       	        if j gt 0 then   p1=STRMID(p1,0,j)+p2+'.' $
			        else     begin
					 if p3 eq 1 then begin
					    j =STRPOS(p1, ';')
				            if j gt 0 then p1=STRMID(p1,0,j)+p2 else p1=p1+p2
				         endif else begin
					    j =STRPOS(p1, '.')
				            if j gt 0 then p1=STRMID(p1,0,j+1)+p2
				         endelse
			        endelse
		      end
		 ELSE:p1=p1+p2
	   ENDCASE
	   END
	   
	   
	   ;Print a PS file p2 to a specified printer_name p1
	   ;-------------------------------------------------
'PRINT':   BEGIN CASE os of
		'vms':   spawn,'print/notify/queue='+p1+' '+p2
      		'Win32':begin kp=!D.name & set_plot,"WIN"
			      DEVICE,print_file=p2 & set_plot,kp & end
      		'MacOS':begin
      			;;Do you really want to choose a printer ???
      			;script = [  'tell application "Finder"',$
      			;	    'print file "' + p2 + '"'  ,$
      			;	    'end tell' ]
      			;DO_APPLE_SCRIPT, script, RESULT=res
			;HANSEN!!
      			lf=STRING(13B)
      			CD,CURRENT=current_directory
			if strpos(p2,':') lt 0 then p3=current_directory+p2 else p3=p2
      			PRINT,'print ',p3,' on ', p1
      			script=['tell application "Finder"'+lf+'copy file "'+p3+'" to item "'+p1+'"'+lf+'end tell']
      			PRINT,script
      			DO_APPLE_SCRIPT, script;, RESULT=res
      		 	end
		'linux':begin
			print,'lpr -P'+p1+' '+p2
			spawn,'lpr -P'+p1+' '+p2
			end
      		 ELSE:  begin
			 if strpos(p2,'_s.') gt 0 then print,'lp -c -d'+p1+' '+p2 $
						  else print,'lp -d'   +p1+' '+p2
			 if strpos(p2,'_s.') gt 0 then spawn,'lp -c -d'+p1+' '+p2 $
						  else spawn,'lp -d'   +p1+' '+p2
			end
	   ENDCASE
	   END
	   
	   ;Print a file p1 to the default printer
	   ;--------------------------------------
'PRT_DEF': BEGIN CASE os of
		'vms':   spawn,'print '+p1
      		'Win32':begin kp=!D.name & set_plot,"WIN"
			      DEVICE,print_file=p1 & set_plot,kp & end
      		'MacOS':begin
      			;script = [  'tell application "Finder"', $
      			;	    'print file "' + p1 +'"'   , $
      			;	    'end tell' ]
      			;DO_APPLE_SCRIPT, script, RESULT=res
			;HANSEN!!
      			lf=STRING(13B)
      			CD,CURRENT=current_directory
			if strpos(p1,':') lt 0 then p3=current_directory+p1 else p3=p1
      			PRINT,'print ', p3
      			script = ['tell application "Finder"'+lf+'print file "'+p3+'"'+lf+'end tell']
      			PRINT,script
      			DO_APPLE_SCRIPT, script, RESULT=res
      		 	end
		'linux':spawn,'lpr '  +p1
      		 ELSE:  spawn,'lp '   +p1
	   ENDCASE
	   END

	   ;Color: type of visual
	   ;---------------------
'PSEUDO':  BEGIN CASE os of
      		'Win32': 
      		'linux':;if (!D.name ne 'Z') and (!D.name ne 'TEK') then device, pseudo_color = 8
      		 ELSE:	 if (!D.name ne 'Z') and (!D.name ne 'TEK') then device, pseudo_color = 8
	   ENDCASE
	   if (!D.name ne 'Z') and (!D.name ne 'TEK') then device, decomposed   = 0
	   END

	   ;Byte Order compatibility
	   ;------------------------
'SWAPER':  BEGIN CASE os of
		'vms':   if (p1 eq 'uni') or (p1 eq 'mac') then res=1
      		'Win32': if (p1 eq 'uni') or (p1 eq 'mac') then res=1
		'linux': if (p1 eq 'uni') or (p1 eq 'mac') then res=1
      		'MacOS': if (p1 eq 'vms') or (p1 eq 'win') or (p1 eq 'lin') then res=1
      		 ELSE:   if (p1 eq 'vms') or (p1 eq 'win') or (p1 eq 'lin') then res=1
	   ENDCASE
	   END

	   ;Zip file p1
	   ;-------- --
'ZIP':    BEGIN CASE os of
		'vms':   res=0
      		'Win32': begin
      			 command_line='gzip -fq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 res=execute('spawn, command_line'+key)
      			 end
      		'MacOS': res=0
      		 ELSE:   begin	if ziper eq ''  then begin
				   spawn,'whereis zip',str
				   if strpos(str(0),'/zip') gt 0 then ziper='zip' else ziper='-'
				endif
				res=1
				if ziper ne '-' then begin
				   fzip=strmid(p1,0,strpos(p1,'.'))
				   if p2 ne '' then spawn, 'cd '+p2+' ; zip -mq ' +fzip+' ' +p1 
				   if p2 eq '' then spawn,             'zip -mq ' +fzip+' ' +p1 
				endif else res=0
			 end
	   ENDCASE
	   END

	   ;UnZip file p1
	   ;---------- --
'UNZIP':  BEGIN CASE os of
		'vms':   res=0
      		'Win32': begin	if ziper eq ''  then begin
				bid= findfile(!Dir+'\gzip.exe',count=nn)
				if nn gt 0 then ziper=!Dir+'\gzip' else ziper='gzip'
				endif
      			 command_line=ziper+' -dfq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 res=execute('spawn, command_line'+key)
      			 end
      		'MacOS': res=0
      		 ELSE:   begin	if ziper eq ''  then begin
				   spawn,'whereis unzip',str
				   if strpos(str(0),'/unzip') gt 0 then ziper='zip' else ziper='-'
				endif
				res=1
				if ziper ne '-' then spawn, 'cd '+p2+' ; unzip -qqux ' +p1 else res=0
			 end
	   ENDCASE
	   END

	   ;Compress file p1
	   ;-------- ---- --
'DO_Z':    BEGIN CASE os of
		'vms':   begin
			 spawn, 'compress -f '+p1
			 spawn, 'rename '+p1+'_Z '+p1+'Z' ,/NOWAIT
			 end
      		'Win32': begin
      			 command_line='gzip -fq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 ii=execute('spawn, command_line'+key)
      			 end
      		'MacOS': 
      		 ELSE:   spawn, 'compress -f '   +p1
	   ENDCASE
	   END

	   ;UnCompress file p1
	   ;---------- -------
'UN_Z':    BEGIN CASE os of
		'vms':   spawn, 'gunzip -dfq '+p1  
      		'Win32': begin	if ziper eq ''  then begin
				bid= findfile(!Dir+'\gzip.exe',count=nn)
				if nn gt 0 then ziper=!Dir+'\gzip' else ziper='gzip'
				endif
      			 command_line=ziper+' -dfq "'+p1+'"' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 ii=execute('spawn, command_line'+key)
      			 end
      		'MacOS':begin
      			; 'LZIV' = signature de l'application "MacCompress3.2"
      			; spawn, MACCREATOR='LZIV', p1
      			
      			script = [  'tell application "' + Lamp_Dir + 'Helpers:MacGzipPPC"',$
							'    open file "' + p1 + '"',$
							'end tell' ]
							
				DO_APPLE_SCRIPT, script
				
				; MacGzip works in the background
				; so we need to wait for the uncompressed files
				uncompressedFile = STRMID(p1, 0, STRLEN(p1)-2) ; Strip ".Z" suffixe
				dummy = FindFile(uncompressedFile, Count=AreYouThere)
				WHILE (AreYouThere EQ 0) DO BEGIN
					Print, "Waiting..."
					Wait, 0.5
					dummy = FindFile(uncompressedFile, Count=AreYouThere)
				ENDWHILE				
				
				res=1

      		 	 end
      		 ELSE:   spawn, 'uncompress -f ' +p1
	   ENDCASE
	   END

	   ;UnCompress file list p1
	   ;---------- ------------
'UN_ZLIS': BEGIN CASE os of
		'vms':   BEGIN
			 ch=p1(0) & n=n_elements(p1)-1
			 if n gt 0 then for i=1,n do ch=ch+' '+p1(i)
			 spawn, 'gunzip -dfq '+ch
			 END
      		'Win32': begin	if ziper eq ''  then begin
				bid= findfile(!Dir+'\gzip.exe',count=nn)
				if nn gt 0 then ziper=!Dir+'\gzip' else ziper='gzip'
				endif
      			 command_line=ziper+' -dfq' ;relies on gzip.exe being in the path
			 if !version.release ge '5.4' then key=',/hide' else key=''
      			 for i=0,n_elements(p1)-1 do begin com_line=command_line+' "'+p1(i)+'"'
      			                          ii=execute('spawn, com_line'+key) & endfor
      			 end
      		'MacOS':begin
      			; Get the current dir
      			cd, CURRENT=homeFolder
				
				; Add path 
				fileArray = homeFolder + p1

				lastFile = fileArray(n_elements(fileArray)-1)
				
      			; Prepare the file list in AppleScript format
      			Build_MacFileListFromArray, fileArray ,macFileList
      			
      			; Print, "SD :UN_ZLIS :" + macFileList

      			script = [  'tell application "' + Lamp_Dir + 'Helpers:MacGzipPPC"',$
							'    open ' + macFileList + LF,$
							'end tell' ]
				
				; Print, "Quitting IDL..."
				
				DO_APPLE_SCRIPT, script
				
				; Print, "Returning..."
		
				; MacGzip works in the background
				; so we need to wait for the last uncompressed file
				lastFile = STRMID(lastFile, 0, STRLEN(lastFile)-2) ; Strip ".Z" suffixe
				dummy = FindFile(lastFile, Count=AreYouThere)
				WHILE (AreYouThere EQ 0) DO BEGIN
					Print, "Waiting..."
					Wait, 0.5
					dummy = FindFile(lastFile, Count=AreYouThere)
				ENDWHILE
				
				; Print, "OK"
				res=1

      		 	 end
      		 ELSE:   spawn,['uncompress','-f',p1],/noshell
	   ENDCASE
	   END

'DEMO':     if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/DEMO)<1')     else res=0
'STUDENT':  if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/STUDENT)<1')  else res=0
'RUNTIME':  if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/RUNTIME)<1')  else res=0
'EMBEDDED': if  float(!version.release) ge 5.1 then ii=execute('res=LMGR(/EMBEDDED)<1') else res=0
'VM':       if  float(!version.release) ge 6.0 then ii=execute('res=LMGR(/VM)<1')       else res=0
'VERSION':  res=float(!version.release)
'MATLAB':   res=matlab
'SCILAB':   res=scilab

	   ;Start a VIEWER (vrml file is lamp.wrl)
	   ;--------------------------------------
'VIEWER':  BEGIN CASE os of
		'vms':  begin if viewer eq ''  then begin
				 viewer=getenv('VrmlViewer')
				 if viewer eq '' then begin viewer='-'
				    print,string(7b)+'(no logical VrmlViewer) !!!' & endif
			      endif
			      res=1
			      if viewer ne '-' then begin
				 if n_elements(p1) eq 1 then spawn,'VrmlViewer '+p1,/NOWAIT
			      endif
			end
      		'Win32':res=1
      		'MacOS':res=1
      		 ELSE:  begin if viewer eq ''  then begin
				 spawn,'whereis webspace',str
				 if strpos(str(0),'/webspace') gt 0 then viewer='webspace -remote ' $
				 else begin spawn,'whereis modelviewer',str
				 if strpos(str(0),'/modelvie') gt 0 then viewer='modelviewer -remote ' $
				 else begin spawn,'whereis vrweb',str
				 if strpos(str(0),'/vrweb')    gt 0 then viewer='vrweb  -remote ' $
				 else begin spawn,'whereis ivview',str
				 if strpos(str(0),'/ivview')   gt 0 then viewer='ivview  '
				 endelse & endelse & endelse
				 if viewer eq '' then viewer=getenv('VrmlViewer')
				 if viewer eq '' then begin viewer='-'
				    print,string(7b)+'(webspace,modelviewer,vrweb,ivview,$VrmlViewer) not found !!!' & endif
			      endif
			      res=1
			      if viewer ne '-' then begin
				 if n_elements(p1) eq 1 then spawn,viewer+' '+p1+' &'
			      endif
			end
	   ENDCASE
	   END

ELSE:
ENDCASE

RETURN,res
END ; sys_dep
pro dumpx,wk_in,o_file
;
; Dumps an INX file - parameters may be a bit odd
@lamp.cbk
wkstr=strtrim(string(alone),2)
pi=3.1416
w_buf=0
x_buf=0
y_buf=0
pmt_buf=0
;
; Prepare zones
   nzone=intarr(7)
   nzone(1)=1
   nzone(2)=2
   nzone(3:6)=0
;
; Prepare w_buffer
   jjj0=execute('w_buf=w'+wkstr)
      my_check=size(w_buf)

;
; What dimensions for the data?
      case my_check(0) of
         0: return
         1: begin
               nchans=my_check(1)
               nspecs=1
            end
         2: begin
               nchans=my_check(1)
               nspecs=my_check(2)
            end
	 else: return
      endcase
;
; Prepare other buffers
   jjj1=execute('x_buf=x'+wkstr)
   jjj2=execute('y_buf=y'+wkstr)
   jjj3=execute('pmt_buf=p'+wkstr)
   jjj4=execute('e_buf=e'+wkstr)
   
   if n_elements(w_buf) ne n_elements(e_buf) then e_buf=w_buf*0.
   if (size(y_buf))(0) eq 2 then y_buf=reform(y_buf(0,*))
   sx=(size(x_buf))(0)
   
; Get the parameters
      temp	=pmt_buf(11) 
      einc	=81.799/pmt_buf(21)/pmt_buf(21) 
      qinc	=2*pi/pmt_buf(21) 
      amass	=1.0
      nlines	=nchans+3
      deltatau	=pmt_buf(18)
      deltaen	=0.0
      deltak	=0.0
      isym	=0
      dumme	=0.0
      on_ioerror,pb_wrt  
      get_lun,ifile
      openw,ifile,o_file
				frmv='(5x,f10.5,e13.5,e12.4)'
       if max(y_buf) ge 10 then frmt='(x,f6.2,f8.3,f8.4,f9.3,f6.1,i2)' $
			   else frmt='(x,f6.4,f8.3,f8.4,f9.3,f6.1,i2)'
       for i=0,nspecs-1 do begin
         printf ,ifile,nlines,nzone(1:6),nchans          ,format='(8i5)'
	 printf ,ifile,w_tit(alone)
	 printf ,ifile,y_buf(i),einc,qinc,temp,amass,isym,format=frmt
	 printf ,ifile,deltaen,deltatau,deltak           ,format='(16x,3f8.4)'
	 if sx eq 1 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j)  ,w_buf(j,i),e_buf(j,i)  ,format=frmv

	 if sx eq 2 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j,i),w_buf(j,i),e_buf(j,i)   ,format=frmv

       endfor
       pb_wrt:free_lun,ifile
    return
    end	    
      
pro groupy, w,y,e ,AVERAGE=average
;** ******
;**
;** To group spectra (w) having the same ordinate (y)
;** Spectra are added.

d=100 ;means check only 2 decimals

;** Check concistencies
    sw=SIZE(w)
    sy=SIZE(y)
    IF sw(0) eq 2 THEN IF sw(2) eq sy(1) THEN BEGIN

	IF n_elements(e) eq n_elements(w) THEN r=1 else r=0
	IF r THEN E=E^2
	flg =lonarr(sy(1))+1
	wout=w*0 & wout(*,0)=w(*,0)
	yout=y*0 & yout  (0)=y  (0)
	j   =  0

	FOR i=1,sy(1)-1 DO BEGIN

	    IF  round(y(i)*d) eq round(yout(j)*d) THEN BEGIN
		wout(*,j)= wout(*,j)+w(*,i)
		IF r THEN  E   (*,j)=E(*,j)+w(*,i)
		flg(j)=flg(j)+1

	    ENDIF ELSE BEGIN
		j=j+1
		wout(*,j)=w(*,i)
		yout(  j)=y(  i)
		IF r THEN E(*,j)=E(*,i)
	    ENDELSE
	ENDFOR

	IF r THEN E=SQRT(E)

	IF keyword_set(average) THEN FOR i=0,j DO BEGIN
					wout(*,i)=wout(*,i)/flg(i)
					IF r THEN E   (*,i)=E(*,i)/flg(i)
				     ENDFOR
	w=wout(*,0:j)
	y=yout(  0:j)
	IF r THEN E=E(*,0:j)

    ENDIF
RETURN
END
;procedures in comment for pv-wave:
;*********************************
;RDID_D7
;RDID_D20
;RDID_D17
;GROUPY
;SET_TOLERANCE
;CATCH       now is dummy
;EXPAND_PATH now is dummy
;P_LAMBDA p_did_calib p_did_calev p_did_calod p_did_caldo (dummy for calibration)
;READS as been redefined
;SYS_DEP as been redefined
;## is changed by #
;structure {...} now is {,...} for DATP

FUNCTION P_LAMBDA, dummy
;******* ********
;**
@lamp.cbk

if n_elements(lamp_macro) ne 1 then return,''
rst=lamp_macro
idx=strpos(lamp_macro,'macros')
if  idx gt 0 then begin rst= strmid(lamp_macro,0,idx-1) +lamp_dvd
			if   lamp_dvd eq "" then rst=rst+"]"
             endif else if   lamp_dvd ne "" then rst=rst+lamp_dvd

if rst gt ' ' then if strmid(rst,strlen(rst)-1,1) ne lamp_dvd then rst=rst+lamp_dvd
bid=findfile    (rst+'*',count=n)
if n eq 0 then rst=''
return, rst
end


pro p_did_calib, inst, lamp_b1
;** ***********
;**
common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 , inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
common calibrotion         , cal_in4 , idx_in4 , shf_in4 , inf_in4 , zon_d2b

common calib	  , base0,lirlist,listcal,comment,curfil,bacur,nwork,swork,filen,lodfil,minst,ytext
common c_lamp_font

if (!D.flags and 65536) eq 0 then RETURN
IF xregistered('CALIB') gt 0 then widget_control,bad_id=ii,base0,map=1 $
ELSE BEGIN

CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN & endif
      MINST   = strlowcase(inst)
	PATHCAL = sys_dep('INSUB',P_LAMBDA(0),'CALIBRATION')
		    bid=findfile(pathcal+'*',count=nn) & if nn eq 0 then pathcal=''
      CD,PATHCAL,current=mee & lirlist = findfile('*'+MINST+'*') & CD,mee
      IF n_elements(CURFIL) eq 0 THEN CURFIL  =  MINST+'.cal'
      IF n_elements(SWORK)  eq 0 THEN swork   =' 0 '
      LODFIL=CURFIL

base0	=  widget_base  (title = 'CALIBRATION',resource_name='lamptouch',/column)
base0a	=  widget_base  (base0  ,/row   ,frame=4)
base0a1 =  widget_base  (base0a ,/column)
bid	=  widget_label (base0a1,value = PATHCAL,font=ft_b_bigger)
listcal	=  widget_list  (base0a1,value = lirlist,ysize = 7	,uvalue = [-88,394,1])

base0a1 =  widget_base  (base0a ,/column)
bid     =  widget_label (base0a1,value = 'for '+inst ,font=ft_b_bigger)
	   put_logo	,widget_base(base0a1,/row)
bid	=  widget_button(base0a1,value = 'Load selected file'	,uvalue = [-88,394,2])
bid	=  widget_button(base0a1,value = 'NO Calibration'	,uvalue = [-88,394,3])
bid	=  widget_button(base0a1,value = 'EXIT'			,uvalue = [-88,399  ])

base03	=  widget_base  (base0  ,/row)
bid	=  widget_label (base03 ,value = 'Current Calibration: '  ,font=ft_b_normal)
bacur	=  widget_label (base03 ,value = string(replicate(45b,30)),font=ft_b_normal)
comment	=  widget_label (base0  ,value = string(replicate(45b,50)),font=ft_b_normal)

base0b	=  widget_base  (base0  ,/column,frame=4)
bid	=  widget_label (base0b ,value = 'Make a Calibration file from raw data',font=ft_b_bigger)
base06	=  widget_base  (base0b ,/row)
bid	=  widget_label (base06 ,value='Wk_space #')
NWORK	=  widget_text  (base06 ,/editable,xsize =3 ,value= SWORK	,font=ft_propor)
bid	=  widget_label (base06 ,value='Comment:')
YTEXT	=  widget_text  (base06 ,/editable,xsize =15,value= 'no comment',font=ft_propor)
base07	=  widget_base  (base0b ,/row)
bid	=  widget_label (base07 ,value ='Filename:')
FILEN	=  widget_text  (base07 ,/editable,xsize =20,value='new'+MINST+'.cal',font=ft_propor)
bid	=  widget_button(base07 ,value = 'MAKE'			,uvalue = [-88,394,4])
bid	=  widget_label (base07 ,value ='(Put "'+MINST+'" in filename)')

widget_control  ,base0 , group_leader = lamp_b1,/realize  & put_logo
widget_control  ,bacur , set_value    = curfil
XMANAGER,'CALIB',base0 , event_handler='LAMP_EVENT_PARSER',/just_reg
ENDELSE
RETURN
END

pro p_did_calev, event,uv
;** ***********
;**
common calibration
common calibrotion
common calib

widget_control,comment,bad_id=ii,set_value=' '
CASE uv(2) of
;**SELECT
   1:	   lodfil = lirlist(event.index)
;**LOAD
   2:begin P_DID_CALOD, minst,lodfil, flg ,COMMENT=line
	   IF flg THEN begin curfil=lodfil & com= line+' is accepted ...' & endif $
		  ELSE begin curfil='None' & com= 'Bad Calibration file !!!' & endelse
	   widget_control,bacur  ,bad_id=ii, set_value=curfil
	   widget_control,comment,bad_id=ii, set_value=com
     end
;**NONE
   3:begin curfil='None' &  P_DID_CALOD, minst & widget_control,bacur,bad_id=ii,set_value=curfil & END
;**MAKE
   4:begin widget_control,nwork,bad_id=ii,get_value=swork & swork=strtrim(swork(0),2)
	   on_ioerror,mis_w & flg=0 & wn=fix(swork) & if (wn gt 0) and (wn le 20) then flg=1 & mis_w:
	   widget_control,filen,bad_id=ii,get_value=filnm & filnm=strtrim(filnm(0),2)
	   widget_control,ytext,bad_id=ii,get_value=text  & text =strtrim(text (0),2)
	   if flg eq 0 then com='Bad workspace number !!!' $
	   else begin	    P_DID_CALOD, minst,filnm,flg,wn , text
	   		    if flg eq  0 then com='Problem writting ' +filnm  +' !!!' else $
			    if flg eq -1 then com='Access denied:'    +pathcal+' !!!' $
					 else com= filnm+' write success ...'
      			    CD,PATHCAL,current=mee & lirlist = findfile('*'+MINST+'*') & CD,mee
			    widget_control,listcal , bad_id=ii,set_value=lirlist
	   endelse  &  widget_control,comment,bad_id=ii, set_value=com
     end
ELSE:
ENDCASE
RETURN
END

pro p_did_calod,minst,file, OK ,wn ,text ,LIST=list, COMMENT=line
;** ***********
;**
@lamp.cbk
common calibration
common calibrotion

IF n_elements(wn)   eq 1 then mot='MAKE'  else $
IF n_elements(file) eq 1 then mot='READ'  else $
IF keyword_set(list)     then mot='LIST'  else mot='CLEAR'

OK=-1 & in=0 & out=0 & line=''
IF mot eq 'READ' then begin on_ioerror,mis_read & OPENR,in ,pathcal+file,/get_lun
			    mis_read:  if in le 0 then mot='CLEAR'			& endif
on_ioerror,mis_writ
IF mot eq 'MAKE' then begin OPENW,out,pathcal+file,/get_lun
			    tmp=1 & ii=execute('tmp=float(W'+strtrim(string(wn),2)+')')	& endif
ok=0

IF mot eq 'LIST' then begin tmp=FINDFILE(pathcal+'*'+minst+'*' ,count=cc)
			    j  =strlen  (pathcal) & k=strpos(tmp(0),pathcal)
			    if cc gt 0 then begin   print,'Note:  CALIBRATION [,file="myfile"] [,/nocal] [,/list]'
						    print,'Actual calibration files:'
						    for i=0,cc-1  do if k lt 0 then print,tmp(i) $
						    else    print,strmid(tmp(i),j,30)
			    endif
endif else $
CASE  minst of
'd16':  IF mot eq 'READ' then begin
	   on_ioerror,misd16
	   inf_d16 =[file]
	   READF,  in,line
	   i =strpos(line,'(')   & j=strpos(line,'*')   & k=strpos(line,')')
	   sx=long(strmid(line,i+1,j-i-1)) & sy=long(strmid(line,j+1,k-j-1))
	   cal_d16 =fltarr(sx,sy)
 	   READF,in,cal_d16	&   ok=1
	   misd16: IF ok eq 0 THEN  cal_d16 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd16
	   sz=SIZE(tmp) & sx=strtrim(string(sz(1)),2) & sy=strtrim(string(sz(2)),2)
	   PRINTF, out,'Calib('+sx+'*'+sy+') ' +systime()+' '+text
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd16:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d16 =0

'd1a':  IF mot eq 'READ' then begin cal_d1a =fltarr(25)  & ang_d1a=findgen(25)
	   on_ioerror,misd1a
	   inf_d1a =[file]
	   READF,  in,line  & READF,in,ang_d1a,cal_d1a	 & ok=1
	   misd1a: IF ok eq 0 THEN  cal_d1a =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd1a
	   PRINTF, out,'Calib(25)    ' +systime()+' '+text
	   TAKE_DATP,p,w=wn
	   PRINTF, out, P.x
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd1a:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d1a =0

'd2b':  IF mot eq 'READ' then begin
	   on_ioerror,misd2b
	   inf_d2b =[file]
	   if strpos(file,'oldd2b') ge 0 then begin ; old d2b case,calib file contains oldd2b
	      nn=64
	      cal_d2b =fltarr(nn)  & ang_d2b=findgen(nn)
	      READF,  in,line  & READF,in,format='(64F8.3)',ang_d2b
			         READF,in,format='(64F8.5)',cal_d2b	  & ok=1
	   ENDIF else begin  ; new d2b case, calib file contains title, zones, values, efficiencies, values, angles, values, calib_end
	      nt=128 & nh=128 & nn=nt
	      zon_d2b=intarr(4,nt/2) & cal_d2b=fltarr(nh,nt) & ang_d2b=fltarr(nt)
	      readf, in, line ; title
	      readf, in, line ; zones
	      readf, in, zon_d2b ; values for active zone limits
	      readf, in, line ; efficiencies
	      readf, in, cal_d2b ; values for efficiencies
	      readf, in, line ; angles
	      readf, in, ang_d2b ; values for angles
	      ok=1 & line=file
	   ENDELSE
	   misd2b: IF ok eq 0 THEN BEGIN cal_d2b =0 & ang_d2b=findgen(nn) & ENDIF ; case-no calibration file read
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd2b
	   if strpos(file,'oldd2b') ge 0 then nn=64 else nn=128 & ns=strtrim(string(nn),2)
	   PRINTF, out,'Calib('+ns+')    ' +systime()+' '+text
	   TAKE_DATP,p,w=wn
	   PRINTF, out, P.x
	   PRINTF, out, tmp/(total(tmp)/n_elements(tmp)) & ok=1 & mikd2b:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_d2b =0

'd20': IF mot eq 'READ' then begin cal_d20 =fltarr(1600)& ang_d20=findgen(1600)
     	IF file EQ ' default' THEN BEGIN
       		inf_d20=[file,'not loaded','autod20.cal']
     	ENDIF ELSE BEGIN
		on_ioerror,misd20
 	     	READF,  in,line 
       		cal_d20 =fltarr(1600,long(strmid(line,6,4))/1600)
       		READF,in,ang_d20,cal_d20	 & ok=1
		IF N_ELEMENTS(inf_d20) EQ 0 THEN inf_d20=[file,line,'manualchoice'] ELSE inf_d20(0:1)=[file,line]
       		print,'New Calibration file loaded: ', inf_d20(0)
       		print,inf_d20(1)
       		if N_ELEMENTS(inf_d20) GE 3 THEN IF inf_d20(2) EQ 'autochoice' THEN BEGIN
         		PRINT,'D20 automatic default calibration by the right file - attention to wavelength!' 
       		ENDIF ELSE BEGIN
         		PRINT,'D20 manual choice of calibration file - pay attention to wavelength!' 
         		inf_d20(2) = 'manualchoice'
       		ENDELSE
 		misd20: IF ok eq 0 THEN  cal_d20 =0
     	ENDELSE
       ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikd20
	IF N_ELEMENTS(inf_d20) GE 1 THEN inf_d20=inf_d20(0:2)
 	PRINTF, out,'Calib('+strtrim(string(N_ELEMENTS(tmp)),2)+')  ' +systime()+' '+text
 	TAKE_DATP,p,w=wn
 	PRINTF, out, P.x(0:1599,0,0)
 	PRINTF, out, tmp & ok=1 & mikd20:
       ENDIF ELSE BEGIN
	cal_d20 =0
	inf_d20(0:2)=['','','']
	print,'NO Calibration',STRLEN(inf_d20(0))
       ENDELSE
	
'in13': IF mot eq 'READ' then begin cal_in13=fltarr(70)
	   on_ioerror,misin13
	   inf_in13=[file]
	   READF,  in,line  & READF,in,cal_in13		 & ok=1
	   misin13:IF ok eq 0 THEN  cal_in13=0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin13 & mikin13:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in13=0

'in6':  IF mot eq 'READ' then begin
	   on_ioerror,misin6
	   inf_in6 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in6 =fltarr(sz)  & idx_in6=intarr(sz) & shf_in6=intarr(sz)
	   READF,in,cal_in6	& READF,in,idx_in6 & READF,in,shf_in6 & ok=1
	   idx_in6=where(idx_in6 ge 0)
	   misin6: IF ok eq 0 THEN  cal_in6 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin  on_ioerror,mikin6
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf*0 & ok=1 & mikin6:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in6 =0

'in5':  IF mot eq 'READ' then begin
	   on_ioerror,misin5
	   inf_in5 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in5 =fltarr(sz)  & idx_in5=intarr(sz) & shf_in5=intarr(sz)
	   READF,in,cal_in5	& READF,in,idx_in5 & READF,in,shf_in5 & ok=1
	   idx_in5=where(idx_in5 ge 0)
	   misin5: IF ok eq 0 THEN  cal_in5 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin5
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf & ok=1 & mikin5:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in5 =0

'in4':  IF mot eq 'READ' then begin
	   on_ioerror,misin4
	   inf_in4 =[file]
	   READF,in,line & sz=1 & READS,line,sz
	   cal_in4 =fltarr(sz)  & idx_in4=intarr(sz) & shf_in4=intarr(sz)
	   READF,in,cal_in4	& READF,in,idx_in4 & READF,in,shf_in4 & ok=1
	   idx_in4=where(idx_in4 ge 0)
	   misin4: IF ok eq 0 THEN  cal_in4 =0
        ENDIF ELSE IF mot eq 'MAKE' then begin on_ioerror,mikin4
	   s_e=-1
	   if (size(tmp))(0) eq 2   then begin  win=lineup(tmp,pos,s_i,s_e,shf,.2)
						tmp=total (tmp,1)
				    endif else  shf=tmp*0
	   np=n_elements(tmp) & sz =strtrim(np,2)
	   tmp=(tmp/(total(tmp)/np))>.25
	   idb=where( (tmp le .25) or (tmp ge 4.) )
	   idx=indgen(np)
	   if s_e(0) ge 0 then idx(s_e)=-1 else if idb(0) ge 0 then idx(idb)=-1

	   PRINTF, out,sz+' Angles ,goods ,lineup ' +systime()+' '+ text
	   PRINTF, out, tmp & PRINTF, out, idx & PRINTF, out, shf & ok=1 & mikin4:
        ENDIF ELSE IF mot eq 'CLEAR' then cal_in4 =0
ELSE:
ENDCASE
mis_writ:
IF in  gt 0 THEN FREE_LUN,in
IF out gt 0 THEN FREE_LUN,out
RETURN
END

pro p_did_caldo,minst,WOUT,YOUT,ok
;** ***********
;**
common calibration
common calibrotion
ok=0
CASE  minst of
'in4':begin	IF n_elements(cal_in4) eq 0 THEN P_DID_CALOD, minst,minst+'.cal', flg
		IF n_elements(cal_in4) gt 1 THEN BEGIN WOUT = float(WOUT)
			sz=(size(WOUT))(2)   & sc= n_elements(cal_in4)
			if sz ne sc then begin cal_in4=0 & print,' # of Angles in calibration file is different !!!' & endif
			if sz ge sc then begin sw=sz-sc & sc=0
			endif	    else begin sc=sc-sz & sw=0 & endelse
			FOR i=sw,sz-1 DO WOUT(*,i)=SHIFT(WOUT(*,i),shf_in4(i-sw+sc)) $
								  /cal_in4(i-sw+sc)
			ok=1
			if sw gt 0 then  idx=[indgen(sw),idx_in4+sw]   else $
			if sc gt 0 then  idx=idx_in4(where((idx_in4-sc) ge 0))-sc $
				   else  idx=idx_in4
			WOUT=WOUT(*,idx) & YOUT=YOUT(idx)
		ENDIF
	end
'in5':begin	IF n_elements(cal_in5) eq 0 THEN P_DID_CALOD, minst,minst+'.cal', flg
		IF n_elements(cal_in5) gt 1 THEN BEGIN WOUT = float(WOUT)
			sz=(size(WOUT))(2)   & sc= n_elements(cal_in5)
			if sz ge sc then begin sw=sz-sc & sc=0
			endif	    else begin sc=sc-sz & sw=0 & endelse
			FOR i=sw,sz-1 DO WOUT(*,i)=SHIFT(WOUT(*,i),shf_in5(i-sw+sc)) $
								  /cal_in5(i-sw+sc)
			ok=1
			if sw gt 0 then  idx=[indgen(sw),idx_in5+sw]   else $
			if sc gt 0 then  idx=idx_in5(where((idx_in5-sc) ge 0))-sc $
				   else  idx=idx_in5
			WOUT=WOUT(*,idx) & YOUT=YOUT(idx)
		ENDIF
	end
'in6':begin	IF n_elements(cal_in6) eq 0 THEN P_DID_CALOD, minst,minst+'.cal', flg
		IF n_elements(cal_in6) gt 1 THEN BEGIN WOUT = float(WOUT)
			sz=(size(WOUT))(2)   & sc= n_elements(cal_in6)
			if sz ne sc then begin cal_in6=0 & print,' # of Angles in calibration file is different !!!' & endif
			if sz ge sc then begin sw=sz-sc & sc=0
			endif	    else begin sc=sc-sz & sw=0 & endelse
			FOR i=sw,sz-1 DO WOUT(*,i)=SHIFT(WOUT(*,i),shf_in6(i-sw+sc)) $
								  /cal_in6(i-sw+sc)
			ok=1
			if sw gt 0 then  idx=[indgen(sw),idx_in6+sw]         else $
			if sc gt 0 then  idx=idx_in6(where((idx_in6-sc) ge 0))-sc $
				   else  idx=idx_in6
			WOUT=WOUT(*,idx) & YOUT=YOUT(idx)
		ENDIF
	end
ELSE:
ENDCASE
RETURN
END


pro skipline , in,line,cnt,nvers=nvers
;** ********
;**
	ON_IOERROR,nocnt
	cnt=0L & bid=0L & READS,line+' 0 0 0',cnt,bid,nvers
	IF bid gt 0 THEN FOR i=1,bid DO READF,in,line
	nocnt:
RETURN
END

pro skipvpar ,vpb,vpara,in
;** ********
;**
IF vpb gt 0 THEN BEGIN deco=''
		 FOR I=0,vpb-1 DO BEGIN
			 READF,in,deco
			 READF,in,deco     & SKIPLINE,in,deco,vpb
			 vpara=fltarr(vpb) & READF,in,vpara
		 ENDFOR
ENDIF
RETURN
END


FUNCTION rdid , INST_GRP,PATH,FILENAME,STATUS,DATP ,COMP=comp
;******* ****
;**
;Input parameters
;----------------
;INST_GRP= ['in5','tof','1','0']
;PATH    =  '/usr/illdata/data/'
;FILENAME=  '001260'
;
;output parameters
;-----------------
;STATUS  = 0 if ok
;DATP    ={,w_tit:WT ,x_tit:XT ,y_tit:YT ,z_tit:ZT ,other_tit:OT $
;          ,time:DATE,p:PP,par_txt:PTXT,$
;           x:XX ,y:YY ,z:ZZ ,n:NN ,pv:PV ,e:EE}
common calibration
common calibrotion
common c_rdid , dzap, pzap, pzip ,pzup

;help, INST_GRP,PATH,FILENAME,STATUS,DATP ,COMP
;print,INST_GRP,PATH,FILENAME,STATUS,DATP

IF n_elements(PATHCAL )   eq 0 then begin PATHCAL =sys_dep('INSUB',P_LAMBDA(0),'CALIBRATION')
					  bid=findfile(pathcal+'*',count=nn) & if nn eq 0 then pathcal='' & endif
IF n_elements(INST_GRP)   le 1 then return,1
CATCH,stat & if stat ne 0 then begin CATCH,/cancel & print,!err_string
				     FREE_LUN,in   & RETURN, WOUT & endif

WOUT=0 & WT='' & DATE='' & OT='' & XT='' & YT='' & ZT='' & PP=0 & PTXT=''
WOU =0 & XX=0  & YY  =0  & ZZ=0  & NN=0  & PV=0  & EE=0

scan=0 & Vri=-1 & text='' & exper='' & partx='' & param=0  & parai=0 & vparm=0
pthv=PATH
INST=strlowcase(INST_GRP)
IF n_elements(FILENAME) gt 1 THEN BEGIN NIMG=fix(FILENAME(1)) & FILENAME=FILENAME(0)
			     ENDIF ELSE NIMG=0

IF (INST(0) EQ 'd16') OR   (INST(0) EQ 'db21') THEN INST(1) ='dif'
IF  INST(3) EQ '1'  THEN IF INST(1) EQ 'dif'   THEN IF INST(0) NE 'd1a' THEN  $
						    IF INST(0) NE 'd2b' THEN  $
						    IF INST(0) NE 'd10' THEN  $
						    IF strpos(pthv,INST(0)) gt 0 THEN $
		    pthv=pthv+INST(0)+'_'+strmid(FILENAME,1,1)+sys_dep('DIVIDER')
IF  INST(0) EQ 'd11tof' THEN BEGIN P=strpos(pthv,'tof')
				   if P gt 0 THEN pthv=strmid(pthv,0,P)+'/' & ENDIF
;Compressed or not!
;---------- -- ---
FIFI=FILENAME & fufu=strlowcase(FIFI) & zipd=0 & cprs=0 & slashc=0
IF (strpos(fufu,'.gz') gt 0) or (strpos(fufu,'.gzip') gt 0) then zipd=1 $
ELSE begin form=findfile(pthv+FILENAME+'.Z',count=cnt)  & if cnt gt 0 then zipd=2 & endelse
IF zipd GT 0  THEN BEGIN
   if zipd eq 2 then FIFI=FIFI+'.Z'
   
   IF (sys_dep('VERSION') lt 5.4) or (zipd eq 2) then begin
	IF pthv NE '' THEN begin bid=sys_dep ('COPY',FIFI,pthv) & cprs=1 & endif
	bid=sys_dep ('UN_Z',FIFI) &  pthv=''
	FIFI=strmid(FIFI,0,rstrpos(FIFI,'.'))
   ENDIF else slashc=1
ENDIF

ON_IOERROR,misopen
STATUS=11
in=125
GET_LUN,in & if in ge 125 then for i=125,128 do free_lun,i

if slashc then OPENR,in,pthv+FIFI,/COMPRESS $
          else OPENR,in,pthv+FIFI

	STATUS=13
	line  =''   & deco='' & form ='' & cnt =0L & bid=0L & numor=0L & vpb=0L
	linet =[''] & nvers=0 & formb='' & cntb=0L
	ON_IOERROR,misread
	
	READF,in,line     & READF,in,deco   & READF,in,line
	SKIPLINE,in,deco,numor,nvers=nvers

;	Contact and date
;	------- --- ----	
	READF,in,deco  & cnt=80
	SKIPLINE,in,deco,cnt
	nbl  =long(cnt/80) & IF nbl*80 lt cnt  THEN  nbl=nbl+1
	text =strarr(nbl)  & READF,in,text   & READF,in,form
	form =strmid(form,0,2)
     	insv =strlowcase(strtrim(strmid(text(0),0,4),2))
	if (inst(0) eq 'd9') or (inst(0) eq 'd10') then insv=inst(0)  ;!!!!!!! to comment in some days
	if (inst(0) eq 'd11tof') then insv=inst(0)
	if (inst(0) lt ' '     ) then begin INST_GRP(0)=insv & inst(0)=insv & endif

	IF  form ne 'VV'  THEN BEGIN
	 WHILE form ne 'AA' DO BEGIN READF,in,form & form=strmid(form,0,2)
	 ENDWHILE

;	 Experiment
;	 ----------	
	 READF,in,deco      & SKIPLINE,in,deco,cnt
	 nbl  =long(cnt/80) & IF nbl*80 lt cnt  THEN  nbl=nbl+1
	 exper=strarr(nbl)  & READF,in,exper  & READF,in,form
	 form =strmid(form,0,2)
	 WHILE form lt 'AA' DO BEGIN READF,in,form & form =strmid(form,0,2) & ENDWHILE
	ENDIF

;	Parameters
;	----------
	WHILE (form ne 'SS') AND (form ne 'VV') DO BEGIN
		
		READF,in,deco      & SKIPLINE,in,deco,cnt
		nbl  =long(cnt/80) & IF nbl*80 lt cnt  THEN  nbl=nbl+1
		IF form eq 'FF'  THEN BEGIN
 				      IF n_elements(par4)  gt 0 THEN par5=par4
 				      IF n_elements(par3)  gt 0 THEN par4=par3
 				      IF n_elements(par2)  gt 0 THEN par3=par2
 				      IF n_elements(par1)  gt 0 THEN par2=par1
				      IF n_elements(param) gt 1 THEN par1=param
				      param=fltarr(cnt) & ENDIF ELSE $
		IF form eq 'II'  THEN parai=lonarr(cnt)   ELSE  $
		IF form eq 'AA'  THEN bidon=strarr(nbl)
	
		IF form eq 'AA'  THEN READF,in,bidon ELSE $
		IF form eq 'II'  THEN READF,in,parai ELSE $
		IF form eq 'FF'  THEN READF,in,param
		READF,in,form
		form=strmid(form,0,2)
	
	ENDWHILE
	
	IF form eq 'SS' THEN BEGIN
;***	** **** ** **** **** ***** ---> DIF TOF
;***	** **** ** **** **** ***** ---> DIF TOF
;***	** **** ** **** **** ***** ---> DIF TOF

;	# scans
;	-------
	
	READF,in,deco     & READS,deco+' 0 0 0 0 0 0',bid,scan,bid,bid,bid,vpb
	SKIPVPAR,vpb,vpara, in
	READF,in,form     & form=strmid(form,0,2)
	IF form eq 'JJ' THEN form='II'
	IF scan lt  1   THEN scan=1 ELSE scan=scan+1

	READF,in,deco     & SKIPLINE,in,deco,cnt
	
	forcl=1 & forcd=0 & m19=0
	
	CASE insv OF
	'd19' : begin   vp=10 & forcl=0
		IF (scan gt 1) and (cnt eq 512.*16) THEN BEGIN  forcd=1
		    bad_d=intarr(512) & m19=2*512 & cnt=cnt-m19 & ENDIF
	        end
	'd9'  : begin   vp=10 & forcl=0 & end
	'db21': begin   vp=10 & forcl=0 & end
	'd16' : begin   vp=10 & end
	'd1b' : begin   vp=3  & end
	else  : begin   vp=0  & end
	ENDCASE

	IF vpb gt 0 THEN vp=0

	cnt  =  cnt-vp
	IF cnt  ge 1 THEN BEGIN
	IF vp   gt 0 THEN BEGIN vparm=lonarr(vp ,scan) & vpara=lonarr(vp) & ENDIF
	IF vpb  gt 0 THEN	vparm=fltarr(vpb,scan)
	IF scan gt   1    THEN $
	IF form eq 'II'   THEN buf=lonarr(cnt) $
	                  ELSE buf=fltarr(cnt)

	IF form ne 'II'   THEN WOUT=fltarr(cnt,scan) $
	                  ELSE IF   forcl  eq 0 THEN $
			           WOUT=intarr(cnt,scan) $
	                  ELSE WOUT=lonarr(cnt,scan)
;	Read data
;	---- ----
	ib=0 & scanv=scan
	FOR i=0,scanv-1 DO   BEGIN
	    IF  i gt 0  THEN BEGIN
	    	READF,in,line   & READF,in,deco
		READS,deco+' 0 0 0 0 0 0',bid,bid,bid,bid,bid,vpb
		SKIPVPAR,vpb,vpara,in
		READF,in,formb	& formb=strmid(formb,0,2) & IF formb eq 'JJ' THEN formb='II'
	    	READF,in,deco 	& SKIPLINE,in,deco,cntb & cntb=cntb-m19
		IF   cntb ne cnt+1 THEN $
		IF ((cntb ne cnt) or (formb ne form)) and (vp eq 0) then begin
				cnt=cntb & form=formb & WOU=WOUT(*,0:i-1) & ib=i  & scan=(scan-i)>1
				IF form eq 'II' THEN buf =lonarr(cnt)      ELSE buf =fltarr(cnt)
				IF form eq 'II' THEN WOUT=lonarr(cnt,scan) ELSE WOUT=fltarr(cnt,scan)
				ENDIF
	    ENDIF
	    IF vpb  gt 0 THEN   vparm(*,i)=vpara
	    IF scan le 1 THEN   BEGIN
	    			IF vp eq 0 THEN READF, in,         WOUT  $
	    			ELSE      BEGIN READF, in, vpara , WOUT
	    			                vparm(0,i)=vpara & ENDELSE
	    ENDIF	 ELSE   BEGIN
	    			IF vp eq 0 THEN BEGIN
				  IF forcd eq 1 THEN READF,in,bad_d,buf,bad_d $
				                ELSE READF,in,buf
				ENDIF      ELSE BEGIN
				  IF forcd eq 1 THEN READF,in,vpara,bad_d,buf,bad_d $
				                ELSE READF,in,vpara,buf
	    			  vparm(*,i)=vpara
				ENDELSE
	    		      WOUT(*,i-ib)=buf
	    ENDELSE
	    Vri=i+1
	ENDFOR
	STATUS=0
	ENDIF
	ENDIF ELSE $
	IF form eq 'VV' THEN BEGIN
;***	** **** ** **** **** ***** --->  TAS
;***	** **** ** **** **** ***** --->  TAS
;***	** **** ** **** **** ***** --->  TAS

	NP=0
	READF,in,line & partx=[line]   &  READF,in,line
	linec='' & step='!!'
	WHILE strpos(line,'DATA_:') lt 0 DO BEGIN
	      IF strpos(line,'COMND:') eq 0 THEN BEGIN
	      			i=strpos(strlowcase(line),' np ')
	      			IF i  gt 0 THEN READS,strmid(line,i+4,5)+' 0' ,NP
	      			IF NP eq 0 THEN NP=100
	      			linec=strmid(strtrim(strcompress(line),2),7,50)
	      			ENDIF
	      IF strpos(line,'STEPS:') eq 0 THEN $
				step=strmid(strtrim(strmid(line,6,6),2),1,6)
	      partx=[partx,line]
	      READF,in,line
	ENDWHILE
	READF,in,line & line=strtrim(strcompress(line),2)+' ' & partx=[partx,line]
			l=strlen(line) & j=0
			FOR i=0,l-1 DO IF strmid(line,i,1) eq ' ' THEN BEGIN
					  linet=[linet,strmid(line,j,i-j)] & j=i+1 & ENDIF
			linet=linet(1:*)
	partx=strtrim(partx,2)

	IF NP  GT 0 THEN BEGIN
	   pos=0L & POINT_LUN,-in,pos
	   	    READF,in,line & line=strtrim(strcompress(line),2)
	   	    POINT_LUN, in,pos
	   cnt=0 & i=0 & WHILE i ge 0 DO BEGIN cnt=cnt+1 & i=strpos(line,' ',i+1)  & ENDWHILE
	
	   ON_IOERROR,eofread
	   vparm=fltarr(cnt,NP)
	   READF,in,vparm
	   
	   IF vparm(0,NP-1) eq 100 THEN BEGIN   buf=fltarr(cnt)
	   					WHILE (1) DO BEGIN READF,in,buf
	   						     vparm=[[[vparm]],[buf]]
	   						     NP=NP+1 & ENDWHILE & ENDIF
	eofread:STATUS=0
	IF n_elements(vparm) gt 1 THEN BEGIN i=NP-1 & WHILE (i gt 0) and (vparm(0,i) eq 0) do i=i-1
						vparm=vparm(*,0:i>0)               & ENDIF
	ENDIF
	ENDIF
	
misread:FREE_LUN,in
	IF Vri gt 0 then IF Vri lt scan THEN begin scan=Vri & WOUT=WOUT(*,0:scan-1) & STATUS=0
					IF vp+vpb gt 0 THEN vparm=vparm(*,0:scan-1) & endif
IF cprs gt 0 THEN bid=sys_dep ('DELET', FIFI)

misopen:FREE_LUN,in

IF STATUS eq 11 THEN print,'File "'+pthv+FILENAME+'" Not found  !!!'
IF STATUS eq 13 THEN print,'File "'+pthv+FILENAME+'" Read error !!!'
IF STATUS eq 0  THEN BEGIN

   CASE INST(1) OF
   'dif':  BEGIN
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' Run ' + FILENAME    ;+' User '     +strmid(text,4,10)  
           XT  ='Detector X .'
           YT  ='Detector Y .'
           IF    scan gt 1 THEN ZT ='Points' ELSE  ZT ='Counts'
	   NN  = 1
	   ntype=0 & kctrl=0 & manip=0 & nbang=0 & icdes=[0] & ub=fltarr(3,3)
	   if n_elements(parai) gt 25 then begin
	   	ntype=parai(1)
	   	kctrl=parai(2)
	   	manip=parai(3)
	   	nbang=parai(4)<6
	   	icdes=parai(24:24+nbang+1)
	   	ub   =reform(param(8:16),3,3)
	   endif
	   IF   n_elements(param) ge 50      THEN  BEGIN
	   	   PP  = [param(3:6),param(17)   ,param(45:47),param(29),param(35:36),param(38),$
		          param(0:2),param(21:23),param(8 :16),manip ,kctrl]
	   	   PTXT= ['Phi    ','Chi    ','Omega  ','2*Theta',$
	   	   	  'Wave lenght',$
	   	   	  'Requested  Temperature  ',$
	   	   	  'Regulation Temperature  ',$
	   	   	  'Sample (K) Temperature  ',$
	   	   	  'Sample-Detector Distance',$
		   	  'Starting Angle  ',$
		   	  'Angle Variation ',$
		   	  'Preset (monitor)',$
			  'Hmin','Kmin','Lmin','Hmax or 0','Kmax or 0','Lmax or 0',$
			  'ub(1,1)','ub(1,2)','ub(1,3)','ub(2,1)','ub(2,2)','ub(2,3)','ub(3,1)','ub(3,2)','ub(3,3)',$
			  'Manip 1:gamma 2:omega 3:chi 4:phi','Kctrl 1:around hkl']
		   NN  = param(38)
	   	   ENDIF
    	   IF   n_elements(vparm) ge scan*2  THEN  NN =[vparm(0,0:scan-1),vparm(1,0:scan-1)]
    	   IF  (n_elements(vparm) ge scan*4) and (scan gt 1) and ((nbang ge 1) or (icdes(0) eq -1)) THEN BEGIN
    	           ZZ  =[ vparm(3,0:scan-1)]/1000.
     	           PV  =[ vparm(3:2+(nbang>1),0:scan-1)]/1000.
		   XT='X' & YT='Z' & ZT='Scan'
		   AX_g=fltarr(scan)+param(6)*!pi/180. & AX_o=fltarr(scan)+param(5)*!pi/180.
		   AX_c=fltarr(scan)+param(4)*!pi/180. & AX_p=fltarr(scan)+param(3)*!pi/180.
		   FOR i=0,nbang-1 do begin
		     case icdes(i) of
		     -1:begin if i eq 0 then ZT='Temperature'                           & end
		      1:begin if i eq 0 then ZT='Gamma' & AX_g=reform(PV(i,*))*!pi/180. & end
		      2:begin if i eq 0 then ZT='Omega' & AX_o=reform(PV(i,*))*!pi/180. & end
		      3:begin if i eq 0 then ZT='Chi'   & AX_c=reform(PV(i,*))*!pi/180. & end
		      4:begin if i eq 0 then ZT='Phi'   & AX_p=reform(PV(i,*))*!pi/180. & end
		      else:
		      endcase
		   ENDFOR
		   UB1=invert((ub),statub)
		   IF  statub eq 0 then begin
		                        SIN_g=2*sin(AX_g/2.)/param(17)
		      if insv eq 'd10' then COS_o=cos(AX_o-AX_g/2.) else COS_o=cos(AX_o)
		      if insv eq 'd10' then SIN_o=sin(AX_o-AX_g/2.) else SIN_o=sin(AX_o)
		      COS_c=cos(AX_c) & SIN_c=sin(AX_c)
		      COS_p=cos(AX_p) & SIN_p=sin(AX_p)
		      HMU  =[[(COS_o * COS_c * COS_p - SIN_o * SIN_p)* SIN_g] , $
		             [(COS_o * COS_c * SIN_p + SIN_o * COS_p)* SIN_g] , $
		             [(COS_o * SIN_c)* SIN_g]]
		      HKL  =transpose((UB1)##(HMU))
		      d=10000. & HKL=round(HKL*d) & HKL=HKL/d
		      PV   =[PV,HKL]
		   ENDIF
     	   ENDIF ELSE IF scan gt 1 then ZZ=indgen(scan)+1 else ZZ=0

     	   CASE insv of
     	   'd19':  BEGIN IF n_elements(cal_d19) eq 0 THEN BEGIN
     	   		 ENDIF
			 IF n_elements(WOUT) eq 64.*64*scan then $
			      IF scan le 1 THEN WOUT=reform(WOUT,64,64     ,/overwrite) $
			                   ELSE WOUT=reform(WOUT,64,64,scan,/overwrite) $
     	   		 ELSE WOUT=reform(WOUT,512  ,n_elements (WOUT)/512 ,/overwrite)
		   END
	   'd9':   BEGIN IF scan gt 1 THEN WOUT=reform   (WOUT,32,32,n_elements(WOUT)/32/32,/overwrite)$
	    	   	      	      ELSE WOUT=reform   (WOUT,32,32, /overwrite)
			 
			 IF sys_dep('VERSION') ge 4.0 then $
			 IF scan gt 1 THEN ii=execute('WOUT=transpose(WOUT,[1,0,2])') $
				      ELSE WOUT=transpose(WOUT)
		   END
	   'd10':  BEGIN IF scan gt 1 THEN WOUT=reform   (WOUT,32,32,n_elements(WOUT)/32/32,/overwrite)$
	    	   	      	      ELSE WOUT=reform   (WOUT,32,32, /overwrite)
				
			 IF sys_dep('VERSION') ge 4.0 then $
			 IF scan gt 1 THEN ii=execute('WOUT=transpose(WOUT,[1,0,2])') $
				      ELSE WOUT=transpose(WOUT)
		   END
	   'd15':  BEGIN IF scan gt 1 THEN WOUT=reform   (WOUT,32,32,n_elements(WOUT)/32/32,/overwrite)$
	    	   	      	      ELSE WOUT=reform   (WOUT,32,32, /overwrite)
			 
			 IF sys_dep('VERSION') ge 4.0 then $
			 IF scan gt 1 THEN ii=execute('WOUT=transpose(WOUT,[1,0,2])') $
				      ELSE WOUT=transpose(WOUT)
		   END
	   'd16':  BEGIN nel=n_elements(WOUT) & nxy=nel/scan & sy=nxy/64 & sx=nxy/sy
	   		 IF nxy ge 64.*64 then begin  & sy=sqrt(nxy) & sx=nxy/sy & endif
			 IF scan gt 1 THEN WOUT=reform   (WOUT,sx,sy,nel/sx/sy,/overwrite) $
	    	   	      	      ELSE WOUT=reform   (WOUT,sx,sy, /overwrite)
					   IF sy eq 16 then begin
					    WOUT=reverse  (WOUT(1:sx-2,1:sy-2,*),1) & sx=sx-2 & sy=sy-2
					   ENDIF
			 sw=size(WOUT) & if sw(0) eq 3 then sz=sw(3) else sz=1
			 IF n_elements(cal_d16) eq 0 THEN $
			    P_DID_CALOD, insv,insv+'.cal', flg

			 IF n_elements(cal_d16) gt 1 THEN BEGIN WOUT=float(WOUT)
				FOR i=0,sz-1 DO WOUT(0,0,i)=WOUT(*,*,i)/cal_d16
				OT=OT+' /'+inf_d16(0) & ENDIF
		   ZZ  =numor
		   
		   if n_elements(pzip) eq 0 then pzip=0.
		   D2TH=pzip

		   PTXT= ['2*Theta   ','Omega     ','Chi       ','Phi       ',$
	   	   	  'Trans_X   ','Trans_Y   ','Rot       ','Beamstop  ',$
                          'Wave lenght             ','Requested  Temperature  ',$
	   	   	  'Regulation Temperature  ','Sample (K) Temperature  ',$
	   	   	  'Sample-Detector Distance','Starting Angle          ',$
                          'Angle Variation         ','Angle Range             ',$
			  'PRESET                  ','Coupling factor         ',$
                          'Motor scanned           ','Nb points requested     ','Nb points saved         ',$ 
			  'Count:Monitor or Time   ','Type of T-regulation    ','Type of Multi-meter     ',$
                          'Delta2th                ']
		   PP  =[param(6),param(5),param(4),param(3),0,0,0,0,param(17),param(45:47),$
                         param(29),param(35:38),param(42),parai(3),parai(5:7),parai(12:13),pzip]
                        
                   scan_t=parai(3)
                   nbang =parai(4)
                   FOR i=1,nbang DO IF parai(23+i) eq 0 THEN parai(23+i)=24

;                  ***Lecture pour les differents motors scans*****
	 	   PP(parai(24)-1)=vparm(3)/1000.
                   IF nbang eq 1 THEN BEGIN ZZ=PP(2) & ENDIF
		   IF nbang eq 2 THEN BEGIN PP(parai(25)-1)=vparm(4)/1000. & ENDIF
                   IF nbang eq 3 THEN BEGIN PP(parai(25)-1)=vparm(4)/1000. & PP(parai(26)-1)=vparm(5)/1000. & ENDIF
                   IF parai(3) gt 0 THEN BEGIN ZZ=round(vparm(3)*100/1000.) 
		       IF ZZ   eq 0 THEN ZZ=1
                       IF parai(3) eq 1  THEN  ZT='gamma*100'   & IF parai(3) eq 2 THEN ZT='omega*100'
                       IF parai(3) eq 3  THEN  ZT='chi*100'     & IF parai(3) eq 4 THEN ZT='phi*100'
                       IF parai(3) eq 5  THEN  ZT='Trans_X*100' & IF parai(3) eq 6 THEN ZT='Trans_Y*100'
                       IF parai(3) eq 7  THEN  ZT='Rot*100'
		   ENDIF
                   IF PP(12) le 0 THEN PP(12)=100.
		   if sy gt 16 then reso=.3 else reso=.254
		   if sy gt 64 then reso=.2
		   step = 180./!pi * reso/PP(12)
		   ste  = fix(step*1000) & ste = ste/1000.
		   set_tolerance,tt,/get & if tt eq 0 then set_tolerance,ste
		   offs = sx/2 -.5
		   XX   = findgen(sx)*step + PP(0) - offs*step
		   YY   =  indgen(sy)
                   NN   = vparm(1)

;                  ****Write the file in a regular grid determined by the delta2th parameter***
                   IF D2TH gt 0.001 THEN BEGIN
                     S=ROUND((XX(n_elements(XX)-1)-XX(0))/D2TH)+2
                     WINT=fltarr(S,sy) & FRAC=0 & XR=fltarr(S) & NN=lonarr(S)
;                    ***XR contains the 2th's rounded to the nearest step size**
		     tent=round(XX(0)/D2TH)*D2TH
                     if XX(0) gt tent then XR(0)=tent else XR(0)=tent-D2TH

                     for i=1,S-1   do XR(i)=XR(i-1)+D2TH  
;                    ****How to write the numor o the regular grid XR****
                     FOR i=0,sx-1 do begin 
                      FOR J=0,S-2 do begin
                       IF (XX(i) gt XR(j)) and (XX(i) lt XR(j+1)) then begin
			   FRAC=(XX(i)-XR(j))/D2TH & FRAC1=1-FRAC
                           WINT(j,*)=FRAC1*WOUT(i,*)+WINT(j,*)	& WINT(j+1,*)=FRAC*WOUT(i,*)+WINT(j+1,*) 
                             NN(j)  =FRAC1*vparm(1) +  NN(j)	&   NN(j+1)  =FRAC*vparm(1) +  NN(j+1) 
                       ENDIF
                      ENDFOR 
                     ENDFOR
		     XX=XR & WOUT=WINT 
                     EE = SQRT(WOUT)		; *** EE the error
                   ENDIF
                   XX=round(XX*10000) & XX=XX/10000.
           	   XT   ='2*theta'
		   END
	   'db21': BEGIN WOUT=reform(WOUT,128 ,128,/overwrite)
	   	   END
	   'd1b':  BEGIN
           	   XT  ='2*Theta'
           	   YT  ='Temperature'
           	   XX  =findgen(n_elements(WOUT)) * 79.8/(n_elements(WOUT)-1)+PP(3)
           	   YY  =param(46)
	   	   END
	   'd1a':  BEGIN
	   	   if n_elements(WOUT) ge 65536 then begin
		      IF scan gt 1 THEN WOUT=  reform(WOUT,256,256,n_elements(WOUT)/256/256,/overwrite) $
		                   ELSE WOUT=  reform(WOUT,256,256,/overwrite)
		   endif else begin
	  	   nd=25. & IF n_elements(cal_d1a) eq 0 THEN $
				     P_DID_CALOD, insv,insv+'.cal', flg
		   nj  = n_elements(WOUT)/(nd+4)
		   stop
		   if long(nj) ne nj then RETURN,0
	   	   WOUT= reform(WOUT,(nd+4),nj ,/overwrite)
		   NN  = WOUT(0,0)
		   YY  = reform(WOUT(2,*))/1000.
   	   	   YT  ='Counts'
		   WOUT= WOUT(4:*,*)
		   IF n_elements(cal_d1a) eq nd THEN BEGIN wout=float(wout) &  FOR i=0,nj-1 $
						        DO wout(0,i)=wout(*,i)/cal_d1a & fct=1.
							OT=OT+' /'+inf_d1a(0)
		   ENDIF ELSE fct = -6.

		   XX  =fct*ang_d1a+YY(0)
		   WOUT= reform(WOUT,nd*nj,/overwrite)
		   IF nj gt 1 then BEGIN FOR i=1,nj-1 do  XX=[XX , fct*ang_d1a+YY(i)]
		   			 idx=sort (XX) &  XX =XX(idx) & WOUT=WOUT(idx)
		   			 XX =round(XX/0.05) & XX=XX*0.05
		   			 YY =param(46)
		   		   ENDIF
           	   XT  ='2*Theta'
		   endelse
	   	   END
	   'd2b':  BEGIN
;			*** initialize parameters ***
			nd=float(parai(23)) & D2TH = param(36) 
		        if n_elements(dzap) eq 0 then dzap=0
		        if n_elements(pzap) eq 0 then pzap=0
;			*** read calibration file (if present)
			IF n_elements(cal_d2b) eq 0 THEN begin
			   if nd eq 64 then fcal='oldd2b.cal' else fcal=insv+'.cal'
			   P_DID_CALOD, insv,fcal, flg
			ENDIF
;		       *** nj = number of points ***
                   
;              ### SEPARATE OLD D2B WITH 64 DETCETORS FROM SUPER D2B WITH 128 x H DETECTORS
                   IF nd eq 64 THEN BEGIN; old d2b - pre 2003
                     print, 'OLD D2B'
		   vp  = parai(4)+2
		   nj  = n_elements(WOUT)/(nd+vp)
;                   print, nd, D2TH, vp, nj
;		       *** rewrite WOUT in matrix form (69 cols, nj rows) ***
	   	   WOUT= reform(WOUT,(nd+vp),nj ,/overwrite)
		   NN  = WOUT(0,0)
;			*** YY = 2th values for detector 1 ***
		   YY  = reform(WOUT(2,*))/1000.
;			*** set titles ***
   	   	   YT  ='Counts'
		   XT  =' 2*Theta' 
;			*** reform WOUT to eliminate first vp values (not data) ***
		   WOUT= WOUT(vp:*,*)
;		   *** detector zapping algorithm ***
;		   *** definition of new calibration arrays (default: equal to old)
		   newcal_d2b=cal_d2b 
		   newang_d2b=ang_d2b
		   newd=nd
;		   *** test if dzap contains real detectors **
		   idz=where(dzap ge 1 and dzap le 64)
;		   *** in case, eliminate spurious values ***
		   if idz(0) ne -1 then dzap=dzap(idz) else dzap=0
;		   *** is there something left? ***
		   SD=SIZE(dzap)

;		   *** test if pzap contains real points **
		   idz=where(pzap ge 1 and pzap le nj)
;		   *** in case, eliminate spurious values ***
		   if idz(0) ne -1 then pzap=pzap(idz) else pzap=0
;		   *** is there something left? ***
		   SP=SIZE(pzap)

;		   *** if dzap has something, do the following ***
		   if SD(0) gt 0 then BEGIN
;		     *** set all dud values and calibration to -999 ***
		     WOUT(dzap-1,*)=-999
		     newcal_d2b(dzap-1)=-999
;		     *** good values are those which do not contain -999 ***
		     GOOD=where(WOUT ne -999)
		     if GOOD(0) eq -1 then return, GOOD(0)

;		     *** cut out dud values from WOUT and calibrations ***
		     WOUT=WOUT(GOOD)
		     newang_d2b=ang_d2b(where(newcal_d2b ne -999))
		     newcal_d2b=cal_d2b(where(newcal_d2b ne -999))
;		     *** redefine the detector number
		     newd=(nd-n_elements(dzap))
;		     *** reform WOUT to proper format
		     WOUT=reform(WOUT,newd,nj ,/overwrite)
		   ENDIF

;		   *** if pzap has something, do the following ***
		   if SP(0) gt 0 then BEGIN
;		     *** set all dud values -999 ***
		     WOUT(*,pzap-1)=-999
;		     *** good values are those which do not contain -999 ***
		     GOOD=where(WOUT ne -999)
;		     *** cut out dud values from WOUT ***
		     WOUT=WOUT(GOOD)
;		     *** redefine the number of points
		     nj=(nj-n_elements(pzap))
;		     *** reform WOUT to proper format
		     WOUT=reform(WOUT,newd,nj ,/overwrite)
		   ENDIF
;			*** if calibration available, calibrate by dividing ***
		   
		   IF n_elements(cal_d2b) eq nd THEN BEGIN wout=float(wout) &  FOR i=0,nj-1 $
							DO wout(0,i)=wout(*,i)/newcal_d2b & fct=1. ; all of wout should be corrected, not just 0?
							OT=OT+' /'+inf_d2b(0)
;		        *** fct*newang_d2b always newd values spaced by ~ -2.5 ***
		   ENDIF ELSE fct = -2.5

;			*** XX array of initial 2th for all detectors ***
		   XX  =fct*newang_d2b+YY(0) ; &  print, XX
;			*** reform WOUT to be a 1-line vector ***
		   WOUT= reform(WOUT,newd*nj,/overwrite)
;			*** create a XX array by adding up all 2th for all dets **
;			*** in the same order as in WOUT

;			*** do the following if there are at least 2 points ***
		   IF nj gt 1 then BEGIN FOR i=1,nj-1 do  XX=[XX , fct*newang_d2b+YY(i)]
;			*** sort the XX and WOUT arrays (idx is the index array) ***
		   			 idx=sort (XX) &  XX =XX(idx) & WOUT=WOUT(idx) ; & print, idx
;			*** XR contains the 2th's rounded to the nearest step size ***
		   			 XR =round(XX/D2TH) & XR=XR*D2TH
;			*** GRID contains the fractional indices of XR into XX ***					 
					 GRID=(XR-XX)/D2TH+findgen(n_elements(XX))				
;			*** WINT is WOUT interpolated onto the fractional indices *** 
					 WINT=interpolate(WOUT,GRID)
;			*** reassign XX and WOUT
					 XX=XR
				         WOUT=WINT
;			*** YY is the temperature, EE the error
		   			 YY =param(46)
;No error for Emanuelle			 EE = SQRT(WOUT)
		   		   ENDIF

;                  end old d2b - pre 2003
                   ENDIF ELSE BEGIN ; super d2b - 2003 on
		   NN  = param(38)
	           rdid_d2b, INST,numor,nvers,text,exper,scan,cnt,nd,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                 WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE


                   ENDELSE ; end super d2b - April 2003 onward
	   	   END ; end d2b case
		   
	'd20': rdid_d20, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                 WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE

	
	   else:
	   ENDCASE
	   END

   '3axes':BEGIN
   	   DATE=strmid   (partx(5),7,9)
   	   WT  =strmid(partx(2),7,11) +' '+linec
   	   OT  =insv +' '+partx(5)+' '+partx(2)+' Run ' + FILENAME
   	   XT  =strcompress(strmid(partx(6),7,69))
   	   YT  ='CNTS'
   	   PP  =fltarr(n_elements(partx))
   	   PTXT=partx
   	   PV  =vparm
   	   
   	   idx =where(linet eq 'CNTS') & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN WOUT=reform(vparm(idx,*)) ELSE WOUT=reform(vparm)
	   
   	   idx =where(linet eq 'M1')   & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN NN  =reform(vparm(idx,*))

   	   idx =where(linet eq step)   & idx=idx(0)
   	   IF idx ge 0 THEN IF idx lt cnt THEN BEGIN XX  =reform(vparm(idx,*))
   	   					     id  =sort(XX)
   	   					     XX  =XX  (id)
   	   					     WOUT=WOUT(id)
   	   					     IF n_elements(NN) gt 1  THEN  NN=NN(id)
   	   					     XT  =XT+' unit= '+step  &  ENDIF
	   EE  =sqrt(WOUT)
   	   END
   'tof':  BEGIN nd =0
   	   nb_chn=(SIZE(WOUT))(1)
   	   nb_spc=(SIZE(WOUT))(2)
	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
	   WT  =	                            strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
	   XT  ='Channels'
	   YT  ='Spectrum'
	   ZT  ='Numor' & ZZ=numor

     	   CASE insv of
	   
           'd7':   rdid_d7, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                    WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE
     	   'in16': BEGIN IF n_elements(WOUT) gt 1 THEN BEGIN Helas=0
			        IF n_elements(WOU) eq 1 THEN WOU=WOUT else Helas=1
				nb_chn=par1(6)          & nb_spc=par1(7)
				nb_mon=par1(8)          & md_pos=par1(64)
				n_md  =20               & ndind =nb_spc
				YY    =fltarr(nb_spc)
				NN    =WOU (0:nb_chn-1,nb_spc:nb_spc+nb_mon-1)>1
				PP    =[par1 (14),par1 (6 ),par1 (7 ),par1 (8 ),par1 (15),0.       ,$
				        0.       ,par1 (69),par1 (79),par1 (9 ),par1 (20),par1 (83),$
				        par1 (59),par1 (60),par1 (13),0.       ,0.       ,0.       ,$
				        0.       ,par1 (64),param(20),param(21),param(22),param(23),$
				        param(24),param(25),param(26),param(27),param(0 ),$
				        param(1 )-param(0 ),n_md]
				PTXT  =['Type of scan (index)            ','Number of channels              ',$
				        'Number of detectors             ','Number of monitors              ',$
				        'Mesuring time per step (seconds)','Not used                        ',$
				        'Not used                        ','Monochromator d-spacing (ang.)  ',$
				        'Analyser      d-spacing (ang.)  ','Average sample temperature  (K) ',$
				        'Deflector Chopper frequency (Hz)','Number of dead channels         ',$
				        'T1 (microsec.)                  ','T2 (microsec.)                  ',$
				        '1 if diffraction detector used  ','Not used                        ',$
				        'Not used                        ','Not used                        ',$
				        'Not used                        ','MD position                     ',$
				        'Single scattering angle 1 (deg.)','Single scattering angle 2 (deg.)',$
				        'Single scattering angle 3 (deg.)','Single scattering angle 4 (deg.)',$
				        'Single scattering angle 5 (deg.)','Single scattering angle 6 (deg.)',$
				        'Single scattering angle 7 (deg.)','Single scattering angle 8 (deg.)',$
				        'First angle MD-tube       (deg.)','Angle increment MD        (deg.)',$
				        'Number of MD-tubes              ']
				IF (nb_spc ge n_md)  THEN BEGIN
				  ndind = nb_spc - n_md
				  if ndind   gt   0  THEN YY(0    :ndind-1)     = param(n_md:n_md+ndind-1)
				  OFS=((md_pos-1)>0)*.5 & YY(ndind:ndind+n_md-1)= param(0:n_md-1)+OFS
				ENDIF   ELSE              YY(0    :ndind-1)     = param(n_md:n_md+ndind-1)

				IF par1(14) eq 0         THEN BEGIN		;*** DOPLER **
				  PP(2)=par1(2) & PP(3)=par1(7) & PP(4)=par1(8)
				  PP(5)=par1(0) & PP(6)=par1(1)
				  PTXT(2)='Average Doppler frequency       ' & PTXT(3)='Number of detectors             '
				  PTXT(4)='Number of monitors              ' & PTXT(5)='Duration of scan (seconds)      '
				  PTXT(6)='Counts in Monitor 1             '
				  XX=indgen(nb_chn)+1
				  ENDIF
				IF par1(14) eq 1         THEN BEGIN		;*** ELASTIC SCAN sample_t **
				  XX=WOU (0:nb_chn-1,nb_spc+nb_mon)/1000.
				  ENDIF
				IF par1(14) ge 2         THEN BEGIN		;*** ANGLE SCAN **
				  XX=WOU (0:nb_chn-1,nb_spc+nb_mon)/100.
				  ENDIF
				WOU =WOU (0:nb_chn-1,0:nb_spc-1)
				IF (nb_spc gt n_md)      THEN BEGIN
				  WOT =WOU
				  WOU (*,0:ndind-1)=WOT(*,n_md:n_md+ndind-1)	; Normal detectors
				  WOU (*,ndind:n_md+ndind-1)=WOT(*,0:n_md-1)	; Multi  detectors  
				  ENDIF
				if (INST(2) eq '0')      THEN BEGIN
				  OT     =OT + " Normalized"
				  moni   =round(total(NN(*,0)))/nb_chn & mona=moni/(NN(*,0)>1)
				  FOR  i =0,nb_spc-1 do WOU (*,i)=WOU (*,i)*mona
				  NN(*,0)=moni
				  ENDIF
				if (Helas)  THEN BEGIN ;par1(13)=1
				  OT = OT + " (Diff. on)"
				  PTXT(15) = 'Angle increment between detect. ' & PP(15)=par1(18)
				  PTXT(16) = 'Vert. angle wrt scattering plane' & PP(16)=par1(19)
				  PTXT=[PTXT,'Zero point (deg) of 1st det. Blk',$
				             'Zero point (deg) of 2nd det. Blk',$
				             'Zero point (deg) of 3rd det. Blk',$
				             'Zero point (deg) of 4th det. Blk',$
				             'Zero point (deg) of 5th det. Blk']
				  PP  =[PP  , par1(120),par1(121),par1(122),par1(123),par1(124)]
				  ENDIF
				YT='2-Theta (deg.)'
				CASE par1(14) of
				0:  BEGIN XT='Channels'                 & END
				1:  BEGIN XT='T/K'                      & END
				2:  BEGIN XT='Gamma-1 deg.'             & END
				3:  BEGIN XT='Gamma-2 deg.'             & END
				4:  BEGIN XT='THETA-S deg.'             & END
				5:  BEGIN XT='Sample Height'            & END
				6:  BEGIN XT='Theta-ANALYSER'           & END
				7:  BEGIN XT='2*Theta-ANALYSER'         & END
				8:  BEGIN XT='Theta-Monochromator deg.' & END
				9:  BEGIN XT='Gamma-Monochromator'      & END
				10: BEGIN XT='Theta-D1 deg.'            & END
				11: BEGIN XT='CD1'                      & END
				12: BEGIN XT='Theta-D2 deg.'            & END
				ELSE:
				ENDCASE
			
				IF n_elements(dzap) ne 1 THEN dzap=0 & if dzap eq 0 then Helas=0
				IF not Helas then WOUT=float(WOU) $	;*** INELASTIC **
				ELSE BEGIN			        ;*** MULTI DETECTOR **
				  sz  =size(WOUT)
				  XT  ='Angles' & YT='Counts'
				  a   =par1(18)
				  XX  =[findgen(32)*a+par1(120),findgen(32)*a+par1(121),findgen(32)*a+par1(122),$
				        findgen(32)*a+par1(123),findgen(32)*a+par1(124)]
				  IF  sz(0) ge 2 THEN BEGIN YT ='Scan set'
					YY=indgen(sz(2))+1 & ENDIF
				  PV  =WOU
				  WOUT=REVERSE(WOUT,1)
				ENDELSE
	                 ENDIF
	           END
     	   'in10': BEGIN
			mon =par1 (20)>1
			chn =par1 (23)
			spc =par1 (19)
			NN  =WOUT (0:chn-1,spc:spc+mon-1)
			YY  =param (0:spc-1)
			
				CASE par1(21) of
				0:  BEGIN XT='Channels'           & XX  =indgen(chn)+1                    & END ; DOPLER **
				1:  BEGIN XT='T/K'                & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ELASTIC SCAN **
				2:  BEGIN XT='T/K'                & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ELASTIC SCAN **
				3:  BEGIN XT='CHI_M  (deg.)'      & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ANGLE SCAN **
				4:  BEGIN XT='THETA_M2  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END ; ""
				5:  BEGIN XT='THETA_M1  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				6:  BEGIN XT='CHI_E1  (deg.)'     & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				7:  BEGIN XT='CHI_E2  (deg.)'     & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				8:  BEGIN XT='THETA_G  (deg.)'    & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				9:  BEGIN XT='CHI_G  (deg.)'      & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				10: BEGIN XT='2THETA_G  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				11: BEGIN XT='OMEGA_E1  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				12: BEGIN XT='OMEGA_E2  (deg.)'   & XX  =WOUT (0:chn-1,nb_spc-1)/par1(22) & END
				13: BEGIN XT='Spectrum number'    & XX  =WOUT (0:chn-1,nb_spc-1)/1000.0   & END ; Monochromator-T **
				ELSE:
				ENDCASE
				
			WOUT=FLOAT(WOUT (0:chn-1,0:spc-1))
			PTXT=['Type of scan (index)                 =' , 'Duration of scan (seconds)           =']
			
			IF par1(21) eq 0 then begin
			 PTXT=[ PTXT,$
			'Max. Doppler frequency (Hz)          =' , 'Min. Doppler frequency (Hz)          =', $
			'Chopper frequency (RPM)              =' , 'Lattice param. Monochromator (ang.)  =', $
			'Lattice param. Analyser      (ang.)  =' , 'Lattice param. Deflector     (ang.)  =', $
			'TOF Sample-Det. (microsec.)          =' , 'TOF Sample-M1   (microsec.)          =', $
			'TOF Sample-M2   (microsec.)          =' , 'T1              (microsec.)          =', $
			'T2              (microsec.)          =' , 'Number of detectors in use           =', $
			'Number of monitors  in use           =' , 'Channel limit                        =', $
			'Number of points in spectrum         =' , 'Scattering angle 1 (2*theta) (deg.)  =', $
			'Scattering angle 2 (2*theta) (deg.)  =' , 'Scattering angle 3 (2*theta) (deg.)  =', $
			'Scattering angle 4 (2*theta) (deg.)  =' , 'Scattering angle 5 (2*theta) (deg.)  =', $
			'Scattering angle 6 (2*theta) (deg.)  =' , 'Scattering angle 7 (2*theta) (deg.)  =', $
			'Scattering angle 8 (2*theta) (deg.)  =' , 'Deflector  angle Theta-g     (deg.)  =', $
			'Not used =' , 'Not used =' , 'Not used =' , 'Not used =' , 'Not used =']
			 PP=[ $
			 par1 (21),par1 (0 ),par1 (1 ),par1 (2 ),par1 (3 ),par1 (81),par1 (83),par1 (82), $
			 par1 (84),par1 (85),par1 (86),par1 (87),par1 (88),par1 (19),par1 (20),par1 (6 ), $
			 par1 (23),param(0 ),param(1 ),param(2 ),param(3 ),param(4 ),param(5 ),param(6 ), $
			 param(6 ),par1 (50),0. ,0. ,0. ,0. ,0. ]
			ENDIF
			
			IF (par1(21) ge 1) and (par1(21) le 12) then begin
			 PTXT=[ PTXT,$
			'Chopper frequency (RPM)              =' , 'Lattice param. Monochromator (ang.)  =', $
			'Lattice param. Analyser      (ang.)  =' , 'Lattice param. Deflector     (ang.)  =', $
			'TOF Sample-Det. (microsec.)          =' , 'TOF Sample-M1   (microsec.)          =', $
			'TOF Sample-M2   (microsec.)          =' , 'T1              (microsec.)          =', $
			'T2              (microsec.)          =' , 'Number of detectors in use           =', $
			'Number of monitors  in use           =' , 'Number of points in spectrum         =', $
			'Not used =' , 'Not used =' , 'Not used =' , 'Not used =' , 'Not used =']
			 PP=[ $
			 par1 (21),par1 (0 ),par1 (3 ),par1 (81),par1 (83),par1 (82),par1 (84),par1 (85), $
			 par1 (86),par1 (87),par1 (88),par1 (19),par1 (20),par1 (23),0. ,0. ,0. ,0. ,0. ]
			ENDIF
			
			IF par1(21) eq 13 then begin
			 PTXT=[ PTXT,$
			'Chopper frequency (RPM)              =' , 'Monochromator coeff. A0              =', $
			'Monochromator coeff. A1              =' , 'Monochromator coeff. A2              =', $
			'Monochromator coeff. A3              =' , 'Monochromator coeff. B0              =', $
			'Monochromator coeff. B1              =' , 'Monochromator coeff. B2              =', $
			'Monochromator coeff. B3              =' , 'Coeff. transition  temperature (K)   =', $
			'Max. monochromator temperature (K)   =' , 'Lattice param. Analyser      (ang.)  =', $
			'Lattice param. Deflector     (ang.)  =' , 'TOF Sample-Det. (microsec.)          =', $
			'TOF Sample-M1   (microsec.)          =' , 'TOF Sample-M2   (microsec.)          =', $
			'T1              (microsec.)          =' , 'T2              (microsec.)          =', $
			'Number of detectors in use           =' , 'Number of monitors  in use           =', $
			'Number of points in spectrum         =' , 'Scattering angle 1 (2*theta) (deg.)  =', $
			'Scattering angle 2 (2*theta) (deg.)  =' , 'Scattering angle 3 (2*theta) (deg.)  =', $
			'Scattering angle 4 (2*theta) (deg.)  =' , 'Scattering angle 5 (2*theta) (deg.)  =', $
			'Scattering angle 6 (2*theta) (deg.)  =' , 'Scattering angle 7 (2*theta) (deg.)  =', $
			'Scattering angle 8 (2*theta) (deg.)  =' ]
       			 PP=[ $
			 par1 (21),par1 (0 ),par1 (3 ),par1 (66),par1 (67),par1 (68),par1 (69),par1 (70), $
			 par1 (71),par1 (72),par1 (73),par1 (74),par1 (75),par1 (83),par1 (82),par1 (84), $
			 par1 (85),par1 (86),par1 (87),par1 (88),par1 (19),par1 (20),par1 (23),param(0 ), $
			 param(1 ),param(2 ),param(3 ),param(4 ),param(5 ),param(6 ),param(7 )]
			ENDIF
			if (INST(2) eq '0')  THEN BEGIN
				OT     =OT + " Normalized"
				moni   =round(total(NN(*,0))/chn) & mona=moni/(NN(*,0)>1)
				FOR  i =0,spc-1 do WOUT (*,i)=WOUT (*,i)*mona
				NN(*,0)=moni
				ENDIF
	           END
     	   'in4':  BEGIN an=strmid(DATE,6,3) & if strpos(an,'-') eq 0 then an=strmid(an,1,2)
	   		if (an gt '75') and (an lt '91') then off=2 else off=16
			NN  =      WOUT(0:nb_chn-2,0:1)
			WOUT=FLOAT(WOUT(0:nb_chn-2,off:nb_spc-1))
			XX  =indgen(nb_chn-1)+1
			YY  =par1  (31+off:31+nb_spc-1)
			PTXT=[ $
			'Run duration (seconds)             =' , 'Time in 0.1 seconds                =', $
			'Number of reserved channels        =' , 'Counts in M1                       =', $
			'Counts in M2                       =' , 'Not used                           =', $
			'Total counts                       =' , 'Not used                           =', $
			'Sample angle (deg.)                =' , 'Elastic peak position (channel)    =', $
			'Numor                              =' , 'Sample temperature (K)             =', $
			'Digital Voltmeter Reading          =' , 'Repetition period (microsec.)      =', $
			'Multiplier for repetition period   =' , 'Not used                           =', $
			'Not used                           =' , 'Not used                           =', $
			'Channel width (microsec.)          =' , 'Number of channels used            =', $
			'TOF delay (microsec.)              =' , 'Wavelength (angstroms)             =', $
			'Distance CH4 - M1     (meter)      =' , 'Distance CH4 - Sample (meter)      =', $
			'Not used                           =' , 'Distance M1  - M2     (meter)      =', $
			'Not used                           =' , 'Distance Det - Sample (meter)      =', $
			'Contents scaler 1                  =' , 'Contents scaler 2                  =', $
			'Number of angles                   =' ]
       			 PP=[ $
			 par1 (2 ),par1 (5 ),param(1 ),par1 (3 ),par1 (4 ),  0.     ,par1 (7 ),  0.     , $
			 par1 (17),param(8 ),param(9 ),param(10),par1 (15),param(12),param(13),  0.     , $
			   0.     ,   0.    ,param(17),nb_chn-1 ,param(19),param(20),param(21),param(22), $
			   0.     ,param(24),   0.    ,param(26),par1 (0 ),par1 (1 ),nb_spc-off]
			   
			if (INST(2) eq '0') THEN begin	P_DID_CALDO, insv,WOUT,YY,ok
							if ok then begin  XT=XT+' pre-Calibrated'
								monu= 500000.
								tot = monu/total(NN(*,0))
								WOUT= WOUT*tot
								NN(*,0) =0 & NN(0,0)=monu & endif & endif
	           END
     	   'in5':  BEGIN off=8
	   		IF n_elements(par2) eq 0 then begin par2=par1 & par1=param & off=6 & endif
			NN  =      WOUT(0:nb_chn-2,0:2)
			WOUT=FLOAT(WOUT(0:nb_chn-2,off:nb_spc-1))
			XX  =indgen(nb_chn-1)+1
			YY  =par2  (31+off:31+nb_spc-1)
			PTXT=[ $
			'Run duration (seconds)             =' , 'Time in 0.1 seconds                =', $
			'Number of reserved channels        =' , 'Counts in M1                       =', $
			'Counts in M2                       =' , 'Counts in M3                       =', $
			'Total counts                       =' , 'Not used                           =', $
			'Sample angle (deg.)                =' , 'Elastic peak position (channel)    =', $
			'Numor                              =' , 'Sample temperature (K)             =', $
			'Digital Voltmeter Reading          =' , 'Repetition period (microsec.)      =', $
			'Multiplier for repetition period   =' , 'Not used                           =', $
			'Not used                           =' , 'Not used                           =', $
			'Channel width (microsec.)          =' , 'Number of channels used            =', $
			'TOF delay (microsec.)              =' , 'Wavelength (angstroms)             =', $
			'Distance CH4 - M1     (meter)      =' , 'Distance CH4 - Sample (meter)      =', $
			'Not used                           =' , 'Distance M1  - M2     (meter)      =', $
			'Distance M1  - M3     (meter)      =' , 'Distance Det - Sample (meter)      =', $
			'Contents scaler 1                  =' , 'Contents scaler 2                  =', $
			'Number of angles                   =' ]
       			 PP=[ $
			 par2 (2 ),par2 (5 ),par1 (1 ),par2 (3 ),par2 (4 ),par2 (6 ),par2 (7 ),  0.     , $
			 par2 (17),par1 (8 ),par1 (9 ),par1 (10),par2 (15),par1 (12),par1 (13),  0.     , $
			   0.     ,   0.    ,par1 (17),nb_chn-1 ,par1 (19),par1 (20),par1 (21),par1 (22), $
			   0.     ,par1 (24),par1 (25),par1 (26),par2 (0 ),par2 (1 ),nb_spc-off]
			   
			if (INST(2) eq '0') THEN begin	P_DID_CALDO, insv,WOUT,YY,ok
							if ok then begin  XT=XT+' pre-Calibrated'
								monu= 500000.
								tot = monu/total(NN(*,0))
								WOUT= WOUT*tot
								NN(*,0) =0 & NN(0,0)=monu & endif & endif
	           END
     	   'in6':  BEGIN if nb_spc gt 300 then begin off=3  & mom=3
	                            endif else begin off=21 & mom=4 & endelse
			 if nb_spc lt 100 then off=6
			NN  =      WOUT(0:nb_chn-2,0:mom-1)
			WOUT=FLOAT(WOUT(0:nb_chn-2,off:nb_spc-1))
			XX  =indgen(nb_chn-1)+1
			YY  =par1  (31+off:31+nb_spc-1)
			PTXT=[ $
			'Run duration (seconds)             =' , 'Time in 0.1 seconds                =', $
			'Number of reserved channels        =' , 'Counts in M1                       =', $
			'Counts in M2                       =' , 'Counts in M3                       =', $
			'Total counts                       =' , 'Not used                           =', $
			'Sample angle (deg.)                =' , 'Elastic peak position (channel)    =', $
			'Numor                              =' , 'Sample temperature (K)             =', $
			'Digital Voltmeter Reading          =' , 'Repetition period (microsec.)      =', $
			'Multiplier for repetition period   =' , 'Not used                           =', $
			'Not used                           =' , 'Not used                           =', $
			'Channel width (microsec.)          =' , 'Number of channels used            =', $
			'TOF delay (microsec.)              =' , 'Wavelength (angstroms)             =', $
			'Distance CH4 - M1     (meter)      =' , 'Distance CH4 - Sample (meter)      =', $
			'Not used                           =' , 'Distance M1  - M2     (meter)      =', $
			'Distance M1  - M3     (meter)      =' , 'Distance Det - Sample (meter)      =', $
			'Contents scaler 1                  =' , 'Contents scaler 2                  =', $
			'Number of angles                   =' ]
       			 PP=[ $
			 par1 (2 ),par1 (5 ),param(1 ),par1 (3 ),par1 (4 ),par1 (6 ),par1 (7 ),  0.     , $
			 par1 (17),param(8 ),param(9 ),param(10),par1 (15),param(12),param(13),  0.     , $
			   0.     ,   0.    ,param(17),nb_chn-1 ,param(19),param(20),param(21),param(22), $
			   0.     ,param(24),param(25),param(26),par1 (0 ),par1 (1 ),nb_spc-off]
			   
			if (INST(2) eq '0') THEN begin	P_DID_CALDO, insv,WOUT,YY,ok
							if ok then begin  XT=XT+' pre-Calibrated'
								GROUPY,WOUT ,YY ,/average
								monu= 500000.
								tot = monu/total(NN(*,0))
								WOUT= WOUT*tot
								NN(*,0) =0 & NN(0,0)=monu & endif & endif
	           END
     	   'in13': BEGIN wavel=2.23
		    IF (size(WOUT))(2) eq 74 THEN BEGIN  nd=70
			  ;inelastic scan old format
			  ;*************************
			  IF n_elements(cal_in13) eq 0 THEN $
			     P_DID_CALOD, insv,insv+'.cal', flg
			  YY=[round(param(0 :34)*100)/100.      ,.1,.2,$
			      round(param(0 :34)*100)/100.+0.001,.3,.4]
			  sx=(size(WOUT))(1)
			  NN=lonarr(sx,3)
			  NN(*,1)=WOUT(*,36)>1 & NN(*,2)=WOUT(*,73)>1
			  WOUT=float(WOUT)
			  FOR i=0 ,34 do WOUT(*,i)=WOUT(*,i)/NN(*,1)
			  FOR i=37,71 do WOUT(*,i)=WOUT(*,i)/NN(*,2)
			  NN(*,0)=round(total(NN)/sx)

			  idx =sort(YY) & WOUT=WOUT(*,idx) & YY=YY(idx)
					  WOUT=WOUT(*,4:*) & YY=YY(4:*)
			  WOUT=WOUT*NN(0,0)
			  IF n_elements(cal_in13) eq nd THEN BEGIN
				FOR i=0,nd-1 DO wout(0,i)=wout(*,i)/cal_in13(i)
				OT=OT+' /'+inf_in13(0)
			  ENDIF
			  XX  =findgen (sx)*par1(11)+par1(1)-par1(2)
			  YY  =4*!pi/wavel*sin(YY/2*!pi/180.)
           		  XT  ='Energy micro eV   (normalized)'
           		  YT  ='Q(0) pairs'
			  IF par1(8) gt 0 THEN BEGIN ZZ=(par1(9)+par1(10))/2
						     ZT='Temperature' & ENDIF
		    ENDIF ELSE $
		    IF (par1(8) eq 1 or par1(8) eq 2)  THEN BEGIN  nd=par1(7)-2 & sx=(size(WOUT))(1)
			  ;inelastic scan
			  ;**************
			  IF n_elements(cal_in13) eq 0 THEN $
			     P_DID_CALOD, insv,insv+'.cal', flg
			  YY  =round(param(0 :nd-1)*100)/100.
			  WOUT=float(WOUT)
			  XX  =WOUT(*,nd+2) & XI=(XX(1)-XX(0))/2
			  XX  =(XX+Xi)/100.
			  if XI lt 0 then BEGIN
				XX=REVERSE(XX) & WOUT=REVERSE(WOUT,1)
			  ENDIF
		     	  NN  =WOUT(*,nd)>1
			  WOUT=WOUT(*,0 :nd-1)
			  idx =sort(YY) & WOUT=WOUT(*,idx) & YY=YY(idx)
			  if (INST(2) eq '0') then BEGIN
			  	OT   =OT + " Normalized"
				moni =round(total(NN)/sx) & mona=moni/(NN>1)
				FOR i=0,nd-1 do WOUT(*,i)=WOUT(*,i)*mona
				NN(*)=moni
			  ENDIF
		    ENDIF ELSE $
		    IF (scan    eq 1)  THEN BEGIN
			  ;elastic scan old format
			  ;***********************
		          nd=35 & sx=1
		     	  NN  =WOUT(36)
			  WOUT=float(WOUT(0:34))
			  XX  =round(param(0 :34)*100)/100.
			  idx =sort(XX) & XX  =XX(idx) & WOUT=WOUT(idx)
			  XX  =4*!pi/wavel*sin(XX/2*!pi/180.)
           		  XT  ='Q(0)'
			  YY=(par1(9)+par1(10))/2
			  YT  ='Counts'
		    ENDIF ELSE $
		    IF (par1(8) eq 0)  THEN BEGIN  nd=par1(7)-2 & sx=(size(WOUT))(1)
			  ;elastic scan
			  ;************
		     	  NN  =WOUT(*,nd)
			  YY  =WOUT(*,nd+3)/100.
			  WOUT=float(WOUT(*,0:nd-1))
			  WOUT=reform(TRANSPOSE(WOUT))
			  if (sx gt 1) and (INST(2) eq '0') then BEGIN
			  	OT   =OT + " corrected"
				moni =total(NN)/sx
				FOR i=0,sx-1 do WOUT(*,i)=WOUT(*,i)*moni/NN(i)
				NN   =moni
			  ENDIF
			  XX  =round(param(0 :nd-1)*100)/100.
			  idx =sort(XX) & XX  =XX(idx) & WOUT=WOUT(idx,*)
			  XX  =4*!pi/wavel*sin(XX/2*!pi/180.)
           		  XT  ='Q(0)'
			  YT  ='Counts'
		    ENDIF
		    IF nd gt 0 THEN BEGIN
			  EE  =sqrt(WOUT)
			  PP  =[par1(8),par1(0),par1(3),par1(1),par1(2),par1(11),wavel]
			  PTXT=['Type  of scan      (index)   ','Duration of scan   (second)  ',$
				'Chopper frequency            ','Energy   center    (micro eV)',$
				'Energy half range  (micro eV)','Channel  width     (micro eV)',$
				'Wave length        (angstrom)']
		    ENDIF
		  END
	   else:
	   ENDCASE
	   END
   'lss':  BEGIN
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
	   ZZ  = param(64)
	   NN  = param(4)
	   PP  = [0.0] & PTXT= [" "]
	   
	   dim= LONG(SQRT(n_elements(WOUT)))
	   IF dim*dim  eq n_elements(WOUT) then BEGIN
	   	WOUT=reform(WOUT,dim,dim,/overwrite)
	   	WOUT=float(WOUT)
	   	sw=size(WOUT)
		XX  = INDGEN(sw(1))
		YY  = INDGEN(sw(2))
		XT  ='X detector'
		YT  ='Y detector'
		ZT  ='Sample Angle'

	     PP=[param(0) ,param(1) ,param(2) ,param(3) ,param(14),param(15),param(16),param(17),param(18),$
	         param(25),param(30),param(32),param(33),param(50),param(51),param(52),param(53),param(57),$
		 param(60),param(61),param(62),param(63),param(64),param(65),param(66),param(80),numor,0,0,0,0]

	     PTXT=['PRESET 1                             ','PRESET 2                             ',$
		   'Run duration (1/10 sec.)             ',$
		   'Total detector counts                ','Detector offset angle (deg.)         ',$
		   'Coder 1: By (mm)                     ','Coder 2: Bx (mm)                     ',$
		   'Coder 3: Sample changer transl. (mm) ','Coder 4: Detector distance (set) (m) ',$
		   'Sample-Detector distance (calc.) (m) ','Sample Temperature (K)               ',$
		   'Value of IEEE-1 at start             ','Value of IEEE-1 at end               ',$
		   'Beam centre adress X0 (mm)           ','Beam centre adress Y0 (mm)           ',$
		   'Wavelength (angstroms)               ','Wavelength resolution                ',$
		   'Collimation  (m)                     ','Detector angle (set) (deg.)          ',$
		   'Detector translation (set) (mm)      ','Selector angle (deg.)                ',$
		   'Sample distance (mm)                 ','Sample rotation (deg.)               ',$
		   'Changer position                     ','Sample height (mm)                   ',$
		   'Shear speed (1/min.)                 ','Numor                                ',$
		   'Not used  ', 'Not used  ','Not used  ','Not used  ']
	   ENDIF
	   CASE insv of

           'd17': if nvers gt 0 then BEGIN
		   rdid_d17,INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                    WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE
		   WOUT=reform(WOUT)
		  ENDIF
	   'd22':
	   'd11': BEGIN PTXT(2) ='Run duration (sec.)                  '
			PTXT(21)='Sample distance (mm)                 '
			PTXT(22)='Sample rotation (deg.)               ' & WOUT(0,0)=1 & END
	   'd11tof': BEGIN
			WOUT=reform(WOUT,n_elements(WOUT),/overwrite)
			XT='T.O.F.' & YT='Counts' & XX=INDGEN(n_elements(WOUT))+1 & YY=0
			PP(*)=0.    & PTXT(*)='Not used  '  & END
	   else:
	   ENDCASE

	   END

   'test': BEGIN nd =0
   	   text=text(0) & expar=exper(0)
	   DATE=strmid(text,14,9)
   	   WT  =	    strmid(text,4,10) +'  '+strcompress(strmid(expar,0 ,69))$
   	  				      + ' '+strcompress(strmid(expar,70,79))
     	   OT  =insv +' Date '+ DATE +' Time '     +strmid(text,24,8)$
     	  			     +' User '     +strmid(text,4,10)  +' Run ' + FILENAME
           XT  ='OMEGA'
           YT  ='Counts'
	   ZT  ='Numor' & ZZ=numor

     	   CASE insv of
     	   't13a':BEGIN nd =n_elements(WOUT)/2
	   	  WOUT =reform(WOUT,2,nd)
		  XX   =reform(WOUT(0,*))
		  WOUT =reform(WOUT(1,*))
		  END
     	   't13c':BEGIN nd =n_elements(WOUT)/2
	   	  WOUT =reform(WOUT,2,nd)
		  XX   =reform(WOUT(0,*))
		  WOUT =reform(WOUT(1,*))
		  END
 	   else:
	   ENDCASE
	   END
		
   'lon':  BEGIN
           CASE insv OF
	   't3':BEGIN
			add = 1
			IF (STRMID(exper(2),0,3) EQ 'End') THEN add = 0 
	   		text = text(0)
	   		DATE = STRMID(text,14,18)
			i = STRPOS(exper(3),' ')
	   		XT = STRMID(exper(3),0,i)
			YT = 'Phase'
			ZT = 'Counts'
			OT = STRTRIM(text,2)
			IF (add EQ 0 AND STRPOS(exper(5),' ') EQ 0) THEN $
				bl = 1 ELSE bl = 0
			i = STRPOS(exper(8 + add + bl),',')
			jj = STRPOS(exper(7 + add  + bl),':')
			kk = RSTRPOS(exper(7 + add + bl),' ')
			WT = STRMID(exper(8 + add + bl),8,i-8)+STRMID(exper(7 + add + bl),jj+1,kk-jj)
                        WT = STRTRIM(WT,2)
			READS, STRMID(exper(5 + add + bl),13,3), nd
			nphases = (cnt/nd) - 3 - add
			WOUT = REFORM(WOUT,nphases + 3 + add,nd)
			WOUT = TRANSPOSE(WOUT)
			XX = WOUT(*,0+add)
			NN = WOUT(*,1+add:2+add)
			CASE nphases OF
			1: BEGIN
				WOUT = WOUT(*,3+add)
				YY = 0
			   END
			2: BEGIN
				WOUT = WOUT(*,3+add:4+add)
				YY = INDGEN(2)
			   END
			ENDCASE
			READS, STRMID(exper(4 + add),STRPOS(exper(4 + add),':')+1,5), b1
			READS, STRMID(exper(4 + add),RSTRPOS(exper(4 + add),':')+1,5), b2
			READS, STRMID(exper(8 + add + bl),RSTRPOS(exper(8 + add + bl),':')+1,5), lam
			i = RSTRPOS(exper(6 + add + bl),'=')
			READS, STRMID(exper(6 + add + bl),i+1,10), dbc1
			i = RSTRPOS(exper(6 + add + bl),',')
			READS, STRMID(exper(6 + add + bl),i+1,10), dbc2
			PP = [LONG(numor),lam,b1,b2,dbc1,dbc2]
			PTXT = ['0) Numor:                    ',$
				'1) Lambda:                   ',$
				'2) Flipper Current:          ',$
				'3) Correction Current:       ',$
				'4) Direct Beam (Cts/Sec):    ',$
				'5) Direct Beam (CtsMon/Sec): ']
		END
	   ENDCASE
	   END
   else:
   ENDCASE

   DATP={w_tit:WT ,x_tit:XT ,y_tit:YT ,z_tit:ZT ,other_tit:OT ,time:DATE,p:PP,par_txt:PTXT,$
         x:XX     ,y:YY     ,z:ZZ     ,n:NN     ,pv:PV        ,e:EE}
   
ENDIF ELSE begin print,!err_string, string(7b)
   ssz=SIZE(WOUT)
   if ssz(0) ge 1 then XX=indgen(ssz(1))+1 else XX=0
   if ssz(0) ge 2 then YY=indgen(ssz(2))+1 else YY=0
   DATP={x:XX ,y:YY}
ENDELSE

RETURN, WOUT
END
function tee,in_wk
;
;converts array w_in  to energy in w_out.....GJK 1994
;
;Example call: w2=t2e(w1)
;         convert tof spectrum in w1 to energy and output in w2

;
; Sets up and copies work-space stuff into simple arrays
@lamp.cbk
      nwk=''
      x=0.0
      y=0.0
      w=0.0
      if one ne 0 then out_wk=one
      if two ne 0 then begin
        n_wk=strtrim(string(two),2)
        iii=execute('w_in = w' +n_wk)      
        iii=execute('n_in = n' +n_wk)
        iii=execute('pv_in= pv'+n_wk)       
        iii=execute('p_in = p' +n_wk)       
        iii=execute('x_in = x' +n_wk)
        iii=execute('y_in = y' +n_wk)
        iii=execute('z_in = z' +n_wk)
        iii=execute('e_in = e' +n_wk)
        
;       set defaults            
        n_out =n_in
        p_out =p_in
        pv_out=pv_in
        x_out =x_in
        y_out =y_in
        z_out =z_in
        e_out =e_in
        endif
;
;done @mac.in

my_check=size(in_wk)

  if my_check(0) lt 1 then  begin
     P_MUS,'mus_cannon'
     mess='Workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
   endif

  if strpos(his(two),'t2e') gt 0 then begin
     P_MUS,'mus_cannon'
     mess='Workspace already in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
  endif

  P_MUS,'mus_shot'
  nch=my_check(1)
  if my_check(0) gt 1 then nang=my_check(2) else nang=1
;
; stof or bs
  if (inst_value eq 'IN10') or (inst_value eq 'IN16') then begin
       x_in     = INDGEN(nch)+1
       t2efac   = 3.868212/p_in(7) ;p_in(7)=monochromator d-spacing (1.234)
       if (inst_value eq 'IN16') then t2efac= 3.296138/p_in(7) ;(1.036)
  x_out=x_in*2.0*t2efac*p_in(2)/max(x_in)
  x_out=x_out-0.5*max(x_out)

  x_tit(one)='Energy Transfer (ueV)'
; Copies work-space stuff from simple arrays back to main LAMP arrays
      n_wk=string(out_wk)
      n_wk=strtrim(n_wk,2)

      jjj=execute('p' +n_wk+'=p_out' )
      jjj=execute('pv'+n_wk+'=pv_out')
      jjj=execute('x' +n_wk+'=x_out' )
      jjj=execute('y' +n_wk+'=y_out' )
      jjj=execute('z' +n_wk+'=z_out' )
      jjj=execute('e' +n_wk+'=e_out' )
;
;done @mac.out
return,in_wk
  endif

  	coef=fltarr(nch)
	x_out=fltarr(nch)
        w_out=fltarr(nch,nang)
        w_buf=fltarr(nch,nang)
	if n_elements(e_in)  ne n_elements(w_in) then e_out=0
	if n_elements(e_out) gt 1 then e_buf=w_buf
;
	y_out=y_in

  ;
; Convert to Energy
	eelast=81.799/p_in(21)^2                  ; Ei in meV
	telast=p_in(27)*p_in(21)/3956.0           ; TOF in sec
	cwidth=p_in(18)*1e-6                      ;chw in sec
        epp=p_in(9)

  ;
; Any channels to shift?
        norg=nch
        nxtra=0
        elimit=1000.0
        tlimit=p_in(27)*sqrt(81.8/elimit)/3956.0
        for j=0,nch-1 do begin
         time_diff=(p_in(9)-j)*cwidth        
         flt_time=telast-time_diff
         if flt_time le tlimit then begin
          epp=epp-1
          w_buf(nxtra,*)=in_wk(j,*)
	  if n_elements(e_out) gt 1 then e_buf(nxtra,*)=e_in(j,*)
          nxtra=nxtra+1
          norg=norg-1
         endif
        endfor

        if nxtra gt 0 then begin
           w_out(0:norg-1,*)  =in_wk(nxtra:nch-1,*)
           w_out(norg:nch-1,*)=w_buf(0:nxtra-1,*)
	  if n_elements(e_out) gt 1  then begin
           e_out(0:norg-1,*)  =e_in (nxtra:nch-1,*)
           e_out(norg:nch-1,*)=e_buf(0:nxtra-1,*)
	  endif
        endif
        if nxtra le 0 then w_out=in_wk

  
        bodge=1.0e6/telast
	for j=0,nch-1 do begin
	    time_diff=(epp-j)*cwidth
	    flt_time=telast-time_diff
	    lam=flt_time*3956.0/p_in(27)
	    x_out(j)=eelast-(81.8/lam^2)
	    w_out(j,*)=w_out(j,*)*flt_time^4*bodge
	    if n_elements(e_out) gt 1 then e_out(j,*)=e_out(j,*)*flt_time^4*bodge
	    endfor
	p_out=p_in
	x_tit(one)='Energy Transfer (meV)'
; Copies work-space stuff from simple arrays back to main LAMP arrays
      n_wk=string(out_wk)
      n_wk=strtrim(n_wk,2)

      jjj=execute('p' +n_wk+'=p_out' )
      jjj=execute('pv'+n_wk+'=pv_out')
      jjj=execute('x' +n_wk+'=x_out' )
      jjj=execute('y' +n_wk+'=y_out' )
      jjj=execute('z' +n_wk+'=z_out' )
      jjj=execute('e' +n_wk+'=e_out' )
;
;done @mac.out
	return,w_out
	end
function biny, win ,by
;******* ****
;**
;** Group ordinates by by (DR 2001)
;** CALL: Wi=biny(wj [,2])

dim =SIZE(win)

IF dim(0) eq 2 THEN IF dim(2) GE 4 THEN BEGIN

	IF n_elements(by) ne 1 THEN by=2
	by=by>2<(dim(2)/2)

	wout =FLTARR( dim(1) ,dim(2)/by )
	yout =FLTARR( dim(2)/by)

;	Take all parameters
;	**** *** **********
	TAKE_DATP,P
	r=0
	IF n_elements(P.e) eq n_elements(win) THEN BEGIN
		r=1 & P.e=P.e^2 & eout=wout & ENDIF

	FOR i=0,dim(2)/by-1 DO BEGIN
	    j=i*by
	    wout(*,i)= total(win(*,j:j+by-1),2)/by
	    yout(i)  = total(P.Y(  j:j+by-1)  )/by
	    IF r  THEN eout (*,i)= total(P.e(*,j:j+by-1),2)
	ENDFOR
	
;	Give back parameters
;	**** **** **********
	P.Y_TIT  =P.Y_TIT+' (binY*'+strtrim(string(by),2)+')'
	MOD_DATP ,P,'Y',yout	;P.Y=yout is the normal formulation but it
				;d'nt work (because the size changed)

	IF r THEN MOD_DATP ,P,'E',SQRT(eout)/by

	GIVE_DATP,P		;Give back

	RETURN,wout
ENDIF

P_MUS ,'mus_cannon'
RETURN, win
END

pro DialCommons
;** ***********
;**
@lamp.cbk
common c_geo, geo_stat, geo_w  , geo_vis, geo_alp, geo_freq, geo_isw, geo_onbas,$
              geo_bxy , geo_cur, geo_ran, geo_seq, geo_info, geo_lim, geo_timon,$
              geo_par2, geo_lead,geo_act

common c_geweb, geo_web,gew_act, gew_pth, gew_snd, gew_err, gew_pwd, gew_r,gew_g,gew_b,gew_v
end

function N2S, number
;******* ***
;**
return, strtrim(string(number),2)
end

function DialNameToNumber, name, find=find
;******* ****************
;**
;** Given the name of a dial, return its number
;** If keyword_set find then  return a free number if no name match

common dialshare2
common c_geo

named=strupcase(name) & nome=''
N=0   & Pn=(size(geo_w))(2)-1
k=1   & while k le Pn do begin di=strtrim(string(k),2)
		    ii=execute ('if n_tags(d'+di+') gt 1 then nome=d'+di+'.NAME')
		    if strupcase(nome) eq named then begin N=k & k=Pn & endif & k=k+1
        endwhile

if N eq 0 then if keyword_set(find) then begin
			k=1 & while k le Pn do begin di=strtrim(string(k),2)
			      ii=execute ('if n_tags(d'+di+') le 1 then N=k')
			      ii=execute ('if n_tags(d'+di+') gt 1 then if d'+di+'.NAME eq "" then N=k')
			      if N gt 0 then   k=Pn & k=k+1
				endwhile
			if N eq 0 then $
			k=1 & while k le Pn do begin di=strtrim(string(k),2) & onoff=1
			      ii=execute ('if (n_tags(d'+di+') gt 1) then onoff=d'+di+'.ONOFF')
			      if onoff ne 1 then begin N=k & k=Pn & endif & k=k+1
				endwhile
			endif
return,N
end

;******* **************************************************************************
;******* **************************************************************************
;******* **************************************************************************
pro DialTag, name, d=dnum, TAG=tag, SET=setv, GET=getv
;** *******
;**
;** Set or Get the tag value of named dial
common c_geo
common dialshare2
	getv=0
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then if n_elements(tag) eq 1 then begin
	   if n_elements(setv) gt 0 then begin
	      if strupcase(tag) eq "ONOFF"   then if setv gt 0 then DialStart, d=dnum $
	                                                       else DialStop , d=dnum else $
	      if strupcase(tag) eq "HISTORY" then DialHistory, d=dnum ,ONOFF=setv     else $
	      if strupcase(tag) eq "VALUE"   then DialModValue,d=dnum ,      setv     else $
	      if strupcase(tag) eq "ERROR"   then DialModValue,d=dnum ,      setv, tag='ERROR' $
		  else DialModValue,d=dnum ,      setv, tag=strupcase(tag)
	     ;else    ii=execute('d'+strtrim(string(dnum),2)+'.'+tag+'=setv')

	   endif else ii=execute('getv=d'+strtrim(string(dnum),2)+'.'+tag)
	endif else if n_elements(setv) eq 0 then ii=execute('getv=d'+strtrim(string(dnum),2))  $
	                                    else ii=execute('d'+strtrim(string(dnum),2)+'=setv')
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialsFrequency, GET=getv, SET=setv, STOP=stop, START=start, DURATION=lim, SENS=sens
;** **************
;**
;** Settings of the Timer

common c_geo
	if n_elements(setv) eq 1 then begin
	   on_ioerror,miset & geo_freq=setv & v=strtrim(string(setv),2)
	   if geo_onbas(0) gt 0 then widget_control,geo_onbas(0),bad_id=ii,set_value=v
	   miset:
	endif
	if n_elements(lim)  eq 1 then begin
	   on_ioerror,mislm & geo_lim =lim  & v=strtrim(string(lim),2) & if lim le 0 then v=" "
	   if geo_onbas(2) gt 0 then widget_control,geo_onbas(2),bad_id=ii,set_value=v
	   mislm:
	endif
	if keyword_set(stop)  then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=0
	   geo_stat=0 & geo_w(8,*)=0 & endif
	if keyword_set(start) then begin
	   if geo_onbas(1) gt 0 then widget_control,geo_onbas(1),bad_id=ii,set_button=1
	   geo_stat=1 & geo_timon(0)=systime(1)*1000 & P_GEO_TIMER, {id:geo_onbas(3)}
	   geo_w(8,*)=0 & endif

	if keyword_set(sens)  then if geo_stat  then   P_GEO_TIMER, {id:geo_onbas(3)}

	getv=geo_freq
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialNewValue, tope, NAME=name, d=dnum, SETVALUE=setvalue, COMMENT=ctxt, TYPE=tipe
;******* ************
;**
;** Get next value of the named dial by calling dial_"generic"_read interface function
;** (called from dial_macros)

common dialshare2
common c_lamp_par
common c_geo
val='0'
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if n_elements(ctxt) eq 0 then ctxt=""
	if n_elements(tope) eq 1 then if n_elements(tipe) ne 1 then tipe=tope

	 di=strtrim(string(dnum),2)

	   P_GEO_STATUS, dnum, "Get"

	   generic='' & nome='' & prox=-1
	   if n_elements(tipe) eq 1 then nome=tipe else $
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('generic=d' +di+'.GENERIC')
	   ii=execute('prox   =d' +di+'.PROX')
	   now=systime(1)
	   val=3.14

	   if generic eq 'lamp' then begin val=' '
	      CASE strlowcase(nome) of
	      'flagus':	val=0
	      'status':	val='Idle'
	      'log':	DID_WRITE_JOURNAL, val
	      ELSE:
	      ENDCASE
	   endif else $
	   if prox(0) ge 0 then begin par1=nome & par2=now     & par3=ctxt & par4=val
	                              COMMCA, proxcod ,prox    & val =par4 ; GET THE VALUE !!!!!!!!!!!!
	   endif else begin
	    ii=execute('val=dial_'+generic+'_read(nome, now, ctxt)')       ; GET THE VALUE !!!!!!!!!!!!
	    if not ii then begin val='0' & DialErrMes & DialStop & endif
	   endelse

	   geo_w(9,dnum)=geo_w(9,dnum)+((systime(1)-now)*1000)
	   sv=SIZE(val)
	   if sv(sv(0)+1) eq 4 then if val(0) eq 3.14 then P_GEO_STATUS, dnum, "GetNone" $
	                                              else P_GEO_STATUS, dnum, "GetOk"   $
	                                              else P_GEO_STATUS, dnum, "GetOk"

	   if keyword_set(setvalue) then DialModValue, val, d=dnum
return, val
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialModValue, val, NAME=name, d=dnum ,tag=TAG
;** ************
;**
;** Used when dial.VALUE changes its type or dimension

common dialshare2
common c_geo

    if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
    if n_elements(dnum) ne 1 then dnum=geo_cur
    if dnum gt 0 then begin
      di=strtrim(string(dnum),2)
      sv=SIZE   (val)
      if n_elements(TAG) ne 1 then TAG='VALUE' else TAG=strupcase(TAG)
      sz=[0,0,0] & ii=execute('sz=SIZE(d'+di+'.'+TAG+')')
      if (sz(sz(0)+1) ne sv(sv(0)+1)) or (sz(sz(0)+1) eq 8) or  $
         (sz(0) ne sv(0)) or (sz(sz(0)+2) ne sv(sv(0)+2)) then begin
	 elsa = ''
	 tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
	 for k=0,n_elements(tlist)-1 do begin
          CASE tlist(k) of
           TAG:
           ELSE:      elsa =elsa+','+tlist(k)+':d'+di+'.'+tlist(k)
          ENDCASE
	 endfor
                 ii=execute('d'+di+'={'+TAG+':val'+ elsa +'}')
      endif else ii=execute('d'+di+'.' +TAG+'=val')
    endif
end

pro DialMix, A,B
;** *******
;**
;** Mixe Dial B into Dial A

    nA=n_tags(A)  & nB=n_tags(B)
    if nB lt 1 then return
    if nA lt 1 then begin A=B  & return & endif
    elsa=''
    lA=strupcase(tag_names(A))
    for k=0,nA-2 do  elsa =elsa    + lA(k)   +':A.'+lA(k)+','
                     elsa =elsa    + lA(nA-1)+':A.'+lA(nA-1)
    lB=strupcase(tag_names(B))
    for k=0,nB-1 do  if (where(lA eq lB(k)))(0) eq -1 then $
                     elsa =elsa+','+ lB(k)   +':B.'+lB(k)

    ii=execute('A={'+ elsa +'}')
end

pro DialHistory, name, d=dnum, ONOFF=v
;** ***********
;**
;** A short for DialTag procedure

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  ii=execute('d'+strtrim(string(dnum),2)+'.HISTORY=v')
	                   if v then lab ='History is on' else lab ='History is off'
				 if geo_isw then widget_control,bad_id=ii,geo_w(7,dnum),set_value=lab
				 endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStop, name, d=dnum
;** ********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geo
common c_geweb
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=0')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=0
				 geo_w(8,dnum)=0
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' stopped'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial stopped' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' stopped'
				 if geo_web then WebDo,'val',dnum,dnum
				 endif
end
;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
pro DialStart, name, d=dnum
;** *********
;**
;** A short for DialTag procedure

common c_lamp_info
common dialshare2
common c_geo
common c_geweb
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin  di=strtrim(string(dnum),2) & wupd=0
				 ii=execute('d'+di+'.ONOFF=1')
				 ii=execute('name=d'+di+'.NAME')
				 ii=execute('wupd=d'+di+'.WUPDATE')
				 if geo_isw then widget_control,bad_id=ii,geo_w(3,dnum),set_button=1
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
				 freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
				 geo_w(8,dnum)=0
				 geo_timon(dnum)=systime(1)*1000
				 if freq  gt 0  then  P_GEO_TIMER, {id:geo_w(11,dnum)} $
	                                  else  DialsFrequency, /SENS
				 if l_message gt 0 then $
				 widget_control,bad_id=ii,l_message,set_value='Dial '+name+' started'
				 if wupd gt 0 then $
				      TO_DON_HISTORY,dnum,0,'W'+di+'=dial_'+name+'_macro result ;Dial started' $
				 else TO_DON_HISTORY,-1  ,0,'Dial '+name+' started'
				 if n_elements(gew_pth) eq 0 then WEBON
	endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialControl, command, d=dnum ,check=check ,name=nome
;******* ***********
;**
;** Back control to the instrument

common dialshare2
common c_lamp_par
common c_geo
common c_geweb

if n_elements(dnum)  ne 1 then dnum =geo_cur
if n_elements(nome)  eq 1 then dnum =DialNameToNumber(nome)
if n_elements(check) ne 1 then check=0.

di     =strtrim(string(dnum),2)
generic='' & ii=execute('generic=d' +di+'.GENERIC')
if generic eq 'lamp' then ctrl='' else ctrl='Ctrl:'

comm=[strtrim(command,2)]
comh= comm
for i=0,n_elements(comm)-1 do begin

	if strpos(strupcase(comm(i)),'CTRL:') eq 0 then comm(i)=strmid(comm(i),5,85)
	if i eq 0 then comh(i)= ctrl  +comm(i)+" ;; "+!stime $
	          else comh(i)='----:'+comm(i)
	to_don_history,-1,0,comh(0)
endfor
if geo_web then WebDo,'snd',comh,dnum

if generic ne "lamp" then begin
	   P_GEO_STATUS,dnum, "Send"

	   nome='' & prox=-1 & name=""
	   ii=execute('nome   =d' +di+'.TYPE')
	   ii=execute('name   =d' +di+'.NAME')
	   ii=execute('prox   =d' +di+'.PROS')
	   now=systime(1)
	   val=3.14

	   if prox(0) ge 0 then begin par1=nome & par2=check & par3=comm & par4=val & par5=name
	                              COMMCA, proxcod ,prox  & val =par4     ; SEND THE COMMAND !!!!!!!!!!!!

	   endif else begin CoCo='val=dial_'+generic+'_send(nome, check, comm, name)'
				      ii=EXECUTE(CoCo)                       ; SEND THE COMMAND !!!!!!!!!!!!

	    if not ii then begin val=0 & DialErrMes & DialStop & endif
	   endelse

	   geo_w(10,dnum)=geo_w(10,dnum)+((systime(1)-now)*1000)

	   if val ne 3.14 then P_GEO_STATUS,dnum, "SendOk" $
                        else P_GEO_STATUS,dnum, "SendNone"

endif else begin val=0 & XICUTE,comm(0) & endelse
return,val
end

pro DialClear, name, d=dnum
;** *********
;**
;** Remove the named dial

common dialshare2
common c_geo
	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
				 DialStop,d=dnum
				 DialTag ,d=dnum, tag="NAME", set=""
				;DialTag ,d=dnum, tag="PWD",  set=""
				 geo_w(6,dnum)=0
				 geo_w(8,dnum)=0
				 if geo_isw then widget_control,bad_id=ii,geo_w(2,dnum),sensitive =0
				 if geo_w(1,dnum) gt 0 then begin
				    di=strtrim(string(dnum),2)
				    P_GEO_DISPLAY, 'd'+di, geo_w(1,dnum) ,-1 ,DNUM=dnum
	endif		&	 endif
end

pro DialMacro, name, d=dnum, Si=di
;** *********
;**
;** Execute the macro of the named dial
;** Display the result

@lamp.cbk
common c_geo
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

	if n_elements(name) eq 1 then dnum=DialNameToNumber(name)   else name=''
	if n_elements(dnum) ne 1 then dnum=geo_cur
	if dnum gt 0 then begin
	   if n_elements(di) ne 1 then di = strtrim(string(dnum),2)

	   geo_w(5,dnum)=geo_cur & geo_cur= dnum
	   geo_w(9,dnum)=0       & geo_w(10,dnum)=0
	   now=systime(1)

	   ii=execute('name =d'+di+'.NAME')
	   ii=execute('orig =d'+di+'.ORIGIN')
	   ii=execute('prox =n_elements(dt'+di+')') & jj=1

	   CATCH,stat & if stat ne 0 then begin catch,/cancel & DialErrMes & DialStop & return & endif

	   if prox gt 1 then begin DialFromD,keepd
	                     ii=execute('DialToD,  d'+di)
	                     jj=execute('COMMCA,  dt'+di)           ;EXECUTE THE MACRO OF THE DIAL from .prox
	                     ii=execute('DialFromD,d'+di)
	                                 DialToD  ,keepd
	   endif        else jj=execute('dial_'+orig+'_macro,d'+di) ;EXECUTE THE MACRO OF THE DIAL from .pro

	   if jj eq 0 then begin DialErrMes &  DialStop & endif

	   geo_w(8,dnum)=((systime(1)-now)*1000)>1

	   sz  =0  & ii=execute('sz   = SIZE (d'+di+'.VALUE)')
	   wupd=0  & ii=execute('wupd =d'+di+'.WUPDATE')
	   hiss=0  & ii=execute('hiss =d'+di+'.HISTORY')
	   if hiss then begin u=-1
		ii=execute('val=d'+di+'.VALUE(0)')
		if (val ne '') or (sz(sz(0)+2) gt 1) then begin
			on_ioerror,misopn & openw,u,"dial_"+name+".his",/append,/get_lun
			ii=execute('printf,u,d'+di+'.VALUE')
			misopn: if u gt 0 then free_lun,u
	   endif  & endif
	   val  =0
	   plt  =0      &         ii=execute('plt =       d'+di+'.PLOT')
	   histo=0

	   dw=di
	   if wupd le 0 then dw=strtrim(string(dnum+70),2)

	   if (sz(sz(0)+1) eq 7) and (plt gt -2) then begin
		ii=execute('val =  ";"+ d'+di+'.VALUE')
		if sz(sz(0)+2) gt 1 then begin
			WebDo,'log',val,dnum
			form_out,val & print,val & val='... '+val(n_elements(val)-1)
		endif else begin
			if val(0) le "; " then plt=-2
		endelse
		if plt ne -2 then begin ii=execute('w'+dw+' = val') & plt=-1 & endif

	   endif else if plt eq -1 then ii=execute('w'+dw+' = d'+di+'.VALUE') $

	   else if plt ge 0 then begin
		   sze=0.       &   ii=execute('sze  = d'+di+'.ERROR')
		   if n_elements(sze) ne sz(sz(0)+2) then sze=0.
				    alltag=[' '] & ii=execute('alltag = strupcase(TAG_NAMES(d'+di+'))')
				    xtl='' & ytl=''
				    idx=where(alltag eq 'X_TIT')  & idy=where(alltag eq 'Y_TIT')
				    if idx(0) ge 0 then  ii=execute ( 'xtl     = d'+di+'.X_TIT')
				    if idy(0) ge 0 then  ii=execute ( 'ytl     = d'+di+'.Y_TIT')
				    if wupd   gt 0 then  x_tit(dnum) = xtl    & !X.title=xtl
				    if wupd   gt 0 then  y_tit(dnum) = ytl    & !Y.title=ytl
				    if wupd   gt 0 then  w_tit(dnum) = name
				    if wupd   gt 0 then  other_tit(dnum) =  '(Dial)'
		   if sz(sz(0)+2) gt 1 then begin
				    ii=execute('w'+dw+' = d'+di+'.VALUE')
				    ii=execute('e'+dw+' = sze')
				    idx=where(alltag eq 'XVALUE') & idy=where(alltag eq 'YVALUE')
				    if idx(0) ge 0 then  ii=execute ( 'x'+dw+' = d'+di+'.XVALUE')
				    if idy(0) ge 0 then  ii=execute ( 'y'+dw+' = d'+di+'.YVALUE')
		   endif else begin
		     if plt gt 1 then  begin val=0 & ii=execute('val    = d'+di+'.VALUE')
			                             ii=execute('sz     = n_elements(w'+dw+')')
			if sz lt plt then begin      ii=execute('w'+dw+'=[(lonarr(plt-sz)+1)*val,w'+dw+']')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			if sz gt plt then begin      ii=execute('w'+dw+'= w'+dw+'(sz-plt:sz-1)')
			           if sze gt 0. then ii=execute('e'+dw+'=  fltarr(plt)')
			endif
			                 ii=execute('w'+dw+'=[w'+dw+'(1:plt-1),val]')
			if sze gt 0 then ii=execute('e'+dw+'=[e'+dw+'(1:plt-1),sze]')
			histo=1
		     endif          else ii=execute('w'+dw+'= d'+di+'.VALUE')
		   endelse
	   endif
	   if plt ge -1 then if (geo_w(1, dnum) gt 0) or (geo_w(13, dnum) gt 0) then begin
			ii=execute('P_GEO_DISPLAY, D'+di+', W'+dw+', error=E'+dw+', X=X'+dw+', Y=Y'+dw+', histo=histo')
	   endif
	   if geo_act eq 2 then WebDo,'dws',0,0,0

	   geo_cur=geo_w(5,dnum) & geo_w(5,dnum)=0
	   nel=n_elements(geo_timon)-1
	   if now - geo_timon(nel-dnum) gt 3. then begin
	   	if (dw eq di) and (plt gt -2) then TO_DON_HISTORY ,dnum,0,'W'+di+'=dial_'+name+'_macro result' ,/nojournal
		geo_timon(nel-dnum)=now
	   endif
	endif
end

pro DialFromD, Dial
;** *********
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
if n_elements(d) gt 0 then Dial=d
end
pro DialToD, Dial
;** *******
common for_users,	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
d=Dial
end
pro DialErrMes
;** **********
@lamp.cbk
common c_geo
  if l_message gt 0 then widget_control,bad_id=ii,l_message,set_value=strmid(!err_string,0,65)+' ...'
  print, !err_string
  WebDo,'err',!err_string
end
pro DialWSet, Activity=activity
;** ********
@lamp.cbk
common c_geo
  if keyword_set(activity) then begin
	P_GEO_DISPLAY,did_win0,1,0
  	geo_act=0
  endif else begin
  	if geo_act ne 2 then P_GEO_DISPLAY,did_win0,-1,0
  	geo_act=2
  	p_did_setwin0,/map
  endelse
end

pro DialInit, name, d=dnum, path=pth, restore=restore, new=newed, herits=diaH, nostart=nostart
;** ********
;**
;** the dial_name.pro file is compiled
;** and dial_name function is used to initiate the Dial.
;** Check for dial consistency then put it in D'dnum'.
;** /restore is used when restore saved session.
;** If new is defined then after loaded, give it the name "newed".

@lamp.cbk
common c_geo
common c_geowks, W71,W72,W73,W74,W75,W76,W77,W78,W79,W80,W81,W82,W83,W84,W85,W86,W87,W88,W89,W90, $
		 E71,E72,E73,E74,E75,E76,E77,E78,E79,E80,E81,E82,E83,E84,E85,E86,E87,E88,E89,E90
common c_geowkc, X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90, $
		 Y71,Y72,Y73,Y74,Y75,Y76,Y77,Y78,Y79,Y80,Y81,Y82,Y83,Y84,Y85,Y86,Y87,Y88,Y89,Y90

if n_elements(name)   eq 1 then begin
 if n_elements(newed) ne 1 then newed =strlowcase(name)
 if n_elements(dnum)  ne 1 then dnum  =DialNameToNumber( newed, /find)
 if (dnum ge 1) and (dnum lt (size(geo_w))(2)) then begin
  di=strtrim(string(dnum),2)
  if l_message gt 0 then widget_control,l_message,bad_id=ii,set_value=" "
  if n_elements(pth) ne 1 then pth =""
  CD,current=mee
  if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
  fname="dial_"+name
  dial =''
  proc =findfile(fname+".pro" ,count=nn)
  if nn eq 0 then begin
     prox =findfile(fname+".prox",count=nn)
     if  nn gt 0 then begin DialFromD,keepd
                         COMMSI,fname+".prox", /EXEC             & DialFromD,dial
                         COMMSI,fname+"_macro.prox", MACRO=extxt & ii=execute('dt'+di+'=extxt')
                         DialToD  ,keepd  &  nn=-2
     endif & CD,mee
  endif
  if  nn ne -2 then begin
       if newed eq strlowcase(name) then if  sys_dep ('VERSION') ge 4.0 then $
       if (not sys_dep("EMBEDDED")) and (not sys_dep("RUNTIME")) then $
       ii  =execute('RESOLVE_ROUTINE,fname,/is_f')
       rout=[strupcase(fname)]
       if  sys_dep ('VERSION') ge 5.1 then ii=execute('rout=routine_info(/functions)')
       idx=where(rout eq strupcase(fname))
       if idx(0) ge 0 then ii=execute('dial='+fname+'()')	;INITIATE THE DIAL
       CD,mee
       if not ii then DialErrMes
  endif

  if n_elements(restore) eq 0 then begin

   if n_tags(dial) lt 1 then dial={init:0}

	tlist=strupcase(tag_names(dial))
	idx=where(tlist eq 'INHERIT')
	if idx(0) ge 0 then if dial.inherit gt ' ' then begin    diaG=''
	    DialInit , string (dial.inherit) , d=dnum, path=pth, herits=diaG
	    DialMix  , dial ,  diaG
	    tlist=strupcase(tag_names(dial)) & endif

	if n_elements(diaH) gt 0 then begin
	    DialMix  ,diaH,dial  &   return  & endif

	named    =newed
	generic  ='mad'
	type     =name
	value    =""
	error    =0.
	onoff    =0
	number   =dnum
	frequency=0.
	wupdate  =0. & if GEORGE eq 1 then wupdate=1
	upperlim =0.
	lowerlim =0.
	plot     =50
	history  =0
	duration =0
	init     =0
	unit     =''
	elsa     =''
	for k=0,n_elements(tlist)-1 do begin

	    CASE tlist(k) of
	    'NAME':
	    'NUMBER':
	    'PATH':
	    'ONOFF':     onoff    =fix   (dial.onoff)
	    'VALUE':     value    =dial.value
	    'ERROR':     error    =float (dial.error)
	    'PLOT':      plot     =fix   (dial.plot)
	    'WUPDATE':   wupdate  =fix   (dial.wupdate)
	    'INIT':      init     =fix   (dial.init)
	    'UNIT':      unit     =string(dial.unit)
	    'UPPERLIM':  upperlim =float (dial.upperlim)
	    'LOWERLIM':  lowerlim =float (dial.lowerlim)
	    'GENERIC':   generic  =string(dial.generic)
	    'TYPE':      type     =string(dial.type)
	    'FREQUENCY': frequency=float (dial.frequency)
	    'HISTORY':   history  =fix   (dial.history)
	    'DURATION':  duration =float (dial.duration)
	     ELSE:       elsa=elsa+','+tlist(k)+':dial.'+tlist(k)
	     ENDCASE
	endfor

	if keyword_set(nostart) then onoff=0
	DialClear,named
	ii=execute('d'+di+'={NAME:named,ORIGIN:name,GENERIC:generic,TYPE:type,INIT:init'+ $
	                   ',PLOT:plot ,UPPERLIM:upperlim,LOWERLIM:lowerlim,WUPDATE:wupdate'    + $
	                   ',ONOFF:onoff,VALUE:value,ERROR:error,FREQUENCY:frequency,DURATION:duration' +$
	                   ',HISTORY:history,PROX:[-1L,0],PROS:[-1L,0],NUMBER:number,UNIT:unit,PATH:pth'+$
	                     elsa +'}')

	if (wupdate gt 0) then begin
		ii=execute('w'+di+'=0')
		CLEARPAR, dnum,di
		w_tit    (dnum)=named  +' dial'
		other_tit(dnum)=type   +' (type) <- '+generic
		y_tit    (dnum)=unit
	endif
	ii=execute('w'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('x'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('y'+strtrim(string(dnum+70),2)+'=0')
	ii=execute('e'+strtrim(string(dnum+70),2)+'=0')

	if pth gt " " then begin catch,stat & if stat eq 0 then CD,pth else catch,/cancel & endif
	SetDuduch, "_read", generic, PROX & ii=execute('d'+di+'.PROX=PROX')
	SetDuduch, "_send", generic, PROX & ii=execute('d'+di+'.PROS=PROX')
	CD,mee

  endif
  if geo_isw then begin
			widget_control,bad_id=ii,geo_w(2,dnum),sensitive =1
			P_GEO_DISPLAY, newed, dnum ,-2

			DialTag, d=dnum, TAG='ONOFF'  , GET=onoff
			DialTag, d=dnum, TAG='ONOFF'  , SET=onoff
			DialTag, d=dnum, TAG='HISTORY', GET=history
			DialTag, d=dnum, TAG='HISTORY', SET=history
			endif

  if geo_w(1,dnum) gt 0 then P_GEO_DISPLAY, newed, geo_w(1,dnum) ,-1 ,DNUM=dnum
  
  if geo_cur le 0 then geo_cur=dnum ; To prevent problems in DialControl & DialNewValue
  geo_w(6,dnum)=1
 endif
endif
end

pro SetDuduch, proo, generic, PROX
;** *********
;**
common dialshare2

PROX=[-1L,0]
	  proc  =findfile ("dial_"+generic+proo+".pro" ,count=nn)
	  if nn eq 0 then begin
	   prof =findfile ("dial_"+generic+proo+".prox",count=nn)
	   if nn gt 0 then begin
		idx=where(duduch3 eq generic+proo) & idx=idx(0)
		if idx eq -1 then begin              idx=n_elements(proxcod)
		   COMMSI,"dial_"+generic+proo+".prox",  MACRO=tmpcod
		   nn     =n_elements(tmpcod)
		   duduch3=[duduch3,generic+proo,string(idx),string(idx+nn-1)]
		   proxcod=[proxcod,tmpcod]
		   PROX   =[idx,idx+nn-1L]
		endif else PROX=[long(duduch3(idx+1)),long(duduch3(idx+2))]
	   endif
	  endif
end

;** *******************************************************************************
;** *******************************************************************************
;** *******************************************************************************
function DialOn, dial, d=dnum
;******* ******
;**
;** Check for a User interrupt

common dialshare2
common c_geo

R=1
if geo_isw then begin
	if geo_onbas(1) gt 0 then begin
	   evv=widget_event(geo_onbas(1),/nowait,bad_id=ii)
	   if evv.id    eq  geo_onbas(1) then begin geo_stat =evv.select & R=geo_stat
	                                            geo_timon(0)=systime(1)*1000  &  endif
	endif
	if R then begin
	   if n_elements(dnum) ne 1 then dnum=geo_cur
	   if n_tags(dial)     gt 1 then dnum=dial.number
	   if (dnum ge 1) and (dnum le (size(geo_w))(2)) then begin
	     evv=widget_event(geo_w(3,dnum),/nowait,bad_id=ii)
	     if evv.id    eq  geo_w(3,dnum) then DialTag, d=dnum, tag='ONOFF', set=evv.select
	     DialTag ,d=dnum,tag='ONOFF', get=R
	   endif
	endif
endif
return,R
end

;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
;************************************** WEB MODULES ***************************
pro WebFTP, file ,open=opn ,ifopn=ifopn ,check=check
;** ******
common c_geweb
common c_geUnit, gew_unit, gew_tftp ,gew_chk

;TEST FOR FTP AND BARNS ENABLE
if n_elements (gew_unit)  eq 0 then begin
   if sys_dep ('MACHINE') eq 'unix' then gew_unit= 0 else gew_unit=-1
   if sys_dep ('VERSION') lt 5.2    then gew_unit=-1
   bb=findfile(expand_path('~/.ssh')+'/*',count=n)  & if n lt 1 then gew_unit=-1
   gew_chk=0 & gew_tftp= dblarr(2)
endif else if keyword_set(opn) then begin if gew_unit lt 0 then gew_unit=0 & gew_chk=0 & endif

gew_unit=-1 ;Barns now is inside ILL

if gew_unit ge 0 then begin line=' ' & u=0
   on_ioerror,misftp
   if gew_unit gt 0 then begin now=systime(1) & delt=now-gew_tftp(0)
;   TEST TIME-TO-TIME FOR PIPE CONNECTION (OR INPUT COMMAND)
    if keyword_set(check) or (delt gt 7.) then begin
       if delt le 7. then begin if check eq 2 then gew_chk=0 & ok=1 & endif else ok=0
       s=fstat(gew_unit) & six=6
       if s.size gt six then begin ok=1
          while s.size gt six do begin readf,gew_unit,line & s=fstat(gew_unit)
	   if strpos(line,'Timeout')  ge 0 then begin s.size=0 & ok=0 & WebFTP_close & endif else $
	   if strpos(line,'by peer')  ge 0 then begin s.size=0 & ok=0 & WebFTP_close & endif else $
	   if strpos(line,gew_pth(3)) ge 0 then if (strpos(line,'Fetching') lt 0) and (strpos(line,'Removing') lt 0) then begin
	                                        printf, gew_unit,'get '+gew_pth(1)+gew_pth(3)+' '+gew_pth(1)+gew_pth(3)
                                                printf, gew_unit,'rm  '+gew_pth(1)+gew_pth(3) & gew_chk=2 & endif
          endwhile
          if ok eq 1 then begin if keyword_set(check) then begin
	                           if check eq 2 then gew_chk=0 $  ;RESET by webon_macro
				   else begin check=gew_chk        ;WILL BE THERE NEXT TIME IF gew_chk eq 2
	                                      if gew_chk eq 2 then begin gew_chk=1 & check=0 & endif
                                              if gew_chk eq 0 then printf, gew_unit,'dir '+gew_pth(1) & endelse
	                        endif
				printf, gew_unit,'pwd' & gew_tftp(0)=now & endif
       endif else check=gew_chk
       if ok eq 0 then if now-gew_tftp(1) gt 60*6. then gew_tftp(1)=now else $
                       if now-gew_tftp(1) gt 60*4. then WebFTP_close    else $
		       if now-gew_tftp(1) lt 20*1. then begin print,'No response from Ftp '+!stime & gew_tftp(1)=now-20 & endif
    endif
   endif
;  OPEN FIRST OR BROKEN CONNECTION
   if gew_unit eq 0 then begin
      if keyword_set(ifopn) then return
;     openr ,u,gew_pth(2),/get_lun & readf ,u,line & free_lun,u
;     openw ,u,'~/.netrc',/get_lun & printf,u,line & free_lun,u
;     spawn,'chmod 600 ~/.netrc' & openr ,u,'~/.netrc',/get_lun,/DELETE
      spawn,['sftp','arthur@barns'],unit=gew_unit,/noshell
      printf, gew_unit,'cd '+ gew_pth(0)
      printf, gew_unit,'pwd' & wait,2 & s=fstat(gew_unit) & six=6
      ok=1
      if gew_tftp(0) eq 0 then begin jj=5 & ok=0 ;FIRST TIME OPENED
         while (s.size le six) and (jj gt 0) do begin wait,1 & jj=jj-1 & s=fstat(gew_unit) & endwhile
         if s.size gt six then begin
            while s.size gt six do begin readf,gew_unit,line & s=fstat(gew_unit) & endwhile
            if strpos(line,strmid(gew_pth(0),0,strlen(gew_pth(0))-1)) ge 0 then begin
               printf, gew_unit,'pwd' & print,'Ftp reactivated '+!stime & ok=1 & endif
         endif
      endif                                      ;-----------------
      gew_tftp(0:1)=systime(1)
      if not ok then begin WebFTP_close & gew_unit=-1 & endif
      if u gt 0 then free_lun,u & u=0
   endif

;  SEND THE FILE
   if n_elements(file) eq 1 then printf, gew_unit,'put '+gew_pth(0)+file+ ' '+file
   return
   
   misftp: WebFTP_close & if u gt 0 then free_lun,u & if gew_tftp(0) eq 0 then gew_unit=-1
endif
end

pro WebFTP_close
;** ************
common c_geUnit
if n_elements(gew_unit) eq 1 then if gew_unit gt 0 then begin
   print,'Ftp canceled '+!stime
   if sys_dep('VERSION') lt 5.4 then free_lun,gew_unit else ii=execute('free_lun,gew_unit,/force')
   gew_unit=0
endif
end

pro dial_webon_macro,D
;** ****************
;**
nn =1 & WebFtp,CHECK=nn
if  nn eq 1 then bid=FINDFILE(D.webpth,count=nn)
IF  nn gt 0 then begin wline=[''] & value=['']
    on_ioerror,misopn
    OPENR,u,D.webpth,/GET_LUN,/DELETE
	on_ioerror,misread
	line=''
	WHILE (not EOF(u)) do begin READF,u,line & wline=[wline,line] & ENDWHILE
	misread:  on_ioerror,misopn
	FREE_LUN ,u
	WebFtp,CHECK=2
	IF n_elements(wline) gt 2 then if wline(1) eq D.pwd then begin
		wline=wline(2:*)
		XICUTER,' ;--->WebOn '+!stime+' {'+wline(0)+'...}'
		CATCH,stat & if stat ne 0 then begin print,!err_string & return & endif
		FOR i=0,n_elements(wline)-1 do $
			IF wline(i) ne D.pwd then begin line=strtrim(wline(i),2)
			
			   if strpos(line,'ii=barns_i') ge 0 then jj=EXECUTE(line) $
			   else if line gt ' '	then begin XICUTER,(line+'') & value=[value,line]
			        endif
			ENDIF
		XICUTER,' ;---> '
		if n_elements(value) gt 1 then value=value(1:n_elements(value)-1)
		WebDo,'log',value,12
	ENDIF
	DialModValue,value, TAG='VALUE'
    misopn:
endif else if D.value(0) ne '' then DialModValue,[''], TAG='VALUE'
end

function dial_webon
;******* **********
;**
return,{NAME:"webon",PLOT:0,HISTORY:0,VALUE:[''],FREQUENCY:3,WEBPTH:'',PWD:'',WUPDATE:-1}
end

pro WebOn, PATH=wpth ,PASSWORD=pass, PASSWD=pasw
;** *****
common c_geo
common c_geweb

catch,stat & if stat ne 0 then return

if n_elements(gew_pwd) ne 1 then       gew_pwd= ''
if n_elements(   pass) eq 1 then begin gew_pwd=pass & ii=execute('geokey,gew_pwd') & endif
if n_elements(   pasw) eq 1 then begin gew_pwd=pasw & ii=execute('geokey,gew_pwd') & endif
Mach=strupcase(getenv('HOST')) & id=strpos(Mach,'.')
if id gt 0 then Mach=strmid(Mach,0,id)
dvd=sys_dep('DIVIDER')
if n_elements(gew_pth) lt 2 then begin gew_pth=['','','','.geo_webon.txt']
		if Mach eq "" then begin F='C:\User\Didier\geoport\' & Mach='pcRichard'
		endif         else       F='/home/cs/lambda/geoport/'
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(0)=F+Mach
		gew_pth(2)=F+'.bArns'
		F=F+'WebGeorge'+dvd
		T=FINDFILE(F+'*',count=n)
		if n gt 0 then gew_pth(1)=F+Mach+dvd else gew_pwd=''
endif

if n_elements(wpth) eq 1 then gew_pth(0)=  wpth
nld=strlen(gew_pth(0))-1
if nld gt 0 then if strmid(gew_pth(0),nld,1) eq dvd then gew_pth(0)=strmid(gew_pth(0),0,nld)

if gew_pth(0) gt ' ' then begin
 gew_pth(0)=gew_pth(0)+dvd
 on_ioerror,misopn
 openw,u,gew_pth(0)+'geo_d_0.web',/get_lun & free_lun,u

    list=findfile(gew_pth(0)+'geo_d_*',count=nn)
    if  nn gt 0 then bid=sys_dep('DELIST',list)

    par1 =''
    if Mach ne '' then begin
	catch,stat
	if stat eq 0 then ii=execute('par1=dial_pad_init_'+(Mach)+'(dummy)') else catch,/cancel
    endif
    
    WebFTP,/open
    
    sz=SIZE(par1)
    if  sz(0) lt 2 then ii=execute("par1=dial_pad_init()") & sz=SIZE(par1)
    if (sz(0) eq 2) and (sz(1) eq 5) then begin
	  openw,u,gew_pth(0)+'dial_pad.web',/get_lun
	  printf,u,'# George Instrument PAD'
	  printf,u,'# ',strtrim(string(sz(2)),2),' * 5 entries (label command flag program check)'
	  printf,u,'# First 5 lines for input text, others for buttons'
	  printf,u,'# '
	  for j=0,sz(2)-1 do for i=0,sz(1)-1 do printf,u,par1(i,j)
	  free_lun,u
	  WebFTP, 'dial_pad.web' & endif

 if sys_dep('MACHINE')  eq  'vms' then gew_v=';1' else gew_v=''
 gew_act=100 & gew_snd=['-'] & gew_err='-'
 tvlct,gew_r,gew_g,gew_b,/get
 if    gew_pwd gt ' ' then begin list=findfile(gew_pth(1)+gew_pth(3),count=nn)
				 if  nn gt 0 then bid=sys_dep('DELIST',list)
				 DialInit ,"webon",d=12
				 DialTag  ,"webon",tag="WEBPTH",set=gew_pth(1)+gew_pth(3)
				 DialTag  ,"webon",tag="PWD"   ,set=gew_pwd
				 DialStart,"webon" & endif
 geo_web=1
 WebDo,"sta","on",0
 return
 misopn: ;DialErrMes
endif
gew_pth='' & gew_pwd= ''
end

pro WebOff
;** ******
common c_geo
common c_geweb
if geo_web gt 0 then WebDo,"sta","off",0
geo_web=0
gew_pth='' & gew_pwd= '' & DialClear,"webon" & WebFTP_close
end

pro WebMess, val
;** *******
WebDo, 'log', val, 9
end

pro WebDo, flag, val, dnum, matx
;** *****
common c_geo
common dialshare2
common c_geweb

if geo_web eq 0 then return
on_ioerror,misopn
flg=flag
case flg of
'act':gew_act=100 + 100-val
'err':gew_err=val
'snd':gew_snd=val
'pth':begin   val=gew_pth(0) & return & end
'fil':WebFTP, val
'log':begin fifi='geo_d_'+strtrim(dnum,2)+'Lhtm.web'+gew_v
		openw,u,gew_pth(0)+fifi,/get_lun
		printf,u,'<html><head></head><body><b>'
		if dnum eq 12 then printf,u,'<h3>Command executed:</h3><br>'
		for i=0,n_elements(val)-1 do printf,u,'<nobr>'+val(i)+'<br>'
		printf,u,'</body></html>'  & printf,u,''
		flush,u & free_lun,u
		WebFTP, fifi
      end
;'dws':return ;nfs problem for big files
 else:begin ds=strtrim(dnum,2)			;'gif' 'dws' ('val' 'wks')
       now=systime(1)
       nel=n_elements(geo_timon)-1
       onf=1     &  if dnum gt 0 then ii=execute('onf =d'+ds+'.onoff')
       if (now-geo_timon(nel-dnum) ge 3.) or (flg eq 'val') or (not onf) then begin ;Care 3. le that for history!!!!!!

	freq=0   &  if dnum gt 0 then ii=execute('freq=d'+ds+'.frequency')
	dur =0   &  if dnum gt 0 then ii=execute('dur =d'+ds+'.duration')
	his =0   &  if dnum gt 0 then ii=execute('his =d'+ds+'.history')
	nam ='z' &  if dnum gt 0 then ii=execute('nam =d'+ds+'.name')
	if (not onf) then nam=nam+'_stopped'
	ifopn=0
	dws =flg
	if flg eq 'dws' then begin flg='gif' & if not val then begin DialWSet & geo_act=1 & endif else ifopn=1 & endif
	if flg eq 'gif' then begin r=0       & matx=tvrdd(r,g,b) & endif
	if flg eq 'val' then flg='gif'
	if flg eq 'gif' then if sys_dep('VERSION') ge 5.4 then  flg='png'

	img=n_elements(matx)
	if img gt 1 then $
	   if flg ne 'wks' then begin fifi='geo_d_'+ds+'.'+flg+gew_v
	    if n_elements(r) le 1 then $
	         WRITE_KIF,gew_pth(0)+fifi,matx,gew_r,gew_g,gew_b,transparent=0 $
	    else WRITE_KIF,gew_pth(0)+fifi,matx, r,g,b,transparent=0
	    WebFTP, fifi, IFOPN=ifopn
	   endif
	if dws eq 'dws' then flg=dws

	fifi='geo_d_'+ds+'.web'+gew_v
	openw,u,gew_pth(0)+fifi,/get_lun
	printf,u, nam,gew_act,geo_freq,geo_lim
	printf,u, freq,dur,his,' '+flg
	printf,u, val
	if gew_err    ne '' then begin printf,u,'err:'+gew_err & gew_err=''   & endif
	if gew_snd(0) ne '' then begin printf,u,'snd:'+gew_snd & gew_snd=[''] & endif
	flush,u & free_lun,u
	WebFTP, fifi, IFOPN=ifopn
	
       endif
      end
endcase
misopn:
end
;************************************ END WEB MODULES *************************
;************************************ END WEB MODULES *************************

pro P_GEO_EVENT, ev, uv
;** ***********
;**
;** Widget events handler
@lamp.cbk
common c_geo

if uv(1) eq 667 then begin geo_stat  =ev.select  & uv(1)=666                        ;on/off General
                           geo_w(8,*)=0 & endif
case uv(1) of
	614: begin                                                                  ;Mad command
		widget_control,uv(3),bad_id=ii,get_value=comm
		comm=strtrim(comm(0),2)
		if strpos(strupcase(comm),'CTRL:') ne 0 then comm='Ctrl:'+comm
		XICUTER,comm
	     end
	660: if geo_act ne ev.select then begin geo_act=ev.select                   ;plot Activity
	        if geo_act gt 0 then P_GEO_DISPLAY,did_win0,0,0 $
			        else P_GEO_DISPLAY,did_win0,1,0
	     endif
	665: DialTag, d=uv(2), tag='ONOFF', set=ev.select                           ;on/off on Dials
	666: begin                                                                  ;Change frequency ?
		widget_control,uv(2),get_value=bid
		on_ioerror,mis666
		geo_freq=(float(bid(0))>0.) & duduch1=geo_freq
		bid=0
		widget_control,uv(4),get_value=bid,bad_id=ii                        ;Change duration  ?
		on_ioerror,misbid
		geo_lim =(float(bid(0))>0.) & duduch2=geo_lim & misbid:
                geo_timon(0)=systime(1)*1000
		P_GEO_TIMER, {id:uv(3)}
		mis666:
	     end
	670: begin case uv(2) of
	     1:  begin dnum=uv(3)                                                   ;Reset
	               pth   =''   & DialTag,d=dnum,tag="PATH"  ,get=pth
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               named =''   & DialTag,d=dnum,tag="NAME"  ,get=named
	               origin=''   & DialTag,d=dnum,tag="ORIGIN",get=origin
	               DialInit, origin, d=dnum, path=pth ,new=named
	                            DialTag,d=dnum,tag="ONOFF",set=onoff
	               end
	     2:  DialTag,d=uv(3),tag="HISTORY",set=0                                ;History off
	     3:  DialTag,d=uv(3),tag="HISTORY",set=1                                ;History on
	     4:  begin DialTag,d=uv(3),tag="NAME",get=named                         ;Clear history file
	               bid=sys_dep('DELET',"dial_"+named+".his")
	               end
	     5:  begin dn=uv(3) & dw=geo_w(13,dn)                                   ;large dial
		       keep_w=!D.window
	               if dw gt 0 then begin ii=execute('wset,dw')
	                                     if ii ne 1  then dw=0 else wshow,dw & endif
	               DialTag,d=uv(3),tag="WUPDATE",get= wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=(wupd<1)
		       
	               if dw le 0 then begin DialTag,d=dn,tag="NAME" ,get=named
		                               if geo_w(1,dn) gt 0 then P_GEO_DISPLAY, 'Large '+named,geo_w(1,dn),-1
	                                     WINDOW,xsize=geo_bxy(0)*2,ysize=geo_bxy(1)*2,title=named,/FREE
	                                     dw=!D.Window & endif
	               geo_w(13,dn)=dw
		       if keep_w gt 0 then wset,keep_w
	         end
	     6:  begin di=strtrim(string(uv(3)),2)                                  ;Properties list
	               tlist=[''] & ii=execute('tlist=strupcase(tag_names(d'+di+'))')
		       if geo_lead gt 0 then begin b0=widget_base(title="Dial "+di+" properties",resource_name="lamp")
						   b1=widget_base(b0,/column,resource_name="geo") & endif
	               for k=0,n_elements(tlist)-1 do begin
			   DialTag,d=uv(3),tag=tlist(k),get=V & tag='d'+di+'.'+tlist(k)
	                   CASE tlist(k) of
	                   'ERROR':
	                   'PROX':
	                   'PROS':
	                   'PWD':
	                    ELSE:   if geo_lead gt 0 then begin sz=SIZE(V)
			    		if sz(sz(0)+1) eq 8 then V='is a structure' $
			    		else if sz(sz(0)+2) gt 1 then begin  V=strtrim(string(sz(1)),2)
							if sz(0) gt 1 then V=V+','+strtrim(string(sz(2)),2)
							if sz(0) gt 2 then V=V+','+strtrim(string(sz(3)),2)
							if sz(0) gt 3 then V=V+',..'
							V='size('+V+')'
					endif else      V= strtrim(string(V(0)),2)
			    		b2=widget_base (b1,/row)
					bb=widget_label(b2,value=tag+"=",font=ft_b_normal)
					bb=widget_label(b2,value=V      ,font=ft_b_normal)
				    endif else print, tag+'= ',V
	                   ENDCASE
	               endfor
		       if geo_lead gt 0 then widget_control,b0,group_leader=geo_lead,/realize
	         end
	     7:  if ev.TYPE eq 0 then begin
	               di=strtrim(string(uv(3)),2) & N=0 & wupd=0				;plot in main window
	               geo_info(5)=did_win0							;case main window changed
	               DialTag,d=uv(3),tag="WUPDATE",get=wupd
	               DialTag,d=uv(3),tag="WUPDATE",set=2
	               ii=execute('N=n_elements(D'+di+'.VALUE)')
	               if N  gt 1 then begin
	                  DialTag,d=uv(3),tag="XVALUE",get=XX
	                  DialTag,d=uv(3),tag="YVALUE",get=YY
	                  ii=execute('P_GEO_DISPLAY, D'+di+', D'+di+'.VALUE, error=D'+di+'.ERROR, X=XX, Y=YY')
	               endif
	               if ev.PRESS eq 2 then DialTag,d=uv(3),tag="WUPDATE",set=1 ;middle
	               if ev.PRESS eq 1 then DialTag,d=uv(3),tag="WUPDATE",set=0 ;left
		 endif
	     8:        DialClear,d=uv(3)                                            ;Remove the dial
	     else:
	     endcase
	     if (uv(2) ge 80) and (uv(2) le 95) then begin
			widget_control,ev.id,get_value=fq & DialTag,d=uv(3),tag="FREQUENCY",set=float(fq(0))
			;widget_control,uv(4),set_value='Own Frequency='+fq
			DialTag,d=uv(3),tag="ONOFF",get=V & if V eq 1 then DialTag,d=uv(3),tag="ONOFF",set=1
	     endif
	     end
	671: begin  DialTag,d=uv(3),tag="PLOT",set=uv(2)
	            if uv(2) eq -2 then if geo_w(1,uv(3)) gt 0 then P_GEO_DISPLAY,'no Plot',geo_w(1,uv(3)),-1, DNUM=uv(3)
	     end
	else:
endcase
end

pro P_GEO_TIMER, ev
;** ***********
;**
;** Timer handler

common dialshare2
common c_geo

begtim=systime(1)
if ev.id eq geo_onbas(3) then begin
;  GENERAL TIMER
   if geo_lim gt 0  then if (begtim*1000 - geo_timon(0) gt geo_lim*1000) then DialsFrequency,/STOP
   if geo_stat      then begin
	 P_GEO_RETIM ,ev.id, geo_freq
	 Pn=((size(geo_w))(2))-1
	 dnum =0
	 R    =1
	 for i=1,Pn do if geo_w(6,i) eq 1 then begin

	   di   =strtrim(string(i),2)
	   onoff=0 & ii=execute('if n_tags(d'+di+') gt 1 then onoff=d'+di+'.ONOFF else geo_w(6,i)=0')
	   if onoff then begin
	    freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    if   freq le 0 then begin
	      if dnum eq 0 then P_GEO_STATUS, 0,"Loop",begtim  else   R=DIALON(d=(i+0))

	      if geo_stat  then if R then begin dnum=i
	                                        P_GEO_STATUS, dnum, "This" ,2
		                                DIALMACRO,  d=dnum, Si=di
	    					freq=0 & ii=execute('freq=d'+di+'.FREQUENCY')
	    					if freq gt 0 then P_GEO_RETIM ,geo_w(11,dnum), freq
	      endif
	    endif else if abs(geo_w(12,i)) eq 2 then  DialStart,d=(i+1-1)
	   endif else geo_w(8,i)=0
	 endif
	 if   dnum  gt 0   then P_GEO_STATUS, (geo_freq+0), "EndL" ,begtim
	 totim=geo_freq-(systime(1)-begtim)
	 if totim lt 0 then if geo_freq gt 0 then P_GEO_RETIM ,ev.id, totim ;GIVE TIME FOR OTHERS.
   endif
endif else begin

;  SPECIFIC TIMER
   widget_control,ev.id,get_uvalue=dnum
   di   = strtrim(string(dnum),2)
   freq = 0 & ii=execute('freq =d'+di+'.FREQUENCY')
   durat= 0 & ii=execute('durat=d'+di+'.DURATION')
   if durat gt 0 then if (begtim*1000 - geo_timon(dnum) gt durat*1000) then DialStop, d=dnum
   onoff= 0 & ii=execute('onoff=d'+di+'.ONOFF')
   if freq gt 0 then if onoff then begin
		P_GEO_RETIM ,ev.id,  freq
		P_GEO_STATUS, 0   , "Loop", begtim
		P_GEO_STATUS, dnum, "This" ,1
		DIALMACRO  ,d=dnum, Si=di
		P_GEO_STATUS, freq, "EndL" ,begtim
		fruq=freq & ii=execute('freq =d'+di+'.FREQUENCY')
		if freq ne fruq then P_GEO_RETIM ,ev.id,  freq $
		else begin
		  totim=(geo_freq*geo_stat)+freq - (systime(1)-begtim)
		  if totim lt 0 then P_GEO_RETIM ,ev.id, totim              ;GIVE TIME FOR OTHERS.
		endelse
   endif    else geo_w(8, dnum)=0
endelse
end

pro P_GEO_RETIM, id,freq
;** ***********
;**
;** RE-TIMER
			widget_control,bad_id=ii,id,/CLEAR_EVENTS
if freq gt 0 then	widget_control,bad_id=ii,id, TIMER=freq	else $
if freq lt 0 then	widget_control,bad_id=ii,id, TIMER=0.05<(-freq)
end

pro P_GEO_STATUS, dnum, way , flgtim
;** ************
;**
;** Display a scheme for the timer process

common dialshare2
common c_lamp_info
common c_geo
common c_geweb
common c_geostat,kpstr

if way eq "Loop" then       geo_seq=flgtim
if way eq "This" then       geo_w(12,dnum)=flgtim
if geo_isw then begin

   if geo_act eq 0 then begin keep_w=!D.window & wset,did_win0
   case way of

	"Loop":
	"This":     begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	            end

	"Get":      begin if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
	                  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=120
	            end

	"GetOk":          plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0

	"GetNone":  begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Bad new Value !!!'
			  plots,[geo_bxy(0)/2+20,geo_info(0)/3] , [geo_info(3)-10,40],thick=2.,/device,color=0
	            end

	"Send":     begin if dnum gt 0 then $
			   if geo_info(4) ne dnum then begin
			      device,copy=[0,dnum*25,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
			      geo_info(4)=dnum & endif
			  plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=120
	            end

	"SendOk":   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0

	"SendNone": begin if l_message gt 0 then widget_control,l_message,bad_id=ii, $
	                     set_value='Dial'+string(dnum)+' got a Send Control error-code !!!'
			   plots,[geo_bxy(0)/2+20,geo_info(0)*2/3],[geo_info(3)-10,70],thick=2,/device,color=0
	            end

	"EndL":     begin device,copy=[0,0      ,geo_bxy(0),geo_bxy(1)/2,   20      ,geo_info(3),geo_alp(3)]
	                  geo_info(4)= 0
				idx=where(geo_w(8,*) gt 0)
				totim= ((systime(1)-flgtim)*1000+geo_w(9,0))>1
				now  =   systime(1)
				if idx(0) ge 0 then begin
				   for i= 0,n_elements(idx)-1 do if geo_w(12,idx(i)) gt 0 then begin

				       j=idx(i)
				       geo_w(8 ,j)=(geo_w(8 ,j)*100./totim)>1
				       geo_w(9 ,j)=(geo_w(9 ,j)*100./totim)
				       geo_w(10,j)=(geo_w(10,j)*100./totim)
				       geo_w(12,j)=-geo_w(12,j)

				       endif else geo_w(8:10)=1

				   P_GEO_DISPLAY, idx ,dnum,totim
				   if geo_web then begin
				      if dnum gt 0 then ppm=long(dnum*1000*100./totim)<100 else ppm=100
				      WebDo,'act',ppm
				      endif
				endif
				device,copy=[0,0,geo_info(0)/2+30,geo_info(1)*2/3,geo_info(0)/2-32,geo_info(1)/3-2,geo_alp(4)]
				geo_w(9,0) =(systime(1)-now)*1000
	            end
	else:
	endcase
	if keep_w gt 0 then wset,keep_w

   endif else if geo_act gt 0 then begin di=string(dnum)
   case way of

	"Loop":      kpstr=''
	"This":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	                    di=strtrim(di,2) &  name="" & ii=execute('name=d'+di+'.NAME')
						wupd="" & ii=execute('wupd=d'+di+'.WUPDATE')
	             if wupd gt 0 then sws='W' else sws='D'
	             if wupd ge 0 then begin kpstr=kpstr+' ('+sws+di+')'+name
	             widget_control,l_message,bad_id=ii,set_value='............ Dial '+name+' running ...'
		     endif & endif
		     end
	"Get":      ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' requesting ...'
	"GetOk":    ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"GetNone":  ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad request !!!'
	"Send":     ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' sending control ...'
	"SendOk":   ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' running ...'
	"SendNone": ;widget_control,l_message,bad_id=ii,set_value='............ Dial'+di+' bad control !!!'
	"EndL":      begin ok=1 & if n_elements(b_labins) ge 6 then ok=b_labins(5)
	             if ok then begin
	               if kpstr gt ' ' then begin
	                  totim= ((systime(1)-flgtim)*1000)>1
	                  ppm  =long(dnum*1000*100./totim)
	                  if ppm lt 100 then miss=' mis:'+string(long(totim-dnum*1000)/1000.)+' sec' else miss=''
	                  widget_control,l_message,bad_id=ii,set_value=kpstr+string(ppm<100)+'%'+miss
	                  if geo_web then WebDo,'act',ppm<100
                       endif
	             endif
		     end
	else:
   endcase
   endif
endif
end

pro P_GEO_DISPLAY, D, W ,totim  ,error=E ,X=XXX ,Y=YYY ,histo=histo ,DNUM=dnum
;** *************
;**
;** Dial   display -> D=dial      ,  W=workspace
;** Scheme display -> D=dial index,  W=frequence,  totim= time
;** Backgr display -> D=did_win0  ,  W=big arrow,  totim= 0
;** Backgr reset   -> D=did_win0  ,  W=1        ,  totim= 0
;** Backgr erase   -> D=did_win0  ,  W=0        ,  totim= 0
;** di     xyouts  -> D=di        ,  W=winID    ,  totim=-1
;** Dial big name  -> D=name      ,  W=dnum     ,  totim=-2
;** c_did  info    -> D=return [] ,  W=0        ,  totim=-3

common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common c_draw ; rx,rz,nlv,styles(0,0),styles(1,0)
common c_did  ;[did_x,did_y,did_wd]
common c_geo
common c_geweb

	keep_w=!D.window
	if n_elements(totim)  eq 0 then begin

			dw  =geo_w(13,D.NUMBER)
			if  (D.WUPDATE eq 2)  then begin if dw gt 0 then              ii=execute('wdelete,dw')
							 dw=geo_info(5)
							 geo_w(13,D.NUMBER)=0       & ii=execute('wset   ,dw')
			endif else if dw gt 0 then begin ii= execute('wset, dw')    & if ii ne 1  then    dw=0
							 geo_w(13,D.NUMBER)=dw      & endif
			trap_current=dw
			stime=strmid(!stime,12,8)
			sz =SIZE(W) & upl=D.UPPERLIM & lwl=D.LOWERLIM
			if sz(sz(0)+2) eq 1 then begin
			   if (D.PLOT le 0) or (upl le lwl) or (dw gt 0) then begin
				if  (dw le 0) or (geo_web) then begin
				     wset,geo_alp(1) & erase
				     xyouts,3,3,strtrim(string(W(0)),2), charsize=1.,/device
				     xyouts,3,geo_bxy(1)-10,D.NAME     , charsize=1.,/device
				     wset  ,geo_w(1,D.NUMBER)
				     device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				     if geo_web then WebDo,'gif',W(0),D.number
				     endif
				if  (dw gt 0) then begin
				     if geo_web then wset,dw & erase
				     xyouts,9,9,strtrim(string(W(0)),2), charsize=3.,charthick=3,font=-1,/device
				endif
			   endif else begin
				wset,geo_w(1,D.NUMBER)
				on_ioerror,notan & res=0
				res=fix(float(upl-W(0))/(upl-lwl) * geo_bxy(0))
				device,copy=[res,0,geo_bxy(0),geo_bxy(1)-3,0,3,geo_alp(0)]
				notan: if res eq 0 then erase
				xyouts,3,geo_bxy(1)-23,strtrim(string(W(0)),2),charsize=1.,/device
			        xyouts,3,geo_bxy(1)-10,D.NAME,charsize=.6,/device
				if geo_web then WebDo,'gif',W(0),D.number
			   endelse

			endif else if sz(0) eq 1 then begin
			   if n_elements(xxx) ne sz(1) then xxx=indgen(sz(1))
			   if keyword_set(histo) then velu=       strtrim(string(W(sz(1)-1)),2) $
			   		   else begin mox =max(W) & velu= 'Max:'  +strtrim(string(mox),2)     + $
					   				  ' at X:'+strtrim(string(xxx(!C)),2)
					   endelse
			   if (dw le 0) or (geo_web)   then begin
			      wset,geo_alp(1)
			      if upl le lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[0,0],ymargin=[0,2],charsize=.7,font=-1,yrange=[lwl,upl]
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,D.NAME+'='+velu+'  ',charsize=.6,/device $
			                       else xyouts,3,geo_bxy(1)-10,velu+'      '       ,charsize=.6,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
				if geo_web then WebDo,'gif',W(n_elements(W)-1),D.number
				endif
			   if (dw gt 0)  then begin
				if geo_web then wset,dw
			      erase
			      velu=velu+' Updated:'+stime
			      if n_elements(E) eq n_elements(W) then sym=4 else sym=10
			      if upl le lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if upl gt lwl then plot,xxx,W,xmargin=[10,1],ymargin=[4,2],title=velu,psym=sym,yrange=[lwl,upl],$
			                              yticks=4,yticklen=1.,ygridstyle=1,thick=1.4,charthick=1.4,charsize=1.2,$
						      font=-1
			      if n_elements(E) eq n_elements(W) then errplot,xxx,W-E,W+E
			   endif

			endif else if sz(0) eq 2 then begin
			   if (n_elements(xxx) ne sz(1)) and (n_elements(xxx) ne sz(1)*sz(2)) then xxx=indgen(sz(1))
			   if (n_elements(yyy) ne sz(2)) and (n_elements(yyy) ne sz(1)*sz(2)) then yyy=indgen(sz(2))
			   congw='w' & congx=',xxx' & congy=',yyy' & qq=128L
			   if upl gt lwl then congw='w>lwl<upl'
			   if (sz(sz(0)+2) gt qq*qq) and (D.PLOT ne 0) then begin
			   	                                 congw= 'congrid('+congw+',qq<sz(1),qq<sz(2))'
			   	if n_elements(xxx) eq sz(1) then congx=',congrid(xxx,qq<sz(1))'          else $
								 congx=',congrid(xxx,qq<sz(1),qq<sz(2))'
			   	if n_elements(yyy) eq sz(2) then congy=',congrid(yyy,qq<sz(2))'          else $
								 congy=',congrid(yyy,qq<sz(1),qq<sz(2))'
			   endif
			   if D.PLOT eq 0 then mmx=max(W)
			   if (dw le 0) or (geo_web)  then begin
			      wset,geo_alp(1)
			      if D.PLOT eq 0 then begin 
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',geo_bxy(0),geo_bxy(1))+1)>1)') $
					       else ii=execute('tvscl,      CONGRID('+congw+',geo_bxy(0),geo_bxy(1))      ')
			      endif else $
			      if D.PLOT ne 2 then ii=execute($
				'shade_surf,'+congw+congx+congy+',xstyle=4,ystyle=4,zstyle=4,xmargin=[0,0],ymargin=[0,0],az=rz,ax=rx') $
			                      else ii=execute($
				'contour,'   +congw+congx+congy+',xstyle=4,ystyle=4,/fill   ,xmargin=[0,0],ymargin=[0,0],nlevels=nlv')
			      if (not geo_web) then xyouts,3,geo_bxy(1)-10,    D.NAME,    charsize=1.,/device
			      wset,geo_w(1,D.NUMBER)
			      device,copy=[0,0,geo_bxy(0),geo_bxy(1),0,0,geo_alp(1)]
			      if geo_web then WebDo,'gif',0,D.number
			      endif
			   if (dw gt 0) then begin
			   	titil=D.NAME+' updated:'+stime
				if geo_web then wset,dw
			      ;sxx=[1,round(sz(1)/4),round(sz(1)/2),round(sz(1)*3/4),sz(1)] & sxx=strtrim(string(sxx),2)
			      ;syy=[1,round(sz(2)/4),round(sz(2)/2),round(sz(2)*3/4),sz(2)] & syy=strtrim(string(syy),2)
			      if D.PLOT eq 0 then begin
				dxsiz=!D.x_size & xo=40 & xf=10
				dysiz=!D.y_size & yo=40 & yf=20
				if (sz(1) eq sz(2)) and (D.WUPDATE eq 2) then begin
				   if dxsiz gt dysiz then dxsiz=dysiz else dysiz=dxsiz
				endif
				erase
				if mmx gt 10^3 then ii=execute('tvscl,ALOG((CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf)+1)>1),xo,yo') $
					       else ii=execute('tvscl,     (CONGRID('+congw+',dxsiz-xo-xf,dysiz-yo-yf))     ,xo,yo')
				ii=execute('plot,W,charsize=1.2 ,xrange=[xxx(0),xxx(sz(1)-1)],yrange=[0,sz(2)-1]'+$
				           ',/nodata,position=[xo,yo,dxsiz-xf-1,dysiz-yf-1],/noerase,/device,title=titil')
			      endif else $
			      if D.PLOT ne 2 then begin
				surfbody=congw+congx+congy+',az=rz,ax=rx,xticks=4,yticks=4,zticks=1,title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
			 	surfkey ='' & surf='surface,'
				if styles(0,0) eq 4 then surfkey =''             else $
				if styles(0,0) eq 5 then surfkey =',/lego'       else $
				if styles(0,0) eq 6 then surfkey =',/horizontal'      $
				                    else surf    ='shade_surf,'
				ii=execute( surf+surfbody+surfkey )
			      endif else begin
				surfbody=congw+congx+congy+',xticks=4,yticks=4,zticks=2,xmargin=[10,1],ymargin=[4,2],title=titil'
				;surfbody=surfbody+',xtickname=sxx,ytickname=syy'
				surf    ='contour,'
				if styles(1,0) ne 1 then surfkey =',/fill,nlevels=nlv' $
				                    else surfkey =',c_colors=(indgen(nlv)+1)*(180/nlv)+50,nlevels=nlv'
				ii=execute( surf+surfbody+surfkey )
			      endelse
			   endif
			endif

	endif else if totim gt 0 then begin

		if W gt 0 then ppm=long(W*1000*100./totim)<100 else ppm=100
		wset,geo_alp(4) & trap_current=geo_alp(4)
		nk =n_elements(D)
		YYt=reform(geo_w(8 ,D))
		YYl=reform(geo_w(10,D))
		YYm=reform(geo_w(9 ,D))+YYl

		if  nk eq 1 then begin
		    YYt=[YYt,0] & YYm=[YYm,0] & YYl=[YYl,0] & D=[D,0] & endif
		sx ='d'+strtrim(string(D),2)
		if  nk eq 1 then begin nk =2  & sx(1)='  '  & endif
		ttl=    strtrim(string(round(totim/10.)/100.),2)+' Elapse sec.'

		if nk gt 8 then begin
		plot, YYl,xmargin=[2,2],ymargin=[2,2],charsize=.8,font=0,yrange=[0,100],$
		          psym=10,xticks=nk-1,xtickname=sx,title=ttl,ystyle=4,xthick=2,linestyle=1

		oplot,YYm,psym=10,linestyle=2
		oplot,YYt,psym=10,linestyle=0
		if ppm lt 100 then begin YYl(*)=ppm & oplot,YYl,thick=2 & endif

		endif else begin
		YP =[[YYl],[YYm],[YYt]]
		sy =['Command    ','Request  ','Macro']
		sz =[ ' ' , strtrim(string(ppm),2)+'%' ]
		w4d=bytscl(YP,min=0,max=100)>20
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],xticks=nk-1,xtickname=sx,shades=w4d,$
		        title=ttl,/lego,charsize=1.2,font= 0,yticks=2,ytickname=sy,zticks=1,ztickname=sz

		if ppm lt 100 then begin
		YP(*)=ppm
		surface,YP,xmargin=[4,2],ymargin=[2,2],zrange=[0,100],/lego,/noerase,$
		        xstyle=4,ystyle=4,zstyle=4,charsize=1.2,font= 0
		endif
		endelse

	endif else if totim eq 0 then begin
		if n_elements(w) gt 1 then begin
		    wset,geo_alp(4) & erase
		    wset,geo_alp(3) & erase
		    wset,geo_alp(0) & erase & tv,W
		endif else begin
		 wset,D
		 if (n_elements(w) eq 1) and (w(0) le 0) then begin
		 ;if w(0) eq 0 then did_fu=0 else did_fu=1
		 endif else begin
		  erase
		 ;did_fu=1
		  inf=2.4
		  eng=sys_dep('MACHINE') & if (eng eq 'win') then inf=3. else if (eng eq 'mac') then inf=1.5
		  geo_info(3)= geo_info(1)-geo_bxy(1)-10
		  geo_info(2)= geo_info(0)-geo_bxy(0)-10
		  wdt=20 & cz=(geo_info(0)/341.33*2) & ct=round(cz) & cz=cz<inf
		  xyouts,wdt-4,14,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,13,"Values REQUEST ",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,10,"Values REQUEST ",font=-1,charsize=cz,charthick=ct,/device,color=255,width=wdt
		  wdt=geo_info(0)*wdt
		  wdt=geo_info(0)-1-wdt-20
		  xyouts,wdt-4,44,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-3,43,"COMMAND Control",font=-1,charsize=cz,charthick=1 ,/device,color=100
		  xyouts,wdt-0,40,"COMMAND Control",font=-1,charsize=cz,charthick=ct,/device,color=255

		  xf1=(geo_info(0)*2/3) - ((geo_info(0)*2/3)-(geo_bxy(0)/2+20))/4
		  xf2=(geo_info(0)  /3) - ((geo_info(0)  /3)-(geo_bxy(0)/2+20))/4
		  yf1=70 + ((geo_info(3)-10)-(70))/4
		  yf2=40 + ((geo_info(3)-10)-(40))/4
		  plots,[xf1,geo_info(0)*2/3], [yf1,70],thick=2.,/device,color=255
		  plots,[xf2,geo_info(0)  /3], [yf2,40],thick=2.,/device,color=255
		 endelse
		endelse
	endif else if totim eq -1 then begin

		wset,W   &  erase
		xyouts,3,geo_bxy(1)-9,D,charsize=1,/device
		if n_elements(dnum) eq 1  then dw  =geo_w(13,dnum) else dw=0	    ;Delete the large Dial plot.
		if dw gt 0 then begin ii=execute('wdelete,dw')  & geo_w(13,dnum)=0 & endif

	endif else if totim eq -2 then begin

		wset, geo_alp(3)
		device,copy=[0,0, geo_bxy(0),geo_bxy(1)/2, 0,W*25]
		xyouts,0,W*25+1, D ,font=-1,charsize=1.5,charthick=2,/device,color=255

	endif else if totim eq -3 then D=[did_x,did_y,did_wd]

	if keep_w gt 0 then wset,keep_w
end

function P_GEO_Ndials & return,20 & end
;******* ************

pro GEORGEO, init=init, construct=base, timer=bs1, freq=freq, command=intxt, nowin=nowin, lim=lim, duduch=prox
;** *******
;**
;** Construct the base then initiate george (lamp startup)
;** handle a command line for instrument control (from dons)

@lamp.cbk
common c_geo
common c_geweb

	if n_elements(intxt) eq 1 then begin
	   comm=strtrim(intxt,2)
	   if strpos(strupcase(comm),'CTRL:') eq 0 then begin intxt=';' & ln=strlen(comm)
	   		comm=strmid(comm,5,ln)
			typ='PAD' & gen=geo_par2(3)
			if (geo_par2(4) eq '1') then check=1 else check=0
			if strpos(comm,'G:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								gen  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								typ  ='WEB'        & endif
			if strpos(comm,'T:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								typ  =strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								endif
			if strpos(comm,'K:')  eq 0 then begin	comm =strmid(comm,2,ln) & jj=strpos  (comm,':')
								check=strmid(comm,0,jj) & comm=strmid(comm,jj+1,ln)
								on_ioerror,mischk  & check=float(check)
								mischk:            & endif
			comm=str_sep(comm, '<br>') & if n_elements(comm) eq 1 then comm=comm(0)

			d0={GENERIC:gen,NAME:geo_par2(0),TYPE:typ,PROS:long(geo_par2(5:6))} & R=0
			R = DialControl(comm,   d=0, check=check)
			if (R lt 0) or (R gt 1)    then begin print,'error-code '+string(R)
					if geo_web then WebDo,'err','error-code '+string(R) & ENDIF
	   endif
	   return
	endif else $
	if n_elements(base) eq 1 then begin
	   Pn     =P_GEO_Ndials()
	   geo_w  =lonarr(14,Pn+1)
	   geo_vis=Pn/2 -Pn/10
	   geo_bxy=[100,50]
	   if n_elements(geo_freq) eq 0 then begin geo_freq=0 & geo_lim=0 & endif
	   bid=widget_button(base,font=ft_biggest,value='....GET DIALS....',uvalue=[-88,380,0],resource_name="geo")
	   bas=widget_base (base,/column,y_scroll=fix(lamp_siz/2.1)<395)
	   for i=1,((size(geo_w))(2))-1 do begin
		di=strtrim(string(i),2)
		if sys_dep('VERSION') lt 4.0 then bod=widget_base(bas,/column) $
		else bod  =widget_base  (bas,/column,xsize=110)
		bud       =widget_base  (bod,/row)

		if i le geo_vis+4 then begin
	 	  byd     =widget_button(bud,value='d'+di                       ,font=ft_b_normal,menu=2,resource_name="geo")
			bed3   =widget_button(byd ,value='Large Dial'		,font=ft_normal,uvalue=[-88,670,5,i])
			bed1   =widget_button(byd ,value='Reset'		,font=ft_normal,uvalue=[-88,670,1,i])
			bed4   =widget_button(byd ,value='Properties'		,font=ft_normal,uvalue=[-88,670,6,i])
			bed8   =widget_button(byd ,value='Remove'		,font=ft_normal,uvalue=[-88,670,8,i])
			bed2   =widget_button(byd ,value='History is off'	,font=ft_normal,menu=2)
			  bed21=widget_button(bed2,value='Stop recording'	,font=ft_normal,uvalue=[-88,670,2,i])
			  bed22=widget_button(bed2,value='Start recording'	,font=ft_normal,uvalue=[-88,670,3,i])
			  bed23=widget_button(bed2,value='Clear History file'	,font=ft_normal,uvalue=[-88,670,4,i])
			if i le geo_vis  then begin
			bed5   =widget_button(byd ,value='Change Plot'		,font=ft_normal,menu=2)
			  bed51=widget_button(bed5,value='-2 (no plot)'         ,font=ft_normal,uvalue=[-88,671,-2 ,i,bed5])
			  bed51=widget_button(bed5,value='-1 (in W'+di+')'      ,font=ft_normal,uvalue=[-88,671,-1 ,i,bed5])
			  bed51=widget_button(bed5,value=' 0 (scalar,image)'    ,font=ft_normal,uvalue=[-88,671,0  ,i,bed5])
			  bed51=widget_button(bed5,value=' 1 (arrow,surface)'   ,font=ft_normal,uvalue=[-88,671,1  ,i,bed5])
			  bed51=widget_button(bed5,value=' 2 (contour)'         ,font=ft_normal,uvalue=[-88,671,2  ,i,bed5])
			  bed51=widget_button(bed5,value='10 (vector)'          ,font=ft_normal,uvalue=[-88,671,10 ,i,bed5])
			  bed51=widget_button(bed5,value='20 (  ..  )'          ,font=ft_normal,uvalue=[-88,671,20 ,i,bed5])
			  bed51=widget_button(bed5,value='30'                 ,font=ft_normal,uvalue=[-88,671,30 ,i,bed5])
			  bed51=widget_button(bed5,value='50'                 ,font=ft_normal,uvalue=[-88,671,50 ,i,bed5])
			  bed51=widget_button(bed5,value='100'                ,font=ft_normal,uvalue=[-88,671,100,i,bed5])
			  bed51=widget_button(bed5,value='200'                ,font=ft_normal,uvalue=[-88,671,200,i,bed5])
			  bed51=widget_button(bed5,value='500'                ,font=ft_normal,uvalue=[-88,671,500,i,bed5])
			bed6   =widget_button(byd ,value='Own Frequency'      ,font=ft_normal,menu=2)
			  bed61=widget_button(bed6,value='0.00'               ,font=ft_normal,uvalue=[-88,670,80,i,bed6])
			  bed61=widget_button(bed6,value=' .1 '               ,font=ft_normal,uvalue=[-88,670,81,i,bed6])
			  bed61=widget_button(bed6,value=' .5 '               ,font=ft_normal,uvalue=[-88,670,82,i,bed6])
			  bed61=widget_button(bed6,value='1   '               ,font=ft_normal,uvalue=[-88,670,83,i,bed6])
			  bed61=widget_button(bed6,value='2   '               ,font=ft_normal,uvalue=[-88,670,84,i,bed6])
			  bed61=widget_button(bed6,value='4   '               ,font=ft_normal,uvalue=[-88,670,85,i,bed6])
			  bed61=widget_button(bed6,value='10  '               ,font=ft_normal,uvalue=[-88,670,86,i,bed6])
			  bed61=widget_button(bed6,value='30  '               ,font=ft_normal,uvalue=[-88,670,87,i,bed6])
			  bed61=widget_button(bed6,value='60  '               ,font=ft_normal,uvalue=[-88,670,88,i,bed6])
			  bed61=widget_button(bed6,value='240 '               ,font=ft_normal,uvalue=[-88,670,89,i,bed6])
			  bed61=widget_button(bed6,value='600 '               ,font=ft_normal,uvalue=[-88,670,90,i,bed6])
			  bed61=widget_button(bed6,value='1800'               ,font=ft_normal,uvalue=[-88,670,91,i,bed6])
			  bed61=widget_button(bed6,value='3600'               ,font=ft_normal,uvalue=[-88,670,92,i,bed6])
			endif
		endif
		bidof=0
		if (i eq geo_vis+5) and (GEORGE eq 2) then begin
		 cap=0
		 eng=sys_dep('MACHINE') & if eng eq 'win' then cap=3 else if eng eq 'mac' then cap=-2

		 bs1_t =widget_label (bod,font=ft_b_normal,value ='General Freq.' , event_pro='P_GEO_TIMER')
		 bs1_f =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_freq),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bod,font=ft_b_normal,value='Duration:')
		 bs1_d =widget_text  (bod,font=ft_propor  ,value=strtrim(string(geo_lim ),2),xsize=4+cap,ysize=1,/editable  ,resource_name="geo")
		 bact  =widget_button(widget_base(bod,/nonexclusive),font=ft_b_normal,value='no plot,resource_name="geo"')
		 widget_control,bact ,set_uvalue=[-88,660,0,0],set_button=1
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
		if i le geo_vis+4 then $
		   bidof  =widget_button(widget_base(bud,/nonexclusive),uvalue=[-88,665,i],$
						     value='on/off',font=ft_smaller)

		bedou     =widget_label (bud,value="", event_pro='P_GEO_TIMER',uvalue=i)

		geo_w(2 ,i)=bud
		geo_w(3 ,i)=bidof
		geo_w(4 ,i)=byd	;not used at this time!
		geo_w(7 ,i)=bed2
		geo_w(11,i)=bedou
		widget_control,bud  ,sensitive=0
		if i le geo_vis then geo_w(0,i)=widget_draw (bod,retain=2,xsize=geo_bxy(0),ysize=geo_bxy(1),$
							     /button_events,uvalue=[-88,670,7,i])
	   endfor

	endif else $
	if n_elements(bs1)  eq 1 then begin
		eng=sys_dep('MACHINE')
		if eng eq 'win' then begin cap= 3 & scheme=' SCHEME'        & reffre=' frequency:' & dur='Duration:'
		endif           else $
		if eng eq 'mac' then begin cap=-2 & scheme='SCHEME'         & reffre='freq:'      & dur='for:'
		endif           else begin cap= 0 & scheme=' SCHEME'        & reffre='frequency:' & dur='Duration:' & endelse

		if n_elements(lim)  eq 1 then geo_lim =lim  else geo_lim =0
		if n_elements(freq) eq 1 then geo_freq=freq else geo_freq=0
		vaf=strtrim(string(geo_freq),2) & vaf =" 0 "  &  geo_freq=0
		vad=strtrim(string(geo_lim ),2) & if geo_lim le 0 then vad=" "
		geo_onbas=[0L,0L,0L,0L]
		if GEORGE eq 1 then begin
		 bs1_1 =widget_label (bs1,font=ft_biggest ,value = scheme)
		 bs1_t =widget_label (bs1,font=ft_b_normal,value = reffre , event_pro='P_GEO_TIMER')

		 bs1_f =widget_text  (bs1,font=ft_propor  ,value=vaf,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")
		 bs1_1 =widget_label (bs1,font=ft_smallest,value='seconds')
		 bs1_1 =widget_button(widget_base(bs1,/nonexclusive),font=ft_b_normal,value='on/off',resource_name="geo")
		 bid   =widget_label (bs1,font=ft_normal  ,value='Duration:')
		 bs1_d =widget_text  (bs1,font=ft_propor  ,value=vad,xsize=5+cap,ysize=1,/editable  ,resource_name="geo")

		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t]
		 widget_control,bs1_f,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]
		 widget_control,bs1_1,set_uvalue=[-88,667,bs1_f,bs1_t,bs1_d],set_button=1
		 widget_control,bs1_d,set_uvalue=[-88,666,bs1_f,bs1_t,bs1_d]

		 geo_onbas=[bs1_f , bs1_1, bs1_d , bs1_t]
		endif
	endif else $
	if n_elements(prox)  gt 1 then begin
		geo_par2=prox
		SetDuduch,"_send", geo_par2(3,0), prox
		geo_par2=[geo_par2,string(prox)]
	endif else $
	if keyword_set(init) then begin
		setcol,27
		geo_info =lonarr(6)
		P_GEO_DISPLAY, info,0 ,-3                      ;return [did_x,did_y,did_wd]
		geo_info(0)  = info(0) & geo_info(1)=info(1)   ;r=widget_info(did_wd,/geometry)
		geo_info(5)  = did_win0
		P    =geo_bxy(0)   & N=geo_bxy(1)/2
		for i=1,((size(geo_w))(2))-1 do   begin
		    if geo_w(0,i) gt  0  then begin
			   widget_control,bad_id=ii,geo_w(0,i),get_value=j
			   geo_w(1,i)=j
			   di=strtrim(string(i),2)
			   P_GEO_DISPLAY, 'd'+di, j ,-1
		    endif
		endfor
		geo_alp =lonarr(5)
		bid  =widget_base(map=0)
	        geo_alp(0)=widget_draw(bid,retain=2,xsize=2*P,ysize=2 *N)
	        geo_alp(1)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(2)=widget_draw(bid,retain=2,xsize=  P,ysize=2 *N)
	        geo_alp(3)=widget_draw(bid,retain=2,xsize=  P,ysize=21*N)
	        geo_alp(4)=widget_draw(bid,retain=2,xsize=geo_info(0)/2+30,ysize=geo_info(1)*2/3)
		widget_control,bid,group_leader=lamp_b1,/realize
		widget_control,geo_alp(0),get_value=j & geo_alp(0)=j
		widget_control,geo_alp(1),get_value=j & geo_alp(1)=j
		widget_control,geo_alp(2),get_value=j & geo_alp(2)=j
		widget_control,geo_alp(3),get_value=j & geo_alp(3)=j
		widget_control,geo_alp(4),get_value=j & geo_alp(4)=j
		bid=bindgen(P)*2+55
		bis=bytarr(P,N)  & for i=0,n-1,2 do bis(0,i)=bid
		bid=reverse(bid) & for i=1,n-2,2 do bis(0,i)=bid
		bis=bytscl (bis)
		for i=0,N-1 do bis(P-1-abs((N-1)/2-i)/2:P-1,i)=253*0

		P_GEO_DISPLAY, did_win0, bis ,0

		if GEORGE eq 1 then geo_act=0 else geo_act=1
		if GEORGE eq 1 then P_GEO_DISPLAY, did_win0, 1 ,0

		geo_stat=1 & geo_isw=1 & geo_cur=0 & geo_seq=.0D & geo_timon=dblarr(((size(geo_w))(2))*2)
		geo_lead=lamp_b1       & geo_web=0

		if dial_ini then begin
		 for i=1,((size(geo_w))(2))-1 do begin    di=strtrim(string(i),2)
		    named=''
		    ii=execute ('if n_tags(d'+di+') gt 1 then named=d'+di+'.NAME')
		    if named ne '' then begin
			 dnum =i
			 pth  ='' & DialTag,d=dnum, tag="PATH",get=pth
			 DialInit , named,  d=dnum, path=pth, /restore
		    endif
		 endfor
		endif  else dial_ini=1
	endif else $
	if keyword_set(nowin) then begin
		Pn       =P_GEO_Ndials()    ;
		geo_freq =0                 ;General Timer
		geo_timon=dblarr((Pn+1)*2)  ;Time on Timer start process
		geo_lim  =0                 ;General Timer limit
		geo_par2 =['','','','','','-1','0'] ;Contains "dial_pad_init" table
		dial_ini =1
		geo_stat =0                 ;General Timer is on or off
		geo_act  =0                 ;0:plot Activity  1:output strings
		geo_web  =0                 ;1:outputs for web mirror
		geo_alp  =[0L,0L,0L,0L,0L]  ;BaseId  for pixmap plotting
		geo_vis  =0                 ;Visible short Dials
		geo_w    =lonarr(14,Pn+1)   ;0:drawBase    1:drawId  2:sensBase  3:OnOffButton
		                            ;4:HiLightBase 5:previous active dial (geo_cur) 6:has a dial
		                            ;7:HistoryBase 8:time in Macro 9:time in Get 10:time in Send
		                            ;11:Specific timer base  12:in the general or spec loop(2,1)
		                            ;13:large drawId
		geo_info =lonarr(6)         ;0:draw.xsize  1:draw.ysize  4:last dial scheme  5:did_win0
		geo_bxy  =[0,0]             ;short drawBase size
		geo_isw  =0                 ;0 for noWindow
		geo_cur  =0                 ;Current active Dial
		geo_onbas=[0L,0L,0L,0L]     ;BaseId for text & on/off Timer button & limit & Timer
		geo_lead =lamp_b1           ;Group Leader
		geo_seq  =.0D               ;Current Time (double flt)
	endif
end
function inx_in, INST , PATH , FILENAME , STATUS , DATP , interpolate=inter
;
; Read INX files
stat=0 & catch,stat
if stat ne 0 then begin catch,/cancel & print,string(7b),!err_string & return,1 & endif

        if n_elements(datp) gt 0 then full_call=1 $
	else full_call=0
        if   full_call eq 0 then in_file=inst $
	else in_file=filename

;	code 11 for open error
	w_out  =11
	e_out  =0
	status =11
        on_ioerror, no_f
        openr,in,in_file,/get_lun
		w_out  =14
		nzone  =intarr(6)
        	nchans =0 & nlines=0
		tit_in =' '
		tmp_ang=0.0
        	p_out  =fltarr(31)
		einc   =0.0 & qinc=0.0 & temp=0.0 & amass=0.0 & isym=0
		deltaen=0.0 & deltatau=0.0 & deltak=0.0
	
       		on_ioerror, end_f
		   i=0
		   
		   while (1) do begin
			readf,in,nlines,nzone,nchans
			readf,in,tit_in
			readf,in,tmp_ang,einc,qinc,temp,amass,isym
			readf,in,deltaen,deltatau,deltak
			tmp=fltarr(3,nchans)
			readf,in,tmp,format='(5x,f10.5,e13.5,e12.4)'
			if i eq 0 then x_buf=tmp(0,*) $
			  	  else x_buf=[[x_buf],[tmp(0,*)]]
 			if i eq 0 then w_out=tmp(1,*) $
			  	  else w_out=[[w_out],[tmp(1,*)]]
 			if i eq 0 then e_out=tmp(2,*) $
			  	  else e_out=[[e_out],[tmp(2,*)]]
			if i eq 0 then y_buf=[tmp_ang] $
			  	  else y_buf=[[y_buf],[tmp_ang]]
			i=i+1
		   endwhile
 		end_f: free_lun,in

		if (i gt 0) and (nchans gt 1) then begin

		w_out=reform(reform(w_out,nchans,i))
		e_out=reform(reform(e_out,nchans,i))
		x_buf=reform(reform(x_buf,nchans,i))
		y_buf=reform(y_buf,i)
		
		if x_buf(0) gt x_buf(1)  then x_buf=-x_buf
		sx=size(x_buf)
		if sx(0) eq 2  then begin if n_elements(inter) eq 0 then inter=1
		 if inter ne 1 then begin
				    y_buf=transpose([[y_buf],[y_buf]])
				    y_buf=congrid  (  y_buf ,nchans,i)
		 endif else begin
			  	    x_tmp=x_buf & x_buf=total(x_buf,2)/sx(2)
				    for i=0,sx(2)-1 do w_out(*,i)=interpol(w_out(*,i),x_tmp(*,i),x_buf)
		 endelse
		endif

		status=9
         	datp={x:x_buf,y:y_buf,p:fltarr(31), $
		      e:e_out,w_tit:' ',x_tit:' ',y_tit:' ',$
     		      par_txt:strarr(31),other_tit:' '}

		datp.p(8)  =tmp_ang
		datp.p(11) =temp
		datp.p(15) =amass
		datp.p(16) =1				;data read by inx_in
		datp.p(17) =1				;scale=eV
		datp.p(18) =deltatau			;channel width
		datp.p(19) =nchans
		datp.p(30) =i
		datp.p(21) =sqrt(81.799/einc)
		datp.par_txt(8)= 'Sample Angle (deg.)                 '
		datp.par_txt(11)='Sample Temperature (K)              '
		datp.par_txt(15)='Sample Mass                         '
		datp.par_txt(16)='Energy Conversion                   '
		datp.par_txt(17)='Energy Scale                        '
		datp.par_txt(18)='Channel width                       '
 		datp.par_txt(19)='Number of channels used             '
		datp.par_txt(30)='Number of angles                    '
		datp.par_txt(21)='Wavelength (angstroms)              '
		datp.w_tit= tit_in
		datp.x_tit='Energy Transfer'
		datp.y_tit='Angle'
		datp.other_tit='INX file: '+in_file

		if (datp.p(21) gt 1.) then status=0

		endif
 no_f:
        
if full_call eq 0 then give_datp,datp 
return,w_out
end
function NXmlparse, fileN, lun, tag,att,str,data, look=look
;******* *********
;**
data= 0  & lan =0
line= '' & str =[''] & tag =[''] & att =['']
ON_IOERROR,mis
if n_elements(lun) eq 0 then lun=0 & if lun eq 0 then OPENR,lun,fileN,/get_lun
ok  = 1
WHILE (ok) do begin
 READF,lun,line & line=strtrim(strcompress(line),2)
 WHILE line ne '' do begin
  bo=strpos(line,'<') & bf=strpos(line,'>') & ni=n_elements(str)-1
;*******************
;*handle xml syntax*
;*******************
  if (bo lt 0) or  (bf lt bo) then begin   str(ni)=str(ni)+line+' '  & line=''
  endif else begin      blc=strpos(line,' ',bo+2)<bf
      if blc lt bo then blc=bf     &       tag =[tag,strmid(line,bo+1 ,blc-bo-1)]
      if blc eq bf then arr=''   else      arr =     strmid(line,blc+1,bf-blc-1)
	if bo  gt 0  then str(ni)=str(ni)+strmid(line,0,bo)+' '
	att=[att,arr]  &  str=[str,'']
	ln=strlen(line)-1 & if bf eq ln then line='' else line=strmid(line,bf+1,ln-bf)
;*******************
;*handle NXml data *
;*******************
	searchATT,arr, 'type', type & if type eq '' then type='float'
	searchATT,arr, 'dims', dims & if strpos(dims,'[') eq 0 then dims=strmid(dims,1,strlen(dims)-2)
	searchATT,arr, 'file_name', fn

	if dims ne '' then begin    ii = EXECUTE("data=make_array("+dims+",/"+type+")")
	  if fn eq '' then begin            ;********** Read values in current xml file
	     READF,lun, data & ok=0
	  endif else if not look then begin ;********** Read values from "file_name"
	     ON_IOERROR,mio
	     searchATT,arr, 'code', codx
	     if strpos(fn,'.gz') lt 0 then begin
			if strpos(fn,'.txt') lt 0 then begin OPENR,lan,fn,/get_lun,/XDR      & READU,lan,data & ok=0
			endif                     else begin OPENR,lan,fn,/get_lun           & READF,lan,data & ok=0
			                          endelse
	     endif else if !version.release ge '5.3' then begin
			if strpos(fn,'.txt') lt 0 then begin OPENR,lan,fn,/get_lun,/compress & READU,lan,data & ok=0
			endif                     else begin OPENR,lan,fn,/get_lun,/compress & READF,lan,data & ok=0
			                          endelse
	     endif else print,'!!!  .gz files supported since V5.3 of Idl'
	     mio:if lan gt 0 then FREE_LUN,lan & ON_IOERROR,mis
	  endif
	endif else begin                    ;********** Read string next lines
	     searchATT, arr, 'lines', nbl
	     if nbl ne '' then begin  data=strarr(long(nbl)) & READF,lun, data & data=strtrim(data,2) & ok=0 & endif
	endelse
  endelse
 ENDWHILE
ENDWHILE
return,1
mis:if lun gt 0 then FREE_LUN,lun & lun=0
return,0
end

pro searchATT, attr, name, value
;** *********
nam=strlowcase(name) & value='' & att=strlowcase(attr)  & getquotATT, att,nam, qt,v,di
if di ge 0 then begin  nl=strlen(nam)+v   & dj =strpos(att, qt ,di+nl)
                       value=strmid(attr,di+nl,dj-di-nl) & endif & END

pro getallATT, attr, names, values
;** *********
names=[''] &   values=[''] & att=attr
WHILE att gt ' '  do  begin getquotATT, att,'', qt,v,di   &   nc=strlen(att)
      if di ge 0 then begin dj =strpos (att, qt ,di+v)    &   names=[names,strmid(att,0,di)]
                 values=[values,strmid(att,di+v,dj-di-v)] &   att  =strmid(att,dj+2,nc-dj-1)
      endif else att=''
ENDWHILE
END

pro getquotATT, att,nam, qt,v,di
;** **********
                       v=1   & nom=nam+ '='         & di =strpos(att, nom) & bi=strpos(att,nam+' =')
if (di lt 0) or ((bi ge 0) and (bi eq di-1)) then begin v=2 & nom=nam+' =' & endif
                                                      di =strpos(att, nom) & bi=strpos(att,nom+' ')
if bi eq di then begin v=v+1 & nom=nom+ ' ' & endif & bi =strpos(att, nom+'"') & qt='"'
if bi ne di then begin          qt="'"              & di =strpos(att, nom+"'") & endif
v=v+1 & END

;** ********
pro read_xml, FileName , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                         , PR=p, PV=pv, PAR_TXT=p_txt            $
                         , W_tit=wt   , X_tit=xt , Y_TIT=yt      $
                         , Z_tit=zt   , OTHER_TIT=ot , SNAP=snap $
                         , SOURCE=src , Img=immg , HIST=his

CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
STATUS=24
X=0 & Y=0 & Z=0 & E=0 & N=0 & P=0. & PV=0. & P_TXT='' & time='' & lampF=0
LIM   ="" &  WT='' & XT='' & YT='' & ZT='' & OT='' & SNAP=0 & SRC='' & HIS=''
if Data(0) eq -88 then look=1 else look=0  & Data=0
FileN =FILENAME
imm= 1 & if n_elements(immg) ne 1 then img=1 else begin
		simg=str_sep(string(immg),'.')   &  img=long(simg(0))>1
		if n_elements(simg) eq 2 then begin img=long(simg(1))>1 & imm=long(simg(0))>1 & endif
         endelse
ok =1 & NXF='XML' & tiip='UNKNOWN' & nxcur="" & nxI="" & imi =0 & imj  =0
nxdata=0 & nxmonitor=0 & nxsample=0 & nxinstrument=0 & nxbeam=0 & nxlog=0

WHILE (ok) do begin
	 ok=NXmlparse(fileN, lun, tag,att,str, value ,look=look)
		;print,'<'+tag+' '+att+'>'+str & print,value
	 jj=0
	 WHILE jj lt n_elements(tag) DO begin ON_IOERROR,misloop
	  CASE strlowcase(tag(jj)) of

	 'nxmlfile':begin	searchATT, att(jj), 'file_name' , his  & NXF='NXml'
				searchATT, att(jj), 'file_time' , time & his=his+' '+time
				searchATT, att(jj), 'instrument', ins
				searchATT, att(jj), 'user'      , src  & if ins gt "" then src=ins+" " +src
				if strpos( str(jj), 'LAMP') gt 0 then begin time=str(jj) & lampF=1  & endif
			end
	 'nxentry': begin	imi = imi+1 & if imi le imm then if str(jj) gt ' ' then  his=str(jj)
				if imi gt imm then begin ok=0 & jj=n_elements(tag)  & nxcur="Entry" & endif
			end
	 'nxdata':  begin imj = imj+1 & if imj eq img then nxdata=1 else nxdata=0
				if nxdata  then begin
				searchATT, att(jj), 'title'    , wt   & lim=str(jj) & nxcur="Data"
				searchATT, att(jj), 'sub_title', ot   & if ot  eq ''  then ot=FILENAME(0)
				searchATT, att(jj), 'source'   , hit  & if hit gt ' ' then src=hit
				searchATT, att(jj), 'param'    , hit  & if hit gt ' ' then begin p_txt=[p_txt,'(data) param =']
				                                                                 p    =[p,float(hit)] & endif
				endif & end
	 'parameters':if nxdata then begin
				cn=n_elements(value) & P=fltarr(cn) & p_txt=strarr(cn)  & lampF=1
				for j=0,cn-1 do begin  tmp=value (j)  & r=RSTRPOS(tmp,'=')>0
                                if r ge 0 then begin P(j)=FLOAT(STRMID(tmp,r+1,30))
                                                     p_txt(j)=  STRMID(tmp,0,r+1)   & endif
				endfor
			  endif
	 'var_params':if nxdata then pv= value

	 'errors':    if nxdata then e = value

	 'snapshot':  if nxdata then begin
			  endif
	 'monitors':  begin if  nxmonitor then n=value else if nxdata then if n(0) eq 0 then n=value
			  end
	 'nxinstrument': begin  nxinstrument=1 & nxcur="Instrument" & nxI="I " & end
	 'nxmonitor':    begin  nxmonitor=1    & nxcur="Monitor"  & end
	 'nxsample':     begin  nxsample=1     & nxcur="Sample"  & end
	 'nxbeam':       begin  nxbeam=1       & nxcur="Beam"  & end
	 'nxlog':        begin  nxlog=1        & nxcur="Log"  & pv= value & end

	 '/nxinstrument':begin  nxinstrument=0 & nxcur="" & nxI="" & end
	 '/nxmonitor':   begin  nxmonitor=0    & nxcur="" & end
	 '/nxsample':    begin  nxsample=0     & nxcur="" & end
	 '/nxdata':      begin  nxdata=0       & nxcur="" & end
	 '/nxbeam':      begin  nxbeam=0       & nxcur="" & end
	 '/nxlog':       begin  nxlog=0        & nxcur="" & end
	  ELSE:
	  ENDCASE

	  getallATT, att(jj),  names , values & flg=''
	  if  strpos(strlowcase(tag(jj)),'nx') eq 0 then nxcur=nxI+strmid(tag(jj),2,15)
	  FOR ii=1,n_elements(names)-1 do begin val=values(ii)
				 CASE strlowcase(names(ii)) of
				'signal':begin
				         if val eq '1' then if nxdata then begin DATA=value & flg='d' & endif
				         end
				'axis':  if nxdata then begin
				         if val eq '1'  then begin x=value & flg='1' & endif
				         if val eq '2'  then begin y=value & flg='2' & endif
				         if val eq '3'  then begin z=value & flg='3' & endif
				         endif
				'label': if nxdata then begin
				         if flg eq 'd'  then wt=wt+' '+val
				         if flg eq '1'  then xt=xt+' '+val
				         if flg eq '2'  then yt=yt+' '+val
				         if flg eq '3'  then zt=zt+' '+val
				         endif
				'units': if nxdata then begin
				         if flg eq 'd'  then wt=wt+' '+val
				         if flg eq '1'  then xt=xt+' '+val
				         if flg eq '2'  then yt=yt+' '+val
				         if flg eq '3'  then zt=zt+' '+val
				         endif
				'y_value':  if nxdata then y=float(val)
				'z_value':  if nxdata then z=float(val)
				'file_name':
				'file_time':
				'sub_title':
				'title':
				'lines':
				'size':
				'user':
				'min':
				'max':
				'dims':  if flg eq ''  then begin nc=n_elements(value)
				            if nc le 9 then begin
				               p_txt=[p_txt,strarr(nc)+tag(jj)]  & p=[p,value] & endif
				         end
				'type':  if nxdata then if flg eq 'd' then tiip=val
				 else:   begin mesi='('+nxcur+') '+names(ii) & id=strpos(p_txt,mesi)
				               id=where(id ge 0)  & if id(0) lt 0 then begin   uk=0
				                  ON_IOERROR,misF & valf=0 & valf=float(val) & uk=1 & misF:
							;ON_IOERROR,misloop
				                  if uk eq 0 then mesi=mesi+': '+val
				                  p_txt=[p_txt,mesi+' ='] & p=[p,valF]
				                  if strpos(names(ii),'monitor') eq 0 then if n(0) eq 0 then n=valF
				               endif & end
				 ENDCASE
	  ENDFOR
	  misloop:jj=jj+1
	 ENDWHILE
ENDWHILE

if (n_elements(p) gt 1) and (p(0) eq 0) then begin p_txt=p_txt(1:*) & p=p(1:*) & endif

if n_elements(Data) gt 1 then STATUS=0

 IF look then begin
      Data=[time,' ']
      Data=[Data,' SOURCE:         '+src,' '  ,' HISTORY:        '+his ,' ']
	Data=[Data,' FORMAT:         '+NXF      ,' TYPE:           '+tiip,' ',' RANGES:         '+lim ,' ']
	Data=[Data,' TITLES: '+wt,'      X: '+xt,'      Y: '+yt ,'      Z: '+zt,'  OTHER: '+ot,' ']

	Data=[Data,' PARAMETERS:',' ----------']
	for i=0,n_elements(p_txt)-1 do $
	Data=[Data,' * '+p_txt(i)+string(p(i))]
 ENDIF
 END
function vanorm, w_in, w_van, ch1,ch2
;******* ******
;**
;** Normalize W_in with Vanadium elastic peak from channel ch1 to ch2.

;** Check for consistancies
    w_out=w_in
    s_in=size(w_in) & s_vn=size(w_van) & c1=n_elements(ch1) & c2=n_elements(ch2)
    if (c1 le 0) then ch1=1
    if (c2 le 0) then ch2=s_vn(1)

    if (s_in(0) eq 2) and (s_vn(0) eq 2)   then begin
	if (s_in(2) eq s_vn(2))		   then begin
	    if (ch1 le ch2) and (ch1 gt 0) and (ch2 le s_vn(1)) then begin

		TAKE_DATP,P
		w0=total(w_van(ch1-1:ch2-1,*),1) >1
		w0=max(w0)/w0

		for i=0,s_in(2)-1 do w_out(*,i)=w_in(*,i)*w0(i)
		
		IF n_elements(P.e) eq n_elements(w_in) then $
		for i=0,s_in(2)-1 do P.e(*,i)  =P.e(*,i) *w0(i)

		P.x_tit=P.x_tit+' vanorm used'
		GIVE_DATP,P

    	    endif else print, string(7b)+' Inconsistant channels ......' 
    	endif     else print, string(7b)+' Inconsistant angles ......'
     endif        else print, string(7b)+' Inconsistant Workspace dimensions ......'

return,w_out
end
function bsnorm, w_in
;******* *****
;**
;** Normalize W_in with monitor spectrum for in10, in16, in13

    w_out=float(w_in)
    s    =size (w_in)

;** Check for consistancies
    if (s(0) gt 0) and (s(0) lt 3) then begin 
	TAKE_DATP,P
	sp=size(P.n)
	P.n=P.n>1
;**	Normalize
	if s(0) eq 2 then begin
          if (s(1) eq sp(1)) or sp(0) eq 0 then $
			for i =0,s(2)-1 do w_out(0,i)=w_out(*,i)/P.n $
	  else		for i =0,s(2)-1 do w_out(0,i)=w_out(*,i)/P.n(i)
	endif
	if s(0) eq 1 then 		   w_out     =w_out     /P.n

;**	Errors
	if n_elements(P.e) eq n_elements(w_in) then e_out=P.e else e_out=sqrt(w_in)
	if s(0) eq 2 then begin
          if (s(1) eq sp(1)) or sp(0) eq 0 then $
			for i =0,s(2)-1 do e_out(0,i)  =e_out(*,i)/P.n $
	  else		for i =0,s(2)-1 do e_out(0,i)  =e_out(*,i)/P.n(i)
	endif
	if s(0) eq 1 then 		   e_out       =e_out     /P.n

	P.n(*)=1
	P.x_tit=P.x_tit+' normalized'
	MOD_DATP ,P, 'E', e_out
	GIVE_DATP,P
    endif

return,w_out
end
;			GKFIT
; A lamp interface to perform fits on plot.
;
; Fitit procedures were developped by Don Kearley
; Gfit was developped, improved and corrected by :
;					Don Kearley
;					Didier Richard
;					Stephane Thiers
;					Romuald Jouffrey
; During 1995-1996 
;
; This file contains both original fitit.pro and gfit.pro
; Version 1.14		Date: 6/10/96
; Modification History:
; gjk 22/9/96: Common gc_width_factor added with gw_fac and lw_fac. 
;	These take account width as sigma or real width. 
;	For sigma:      gw_fac = 0.5,    lw_fac=1.0
;	For real width: gw_fac = 2sqrt2, lw_fac=0.5
; gjk 22/9/96: If width or intensity set by cursor, g_resid=1.0e12
; gjk 23/9/96: Modified routine adapte to:
;		set symbol plotting if less than 200 points
;		set symbol size according to number of points
;		set error plotting if errors are present
;		to include most of the actual plotting:
;		plot_flag=0 no plot, 
;		         =1 plot all
;			 =2 no overplot
;			 =3 plot,/nodata
;gjk 1/10/96:  Change to middle mouse button for peak definition. Something
;              odd about event 2 2 with left button?
;gjk 5/10/96:  Derivatives for height corrected, and refienement altered,
;              now: ncycles of dumb routine with initial step decreasing
;                   with ncycles.
;              One cycle of derivative method, but 2 if ncycles > 1.
;gjk 6/10/96   Flag peaks with negative height or width with peak_neg equal
;              to offending peak number (0 if ok) and ht_or_wdth = 1 for height
;              and 2 for width. Set in sum_fit.
;gjk 10/10/96  Flat and sloping bg added when peak defined with mouse
;
;did 08/08/02  Detail balance added.
;did 09/08/02  scalling on X and Y is now possible.
;
; ***************************** Widgets Creating Procedure
; GFIT				Create main GKFIT interface
; CREER_EXCL, id		Create Excluding zone interface
; CREER_VIEW, id		Create viewing zone interface
; ***************************** Event processing procedures
; GFIT_EVENT		,Event
; TRAITVIEW_EVENT 	,Event
; TRAITEXCL_EVENT 	,Event
; ***************************** functions of this files are :
; JFIT		,x,y,w,a,stp,siga,g_ncycles,npk,poids
; GENFIT	,X,Y,W,A,stp,npk,resid,poids
; CALCULATE_ERROR,modele
; BELONG_TO	,elem,inter
; GK_FIT	,workspace
; ***************************** Procedures of this files are :
; CREATE_COMMONS
; GAUSS		,x,a,f
; LORENTZ	,x,a,f
; SUM_FIT_FCT	,x,a,f,g_npeaks,pder
; FITIT		,g_npeaks,w_in,w_out,...
; ADAPTE	,x_to_plot,w_to_plot
; AFF_EXCL	,excl_param
; DO_FIT	,option
; GET_PARAM	,g_parameters,idx,p1,p2,p3
; GFIT_HELP	, dummy, formu, formt
; GK_INITIALIZE
; GK_WARNING	,excl_param,viewarr
; PARAMETER_MENU,Ev
; PLOT_SUBF	,g_npeaks,g_parameters,x_ni,g_fct_type
; PUT_TIT	,x_dats,y_dats,f_tit,fx_tit,fy_tit
; PUT_VALS	,x_dats,y_dats,f_dats,plt_dev,poids,lamp_siz
; PRINT_VALS	,x_dats,y_dats,f_dats,plt_dev,poids
; READ_PAR_VALS
; SET_GFIT_PARAM,w,p,Fct_Type=ft
; WRITE_PAR_VALS
; WRITE_PAR_VALS_2
; GFIT		,GROUP=Group
; ERROR_MSG	,Error_Number
; ***************************** Little explanation on variables
; - Local variables are normaly named  			(ex. idx)
; - Each gkfit shared variable begins with g_ 		(ex. g_parameters)
; - gw_ stands for gkfit Widgets identifier variables	(ex. gw_base)
;
; Variables are ALWAYS lowercase, IDL Instructions are ALWAYS uppercase
; Keywords in IDL instructions are ALWAYS Capitalized.
; If you try this, you keep it ... very helpfull in reading ...

;===============================================================================
PRO create_commons				; ==============================
;===============================================================================
; Just to create correct commons while compiling. Explains also variables

COMMON gc_save,		keepw, 		$ ; keep w_ni for cutting
			keepe,		$ ; keep errors     ''
			w_ni,		$ ; input Workspace
			x_ni, 		$ ; input X
			e_ni,           $ ; input errors
			nw_ni,		$ ; in Workspace number
			nwt_in,		$ ; input Workspace number (str)
			nw_out,		$ ; out Workspace number
			sw_ni		  ; Size of input Workspace 

COMMON gc_data,		g_plot_wid, 	$ ; plot area id
			g_old_plot_wid, $ ; keep plot area id
			g_fct_name,	$ ; Name of the fitted function
			g_fct_type,	$ ; Array of function type for each peak
			g_npeaks,	$ ; Peak(s) number
			g_pk_nb,	$ ; Current peak number
			g_nb_pk_max,	$ ; Maximum number of peaks
			g_ncycles,	$ ; Cycle(s) number
			g_largeur,	$ ; Array of consecutive distances
			g_resid,	$ ; the residu after fitting
			g_print_nb,	$ ; Print filename incremental variable (Fix)
			g_step,		$ ; Array of extended parameters
			g_error, 	$ ; Errors on parameters
			g_tx_par, 	$ ; Tripx parameters string array
			g_parameters,	$ ; Array for Pos,Int&Width
			g_char		  ; for each defined peak plus at last
					  ; idx background and slope

					  ; ctrl_panel widget id
COMMON gc_cp,		cp_nb, 		$ ; Widget Id 
			cp_bck,	 	$ ; 	
			cp_pos, 	$ ;  
			cp_hgt,  	$ ; 
			cp_wid,  	$ ; 
			cp_pf,  	$ ; 
			cp_hf,  	$ ; 
			cp_wf,  	$ ; 
			cp_fb,  	$ ; 
			cp_sb,  	$ ; 
			cp_fbf,  	$ ; 
			cp_sbf  	  ; 

COMMON gc_flags,	g_bg_but,	$ ; State of background button
			g_show_subfct,	$ ; if set, subfunctions are plotted
			g_tripx, 	$ ; if set, tripx mode
			g_ctrl_panel, 	$ ; if set, ctrl_panel mode
			g_afitisdone	  ; set if a fit was done, for print fct

COMMON gc_wid,		gw_cycle_lab, 	$ ; Widget Id of cycle label
			gw_cut_slider,	$ ; Widget Id of cutting slider
			gw_cut_label,	$ ; Widget Id of cutting label
			gw_peak_but,	$ ; Array of widget id (peak buttons)
			gw_choice_but,	$ ; Widget Id of choice button
			gw_pk_slider,	$ ; Widget Id of peak slider
			gw_view_base,	$ ; Widget Id of view base
			gw_excl_base,	$ ; Widget Id of exclude base
			gw_pos_text,	$ ; Widget Id of position field text 
			gw_pos_pop,	$ ; Widget Id Array of menu
			gw_int_text,	$ ; Widget Id of integral text field 
			gw_int_pop,	$ ; Widget Id Array of menu
			gw_wdt_text,	$ ; Widget Id of width text field 
			gw_wdt_pop,	$ ; Widget Id Array of menu
			gw_fbg_text,	$ ; Widget Id of flat bg text field 
			gw_fbg_pop,	$ ; Widget Id Array of menu
			gw_sbg_text,	$ ; Widget Id of slope bg text field 
			gw_sbg_pop,	$ ; Widget Id Array of menu
			gw_resid_lab,	$ ; Widget Id of resid label
			gw_plot_area,	$ ; Widget Id of plot drawing area
			gw_err_lab,	$ ; Widget Id of error label
			gw_gkfit_base,	$ ; Widget Id of gkfit base
			gw_type_but,	$ ; Widget Id array of pop up menu button
			gw_bgfixed,	$ ; Widget Id of fixed background button
			gw_pk_no,	$ ; Widget Id of peak number label
			gw_get_but	  ; Widget Id of get button

COMMON gc_fit_excl,	gw_excl_but,	$ ; 
			bb1,		$ ; 
			bb2,		$ ; 
			intv_no,	$ ; 
			excl_widge,	$ ; 
			intv_nb,	$ ;
			ok_but,		$ ; 
			excl_param,	$ ; 
			max_nb_int	  ; 

COMMON gc_fit_view,	viewarr,	$ ; Array of view zone data
			no_zone,	$ ; 
			x_min,		$ ; 
			x_max,		$ ; 
			y_min,		$ ; 
			y_max,		$ ;
			sauv		  ;
			
COMMON gc_width_factor,  gw_fac, lw_fac

COMMON gc_negative, ht_or_wdth,peak_neg

COMMON gc_dids, ws_in_r,free, gw_temp, gw_bose, bose, curpic, debal, gw_mimi,mimirange,mimion, ximion,gx_mim1

END

;===============================================================================
pro Parameter_menu, Ev						; ==============
;===============================================================================
COMMON gc_wid
COMMON gc_data
COMMON gc_flags

fixed=0
IF Ev(1) EQ 0 then if g_bg_but EQ 1 then g_bg_but=0 else g_bg_but=1
IF Ev(1) GE 1 AND Ev(1) LE 5 THEN BEGIN
    IF Ev(1) eq 1 THEN gw_pop=gw_pos_pop
    IF Ev(1) eq 2 THEN gw_pop=gw_int_pop
    IF Ev(1) eq 3 THEN gw_pop=gw_wdt_pop
    IF Ev(1) eq 4 THEN gw_pop=gw_fbg_pop
    IF Ev(1) eq 5 THEN gw_pop=gw_sbg_pop
	    IF Ev(2) eq 0 THEN error_msg, 10		
	    IF Ev(2) eq 1 THEN BEGIN
		WIDGET_CONTROL, bad_id=i, gw_pop(Ev(2)), Get_Value=V
		IF STRPOS(V, 'Un') ge 0 THEN $
		    V=STRMID(V, 2, STRLEN(V)) $
		ELSE BEGIN
		    V='Un'+V & fixed=1
		ENDELSE
		WIDGET_CONTROL, bad_id=i, gw_pop(Ev(2)), Set_Value=V			    
	    ENDIF ELSE BEGIN
		IF Ev(1) GE 1 AND Ev(1) LE 3 THEN BEGIN
		    ; event generated by position, height width button
		    WIDGET_CONTROL, bad_id=i, gw_pop(2), Get_Value=V
		    IF STRLEN(V) GT 15 then V=STRMID(V, 0, 15)
		    IF Ev(2) NE 9 THEN BEGIN
			fixed=1
			WIDGET_CONTROL, bad_id=i, gw_pop(2), $
			    Set_Value=V+' '+STRTRIM(STRING(Ev(2)-2), 2)+' '
		    ENDIF ELSE WIDGET_CONTROL, bad_id=i, gw_pop(2), Set_Value=V
		ENDIF
	    ENDELSE
str=""
WIDGET_CONTROL, bad_id=i, gw_pop(0), Get_Value=str
IF fixed eq 1 THEN BEGIN
    if STRPOS(str, ' fx ') LT 0 THEN str=STRMID(str, 0,  STRPOS(str, '    '))+' fx '
ENDIF ELSE BEGIN
    p=STRPOS(str, ' fx ')
    if p GE 0 then str=STRMID(str,0, p)+'    ' 
ENDELSE
WIDGET_CONTROL, bad_id=i, gw_pop(0), Set_Value=str
ENDIF
read_par_vals
g_resid=1.0e12
END

;===============================================================================
FUNCTION jfit,x,y,w,a,stp,siga,ncycles,npk,poids		; ==============
;===============================================================================
;
; Free fall minimisation routine gjk March 1994
; Treats one parameter at a time: shifts value, if better then shifts
; twice as much, if worse shifts back half as much. Halts for each 
; parameter when change in residual is less than "tiny". 
; When all parameters are done this is one cycle. Repeated for ncycles.

 COMMON gc_negative

tiny=0.005
pc100=SQRT(TOTAL(y^2))
nvars=npk*3+2
nquit=2000
f=x

IF ncycles EQ 0 THEN BEGIN
    Sum_fit_fct,x,a,f,npk,dummy_par ;fifth parameter is not used here
    siga=100.0*SQRT(TOTAL(ABS(y-f)^2*poids))/pc100
    RETURN,f
ENDIF	

;.......Start loop round cycles 

FOR kk=1,ncycles DO BEGIN
    ;.......Get starting residual
	Sum_fit_fct,x,a,f,npk,dummy_par	;fifth parameter is not used here
    best=sqrt(total(abs(y-f)^2*poids))/pc100
    old_dify=0.0
    first_step=0.1/(kk^2)
    ;.......Start loop round each parameter
    FOR np=1,nvars DO BEGIN
	IF stp(np-1) gt 0 THEN BEGIN
	    ;.......Set up best value of parameter, default change in residual,
	    ;.......and initial shift (10% of parameter value)
	    bestp=a(np-1)
	    difydify=1.0
	    shifty=a(np-1)*first_step
	    a(np-1)=a(np-1)+shifty
	    ;.......Endless loop to minimise, quit after nquit tries and go home
	    iquit=0
	    WHILE abs(difydify) gt tiny DO BEGIN
		iquit=iquit+1
		if iquit gt nquit THEN return,f
		Sum_fit_fct,x,a,f,npk,dummy_par	;fifth parameter is not used here
		if peak_neg gt 0 then return,f
		chsq=sqrt(total(abs(y-f)^2*poids))/pc100
		dify=best-chsq
		difydify=old_dify-dify
		old_dify=dify
		;.......keep best value of parameter
		if chsq lt best THEN BEGIN
		   best=chsq
		   bestp=a(np-1)
		   shifty=shifty*2.
		endif
		if dify lt 0.0 THEN shifty=-shifty/2.0
		a(np-1)=bestp+shifty
		shifty=abs(shifty)
	    ENDWHILE
	    a(np-1)=bestp
	ENDIF ELSE BEGIN
	    ;.......Fixed or tied parameters
	    IF stp(np-1) lt 0 THEN BEGIN
		;Tie to which peak?
		n_piv=abs(stp(np-1))
		;What is current peak number?
		n_peak=fix((np-1)/3)
		ikind=np-(n_peak*3)
		a(np-1)=a((n_piv-1)*3+(ikind-1))
	    ENDIF
	ENDELSE
    ENDFOR

ENDFOR
Sum_fit_fct,x,a,f,npk,dummy_par	;fifth parameter is not used here
siga=100.0*SQRT(TOTAL(ABS(y-f)^2*poids))/pc100
return,f
END

;===============================================================================
FUNCTION genfit,X,Y,W,A,stp,npk,resid,poids 				; ======
;===============================================================================
;Doctored version of curvefit gjk March 95
;

;ON_ERROR,2		;return to caller if error ***removed gjk
yfit=fltarr(N_ELEMENTS(x))
nvars=npk*3+2
a=1.*a		;make params floating
nterms=N_ELEMENTS(a)	;# of params.
nfree=(N_ELEMENTS(y)<N_ELEMENTS(x))-nterms ;degs of freedom
if nfree le 0 THEN error_msg, 8
if nfree le 0 THEN return,yfit
flambda=0.001		;initial lambda
diag=indgen(nterms)*(nterms+1) ;subscripts of diagonal elements
total_y2=total(y^2)
pc100=sqrt(total_y2)
end_iter=total_y2/1.0e7/nfree
iter=0
while (iter le 20) DO BEGIN ;iteration loop, evaluate alpha and beta matricies.
    iter=iter+1
    Sum_fit_fct,x,a,yfit,npk,pder
    beta=(y-yfit)*w # pder
    alpha=transpose(pder) # (w # (fltarr(nterms)+1)*pder)
    chisq1=total(w*(y-yfit)^2*poids)/nfree ;present chi squared.

    ; if a good fit, no need to iterate
    IF chisq1 lt end_iter THEN BEGIN
	sigmaa=fltarr(nterms)	;return all 0's
	RETURN, yfit
    ENDIF

    ; invert modified curvature matrix to find new parameters.
    iescape=0
    REPEAT BEGIN
	c=SQRT(alpha(diag) # alpha(diag))
	iescape=iescape+1
	array=alpha/c
	array(diag)=array(diag)*(1.+flambda)		
	array=INVERT(array)
	b=a+(array/c # TRANSPOSE(beta)) ;new params
	    FOR np=1,nvars DO BEGIN
		IF stp(np-1) eq 0 THEN b(np-1)=a(np-1)
		;fixed or tied parameters
		if stp(np-1) lt 0 THEN BEGIN
		    ;tie to which peak?
		    n_piv=abs(stp(np-1))
		    ;what is current peak number?
		    n_peak=fix((np-1)/3)
		    ikind=np-(n_peak*3)
		    b(np-1)=b((n_piv-1)*3+(ikind-1))
		ENDIF
	    ENDFOR
	    Sum_fit_fct,x,b,yfit,npk,dummy_par	;fifth parameter is not used here
	    chisqr=TOTAL(w*(y-yfit)^2*poids)/nfree ;new chisqr
	    flambda=flambda*10.	;assume fit got worse
	    IF iescape gt 200 THEN RETURN,yfit
    ENDREP UNTIL chisqr le chisq1

    flambda=flambda/100.    	;decrease flambda by factor of 10
    a=b			  	;save new parameter estimate.	
    IF ((chisq1-chisqr)/chisq1) le .001 THEN iter=21  
endwhile

done:   pc100=SQRT(TOTAL(y^2*poids))
	resid=100.0*SQRT(TOTAL((y-yfit)^2*poids))/pc100
	RETURN,yfit		;return result
END

;===============================================================================
PRO Gauss,x_vector,p1,p2,p3,peak,partial_deriv			; ==============
;===============================================================================
; Define in peak a Gaussian on parameters p1 (pos),p2 (ht), p3 (wdth) into
; array peak. If partial_deriv parameters is done, partial_deriv contains
; partial_deriv for each parameters.
COMMON gc_width_factor
COMMON gc_dids

p2_tmp=p2*p3*2.50663		; compute integral for p2 height
z=(x_vector-p1)/p3
z2= (z^2) <15.
peak=p2_tmp*exp(-gw_fac*z2)/p3/2.50663
peakt=peak

temp=0 & det_bal=1. & peaks=0 & zs=0 & z2s=0 & expzs=0

if bose(curpic-1) then begin
   widget_control,gw_temp,get_value=tmpt & tmpt=tmpt(0)
   on_ioerror,mistmpt & tmpt=float(tmpt) & temp=tmpt & mistmpt:
endif
if temp gt 0 then begin                  ;STRUCTURE FACTOR ASKED (det_bal)
	w_t=x_vector/temp*11.6
	e_w_t=EXP(-w_t)
	det_bal=w_t*0+temp/11.6 & debal=det_bal(0)
	idx=where(abs(w_t) gt 0.0005)
	if idx(0) ge 0 then det_bal(idx)=w_t(idx)/(1.-e_w_t(idx))
	
	zs   =(x_vector+p1)/p3 & z2s= (zs^2) <15. ;symetric
	expzs=exp(-gw_fac*z2s)                    ;symetric
	peaks=p2_tmp*expzs/p3/2.50663             ;symetric
        peak =peak+peaks                          ;symetric
	peak =peak*det_bal
endif

IF N_PARAMS() GT 5 THEN BEGIN
    if gw_fac gt 0.5 then new_p3=p3*0.353553 else new_p3=p3
    partial_deriv=FLTARR(N_ELEMENTS(x_vector),3)           ; define partial_deriv array
    partial_deriv(*,0)=2.*gw_fac/new_p3*(peakt*z -peaks*zs) *det_bal ; partial deriv % p1
    partial_deriv(*,1)= (exp(-gw_fac*z2)+expzs)             *det_bal ; partial deriv % p2
    partial_deriv(*,2)=2.*gw_fac/new_p3*(peakt*z2+peaks*z2s)*det_bal ; partial deriv % p3
ENDIF
END

;===============================================================================
PRO Lorentz,x_vector,p1,p2,p3,peak,partial_deriv		; ==============
;===============================================================================
; Define in peak a Lorentzian on parameters p1 (pos),p2 (ht), p3 (wdth) into
; array peak. If partial_deriv parameters is done, partial_deriv contains
; partial_deriv for each parameters.
COMMON gc_width_factor
COMMON gc_dids

if lw_fac lt 1. then new_p3=p3*0.5 else new_p3=p3

p2_tmp=p2*new_p3*!PI			; compute integral for p2 height
xvt=(x_vector-p1)
peak=p2_tmp/(1+(xvt/new_p3)^2)/new_p3/!PI
peakt=peak

temp=0 & det_bal=1. & peaks=0 & xvs=0

if bose(curpic-1) then begin
   widget_control,gw_temp,get_value=tmpt & tmpt=tmpt(0)
   on_ioerror,mistmpt & tmpt=float(tmpt) & temp=tmpt & mistmpt:
endif
if temp gt 0 then begin                  ;STRUCTURE FACTOR ASKED (det_bal)
	w_t=x_vector/temp*11.6
	e_w_t=EXP(-w_t)
	det_bal=w_t*0+temp/11.6 & debal=det_bal(0)
	idx=where(abs(w_t) gt 0.0005)
	if idx(0) ge 0 then det_bal(idx)=w_t(idx)/(1.-e_w_t(idx))
	
	xvs =(x_vector+p1)                             ;symetric
        peak=peak+p2_tmp/(1+(xvs/new_p3)^2)/new_p3/!PI ;symetric
	peak=peak*det_bal
endif

IF N_PARAMS() GT 5 THEN BEGIN
    partial_deriv=FLTARR(N_ELEMENTS(x_vector),3); define partial_deriv array
    partial_deriv(*,0)=2./p2/new_p3^2 *( xvt*peakt ^2 - xvs*peaks ^2)*det_bal ;% p1
    partial_deriv(*,1)=   p2*(peakt+peaks)                           *det_bal ;% p2
    partial_deriv(*,2)=2./p2/new_p3^2 *((xvt*peakt)^2 +(xvs*peaks)^2)*det_bal ;% p3
ENDIF
END

;===============================================================================
PRO Sum_fit_fct,x,a,f,npk,pder					; ==============
;===============================================================================
; defines npk 'fct type' plus flat and sloping background
; parameters go pos,ht,wdth in array a

COMMON gc_data
COMMON gc_negative
COMMON gc_dids

nx =N_ELEMENTS(x)
pder=fltarr(nx,N_ELEMENTS(a))	; jacobienne
f(*)=0.0
peak=f
ht_or_wdth=0
peak_neg=0
FOR i=0,npk-1 DO BEGIN
    peak(*)=0.0 & ind=i*3
    p1=a(ind) & p2=a(ind+1) & p3=a(ind+2)
    curpic=i+1
    CALL_PROCEDURE, g_fct_type(i),x,p1,p2,p3,peak,partial_deriv
    if (p2 lt 0.0) or (p3 lt 0.0) then begin
       peak_neg=i+1
       if (p2 lt 0.0) then ht_or_wdth=1
       if (p3 lt 0.0) then ht_or_wdth=2
    endif
    f =f+peak
    pder(*,ind)  =partial_deriv(*,0)
    pder(*,ind+1)=partial_deriv(*,1)
    pder(*,ind+2)=partial_deriv(*,2)
ENDFOR

ilast=npk*3-1		; Add flat and sloping bg
get_bckg, npk, a, bbb, sss
f=f+bbb+sss*x

pder(*,ilast+1)=1	;.....Get partials for backgrounds
pder(0,ilast+2)=x
END

;===============================================================================
PRO fitit,	npeaks,	w_in, w_out, g_parameters, x_ci,$	; ==============
		ncycles,resid,g_step,gw_resid_lab,$		; ==============
		excl_param, poids				; ==============
;===============================================================================

;gjk April 1995

COMMON gc_save
COMMON gc_negative
peak_neg=0
npk	 =npeaks
tiny     =1.0e-4
g_step   =STRTRIM(g_step,2)
parstep  =fltarr((npk*3)+2)
wts	 =w_in
wts(*)   =1.0
size_of_x=N_ELEMENTS(x_ci)

;... calcul de la fonction poids associee a excl_param : (version zone de fit)
;on met 0 en dehors des intervalles entres, ie 1 dans les intervalles entres
poids=fltarr(size_of_x)
for i=1,N_ELEMENTS(excl_param)/2 DO BEGIN
    ;inclusion de l'intervalle [excl_param(2*i-2) , excl_param(2*i-1)] : 
    eps=abs((x_ci(size_of_x-1)-x_ci(0)))/(size_of_x-1) ; eps=distance moyenne 
    ; entre deux elements de x_ci
    FOR j=0,size_of_x-1 DO BEGIN
	IF ((x_ci(j) ge excl_param(2*i-2)) AND (x_ci(j) le excl_param(2*i-1)))$
	    THEN poids(j)=1
    ENDFOR  
ENDFOR
;... fin du calcul de la fonction poids associee a excl_param 

;........Copy across parameters and steps
FOR nvb=0,(npk*3)+1 DO BEGIN
    parstep(nvb)=1.
    ;do we know the step?
    IF STRPOS(g_step(nvb),'f') ge 0 THEN parstep(nvb)=0. ELSE BEGIN
	FOR jd=1,npk DO BEGIN
	    IF float(jd) eq float(g_step(nvb)) THEN BEGIN
 		  parstep(nvb)=-float(jd)
 	    ENDIF	
	ENDFOR
    ENDELSE 
ENDFOR

params=FLTARR((npk*3)+2)
params(0:(npk*3)+1)=g_parameters(0:(npk*3)+1)

if ncycles eq 0 then begin
    w_out=jfit(x_ci,w_in,wts,params,parstep,resid,ncycles,npk,poids)
endif else begin
    o_pars=params
    o_resid=resid
    t=systime(1)
    ; Dumb shifting routine to get it about right, ncycles times
    w_out=jfit(x_ci,w_in,wts,params,parstep,resid,ncycles,npk,poids)
   ; Hope that we are close enough for derivatives, do it twice if ncycles > 1
    if peak_neg eq 0 then begin
       w_out=genfit(x_ci,w_in,wts,params,parstep,npk,resid,poids)
       if ncycles gt 1 then $
       w_out=genfit(x_ci,w_in,wts,params,parstep,npk,resid,poids)
    endif
    IF (resid ge o_resid) or (peak_neg gt 0) THEN BEGIN
	resid=o_resid & params=o_pars
    ENDIF
    old_g=g_parameters
    g_parameters(0:(npk*3)+1)=params(0:(npk*3)+1)
endelse
END

; ************ END OF FITIT **********

;===============================================================================
FUNCTION calculate_error, modele					; ======
;===============================================================================
; retourne un vecteur contenant les erreurs faites sur les parametres
; de la fonction approximante.(cf. "variance-covariance matrix
; determination in non-linear least squares fitting" by R.F. Pettifer)

COMMON gc_data
COMMON gc_save
donnees=w_ni
points_mes=x_ni	

tiny=1e-10
m=N_ELEMENTS(points_mes)	; nombre de mesures
nvarf=0
FOR i=0,3*g_npeaks+1 DO BEGIN
    IF STRPOS(g_step(i),'f') ge 0 or (abs(g_parameters(i)) le tiny) THEN BEGIN
	nvarf=nvarf+1
	IF N_ELEMENTS(repf) eq 0 THEN repf=[i] ELSE repf=[repf,i]
    ENDIF
ENDFOR
IF N_ELEMENTS(repf) ne 0 THEN repfkept=repf
n=3*g_npeaks+2-nvarf		; nb de variables non fixees du modele
f=modele-donnees
s=total(f^2)
;... calcul de la jacobienne J: appel aux procedures de fitit
Sum_fit_fct,points_mes,g_parameters,f,g_npeaks,J
J=transpose(J)
J=J(0:3*g_npeaks+1,*)
nj=3*g_npeaks+2    ; nb de colonnes de J
FOR i=0,nvarf-1 DO BEGIN
    IF (repf(i) eq 0) THEN BEGIN	;cas ou on enleve la 1e colonne
	J=J(1:nj-1,*)
    END ELSE IF (repf(i) eq nj-1) THEN BEGIN	;cas ou on enleve la derniere
						;colonne
	J=J(0:nj-2,*)
    END ELSE BEGIN
	J=[J(0:repf(i)-1,*) , J(repf(i)+1:nj-1,*)]
    ENDELSE
    repf=repf-1
    nj  =nj-1
ENDFOR
; le J obtenu apres call_procedure etait la transposee de la jacobienne
G=2*j#transpose(J)	; produit matriciel !!
H=nr_invert(G)	; inversion matricielle !!
sigcarre=2*S/(m-n)*H
diag =fltarr(n)
FOR i=1,n DO BEGIN
    diag(i-1)=sigcarre(i-1,i-1)
ENDFOR
g_error(0)=sqrt(diag)
IF N_ELEMENTS(repf) ne 0 THEN BEGIN
    error2=fltarr(N_ELEMENTS(g_error))
    j=0 & k=0
    FOR i=0,N_ELEMENTS(error2)-1 DO BEGIN
	IF N_ELEMENTS(repfkept) gt j THEN IF repfkept(j) eq i THEN BEGIN
	    error2(i)=0.0
	    j=j+1
	ENDIF ELSE BEGIN
	    error2(i)=g_error(k)
	    k=k+1
	ENDELSE
    ENDFOR
g_error=error2
ENDIF
RETURN, g_error
END

;===============================================================================
PRO adapte 	,x_to_plot,w_to_plot,w_out,plot_flag, e_to_plot	; ==============
;===============================================================================
; Adapt vector to current view zone

common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
COMMON gc_save
COMMON gc_data
COMMON gc_wid
COMMON gc_fit_view
COMMON gc_fit_excl
COMMON gc_dids

; Adapt vector to current plot zone
		noxrange=1
		if ximion then begin
		   widget_control,gx_mim1,get_value=tmpa  & tmpa=str_sep(tmpa(0),',')
		   if n_elements(tmpa) lt 2 then begin tmpb=tmpa & tmpa='Min' & endif else begin tmpb=tmpa(1) & tmpa=tmpa(0) & endelse
		   if strpos(strlowcase(tmpa),'min') ge 0 then tmpa=min(x_ni)
		   if strpos(strlowcase(tmpb),'max') ge 0 then tmpb=max(x_ni)
		   on_ioerror,misximi & tmpa=float(tmpa) & tmpb=float(tmpb)
		   if tmpb gt tmpa then begin noxrange=0 & ximirange=[tmpa,tmpb] & viewarr(0:1)=ximirange & endif
		   misximi:
		endif
		noyrange=1
		if mimion then begin
		   widget_control,gw_mimi,get_value=tmpa  & tmpa=str_sep(tmpa(0),',')
		   if n_elements(tmpa) lt 2 then begin tmpb=tmpa & tmpa='Min' & endif else begin tmpb=tmpa(1) & tmpa=tmpa(0) & endelse
		   if strpos(strlowcase(tmpa),'min') ge 0 then tmpa=min(w_ni)
		   if strpos(strlowcase(tmpb),'max') ge 0 then tmpb=max(w_ni)
		   on_ioerror,mismimi  & tmpa=float(tmpa) & tmpb=float(tmpb)
		   if tmpb gt tmpa then begin noyrange=0 & mimirange=[tmpa,tmpb] & viewarr(2:3)=mimirange & endif
		   mismimi:
		endif
ind =where((x_ni ge viewarr(0)) AND (x_ni le viewarr(1)) AND $
		(w_ni ge viewarr(2)) AND (w_ni le viewarr(3)), nb_pt1)

IF (nb_pt1 eq 0) THEN BEGIN
    error_msg, 1
    viewarr(0)=MIN(x_ni,MAX=ma) & viewarr(1)=ma
    viewarr(2)=MIN(w_ni,MAX=ma) & viewarr(3)=ma
    x_to_plot =x_ni
    w_to_plot =w_ni
    if n_elements(e_ni) gt 1 then e_to_plot=e_ni
ENDIF ELSE BEGIN
    x_to_plot =x_ni(ind) ; WE USE XRANGE !!!
    w_to_plot =w_ni(ind) ; WE USE YRANGE !!!
    if n_elements(e_ni) gt 1 then e_to_plot=e_ni(ind)
ENDELSE
    sym_test=size(x_to_plot)
    if sym_test(1) lt 200 then begin
    sym_to_plot=7
    size_to_plot=2.0-(sym_test(1)/200.)
    endif else begin 
    sym_to_plot=10
    size_to_plot=1.
    endelse
    if n_elements(e_ni) le 1 then e_to_plot=0
;
; Plot the data and errors if plot_flag set
    if plot_flag ge 1 then begin
        trap_current=!D.window
        if plot_flag eq 3 then plot,x_to_plot,w_to_plot,/noerase,/nodata $
	else begin
		if (noyrange and noxrange) then plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot $
		else   begin if (noyrange) then plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot,xrange=ximirange  $
		       else  if (noxrange) then plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot,yrange=mimirange  $
		     			   else plot,x_to_plot,w_to_plot,psym=sym_to_plot,symsize=size_to_plot,xrange=ximirange,yrange=mimirange
		endelse
		if n_elements(e_to_plot) gt 1 and n_elements(e_to_plot) lt 100 then $
			errplot,x_to_plot,w_to_plot - e_to_plot,w_to_plot + e_to_plot
		aff_excl,excl_param
	endelse
	if plot_flag eq 1 then if n_elements(w_out) eq n_elements(x_ni) then oplot,x_ni,w_out,linestyle=2,thick=2 
    endif
END

;===============================================================================
FUNCTION belong_to	,elem,inter				; ==============
;===============================================================================
; retourne un booleen indiquant si l'element elem est dans l'un des intervalles
; de inter ( sert a la procedure aff_excl)

nb  =N_ELEMENTS(inter)
i   =0
WHILE (i le nb/2-1) DO BEGIN
    IF ((elem ge inter(2*i)) AND (elem le inter(2*i+1))) THEN return ,1
    i=i+1
ENDWHILE

return ,0
END

;===============================================================================
PRO aff_excl	,excl_param					; ==============
;===============================================================================
; affichage des zones exclues du fit

COMMON gc_save

; calcul des zones exclues a partir des fit zones : l'ensemble complementaire
; de l'union des intervalles de excl_param dans le domaine de travail.
; on parcourt x_ni avec cour (element courant) et deux indicateurs :
; prec indique si l'element precedent cour etait dans une fit zone
; avprec indique si l'element precedent l'element precedent prec
; etait dans une fit zone.
; res est le tableau resultat contenant les bornes des intervalles
; complementaires de la fit zone

res=fltarr(1) & mini=MIN(x_ni)
IF (MIN(excl_param) le mini) THEN BEGIN
    prec=1 & res(0)=mini
ENDIF ELSE prec=0

FOR i=0,N_ELEMENTS(x_ni)-1 DO BEGIN
    cour=x_ni(i)
    IF belong_to(cour,excl_param) THEN BEGIN 	; We are in a fit zone  
	IF prec THEN avprec=1 ELSE BEGIN
	    avprec=0
	    prec=1
	ENDELSE
    ENDif ELSE BEGIN				; We are not in a fit zone    
	IF N_ELEMENTS(res) eq 1 THEN BEGIN
	    res(0)=cour
	    res=[res,cour]
	    prec  =0
	    avprec=0
	ENDIF ELSE BEGIN		; le nb d'elements de res est > 1   
	    IF prec THEN BEGIN		;prec etait dans une fit zone:
		res =[res,cour] ;on rajoute le min de l'intervalle exclu commence.
		prec  =0
		avprec=1
	    ENDIF ELSE BEGIN		; prec n'etait pas dans une fit zone ...
		prec=0
		IF avprec THEN res=[res,cour]$   ; ... mais avprec si :
		    ; il faut rajouter le max de l'intervalle courant.
		ELSE res(N_ELEMENTS(res)-1)=cour    ;prec n'etait pas dans une fit$
		    ; zone -> il suffit de deplacer la borne max de$
		    ;l'intervalle courant
		avprec=0
	    ENDELSE  
	ENDELSE
    ENDELSE
ENDFOR

; We can now plot fit excluded zone, only in view zone

adapte ,x_to_plot,w_to_plot,w_out,0

FOR i=0,N_ELEMENTS(res)/2-1 DO BEGIN
    ;affichage de l 'intervalle [res(i),res(i+1)]
    index=where((x_to_plot ge res(2*i)) AND (x_to_plot le res(2*i+1)),compt)
    IF compt ne 0 THEN BEGIN
	x	=fltarr(2*compt)
	x(0)	=x_to_plot(index)
	x(compt)=reverse(x(0:(compt-1)))
	w	=fltarr(2*compt)
	wmax	=MAX(w_to_plot,MIN=wmin)
	w(0)	=w_to_plot(index)
	w(compt)=reverse(w(0:(compt-1)))+(wmax-wmin)/10
	polyfill,x,w
    ENDIF
ENDFOR
END

FUNCTION gfit_event_func, event
gfit_event, event
RETURN, 0
END

;===============================================================================
PRO gfit_ctrl_panel, id						; ==============
;===============================================================================
; if id is defined,  then gfit_ctrl_panel has been destroyed, build it again

@lamp.cbk
COMMON gc_save
COMMON gc_wid
COMMON gc_data
COMMON gc_fit_excl
COMMON gc_cp
COMMON gc_flags
COMMON gc_fit_view

IF XREGISTERED('gfit_ctrl_panel') GT 0 AND N_PARAMS() EQ 0 THEN RETURN
IF XREGISTERED('gfit_ctrl_panel') GT 0 THEN WIDGET_CONTROL, bad_id=i, id, /Destroy
IF XREGISTERED('gfit') LE 0 then RETURN
if gw_gkfit_base       eq 0 then RETURN
BASE		=WIDGET_BASE  (Title='GFIT Control Panel', $
			       Group_Leader=gw_gkfit_base, $
			       Resource_Name='lampdon', /Column)
set_show_base	=WIDGET_BASE  (BASE, /Column, /frame)

peak_lab	=WIDGET_LABEL (set_show_base, Font= ft_b_bigger,$
				VALUE='Set fit parameters of function #')

peak_menu2	=WIDGET_BASE  (set_show_base , Column=g_nb_pk_max)
gw_type_but	=LONARR(g_nb_pk_max)  
gw_gau_but	=LONARR(g_nb_pk_max)
gw_lor_but	=LONARR(g_nb_pk_max)
gw_peak_but	=LONARR(g_nb_pk_max)

FOR i=1,g_nb_pk_max DO BEGIN
    gw_type_but(i-1)=WIDGET_BUTTON (peak_menu2, /Menu, Font=ft_propor, $
				UValue=[4,i,1], Value=STRMID(g_fct_type(i-1), 0, 3))
    gw_gau_but(i-1)=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,1],Value='Gauss', Font=ft_propor)
    gw_lor_but(i-1)=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,2],Value='Lorentz', Font=ft_propor)
    peak_base	   =WIDGET_BASE(peak_menu2, /Exclusive)
    gw_peak_but(i-1)=WIDGET_BUTTON(peak_base,/No_Release, Value=STRTRIM(STRING(i),2),$
				   UValue=[2,2,0], Font=ft_b_bigger) 
    IF i LE g_npeaks THEN sens=1 ELSE sens=0
    WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1) ,Sensitive=sens
ENDFOR
WIDGET_CONTROL, bad_id=i, gw_peak_but(g_pk_nb-1), Set_Button=1	; First button is set (Default)

gw_pk_slider=WIDGET_SLIDER(set_show_base, Maximum=g_nb_pk_max,$
				Minimum=1,/Suppress_Value, YSize=15,$
				UVALUE=[2,1,0],Value=g_npeaks)

button_base =WIDGET_BASE  (Title='GFIT Control Panel', BASE, /Column)
bloc_base   =WIDGET_BASE   (BASE , /row)		;.... gw_resid_lab .... 
resid_lab   =WIDGET_LABEL  (bloc_base,Value ='Residual:', Font=ft_normal)
gw_resid_lab=WIDGET_LABEL  (bloc_base,Value ='______________',Font=ft_b_normal)
bloc_baseb   =WIDGET_BASE   (BASE , /row)		;.... gw_resid_lab .... 
gw_cycle_lab=WIDGET_LABEL  (bloc_baseb, Font=ft_b_normal, Value='  '+$
				 STRTRIM(STRING(g_ncycles),2)+' Cycles')

cycles_sld  =WIDGET_SLIDER (bloc_baseb, Maximum=75 ,Minimum=0 , /Drag,$
				Value=g_ncycles,xsize=150, $
				YSize=16,/Suppress_Value, UValue=[2,3,0])

bloc_basec   =WIDGET_BASE   (BASE , /row)		;.... gw_resid_lab .... 
fit_but	    =WIDGET_BUTTON  (bloc_basec, Font=ft_biggest,$
				UValue=[2,4,0], Value ='FIT IT')
print_but   =WIDGET_BUTTON  (bloc_basec,Font=ft_biggest,$
				UValue=[3,1,0],Value=' Print ')
help_but    =WIDGET_BUTTON  (bloc_basec,Font=ft_biggest,$
				UValue=[3,2,0],Value=' Help ')
gw_exit_but =WIDGET_BUTTON  (bloc_basec,Font=ft_biggest,$
				UValue=[3,3,0], Value=' DONE ')


bloc_based  =WIDGET_BASE   (BASE , /Column, Frame=2)
title_lab   =WIDGET_LABEL  (bloc_based, Font=ft_propor, Value='Parameters')
bloc_based1 =WIDGET_BASE   (bloc_based, /Column, /Frame)
title_lab   =WIDGET_LABEL  (bloc_based1, Font=ft_smaller, Value='# bck.      Pos.     Fix.  Height   Fix.  HwHm  Fix.')
row	    =LONARR(g_nb_pk_max)
cp_nb	    =LONARR(g_nb_pk_max)
cp_bck	    =LONARR(g_nb_pk_max)
cp_pos	    =LONARR(g_nb_pk_max)
cp_hgt	    =LONARR(g_nb_pk_max)
cp_wid	    =LONARR(g_nb_pk_max)
cp_pf	    =LONARR(g_nb_pk_max)
cp_hf	    =LONARR(g_nb_pk_max)
cp_wf	    =LONARR(g_nb_pk_max)
FOR i=1, g_nb_pk_max DO BEGIN
    row(i-1)    =WIDGET_BASE   (bloc_based1, /Row, /Frame)
    cp_nb(i-1)  =WIDGET_LABEL  (row(i-1),Font=ft_smaller, Value=STRTRIM(STRING(i), 2))
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_bck(i-1) =WIDGET_BUTTON (basecp,Font=ft_propor, Value='')
    cp_pos(i-1) =WIDGET_TEXT   (row(i-1), Font=ft_smaller, Value='', XSize=6)
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_pf(i-1)  =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
    cp_hgt(i-1) =WIDGET_TEXT   (row(i-1), Font=ft_smaller, Value='', XSize=6)
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_hf(i-1)  =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
    cp_wid(i-1) =WIDGET_TEXT   (row(i-1), Font=ft_smaller, Value='', XSize=6)
    basecp	=WIDGET_BASE   (row(i-1), /NonExclusive)
    cp_wf(i-1)  =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
ENDFOR
bloc_based2 =WIDGET_BASE   (bloc_based, /Column, /Frame)
lab	    =WIDGET_LABEL  (bloc_based2, Font=ft_propor, Value='    Flat BKG Fix. Slope BKG Fix.')
row1	    =WIDGET_BASE   (bloc_based2, /Row)
bid	    =WIDGET_LABEL  (row1, Font=ft_smaller, Value='         ')
cp_fb	    =WIDGET_TEXT   (row1, Font=ft_smaller, Value='', XSize=7)
basecp	    =WIDGET_BASE   (row1, /NonExclusive)
cp_fbf	    =WIDGET_BUTTON (basecp,Font=ft_smaller, Value='f')
cp_sb	    =WIDGET_TEXT   (row1, Font=ft_smaller, Value='', XSize=7)
basecp	    =WIDGET_BASE   (row1, /NonExclusive)
cp_sbf	     =WIDGET_BUTTON(basecp,Font=ft_smaller, Value='f')
bid=sys_dep('DYNLAB', base, 1)
WIDGET_CONTROL, bad_id=i, BASE, /Realize
XMANAGER, 'gfit_ctrl_panel', BASE, /Just_reg, Cleanup='gfit_ctrl_panel'
WIDGET_CONTROL, bad_id=i, BASE, Event_Func='gfit_event_func'
RETURN
END

;===============================================================================
PRO do_fit, option						; ==============
;===============================================================================
; 
@lamp.cbk
COMMON gc_save
COMMON gc_wid
COMMON gc_data
COMMON gc_fit_excl
COMMON gc_flags
COMMON gc_fit_view
COMMON gc_negative

IF sw_ni(0) gt 0 THEN BEGIN
    ;calculation of the array used to calculate integrals for non-linear scales
    ;l(i)=(x(i+1)-x(i-1))/2 pour i variant de 1 a nombre mesures-1
    ;l(0)=(x(1)-x(0))/2  et  l(n)=(x(n)-x(n-1))/2
    larg =fltarr(N_ELEMENTS(x_ni))
    xprim=[x_ni(1:N_ELEMENTS(x_ni)-1),x_ni(N_ELEMENTS(x_ni)-1)]
    xsec =[x_ni(0),x_ni(0:N_ELEMENTS(x_ni)-2)]
    g_largeur=(xprim-xsec)/2
    read_par_vals
    gk_warning,excl_param,viewarr

    empty=0			; Check if each peaks is defined
    FOR i=0,g_npeaks-1 DO BEGIN
	if g_parameters(i*3+1) le 0 or g_parameters(i*3+2) le 0 THEN $
	    empty=empty+1
    ENDFOR
    IF empty gt 0 THEN BEGIN	; --- One of the peaks was undefined
	str=STRTRIM(STRING(empty),2)+' peak'
	if empty gt 1 THEN str=str +'s are ' ELSE str=str+' is '
	str=str+'not defined ! Define empty peak'
	if empty gt 1 THEN str=str+'s'
	error_msg, -1, str
    ENDIF ELSE BEGIN		; --- No peak is undefined
	old_resid=g_resid		; --- Push resid
	old_par=g_parameters	; --- Push parameters
	fitit,g_npeaks,w_ni,w_out,g_parameters,x_ni,g_ncycles,$
	      g_resid,g_step,gw_resid_lab ,excl_param,poids
	g_afitisdone=1		; a fit was done
	
	if peak_neg gt 0 then begin
	   if ht_or_wdth eq 1 then $
	   str='Height of peak '+ STRTRIM(STRING(peak_neg),2) + ' becomes negative'
           if ht_or_wdth eq 2 then $
	   str='Width of peak '+ STRTRIM(STRING(peak_neg),2) + ' becomes negative'
	   error_msg,-1,str 
	   g_resid=old_resid	    ; Pop resid
	   g_parameters=old_par    ; Pop parameters
	endif
	
	IF (g_resid ge old_resid) and (peak_neg eq 0) THEN BEGIN ; If worse, restore old values
	    g_resid=old_resid	    ; Pop resid
	    g_parameters=old_par    ; Pop parameters
	    error_msg, 4	    ; Alert user
	ENDIF ELSE $
;
; Plotting of results on screen here
	WIDGET_CONTROL, bad_id=i, gw_resid_lab, Set_Value=STRTRIM(STRING(g_resid),2)+'%'
	IF N_PARAMS() GT 0 THEN wset,did_win0 ELSE wset,g_plot_wid

	adapte ,x_out,w_to_plot,w_out,1 ,e_out
	plt_dev=0
	;.....plot subfunctions if necessary
	IF g_show_subfct THEN plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
	; --- Error calculation
	g_error=calculate_error(w_out)
	put_vals,x_ni,w_ni,w_out,plt_dev,poids,lamp_siz
	write_par_vals, /No_Update
    ENDELSE
ENDIF
IF N_PARAMS() GT 0 THEN BEGIN
    option=w_out
ENDIF
END

;===============================================================================
PRO get_param, g_parameters, idx, p1, p2, p3	    		; ==============
;===============================================================================

ind=(idx-1)*3
p1=g_parameters(ind)
p2=g_parameters(ind+1)
p3=g_parameters(ind+2)
RETURN
END

;===============================================================================
PRO get_bckg, g_npeaks, g_parameters, bbb, sss	    		; ==============
;===============================================================================

ilast=g_npeaks*3-1
bbb  =g_parameters(ilast+1)
sss  =g_parameters(ilast+2)
RETURN
END

;===============================================================================
PRO gfit_help	, dummy, formu, formt
;===============================================================================

formu=''
formt='Fitting Routines by G.Kearley. Interface by Romuald JOUFFREY.'
formu=[formu,'What is to be plotted :']
formt=[formt,'']
formu=[formu,'']
formt=[formt,'Adjust workspace number (upper left) and Click "GetWs #" to fetch data.']
formu=[formu,'']
formt=[formt,'Cutting value can be set with the tiny slider']
formu=[formu,'How to perform a fit :']
formt=[formt,'']
formu=[formu,'High level details']
formt=[formt,'']
formu=[formu,'']
formt=[formt,'Once a scan is plotted, choose the number of subfonctions, Then choose the type of fitting subfonction(s)']
formu=[formu,'']
formt=[formt,'']
formu=[formu,'Clicks on plot are significant :']
formt=[formt,'']
formu=[formu,'Left mouse button ']
formt=[formt,'- click current subfunction Height(position) then drag and release on half-Width']
formu=[formu,'Right mouse button']
formt=[formt,'- Drag to set the fitting area ("Fit-zone" button is used for multiple areas)']
formu=[formu,'']
formt=[formt,'']
RETURN
END

;===============================================================================
PRO gk_initialize, excl=excl					; ==============
;===============================================================================

COMMON gc_save
COMMON gc_data
COMMON gc_flags
COMMON gc_fit_excl
COMMON gc_wid

if not keyword_set(excl) then begin

 WIDGET_CONTROL, bad_id=i, gw_pos_text,	Set_Value='0.0'	;Clear field
 WIDGET_CONTROL, bad_id=i, gw_int_text,	Set_Value='0.0'	;Clear field
 WIDGET_CONTROL, bad_id=i, gw_wdt_text,	Set_Value='0.0'	;Clear field
 WIDGET_CONTROL, bad_id=i, gw_fbg_text,	Set_Value='0.0'	;Clear field
 WIDGET_CONTROL, bad_id=i, gw_sbg_text,	Set_Value='0.0'	;Clear field
 WIDGET_CONTROL, bad_id=i, gw_cut_label,	Set_Value=''
 WIDGET_CONTROL, bad_id=i, gw_resid_lab,	Set_Value=''

 g_resid=1.0e12
 WSET, g_plot_wid
 ERASE, 0

endif else begin
;initialisation de excl_param :
 excl_param(0)=MIN(x_ni,MAX=ma)
 excl_param(1)=ma
 WIDGET_CONTROL, bad_id=i,excl_widge(0),Set_Value=STRTRIM(STRING(excl_param(0)),2)
 WIDGET_CONTROL, bad_id=i,excl_widge(1),Set_Value=STRTRIM(STRING(excl_param(1)),2)
 FOR i=1,max_nb_int-1 do BEGIN
  excl_param(2*i)  =excl_param(0)-1
  excl_param(2*i+1)=excl_param(0)-1
  WIDGET_CONTROL, bad_id=iii,excl_widge(2*i)  ,Set_Value='***'
  WIDGET_CONTROL, bad_id=iii,excl_widge(2*i+1),Set_Value='***'
 ENDFOR
;selection du bouton no 1 :
 WIDGET_CONTROL, bad_id=i,gw_excl_but,set_button=1
 intv_no=1
endelse
END 

;===============================================================================
PRO gfit_Event, Event						; ==============
;===============================================================================
; Called when a gfit event is generated

@lamp.cbk
common c_trap, trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
COMMON gc_save
COMMON gc_wid
COMMON gc_data
COMMON gc_fit_excl
COMMON gc_flags
COMMON gc_fit_view
COMMON gc_width_factor
COMMON gc_negative
COMMON gc_dids

stat=0
catch,stat
if stat  ne 0  then BEGIN
		catch,/cancel
 		set_plot,my_path(3)
		WIDGET_CONTROL, bad_id=i, gw_err_lab, Set_Value=!err_STRING
		RETURN & ENDIF
error_msg, 0				; Clear error msg fields

if  tag_names(Event,/structure_name) ne 'WIDGET_DRAW' then $
	WIDGET_CONTROL, bad_id=i, Event.Id, /Hourglass
	WIDGET_CONTROL, bad_id=i, Event.Id, GET_UVALUE=Ev, Get_Value=value
no_plot=0
CASE Ev(0) OF
    1 	: BEGIN
    CASE Ev(1) OF
    1 : BEGIN			; W slider event
	    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=nw_ni
	END

    2	: BEGIN			; Get Button event
	;gk_initialize
	IF Ev(2) NE 0 THEN BEGIN
	    nw_ni=Ev(2)
	    tripx_mode=1
	ENDIF ELSE tripx_mode=0
	nwt_in=STRTRIM(STRING(nw_ni),2)	; Get W number id
	w_ni=0 & x_in=0 & y_in=0 & e_in=0
	iii=EXECUTE("w_ni=w"+nwt_in)
	iii=EXECUTE("x_in=x"+nwt_in) & x_ni=x_in(*,0)
	iii=EXECUTE("y_in=y"+nwt_in)
	iii=EXECUTE("e_ni=e"+nwt_in)
	if n_elements(e_ni) ne n_elements(w_ni) then e_ni=0
	w_ni=w_ni > 0
	sw_ni=SIZE(w_ni) & sx_ni=SIZE(x_ni)		    & sy_in=SIZE(y_in)
	if sy_in(1) gt 1  then begin y_in=reform(y_in(0,*)) & sy_in=SIZE(y_in) & endif
	keepw=w_ni
	keepe=e_ni
	IF sw_ni(0) gt 0 THEN BEGIN
	    IF sw_ni(0) gt 2 THEN BEGIN
		w_ni =TOTAL(w_ni,3) & e_ni=0
		sw_ni=SIZE(w_ni)
		error_msg, 2
	    ENDIF

	    IF (sw_ni(1) ne sx_ni(1)) or (sx_ni(0) ne 1) THEN BEGIN
		x_ni=indgen(sw_ni(1)) & x_in=x_ni      & ENDIF

	    IF sw_ni(0) gt 1 THEN BEGIN
		WIDGET_CONTROL, bad_id=i, ws_in_r      , Map=1
	    	WIDGET_CONTROL, bad_id=i, gw_cut_slider, /Sensitive
	    	; initializing regle
	    	WIDGET_CONTROL, bad_id=i, gw_cut_slider, Set_Slider_Max=sw_ni(2)
	    	; on cree un "y" par defaut :
		IF n_elements(y_in) ne sw_ni(2) THEN y_in=findgen(sw_ni(2))+1
	    	WIDGET_CONTROL, bad_id=i, gw_cut_slider, Get_Value=no_coupe
	    	w_ni =keepw(*,no_coupe-1)
	    	if n_elements(e_ni) gt 1 then $
		e_ni =keepe(*,no_coupe-1)
	    	sw_ni=size(w_ni)
		IF (size(x_in))(0) eq 2 then x_ni=x_in(*,no_coupe-1)

	    	; initialisation du label de la regle :
	    	WIDGET_CONTROL, bad_id=i, gw_cut_label, Set_Value='->'+$
	    	STRTRIM(STRING(y_in(no_coupe-1)),2)

	    ENDIF ELSE BEGIN
	        WIDGET_CONTROL, bad_id=i, gw_cut_slider, sensitive=0
		WIDGET_CONTROL, bad_id=i, ws_in_r      , Map=0 & ENDELSE

	    g_error=fltarr(3*g_nb_pk_max+2)

	    ;initialisation de excl_param si necessaire:
	    min_xin=min(x_in,MAX=max_xin)
	    if (excl_param(0) lt min_xin) or (excl_param(1) gt max_xin)  $
	    or (excl_param(0)+excl_param(1) eq 0) then gk_initialize,/excl
	
	    ; initialisation de viewarr :
	    viewarr(0)=min_xin	        & viewarr(0+sauv)=viewarr(0)
	    viewarr(1)=max_xin	        & viewarr(1+sauv)=viewarr(1)
	    viewarr(2)=MIN(w_ni,MAX=ma)	& viewarr(2+sauv)=viewarr(2)
	    viewarr(3)=ma		& viewarr(3+sauv)=viewarr(3)
	    mimirange =[viewarr(2),viewarr(3)]

	    IF tripx_mode THEN WSET, did_win0 ELSE WSET,g_plot_wid
	   ;!p.title=w_tit(nw_ni)
	    !x.title=x_tit(nw_ni)
	    !y.title=y_tit(nw_ni)
	    
	    trap_current=!D.window
	    adapte ,x_to_plot,w_to_plot,w_ni,1
    ENDIF ELSE error_msg, 3
    END
    3 : BEGIN			; Cut slider event
		    g_resid=1.0e12
		    ; --- Getting data to plot
		    WIDGET_CONTROL, bad_id=i, gw_cut_slider, Get_Value=no_coupe
		    w_ni=keepw(*,no_coupe-1)
		    if n_elements(e_ni) gt 1 then $
		    e_ni=keepe(*,no_coupe-1)
		    IF (size(x_in))(0) eq 2 then x_ni=x_in(*,no_coupe-1)

		    ; --- Initializing  viewarr(2) & viewarr(3)
		    viewarr(2)=MIN(w_ni,MAX=ma)	& viewarr(2+sauv)=viewarr(2)
		    viewarr(3)=ma		& viewarr(3+sauv)=viewarr(3)
		    mimirange =[viewarr(2),viewarr(3)]

		    ; update label of parameter
		    WIDGET_CONTROL, bad_id=i, gw_cut_label, Set_Value =$
			'->'+STRTRIM(STRING(y_in(no_coupe-1)),2)

		    ; do the plot
		    !x.title=x_tit(nw_ni)+' Spectrum '+STRTRIM(STRING(y_in(no_coupe-1)),2)
		    wset,g_plot_wid
		    adapte ,x_to_plot,w_to_plot,w_out,1
		  END
    4		: BEGIN			; --- W out Slider event
		    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=nw_out
		  END
    5		: IF sw_ni(0) gt 0 THEN BEGIN	; --- W out Button event
			xicuter, 'w'+STRTRIM(STRING(nw_out),2) +$
			'=gk_fit(w' +STRTRIM(STRING(nw_ni),2) +')'
		  ENDIF
    ENDCASE
    END
    2	: BEGIN
    CASE Ev(1) OF
    1		: BEGIN			; --- Peak Slider 
		new_npeaks=0
		WIDGET_CONTROL, bad_id=i, event.id, Get_Value=new_npeaks
		IF new_npeaks LT g_pk_nb THEN BEGIN
		    ; peak_number 1 button Simulated event
		    gfit_Event,{WIDGET_BUTTON, ID:gw_peak_but(0), $
				TOP:gw_gkfit_base, HANDLER:0L, SELECT:1} 
		ENDIF ELSE BEGIN
		    g_step(g_npeaks*3:g_npeaks*3+1)=''
		ENDELSE
		g_npeaks=new_npeaks
		; Make Peak buttons number > g_npeaks NonSensible
		FOR i=1,g_nb_pk_max DO BEGIN
		    IF i GT g_npeaks THEN BEGIN
			WIDGET_CONTROL, bad_id=iii, gw_pos_pop (i+3), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_int_pop (i+3), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_wdt_pop (i+3), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1), Sensitive=0
			WIDGET_CONTROL, bad_id=iii, gw_type_but(i-1), Sensitive=0
			if n_elements(gw_peak_but) gt g_nb_pk_max then $
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(g_nb_pk_max+i-1), map=0
		    ENDIF ELSE BEGIN
			WIDGET_CONTROL, bad_id=iii, gw_pos_pop (i+3), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_int_pop (i+3), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_wdt_pop (i+3), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1), /Sensitive
			WIDGET_CONTROL, bad_id=iii, gw_type_but(i-1), /Sensitive
			if n_elements(gw_peak_but) gt g_nb_pk_max then $
			WIDGET_CONTROL, bad_id=iii, gw_peak_but(g_nb_pk_max+i-1), map=1
		    ENDELSE
		    g_resid=1.0e12
		ENDFOR
		g_resid=1.0e12
		 END
    2	       : BEGIN			; --- Peak number Button event
		    ; Get old selected peak parameters
		    read_par_vals
		    g_old_pk_nb=g_pk_nb
		    WIDGET_CONTROL, bad_id=i, event.id, Get_Value=g_pk_nb
		    IF g_pk_nb ne g_old_pk_nb THEN BEGIN
		        WIDGET_CONTROL, bad_id=i, gw_bose , set_button=bose(g_pk_nb-1)
			WIDGET_CONTROL, bad_id=i, gw_pk_no, Get_value=V
			V='Peak #'+STRTRIM(STRING(g_pk_nb), 2)+' param'
			WIDGET_CONTROL, bad_id=i, gw_pk_no, Set_Value=V
			FOR i=0,g_npeaks-1 DO $
			    WIDGET_CONTROL, bad_id=iii, gw_peak_but(i), $
					    Set_Button=(i EQ g_pk_nb-1)
			write_par_vals
			error_msg, -2, g_pk_nb
		    ENDIF
		   END
		




    3		: BEGIN		; --- Number of cycle(s) slider event
			WIDGET_CONTROL, bad_id=i, event.id, Get_Value=g_ncycles
			str='  '	; --- Display number of cycle(s)
			IF g_ncycles gt 1 THEN str='s'
			IF strlen(STRTRIM(STRING(g_ncycles),2)) eq 1 THEN $
			WIDGET_CONTROL, bad_id=i, gw_cycle_lab, Set_Value='  '+$
			STRTRIM(STRING(g_ncycles),2)+' Cycle'+str $
			ELSE $
			WIDGET_CONTROL, bad_id=i, gw_cycle_lab, Set_Value=$
			STRTRIM(STRING(g_ncycles),2)+' Cycle'+str
		    END
    4	: do_fit
    5	: BEGIN				; --- Fitting Zone Button event
		WIDGET_CONTROL, bad_id=i, gw_excl_base, /Map ,/Show
	  END
    6  	: BEGIN			; --- Exit Button event
		    WIDGET_CONTROL, bad_id=i, gw_view_base, /Map, /Show
		  END
    7		: IF sw_ni(0) gt 0 THEN $	; --- Plot area event
		    ; IF released button or right button is pressed
		    IF ((event.TYPE eq 1) or ((event.TYPE eq 0) $
		    	AND ((event.press eq 4) or (event.press eq 1)))) THEN BEGIN 
			WSET ,g_plot_wid
			if trap_current ne g_plot_wid then adapte ,x_to_plot,w_to_plot,w_out,3
			CURSOR,xcurs,ycurs,/nowait
			read_par_vals
			ind=(g_pk_nb-1)*3
			affiche=1
			IF g_parameters(ind+1) le 0 THEN g_parameters(ind+1)=10e-12  ;intensite par defaut 
			IF g_parameters(ind+2) le 0.0 THEN BEGIN ;largeur par defaut
			    sx=size(x_ni)
			    g_parameters(ind+2)=ABS(x_ni(sx(3)-1)-x_ni(0))/30.0
			    ; ???
			ENDIF
			; Set Position and Intensity
			g_resid=1.0e12
			IF event.press eq 1 THEN BEGIN
			    DEVICE ,cursor_standard=16
			    g_parameters(ind)=xcurs
			    ;g_parameters(ind+1)=ycurs
			    get_bckg, g_npeaks, g_parameters, bbb, sss
			    g_parameters(ind+1)=ycurs-(bbb+xcurs*sss)
			    no_plot=1  ; prevent plotting
			ENDIF
			; fin de determination de la position et de l'intensite 

			;..... width determination  
			IF event.release eq 1 THEN BEGIN
			   DEVICE ,cursor_standard=2
			   g_resid=1.0e12 
			   p=g_parameters(ind) & h=g_parameters(ind+1)
			   old_w=g_parameters(ind+2)
		           get_bckg, g_npeaks, g_parameters, bbb, sss
			   ht_bg=ycurs-(bbb+xcurs*sss)
			   IF g_fct_type(g_pk_nb-1) eq 'Gauss' THEN BEGIN
			    ;calcul de la largeur =|pos-xcurs|/rac(2|log(h)-log(ht_bg)|)
 			    denom=sqrt((abs(ALOG(h)-ALOG(ht_bg)))/gw_fac)
			    g_parameters(ind+2)=ABS(p-xcurs)/denom
			   ENDIF
			   IF g_fct_type(g_pk_nb-1) eq 'Lorentz' THEN BEGIN
			    ;calcul de la largeur =|pos-xcurs|/rac(h/y-1)
			    IF h le ht_bg THEN g_parameters(ind+2)=1.0e12 $
			    ELSE g_parameters(ind+2)=ABS(p-xcurs)/(SQRT(h/ht_bg-1)*lw_fac)
			   ENDIF
		        ENDIF
		        ;..... fin de determination de la largeur

		        ;.... determination de la fit zone :
		        IF event.press eq 4 THEN BEGIN
			   affiche=0
			   bb1=xcurs
			   bb2=x_ni(0)
			   DEVICE ,cursor_standard=32
		        ENDIF

		        IF event.release eq 4 THEN BEGIN
			   affiche=1
			   DEVICE ,cursor_standard=2
			   bb2=xcurs
			   ma =MAX(x_ni,MIN=mi)
			   IF abs(bb2-bb1) gt (ma-mi)/30 THEN BEGIN
			    ma=MAX([bb1,bb2],MIN=mi)
			    idx=        where(x_ni ge mi)  & if idx(0) ge 0 then mi=x_ni(idx(0))
			    idx=reverse(where(x_ni le ma)) & if idx(0) ge 0 then ma=x_ni(idx(0))
			    excl_param(2*intv_no-2)=mi
			    excl_param(2*intv_no-1)=ma
				WIDGET_CONTROL, bad_id=i, excl_widge(2*intv_no-2),$
				Set_Value=STRTRIM(STRING(mi),2)
				WIDGET_CONTROL, bad_id=i, excl_widge(2*intv_no-1),$
				Set_Value=STRTRIM(STRING(ma),2)
			   ENDIF
		        ENDIF
		        ;....  fin de determination des intervalles a exclure

		    	if no_plot eq 0 then $
		    	adapte ,x_to_plot,w_to_plot,w_out,2
		    	IF affiche THEN aff_excl,excl_param
		    	;..... plot peaky(s)
		    	if no_plot eq 0 then $
		    	plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
		    	no_plot=0
		    	write_par_vals, /No_Update

;		    	IF event.release eq 2 THEN BEGIN
;		    	   read_par_vals
;		    	   new_pk_nb=g_pk_nb+1
;		    	   IF new_pk_nb GT g_npeaks THEN new_pk_nb=1
;		    	   gfit_Event,{WIDGET_BUTTON, ID:gw_peak_but(new_pk_nb-1), $
;				TOP:gw_gkfit_base, HANDLER:0L, SELECT:1} 
;		        ENDIF
		    ENDIF
    8		: IF sw_ni(0) gt 0 THEN BEGIN	; --- Show subfunctions
			g_show_subfct=event.select
		ENDIF
    9		: BEGIN	; --- Convolution Button event
			; To be continued ...
		END
    10:		bose(g_pk_nb-1)=event.select
    11:		begin mimion   =event.select & if not mimion then begin viewarr(2)=MIN(w_ni,MAX=ma) & viewarr(3)=ma & endif
    		      adapte ,x_to_plot,w_to_plot,w_out,1 & end
    12:		begin ximion   =event.select & if not ximion then begin viewarr(0)=MIN(x_ni,MAX=ma) & viewarr(1)=ma & endif
    		      adapte ,x_to_plot,w_to_plot,w_out,1 & end
    13: 	adapte ,x_to_plot,w_to_plot,w_out,1

    ENDCASE
    END
    3	: BEGIN
    CASE Ev(1) OF
        1   : IF sw_ni(0) gt 0 AND g_afitisdone THEN BEGIN ; Print But event
		g_print_nb=g_print_nb+1
		psFile='fit'+STRTRIM(STRING(g_print_nb),2)+'.ps'
		wplot=!D.NAME
		err=1
		ON_IOERROR,IFerr
		set_plot,'PS'
		DEVICE, filename=psFile
		DEVICE, bits_per_pixel=8,color=0
		IF g_tripx THEN BEGIN		; Tripx printing mode
		    short_side	=17.0
		    small_offset=0.5
		    long_side	=14.0
		    big_offset	=14.0
		    w_out=0
		    DEVICE, /portrait, /inches
		    DEVICE, xsize=short_side, ysize=long_side
		    DEVICE, xoffset=small_offset, yoffset=big_offset
		    fitit,g_npeaks,w_ni,w_out,g_parameters,x_ni,0,g_resid,$ 
				g_step,gw_resid_lab,excl_param,poids

		    adapte ,x_to_plot,w_to_plot,w_out,1
		    IF g_show_subfct THEN plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
		    plt_dev=1
				; Printing -> big character size
		    FOR i=0, N_ELEMENTS(g_tx_par)-1 DO BEGIN
			XYOUTS, 100, -360.-(i-1)*320., g_tx_par(i), $
				    CharSize=g_char, /Device
		    ENDFOR
		    print_vals,x_ni,w_ni,w_out,plt_dev,poids
		    DEVICE, /color
		    P_DID_PS_HEADER, 5.5, 0, psFile
		ENDIF ELSE BEGIN		; gfit printing mode
		    sx=7. & sy=11.5
		    DEVICE,yoffset=sy-.5,xoffset=.5,/inches,/landscape
		    read_par_vals
		    w_out=0
		    fitit,g_npeaks,w_ni,w_out,g_parameters,x_ni,0,g_resid,$ 
				g_step,gw_resid_lab,excl_param,poids

		    adapte ,x_to_plot,w_to_plot,w_out,1
		    IF g_show_subfct THEN plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
		    plt_dev=1
				; Printing -> big character size
		    put_vals,x_ni,w_ni,w_out,plt_dev,poids,1000
		    print_vals,x_ni,w_ni,w_out,plt_dev,poids
		    DEVICE, bits_per_pixel=8, /color
		    P_DID_PS_HEADER, 7., nw_ni, psFile
		    err=0
		ENDELSE
		IFerr: DEVICE,/Close_File
		set_plot,wplot
		ENDIF
    2  	: BEGIN
		show_helps, [-88, 590]
	  END
    3  	: BEGIN			; --- Exit Button event
		gg=gw_gkfit_base & gw_gkfit_base=0
		WIDGET_CONTROL, bad_id=i, gg ,/Destroy & wait,.3
		IF g_old_plot_wid GT 0 then WSET,g_old_plot_wid
	  END
    ENDCASE
    END
    4	: BEGIN	; --- Peak pop up menu event
		if Ev(2) eq 1 then BEGIN
		g_fct_type(Ev(1)-1)='Gauss'
		v='Gau'
		ENDIF
		if Ev(2) eq 2 then BEGIN
		g_fct_type(Ev(1)-1)='Lorentz'
		v='Lor'
		ENDIF
		WIDGET_CONTROL, bad_id=i, gw_type_but(Ev(1)-1), Set_Value=v
		g_resid=1.0e12
	  END
    5   : Parameter_menu,Ev
    6	: BEGIN
		read_par_vals
		g_resid=1.0e12
		adapte ,x_to_plot,w_to_plot,w_out,1
		plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type
	  END
    -88 : if Ev(1) eq 391 then p_did_mvlog, Event,Ev

    ELSE: error_msg, 5
    ENDCASE
END

;===============================================================================
PRO gk_warning	,excl_param, viewarr				; ==============
;===============================================================================
; Warning if points of fitting zone are not in viewing zone

COMMON gc_wid

FOR i=1,N_ELEMENTS(excl_param)/2 DO BEGIN ; parcours sur chaque intervalle de fit
    IF ((viewarr(0) gt excl_param(2*i-2)) or $
	   (viewarr(1) lt excl_param(2*i-1)) ) $
	   AND (excl_param(2*i-2) ne excl_param(2*i-1)) $
	THEN error_msg, 6
    ENDFOR
END

;===============================================================================
PRO plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type		; ==============
;===============================================================================
;Puts titles on plot
;
COMMON gc_dids

FOR idx=1,g_npeaks DO BEGIN
    get_param, g_parameters, idx, p1, p2, p3
    IF p2 gt 0 AND p3 gt 0 THEN BEGIN
	IF p2 lt 0.0 THEN peaky=0.0
	IF p2 gt 0.0 THEN BEGIN
	    curpic=idx
	    CALL_PROCEDURE, g_fct_type(idx-1), $
			x_ni,p1,p2,p3,peaky
	    get_bckg, g_npeaks, g_parameters, bbb, sss
	    ma=MAX(peaky,MIN=mi)
	    pp=0.3*(ma-mi)
	    peaky=peaky + (bbb + x_ni*sss) 
	    OPLOT,x_ni,peaky,linestyle=1,thick=2
	    pp=pp+(bbb+p1*sss)
	    XYOUTS,p1,pp,STRTRIM(STRING(idx),2),CharSize=1.2, NoClip=0
	ENDIF
    ENDIF
ENDFOR
RETURN
END

;===============================================================================
PRO put_tit	,x_dats,y_dats,f_tit,fx_tit,fy_tit		; ==============
;===============================================================================
;Puts titles on plot
;

ma  =MAX(x_dats,MIN=mi)
xrng=ma-mi
ma  =MAX(y_dats,MIN=mi)
yrng=ma-mi
anx_mid=xrng/2
any_mid=yrng/2
dispx=-(xrng)*0.06
dispy=-(yrng)*0.08
dispt=ma+(yrng)*0.02
xyouts,anx_mid,dispy,fx_tit,alignment=0.5,size=1.5
xyouts,dispx,any_mid,fy_tit,alignment=0.5,orientation=90,size=1.5
xyouts,anx_mid,dispt,f_tit,alignment=0.5,size=1.5
return
END

;===============================================================================
PRO put_vals	,x_dats,y_dats,f_dats,plt_dev,poids,lamp_siz	; ==============
;===============================================================================
;Puts result on plot
;

COMMON gc_wid
COMMON gc_fit_excl
COMMON gc_data
COMMON gc_fit_view
COMMON gc_dids

downy=0.08
if lamp_siz gt 800 then downy=0.06
if lamp_siz gt 900 then downy=0.04

if plt_dev eq 0 THEN wset,g_plot_wid
size_of_x=N_ELEMENTS(x_dats)
eps=abs((x_dats(size_of_x-1)-x_dats(0)))/(size_of_x-1) 
device_fac=1.5
;	IF plt_dev eq 1 THEN device_fac=2.
boxx   =fltarr(5)
boxy   =fltarr(5)
min_x  =viewarr(0) 
min_y  =viewarr(2) 
xrng   =viewarr(1)-min_x 
yrng   =viewarr(3)-min_y 

yrng   =viewarr(3)-min_y 
dispx  =min_x+(xrng*0.02)
dispy  =min_y+(yrng*0.96)
boxx(0)=min_x+(xrng*0.01)
boxy(0)=min_y+(yrng*0.98)
boxx(4)=boxx(0)
boxy(4)=boxy(0)
boxx(3)=boxx(0)
boxy(1)=boxy(0)
boxx(1)=min_x+(xrng*0.3)
boxx(2)=boxx(1)
boxy(2)=min_y+(yrng*0.85)
boxy(3)=boxy(2)

; Get total of fitted peak without that marked background "b"
sum_fit=0 
FOR j=1,g_npeaks DO BEGIN
    pk_int=0.0
    ind=(j-1)*3
    iback=0
    ; Look FOR "b" on a parameter
    FOR ipmt=0,2 DO BEGIN
	IF STRPOS(g_step(ind+ipmt),'b') ge 0 THEN iback=1
    ENDFOR

    IF iback eq 0 THEN BEGIN
	get_param, g_parameters, j, p1, p2, p3
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448 G.J.K !!!
; For Gaussian real width related to sigma by sqrt((1/2^3))         = 0.353553 D.R   !!!
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then sum_fit=sum_fit+(p2*p3*0.353553*!pi)
    if g_fct_type(j-1) eq 'Lorentz' then sum_fit=sum_fit+(p2*p3*0.5*!pi)
    if bose(j-1) then if debal gt 0 then sum_fit=sum_fit/debal
    ENDIF
ENDFOR
get_bckg, g_npeaks, g_parameters, bbb, sss
dataIntegral=TOTAL(y_dats*poids*g_largeur)	; calculate Data integral

fittedbackground=TOTAL((bbb+x_dats*sss)*poids*g_largeur)
dataIntegral=dataIntegral-fittedbackground

partxt='Fit Integral ='+STRTRIM(STRING(sum_fit,format='(g10.3)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char
partxt='Data Int.-bg.= '+STRTRIM(STRING(dataIntegral,format='(g10.3)'),2)
dispy=dispy-((yrng*downy)/device_fac)
XYOUTS,dispx,dispy,partxt,charsize=g_char
dispy=dispy-((yrng*downy)/device_fac)
partxt='Fitted Bg.   ='+STRTRIM(STRING(fittedbackground,format='(g10.3)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char

IF (sum_fit gt 0.0) AND (dataIntegral GT 0) THEN BEGIN
    FOR j=1,g_npeaks DO BEGIN
	pk_int=0.0
	get_param, g_parameters, j, p1, p2, p3
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448
; For Gaussian real width related to sigma by sqrt((1/2^3))         = 0.353553
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then pk_int=p2*p3*0.353553*!pi
    if g_fct_type(j-1) eq 'Lorentz' then pk_int=p2*p3*0.5*!pi
    if bose(j-1) then if debal gt 0 then pk_int=pk_int/debal
	percy=pk_int*100.0/dataIntegral
;	percy_txt=' ('+STRTRIM(STRING(percy,format='(f5.1)'),2)+'%)'
;Something wrong with data integral here - I removed it gjk.
	percy_txt=' '
	dispy1=dispy-(j*(yrng*downy)/device_fac)
	partxt='Inty'+STRTRIM(STRING(j),2)+'='+STRTRIM(STRING(pk_int),2)
	partxt=partxt+percy_txt
	XYOUTS,dispx,dispy1,partxt,charsize=g_char
   ENDFOR
ENDIF
;boxy(2)=yrng*(0.85-(g_npeaks*0.05))	; ???
;boxy(2)=yrng*(0.84-(g_npeaks*0.06))	; ???
;boxy(3)=boxy(2)
;IF plt_dev eq 0 THEN oplot,boxx,boxy
return
END

;===============================================================================
PRO print_vals	,x_dats,y_dats,f_dats,plt_dev,poids		; ==============
;===============================================================================
;Put other result on print
;

COMMON gc_wid
COMMON gc_fit_excl
COMMON gc_data
COMMON gc_fit_view
COMMON gc_dids

downy=0.05	; value to go down on y axis for youts

device_fac=1.5

min_x  =viewarr(0) 
min_y  =viewarr(2) 
xrng   =viewarr(1)-min_x 
yrng   =viewarr(3)-min_y 

; Get total of fitted peak without that marked background "b"
sum_fit=0 

FOR j=1,g_npeaks DO BEGIN
    pk_int=0.0
    ind=(j-1)*3
    iback=0
    ; Look FOR "b" on a parameter
    FOR ipmt=0,2 DO BEGIN
	IF STRPOS(g_step(ind+ipmt),'b') ge 0 THEN iback=1
    ENDFOR
    IF iback eq 0 THEN BEGIN
	get_param, g_parameters, j, p1, p2, p3
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448
; For Gaussian real width related to sigma by sqrt((1/2^3))         = 0.353553
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then sum_fit=sum_fit+(p2*p3*0.353553*!pi)
    if g_fct_type(j-1) eq 'Lorentz' then sum_fit=sum_fit+(p2*p3*0.5*!pi)
    if bose(j-1) then if debal gt 0 then sum_fit=sum_fit/debal
    ENDIF
ENDFOR



get_bckg, g_npeaks, g_parameters, bbb, sss
ilast=g_npeaks*3-1
dataIntegral=TOTAL(y_dats*poids*g_largeur)	; calculate Data integral
fittedbackground=TOTAL((bbb+x_dats*sss)*poids*g_largeur)
dataIntegral=dataIntegral-fittedbackground

dispx=min_x+xrng+(xrng*0.02)/device_fac
dispy=min_y+yrng+(yrng*0.02)/device_fac
dispy=dispy-((yrng*(downy+0.01))/device_fac)
partxt='Fit Int. = '+STRTRIM(STRING(sum_fit,format='(g10.3)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char
partxt='Data Int.-bg.= '+STRTRIM(STRING(dataIntegral,format='(g10.3)'),2)
dispy=dispy-((yrng*downy)/device_fac)
XYOUTS,dispx,dispy,partxt,charsize=g_char
dispy=dispy-((yrng*downy)/device_fac)
partxt='Fitted Bg.    = '+STRTRIM(STRING(fittedbackground,format='(g10.3)'),2)
XYOUTS,dispx,dispy,partxt,charsize=g_char

FOR j=1,g_npeaks DO BEGIN
    pk_int=0.0
    get_param, g_parameters, j, p1, p2, p3
    IF p2 gt 0 AND p3 gt 0 THEN BEGIN
	curpic=j
	CALL_PROCEDURE, g_fct_type(j-1),x_dats,p1,p2,p3,peaky
    ENDIF
;
; For Gaussian real width related to sigma by sqrt((1/2^3)*sqrt(2)) = 0.420448
; For Gaussian real width related to sigma by sqrt((1/2^3))         = 0.353553
; For Lorentz factor is 0.5
    if g_fct_type(j-1) eq 'Gauss'   then pk_int=p2*p3*0.353553*!pi
    if g_fct_type(j-1) eq 'Lorentz' then pk_int=p2*p3*0.5*!pi
    if bose(j-1) then if debal gt 0 then pk_int=pk_int/debal
;
; Error on intensity as average of height and width
    ht_er=(g_error(ind+1)/p2)^2
    w_er=(g_error(ind+2)/p3)^2
    pk_error=pk_int*sqrt(ht_er+w_er)
    p_txt=STRING(p1,format='(g10.3)')
    i_txt=STRING(pk_int,format='(g10.3)')
    w_txt=STRING(p3,format='(g10.3)')
    e_p_txt=STRING(ABS(g_error(ind))  ,format='(g10.3)')
    e_i_txt=STRING(ABS(pk_error),format='(g10.3)')
    e_w_txt=STRING(ABS(g_error(ind+2)),format='(g10.3)')
    str=' --- Error'
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'Peak '+STRTRIM(STRING(j),2)+str,charsize=1.0
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'P'+p_txt+' '+e_p_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'I'+i_txt+' '+e_i_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'W'+w_txt+' '+e_w_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    percy=pk_int*100.0/dataIntegral
    percy_txt=STRTRIM(STRING(percy,format='(f5.1)'),2)+'%'
    delta_i=ABS(g_error(ind+1))
    delta_ie=2*SQRT(dataIntegral)
    ind=(j-1)*3
    ; Look FOR "b" on a parameter
    FOR ipmt=0,2 DO IF STRPOS(g_step(ind+ipmt),'b') ge 0 THEN $
	delta_ie=delta_ie+ABS(g_error(ilast+1))+ABS(g_error(ilast+2))
    delta=(delta_i*dataIntegral+p2*delta_ie)/(dataIntegral*dataIntegral)
    delta_txt=STRTRIM(STRING(ABS(delta),format='(g10.3)'),2)
    txt='Pct '+STRTRIM(STRING(j),2)+' '+percy_txt+'      '+delta_txt
    XYOUTS,dispx,dispy,txt,charsize=g_char
ENDFOR
    ; Add flat AND sloping bg
    bg_txt=STRTRIM(STRING(ABS(g_parameters(ilast+1))),2)
    sl_txt=STRTRIM(STRING(ABS(g_parameters(ilast+2))),2)
    e_bg_txt=STRTRIM(STRING(ABS(g_error(ilast+1)),format='(g10.3)'),2)
    e_sl_txt=STRTRIM(STRING(ABS(g_error(ilast+2)),format='(g10.3)'),2)
    dispy=dispy-((yrng*(downy+0.01))/device_fac)
    XYOUTS,dispx,dispy,'background',charsize=1.0
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'flat  '+bg_txt+' '+e_bg_txt,charsize=g_char
    dispy=dispy-((yrng*downy)/device_fac)
    XYOUTS,dispx,dispy,'slope '+sl_txt+' '+e_sl_txt,charsize=g_char
    dispy=dispy-((yrng*(downy+0.01))/device_fac)
    XYOUTS,dispx,dispy,'P: Pos. I: Int. W: hwhm',charsize=g_char
return
END

;===============================================================================
FUNCTION gk_fit	,workspace					; ==============
;===============================================================================
;

@lamp.cbk
COMMON gc_save
COMMON gc_wid
COMMON gc_data
COMMON gc_dids

nwt_out=STRTRIM(STRING(nw_out),2)
par_txt(nw_out,*)=''

read_par_vals & tmppar=g_parameters

FOR ind_p=0,g_npeaks-1 DO BEGIN
    peak_num=STRTRIM(STRING(ind_p+1))
    i3=ind_p*3-1
    par_txt(nw_out,i3+1)="Gaussian "+peak_num+" position = "
    par_txt(nw_out,i3+2)="Gaussian "+peak_num+" Height   = "
    par_txt(nw_out,i3+3)="Gaussian "+peak_num+" Width    = "
    if bose(ind_p) then if debal gt 0 then tmppar (i3+2)=tmppar (i3+2)/debal
ENDFOR

    jj=i3+6
    par_txt(nw_out,jj)  ="Spectrum number                = "

par_txt(nw_out,i3+4)="Flat background                = "
par_txt(nw_out,i3+5)="Sloping background             = "

iii=execute("p"+nwt_out+"=tmppar")
WIDGET_CONTROL, bad_id=i, gw_cut_slider, Get_Value=no_coupe
iii=execute("p"+nwt_out+"(jj)=no_coupe")

if strpos(x_tit(nw_out),'(Fitted)') lt 0 then x_tit(nw_out)=x_tit(nw_out)+' (Fitted)'

iii=execute("x"+nwt_out+"=x_out")
iii=execute("e"+nwt_out+"=e_out")
RETURN, w_out
END

;===============================================================================
PRO read_par_vals						; ==============
;===============================================================================
; Get parameters value from fields
;

COMMON gc_wid
COMMON gc_data
COMMON gc_cp
COMMON gc_flags
COMMON gc_dids

flag=" "
idx=(g_pk_nb-1)*3	;.......Read visible parameters for peak

FOR j=0,2 DO BEGIN
 IF g_ctrl_panel THEN BEGIN
    CASE j OF
	0 : BEGIN & wid1=cp_pos(g_pk_nb-1) & END
	1 : BEGIN & wid1=cp_hgt(g_pk_nb-1) & END
	2 : BEGIN & wid1=cp_wid(g_pk_nb-1) & END
    ENDCASE
 ENDIF ELSE BEGIN
    CASE j OF
	0 : BEGIN & wid1=gw_pos_text & wid2=gw_pos_pop & END
	1 : BEGIN & wid1=gw_int_text & wid2=gw_int_pop & END
	2 : BEGIN & wid1=gw_wdt_text & wid2=gw_wdt_pop & END
    ENDCASE
 ENDELSE
 
 WIDGET_CONTROL, bad_id=i, wid1, Get_Value=parval
 on_ioerror,mis1 & ok=0 & tmp=float(parval(0)) & ok=1
 if j eq 1 then if bose(g_pk_nb-1) then if debal gt 0 then tmp=tmp*debal
 g_parameters(idx+j)=tmp
 mis1: if not ok then widget_control,gw_err_lab,set_value='? Convertion error (parameters)'
 
 IF NOT(g_ctrl_panel) THEN BEGIN
    flag=''
    WIDGET_CONTROL, bad_id=i, wid2(1), Get_Value=str
    IF STRPOS(str, 'Un') GE 0 THEN flag=flag+'f'

    IF g_bg_but EQ 1 THEN flag=flag+'b'

    WIDGET_CONTROL, bad_id=i, wid2(3), Get_Value=str
    IF STRLEN(str) GT 15 THEN flag=flag+STRMID(str, 16, 1)
    g_step(idx+j)=flag
 ENDIF
ENDFOR

ilast=g_npeaks*3-1
WIDGET_CONTROL, bad_id=i, gw_fbg_text, Get_Value=parval
on_ioerror,mis2 & ok=0 & tmp=float(parval(0)) & ok=1
g_parameters(ilast+1)=tmp
mis2: if not ok then widget_control,gw_err_lab,set_value='? Convertion error (background)'
flag=''
WIDGET_CONTROL, bad_id=i, gw_fbg_pop(0), Get_Value=str
IF STRPOS(str, 'fx') GE 0 THEN flag=flag+'f'
g_step(ilast+1)=flag

WIDGET_CONTROL, bad_id=i, gw_sbg_text, Get_Value=parval
on_ioerror,mis3 & ok=0 & tmp=float(parval(0)) & ok=1
g_parameters(ilast+2)=tmp
mis3: if not ok then widget_control,gw_err_lab,set_value='? Convertion error (slope)'

flag=''
WIDGET_CONTROL, bad_id=i, gw_sbg_pop(0), Get_Value=str
IF STRPOS(str, 'fx') GE 0 THEN flag=flag+'f'
g_step(ilast+2)=flag
END

;===============================================================================
PRO write_par_vals_2, wid, g_step, idx, j		; ======================
;===============================================================================
; Update interface parameters
; wid

str=''
fixed=0

WIDGET_CONTROL, bad_id=i, wid(1), Get_Value=str
IF STRPOS(g_step(idx+j), 'f') GE 0 THEN BEGIN
    fixed=1
    IF STRPOS(str, 'Un') LT 0 THEN str='Un'+str
ENDIF ELSE IF STRPOS(str, 'Un') GE 0 THEN str=STRMID(str, 2, STRLEN(str))
WIDGET_CONTROL, bad_id=i, wid(1), Set_Value=str

; ??? anciennement fix it as a parameter
;WIDGET_CONTROL, bad_id=i, wid(2), Get_Value=str
;IF STRPOS(g_step(idx+j), 'b') GE 0 THEN BEGIN
;    fixed=1
;    IF STRPOS(str, 'Un') LT 0 THEN str='Un'+str
;ENDIF ELSE IF STRPOS(str, 'Un') GE 0 THEN str=STRMID(str, 2, STRLEN(str))
;WIDGET_CONTROL, bad_id=i, wid(2), Set_Value=str

FOR k=0, strlen(g_step(idx+j)) do BEGIN
    IF (STRMID(g_step(idx+j),k, 1) NE 'f') AND (STRMID(g_step(idx+j),k, 1) NE 'b') THEN BEGIN
	IF  FIX(STRMID(g_step(idx+j),k, 1)) GE 48 AND $
	    FIX(STRMID(g_step(idx+j),k, 1)) LE 57 THEN BEGIN
	        fixed=1
		WIDGET_CONTROL, bad_id=i, wid(2), Set_Value=STRMID(g_step(idx+j),k, 1)
	ENDIF
    ENDIF
ENDFOR

WIDGET_CONTROL, bad_id=i, wid(0), Get_Value=str
IF fixed eq 1 THEN BEGIN
    if STRPOS(str, ' fx ') LT 0 then str=STRMID(str, 0,  STRPOS(str, '    '))+' fx '
ENDIF ELSE BEGIN
    p=STRPOS(str, ' fx ')
    if p GE 0 then str=STRMID(str, 0,  p)+'    '
ENDELSE
WIDGET_CONTROL, bad_id=i, wid(0), Set_Value=str
RETURN
END

;===============================================================================
PRO set_gfit_param, w, p, Fct_Type=ft				; ==============
;===============================================================================
;
COMMON gc_flags
COMMON gc_data
COMMON gc_wid
COMMON gc_save

g_resid		=   1e12	    ; residu is big
WIDGET_CONTROL, bad_id=i, gw_get_but, Set_UValue=[1, 2, w]
gfit_Event,{WIDGET_BUTTON, ID:gw_get_but, TOP:gw_gkfit_base, $
	    HANDLER:0L, SELECT:1}
WIDGET_CONTROL, bad_id=i, gw_get_but, Set_UValue=[1, 2, 0]

g_npeaks=N_ELEMENTS(p)/3
g_ncycles=1
FOR i=0, N_ELEMENTS(p)-1 DO g_parameters(i)=p(i)
IF KEYWORD_SET(ft)    THEN $
    FOR i=0, N_ELEMENTS(ft)-1 DO g_fct_type(i)=ft(i)

write_par_vals
read_par_vals
plot_subf, g_npeaks, g_parameters, x_ni, g_fct_type

RETURN
END

;===============================================================================
PRO write_par_vals, No_Update=no_update			; ======================
;===============================================================================
; Display errors values in widget labels

COMMON gc_wid
COMMON gc_data
COMMON gc_cp
COMMON gc_flags
COMMON gc_dids

;........Writes parameters to visible window
nvarf =0	; nb de variables fixees avant le pic en question
idx=(g_pk_nb-1)*3
;
fixed=0
FOR j=0,2 DO BEGIN
    tmp=g_parameters(idx+j)
    if j eq 1 then if bose(g_pk_nb-1) then if debal gt 0 then tmp=tmp/debal
    parval=STRTRIM(STRING(tmp),2)
    IF g_ctrl_panel THEN BEGIN
    CASE j OF
	0 : BEGIN & wid1=cp_pos(g_pk_nb-1) & END
	1 : BEGIN & wid1=cp_hgt(g_pk_nb-1) & END
	2 : BEGIN & wid1=cp_wid(g_pk_nb-1) & END
    ENDCASE
    ENDIF ELSE BEGIN
    CASE j OF
	0 : BEGIN & wid1=gw_pos_text & wid2=gw_pos_pop & END
	1 : BEGIN & wid1=gw_int_text & wid2=gw_int_pop & END
	2 : BEGIN & wid1=gw_wdt_text & wid2=gw_wdt_pop & END
    ENDCASE
    ENDELSE
    WIDGET_CONTROL, bad_id=i, wid1, Set_Value=parval
    IF NOT(g_ctrl_panel) THEN if not(KEYWORD_SET(No_Update)) THEN write_par_vals_2,wid2, g_step, idx, j
    IF (STRPOS(g_step(idx+j), 'b') GE 0) THEN fixed=1
ENDFOR

IF fixed EQ 1 THEN g_bg_but=1 else g_bg_but=0
WIDGET_CONTROL, bad_id=i, gw_bgfixed, Set_Button=g_bg_but
IF g_ctrl_panel THEN WIDGET_CONTROL, bad_id=i, cp_bck(g_pk_nb-1), Set_Button=g_bg_but
ilast=g_npeaks*3-1

parval=STRTRIM(STRING(g_parameters(ilast+1)),2)

WIDGET_CONTROL, bad_id=i, gw_fbg_text, Set_Value=parval
IF g_ctrl_panel THEN WIDGET_CONTROL, bad_id=i, cp_fb, Set_Value=parval
IF NOT(g_ctrl_panel) THEN IF not(KEYWORD_SET(No_Update)) THEN write_par_vals_2,gw_fbg_pop, g_step, ilast, 1

parval=STRTRIM(STRING(g_parameters(ilast+2)),2)
WIDGET_CONTROL, bad_id=i, gw_sbg_text, Set_Value=parval
IF g_ctrl_panel THEN WIDGET_CONTROL, bad_id=i, cp_sb, Set_Value=parval
IF NOT(g_ctrl_panel) THEN if not(KEYWORD_SET(No_Update)) THEN write_par_vals_2,gw_sbg_pop, g_step, ilast, 1

; Errors Display:
;****************
; ???
;index=where(g_error ne 0,combien)
;IF combien ne 0 THEN g_error=g_error(where(g_error ne 0))
    FOR i=0,3*(g_pk_nb-1)-1 DO BEGIN 
	IF STRPOS(g_step(i),'f') ge 0 THEN nvarf=nvarf+1
    ENDFOR    
    inderr=3*(g_pk_nb-1)-nvarf

    IF STRPOS(g_step(idx),'f') ge 0 THEN err='* FIXED'$
    ELSE BEGIN
	err=STRTRIM(STRING(g_error(inderr)),2)
	inderr=inderr + 1
    ENDELSE  
    WIDGET_CONTROL, bad_id=i, gw_pos_pop(3), Set_Value='Err: '+err

    IF STRPOS(g_step(idx+1),'f') ge 0 THEN err='* FIXED'$
    ELSE BEGIN
	err=STRTRIM(STRING(g_error(inderr)),2)
	inderr=inderr + 1
    ENDELSE  
    WIDGET_CONTROL, bad_id=i, gw_int_pop(3), Set_Value='Err: '+err
    
    IF STRPOS(g_step(idx+2),'f') ge 0 THEN err='* FIXED'$
    ELSE BEGIN
	err=STRTRIM(STRING(g_error(inderr)),2)
	inderr=inderr + 1
    ENDELSE
    WIDGET_CONTROL, bad_id=i, gw_wdt_pop(3), Set_Value='Err: '+err
 
    IF STRPOS(g_step(g_nb_pk_max*3+1),'f') ge 0 THEN BEGIN
	err='* FIXED' 
	ajust=0
    ENDIF ELSE BEGIN
	err=STRTRIM(STRING(g_error(N_ELEMENTS(g_error)-1)),2)
	ajust=1
    ENDELSE
    WIDGET_CONTROL, bad_id=i, gw_sbg_pop(3), Set_Value='Err: '+err
  
    IF STRPOS(g_step(g_nb_pk_max*3),'f') ge 0 THEN err='* FIXED'$
    ELSE err=STRTRIM(STRING(g_error(N_ELEMENTS(g_error)-1-ajust)),2) 
    WIDGET_CONTROL, bad_id=i, gw_fbg_pop(3), Set_Value='Err: '+err
END

;===============================================================================
PRO error_msg, error_number, str1				; ==============
;===============================================================================
; Display error message identified by error_number
;

COMMON gc_wid

CASE error_number OF
    -2: str='Use left mouse-button to define peak #'+STRTRIM(STRING(str1), 2)
    -1: str=str1
    0 : str=''
    1 : str='Invalid view zone.     *** ignored ***'
    2 : str='3D Workspace. Reduced to 2D by summing !'
    3 : str='Woops ...no data !'
    4 : BEGIN
	    print,STRING(7b)
	    str='No better fit found ** Click on peak-slider (above) to reset **'
	END
    5 : str='You can'+STRING(39b)+'t do that. Please fill in a value'
    6 : str='WARNING : defined zone is smaller than fitting zone'
    7 : str='Bum fit : negative height or width !'
    8 : str='Not enough data points in genfit function !'
    9 : BEGIN
    	    print,STRING(7b)
    	    str='Sorry, Not yet implemented !'
	END
    10 : BEGIN
    	    print,STRING(7b)
    	    str='Just a display of position error'
	END
    ELSE:str='!error '+error_number
ENDCASE
WIDGET_CONTROL, bad_id=i, gw_err_lab, Set_Value=str
END

;===============================================================================
PRO traitview_event	,event					; ==============
;===============================================================================
;

COMMON gc_fit_view	& COMMON gc_data	& COMMON gc_fit_excl

WIDGET_CONTROL, bad_id=i, Event.Id, GET_UVALUE=Ev
CASE Ev(0) OF
    'load' : BEGIN ; charge les valeurs des zones texte dans viewarr et
		   ; initialise la zone courante avec ces valeurs
		WIDGET_CONTROL, bad_id=i, x_min, Get_Value=xmin
		WIDGET_CONTROL, bad_id=i, x_max, Get_Value=xmax
		WIDGET_CONTROL, bad_id=i, y_min, Get_Value=ymin
		WIDGET_CONTROL, bad_id=i, y_max, Get_Value=ymax
		viewarr(0+sauv+4*no_zone)=xmin & viewarr(0)=xmin
		viewarr(1+sauv+4*no_zone)=xmax & viewarr(1)=xmax
		viewarr(2+sauv+4*no_zone)=ymin & viewarr(2)=ymin
		viewarr(3+sauv+4*no_zone)=ymax & viewarr(3)=ymax
	     END

    'recall' :	BEGIN ; initialise la zone courante avec les valeurs
		;  de la zone specifiee
		viewarr(0)=viewarr(0+sauv+4*no_zone)
		viewarr(1)=viewarr(1+sauv+4*no_zone)
		viewarr(2)=viewarr(2+sauv+4*no_zone)
		viewarr(3)=viewarr(3+sauv+4*no_zone)
		WIDGET_CONTROL, bad_id=i, x_min, Set_Value=STRTRIM(STRING(viewarr(0)),2)
		WIDGET_CONTROL, bad_id=i, x_max, Set_Value=STRTRIM(STRING(viewarr(1)),2)
		WIDGET_CONTROL, bad_id=i, y_min, Set_Value=STRTRIM(STRING(viewarr(2)),2)
		WIDGET_CONTROL, bad_id=i, y_max, Set_Value=STRTRIM(STRING(viewarr(3)),2)
		END

    'memzone' : BEGIN
		no_zone=Ev(1)
		END

    'done' :	BEGIN  ; on avertit l'utilisateur s'il existe des points de
		 ; la zone a fitter qui ne sont pas dans la zone a tracer :
		gk_warning,excl_param,viewarr
		WIDGET_CONTROL, bad_id=i, event.top, Map=0
		END

    'reset' :	BEGIN
		viewarr(0)=viewarr(0+sauv)
		viewarr(1)=viewarr(1+sauv)
		viewarr(2)=viewarr(2+sauv)
		viewarr(3)=viewarr(3+sauv)
		WIDGET_CONTROL, bad_id=i, x_min, Set_Value=STRTRIM(STRING(viewarr(0)),2)
		WIDGET_CONTROL, bad_id=i, x_max, Set_Value=STRTRIM(STRING(viewarr(1)),2)
		WIDGET_CONTROL, bad_id=i, y_min, Set_Value=STRTRIM(STRING(viewarr(2)),2)
		WIDGET_CONTROL, bad_id=i, y_max, Set_Value=STRTRIM(STRING(viewarr(3)),2)
		END

    ELSE : BEGIN
	   ; Do nothing !
	   END
ENDCASE
END

;===============================================================================
PRO traitexcl_event	,event					; ==============
;===============================================================================
;

@lamp.cbk

COMMON gc_save
COMMON gc_fit_excl
COMMON gc_data
COMMON gc_flags
COMMON gc_wid

g_resid=1.0e12
WIDGET_CONTROL, bad_id=i, Event.Id, GET_UVALUE=Ev
CASE Ev(0) OF 
    'coucou':	BEGIN
		    intv_no=float(Ev(1))
		END

    'done' :  	BEGIN
		    WIDGET_CONTROL, bad_id=i,event.top,Map=0
		END

    'reset':	BEGIN
		    ;initialisation par defaut de excl_param :
		    gk_initialize,/excl
		    adapte ,x_to_plot,w_to_plot,w_out,1
		END
ENDCASE
END

;===============================================================================
pro creer_excl,		id					; ==============
;===============================================================================
; Create widget window to define determinant fitting zone

@lamp.cbk
COMMON gc_fit_excl
COMMON gc_wid

if XREGISTERED('gfit') le 0 then RETURN
if gw_gkfit_base       eq 0 then RETURN
;--------------------------------- gw_excl_base --------------------------------
gw_excl_base= WIDGET_BASE (Group_Leader=gw_gkfit_base ,Resource_Name='lamp', $
				/Column, Title= 'Fit zone', Map=0) 

conseil_lab=WIDGET_LABEL( gw_excl_base ,Font=ft_b_bigger,$
				Value='To choose your fit zone:')
conseil_lab=WIDGET_LABEL( gw_excl_base, Font=ft_b_bigger,$
				Value='Drag the right mouse-button')

; ..... all_but_base :
all_but_bse=WIDGET_BASE  (gw_excl_base, /Row)
reset_but  =WIDGET_BUTTON(all_but_bse, Font=ft_b_bigger ,$
				UValue=['reset'], Value='Reset')
empty_lab  =WIDGET_LABEL (all_but_bse, Font=ft_propor, Value='     ')
int_but_bse=WIDGET_BASE  (all_but_bse ,/Row ,/Exclusive)

FOR i=1,max_nb_int DO BEGIN
    coucou =WIDGET_BUTTON(int_but_bse ,font=ft_b_bigger, $
			    Value=STRTRIM(STRING(i),2)+'     ',$
			    UValue=['coucou',STRTRIM(STRING(i),2)])
    IF i EQ 1 THEN gw_excl_but=coucou
ENDFOR
intv_no=1
WIDGET_CONTROL, bad_id=i, coucou, /Set_Button 


ok_but	      =WIDGET_BUTTON(all_but_bse,Font=ft_b_bigger,$
				UValue=['done'],Value='Done')
; ..... END of all_but_base

int_defin  =WIDGET_BASE (gw_excl_base ,/Column)
lab_min_max=WIDGET_BASE (int_defin ,/Row)
intv_nb	   =WIDGET_LABEL(lab_min_max, Font=ft_propor, Value='          ')

FOR i=1,max_nb_int DO BEGIN
    lab_min_max=WIDGET_BASE(int_defin,/Row)
    intv_nb=WIDGET_LABEL(lab_min_max, Font=ft_propor, Value='interval #'+$
			   STRTRIM(STRING(i),2)+':   xmin=')
    xmin =WIDGET_LABEL(lab_min_max,Font=ft_propor,UValue=['xmin',STRTRIM(STRING(i),2)])
    excl_widge(2*(i-1))=xmin	; to be able to write in this label
    WIDGET_CONTROL, bad_id=iii,xmin,Set_Value=STRTRIM(STRING(excl_param(2*i-2)),2)
    xmax_lab=WIDGET_LABEL(lab_min_max ,Font=ft_propor,Value='     xmax=')
    xmax  =WIDGET_LABEL ( lab_min_max ,Font=ft_propor,UValue =['xmax',STRTRIM(STRING(i),2)])
    excl_widge(2*i-1)=xmax
    WIDGET_CONTROL, bad_id=iii, xmax, Set_Value=STRTRIM(STRING(excl_param(2*i-1)),2)
ENDFOR

bid=sys_dep('DYNLAB', gw_excl_base, 1)
WIDGET_CONTROL, bad_id=i, gw_excl_base, /Realize
XMANAGER, 'traitexcl', gw_excl_base, /Just_Reg, Cleanup='creer_excl'
END

;-------------------------------- END of gw_excl_base --------------------------

;===============================================================================
PRO creer_view,		id					; ============== 
;===============================================================================
;

@lamp.cbk
COMMON gc_fit_view	& COMMON gc_data	& COMMON gc_wid

if XREGISTERED('gfit') le 0 then RETURN
if gw_gkfit_base       eq 0 then RETURN
;----------------------------- gw_view_base --------------------------------------
gw_view_base=WIDGET_BASE(Group_Leader=gw_gkfit_base ,Resource_Name='lampdon' ,$
			 /Column, Title='View', Map=0)
invit_lab=WIDGET_LABEL	(gw_view_base , Font=ft_b_bigger ,$
			 Value='Select plot range :')
qwer_BASE=WIDGET_BASE 	( gw_view_base ,/row ) 
load_but =WIDGET_BUTTON	(qwer_base ,UValue=['load'] ,$
				Font=ft_b_bigger, Value=' Load ')
zone_base=WIDGET_BASE	(qwer_BASE ,/Row ,/Exclusive )

nbzone=3			    ; as defined in gfit
FOR i=1,nbzone DO BEGIN
    m=WIDGET_BUTTON(zone_base ,UValue=['memzone',STRTRIM(STRING(i),2)] ,$
				Font=ft_b_bigger, Value=STRTRIM(STRING(i),2))
    IF (i eq 1) THEN WIDGET_CONTROL, bad_id=iii, m, /Set_Button
ENDFOR

recall_but =WIDGET_BUTTON(qwer_base, UValue=['recall'] ,$
				Font=ft_b_bigger, value='Recall')
x_base	   =WIDGET_BASE  ( gw_view_base, /Row )
x_lab	   =WIDGET_LABEL ( x_base, Font=ft_b_bigger, Value='Xrange  :')
x_min	   =WIDGET_TEXT  ( x_base, /Editable, Font=ft_propor, $
				UValue=['x_min'] , Xsize=9 , Value='') 
x_max	   =WIDGET_TEXT  ( x_base, /Editable, Font=ft_propor, $
				UValue=['x_max'] , XSize=9, Value='') 
y_base	   =WIDGET_BASE  ( gw_view_base ,/Row )
y_lab	   =WIDGET_LABEL ( y_base, Font=ft_propor, Value='Yrange  :')
y_min	   =WIDGET_TEXT  ( y_base, /Editable ,Font=ft_propor, $
				UValue=['y_min'], Xsize=9, Value='')
y_max	   =WIDGET_TEXT  ( y_base, /Editable,Font=ft_propor, $
				UValue=['y_max'], Xsize=9, Value='')
  
  
small_base =WIDGET_BASE  ( gw_view_base ,/Row )

reset_but  =WIDGET_BUTTON(small_base, UValue=['reset'],$
				Font=ft_b_bigger, Value=' Reset ')
vide	   =WIDGET_LABEL (small_base , Font=ft_propor, Value='                           ')
done_but   =WIDGET_BUTTON(small_base , UValue=['done'] ,$
				Font=ft_b_bigger, Value=' Done ')
bid=sys_dep('DYNLAB', gw_view_base, 1)
WIDGET_CONTROL, bad_id=i, gw_view_base, /Realize
XMANAGER , 'traitview' , gw_view_base ,/Just_Reg, Cleanup='creer_view'
;------------------------------ END of gw_view_base ----------------------------
END

;===============================================================================
PRO gfit, Just=just, Group=group, Tripx=tripx, tx_param		; ==============
;===============================================================================
;

@lamp.cbk
COMMON gc_save
COMMON gc_fit_view
COMMON gc_wid
COMMON gc_data
COMMON gc_flags
COMMON gc_fit_excl
COMMON gc_cp
COMMON gc_width_factor
COMMON gc_dids

;Factors for using measured widths for peaks
;
gw_fac=2.0*sqrt(2.)
lw_fac=0.5

IF N_ELEMENTS(tx_param) EQ 0 THEN g_tx_par=[''] ELSE g_tx_par=tx_param
IF KEYWORD_SET(tripx) THEN g_tripx=1 ELSE g_tripx=0
IF KEYWORD_SET(just) THEN g_ctrl_panel=1 ELSE g_ctrl_panel=0
IF (!D.flags and 65536) eq 0  THEN print,'set_plot,"X" before using rdfilter' else  $
IF (XREGISTERED('gfit') le 0) THEN BEGIN
    cp_nb	=0
    cp_bck	=0 	
    cp_pos	=0  
    cp_hgt	=0
    cp_wid	=0 
    cp_pf	=0
    cp_hf	=0 
    cp_wf	=0
    cp_fb	=0
    cp_sb	=0
    cp_fbf	=0 
    cp_sbf	=0 
    
  g_old_plot_wid=!D.window
  P_MUS,'mus_harp'				; PLAY a tune
  g_fct_name	='Gauss' ; Default is Gauss
  g_old_pk_nb	=1	 ; old peak number
  g_afitisdone	=0	 ; No fit was done
  g_pk_nb	=1	 ; number of peak processed
  g_char	=0.8	 ;
  g_print_nb	=0	 ;
  g_show_subfct	=1	 ; if this flag is set, subfunctions are plotted
  bb1		=0	 ;l'une des bornes d'un intervalle a exclure (sert a la saisie)
  bb2		=0	 ;idem bb1 
  g_nb_pk_max	=6	 ;<----change peaks maximum number 
  max_nb_int	=3	 ;<----change excluded zone maximum number
  sauv		=4	 ;deplacement (dans viewarr) donnant la zone a afficher initiale
  nbzone	=3	 ;stored zones number
  no_zone	=1	 ;initializing zone number
  g_bg_but	=0	 ;fixed as background button is unset by default
  viewarr	=FLTARR(8+nbzone*4)	 ;dim zone to view array
  excl_param	=FLTARR(2*max_nb_int)	 ;bornes des intervalles exclus
  excl_widge	=LONARR(2*max_nb_int)	 ;widget IDs des fenetres d'affichage des bornes 
  g_parameters	=FLTARR(3*g_nb_pk_max+3) ;parametres position,height,width + flat,slope
  g_step	=STRARR(3*g_nb_pk_max+2) ;extensions des champs pos,height,width,flat,slope
  g_error	=FLTARR(3*g_nb_pk_max+2) ;erreurs sur les parametres correspondants de g_parameters
  g_fct_type	=STRARR(g_nb_pk_max)
  gw_pos_pop	=LONARR(10)		 ;widget ID of pos parameter menu
  gw_int_pop	=LONARR(10)		 ;widget ID of int parameter menu
  gw_wdt_pop	=LONARR(10)		 ;widget ID of wdt parameter menu
  gw_fbg_pop	=LONARR(10)		 ;widget ID of fbg parameter menu
  gw_sbg_pop	=LONARR(10)		 ;widget ID of sbg parameter menu
  sw_ni		=[0]
  g_npeaks	=1
  g_ncycles	=2
  peaky		=0.0
  g_resid	=1.0e12
  bose		=LONARR(g_nb_pk_max)
  debal         =0
  mimirange	=[0,0]
  mimion	=0
  ximion	=0

  g_fct_type(*)	=g_fct_name
  nw_ni=0 & nw_out=1
  IF g_tripx THEN nw_ni=23 ELSE BEGIN
      if lamp_b1 ne 0 then p_did_getw_cur, nw_ni, wstr	; get current w number
      if nw_ni EQ 0 THEN nw_ni=1	; if not defined THEN w=1
      if nw_ni GT lamp_sys THEN nw_ni=1
      nw_out	=nw_ni+1
  ENDELSE
  IF nw_out GT lamp_sys THEN nw_out=lamp_sys

IF N_ELEMENTS(Group) EQ 0 THEN GROUP=lamp_b1
junk		= { CW_PDMENU_S, flags:0, name:'' }

; the whole lamp size depending modifications is here
sl_size =16
if lamp_siz gt 900 then BEGIN
    xsiz=800 & ysiz=440
ENDIF ELSE BEGIN
    xsiz=700 & ysiz=280
ENDELSE
if lamp_siz lt 800 then BEGIN	; adapt to lamp size
    xsiz=550 & ysiz=250		; adapt plotting window size
    sl_size=15
ENDIF
txt_hlp=  '(LEFT press=position  release=width)....(RIGHT= Define Fitting Area)'

gw_gkfit_base=WIDGET_BASE(GROUP_LEADER=Group, /Row, $
				Title='Lamp GKfit Version 8th Aug 02 (gjk)',resource_name='lamp')
MAIN_BIS     =WIDGET_BASE  (gw_gkfit_base, /Column, Title='main_col_base')
; -------------------------  GET_WRITE_BASE  ------------------------------------
GET_WRITE_BASE=WIDGET_BASE  (MAIN_BIS, /Row, Frame=2,resource_name='don')
gw_get_but  =WIDGET_BUTTON(GET_WRITE_BASE, Font=ft_b_bigger,$
				UValue=[1,2,0], Value='Get Ws #')
ws_in_b	    =WIDGET_BASE  (GET_WRITE_BASE ,/column)
IF g_tripx THEN i=23 ELSE i=lamp_sys
ws_in_sld   =WIDGET_SLIDER(ws_in_b, XSIZE=xsiz*.36,$
				Maximum=i,Minimum=1,Font=ft_b_bigger,$
				UValue=[1,1,0], Value=nw_ni)
ws_in_r	    =WIDGET_BASE  (ws_in_b,/row)
gw_cut_slider= WIDGET_SLIDER(ws_in_r, /Drag, Minimum=1, XSize=100,$
				UValue=[1,3,0], /Suppress)
WIDGET_CONTROL, bad_id=i, gw_cut_slider, Sensitive=0
WIDGET_CONTROL, bad_id=i, ws_in_r      , Map=0
gw_cut_label=WIDGET_LABEL (ws_in_r,Font=ft_b_normal,Value=' ',xsize=100)
ws_in_b	    =WIDGET_BASE  (GET_WRITE_BASE ,/column)
ws_out_sld  =WIDGET_SLIDER(ws_in_b, XSize=xsiz*.36, Maximum=lamp_sys, Minimum=1,$
				Title='Out Workspace #', Font=ft_b_bigger,$
				UValue=[1,4,0], Value=nw_out)
ws_write_but=WIDGET_BUTTON(GET_WRITE_BASE ,Font=ft_b_bigger ,$
				UVALUE=[1,5,0] ,VALUE='Write to Ws #')
;---------------------- END of GET_WRITE_BASE  -------------------------
; Threerows : base of the 3 rows under the get and write buttons.
THREEROWS=WIDGET_BASE     (MAIN_BIS, /Column, Title='row_base')
; ----------- END of ROW1_BASE ------ BEGIN of ROW2_BASE ---------------
IF g_ctrl_panel THEN gfit_ctrl_panel ELSE BEGIN
    ROW2_BASE=WIDGET_BASE     (THREEROWS ,/Row)
    set_show_base= WIDGET_BASE  (ROW2_BASE, /Column, /frame,resource_name='don')
    
;   peak_menu2=WIDGET_BASE     (set_show_base , Column=g_nb_pk_max)
    peak_men2 =WIDGET_BASE     (set_show_base ,/row)
    gw_type_but=LONARR(g_nb_pk_max)  
    gw_gau_but=LONARR(g_nb_pk_max)
    gw_lor_but=LONARR(g_nb_pk_max)
    gw_peak_but=LONARR(g_nb_pk_max*2)
    
    FOR i=1,g_nb_pk_max DO BEGIN
	peak_menu2      =WIDGET_BASE   (peak_men2 , /Column) & gw_peak_but(g_nb_pk_max+i-1)=peak_menu2
	gw_type_but(i-1)=WIDGET_BUTTON (peak_menu2, /Menu, Font=ft_propor,$
				    UValue=[4,i,1], Value='Gau')
	gw_gau_but(i-1)	=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,1],Value='Gauss'  , Font=ft_propor)
	gw_lor_but(i-1)	=WIDGET_BUTTON(gw_type_but(i-1), UValue=[4,i,2],Value='Lorentz', Font=ft_propor)
	peak_base	=WIDGET_BASE(peak_menu2, /Exclusive)
	gw_peak_but(i-1)=WIDGET_BUTTON(peak_base,/No_Release , Value=STRTRIM(STRING(i),2),$
				       UValue=[2,2,0], Font=ft_b_bigger) 
	; only first button remains sensitive as g_npeaks=1
	floo=floor(1/i)
	WIDGET_CONTROL, bad_id=iii, gw_peak_but(i-1), Sensitive=floo
	WIDGET_CONTROL, bad_id=iii, gw_type_but(i-1), Sensitive=floo
	WIDGET_CONTROL, bad_id=iii, gw_peak_but(g_nb_pk_max+i-1), map=floo
    ENDFOR
    
    WIDGET_CONTROL, bad_id=iii, gw_peak_but(0), Set_Button=1    ; First button is set (Default)
    
    ;.... END of set/show peak
    szsl=0 & str=''
    if sys_dep('VERSION') ge 4.0 then ii=execute('str=WIDGET_INFO(peak_menu2,/geometry) & szsl=str.xsize')
    if szsl le 0 then $
    gw_pk_slider=WIDGET_SLIDER(set_show_base, Maximum=g_nb_pk_max,      $
				    Minimum=1,/Suppress_Value, YSize=15,$
				    UVALUE=[2,1,0],Value=g_npeaks) else $
    gw_pk_slider=WIDGET_SLIDER(set_show_base, Maximum=g_nb_pk_max,      $
				    Minimum=1,/Suppress_Value, YSize=15,$
				    UVALUE=[2,1,0],Value=g_npeaks,XSize=szsl>150)
    
    peak_lab    =WIDGET_LABEL (set_show_base, Font= ft_b_bigger,$
				    VALUE='The slider sets the # of functions')
    
    ;.... fit , cycle # , peak # , spectrum #.....
    
    base	   =WIDGET_BASE   (ROW2_BASE ,/Column, Map=1,/Frame,resource_name='don')
    bloc_base  =WIDGET_BASE   (base , /row)		;.... gw_resid_lab .... 
    resid_lab  =WIDGET_LABEL  (bloc_base,Value ='Residual:', Font=ft_normal)
    gw_resid_lab= WIDGET_LABEL  (bloc_base,Value ='______________',UValue='resid_field',Font=ft_b_normal)
    gw_cycle_lab= WIDGET_LABEL  (base, Font=ft_b_normal, Value='  '+$
				     STRTRIM(STRING(g_ncycles),2)+' Cycles')
    
    cycles_sld =WIDGET_SLIDER (base, Maximum=75, Minimum=0, /Drag,$
				    Value=g_ncycles, xsize=xsiz/4.8, $
				    YSize=sl_size, /Suppress_Value, UValue=[2,3,0])
    
    fit_but	   =WIDGET_BUTTON (base ,Font=ft_biggest, $
				    UValue=[2,4,0], Value ='FIT IT')
    
    base3	   =WIDGET_BASE   (ROW2_BASE, /Column, /Frame,resource_name='don')
    base3_row1 =WIDGET_BASE	  (base3, /Row)
;   view_but= WIDGET_BUTTON   (base3_row1, Font=ft_biggest,$
;				    UValue=[2,6,0], Value=' View  ')
;   WIDGET_CONTROL, bad_id=iii, view_but, Sensitive=0
    excl_but =WIDGET_BUTTON   (base3_row1, Font=ft_biggest ,$
				    UValue=[2,5,0], Value='Fit zone')
    
    base3r   =WIDGET_BASE     (base3 ,/Row )
    show_bse =WIDGET_BASE     (base3r,/NonExclusive, /Row )
    show_but =WIDGET_BUTTON   (show_bse, Font=ft_b_normal, UValue=[2, 8,0],$
				    Value='Show subfuncts')
    WIDGET_CONTROL, bad_id=iii,show_but, /Set_Button 
    gw_bose  =WIDGET_BUTTON   (show_bse, Font=ft_b_normal, UValue=[2,10,0],$
				    Value='T(K):')
    gw_temp  =WIDGET_TEXT     (base3r, Font=ft_propor,xsize=4,ysize=1,/editable)
    
    base3_row2 =WIDGET_BASE	  (base3, /Row)
    print_but=WIDGET_BUTTON   (base3_row2,Font=ft_biggest,$
				    UValue=[3,1,0],Value=' Print ')
    help_but =WIDGET_BUTTON   (base3_row2,Font=ft_biggest,$
				    UValue=[3,2,0],Value=' Help ')
    gw_exit_but=WIDGET_BUTTON (base3_row2,Font=ft_biggest,$
				    UValue=[3,3,0], Value=' DONE ')
ENDELSE    
;------------------------------- BEGIN of ROW3_BASE -------------------
err_base     =WIDGET_BASE   (MAIN_BIS, /Frame,resource_name='don')
blog	     =WIDGET_BASE   (err_base,/row)
	      put_logo	    ,blog
gw_err_lab   =WIDGET_LABEL  (blog, Value=' ', Font=ft_b_normal,xsize=xsiz-100)

membis       =WIDGET_BASE   (MAIN_bis ,/row)
gwmimi       =WIDGET_BUTTON (widget_base(membis,/NonExclusive),Font=ft_smaller,UValue=[2,11,0],Value='Yr:')
gw_mimi      =WIDGET_TEXT   (membis, Font=ft_smaller,xsize=9,ysize=1,/editable,UValue=[2,13,0],Value='Min , Max')
gxmimi       =WIDGET_BUTTON (widget_base(membis,/NonExclusive),Font=ft_smaller,UValue=[2,12,0],Value='Xr:')
gx_mim1      =WIDGET_TEXT   (membis, Font=ft_smaller,xsize=9,ysize=1,/editable,UValue=[2,13,0],Value='Min , Max')
bid          =WIDGET_LABEL  (membis, Value=' ',Font=ft_propor)
help_label   =WIDGET_LABEL  (membis ,Value=txt_hlp,Font=ft_b_normal)
;------------------------------- BEGIN of gw_plot_area --------------------
gw_plot_area =WIDGET_DRAW    (MAIN_BIS, /Button_Events, Frame=5,Retain=2,$
			     UValue=[2,7,0],Colors=-8,XSize=xsiz,YSize=ysiz)
;------------------------------- BOTTOM BASE ---------------------------
bottom_base =WIDGET_BASE  (MAIN_BIS , /Row,resource_name='don')
IF lamp_siz GE 900 THEN $
    label_blanc =WIDGET_LABEL (bottom_base ,Value=' ',Font=ft_smaller)

gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_pk_no     =WIDGET_LABEL (gw_base, Font=ft_b_normal, Frame=2, Value='Peak #1 param')
;gw_peak_no  =WIDGET_BUTTON(gw_base, Font=ft_b_normal, Value='Peak # ')
gw_base	     =WIDGET_BASE  (gw_base, /NonExclusive)
gw_bgfixed   =WIDGET_BUTTON(gw_base, UValue=[5, 0], Value='is background',Font=ft_b_normal)
;.... position ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_pos_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_pos_pop(0)=WIDGET_BUTTON(gw_base, /Menu, Font=ft_propor,$
				UValue=[5,1,0], Value='Position    ')
gw_pos_pop(3)=WIDGET_BUTTON(gw_pos_pop(0), UValue=[5,1,0], $
			    Value='Err :',  Font=ft_propor)
gw_pos_pop(1)=WIDGET_BUTTON(gw_pos_pop(0) , UValue=[5,1,1], $
			    Value='Fix this parameter', Font=ft_propor)
gw_pos_pop(2)=WIDGET_BUTTON(gw_pos_pop(0), UValue=[5,1,2], $
			    Value='Fixed as peak #',/Menu, Font=ft_propor)
FOR j=1,6 do $
gw_pos_pop(3+j)=WIDGET_BUTTON(gw_pos_pop(2), UValue=[5,1,2+j], $
			      Value=' '+STRTRIM(STRING(j), 2)+' ', Font=ft_propor)
gw	     =WIDGET_BUTTON(gw_pos_pop(2),  UValue=[5,1,9], Value='None', Font=ft_propor)

;.... integral ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_int_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_int_pop(0)=WIDGET_BUTTON(gw_base, /Menu, Font=ft_propor, $
			    Value='Height    ')
gw_int_pop(3)=WIDGET_BUTTON(gw_int_pop(0), UValue=[5,2,0], $
			    Value='Err :', Font=ft_propor)
gw_int_pop(1)=WIDGET_BUTTON(gw_int_pop(0) , UValue=[5,2,1], $
			    Value='Fix this parameter', Font=ft_propor)
gw_int_pop(2)=WIDGET_BUTTON(gw_int_pop(0), UValue=[5,2,2], $
			    Value='Fixed as peak #', /Menu, Font=ft_propor)
FOR j=1,6 do $
gw_int_pop(3+j)=WIDGET_BUTTON(gw_int_pop(2), UValue=[5,2,2+j], $
			    Value=' '+STRTRIM(STRING(j), 2)+' ', Font=ft_propor)
gw	     =WIDGET_BUTTON(gw_int_pop(2),  UValue=[5,2,9], $
			    Value='None', Font=ft_propor)

;.... width ....  
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_wdt_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_wdt_pop(0)=WIDGET_BUTTON(gw_base, /Menu, Font=ft_propor, $
			    Value='Width    ')
gw_wdt_pop(3)=WIDGET_BUTTON(gw_wdt_pop(0), UValue=[5,3,0], $
			    Value='Err :', Font=ft_propor)
gw_wdt_pop(1)=WIDGET_BUTTON(gw_wdt_pop(0) ,UValue=[5,3,1], $
			    Value='Fix this parameter', Font=ft_propor)
gw_wdt_pop(2)=WIDGET_BUTTON(gw_wdt_pop(0), UValue=[5,3,2], $
			    Value='Fixed as peak #', /Menu, Font=ft_propor)
FOR j=1,6 do $
gw_wdt_pop(3+j)=WIDGET_BUTTON(gw_wdt_pop(2), UValue=[5,3,2+j], $
			    Value=' '+STRTRIM(STRING(j), 2)+' ', Font=ft_propor)
gw	     = WIDGET_BUTTON(gw_wdt_pop(2),  UValue=[5,3,9], $
			    Value='None', Font=ft_propor)

; .... flat_bg ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_fbg_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_fbg_pop(0)=WIDGET_BUTTON (gw_base, /Menu, Font=ft_propor,Value='Flat Bg.    ')
gw_fbg_pop(3)=WIDGET_BUTTON(gw_fbg_pop(0), UValue=[5,4,0], $
			    Value='Err :', Font=ft_propor)
gw_fbg_pop(1)=WIDGET_BUTTON(gw_fbg_pop(0) ,UValue=[5,4,1], $
			    Value='Fix this parameter', Font=ft_propor)

;.... slope_bg ....
gw_base      =WIDGET_BASE  (bottom_base, /Column)
gw_sbg_text  =WIDGET_TEXT  (gw_base, Value='0.0',/Editable, $
			    Font=ft_propor,XSize=8, UValue=[6, 0, 0])
gw_sbg_pop(0)=WIDGET_BUTTON (gw_base, /Menu, Font=ft_propor, $
			    Value='Slope Bg.    ')
gw_sbg_pop(3)=WIDGET_BUTTON(gw_sbg_pop(0), UValue=[5,5,0], $
			    Value='Err :',  Font=ft_propor)
gw_sbg_pop(1)=WIDGET_BUTTON(gw_sbg_pop(0), UValue=[5,5,1], $
			    Value='Fix this parameter', Font=ft_b_normal)

;--------------------------- END of BOTTOM BASE --------------------------
FOR j=1,g_nb_pk_max DO BEGIN	    ; Make unsensitive peak popup menu
    ; only first button remains sensitive as g_npeaks=1
    WIDGET_CONTROL, bad_id=iii, gw_pos_pop(j+3) ,Sensitive=floor(1/j) 
    WIDGET_CONTROL, bad_id=iii, gw_int_pop(j+3), Sensitive=floor(1/j) 
    WIDGET_CONTROL, bad_id=iii, gw_wdt_pop(j+3), Sensitive=floor(1/j) 
ENDFOR

; If active, those lines disable the fix as line ...
WIDGET_CONTROL, bad_id=i, gw_pos_pop(2), Sensitive=0
WIDGET_CONTROL, bad_id=i, gw_int_pop(2), Sensitive=0
WIDGET_CONTROL, bad_id=i, gw_wdt_pop(2), Sensitive=0

bid=sys_dep('DYNLAB', gw_gkfit_base, 1)
WIDGET_CONTROL, bad_id=i, gw_gkfit_base, /Realize & put_logo

; Get drawable window index
WIDGET_CONTROL, bad_id=i, gw_plot_area, GET_VALUE=g_plot_wid
wset,g_plot_wid

if lamp_b1 gt 0 then XMANAGER, 'gfit', gw_gkfit_base, /just_reg $
else g_char=0.4

creer_excl		; creation de gw_excl_base
creer_view		; creation de gw_view_base
; Simulate a get workspace button event
gfit_event,{WIDGET_BUTTON,ID:gw_get_but,TOP:gw_gkfit_base,HANDLER:0L,SELECT:1}
error_msg, -2, 1

if lamp_b1 le 0 then XMANAGER, 'gfit', gw_gkfit_base

ENDIF ELSE IF g_tripx THEN $
    gfit_event,{WIDGET_BUTTON,ID:gw_get_but,TOP:gw_gkfit_base,HANDLER:0L,SELECT:1}
IF g_ctrl_panel THEN gfit_ctrl_panel
;mmmap=0 ELSE mmmap=1
;WIDGET_CONTROL, bad_id=i, gw_gkfit_base, Map=mmmap
END
;	***************************
	     pro myhelp, TEXT
;	***************************

;This is effective when the string-array TEXT is more than one element.

text=['This text is printed when the user clicks on the first ? of lamp']

end
function write_tag, lev , tag , attr , str ,opn
;******* *********
ctrT=' '
for i=1,lev do ctrT=ctrT+' '
if tag  gt '' then if opn gt 0 then ctrT=ctrT+'<'+tag else ctrT=ctrT+'</'+tag
if attr gt '' then ctrT=ctrT+' '+attr+'> '  else if tag  gt '' then ctrT=ctrT+'> '
if str  gt '' then ctrT=ctrT+str
if opn  eq 2  then ctrT=ctrT+'</'+tag+'>'
return, ctrT
end

;** *********
pro write_xml, FileName , Data , XC=x, YC=y , ZC=z , E=e  , N=n   $
                               , PR=p, PV=pv, P_TXT=p_txt         $
                               , W_tit=wt  , X_tit=xt , Y_TIT=yt  $
                               , Z_tit=zt  , OTHER_TIT=ot, PAR_TXT_ALL=pa_txt $
                               , SRC=src, HIST=hist, LIM=lim, MACH=mach $
                               , DOE=doe, SNAP=snap, DATE=date, FIFI=fifi
;**
;**	Keywords:
;**		  XC       = vector of x coordinates.
;**		  YC       = vector of y coordinates.
;**		  ZC       = vector of z coordinates.
;**		  W_TIT    =   main title
;**		  X_TIT    = x axis title
;**		  Y_TIT    = y axis title
;**		  Z_TIT    = z axis title
;**		  OTHER_TIT=    sub title
;**		  N        = monitors
;**		  PR       = vector of parameter values
;**		  PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  PV       = an array of any dimensions containing other parameter values
;**		  E        = the errors associated to DATA (same size)
fid=0
CATCH,stat & IF stat ne 0 then begin print,!err_string & return & endif
ON_IOERROR,mis

;******************
;**For Tests only**
;******************
if n_elements(p) eq 0 then begin s=size(Data)
   e=findgen(s(1)) & p=[1.,2.] & p_txt=['a','b'] & pv=findgen(2,3,4) & fifi=FileName
   n=[1,2,3]       & x=indgen(s(1))  & if s(0) gt 1 then y=indgen(s(2)) else y=4.5
   pa_txt=p_txt+ ' = '+string(p)     & if s(0) gt 2 then z=indgen(s(3)) else z=6.4
   wt='W' & xt='X' & yt='Y' & zt='Z' & ot='O' & src='Test'   & hist='Histoire'
   lim='This is limtx' & mach='win'  & snap=bytscl(dist(15)) & date=systime()
   endif
;*****************
;**Preliminaries**
;*****************
if wt eq '' then wt='W' & if xt eq '' then xt='X' & if yt  eq '' then yt='Y'
if zt eq '' then zt='Z' & if ot eq '' then ot='s' & if src eq '' then src='?'
myRG =[max(Data,min=mini),mini]
if n_elements(date)   ne 1 then date=''
if n_elements(fifi)   ne 1 then fifi=FileName
if n_elements(pa_txt) lt n_elements(p) then pa_txt=p_txt + '=' + string(p)

fileN=FileName & i=rstrpos(fileN,'.') & if i gt 0 then fileN=strmid(fileN,0,i)
fileG=fileN                           & i=strpos(FileName,fifi)>0   & lan=0
fileZ=strmid(fileG,i,60)              & fileF=fileZ+'.xml' & fileG=fileZ+'-1.png'
codx='txt' & codz='.gz'
if !version.release lt '5.3' then begin codx='xdr' & codz="" & endif

sx=n_elements(X) & sy=n_elements(Y) & sz=n_elements(Z)
S =size(Data)
xd=S(1) & dim=strtrim(string(xd),2)
	if S(0) gt 1 then begin yd=s(2) & dim=dim+','+strtrim(string(yd),2) & endif else yd=0
      if S(0) gt 2 then begin zd=s(3) & dim=dim+','+strtrim(string(zd),2)
		if sz lt zd then   Z=findgen(zd)+1 & sz=n_elements(Z)         & endif else zd=0

tiip=['ud','byte','int','long','float','double','double','string','ud','ud','ud','ud','uint','ulong','ud','ud']
tip =tiip(s(s(0)+1))
ymj =bin_date(systime()) & day=string(ymj(0),format='(I4,"-")')+string(ymj(1),format='(I2,"-")')+ $
                               string(ymj(2),format='(I2," ")')+string(ymj(3),format='(I2,":")')+ $
                               string(ymj(4),format='(I2,":")')+string(ymj(5),format='(I2)')
mon =float(N(*,0))

;*******************
;**Create XML file**
;*******************
OPENW,fid, FileN+'.xml', /get_lun
;*    ***
 str ='Written_by_LAMP: Lamp + Idl'+!version.release+' on '+!version.os   ;+' '+!version.os_family
 attr=      'file_name="'+FileF+'"'
 attr=attr+' file_time="'+day+'"'
 attr=attr+     ' user="'+src+' '+date+'"'
 PRINTF, fid, write_tag(0 , 'NXmlfile' , attr , str ,1) & PRINTF,fid,''

  if n_elements(hist) eq 1 then str=hist else str=''
  PRINTF, fid, write_tag(1 , 'NXentry'  , 'name="entry1"' , str  ,1) & PRINTF,fid,''

   attr='title="'+wt+'" sub_title="'+ot+'"'
   if n_elements(src)   eq 1 then attr=attr+' source="'+src +'"'
   if n_elements(p)     eq 1 then attr=attr+ ' param="'+strtrim(string(p(0)),2)+'"'
   PRINTF, fid, write_tag(2 , 'NXdata'  , attr  , lim  ,1) & PRINTF,fid,''

     np=n_elements(p)
     if np gt 1 then begin
      PRINTF, fid, write_tag(3 , 'Parameters' , 'lines="'+strtrim(string(np),2)+'"' ,'',1)
      for i=0,np-1 do PRINTF, fid, write_tag(4 ,'','', pa_txt(i) ,0)
      PRINTF, fid, write_tag(3 , 'Parameters'  , '' , '' , 0) & PRINTF,fid,''
     endif

     if n_elements(snap) gt 1 then begin WRITE_KIF,FileG,snap,transparent=[0] ;ii=sys_dep('GIFTRANS',FileG)
      if strpos(FileG,'.png') gt 0 then giff='type="png"'
      if strpos(FileG,'.jpg') gt 0 then giff='type="jpeg"'
      if strpos(FileG,'.gif') gt 0 then giff='type="gif"'
      attr=giff+' size="[192,192]" file_name="'+FileG+'"'
      PRINTF, fid, write_tag(3 , 'Snapshot'  , attr  , ''  ,2) & PRINTF,fid,''
     endif

     if sx gt 1 then begin sxc=size(x)  & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	attr='axis="1" type="float" dims="['+SC+']" units="" label="'+xt+'"'
	PRINTF, fid, write_tag(3 , 'X_coord'  , attr  , ''  ,1)
	PRINTF, fid, float(x)
	PRINTF, fid, write_tag(3 , 'X_coord'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif
     if sy gt 1 then begin sxc=size(y)  & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	attr='axis="2" type="float" dims="['+SC+']" units="" label="'+yt+'"'
	PRINTF, fid, write_tag(3 , 'Y_coord'  , attr  , ''  ,1)
	PRINTF, fid, float(y)
	PRINTF, fid, write_tag(3 , 'Y_coord'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif
     if sz gt 1 then begin sxc=size(z)  & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	attr='axis="3" type="float" dims="['+SC+']" units="" label="'+zt+'"'
	PRINTF, fid, write_tag(3 , 'Z_coord'  , attr  , ''  ,1)
	PRINTF, fid, float(z)
	PRINTF, fid, write_tag(3 , 'Z_coord'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif

     if n_elements(PV) gt 1 then begin sxc=size(PV) & SC=strtrim(string(sxc(1)),2)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	if sxc(0) gt 2 then SC=SC+','+strtrim(string(sxc(3)),2)
	if sxc(0) gt 3 then SC=SC+','+strtrim(string(sxc(4)),2)
	attr='type="float" dims="['+SC+']"'
	PRINTF, fid, write_tag(3 , 'Var_params'  , attr  , ''  ,1)
	PRINTF, fid, PV
	PRINTF, fid, write_tag(3 , 'Var_params'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif

     if n_elements(Data) gt 128*512. then FO=1 else FO=0
     attr='signal="1" type="'+tip+'" dims="['+dim+']"'
     if FO then attr=attr+' file_name="'+fileZ+'.'+codx+codz+'" code="'+codx+'"'
     attr=attr+' min="'+strtrim(string(myRG(1)),2)+'" max="'+strtrim(string(myRG(0)),2)+'"'
     attr=attr+' units="count"'
     if n_elements(mon) eq 1 then attr=attr+' monitors="'+strtrim(string(mon(0)),2)+'"'
     if sy              eq 1 then attr=attr+ ' y_value="'+strtrim(string(  y(0)),2)+'"'
     if sz              eq 1 then attr=attr+ ' z_value="'+strtrim(string(  z(0)),2)+'"'
     PRINTF, fid, write_tag(3 , 'Data' ,attr , '' ,1)
     if not FO then PRINTF, fid, Data $
	 else begin  ON_IOERROR,mio
	             if codx eq 'xdr' then begin OPENW ,lan,fileN+'.'+codx      ,/get_lun,/XDR
	                                         WRITEU,lan,Data
	             endif            else begin OPENW ,lan,fileN+'.'+codx+codz,/get_lun,/compress
	                                         PRINTF,lan,Data        & endelse
	             mio:if lan gt 0 then FREE_LUN,lan & ON_IOERROR,mis & endelse
     PRINTF, fid, write_tag(3 , 'Data'  ,  ''   , ''  ,0) & PRINTF,fid,''

     if n_elements(E)  gt 1 then begin sxc=size(E)  & SC=strtrim(string(sxc(1)),2)
	 if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
     if n_elements(E) gt 128*512. then FO=1 else FO=0
	 attr='type="float" dims="['+SC+']"'
     if FO then attr=attr+' file_name="'+fileZ+'.err'+codz+'" code="'+codx+'"'
	 PRINTF, fid, write_tag(3 , 'Errors'  , attr  , ''  ,1)
	 if not FO then PRINTF, fid, E $
	 else begin  ON_IOERROR,mie
	             if codx eq 'xdr' then begin OPENW ,lan,fileN+'.err'     ,/get_lun,/XDR
	                                         WRITEU,lan,E
	             endif            else begin OPENW ,lan,fileN+'.err'+codz,/get_lun,/compress
	                                         PRINTF,lan,Data        & endelse
	             mie:if lan gt 0 then FREE_LUN,lan & ON_IOERROR,mis & endelse
	 PRINTF, fid, write_tag(3 , 'Errors'  ,  ''   , ''  ,0) & PRINTF,fid,''
     endif

   PRINTF, fid, write_tag(2 , 'NXdata'  , '' , ''  ,0) & PRINTF,fid,''

   if (size(N))(1) eq  S(1) then mon=float(N(*,0)) else mon=float(N)
   if n_elements(mon)  gt 1 then begin sxc=size(mon) & SC=strtrim(string(sxc(1)),2)
   PRINTF, fid, write_tag(2 , 'NXmonitor'  , ''  , ''  ,1)
	if sxc(0) gt 1 then SC=SC+','+strtrim(string(sxc(2)),2)
	if sxc(0) gt 2 then SC=SC+','+strtrim(string(sxc(3)),2)
	attr='type="float" dims="['+SC+']"'
	PRINTF, fid, write_tag(3 , 'Monitors'  , attr  , ''  ,1)
	PRINTF, fid, mon
	PRINTF, fid, write_tag(3 , 'Monitors'  ,  ''   , ''  ,0)
   PRINTF, fid, write_tag(2 , 'NXmonitor'  , ''  , ''  ,0) & PRINTF,fid,''
   endif

  PRINTF, fid, write_tag(1 , 'NXentry'  , '' , ''  ,0)
 PRINTF, fid, write_tag(0 , 'NXmlfile' , '' , '' ,0)
 FREE_LUN,fid
return
mis:	print,!err_string & if fid gt 0 then free_lun, fid
end
function groupx, win ,by
;******* ******
;**
;** Group canals by by ... (J. COOK)
;** CALL: Wi=groupx(wj [,2])

dim =SIZE(win)

IF dim(0) GE 1 THEN IF dim(1) GE 4 THEN BEGIN

	IF n_elements(by) ne 1 THEN by=2
	by=by>2<(dim(1)/4)

	IF dim(0) EQ 1 THEN wout =FLTARR( dim(1)/by )
	IF dim(0) EQ 2 THEN wout =FLTARR( dim(1)/by ,dim(2) )
			    xout =wout(*,0)
;	Take all parameters
;	**** *** **********
	TAKE_DATP,P

	FOR i=0,dim(1)/by-1 DO BEGIN j=i*by
	    IF dim(0) EQ 1 THEN wout(i)  = total(win(j:j+by-1  ))
	    IF dim(0) EQ 2 THEN wout(i,*)= total(win(j:j+by-1,*),1)
				xout(i)  = total(P.x(j:j+by-1  ))/by
	ENDFOR

;	Errors
;	******
	IF n_elements(P.e) eq n_elements(win) then begin
	FOR i=0,dim(1)/by-1 DO BEGIN j=i*by
	    IF dim(0) EQ 1 THEN P.e(i)   = total(P.e(j:j+by-1  )^2)
	    IF dim(0) EQ 2 THEN P.e(i,*) = total(P.e(j:j+by-1,*)^2,1)
	ENDFOR
	P.e=SQRT(P.e)
	ENDIF

;	Give back parameters
;	**** **** **********
	P.X_TIT  =P.X_TIT+' (group*'+strtrim(string(by),2)+')'
	MOD_DATP ,P,'X'    ,xout	;P.X=xout is the normal formulation but it
					;d'nt work (because the size changed)
	GIVE_DATP,P			;Give back

	RETURN,wout
ENDIF

P_MUS ,'mus_cannon'
RETURN, win
END

;RDFILTER was written by Philippe Cuerq on August 1996
;With this interface it is possible to select a part of a run, and
;make three different projections too.

;Version 2.0		Date : 08/96

; ************************ Widgets Creating Procedure ******************
; Rd_Filter			Create main RDFILTER interface

; ************************ Event processing procedures *****************
; P_Fil_Event		,event,uv

; ************************ Functions of this file **********************
; Ph_Verif		,value1,value2,vect,siz

; ************************ Procedures of this file *********************
; Ph_Common
; P_Fil_Event		,event,uv
; Ph_Write		,label,mess
; Ph_Help_RS	
; Ph_Filter		,wks
; Rd_Filter	


; ******************************** BEGINNING ***************************

;    *******************************************************************
;    *                       PROCEDURE PH_COMMON                       *
;    *								       *
;    * Description :   This procedure is simply used to declare        *
;    *		   the commons.					       *
;    *								       *
;    *******************************************************************

pro Ph_Common

					; This structure contains the state of
					;  xrange,yrange,zrange,xproj,yproj,
					; zproj,cons,moni
					; Ex. filter_config.xproj=1 then
Common cm_filgal	,filter_config $; x projection is selected etc....
			,mes_lab $	; Widget Id of message label
			,xtol    $	; Widget Id of tolerance
			,xmkb    $	; Widget Id of X mask list
			,ymkb    $	; Widget Id of Y mask list
			,nomb    $	; Widget Id of Monitor
			,xtolf   $	; float  value of tolerance
			,roto    $	; other  value of tolerance
			,xmsk,mk_x    $	; X mask list (string,value)
			,ymsk,mk_y    $	; Y mask list (string,value)
			,nomo    $	; Monitor value
			,first_time	; To know if RDFILTER is or was active
					; in the same Lamp session. 
			
Common cm_filini	,xmin $		; Keep the xmin value
			,xmax $		; Keep the xmax value
			,ymin $		; Keep the ymin value
			,ymax $		; Keep the ymax value
			,zmin $		; Keep the zmin value
			,zmax $		; Keep the zmax value
			,spect1 $ 	; Keep the first  "run selection"
			,spect2 $	; Keep the second "run selection"
			,spect3		; Keep the third  "run selection"
	
Return 
End

;    *******************************************************************
;    *                   INTERFACES WITH -NW MODE OF LAMP              *
;    *								       *
;    *******************************************************************

pro ph_setmask, wmsk,mk_w
;** **********
;**
		on_ioerror,miswmsk & ok=0
		mk_w=intarr(50)-1  & tm1=' -1 -1 -1 -1 -1 -1 -1 -1 -1 -1'
		reads,wmsk+tm1+tm1+tm1+tm1+tm1, mk_w & ok=1
		miswmsk:   idx =where(mk_w ge 0)
		if (idx (0) ge 0) and (ok) then mk_w=mk_w(idx) else mk_w=-1
		ni=n_elements(idx) & mk_w=reform(mk_w,ni,1)
		wmsk='' & if mk_w(0) ge  0 then for i=0,ni-1 do $
					wmsk=wmsk+strtrim(string(mk_w(i)),2)+' '
end

pro ph_works, selection ,uv
;** ********
;**
@lamp.cbk
Common cm_filgal
Common cm_filini
		selection=strtrim(selection(0),2)
		If (selection ne '') then begin			; Calls Rdmulti
		    monoto=0
		    if (filter_config.moni eq 2) then monoto=-1
		    if (filter_config.moni eq 3) then begin on_ioerror,mismoni & monoto=float(nomo) & mismoni: & endif

		    if (filter_config.cons) and (strpos(selection,':') lt 0) then $
			Ph_Write,mes_lab,'!Sigma apply with concatenation'$
		    else begin
			if (strpos(selection,'>') ge 0) or (strpos(selection,'+') ge 0) then begin
			    if xtol gt 0 then begin roto='0' & widget_control,xtol,bad_id=i,get_value=roto & endif
			    on_ioerror,misxtol & r=0 & r=float(roto(0)) & misxtol:
			    if r ne xtolf then tolerance=r
			endif
		   	w20=0
			if (monimon lt 0) and (monoto ge 0) then RDSET,/def
			if (monimon ge 0) and (monoto lt 0) then RDSET,/raw
			Filterpro,'Ph_Filter'				; on each
			RdMulti,selection,status,uv(0),20,monoto	; selected part
			Filterpro,''					; of the numor
			
			If not status  then begin			; Display the run

				if (strpos(selection,'>') ge 0) or (strpos(selection,'+') ge 0) then begin
				    if xtol gt 0 then widget_control,xtol,bad_id=i,set_value=strtrim(string(toler),2) $
						 else roto=toler
				    xtolf=float(string(toler))
				endif

				to_don_history, 20,0,'w20=RDOPR("'+selection+'") ;RDFILTER '+inst_value
    			     
				r=execute('spect'+strtrim(string(uv(1)),1)+'=selection')
				
				If (filter_config.cons and (size(w20))(0) ge 2) $
				then begin Ph_Write,mes_lab,'Sigma evaluation ...' & w19=0
					   XICUTER,'w19=corel(w20)>1' 
					   if uv(0) gt 0 then forcplot,w=19
				endif else if uv(0) gt 0 then forcplot,w=20
			endif
		   endelse	
		endif
end

;    *******************************************************************
;    *                       PROCEDURE PH_ FIL_EVENT                   *
;    *								       *
;    * Description :   This procedure is the events maintenance .It    *
;    *		   is called by Lamp with the event and the user value *
;    *             of the event.                                       *
;    *								       *
;    *******************************************************************

pro P_Fil_Event,event,uv
;** ***********
;**
Common cm_filgal
Common cm_filini


case uv(2) of 

	1 : filter_config.xrange=event.select	; filter_config.xrange=1 => x
						; range selected
	
	2 : filter_config.yrange=event.select	; idem
	
	3 : filter_config.zrange=event.select	; idem
	
	4 :  filter_config.xproj=event.select	; filter_config.xproj=1 ==> x 
						; projection selected
				
	5 :  filter_config.yproj=event.select	; idem
					    	
	6 :  filter_config.zproj=event.select	; idem
	
	7 :  begin
	       filter_config.cons =event.select	; idem
	       If event.select then chaine='Sigma W19' $
	       		       else chaine='Sigma'
	       Widget_Control,event.id,Set_Value=chaine
	       end
	
	8 :  filter_config.moni =uv(3)		; Normalize

	10 : Ph_Help_RS				; help for run selector
	
	11 : Widget_Control,event.top,/Destroy	; exit event : destroy all 
						; the bases
	
	12 : Begin Ph_Write,mes_lab,''		; initialization
		   Ph_Write,uv(10) ,''

		Widget_Control,nomb,Get_Value=nomo & nomo=strcompress(nomo(0),/remove_all)
		Widget_Control,xmkb,Get_Value=xmsk & xmsk=strtrim(xmsk(0),2)
		Widget_Control,ymkb,Get_Value=ymsk & ymsk=strtrim(ymsk(0),2)

		if xmsk ne ''  then begin ph_setmask, xmsk,mk_x
					  Widget_Control,xmkb,Set_Value=xmsk & endif
		if ymsk ne ''  then begin ph_setmask, ymsk,mk_y
					  Widget_Control,ymkb,Set_Value=ymsk & endif

		If (filter_config.xrange eq 1) then begin	 ; to catch xmin 
			Widget_Control,uv(3),Get_Value=mini	 ; and xmax
			on_ioerror,misxmin & xmin=float(mini(0)) & misxmin:
			Widget_Control,uv(4),Get_Value=maxi
			on_ioerror,misxmax & xmax=float(maxi(0)) & misxmax:
			If (xmax lt xmin) then begin
				Ph_Write,mes_lab,'Xmax > Xmin  !!!'
				return
			endif  
		endif
		
		If (filter_config.yrange eq 1) then begin	 ; to catch ymin
			Widget_Control,uv(5),Get_Value=mini	 ; and ymax
			on_ioerror,misymin & ymin=float(mini(0)) & misymin:
			Widget_Control,uv(6),Get_Value=maxi
			on_ioerror,misymax & ymax=float(maxi(0)) & misymax:
			If (ymax lt ymin) then begin
				Ph_Write,mes_lab,'Ymax > Ymin  !!!'
			   	return
			endif
		endif
		
		If (filter_config.zrange eq 1) then begin	 ; to catch zmin
			Widget_Control,uv(7),Get_Value=mini	 ; and zmax
			on_ioerror,miszmin & zmin=float(mini(0)) & miszmin:
			Widget_Control,uv(8),Get_Value=maxi
			on_ioerror,miszmax & zmax=float(maxi(0)) & miszmax:
			If (zmax lt zmin) then begin
				Ph_Write,mes_lab,'Zmax > Zmin  !!!'
				return
			endif
		endif
					   	   
		selection=''			   		; to catch 
		Widget_Control,uv(9),Get_Value=selection	; the runs
		PH_WORKS, selection ,[uv(10),uv(11)]
	     end
	
	else : return      	

endcase		
return
end

;    *******************************************************************
;    *                       PROCEDURE PH_ WRITE                       *
;    *                                                                 *
;    * Description :   This procedure displays a message(mess)         *
;    *                 in a label(label).                              *
;    *                                                                 *
;    *******************************************************************

pro Ph_Write,label,mess


; Write messages in the label
if label gt 0	then Widget_Control,label,Set_Value=mess $
		else print,mess
Return
End

;    *******************************************************************
;    *                       PROCEDURE PH_ HELP_RS                     *
;    *                                                                 *
;    * Description :   This procedure calls a Lamp function :show_helps*
;    *                 which display a help.                           *
;    *                                                                 *
;    *******************************************************************

pro Ph_Help_RS
show_helps,[-88,594]
return
end



;    *******************************************************************
;    *                       FUNCTION PH_ VERIF                        *
;    *                                                                 *
;    * Description :   This function checks :    		       *
;    *                       - if at least one value is in the interval*  
;    *                  ==> returns a structure with a specific        *
;    *                  value (Aff=1)and the indices of the values     *
;    *                  in the vector (ex:{Aff=1,min=10,max=20}.       *
;    *                       - if not ==> returns a structure with a   *
;    *		        specific value(ex: {Aff=0}).                   *
;    *                                                                 *
;    *******************************************************************

function Ph_Verif,value1,value2,vect,siz


error1=0 & error2=0

If n_elements(vect) ne siz then vect=indgen(siz)+1 

If (vect(0)-vect(1)) gt 0 then begin 
	val=value1
	value1=value2 
	value2=val  
endif

indmax=siz-1 
indmin=0

If (value1 lt vect(0) or value1 gt vect(n_elements(vect)-1)) then error1=1 $
else begin 
	indmin=where(vect ge value1)  
	indmin=indmin(0)
endelse

If (value2 gt vect(n_elements(vect)-1) or value2 lt vect(0)) then error2=1 $
else begin	 
	indmax=where(vect le value2) 
	indmax=indmax(n_elements(indmax)-1)
endelse

If (error1 and error2) then aff={aff:0} $
else begin 
	vect=vect(indmin:indmax)
	aff={aff:1,min:indmin,max:indmax}
endelse	

return, aff	       	
end      	




;    *******************************************************************
;    *                       PROCEDURE PH_FILTER                       *
;    *                                                                 *
;    * Description :   This function selects a part of a workspace and *
;    *                 applies projections to it.                      *
;    *                 Note that data are always restored in workspace *
;    *                 20 and Ph_filter is called by Lamp, Lamp        *
;    *                 specifies that the work happens in W20.	       *
;    *		  		                                       *
;    *                                                                 *
;    *******************************************************************

pro Ph_Filter,wks

; Work= 0 ---> makes projections (if selected)
; Work= 1 ---> modifies workspace and makes projections (if selected)
; Work=-1 ---> does nothing

@lamp.cbk
Common cm_filgal
Common cm_filini

;changes the Lamp workspace for the w20

If wks ne 20 then XICUTE,'w20=w'+strtrim(string(wks),2)
Ph_Write,mes_lab,'---> '+w_numor(20)
siz =Size(w20)
sizn=Size(N20)
Work=0
Wmsk=0
If n_elements(E20) eq  n_elements(W20)	  then ero=1 else ero=0
If (sizn(0) ge 1) and (sizn(1) eq siz(1)) then ern=1 else ern=0

;---------------------- Selection on x axis ----------------------

if siz(0) ge 1 then begin
   If  xmsk ne '' then begin
	If n_elements(x20) lt siz(1) then  x20=indgen(siz(1))+1
	If (size(mk_x))(0) eq 2 then begin tmp=lonarr(siz(1)) & mk_x=mk_x<(siz(1)-1)
					   tmp(mk_x)=-1 & mk_x=where(tmp ge 0)  & endif
	x20=x20 (mk_x,*)    &	if (size(y20))(0) eq 2 then y20=y20(mk_x,*)
	w20=w20 (mk_x,*,*)  &	if  ero then E20=E20(mk_x,*,*)
				if  ern then N20=N20(mk_x,*)     & siz =Size(w20)
   endif
   indxmin=0 & indxmax=siz(1)-1

   If  filter_config.xrange then begin
	S_result=Ph_Verif(xmin,xmax,x20,siz(1))
	If S_result.aff then begin
		indxmin=S_result.min
		indxmax=S_result.max
		if (size(y20))(0) eq 2 then y20=y20(indxmin:indxmax,*)
		Work=1
	endif else begin
		Ph_Write,mes_lab, 'Warning : Xmin='+strtrim(string(min(x20)),2)$
		+'  Xmax='+strtrim(string(max(x20)),2)
		Work=-1
		endelse
   endif
endif
;---------------------- Selection on y axis ----------------------
			       
if siz(0) ge 2 then begin
   If  ymsk ne '' then begin
	If n_elements(y20) ne siz(2) then  y20=indgen(siz(2))+1 
	If (size(mk_y))(0) eq 2 then begin tmp=lonarr(siz(2)) & mk_y=mk_y<(siz(2)-1)
					   tmp(mk_y)=-1 & mk_y=where(tmp ge 0) & endif 
	if (size(y20))(0) eq 2  then y20=y20 (*,mk_y) else  y20=y20  (mk_y)
	if (size(x20))(0) eq 2  then x20=x20 (*,mk_y)
	w20=w20 (*,mk_y,*)  &   if  ero then E20=E20(*,mk_y,*)   & siz =Size(w20)
   endif
   indymin=0 & indymax=siz(2)-1

   If (filter_config.yrange) and (Work ne -1)  then begin
	S_result=Ph_Verif(ymin,ymax,y20,siz(2))
	If S_result.aff then begin
		indymin=S_result.min
		indymax=S_result.max
		If not filter_config.xrange then if (size(x20))(0) eq 2 then x20=x20(*,indymin:indymax)
		Work=1
	endif else begin 
		Ph_Write,mes_lab, 'Warning : Ymin='+strtrim(string(min(y20)),2)$
		+'  Ymax='+strtrim(string(max(y20)),2)
		Work=-1
	        endelse
   endif    	  	     
endif
;---------------------- Selection on z axis ----------------------

indzmin=0 & indzmax=siz(3)-1
If (filter_config.zrange and Work ne -1 and siz(0) eq 3) then begin
	S_result=Ph_Verif(zmin-1,zmax-1,indgen(siz(3)),siz(3))
	If S_result.aff then begin
		indzmin=S_result.min
		indzmax=S_result.max
		Work=1
	endif else begin 
		Ph_Write,mes_lab, 'Warning : Zmin= 1 '+'  Zmax='+$
		strtrim(string(siz(3)),2)
		Work=-1
	        endelse	    	  	     
endif
;--------------------- X,Y or Z projection according to workspace size ---

If Work ne -1 then  CASE siz(0) of
		1 : begin
			If Work then  begin w20=w20(indxmin:indxmax)
				if ern then N20=N20(indxmin:indxmax,*)
				if ero then E20=E20(indxmin:indxmax) & endif
			If filter_config.yproj then  begin w20=total(w20,1)
				if ern then N20=total(N20(*,0))
				if ero then E20=sqrt(total(E20^2,1)) & endif
		    end

		2 : begin
			If Work then  begin w20=w20(indxmin:indxmax,indymin:indymax)
				if ern then N20=N20(indxmin:indxmax,*)
				if ero then E20=E20(indxmin:indxmax,indymin:indymax) & endif
			If filter_config.xproj then  begin w20=total(w20,2)
				if ero then E20=sqrt(total(E20^2,2)) & endif
			If filter_config.yproj then  begin w20=total(w20,1)
				if ern then N20=total(N20(*,0))
				if ero then E20=sqrt(total(E20^2,1)) & endif
		    end

		3 : begin
			If Work then  begin w20=w20(indxmin:indxmax,indymin:indymax,indzmin:indzmax)
				if ern then N20=N20(indxmin:indxmax,*)
				if ero then E20=E20(indxmin:indxmax,indymin:indymax,indzmin:indzmax) & endif
			If filter_config.zproj then  begin w20=total(w20,3)
				if ero then E20=sqrt(total(E20^2,3)) & endif
			If filter_config.xproj then  begin w20=total(w20,2)
				if ero then E20=sqrt(total(E20^2,2)) & endif
			If filter_config.yproj then  begin w20=total(w20,1)
				if ern then N20=total(N20(*,0))
				if ero then E20=sqrt(total(E20^2,1)) & endif
		    end
				    
		else:   return

		    ENDCASE

If Work ne -1 then begin
	if (siz(0) eq 3) and (filter_config.zproj) then begin
	    x_tit(20)=x_tit(20)+' (Frames projection)'
	endif
	if (siz(0) ge 1) and (filter_config.xproj) then begin
	    y_tit(20)=z_tit(20)
	    y20=z20(0) & if  y20 eq 0 then y_tit(20)='Numor'
	    if y20 eq 0 then y20=long(w_numor(20))
	endif
	if (siz(0) ge 2) and (filter_config.yproj) then begin
	    x_tit(20)=y_tit(20) & y_tit(20)=z_tit(20) & x20=y20
	    y20=z20(0) & if  y20 eq 0 then y_tit(20)='Numor'
	    if y20 eq 0 then y20=long(w_numor(20))
	endif
endif
	
If n_elements(w20) eq 1 then begin 
	x_tit(20)=''   
	y_tit(20)='Total Values'
	on_ioerror,mis & x20=long(w_numor(20))
	mis: 
endif

;re-establishes Lamp workspace

If wks ne 20 then XICUTE,'w'+strtrim(string(wks),2)+'=w20'

return		    	    	
end



;    *******************************************************************
;    *                       PROCEDURE RDFILTER                        *
;    *                                                                 *
;    * Description :   This  procedure builds the interface            *
;    *                                                                 *
;    *		  		                                       *
;    *******************************************************************


pro rdfilter ,pth ,XRANGE=xrg ,YRANGE=yrg ,ZRANGE=zrg ,XMASK=xtext ,YMASK=ytext, MONIMOD=momod $
		  ,XPROJ=xproj,YPROJ=yproj,ZPROJ=zproj,WKSP =wksp $
		  ,MONIVAL=moval ,SIGMA=sigma ,TOLERANCE=latol ,SELECTION=selec

@lamp.cbk

Common cm_filgal
Common cm_filini

If n_elements(first_time) eq 0 then begin 
	first_time=1
	mes_lab   =0
	xtol	  =0
	filter_config={xrange:0,yrange:0,zrange:0,xproj:0,yproj:0,zproj:0,cons:0,moni:1}
	xmin  =0 & xmax=0
	ymin  =0 & ymax=0
	zmin  =0 & zmax=0
	spect1='' & spect2='' & spect3='' & xmsk='' & ymsk='' & nomo='100000.' & roto='0'
endif
kef=0		
if n_elements(xtext) eq 1 then begin xmsk =string(xtext) & if xmsk ne ''  then ph_setmask, xmsk,mk_x & kef=1 & endif
if n_elements(ytext) eq 1 then begin ymsk =string(ytext) & if ymsk ne ''  then ph_setmask, ymsk,mk_y & kef=1 & endif

if n_elements(xrg)   eq 2 then begin xmin =xrg(0) & xmax=xrg(1)		& kef=1
				     if xmax le xmin then filter_config.xrange=0 else filter_config.xrange=1
				     if xmax lt xmin then Ph_Write,mes_lab,'Xmax > Xmin  !!!'      &   endif
if n_elements(yrg)   eq 2 then begin ymin =yrg(0) & ymax=yrg(1)		& kef=1
				     if ymax le ymin then filter_config.yrange=0 else filter_config.yrange=1
				     if ymax lt ymin then Ph_Write,mes_lab,'Ymax > Ymin  !!!'      &   endif
if n_elements(zrg)   eq 2 then begin zmin =zrg(0) & zmax=zrg(1)		& kef=1
				     if zmax le zmin then filter_config.zrange=0 else filter_config.zrange=1
				     if zmax lt zmin then Ph_Write,mes_lab,'Zmax > Zmin  !!!'      &   endif

if n_elements(xproj) eq 1 then begin filter_config.xproj=xproj  & if xproj eq 1 then kef=1 & endif
if n_elements(yproj) eq 1 then begin filter_config.yproj=yproj  & if yproj eq 1 then kef=1 & endif
if n_elements(zproj) eq 1 then begin filter_config.zproj=zproj  & if zproj eq 1 then kef=1 & endif

if n_elements(momod) eq 1 then begin filter_config.moni=fix(momod)>1<3	& kef=1 & endif
if n_elements(moval) eq 1 then begin nomo=string(moval)			& kef=1 & endif

if n_elements(sigma) eq 1 then begin if sigma then filter_config.cons=1 else filter_config.cons=0  & kef=1 & endif
if n_elements(latol) eq 1 then begin roto=string(latol) & kef=1 & endif

if n_elements(selec) eq 1 then begin if n_elements(wksp) eq 1 then wk='W'+strtrim(string(wksp),2) else wk=''
				     if wk ne '' then XICUTER, wk+'=0'
				     PH_WORKS  ,selec ,[0,1] & kef =1
				     if wk ne '' then XICUTER, wk+'=w20'
				     endif
if (!D.flags and 65536)    ne 0 then if b_labins(3) eq 0 then $
if xregistered('RDFILTER') le 0 then if    kef      eq 0 then begin

filter_config.cons=0

;============================== BASE  ========================================	
base	   =Widget_Base(/Column	,Title='FILTER 2.0',resource_name='lamptouch')


;============================== BASE 1 =======================================
base1	   =Widget_Base   (base    	,/Column)


;============================== BASE 11 SCALES FILTER ========================
base11	   =Widget_Base   (base1   ,/Column,/Frame)

b_ico	   =Widget_Base   (base11  ,/row)
fs_lab	   =Widget_Label  (b_ico   ,value='SCALES',font=ft_biggest)
	    put_logo,b_ico
if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

base111	   =Widget_Base   (base11  ,/Row)

base1111   =Widget_Base   (base111 ,/Nonexclusive)
xrange_but =Widget_Button (base1111,value='X Range :',uvalue=[-88,379,1] ,font=ft_normal)
xmin_text  =Widget_Text   (base111 ,xsize=5+cap,value=strtrim(string(xmin),1),/Editable,font=ft_propor)
xmax_text  =Widget_Text   (base111 ,xsize=5+cap,value=strtrim(string(xmax),1),/Editable,font=ft_propor)

base112    =Widget_Base   (base11	 ,/Row)

base1121   =Widget_Base   (base112 ,/Nonexclusive)              
yrange_but =Widget_Button (base1121,value='Y Range :',uvalue=[-88,379,2] ,font=ft_normal)
ymin_text  =Widget_Text   (base112 ,xsize=5+cap,value=strtrim(string(ymin),1),/Editable,font=ft_propor)
ymax_text  =Widget_Text   (base112 ,xsize=5+cap,value=strtrim(string(ymax),1),/Editable,font=ft_propor)

base113    =Widget_Base   (base11  ,/Row)

base1131   =Widget_Base   (base113 ,/Nonexclusive)              
zrange_but =Widget_Button (base1131,value='Z Range :',uvalue=[-88,379,3],font=ft_normal)
zmin_text  =Widget_Text   (base113 ,xsize=5+cap,value=strtrim(string(zmin),1),/Editable,font=ft_propor)
zmax_text  =Widget_Text   (base113 ,xsize=5+cap,value=strtrim(string(zmax),1),/Editable,font=ft_propor)

;============================== BASE 12 PROJECTIONS , SIGMA ===================

base12     =Widget_Base   (base1   ,/Column,/Frame)
pf_lab	   =Widget_Label  (Widget_Base(base12,/row)  ,value='PROJECTIONS',font=ft_biggest)

base112    =Widget_Base   (base12  ,/Row,/Nonexclusive)
xproj_but  =Widget_Button (base112 ,value='X Projection',uvalue=[-88,379,4],font=ft_normal)
yproj_But  =Widget_Button (base112 ,value='Y Projection',uvalue=[-88,379,5],font=ft_normal)
base113    =Widget_Base   (base12  ,/Row,/Nonexclusive)
zproj_But  =Widget_Button (base113 ,value='Z Projection',uvalue=[-88,379,6],font=ft_normal)
cons_but   =Widget_Button (base113 ,value='Sigma       ',uvalue=[-88,379,7],font=ft_normal)	

base113    =Widget_Base   (base12  ,/row)
bid	   =Widget_Label  (base113 ,value='X merging Tolerance=',font=ft_normal)
xtolf	   =float(string(tolerance))
xtol	   =Widget_Text	  (base113 ,value=strtrim(string(tolerance),2),xsize=8+cap,/Editable,font=ft_propor)

;============================== BASE 12b MASKS & NORM ===================

base12     =Widget_Base   (base1   ,/Column,/Frame)
pf_lab	   =Widget_Label  (Widget_Base(base12,/row)  ,value='MASKS & NORM.',font=ft_biggest)

base113    =Widget_Base   (base12  ,/row)
bid	   =Widget_Label  (base113 ,value='X masks 0,..n :',font=ft_normal)
xmkb	   =Widget_Text	  (base113 ,value=strtrim(string(xmsk),2),xsize=14,/Editable,font=ft_propor)

base113    =Widget_Base   (base12  ,/row)
bid	   =Widget_Label  (base113 ,value='Y masks 0,..n :',font=ft_normal)
ymkb	   =Widget_Text	  (base113 ,value=strtrim(string(ymsk),2),xsize=14,/Editable,font=ft_propor)

base113    =Widget_Base   (base12  ,/row)
moni_but   =Widget_Base   (base113 ,/row,/exclusive)
moni_def   =Widget_Button (moni_but,value='Def',font=ft_normal,uvalue=[-88,379,8,1],/no_release)
moni_raw   =Widget_Button (moni_but,value='Raw',font=ft_normal,uvalue=[-88,379,8,2],/no_release)
moni_mon   =Widget_Button (moni_but,value='M:' ,font=ft_normal,uvalue=[-88,379,8,3],/no_release)
nomb	   =Widget_Text	  (base113 ,value=strtrim(string(nomo),2),xsize=7+cap,/Editable  ,font=ft_propor)

;============================== BASE 13 RUNS SELECTOR ========================
base13     =Widget_Base  (base1	   ,/Column,/Frame)

base131	   =Widget_Base	 (base13   ,/Row)
rs1_lab	   =Widget_Label (base131  ,value='RUNS SELECTOR ',font=ft_biggest)
helprs_but =Widget_Button(base131  ,value='?',uvalue=[-88,379,10]  ,font=ft_b_normal)

base132	   =Widget_Base	 (base13   ,/Row)
spect1_text=Widget_Text	 (base132  ,xsize=20,/Editable,value=spect1,font=ft_propor)
read1_but  =Widget_Button(base132  ,value='Read',font=ft_b_normal)

base133	   =Widget_Base	 (base13   ,/Row)
spect2_text=Widget_Text	 (base133  ,xsize=20,/Editable,value=spect2,font=ft_propor)
read2_but  =Widget_Button(base133  ,value='Read',font=ft_b_normal)

mes_lab	   =Widget_Label (base13   ,value=string(replicate(32b,50)),font=ft_b_normal,xsize=200)

rsmes_lab  =Widget_Label (base13   ,value=string(replicate(32b,50)),font=ft_b_normal,xsize=200)

;============================== EXIT =========================================

if n_elements(pth) eq 1 then begin
	buse=Widget_Base   (base,/Row)
	exit_but   =Widget_Button (buse,value='EXIT',uvalue=[-88,379,11],font=ft_biggest)
	bid =Widget_Label  (buse,value='Path:',font=ft_b_normal)
	bid =widget_button(buse,font=ft_b_normal,value=cycle,menu=2) 
	  uval =[-88,561,0,b_labins(0),b_labins(1)]
	  for i=0,n_elements(lamp_ali)-1 do begin
	      if strpos(strlowcase(lamp_ali(i)),'c_year') ge 0 then begin
		yr =strtrim(strmid(lamp_ali(i),7,15),2) & yr=strmid(yr,2,2)
		didon=widget_button(bid  ,font=ft_b_normal,menu=2		    	,value=lamp_ali(i))
		for j=1,5 do begin  yrs=yr+strtrim(string(j),2)
		 bido=widget_button(didon,font=ft_b_normal,uvalue=[uval,i,bid,long(yrs)],value='Cycle '+yrs)
		endfor
	      endif else $
		bidon=widget_button(bid  ,font=ft_b_normal,uvalue=[uval,i,bid,0]	,value=lamp_ali(i))
	  endfor   

endif else exit_but=Widget_Button (base,value='EXIT',uvalue=[-88,379,11],font=ft_biggest)

;============================== END BASE =====================================

;============================== Set_Uvalue Read buttons ======================

if (sys_dep('MACHINE') eq 'win') and (sys_dep('VERSION') lt '5.3') then txev=0 else txev=1

Widget_Control,	read1_but  ,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect1_text,rsmes_lab,'1']
Widget_Control,	read2_but  ,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect2_text,rsmes_lab,'2']
if txev then $
Widget_Control,	spect1_text,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect1_text,rsmes_lab,'1']
if txev then $
Widget_Control,	spect2_text,Set_Uvalue	=[-88,379,12,xmin_text,xmax_text,$
					ymin_text,ymax_text,zmin_text,$
					zmax_text,spect2_text,rsmes_lab,'2']

					
If filter_config.xrange then Widget_Control,	xrange_but,	/Set_Button				
If filter_config.yrange then Widget_Control,	yrange_but,	/Set_Button
If filter_config.zrange then Widget_Control,	zrange_but,	/Set_Button

If filter_config.xproj  then Widget_Control,	xproj_but,	/Set_Button				
If filter_config.yproj  then Widget_Control,	yproj_but,	/Set_Button
If filter_config.zproj  then Widget_Control,	zproj_but,	/Set_Button

If filter_config.moni eq 1 then Widget_Control,	moni_def ,	/Set_Button
If filter_config.moni eq 2 then Widget_Control,	moni_raw ,	/Set_Button
If filter_config.moni eq 3 then Widget_Control,	moni_mon ,	/Set_Button


Widget_Control,	 base   ,group_leader=lamp_b1,/Realize & put_logo

if lamp_b1 gt 0  then $
	Xmanager,'RDFILTER',base,Event_Handler='LAMP_EVENT_PARSER',/just_reg $
else	Xmanager,'RDFILTER',base,Event_Handler='LAMP_EVENT_PARSER'

endif
return
end


function corel,wkin ,sigma=sigma
;******* *****
;**
;** Standard deviation over spectra:return sigma/Error or sigma if keyword_set
;** -------- --------- ---- -------

wkout =0
dim   =SIZE(wkin)					

If dim(1) gt 1 then $
	Case dim(0) of
			
		2 : Begin		  		  
		      np    =dim(2)			;Get number of runs
		      wkmean=TOTAL(wkin,2) / np		;Get mean values
		      wkout =wkmean * 0				      
		      For i =0,np-1 do $
			  wkout = (wkin(*,i)  -wkmean)^2 + wkout  
			   			 	;This is SIGMA^2
		    End	
			     
		3 : Begin     						     
		      np    =dim(3)			;Get number of runs
		      wkmean=TOTAL(wkin,3) / np		;Get mean values
		      wkout =wkmean * 0				      
		      For i =0,np-1 do $
			  wkout = (wkin(*,*,i)-wkmean)^2 + wkout  
			      				;This is SIGMA^2
		    End							     
		
		else :return,wkout
	Endcase
	f=.5/np
	if keyword_set(sigma) then    $ 
	     wkout =Sqrt(wkout/(np-1))$			;Return SIGMA
	else wkout =Sqrt(wkout/(np-1)/(wkmean>f))	;Return SIGMA/Error
						    
Return ,wkout
End							  
pro phowind, ytp,rawe,vidp,pry,corre, xout,yin,win, yraw,exclu ,elas,ott,wavel ,ERRdat
;** *******
;**
;** TOF SHOW . (D. Richard).

@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common pho_cu,  pho_grp, pho_rax, pho_fct ,pho_rep, pho_oiw, pho_e,pho_w,pho_x,pho_y,$
		pho_t  , pho_mx , pho_psf

sw   = size(win )
maxw = max(win,min=minw) & maxw=[minw,maxw]
rtp  =[wavel(5:*)]
if n_elements(pho_fct) eq 0 then pho_fct=1
if n_elements(pho_rep) eq 0 then pho_rep=6
if n_elements(pho_grp) eq 0 then pho_grp=sw(2)   $
			    else pho_grp=min([pho_grp,sw(2)])
if n_elements(pho_rax) eq 0 then pho_rax=[0,0]
if n_elements(pho_mx)  eq 0 then pho_mx =maxw(1) $
			    else pho_mx =maxw(1)

if lamp_siz lt 800 then yys=15 else yys=0

wko=ott(0) & wkos=strtrim(string(wko),2) & pho_out=wkos & if wko le 9 then wkos=wkos+' '
wkn=ott(1) & wkns=strtrim(string(wkn),2) & pho_in =wkns
pho_oiw=[pho_out,pho_in]
uv =[-88,340]
psf=pho_rep+pho_fct+(pho_grp+pho_rax(0)+pho_rax(1))/10+wkn
psf='DL'+strtrim(string(psf),2)

bshow =	widget_base  (title='didline '+strtrim(his(wkn),2),group_leader=lamp_b1,$
				   /column,resource_name='lamptouch')
bplt1 = widget_base  (bshow,/row)
bdra1 = widget_draw  (bplt1,xsize=512,ysize=60-yys)
bget1 = widget_base  (bplt1,/column)
blabel= widget_label (bget1,value='RAW SAMPLE PEAKS'      ,font=ft_b_normal)
bggg1 = widget_base  (bget1,/row)
bread = widget_button(bggg1,font=ft_b_normal ,value='re_Treat W'+wkns)
brev  = widget_button(bggg1,font=ft_smallest ,value='<',uvalue=[-88,310,bread,4])
bnex  = widget_button(bggg1,font=ft_smallest ,value='>',uvalue=[-88,311,bread,4])

bplt4 = widget_base  (bshow,/row)
bdra4 = widget_draw  (bplt4,xsize=512,ysize=60-yys)
bcorr = widget_label (bplt4,value='SAMPLE P corrected'    ,font=ft_b_normal)

bplt3 = widget_base  (bshow,/row)
bdra3 = widget_draw  (bplt3,xsize=512,ysize=85-yys)
blabel= widget_label (bplt3,value='EFFICIENCIES'                 ,font=ft_b_normal)
valf  =strtrim(string(wavel),2)
val   =strtrim(string(rtp)  ,2)
betis = widget_button(bplt3,value='?',menu=2,uvalue=rtp          ,font=ft_biggest)
binfo = widget_button(betis,value='Wavelenght   (Angs)= '+valf(0),font=ft_propor)
binfo = widget_button(betis,value='Channel width(msec)= '+valf(1),font=ft_propor)
binfo = widget_button(betis,value='Sample->Det (meter)= '+valf(2),font=ft_propor)
binfo = widget_button(betis,value='Vanadium Temp.  (K)= '+valf(3),font=ft_propor)
binfo = widget_button(betis,value='Sample   Temp.  (K)= '+valf(4),font=ft_propor)
binf2 = widget_button(betis,value='F(E) efficiencies  =IN4,5,6 type',font=ft_propor)

binf2 = widget_button(betis,value='Sample transmission= '+val(0) ,menu=2,font=ft_propor)
 seq  =['.10','.15','.20','.25','.30','.35','.40','.45','.50','.55',$
        '.60','.65','.70','.75','.80','.82','.84','.86','.88','.90',$
        '.91','.92','.93','.94','.95','.96','.97','.98','.99','1.0']
 seq  = reverse    (seq)
 for i=0,n_elements(seq)-1 do $
 btrs = widget_button(binf2,value=seq(i),uvalue=[uv,3,0,binf2,betis]	,font=ft_smallest)
binf2 = widget_button(betis,value='Vana   transmission= '+val(1) ,menu=2,font=ft_propor)
 for i=0,n_elements(seq)-1 do $
 btrv = widget_button(binf2,value=seq(i),uvalue=[uv,3,1,binf2,betis]	,font=ft_smallest)

vabs  = strtrim(string(fix(val(2))),2)
binf2 = widget_button(betis,value='Self-absorption    = '+vabs ,menu=2  ,font=ft_propor)
 bsa1 = widget_button(binf2,value='0=None',uvalue=[uv,3,2,binf2,betis,0]	   ,font=ft_propor)
 case vabs of
 '1':bsa2 = widget_button(binf2,value='1=Single slab',uvalue=[uv,3,2,binf2,betis,1]  ,font=ft_propor)
 '2':bsa2 = widget_button(binf2,value='2=Full cylinder',uvalue=[uv,3,2,binf2,betis,2] ,font=ft_propor)
 '3':bsa2 = widget_button(binf2,value='3=Hollow cylinder',uvalue=[uv,3,2,binf2,betis,3],font=ft_propor)
 else:
 endcase
binf2 = widget_button(betis,value='ABOUT THIS TREATMENT'       ,menu=2  ,font=ft_propor)
 seq  =['- Normalise  vanadium , empty_can , sample according to monitor counts' ,$
        '- Determine  peak position of sample and vanadium'                  ,$
        '- Align      sample and vanadium (empty) using a circular shift'    ,$
        '- Remove     empty_can from sample and vanadium using transmissions',$
        '- Remove     noisy , too low and too high spectra (discrimination)' ,$
        '- Correct    the vanadium using a Debye Waller factor'              ,$
        '- Calibrate  the sample   using the elastic peak of the vanadium'   ,$
        '-(Resolution)instrument is taken from vanadium peak at any angles'  ,$
        '- Correct    for the energy dependent efficiency of the detectors'  ,$
        '- Transform  to energy'                                             ,$
        '- Group      angles if many'                                        ,$
        ' ',$
        'IF YOU CHANGE TRANSMISSION OR ABSORBTION TYPE YOU HAVE TO'          ,$
        'PRESS THE "re_Treat W" BUTTON ON YOUR UPPER RIGHT']
 for i=0,n_elements(seq)-1 do $
  bt  = widget_button(binf2,value=seq(i),font=ft_propor)

if rtp(2) ne 1 then titi='--- EMPTY PEAKS ---' else titi='ABSORPTION shape'
bdra2=0L
blra2=0L
if yys eq 0 then begin
 bplt2= widget_base  (bshow,/row)
 bdra2= widget_draw  (bplt2,xsize=512,ysize=85-yys)
 blra2= widget_label (bplt2,value=titi			,font=ft_b_normal)
endif
brow  = widget_base  (bshow,/row)
br1   = widget_base  (brow ,/column)
btext = widget_list  (br1  ,xsize=14 ,ysize=17		,font=ft_propor)
blabel= widget_label (br1  ,value='TOF reduction'	,font=ft_b_normal)
blabel= widget_label (br1  ,value='by'			,font=ft_smaller)
blabel= widget_label (br1  ,value='D.Richard (7307)'	,font=ft_b_normal)
blabel= widget_label (br1  ,value='M.Ferrand       '	,font=ft_b_normal)

br3   = widget_base  (brow ,/column)
bupd  = widget_button(br3  ,value='re-PLOT'         ,font =ft_b_normal)
blabel= widget_label (br3  ,value='....'            ,font =ft_smallest)
bswqe = widget_button(br3  ,value='S(w,Qel)'        ,font =ft_b_normal)
bswq  = widget_button(br3  ,value='S(w,Q)'          ,font =ft_b_normal)
bpab  = widget_button(br3  ,value='P(a,B)'          ,font =ft_b_normal)
bquas = widget_button(br3  ,value='QUASI'           ,font =ft_b_normal)
blabel= widget_label (br3  ,value='....'            ,font =ft_smallest)
blev  = widget_button(br3  ,value='Levels'          ,font =ft_b_normal)
bsurf = widget_base  (br3  ,/row)
bsu1  = widget_button(bsurf,value='S'               ,font =ft_b_normal)
bsu2  = widget_button(bsurf,value='u'               ,font =ft_b_normal)
bsu3  = widget_button(bsurf,value='r'               ,font =ft_b_normal)
bsu4  = widget_button(bsurf,value='f'               ,font =ft_b_normal)
bsu0  = widget_button(br3  ,value='Front'           ,font =ft_b_normal)
blabel= widget_label (br3  ,value='....'            ,font =ft_smallest)
br3r  = widget_base  (br3  ,/row)
bid   = widget_label (br3r ,value='To'              ,font =ft_smallest)
bhard = widget_button(br3r ,value=psf+'.PS'         ,font =ft_b_normal)
br3r  = widget_base  (br3  ,/row)
bid   = widget_label (br3r ,value='To'              ,font =ft_smallest)
bhinx = widget_button(br3r ,value=psf+'.INX'        ,font =ft_b_normal)
br3r  = widget_base  (br3  ,/row)
bid   = widget_label (br3r ,value='To'              ,font =ft_smallest)
bsav  = widget_button(br3r ,font=ft_propor   ,value='W'+wkos)
brev  = widget_button(br3r ,font=ft_smallest ,value='<',uvalue=[-88,310,bsav,5])
bnex  = widget_button(br3r ,font=ft_smallest ,value='>',uvalue=[-88,311,bsav,5])

br2   = widget_base  (brow ,/column)
bsca  = widget_base  (br2  ,/row)
bidon = widget_label (bsca ,value='Max Count '      	    ,font =ft_b_normal)
bidon = widget_label (bsca ,value=strtrim(maxw(1),2)	    ,font =ft_b_normal)
bidon = widget_label (bsca ,value=' cut to '   	          ,font =ft_b_normal)
bscal = widget_text  (bsca ,value=strtrim(pho_mx ,2),xsize=7,font =ft_propor,/editable)
xwin  = 430
br2r  = widget_base  (br2  ,/row)
bdrac = widget_draw  (br2r ,xsize=xwin,ysize=300)
bslid = widget_base  (br2  ,/row)
bsld1 = widget_base  (bslid,/column)
bsld2 = widget_base  (bslid,/column)
bsli1 = widget_slider(bsld1,title='',min=1  ,max=350,xsize=xwin/2-8,/supp,$
				     value=1  ,/drag,ysize=15)
bsli2 = widget_slider(bsld2,title='',min=151,max=500,xsize=xwin/2-8,/supp,$
				     value=500,/drag,ysize=15)
bran1 = widget_label (bsld1,value='_______________' ,font =ft_propor)
bran2 = widget_label (bsld2,value='_______________' ,font =ft_propor)

bxgrp = widget_base  (br2  ,/row)
bslix = widget_slider(bxgrp,title='',min=3  ,max=500,xsize=xwin,/supp,$
				     value=500,/drag,ysize=15)
blabx = widget_label (bxgrp,value='______'	    ,font =ft_propor)

br2rr = widget_base  (br2r ,/column)
blabg = widget_label (br2rr,value=strtrim(string(pho_grp),2),font=ft_b_normal)
bgrp  = widget_slider(br2rr,title='',min=1,max=sw(2),/supp,value=pho_grp,xsize=17,$
		      /drag,/vertical,ysize=300-20,uvalue=[uv,5,blabg,bran1])

if exclu(0) ge 0 then $
widget_control,btext,set_value=[' Excluded  ' , '  Spectra'  ,  ' ' ,   $
				 strtrim(string(yraw(exclu)) ,2)+' -> '+$
				 strtrim(string(     exclu+1),2)]  else $
widget_control,btext,set_value=[' Excluded  ' , '  Spectra']

if pho_rax(0) eq pho_rax(1) then begin
   idx=where(xout ge -2*xout(sw(1)-1))
   idx=min([idx,(sw(1)-1)/2])
   idx=0
   idz=where(xout ge -2*xout(0))
   if idz(0) le idx then idz=sw(1)-1
   idz=min([idz(0),(sw(1)-1)])
   pho_rax=[idx,idz]
endif else begin
   idx=min([pho_rax(0),sw(1)-4])
   idz=max([min([pho_rax(1),sw(1)-1]),sw(1)/2+2])
   pho_rax=[idx,idz]
endelse

rx1    =xout(idx)
rx2    =xout(idz)
str_lab={sx:sw(1) , idi:idx , xval:xout ,ygrp:pho_grp}
widget_control,bran1,set_uvalue=str_lab,set_value=string(rx1)
str_lab.idi=idz
widget_control,bran2,set_uvalue=str_lab,set_value=string(rx2)

uvs=[uv,1,bran1,bran2,bslix,blabx]
     widget_control,bsli1,set_uvalue=uvs,set_value=(idx+1)*500./sw(1)
uvs=[uv,1,bran2,bran1,bslix,blabx]
     widget_control,bsli2,set_uvalue=uvs,set_value=(idz+1)*500./sw(1)

uvs=[uv,6,blabx,bran1,bran2]
     widget_control,bslix,set_uvalue=uvs  &  grpx=idz-idx+1
     widget_control,blabx,set_value =strtrim(string(grpx),2)

uvs=[uv,2,bran1,bran2,bcorr,1,0 ,blabx,bscal]     	& widget_control,bupd ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-1,blabx,bscal]     	& widget_control,bswqe,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-2,blabx,bscal]     	& widget_control,bswq ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-3,blabx,bscal]     	& widget_control,bpab ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,-4,blabx,bscal]     	& widget_control,bquas,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,1 ,blabx,bscal]     	& widget_control,bsu1 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,2 ,blabx,bscal]     	& widget_control,bsu2 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,3 ,blabx,bscal]     	& widget_control,bsu3 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,4 ,blabx,bscal]     	& widget_control,bsu4 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,5 ,blabx,bscal]     	& widget_control,bsu0 ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,1,6 ,blabx,bscal]     	& widget_control,blev ,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,3,bread,blabx,bscal,bsav] 	& widget_control,bhinx,set_uvalue=uvs
uvs=[uv,2,bran1,bran2,bcorr,2,bread,blabx,bscal]  	& widget_control,bsav ,set_uvalue=uvs
uvs=[uv,4,betis,ott]		            	  	& widget_control,bread,set_uvalue=uvs

bid=sys_dep      ('DYNLAB',bshow,1)
widget_control,bshow,/realize

if bdra2 gt 0 then widget_control,bdra2,get_value=wip2 else wip2=0
widget_control,bdra1,get_value=wip1
widget_control,bdra3,get_value=wip3
widget_control,bdra4,get_value=wip4
widget_control,bdrac,get_value=wic

uvs=[-88,350,wic,bhard,wkn,2]        & widget_control,bhard,set_uvalue=uvs

 widget_control,bpab  ,sensitive=0
 widget_control,bquas ,sensitive=0
;widget_control,bhinx ,sensitive=0

wicp   =[wic,wip2,blra2]
str_lab={cy:yin,w:win,id:wicp,kn:wkn,mx:maxw,hd:[bhard,bhinx],wl:wavel,err:ERRdat}
widget_control,bcorr,set_uvalue=str_lab

XMANAGER, 'Didline', bshow, event_handler='LAMP_EVENT_PARSER',/just_reg

keepd =!D.window
col   =0
bgr   =255
ry1   =min (vidp)
ry2   =max (vidp) & ryt=ry2
ry3   =max (rawe)
if ry3 gt ry2*5 then ry2=ry2*5 else ry2=max([ry2,ry3])

wset,wip1
plot,ytp,rawe        ,color=col,background=bgr,$
		xmargin=[0,0],ymargin=[0,0],ystyle=4 ,xticklen=1.,xgridstyle=1
wset,wip4
plot,ytp,corre       ,color=col,background=bgr,$
		xmargin=[0,0],ymargin=[0,0],ystyle=4 ,xticklen=1.,xgridstyle=1
wset,wip3
plot,ytp,1./pry      ,color=col,background=bgr,$
		xmargin=[0,0],ymargin=[2,0],ystyle=4 ,xticklen=1.,xgridstyle=1

if wip2 gt 0 then begin
wset,wip2
if rtp(2) eq 1 then ry2=ryt
plot,ytp,vidp        ,color=col,background=bgr,yrange=[ry1,ry2],$
		xmargin=[0,0],ymargin=[0,0],ystyle=4 ,xticklen=1.,xgridstyle=1
endif
trap_current=!D.window

wset,keepd
pho_contour,[wic,0],win,xout,yin,ERRdat, [rx1,rx2],maxw, w_tit(wkn) ,pho_grp,grpx,1,wavel,pho_mx

end

pro pho_contour, wicp ,www,xxx,yyy,eee ,rangx ,maxw, wtit ,nsp,nch ,what ,wavel ,maxim
;** ***********
;**
@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common pho_cu

win =www (pho_rax(0):pho_rax(1),*)<maxim
EER =eee (pho_rax(0):pho_rax(1),*)
xout=xxx (pho_rax(0):pho_rax(1),*)
yin =yyy

		 pho_groupx  , nch ,win ,xout,EER
if nsp gt 1 then pho_groupy  , nsp ,win ,yin ,EER $
	    else begin  yin=total(yin)  /n_elements(yyy)
			win=total(win,2)/n_elements(yyy)
			EER=SQRT(total(EER^2,2))/n_elements(yyy)
			endelse

s   =size(win) & if nsp eq 1 then s(2)=1

if pho_fct eq 1 then begin
   xtit='Energy Changes (meV)'
   ytit='Q elastic'
   ztit='S ( Q elas , W )'
   yin = sin(yin*!pi/180/2) *4*!pi / wavel(0)
endif

if pho_fct eq 2 then begin
   xtit='Energy Changes (meV)'
   ytit='Q'
   ztit='S ( Q , W )'
   qc  = cos(yin*!pi/180)
   ymax= sin(max(yin)*!pi/180/2) *4*!pi / wavel(0) *4
   yin = fltarr(s(1),s(2))

   ee    =(1.05457*  2*!pi)^2 / (2*1.67493) / 1.602177 * 10     ;h^2 /2m /f(joules)
   eelast= ee  /  wavel(0) ^2
   mho   = 0.695014*sqrt(eelast+xout) ;+ if energy changes, - if energy transfert
   mhoc  = mho^2
   ki    = 0.695014*sqrt(eelast)
   kic   = ki ^2

   for i=0,s(2)-1 do yin(*,i)= sqrt(kic + mhoc - 2.* ki * mho * qc(i) )

   yin =   yin<ymax
   xout=         [ [xout],[xout] ]
   xout=   congrid (xout ,s(1),s(2))
endif

if pho_fct eq 3 then begin
   rtemp =wavel(4)>5.
   rmass =1.	& radian=57.3
   xtit  ='Energy(meV)  Temp='+strtrim(string(rtemp),2)+' mass=1.'
   ytit  ='PaB'
   ztit  =''
   yin   = sin(yin*!pi/180/2) *4*!pi / wavel(0)

   ei      =81.799/wavel(0)^2  &  temp_inv = 11.61/rtemp  &  temp_x_mass = rtemp*rmass
   tof_fac = 5.227e6/ei        &  tof_in = sqrt(tof_fac)  &  rec_tof2 = 1.0/tof_in^2
   tau     = 1.0/(sqrt((xout)/5.227e6 + 1.0/tof_fac))     &  tau2 = tau^2  &  tau4 = tau^4

   beta      =(xout*temp_inv)<40  &  exp_beta = exp(0.5*beta)>  1.0e-9
   shine_beta= 0.5 *(exp_beta  - 1.0/exp_beta )

   cos_theta= cos(yin / radian)
   q_eff    = ((1.0/tau2)+rec_tof2-((2.0*cos_theta)/(tof_in*tau)))
   alfa     =(((6.07e7)*q_eff)/temp_x_mass) > .00001

   for cpt=0,s(2)-1 do begin
   	yc        = win(*,cpt)*tof_in/((9.681e-8) *tau4)
	sab       =((0.82412e-8)*tau4*exp_beta*yc)/tof_in
        win(*,cpt)=(2.0*beta*shine_beta*sab)/alfa(cpt)
        
   	yc        = EER(*,cpt)*tof_in/((9.681e-8) *tau4)
	sab       =((0.82412e-8)*tau4*exp_beta*yc)/tof_in
        EER(*,cpt)=(2.0*beta*shine_beta*sab)/alfa(cpt)
   endfor
endif

if pho_fct eq 4 then begin
   xtit='Q elastic'
   ytit='Quasi'
   ztit=''
endif

;PLOT
;****
if what eq 1 then begin
   keepd =!D.window
   bg    =255 & col=0

   if wicp(1) gt 0 then begin
      if nsp gt 1 then proj  =total(win,2)/s(2) else proj=win
      proj  =proj -min(proj)
      wset,wicp(1)
      plot,xout,proj,color=col,background=bg,xtitle=xtit,$
		  xmargin=[0,0],ymargin=[2,0] ,xticklen=1.,xgridstyle=1
      widget_control,bad_id=i,wicp(2),set_value=ytit+' projection'
      endif
   wset,wicp(0)
   if (nsp     eq 1) then begin
      plot,xout,win ,color=col,background=bg,xtitle=xtit,xmargin=[7,1],ymargin=[3,2] $
		    ,xticklen=1.,xgridstyle=1,yticklen=1.,ygridstyle=1
   endif  else $
   if (pho_rep eq 6) then begin
;     if maxw(1) gt 50 then win=win<(maxw(1)/10)
      win =alog(win) & xtit=xtit+' (Log display)'
      if s(1)*s(2) gt 80.*50 then if sys_dep('VERSION') lt 4.1 then ii=execute("win=smooth(win,3)") $
                                                               else ii=execute("win=smooth(win,3,/edge)")
      nl  =24
      contour   ,win,xout,yin,/fill,nlevels=nl ,$
                          xtitle=xtit,ytitle=ytit,title=wtit,$
                          xmargin=[7,1],ymargin=[3,2]
;     contour   ,win,xout,yin,c_colors=(indgen(nl)+1)*(180/nl)+50 ,nlevels=nl ,$
;                         xtitle=xtit,ytitle=ytit,title=wtit,background=bg    ,$
;                         xmargin=[7,1],ymargin=[3,2],color=col
   endif  else $
   if (pho_rep ge 1) and (pho_rep le 5) then begin
      maxz=max(win,min=minz)
      mima=maxz -  minz
      szz =strcompress(string([minz, minz+mima/4  ,minz+mima/2,$
				     minz+mima*3/4,maxz],format='(f8.2)'))
      xx=60 &		    zz=   0
      if pho_rep eq 1  then zz= -20 else if pho_rep eq 2 then zz=  20
      if pho_rep eq 3  then zz=-160 else if pho_rep eq 4 then zz= 160
      if pho_rep eq 5  then xx=   0
      if abs(zz) gt 45 then mtit='' else mtit=wtit
      if xx	 eq 0  then begin   mtit=xtit & xtit='' & endif

      res=sys_dep('VIEWER')
      if (res eq 1) and ((pho_rep eq 3) or (pho_rep eq 4)) then begin
	      if pho_rep eq 3 then matovr,win,xout,yin,/row
	      if pho_rep eq 4 then matovr,win,xout,yin,/col
	      res=sys_dep('VIEWER','lamp.wrl')
      endif else $
      if s(2) gt 16 then $
      	      shade_surf,win,xout,yin,ax=xx,az=zz,color=col,zticks=4,ztickname=szz,$
                                      xtitle=xtit,ytitle=ytit,title=mtit,background=bg,$
                                      xmargin=[7,1],ymargin=[3,2]        $
      else    surface   ,win,xout,yin,ax=xx,az=zz,color=col,/horizontal ,$
                                      xtitle=xtit,ytitle=ytit,title=mtit,background=bg,$
                                      xmargin=[7,1],ymargin=[3,2],zticks=4,ztickname=szz
   endif
   trap_current=!D.window
   wset,keepd
endif

;SAVE
;****
if what ge 2 then begin
   pho_tri,win,xout,yin,what ,EER
   pho_t =[wtit,xtit,ytit]
   
   XICUTE,'W'+pho_oiw(0)+'=sav_didline(W'+pho_oiw(1)+',samp='+pho_oiw(1)+')'
   if what eq 3 then $
   XICUTE,'dumpx,W'+pho_oiw(0) +',"'+ pho_psf+'.INX"'
endif

return
end

pro pho_tri, win,xout,yin,what ,EER
;** *******
;**
common pho_cu

s =size(win)
if (pho_fct eq 2) and (what ge 2) and (s(0) eq 2) then begin
   s =size(win)
   sx=size(xout)
   sy=size(yin)
   n =sx(1)-1
   a =max (xout,min=b)   & gsx = (a-b)/n
   n =sy(sy(0))-1
   a =max (yin ,min=c)   & gsy = (a-c)/n

   if sx(0) eq 1 then begin
      xout=         [ [xout],[xout] ]
      xout=   congrid (xout ,s(1),s(2))
      endif
   if sy(0) eq 1 then begin
      yin =transpose([ [yin],[yin] ])
      yin =     congrid(yin ,s(1),s(2))
      endif

   triangulate,  xout,yin, triangles ,bds
   pho_w=     trigrid(xout,yin,win,  triangles ,[gsx,gsy] )
   pho_e=SQRT(trigrid(xout,yin,EER^2,triangles ,[gsx,gsy] ))

   s    =size(pho_w)
   pho_x=b+findgen(s(1))*gsx
   pho_y=c+findgen(s(2))*gsy

endif else begin pho_x=xout & pho_y=yin & pho_w=win & pho_e=EER & endelse

return
end

function sav_didline, w,sample=n
;******* ***********
;**
@lamp.cbk
common pho_cu

   centm=100000.
   iii =execute('X'+pho_oiw(0)+'=pho_x')
   iii =execute('Y'+pho_oiw(0)+'=pho_y')
   iii =execute('E'+pho_oiw(0)+'=pho_e')
   iii =execute('N'+pho_oiw(0)+'=centm')
   w_tit(fix(pho_oiw(0)))=pho_t(0)
   x_tit(fix(pho_oiw(0)))=pho_t(1)
   y_tit(fix(pho_oiw(0)))=pho_t(2)

return,pho_w
end

pro pho_event ,ev ,uv
;** *********
;**
@lamp.cbk
common pho_cu

case uv(2) of

;Range sliders
;***** *******
1:begin widget_control,bad_id=i,uv(3),get_uvalue=str_lab
	idx	   =round(str_lab.sx/500.*ev.value)-1
	str_lab.idi=idx
	strig      =string(str_lab.xval(idx))
	widget_control,bad_id=i,uv(3),set_uvalue=str_lab,set_value=strig
	widget_control,bad_id=i,uv(4),get_uvalue=str_lab & idz=str_lab.idi
	widget_control,bad_id=i,uv(5),set_value =500
	widget_control,bad_id=i,uv(6),set_value =strtrim((abs(idz-idx)+1)>3 ,2)
        end
;Update Save Buttons
;****** **** *******
2:begin widget_control,bad_id=i,uv(3),get_uvalue=str_s1
	widget_control,bad_id=i,uv(4),get_uvalue=str_s2
	widget_control,bad_id=i,uv(5),get_uvalue=str_yw
	da1     =min([str_s1.idi ,str_s2.idi])
	da2     =max([str_s1.idi ,str_s2.idi]) & if da1 eq da2 then da2=da2+2
	pho_rax=[da1,da2]
	pho_grp= str_s1.ygrp
	rangx  =[str_s1.xval(da1),str_s2.xval(da2)]

	if (uv(6) eq 2) or (uv(6) eq 3) then begin
	   if uv(6) eq 2 then iv=ev.id else iv=uv(10)
	   widget_control,iv  ,get_value=wkn  & wkn=wkn(0) & i=strpos(wkn,'W')
	   wkn=strtrim(strmid(wkn,i+1,2),2)   & pho_oiw(0) =wkn
	   widget_control,uv(7),get_value=wkn & wkn=wkn(0) & i=strpos(wkn,'W')
	   wkn=strtrim(strmid(wkn,i+1,2),2)   & pho_oiw(1) =wkn

	endif else if uv(7) gt 0 then pho_rep= uv(7) $
	      else if uv(7) lt 0 then pho_fct=-uv(7)

        psf    =pho_rep+pho_fct+(pho_grp+pho_rax(0)+pho_rax(1))/10+str_yw.kn
        pho_psf='DL'+strtrim(string(psf),2)
	widget_control,bad_id=i,str_yw.hd(0),set_value=pho_psf+'.PS'
	widget_control,bad_id=i,str_yw.hd(1),set_value=pho_psf+'.INX'

	widget_control,bad_id=i,uv(8),get_value=grpx  & grpx =fix(grpx(0))

	widget_control,bad_id=i,uv(9),get_value=maxou & maxou=maxou(0)
			on_ioerror,mismax & maxim=str_yw.mx(1)
			maxim=float(maxou)
			if (maxim le str_yw.mx(0)) then maxim=str_yw.mx(1) $
			else pho_mx=maxim
			mismax:

	pho_contour, str_yw.id ,str_yw.w ,str_s1.xval ,str_yw.cy ,str_yw.err ,rangx ,$
		     str_yw.mx ,w_tit(str_yw.kn),str_s1.ygrp,grpx ,uv(6),str_yw.wl,maxim
	end

;Change parameters
;****** **********
3:begin if uv(3) eq 0 then begin
;	Sample transmision
	   widget_control,ev.id,get_value =val & valf=float(val)
	   widget_control,uv(5),get_uvalue=rtp & rtp(0)=valf
	   widget_control,uv(5),set_uvalue=rtp
	   widget_control,uv(4),set_value ='Next sample trans -> '+val
	endif
	if uv(3) eq 1 then begin
;	Vanadi transmision
	   widget_control,ev.id,get_value =val & valf=float(val)
	   widget_control,uv(5),get_uvalue=rtp & rtp(1)=valf
	   widget_control,uv(5),set_uvalue=rtp
	   widget_control,uv(4),set_value ='Next vanad. trans -> '+val
	endif
	if uv(3) eq 2 then begin
;	Self-absorbtion
	   widget_control,uv(5),get_uvalue=rtp & rtp(2)=uv(6)
	   widget_control,uv(5),set_uvalue=rtp
	   widget_control,uv(4),set_value ='Next absorb. type -> '+strtrim(string(uv(6)),2)
	endif
	end

;Read   button
;****   ******
4:begin
	widget_control,uv(3),get_uvalue=rtp
	widget_control,ev.id,get_value =wkn & wkn=wkn(0)
	i  =strpos(wkn,'W')
	wkn=strtrim(strmid(wkn,i+1,2),2) & pho_oiw(1)=wkn

	cmd='w'+strtrim(string(uv(4)),2)+'=didline(samp='+wkn
	if uv(6) gt 0  then cmd=cmd+        ',vana=' +strtrim(string(uv(6)),2)
	if uv(7) gt 0  then cmd=cmd+        ',empt=' +strtrim(string(uv(7)),2)
	if uv(8) gt 0  then cmd=cmd+        ',canv=' +strtrim(string(uv(8)),2)
	cmd=cmd+',trans_abs=rtp)'
	iii=execute(cmd)
  	end

;Group  slider for angles
;*****  ****** *** ******
5:begin widget_control,uv(3),set_value =strtrim(string(ev.value),2)
	widget_control,uv(4),get_uvalue=str_s1
	str_s1.ygrp=ev.value
	widget_control,uv(4),set_uvalue=str_s1
  	end

;Group  slider for channels
;*****  ****** *** ********
6:begin widget_control,uv(4),get_uvalue=str_lab & da1=str_lab.idi
	widget_control,uv(5),get_uvalue=str_lab & da2=str_lab.idi
	idx=((da2-da1+1)*ev.value/500)>3
	widget_control,uv(3),set_value =strtrim(string(idx),2)
	end
else:

endcase

return
end

pro pho_groupy, nsp,win,yin ,ERR
;** **********
;**
     sw=size(win)
     if nsp ne sw(2) then begin
        gp  =float (sw(2))/nsp
	wtmp=fltarr(sw(1) ,nsp)
	ERRt=fltarr(sw(1) ,nsp) & if n_elements(ERR) eq 0 then ERR=SQRT(win)
	ytmp=fltarr(nsp)

	for  i =nsp -1 ,1,-1  do begin
	     j1=round(i*gp)
	     j2=round(i*gp+gp-1)
	     j3=j2-j1+1
	     if j3 gt 1 then wtmp(*,i)=     total(win(*,j1 : j2)    ,2)  /j3 $
	     		else wtmp(*,i)=           win(*,j1)
	     if j3 gt 1 then ERRt(*,i)=SQRT(total(ERR(*,j1 : j2)^2  ,2)) /j3 $
	     		else ERRt(*,i)=           ERR(*,j1)
	     		     ytmp  (i)=     total(yin(  j1 : j2)      )  /j3
	endfor
	     j3=round(gp)
	     if j3 gt 1 then wtmp(*,0)=     total(win(*, 0 : j3-1)  ,2)  /j3 $
	     		else wtmp(*,0)=           win(*, 0)
	     if j3 gt 1 then ERRt(*,0)=SQRT(total(ERR(*, 0 : j3-1)^2,2)) /j3 $
	     		else ERRt(*,0)=           ERR(*, 0)
	     		     ytmp  (0)=     total(yin(   0 : j3-1)    )  /j3

	win=wtmp & wtmp=0
	ERR=ERRt & ERRt=0
	yin=ytmp & ytmp=0
     endif
return
end

pro pho_groupx, nch,win,xin ,ERR
;** **********
;**
     sw=size(win)
     if nch ne sw(1) then begin
        gp  =float (sw(1))/nch
	wtmp=fltarr(nch,sw(2))
	ERRt=fltarr(nch,sw(2)) & if n_elements(ERR) eq 0 then ERR=SQRT(win)
	xtmp=fltarr(nch)

	for  i =nch -1 ,1,-1  do begin
	     j1=round(i*gp)
	     j2=round(i*gp+gp-1)
	     j3=j2-j1+1
	     if j3 gt 1 then wtmp(i,*)=     transpose(total(win(  j1 : j2,*)  ,1)) /j3 $
	     		else wtmp(i,*)=                     win(  j1     ,*)
	     if j3 gt 1 then ERRt(i,*)=SQRT(transpose(total(ERR(  j1 : j2,*)^2,1)))/j3 $
	     		else ERRt(i,*)=                     ERR(  j1     ,*)
	     		     xtmp  (i)=               total(xin(  j1 : j2) )       /j3
	endfor
	     j3=round(gp)
	     if j3 gt 1 then wtmp(0,*)=     transpose(total(win( 0 : j3-1,*)  ,1)) /j3 $
	     		else wtmp(0,*)=                     win( 0       ,*)
	     if j3 gt 1 then ERRt(0,*)=SQRT(transpose(total(ERR( 0 : j3-1,*)^2,1)))/j3 $
	     		else ERRt(0,*)=                     ERR( 0       ,*)
	     		     xtmp  (0)=               total(xin( 0 : j3-1) )       /j3

	win=wtmp & wtmp=0
	ERR=ERRt & ERRt=0
	xin=xtmp & ytmp=0
     endif
return
end

function didline , radata , sample=sampln  , vanadium=vanadn , empty=emptn , canvan=canva , trans_abs=rtp , cadmium=cadmn
;******* *******
;**
;** Reality show . (D. Richard)
;**
@lamp.cbk

if n_params() eq 1 then begin INX,(one+0),(two+0) & return,radata & endif
instv=strupcase(inst_value)

;****CHECK PARAMETERS
;****
second=two

if n_elements(radata) gt 1 then rodata=radata else $
if n_elements(sampln) eq 1 then if (sampln gt 0)   and (sampln le 20) then  begin second=sampln
   rodata=0 & sn=strtrim(string(sampln),2) & i=execute('rodata=w'+sn) & i=execute('ERRdat=e'+sn)
   endif else sampln=0 else sampln=0

if n_elements(vanadn) eq 1 then if (vanadn gt 0)   and (vanadn le 20) then begin
   vanadi=0 & vn=strtrim(string(vanadn),2) & i=execute('vanadi=w'+vn)
   endif else vanadn=0 else vanadn=0

empti=0
if n_elements(emptn ) eq 1 then if (emptn  gt 0)   and (emptn le 20)  then begin
   empti =0 & en=strtrim(string(emptn) ,2) & i=execute('empti =w'+en) & i=execute('ERRemp=e'+en)
   endif else emptn =0 else emptn =0

if n_elements(canva ) eq 1 then if (canva  gt 0)   and (canva le 20)  then begin
   canvi =0 & ci=strtrim(string(canva) ,2) & if (canva ne emptn) then   i=execute('canvi =w'+ci)
   endif else canva =0 else canva =0

if n_elements(cadmn ) eq 1 then if (cadmn  gt 0)   and (cadmn le 20)  then begin
   cadmi =0 & di=strtrim(string(cadmn) ,2) & i=execute('cadmi =w'+di) & i=execute('ERRcad=e'+di)
   endif else cadmn =0 else cadmn =0

wk1 =strtrim(string(one),2) & wk2=strtrim(string(second),2)

sizs= size(rodata)
siza= size(vanadi)
sizn= size(empti)
sizc= size(canvi)
sizd= size(cadmi)
win = 0
if  n_elements(vanadi) le 1   then  begin v_is= 0 & siza=sizs & endif  else v_is=1
if  n_elements(empti)  le 1   then  begin n_is= 0 & sizn=sizs & endif  else n_is=1
if  n_elements(canvi)  le 1   then  begin c_is= 0 & sizc=sizs & endif  else c_is=1
if  n_elements(cadmi)  le 1   then  begin d_is= 0 & sizd=sizs & endif  else d_is=1
if  emptn  eq sampln		     then n_is=-1
if (emptn  eq canva) and (n_is eq 1) then c_is= 2
;if (c_is   eq 0)     and (n_is eq 1) then c_is= 2

if (sizs(0) eq 2) and (siza(0) eq 2) and (sizn(0) eq 2) and (sizc(0) eq 2) and $
   (sizs(1) eq siza(1)) and (sizs(1) eq sizn(1)) and (sizs(1) eq sizc(1))  and $
   (sizs(2) eq siza(2)) and (sizs(2) eq sizn(2)) and (sizs(2) eq sizc(2)) then begin
    rodata=rodata>0
    if n_elements(ERRdat) ne n_elements(rodata) then ERRdat=SQRT(rodata)
    if n_elements(ERRemp) ne n_elements(empti)  then ERRemp=SQRT(empti)
    if n_elements(ERRcad) ne n_elements(cadmi)  then ERRcad=SQRT(cadmi)
;****
;****
     p_in=0 & p_vn=0 & iii = execute('p_in=p'+wk2)
     if v_is eq 1 then iii = execute('p_vn=p'+vn)

     cwidth= 1. & wavel=1. & dist=1. & kelvis=0. & kelvin=0. & s_elas=sizs(1)/2.+.5 & doppl=1.
     if n_elements(p_in) gt 27 then begin
      doppl = p_in(2)>0.
      cwidth= p_in(18)
      wavel = p_in(21)
      dist  = p_in(27)
      kelvis= p_in(11)
      s_elas= p_in( 9)>0
      if v_is eq 1 then kelvin= p_vn(11)
     endif
     if   (instv eq 'IN10') or (instv eq 'IN16') or $
	  (instv eq 'IN13') then wavel=doppl
     if wavel gt 0 then begin
     if dist  gt 0 then begin

     fe_a  = 1.0      & f5_a  = 0.951
     fe_b  =-0.0565   & f5_b  =-0.0887
     fe_c  =-3.284    & f5_c  =-4.07
     if   (instv eq 'IN4') then begin fe_a=0.951 & fe_b=-.0887 & fe_c=-5.597 & endif
     
     if n_elements(rtp) gt 1 then begin
     		if rtp(0) eq 0 then rtp(0)=.99
     		if rtp(1) eq 0 then rtp(1)=.99
		transs= rtp(0) & Ts=transs
		transv= rtp(1) & Tv=transv
		transc= 0.97   & Tc=transc
		transn= 0.97   & Tn=transn
		slab  = rtp(2)
		tolow = rtp(3)
		ra1   = rtp(4)
		ra2   = rtp(5)
		ires  = rtp(6)
		igg   = fix(rtp(7)) & bgsub=[0,0,0,0] & bgsub(0)=(igg and 1)/1 & bgsub(1)=(igg and 2)/2
		                                        bgsub(2)=(igg and 4)/4 & bgsub(3)=(igg and 8)/8
		sangl = rtp(8)
		test  = long(sangl/180.)
		if test*180 eq sangl then slab=0
      endif  else begin
		transs= 0.90   & Ts=transs
		transv= 0.85   & Tv=transv
		transc= 0.97   & Tc=transc
		transn= 0.97   & Tn=transn
		slab  = 0
		tolow =15./100
		ra1   =0
		ra2   =0
		ires  =0
		igg   =1       & bgsub =[1,0,0,0]
		sangl =0
     endelse

     if strpos(strlowcase(x_tit(second)),'energy')  ge 0   then inergy=1 else inergy=0
     if v_is ne 1 then bgsub(0)=0 & if n_is ne 1 then bgsub(2)=0 & if c_is ne 1 then bgsub(3)=0

;*** ANGLE RANGE
;***
     xout=0 & iii =execute('xout=x'+wk2) & xout=xout(*,0)
     yraw=0 & iii =execute('yraw=y'+wk2)

     if n_elements(xout) ne sizs(1) then xout=findgen(sizs(1))+1.
     if n_elements(yraw) ne sizs(2) then yraw=findgen(sizs(2))+10. & sizy=size(yraw)
     elas = where(xout ge 0) & elas=elas(0)>0
     if elas gt 0 then s_elas= elas
     if sizy(0) eq 2 then yraw=reform(yraw(s_elas,*))

     if ra2 gt ra1 then begin
	id1=where(yraw ge ra1) & id1=id1(0)>0
	id2=where(yraw ge ra2) & id2=id2(0) & if id2 lt id1 then id2=n_elements(yraw)-1
	if id2 gt id1 then begin
				  rodata=rodata(*,id1:id2)
				  yraw  =yraw  (  id1:id2)
				  ERRdat=ERRdat(*,id1:id2)
		if n_is eq 1 then ERRemp=ERRemp(*,id1:id2)
		if n_is eq 1 then empti =empti (*,id1:id2)
		if c_is eq 1 then canvi =canvi (*,id1:id2)
		if d_is eq 1 then cadmi =cadmi (*,id1:id2)
		if d_is eq 1 then ERRcad=ERRcad(*,id1:id2)
		if v_is eq 1 then vanadi=vanadi(*,id1:id2)
		sizs= size(rodata)
	endif
     endif

   if not inergy then begin

;****GROUP SAME ANGLES
;****
     if v_is eq 1  then begin yt=yraw &  groupy,vanadi,yt         ,/average & endif
     if n_is eq 1  then begin yt=yraw &  groupy,empti ,yt  ,ERRemp,/average & endif
     if c_is eq 1  then begin yt=yraw &  groupy,canvi ,yt         ,/average & endif
     if d_is eq 1  then begin yt=yraw &  groupy,cadmi ,yt  ,ERRcad,/average & endif
					 groupy,rodata,yraw,ERRdat,/average
     sizs=size (rodata)

;****NORMALIZE BY MONITORS
;****
        msamp =1 & i=execute('msamp=total(n'+wk2+'(*,0))>1') & centm=100000.
        rodata=(rodata)* ( centm/msamp)
	ERRdat=(ERRdat)* ( centm/msamp)
	msamp =centm

     if v_is eq 1 then begin
        mvana =1 & i=execute('mvana=total(n'+vn +'(*,0))>1')
        vanadi=(vanadi)* ( msamp/mvana)
     endif
     if n_is eq 1 then begin
        mempt =1 & i=execute('mempt=total(n'+en +'(*,0))>1')
        empti =(empti) * ( msamp/mempt)
	ERRemp=(ERRemp)* ( msamp/mempt)
     endif
     if c_is eq 1 then begin
        mcanv =1 & i=execute('mcanv=total(n'+ci +'(*,0))>1')
        canvi =(canvi) * ( msamp/mcanv)
     endif
     if d_is eq 1 then begin
        mcadm =1 & i=execute('mcadm=total(n'+di +'(*,0))>1')
        cadmi =(cadmi) * ( msamp/mcadm)
	ERRcad=(ERRcad)* ( msamp/mcadm)
     endif

;****SELF ABSORPTION CURVE
;****
     if (slab eq 1) and ((n_is eq 1) or (v_is*c_is ge 1)) then begin
	 alpha=sangl*!pi/180.
	 Yr =	 yraw/180.*!pi
	 ida=where(Yr eq alpha)
	 if ida(0) ge 0 then Yr(ida)=Yr(ida)*1.01 ;(Yr((Ida-1)>0)+Yr((ida+1)<(n_elements(yr)-1)))/2.01
	 idt=where(Yr lt alpha) & idr=where(Yr gt alpha)
	 As =	-alog(TRANSs)/   sin(alpha)
	 Bc =	-alog(TRANSc)/(2*sin(alpha))
	 Av =	-alog(TRANSv)/   sin(alpha)
	 Bn =	-alog(TRANSn)/(2*sin(alpha))
	 Mex=85. ;EXP(89)=Inf!

	 if (v_is eq 1) and (c_is eq 2) then begin Bn=Bc & canvi=empti & c_is=1 & endif

	 if idt(0) ge 0 then begin
	    j=idt(0)
	    Rt =    sin(alpha)  / sin(alpha - Yr(idt))
;*	    SAMPLE IN TRANSMISSION
	    vecSt=(exp(-Bc*(Rt+1))*exp(-As*Rt)*(exp((As*(Rt-1))<Mex)-1))/(As*(Rt-1)) ;1/A1

	    if n_is eq 1 then begin ;A2~
	       vectt=(exp(-As*Rt) * exp(-Bc*Rt) +  exp(-As) * exp(-Bc)) / ((1+exp((Bc*(Rt-1))<Mex))*exp(-Bc*Rt))
	    endif
;*	    VANADIUM IN TRANSMISSION
	    vecVt=(exp(-Bn*(Rt+1))*exp(-Av*Rt)*(exp((Av*(Rt-1))<Mex)-1))/(Av*(Rt-1)) ;1/A1

	    if v_is*c_is eq 1 then begin ;A2~
	       vevtt=(exp(-Av*Rt) * exp(-Bn*Rt) +  exp(-Av) * exp(-Bn)) / ((1+exp((Bn*(Rt-1))<Mex))*exp(-Bn*Rt))
	    endif
	 endif
	 if idr(0) ge 0 then begin
	    j=idr(0)
	    Rr =  -sin(alpha)  /  sin(Yr(idr) - alpha)
;*	    SAMPLE IN REFLEXION
	    A1Sr=(exp((Bc*(Rr-1))<Mex)*(exp((As*(Rr-1))<Mex)-1))/(As*(Rr-1)) ;1/A1
	    if idt(0) ge 0 then vecSt=[vecSt,A1Sr] else vecSt=A1Sr

	    if n_is eq 1 then begin ;A2~
	       A2r=(1+exp((Bc*(Rr-1))<Mex)*exp((As*(Rr-1))<Mex)) / (1+exp((Bc*(Rr-1))<Mex))
	       if idt(0) ge 0 then vectt=[vectt,A2r] else vectt=A2r
	    endif
;*	    VANADIUM IN REFLEXION
	    A1Vr=(exp((Bn*(Rr-1))<Mex)*(exp((Av*(Rr-1))<Mex)-1))/(Av*(Rr-1)) ;1/A1
	    if idt(0) ge 0 then vecVt=[vecVt,A1Vr] else vecVt=A1Vr

	    if v_is*c_is eq 1 then begin ;A2~
	       A2r=(1+exp((Bn*(Rr-1))<Mex)*exp((Av*(Rr-1))<Mex)) / (1+exp((Bn*(Rr-1))<Mex))
	       if idt(0) ge 0 then vevtt=[vevtt,A2r] else vevtt=A2r
	    endif
	 endif
	 AA1=vecVt/vecSt
     endif else slab=0

;****REMOVE EMPTY CAN BEFORE ALINE ???
;****
     if bgsub(2) eq 0 then begin
      	 if n_is  eq 1 then                   rodata=(rodata - Ts*empti)
      	 if n_is  eq 1 then                   ERRdat=SQRT(ERRdat^2 + (Ts*ERRemp^2))
      	 if d_is  eq 1 then if n_is eq 1 then rodata=(rodata - (1-Ts)*cadmi)
      	 if d_is  eq 1 then if n_is eq 1 then ERRdat=SQRT(ERRdat^2 + (((1-Ts)*ERRcad^2)))
      	 if v_is  eq 1 then if c_is eq 2 then vanadi=(vanadi - Tv*empti)
      	 if d_is  eq 1 then if c_is eq 2 then vanadi=(vanadi - (1-Ts)*cadmi)
     endif
     if bgsub(3) eq 0 then begin
      	 if v_is  eq 1 then if c_is eq 1 then vanadi=(vanadi - Tv*canvi)
     endif

;****ALINE
;****
     exclu=[-1]   &  s_idx=indgen(sizs(2)) & decal=intarr(sizs(2))       & v_elas=s_elas
     excln=[-1]
     exclv=[-1]
     exclg=[-1]
     if bgsub(3) then cav=lineup(canvi  ,g_elas,g_idx,exclg,bid  ,tolow)
     if bgsub(2) then vid=lineup(empti  ,n_elas,n_idx,excln,bid  ,tolow ,ERRORS=ERRemp)
     if bgsub(0) then van=lineup(vanadi ,v_elas,v_idx,exclv,decal,tolow) & s_elas=v_elas
     if bgsub(1) then win=lineup(rodata ,s_elas,s_idx,exclu,decal,tolow ,ERRORS=ERRdat) else win=rodata

     if bgsub(1) then if not bgsub(0) then for i=0,sizs(2)-1 do win   (*,i)=shift(win   (*,i),decal(i))
     if bgsub(1) then if not bgsub(0) then for i=0,sizs(2)-1 do ERRdat(*,i)=shift(ERRdat(*,i),decal(i))
     if bgsub(0) then if not bgsub(1) then for i=0,sizs(2)-1 do van   (*,i)=shift(van   (*,i),decal(i))
     wro=win

     if  n_is eq 1  then if bgsub(2)  then begin
	 if n_elas gt 0 then $
	 if s_elas ne n_elas then vid   =shift(vid   ,s_elas-n_elas,0)
	 if s_elas ne n_elas then ERRemp=shift(ERRemp,s_elas-n_elas,0)
	endif else vid=empti

     if  v_is eq 1  then if bgsub(0)  then begin
	 if v_elas gt 0 then $
	 if s_elas ne v_elas then van   =shift(van   ,s_elas-v_elas,0)
	endif else van=vanadi

     if  c_is eq 1  then if bgsub(3)  then begin
	 if g_elas gt 0 then $
	 if s_elas ne g_elas then cav   =shift(cav,s_elas-g_elas,0)
	endif else cav=canvi

;****REMOVE EMPTY CAN AFTER ALINE ???
;****
     if bgsub(2) eq 1 then begin              win   =(win - Ts*vid)
                                              ERRdat=SQRT(ERRdat^2 + (Ts*ERRemp^2))
      	 if d_is  eq 1 then if n_is eq 1 then win   =(win - (1-Ts)*cadmi)
      	 if d_is  eq 1 then if n_is eq 1 then ERRdat=SQRT(ERRdat^2 + (((1-Ts)*ERRcad^2)))
         if v_is  eq 1 then if c_is eq 2 then van   =(van - Tv*vid)
      	 if d_is  eq 1 then if c_is eq 2 then van   =(van - (1-Ts)*vid)
     endif
     if bgsub(3) eq 1 then                    van   =(van - Tv*cav)

;****SLAB CORRECTIONS
     if slab then begin
     ;?? if n_is      eq 1 then for i=0,n_elements(vectt)-1 do vid (*,i)=vid (*,i) * vectt(i)
     ;?? if v_is*c_is eq 1 then for i=0,n_elements(vevtt)-1 do cav (*,i)=cav (*,i) * vevtt(i)
	 			for i=0,n_elements(AA1)  -1 do win   (*,i)=win   (*,i) * AA1  (i)
	                        for i=0,n_elements(AA1)  -1 do ERRdat(*,i)=ERRdat(*,i) * AA1  (i)
     endif
     
;****MERGE GOOD INDEX GIVEN BY LINEUP
;****
     idx=s_idx
     if (v_is eq 1) or (n_is eq 1) or (c_is eq 1) then begin
     	 if excln(0) ge 0  then if exclv(0) ge 0  then exclv=[exclv,excln] else exclv=excln
     	 if exclg(0) ge 0  then if exclv(0) ge 0  then exclv=[exclv,exclg] else exclv=exclg
	 if exclv(0) ge 0  then begin
     	    for i= 0,n_elements(s_idx)-1 do begin
	        n= where(exclv eq s_idx(i) ,cnt)
	        if cnt gt 0  then begin
				  exclu   =[exclu,s_idx(i)]
				  s_idx(i)=-1   &   endif
     	    endfor
     	    idx=s_idx(where(s_idx ge 0))
     	    if  n_elements(exclu) gt 1 then  begin
     	    	if exclu(0) eq -1 then exclu=exclu(1:*)
     	    	exclu=exclu(sort(exclu))
	    endif
	 endif
     endif
;****REDUCTION OF BAD DETECTORS
;****
     rr =3    &         win   =win   (rr:sizs(1)-rr-2,idx)
     			ERRdat=ERRdat(rr:sizs(1)-rr-2,idx)
			xout  =xout  (rr:sizs(1)-rr-2)
     if  v_is eq 1 then van   =van   (rr:sizs(1)-rr-2,idx)
     if  n_is eq 1 then vid   =vid   (rr:sizs(1)-rr-2,idx)
     if  slab eq 1 then vecSt =vecSt (idx)
     if  slab eq 1 then vecVt =vecVt (idx)
     sizs  =size (win)

     rawe=total( wro((s_elas-10)>0 : (s_elas+10)<(sizs(1)-1),idx) ,1)/21  &  wro=0

     s_elas=(s_elas-rr)>0
     nsp  =n_elements(idx)
     decal=decal(idx)
     yin  =yraw (idx)
     ytp  =yin

;****REMOVE ELECTR. NOISES IF NO EMPTY GIVEN
;****
     if  n_is eq  0 then vidp=fltarr(nsp)+1 else $
     if  n_is eq -1 then begin
	 pry =total (win,2)
	 pidx=sort  (pry)
	 pidx=pidx  (4:(n_elements(pidx)/4)>5)  &  nch =n_elements(pidx)
	 vch =(nch/10)>2
	 vid =fltarr(vch,nsp)
	 vie =fltarr(vch,nsp)

         for  i= 0,vch-1 do vid(i,*)= win   (pidx(i),*)
         for  i= 0,vch-1 do vie(i,*)= ERRdat(pidx(i),*)
         pry= total(vid  ,1)/vch
	 vie= total(vie^2,1)/vch
         for  i= 0,nsp-1 do win   (*,i)=    (win   (*,i)  -pry(i)) >0
         for  i= 0,nsp-1 do ERRdat(*,i)=SQRT(ERRdat(*,i)^2+vie(i))

         if v_is eq 1 then begin
            for  i= 0,vch-1 do vid(i,*)= van(pidx(i),*)
            pry=(total(vid,1))/vch
            for  i= 0,nsp-1 do van(*,i)=(van(*,i)-pry(i)) >0
         endif

         vidp=pry
     endif else $
         vidp=total(vid((s_elas-10)>0:(s_elas+10)<(sizs(1)-1),*),1)/21

;****NORMALIZE BY EFFICIENCIES
;****
     win=win+.3
     if (v_is eq 0) and (n_is eq -1) then begin
	 van =fltarr(nch,nsp)
	 for  i= 0,nch-1 do van(i,*)=win(pidx(i),*)
         pry =(total(van,1)/nch)+1 & van=0

     endif else if v_is eq 0 then pry=fltarr(nsp)+1 $

     else begin
	 tmp=total(van,2) & tmp=tmp/max(tmp)
	 van=van>0
	 print,'Elastic peak position:',s_elas+rr
         pry=(total(van((s_elas-10)>0:(s_elas+15)<(sizs(1)-1),*),1)/26)+1
;*       DEBYE-WALLER attenuation
;*
         kc   = (sin(yin*!pi/180/2) *4*!pi / wavel) ^2
         dwf  = exp(-.0067*kelvin/300 *kc)
         pry  = pry * dwf
     endelse
     mx   = max ( pry,min=mn )
     pry  = total(pry)/n_elements(pry)/pry

     for i=0,nsp-1 do win   (*,i)=win   (*,i)*pry(i)
     for i=0,nsp-1 do ERRdat(*,i)=ERRdat(*,i)*pry(i)
     if v_is*ires eq 1 then for i=0,nsp-1 do van(*,i)=van(*,i)*dwf(i)
    ;vidp =  vidp*pry
     corre=total(win((s_elas-10)>0:(s_elas+10)<(sizs(1)-1),*),1)/21

;****NEGATIVE VALUES
;****
     if n_is eq 1 then begin
         	idx=where(win   lt 0) & n =n_elements(idx)
		if n gt 1 then begin
			nto=total(win(idx))/n & pto=total(win)/n_elements(win)
			mxx=max  (win,min=mii)
			print,'Transmission Correction Info: E_negative='+string(nto)+' E_positive='+string(pto)
			print,'************ Min='+string(mii)+' Max='+string(mxx)
         		win =win>.3
		endif
     endif

;****Care with multidetector distance
;    --------------------------------
     j1=0  &  j3=0  &  j4=nsp-1

     a =where(yin lt 9.)
     if a(0) ge 0 then begin n=n_elements(a)-1 & j2=a(n) & j3=j2+1 & endif

;****TO S(w,2*theta)
;****
     decad = decal * cwidth/252.781/wavel
     cwidts= cwidth*1e-6
     xgen  = findgen   (sizs(1))

     ee    =(1.05457*  2*!pi)^2 / (2*1.67493) / 1.602177 * 10     ;h^2 /2m /f(joules)
     eelast= ee     /  wavel ^2
     telast= dist   *  wavel /3956.				  ;3956=1e6/252.781
     fltime= telast - (s_elas-xgen)*cwidts
     lam   = fltime *  3956. /dist

     yout =sin(yin*!pi/180/2) *4*!pi / wavel

      if   (instv eq 'IN10') or (instv eq 'IN16') then begin
       if  (instv eq 'IN10') then t2efac= 1.234 else t2efac=1.036
       xgen =xgen+1
       xout =xgen*2.0*t2efac*doppl/max(xgen)
       xout =xout-0.5*max(xout)
      endif else begin

       xout  = eelast -  ee    /lam ^2

;****  F(E) EFFICIENCIES
;****
       eff  = fe_a *exp( fe_b /sqrt(eelast-xout)) * (1-exp( fe_c /sqrt(eelast-xout)))
       ef5  = f5_a *exp( f5_b /sqrt(eelast-xout)) * (1-exp( f5_c /sqrt(eelast-xout)))
       flti = 1
       if instv eq 'IN5' then begin
          j5=where(Yin le 63) & j5=j5(n_elements(j5)-1)
          for i=j1,j5 do begin
		    telas2  =(dist-decad(i))*  wavel /3956.
     		    flti    =(telas2   - (s_elas-xgen)*cwidts) ^4 * 1.0e6 / telas2 *10
		    			   win   (*,i)= win   (*,i) * flti  / ef5
		    			   ERRdat(*,i)= ERRdat(*,i) * flti  / ef5
		    if v_is*ires eq 1 then van   (*,i)= van   (*,i) * flti  / ef5
          endfor
          j1=j5+1
       endif
       for i=j1,j4 do begin
		    telas2  =(dist-decad(i))*  wavel /3956.
     		    flti    =(telas2   - (s_elas-xgen)*cwidts) ^4 * 1.0e6 / telas2 *10
		    			   win   (*,i)= win   (*,i) * flti  / eff
		    			   ERRdat(*,i)= ERRdat(*,i) * flti  / eff
		    if v_is*ires eq 1 then van   (*,i)= van   (*,i) * flti  / eff
       endfor
      endelse

;*****GROUP
;*****
      gp  =1
      if sizs(2) gt 80  then gp=gp+1
      if sizs(2) gt 160 then gp=gp+1
      nsp =nsp/gp
      tms =yin  &	     pho_groupy, nsp,win,yin ,ERRdat
      if v_is*ires eq 1 then pho_groupy, nsp,van,tms
      sizs=size (win)

;*****RESOLUTION FILTER
;*****
      if v_is*ires eq 1 then begin
      tmc=total(van,2)
      tmv=smooth(smooth(median(tmc,3),3),3)
     
	id1=s_elas & m=tmv(s_elas)
	while (id1 gt 0) and (tmv(id1-1) lt m) do begin m=tmv(id1) & id1=id1-1 & endwhile
	id2=s_elas & m=tmv(s_elas) & n=sizs(1)-1
	while (id2 lt n) and (tmv(id2+1) lt m) do begin m=tmv(id2) & id2=id2+1 & endwhile
	
	id =max([s_elas-id1   , id2-s_elas]  )
	tmc=tmc((s_elas-id)>0 :(s_elas+id)<n )
			;tmc=[0,tmc-min(tmc),0]
			; mx=tmc(s_elas) & tmc=smooth(median(tmc,3),3) & tmc(id+1)=mx
	tmc=tmc/total(tmc)
	tmc=tmc>1E-4
	tmc=tmc-1E-4

;      win(*,20)=diconv(win(*,20),tmc,/stat)
      help,tmc
      i=1 & if i then $
      for i=0,nsp-1 do begin print,i,nsp-1
	tms=win(*,i)
;	if ires eq 1 then tms=diconv(tms,tmc,/use,/filt) $
;	             else tms=diconv(tms,tmc,/use,/stat)
	win(*,i)=tms
      endfor
      endif
;*****
      rr=2 & win   = win   (rr:sizs(1)-rr-2,*)
	     ERRdat= ERRdat(rr:sizs(1)-rr-2,*)
	     xout  = xout  (rr:sizs(1)-rr-2,*)
      sizs  =size (win)
      s_elas=(s_elas-rr)>0
      van=0 & vid=0 & cav=0

;*****REVERSE X AXIS (NOT TREATED BY INX FORTRAN)
      P_MUS,'mus_shot'
      win   =reverse( win  )
      ERRdat=reverse(ERRdat)
      xout  =reverse(-xout)
      s_elas=sizs(1) -s_elas -1

;*****WHERE ALREADY IN ENERGIE !!
   endif else begin
      yout=yraw
      yin =asin(yout*wavel/4/!pi)*180*2/!pi
      win =rodata
      ytp =yin & rawe=yin*0+1 & vidp=rawe & pry=rawe & corre=reform(win(s_elas,*))
      exclu=[-1]
   endelse

;*****CALL THE GRAPHICAL SHOW
     if slab eq 1  then vidp=vecSt
     ott   =[one,second,vanadn,emptn,canva]
     wavel =[wavel,cwidth,dist,kelvin,kelvis,transs,transv,slab,tolow,ra1,ra2,$
	     ires ,igg   ,sangl]
     phowind, ytp,rawe,vidp,pry,corre, xout,yin,win, yraw,exclu ,s_elas,ott,wavel ,ERRdat

;****OUTPUT VARIABLES BACK TO LAMP
;****
     iii=execute('y'+wk1+'=yout'  )
     iii=execute('x'+wk1+'=xout'  )
     iii=execute('e'+wk1+'=ERRdat')
     iii=execute('n'+wk1+'=centm' )
     x_tit(one)= 'Energy Changes (meV)'
     y_tit(one)= 'Q elastic'

endif else begin mess='! Sample-Detector distance too small [P'+wk2+'(27)]'
		 widget_control,l_message,bad_id=i,set_value=mess & print,string(7b),mess & endelse
endif else begin mess='! Wave-lenght not defined [P'+wk2+'(21) or P'+wk2+'(2)]'
		 widget_control,l_message,bad_id=i,set_value=mess & print,string(7b),mess & endelse
endif else begin mess='! Workspaces have different sizes ...'
		 widget_control,l_message,bad_id=i,set_value=mess & print,string(7b),mess & endelse
return,win
end
pro inx_event, event,uv
;** *********
;**
@lamp.cbk
common c_inx,inx_base,iws,iwv,iwe,iwc,iwr,its,itv,islab,ilo,ith0,ith1,ith2,ialph,ires,ibgmod

if uv(2) eq 1 then begin

   on_ioerror,mis
   text='? Bad workspace number... '
   widget_control,bad_id=i,uv(3) ,get_value=str & str=strlowcase (str(0))
	  iws   =strmid(str,strpos(str,'w')+1,10)  & nws=fix(strtrim(iws   ,2))
   widget_control,bad_id=i,uv(5) ,get_value=str & str=strlowcase (str(0))
	  iwe   =strmid(str,strpos(str,'w')+1,10)  & nwe=fix(strtrim(iwe   ,2))
   widget_control,bad_id=i,uv(6) ,get_value=str & str=strlowcase (str(0))
	  iwr   =strmid(str,strpos(str,'w')+1,10)  & nwr=fix(strtrim(iwr   ,2))
   widget_control,bad_id=i,uv(7) ,get_value=str & str=strlowcase (str(0))
	  iwv(0)=strmid(str,strpos(str,'w')+1,10)  & nwv=fix(strtrim(iwv(0),2))
   widget_control,bad_id=i,uv(15),get_value=str & str=strlowcase (str(0))
	  iwv(1)=strmid(str,strpos(str,'w')+1,10)  & nwd=fix(strtrim(iwv(1),2))
   widget_control,bad_id=i,uv(11),get_value=str & str=strlowcase (str(0))
	  iwc   =strmid(str,strpos(str,'w')+1,10)  & nwc=fix(strtrim(iwc   ,2))
   
   text='? Bad transmission value... '
   widget_control,bad_id=i,uv(4) ,get_value=str & str=str(0) & nts=float(str) 	  & its=str
   widget_control,bad_id=i,uv(8) ,get_value=str & str=str(0) & ntv=float(str) 	  & itv=str

   text='? Bad discrimination factor... '
   widget_control,bad_id=i,uv(10),get_value=str & str=str(0) & nlo=float(str)/100 & ilo=str

   text='? Bad slab angle... ' & nalph=0
   if islab gt 0 then begin widget_control,bad_id=i,uv(14),get_value=str & str=str(0)
			    nalph=float(str) & ialph=strcompress(str) & endif

   text=''
   on_ioerror,norange & n=-400 & nth1=n & nth2=n
   widget_control,bad_id=i,uv(12),get_value=str & str=str(0) & nth1=float(str)    & ith1=strcompress(str)
   widget_control,bad_id=i,uv(13),get_value=str & str=str(0) & nth2=float(str)    & ith2=strcompress(str)
   str=''
   norange:if (nth1 eq n) or (nth2 eq n) or (nth1 ge nth2)  then  begin
   			if ith0 eq 1 then text='? Bad angle range values...'
   			nth1=0 & nth2=0
   	   endif else   if ith0 eq 0 then begin nth1=0 & nth2=0 & endif
   
   if (nws gt 20) or (nwe gt 20) or  (nwr gt 20) or (nwd gt 20) or $
   		     (nwv gt 20) or  (nwc gt 20) then text='? Workspace gt 20... '
   if (nwr le 0 ) then  text='? Resulting workspace must be specified... '
   if (nws le 0 ) then  text='? Sample workspace must be specified... '
   mis:
   if text ne ''  then  widget_control,bad_id=i,uv(9),set_value=text+str  $
   else begin
  	widget_control,bad_id=i,uv(9),set_value='Working ...'
	ibgm=ibgmod(0)+ibgmod(1)*2+ibgmod(2)*4+ibgmod(3)*8
   	wk=[nwr,nws,nwv,nwe,nwc,nwd]     	 	 & wks= strtrim(string(wk),2)
   	rt=[nts,ntv,islab,nlo,nth1,nth2,ires,ibgm,nalph] & rtp= strtrim(string(rt),2)
   	
   	text='w'+wks(0)+'=didline (samp='+wks(1)+',vana='+wks(2)+',empty='+wks(3)+',canva='+wks(4)+ $
   				 ',cadm='+wks(5)+',trans_abs=['+rtp(0)+','+rtp(1)+','+rtp(2)+','+rtp(3)+ $
   				 	    ','+rtp(4)+','+rtp(5)+','+rtp(6)+','+rtp(7)+','+rtp(8)+'])'
   	XICUTE,text
	to_don_history,-1,0,'w'+wks(0)+'=didline(w'+wks(1)+')'
  	widget_control,bad_id=i,event.top,/destroy
   endelse
   
endif
if uv(2) eq 2 then islab  = uv(3)
if uv(2) eq 3 then ith0   = event.select
if uv(2) eq 4 then ires   = event.select
if uv(2) eq 5 then ibgmod(uv(3)) = event.select

return
end

pro inx ,o,t
;** ***
;**
@lamp.cbk
common c_inx

i=xregistered('Inx')
if i le 0 then begin

if n_elements(iws) eq 0 then begin
   iws=' 0  '  & iwv=[' 0  ',' 0  ']   & iwe=' 0  ' & iwc=' 0  ' & iwr=' 0  '    & ires=0  & ialph='      '
   its=' 0.90' & itv=' 0.85' & islab=0 & ilo='15.'  & ith0=0     & ith1='      ' & ith2 ='      '
   ibgmod=intarr(4) & ibgmod(0)=1
endif

if n_elements(o) eq 1 then begin iws=strtrim(string(t),2) & iwr=strtrim(string(o),2) & endif
if lamp_siz ge  900 then p_set_font,1
if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0

inx_base =widget_base  (title='Lamp parameters for DIDLINE',/column,resource_name='lamp')

base =widget_base  (inx_base,/column,resource_name='mic')
bsamp=widget_base  (base  ,/row)
blab =widget_label (bsamp ,value='Sample workspace'  	 ,font=ft_b_bigger)
bsamw=widget_text  (bsamp ,value=iws    ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bsamp ,value='Transmission'      	 ,font=ft_b_bigger)
bsamt=widget_text  (bsamp ,value=its    ,/editable   	 ,font=ft_propor  ,xsize=8,ysize=1)

bempt=widget_base  (base  ,/row)
blab =widget_label (bempt ,value='Empty-C workspace'	 ,font=ft_b_bigger)
bempw=widget_text  (bempt ,value=iwe    ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bempt ,value='Transmission 0.97'     ,font=ft_b_bigger)

bvana=widget_base  (base  ,/row)
blab =widget_label (bvana ,value='Vanadium workspace'	 ,font=ft_b_bigger)
bvanw=widget_text  (bvana ,value=iwv(0) ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bvana ,value='Transmission'      	 ,font=ft_b_bigger)
bvant=widget_text  (bvana ,value=itv    ,/editable   	 ,font=ft_propor  ,xsize=8,ysize=1)

bvaca=widget_base  (base  ,/row)
blab =widget_label (bvaca ,value='Empty-Van workspace'	 ,font=ft_b_bigger)
bvanc=widget_text  (bvaca ,value=iwc    ,/editable    	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bvaca ,value='Transmission 0.97'     ,font=ft_b_bigger)

bresu=widget_base  (base  ,/row)
blab =widget_label (bresu ,value='RESULTING..workspace'  ,font=ft_b_bigger)
bresw=widget_text  (bresu ,value=iwr    ,/editable       ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bresu ,value='(Cadmium wks'          ,font=ft_b_bigger)
bcadm=widget_text  (bresu ,value=iwv(1) ,/editable   	 ,font=ft_propor  ,xsize=4+cap,ysize=1)
blab =widget_label (bresu ,value=')'                     ,font=ft_b_bigger)

;blab =widget_label (base  ,value='.......'		 ,font=ft_propor)

base =widget_base  (inx_base,/column,resource_name='did')
bslab=widget_base  (base  ,/row)
blab =widget_label (bslab ,value='Self-absorption'   	 ,font=ft_b_bigger)
btog =widget_base  (bslab ,/column,/exclusive)
ntog =4
btg  =lonarr(ntog)
blab =['None','Single slab','Full cylinder','Hollow cylinder']
for i=0,ntog-1 do btg(i)=widget_button(btog  ,value=blab(i),font=ft_propor,/no_release,$
					     uvalue=[-88,341,2,i])
bslab=widget_base  (bslab ,/column)
blab =widget_label (bslab ,value='Angle:',font=ft_b_bigger)
balph=widget_text  (bslab ,value= ialph  ,/editable   ,font=ft_propor  ,xsize=6,ysize=1)

;blab =widget_label (base  ,value='...............'    ,font=ft_propor)

base =widget_base  (inx_base,/column,resource_name='don')
btlow=widget_base  (base  ,/row)
blab =widget_label (btlow ,value='Discrimination spectrum factor (%)' ,font=ft_b_bigger)
bdisc=widget_text  (btlow ,value=ilo    ,/editable   ,font=ft_propor  ,xsize=4+cap,ysize=1)

bteta=widget_base  (base  ,/row)
btete=widget_base  (bteta ,/nonexclusive)
btetb=widget_button(btete ,value='Use 2*Theta range from' ,font=ft_b_bigger,uvalue=[-88,341,3])
btet1=widget_text  (bteta ,value=ith1,/editable   ,font=ft_propor  ,xsize=6+cap,ysize=1)
blab =widget_label (bteta ,value='to',font=ft_b_bigger)
btet2=widget_text  (bteta ,value=ith2,/editable   ,font=ft_propor  ,xsize=6+cap,ysize=1)

;blab =widget_label (base  ,value='.....................'	   ,font=ft_propor)

base =widget_base  (inx_base,/column,resource_name='ben')
baso =widget_base  (base    ,/row)
bid  =widget_label (baso    ,value="Align from: ",font=ft_b_bigger)
bbgmo=widget_base  (baso    ,/row,/nonexclusive)
bbgm1=widget_button(bbgmo   ,value='vana'      ,font=ft_b_normal,uvalue=[-88,341,5,0])
bbgm2=widget_button(bbgmo   ,value='sample'    ,font=ft_b_normal,uvalue=[-88,341,5,1])
bbgm3=widget_button(bbgmo   ,value='empty'     ,font=ft_b_normal,uvalue=[-88,341,5,2])
bbgm4=widget_button(bbgmo   ,value='empty_v'   ,font=ft_b_normal,uvalue=[-88,341,5,3])

breso=widget_base  (base  ,/row,/nonexclusive)
bresb=widget_button(breso ,value='Use vana as instrument resolution' ,font=ft_b_bigger,$
			  uvalue=[-88,341,4])

berr =widget_label (base  ,value='____________________________________________',font=ft_propor)

uv   =[-88,341,1,bsamw,bsamt,bempw,bresw,bvanw,bvant,berr,bdisc,bvanc,btet1,btet2,balph,bcadm]
bgo  =widget_button(base  ,value='NEXT STEP' ,uvalue=uv,font=ft_b_bigger)
bexit=widget_button(base  ,value='CANCEL'    ,uvalue=[-88,399])

widget_control , btg(islab),set_button=1
widget_control , btetb     ,set_button=ith0
widget_control , bresb     ,set_button=ires
widget_control , bbgm1     ,set_button=ibgmod(0)
widget_control , bbgm2     ,set_button=ibgmod(1)
widget_control , bbgm3     ,set_button=ibgmod(2)
widget_control , bbgm4     ,set_button=ibgmod(3)
widget_control , btg(2)    ,sensitive =0
widget_control , btg(3)    ,sensitive =0
widget_control , bresb     ,sensitive =0
widget_control , inx_base  ,group_leader=lamp_b1,/realize
if lamp_siz ge 900 then p_set_font,0

XMANAGER, 'Inx', inx_base  ,event_handler='LAMP_EVENT_PARSER',/just_reg

endif else widget_control,bad_id=i,inx_base,map=1

return
end
function LINEUP, win ,elas ,goodx ,exclu ,decl ,TOLOW ,ERRORS=wer
;******* ******
;**
;** aline  elastic peaks having a shift less that TOBAD canals  (D. Richard).
;** Output:ELAS  for the peaks position.
;**        GOODX for a list of spectra having a good intensity and placement peak.
;**        EXCLU for a list of spectra having a bad  intensity or  placement peak.

wout=0
siz =size(win)
if   siz (0) eq 2 then begin

;  ********    				      *************
   TOBAD=60  & if n_elements(TOLOW) eq 0 then TOLOW=15./100 else TOLOW=TOLOW>0.01
;  ********    				      *************
   sy  =siz(2)
   wout=win
   cm  =fltarr(sy)
   eldx=intarr(sy)

   for  i=0,sy-1 do begin
        tmp      =win(*,i)                                         ;make one peak
	wout(*,i)=smooth(smooth(median(tmp,3),3),4)	           ;
	cm  (  i)=max   (tmp,elas)                                 ;get peak index
	eldx(  i)=elas                                             ;
   endfor

   a   =max(eldx,min=b) & elas=eldx(0)
   if a ne b then begin   his =histogram(eldx)                     ;elastic peak
   			  tmp =max(his  ,c)                        ;
   			  elas=min(eldx)+c        		   ;position
			  endif
   exclu =-1 & idg=0

   for  i=0,sy-1 do begin					   ;verify index
	if abs(elas-eldx(i)) ge TOBAD  then begin		   ;
		    eldx(i)=elas & exclu=[exclu,i]		   ;
	endif else  idg   =[idg,i]				   ;
   endfor

   decl=elas - eldx						   ;how  to  shift

   for  i=0,sy-1 do wout(*,i) =shift(win(*,i),decl(i))		   ;do the work
   if n_elements(wer) eq n_elements(wout) then $		   ;** *** ****
   for  i=0,sy-1 do wer (*,i) =shift(wer(*,i),decl(i))		   ;** *** ****
	
   idg =idg(1:*)						   ;minimum peak
   ng  =n_elements(idg)						   ;
   off =ng/10                                                      ;
   pri =cm(idg)                                                    ;
   pri =pri(sort(pri))                                             ;
   c   =total  (pri(off:ng-off-1))/(ng-2*off)                      ;
   c1  =c*TOLOW  &  c2=c/TOLOW                                     ;

   pry =total (wout(*,idg)>0,2)                                    ;noisy spectra
   pidx=sort  (pry)                                                ;
   pidx=pidx  (4:(n_elements(pidx)/40)>5)                          ;
   tmp =wout  (*,idg)>0                                            ;
   tmp =total (tmp(pidx,*),1) / n_elements(pidx)                   ;
   c   =total (tmp)/ng/TOLOW                                       ;
   for i=0,ng-1 do if tmp(i) gt c+1 then cm(idg(i))=0              ;

   goodx =-1
   for  i=0,ng-1 do if (cm(idg(i)) ge c1) and (cm(idg(i)) le c2) $ ;make goodx
		 then goodx=[goodx,idg(i)] $			   ;
		 else exclu=[exclu,idg(i)]			   ;

   if n_elements(goodx) gt 1 then goodx =goodx(1:*)
   if n_elements(exclu) gt 1 then begin
				  exclu =exclu(1:*)
   				  exclu =exclu(sort(exclu))
   endif
endif else P_MUS,'mus_cannon'

return,wout
end
function positive, w_in
;******* ********
;**
;** Transform an integer*2 unsigned array in a long positive one.
;** Call: W1 = POSITIVE ( W1 )

    s=size(w_in)
    if s(s(0)+1) eq 2 then begin

	index=where ( w_in lt 0 )
	
	w_in       =long  (w_in)
	
	if index(0) ge 0 then w_in(index)=65536+ w_in(index)
	
    endif
    	
    return, w_in
    
end
pro radial_AT, M, CENTER=xy0, INCREMENT=incr, UNROLL=unroll, DIAGRAM=intensity, X=xx, MASK=mask ,ERROR=error
;** *********
;**
;** Radial integration:   "Aurelie Tallandier July 2001 Grenoble".
;** ******************
;**	Input:	M    =2D data matrix (may contains -1 for masked values).
;**	*****	xy0  =[x0,y0] center coordinates (default [n,m]-1/2.)
;**		incr =unit of ray in pixels      (default  0.5)
;**		mask =same dimension as M, contains 1's for masked values otherwise 0's

;**	Output:	intensity =result of Radial integration.
;**	******	M         =Unrolled  matrix if /unroll keyword is set.
;**		xx        =diagram abscissa
;**		error     =diagram errors


common c_rad_at, RR,xc,yc,rmax,rmin

s=size(M)
IF (s(0) ne 2) or (s(1) lt 2) or (s(2) lt 2) THEN RETURN

IF n_elements(xy0)  ne 2 then xy0=([s(1),s(2)]-1.)/2.
IF n_elements(incr) ne 1 then incr=0.5

incr=abs(incr) <(s(1)/2) <(s(2)/2) > 0.01
dr  =incr/2.
xo  =xy0(0)  & yo=xy0(1) & ok=1
IF n_elements(r) eq n_elements(M) then if (xo eq xc) and (yo eq yc) then ok=0

;*****************************CALCUL DES RAYONS******************************
IF ok then BEGIN
	xc=xo & yc=yo

	x =findgen(s(1))
	x =[[x],[x]]
	x =congrid(x,s(1),s(2))

	y =transpose(findgen(s(2)))
	y =congrid(y,s(1),s(2))

	RR=sqrt((x-xo)^2+(y-yo)^2)
	rmax=MAX(RR,min=rmin)

ENDIF

;*****************************MASQUE******************************
R= RR
IF n_elements(mask) eq n_elements(M) then R(WHERE(mask))=-1


;*****************************CALCUL INTENSITE*******************************

; on calcule le  nombre d'elements de r contenus dans un cercle d'epaisseur dr*2
; ce qui nous donne 2 valeurs : un tableau des valeurs qui sont dans r +|-  dr
; et le nombre d'elements de ce tableau.

intensity=fltarr(round((rmax+dr-rmin)/incr)+1)
error    =intensity    
xx       =intensity    
IF keyword_set(unroll) then mat=fltarr(!pi*2*rmax,n_elements(xx))
j=0
FOR i=rmin,rmax+dr,incr DO BEGIN
 
; where permet de determiner quelles sont les valeurs de la matrice R qui se
; trouvent dans le cercle d'epaisseur dr*2. Elle renvoie les indices des valeurs
; correspondantes (indice unique au lieu de l'indicage ligne-colonne) 
; Ces indices sont places dans un tableau res.


 res=WHERE((R ge (i-dr)) and (R le (i+dr)))
 IF res(0) ge 0 then begin           ; Valeurs trouvees par where

; On veut recuperer les valeurs correspondantes aux indices de res
; pour chaque i afin de calculer l'intensite => m(res)

; on pondere la valeur de chq element par rapport a sa position dans le pixel
; plus le point est proche du centre du pixel ie de i, plus la fraction du
; pixel utilise sera grande

  w=1.-(abs(i-R(res))/(dr*2))
  totm= total(w*M(res))
  totw= total(w)
  intensity(j)= totm /totw
  error(j)=sqrt(totm)/totw
  xx(j)=i
  IF keyword_set(unroll) then mat(0,j)=m(res)
  j=j+1
 ENDIF
ENDFOR
IF j ne n_elements(xx) then begin j=j-1
	intensity=intensity(0:j)
	error    =error(0:j)
	xx       =xx(0:j)
ENDIF

IF keyword_set(unroll) then M=mat

END
;***************************************;

pro interpol,x_in,w_in,w_out,E,t,i            ,E_IN,E_OUT
;
; Do interpolation
;
  m=(w_in(t,*)-w_in(t-1,*))/(x_in(t)-x_in(t-1))
  b= w_in(t,*)-m*x_in(t)
  w_out  (i,*)=m*E+b

  if n_elements(e_out) gt 1 then begin
    r=(e_in(t,*)^2+e_in(t-1,*)^2)/(x_in(t)-x_in(t-1))
    s= e_in(t,*)^2  + r*x_in(t)
    e_out  (i,*)=SQRT(r*E+s)
  endif
  i=i+1
end

;***************************************;

pro calculate,Estep,x_in,w_in,w_out,E,t,i,nch ,E_IN,E_OUT
;
; Average over values within E..E+Estep
;
  counter=0
  e_out(i,*)=e_out(i,*)^2
  while (t lt nch-1) and (x_in(t) lt E+Estep)  do begin     
    w_out(i,*)=w_out(i,*)+w_in(t,*)
    if n_elements(e_out) gt 1 then e_out(i,*)=e_out(i,*)+e_in(t,*)^2
    t=t+1
    counter=counter+1
  endwhile
  w_out(i,*)=w_out(i,*)/counter
  if n_elements(e_out) gt 1 then e_out(i,*)=SQRT(e_out(i,*))/counter
  i=i+1
end
;***************************************;

pro starter,Estep,x_in,w_in,w_out,E,t,i       ,E_IN,E_OUT
;
; Find starting point
;
  while (x_in(t) lt E) do t=t+1
  while (x_in(t)-E) gt Estep do begin
    if t eq 0 then w_out(t,*)=0 $
    else interpol,x_in,w_in,w_out,E,t,i       ,E_IN,E_OUT
    E=E+Estep
  endwhile
end



function ebin,in_wk,Emin,Emax,Estep
;
; Bin with given Emin,Emx,Estep
;
@mac.in 
my_check=size(in_wk)

  if my_check(0) lt 1 then  begin
     P_MUS,'mus_cannon'
     mess='Workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
   endif

  if strpos(his(two),'t2e') lt 0 then begin
     P_MUS,'mus_cannon'
     mess='Input workspace not in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return,in_wk
  endif

  P_MUS,'mus_shot'
  nch=my_check(1)
  nang=my_check(2)
;
; Arguments reasonable ?
;
  if Emin gt Emax then begin
    E=Emax
    Emax=Emin
    Emin=E
  endif $
  else E=Emin
    if (Estep lt 0) then Estep=-Estep 
      if Estep gt (Emax-Emin) $
      or Estep eq 0 then Estep=max(x_in)-min(x_in)/nch
  length=round((Emax-Emin)/Estep)+1
  if length gt (3.*nch) then Estep=(Emax-Emin)/(3.*nch)
  w_out=fltarr(round((Emax-Emin)/Estep)+1,nang)
  x_out=fltarr(round((Emax-Emin)/Estep)+1)
  IF n_elements(e_in) eq n_elements(w_in) then E_OUT=w_out else E_OUT=0
  i=0 
  t=0
;
; Main program
;
  starter,Estep,x_in,w_in,w_out,E,t,i                ,E_IN,E_OUT
  repeat begin
    if (x_in(t)-E) gt Estep $
      then interpol,x_in,w_in,w_out,E,t,i            ,E_IN,E_OUT $
      else calculate,Estep,x_in,w_in,w_out,E,t,i,nch ,E_IN,E_OUT
    E=E+Estep
  endrep until E gt Emax
  c=findgen(round((Emax-Emin)/Estep)+1)
  x_out=Emin+Estep*c
  y_out=y_in
  p_out(30)=p_in(30)
  p_out(19)=round((Emax-Emin)/Estep)+1
@mac.out
  return,w_out
end

;***************************************;

pro eventhandler_bin_event, event
;
; Operations following widget events
;
common binwid, min_label,min_slider,max_label,max_slider,step_label, $
         step_slider,w_in_slider,w_out_slider,maxx,maxws,winsli, $
         Emin,Emax,Estep,sd   
common arns,av_epp,ep
@lamp.cbk
@dons.cbk
  widget_control, event.id, get_uvalue=p
;
  case p of 'done' :  begin 
;
;            Conversion to output format
;
      widget_control,min_label,get_value=min_b
      widget_control,max_label,get_value=max_b
      widget_control,step_label,get_value=step_b
      widget_control,w_in_slider,get_value=win_b
      widget_control,w_out_slider,get_value=wout_b
      min_bs =strtrim(strmid(min_b,6,7),2)
      max_bs =strtrim(strmid(max_b,6,7),2)
      step_bs=strtrim(strmid(step_b,7,7),2)
      win_bs =strtrim(string(win_b),2)
      wout_bs=strtrim(string(wout_b),2)
;
;            Execute BIN_W call
;
      rhs='=ebin(w'+win_bs +','+min_bs +','+max_bs + ',' +step_bs +')'
      lhs='w'+wout_bs
      comy=strarr(1)
      comy(0)=lhs+rhs
      xicuter,comy(0)
      widget_control,event.top,/destroy
      end
;
     'abort': widget_control,event.top,/destroy
;
     'w_in' : begin
; 
;            Check whether input workspace is full,
;            set output slider
;
      widget_control,w_in_slider, get_value=s
;      s=ws_full(s)
      widget_control, w_in_slider, set_value=s  
      if s eq maxws then $
        widget_control,w_out_slider,set_value=ws_full(s-1)+1 $
      else widget_control,w_out_slider,set_value=s+1
      winsli=s
      update1
      end

     'w_out': widget_control,event.id,get_value=t 

     'min'  : begin 
;
;           Read out Emin, Emax; is Emin < Emax ?
;           set label values
;
      widget_control,event.id,get_value=s 
      widget_control,max_slider,get_value=t
      if t le s then begin
        widget_control,max_slider,set_value=maxx
        widget_control,max_label,set_value='max = '+ $
          strtrim(string(Emax,format='(f10.2)'),2)
      endif
      widget_control,min_label,set_value='min = '+ $
        strtrim(string(Estep(s-1),format='(f10.2)'),2)
      end

     'max'  : begin
;
      widget_control,event.id,get_value=t
      widget_control,min_slider,get_value=s
      if t le s then begin $
        widget_control,max_slider,set_value=maxx
        widget_control,max_label,set_value='max = '+ $
          strtrim(string(Emax,format='(f10.2)'),2)
      endif $
      else widget_control,max_label,set_value='max = '+ $
        strtrim(string(Estep(t-1),format='(f10.2)'),2)                   
      end
;
   'step' : begin
;
;           Read out Estep
;
      widget_control,step_slider,get_value=s 
      dummy=(1./5.)*sd+s*((5.*sd-(1./5.)*sd)/maxx)
      widget_control,step_label,set_value='step = '+ $
        strtrim(string(dummy,format='(f10.4)'),2)
      end
  endcase
end

;-----------------------------------------------------------

;***************************************;


;***************************************;

pro update1
;
; Updates slider and label values
;
common binwid
common arns,av_epp,ep
@lamp.cbk
@dons.cbk
two=winsli
@mac.in

my_check=size(w_in)

  if my_check(0) lt 0 then   begin
     widget_control,min_label,set_value='No valid data'  
     widget_control,max_label,set_value='No valid data'  
     widget_control,step_label,set_value='No valid data'  
     mess='Input workspace empty'
     widget_control,bad_id=iii,l_message,set_value=mess
     return
  endif
  if strpos(his(two),'t2e') lt 0 then begin
     widget_control,min_label,set_value='No valid data'  
     widget_control,max_label,set_value='No valid data'  
     widget_control,step_label,set_value='No valid data'  
     mess='Input workspace not in energy'
     widget_control,bad_id=iii,l_message,set_value=mess
     return
  endif
     widget_control,bad_id=iii,l_message,set_value='ok'

  nch=my_check(1)
  nang=my_check(2)
; Calculate ranges of the sliders
;
  Estep  =fltarr(100)
  Emax   =x_in(nch-1)
  if (81.799/p_in(21)^2) gt 3*p_in(11)/11.6 then Emin=-81.799/p_in(21)^2 $
  else Emin=-3*p_in(11)/11.6
  if x_in(0) gt Emin then Emin=x_in(0)
  a=findgen(maxx)
  Estep=Emin+a*(Emax-Emin)/(maxx-1)
  if nch-1 ge p_in(9) then $
    sd=round((x_in(fix(p_in(9))+1)-x_in(fix(p_in(9))))*1000.)/1000. $
  else sd=0.01
;
; Set values of sliders and labels
;
  widget_control,min_slider,set_value=1
  widget_control,min_label,set_value='Emin = '+ $
    strtrim(string(Emin,format='(f10.2)'),2)
  widget_control,max_slider,set_value=maxx
  widget_control,max_label,set_value='Emax = '+ $
    strtrim(string(Emax,format='(f10.2)'),2)
  widget_control,step_slider, $
    set_value=round(maxx/6.)
  widget_control,step_slider,get_value=s
  dummy=(1./5.)*sd+s*((5.*sd-(1./5.)*sd)/maxx)
  widget_control,step_label,set_value='Estep = ' $ 
    +strtrim(string(dummy,format='(f10.4)'),2)
end

;--------------------------------------------------------------------------


pro rbin,ws=in_wk
;
; Widget window for the call of BIN_W
;
common binwid, min_label,min_slider,max_label,max_slider,step_label, $
         step_slider,w_in_slider,w_out_slider,maxx,maxws,winsli, $
         Emin,Emax,Estep,sd           
common arns,av_epp,ep
@lamp.cbk
@dons.cbk
  maxws=20
  maxx=100.
;
; Keyword check
;
;  if keyword_set(in_wk) then begin
;    two=in_wk
;    winsli=ws_full(in_wk)
;  endif $
;  else begin
;    two=maxws
;    winsli=ws_full(maxws)
;  endelse
;  two=winsli
@mac.in
emax=1.0
emin=-1.0
if n_elements(x_in) gt 1 then begin
emax=max(x_in)
emin=min(x_in)
endif

;
; Create and realize window
;
  winsli=1
  base     =widget_base (xsize=350, title='Rebin in Energy', $
     /column,space=20)
  head     =widget_label(base,value='REBINING OF SPECTRA',/frame)
  buttons  =widget_base(base,/row,/frame,space=245)
  wkspace  =widget_base(base,/row,/frame,space=105)
  Erange   =widget_base (base,/column,/frame)
  steprange=widget_base (base,/column,/frame)
;
  done_button =widget_button(buttons,value='done',uvalue='done')
  abort_button=widget_button(buttons,value='abort',uvalue='abort')
;
  w_in_slider =widget_slider(wkspace, title='workspace #(in)',$
    minimum=1,maximum=maxws,uvalue='w_in')
  w_out_slider=widget_slider(wkspace,title='workspace #(out)',$
    minimum=1,maximum=maxws,uvalue='w_out')
  widget_control,w_in_slider,set_value=winsli 
  if winsli eq maxws then $
    widget_control,w_out_slider,set_value=ws_full(winsli-1)+1 $
  else widget_control,w_out_slider,set_value=winsli+1
;
  range=widget_label(Erange, value='E-RANGE')
  min_label   =widget_label(Erange)
  min_slider  =widget_slider(Erange,uvalue='min',minimum=1,$
    maximum=maxx,/suppress_value)
  max_label   =widget_label(Erange) 
  max_slider  =widget_slider(Erange,uvalue='max',minimum=1,$
    maximum=maxx,/suppress_value)
;
  st_label   =widget_label(steprange,value='STEPWIDTH') 
  step_label =widget_label(steprange,value='step')
  step_slider=widget_slider(steprange,uvalue='step',/suppress_value)
;  update1
;
  bid=sys_dep      ('DYNLAB',base,1)
  widget_control,base,group_leader=lamp_b1,/realize
  xmanager,'eventhandler_bin',base
end

function rdgsas, INST , PATH , FILENAME , STATUS , DATP
;******* *************  
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.
 DATA  =0
 STATUS=11
 CATCH,stat & if stat ne 0 then begin print,!err_string & RETURN, DATA & endif

 ON_IOERROR, no_file
 OPENR,unit, PATH+FILENAME,/get_lun				;Open the data file

     STATUS=13
     ON_IOERROR, read_err
     wt='                                                                 '
     readf, unit , wt, format='(A80)'
     st1='            ' & st2= '           '
     npoints=0 & nlines=0 & nn=1 & zero= -220. & d2th= 10
     st4='            ' & st3= '           '
     readf, unit,     st1, nn ,npoints,nlines,st2,zero,d2th, $ 
            format = '(A4, I2, I5, I4, A6, I5, I3)'
     datall=intarr(2,npoints)
     readf, unit, datall, format = '(10(I2, I6))'      
     data=fltarr(npoints)+1.
     data=data*datall(1,*)
     err=fltarr(npoints)+1.
     err=err*sqrt(data)/sqrt((datall(0,*)>.25))
	    xv       =  FINDGEN(npoints)*d2th/100.+zero/100.			;Normaly in data file
	    xt       =' 2 theta (degrees) '			;         .
	    par      = [        3.0       ,        5.5        ]	;	  .
	    ptxt     = ['First  parameter','Second parameter' ]	;	  .
	    pall     =  INDGEN(20,8)

      STATUS=0							;Status is ok
;     ********
      DATP={X:      xv,    $					;Pass those variables which were 
            W_TIT:  wt,    $ 				;read-in into the DATP structure
	           X_TIT:  xt,    $                   
	           P:      par,   $
	           PAR_TXT:ptxt,  $
            E:      err,        $
            N:      fltarr(npoints)+100000. , $
	           PV:     pall   }
;     **********************  					
	    
 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:
 
 RETURN, DATA							;Return the data values
;************

 END
function rdspe, INST , PATH , FILENAME , STATUS , DATP
;******* *****
;**
;**	Standard call for a data-read function interfacing LAMP.
		  
;**	Return of the function
;**	 DATA     is an array of any dimensions and type containing the data values (spectra).

;**	Input  parameters:
;**	 INST(0)  is the file_type  (or instrument_name ) (string defined in customize tables).
;**	 INST(1)  is the file_group (or instrument_group) (string defined in customize tables).
;**	 PATH     is the full path where to find the data (string defined in customize tables).
;**	 FILENAME is the name of the data file.
;**		  if FILENAME(1) exists,  this is the requested image number in the file.

;**	Output parameters:
;**	 STATUS   is the returned error code you can choose from the following list:
;**		  0 =' Successfull read'	
;**		  1 =' Client/server on local node not established'
;**		  2 =' Client/server on router node not established'
;**		  3 =' The local  node cannot access the server node'
;**		  4 =' The router node cannot access the server node'
;**		  5 =' VME memory read error'
;**		  7 =' Sequence error in data transfer'
;**		  9 =' Parameter error'
;**		  10=' Router is busy with other transfer'
;**		  11=' Cant open the file or file not found'
;**		  13=' Data file incomplete'
;**		  14=' Bad instrument data definition'
;**		  24=' Cant read the file'.
;**		  
;**	 DATP     is a structure defined as follow: (all tags are OPTIONAL)
;**		  DATP.X        = vector of x coordinates.
;**		  DATP.Y        = vector of y coordinates.
;**		  DATP.Z        = vector of z coordinates.
;**		  DATP.W_TIT    =   main title
;**		  DATP.X_TIT    = x axis title
;**		  DATP.Y_TIT    = y axis title
;**		  DATP.Z_TIT    = z axis title
;**		  DATP.OTHER_TIT=    sub title
;**		  DATP.N        = monitors
;**		  DATP.P        = vector of parameter values up to 31
;**		  DATP.PAR_TXT  = string array of text associated to DATP.P (same size)
;**		  DATP.PV       = an array of any dimensions containing other parameter values
;**		  DATP.E        = the errors associated to DATA (same size)
;**		  DATP.TIME     = string date of the experiment.

 common c_rdid , dzap, pzap, pzip ,pzup

 DATA  =0
 UNIT  =-1
 STATUS=11
 CATCH,stat &	IF stat ne 0 then begin print,!err_string
 		IF unit gt 0 THEN FREE_LUN,unit & RETURN, DATA & endif
 IF n_elements(pzup) eq 0 THEN pzup=""				;Check sub-directory & filename
 MYFILE=FILENAME
 MYPATH=PATH
 abc   =0
 dvd   =sys_dep("DIVIDER")
 IF strpos(strlowcase(MYFILE), '.spe')  ge 0 THEN BEGIN
 			  IF  strpos(MYFILE,'-') eq 2 then $
			  IF rstrpos(MYFILE,'-') eq 5 then $
					     an=strmid(MYFILE,6,2)
					     if strpos(an,'0') eq 0 then an='20'+an else an='19'+an
					     MYPATH=MYPATH+an+dvd
					     MYPATH=MYPATH+strmid(MYFILE,0,8)+dvd
 ENDIF ELSE		  IF pzup ne "" THEN BEGIN  ON_IOERROR,misfix
					     an=strmid(pzup,6,2)
					     if strpos(an,'0') eq 0 then an='20'+an else an='19'+an
					     MYPATH=MYPATH+an+dvd
					     MYPATH=MYPATH+strmid(pzup,0,8)  +dvd
					     abc=fix(MYFILE)  & tmp=strtrim(string(abc),2)
					     if abc lt 100 then tmp= '0'+tmp
					     if abc lt  10 then tmp= '0'+tmp
					     MYFILE=pzup+tmp+'.spe' &  misfix: & ENDIF
 ON_IOERROR, no_file
 OPENR,unit, MYPATH+MYFILE,/get_lun				;Open the data file

      STATUS=13
      ON_IOERROR, read_err
      IF !version.os_family eq 'unix' then swap=1 else swap=0
      HEADER =BYTARR(4100)
      READU,unit,HEADER						;Read the header

	nx = fix (header, 42)	& if swap then BYTEORDER,nx,/sswap
	ny = fix (header, 656)	& if swap then BYTEORDER,ny,/sswap
	nf = long(header, 1446) & if swap then BYTEORDER,nf,/lswap & nf = nf>1
	ty = fix (header, 108)	& if swap then BYTEORDER,ty,/sswap
	case ty of
        0: DATA = fltarr(nx, ny, nf)
        1: DATA = lonarr(nx, ny, nf)
        2: DATA = lonarr(nx, ny, nf)
        3: DATA = intarr(nx, ny, nf)
        else:
	endcase
	READU,unit,DATA & DATA=reform(DATA)			;Read the data

      IF swap then begin
	    if (ty eq 1) or (ty eq 2) then BYTEORDER,DATA,/lswap
	    if (ty eq 3)              then BYTEORDER,DATA,/sswap ;Swap the bytes
      ENDIF
      ;if (ty eq 3)  then DATA = long(DATA) and 'ffff'x  ;does not have unsigned int

      index=where ( DATA lt 0 ) & DATA =long  ( DATA )
      IF index(0) ge 0 then DATA(index)=65536+DATA(index)

      STATUS=0							;Status is ok
;     ********

;offset = 3000
;xcal = { $
;        offset:         double(header, offset), $
;        factor:         double(header, offset+8), $
;        current_unit:   byte  (header, offset+16), $
;        reserved1:      byte  (header, offset+17), $
;        string1:        byte  (header, offset+18, 40), $
;        reserved2:      byte  (header, offset+58, 40), $
;        calib_valid:    byte  (header, offset+98), $
;        input_unit:     byte  (header, offset+99), $
;        polynom_unit:   byte  (header, offset+100), $
;        polynom_order:  byte  (header, offset+101), $
;        calib_count:    byte  (header, offset+102), $
;        pixel_pos:      double(header, offset+103, 10), $
;        calib_value:    double(header, offset+183, 10), $
;        polynom_coeff:  double(header, offset+263, 6), $
;        laser_position: double(header, offset+311), $
;        reserved3:      byte  (header, offset+319), $
;        new_calib_flag: byte  (header, offset+320), $
;        calib_label:    byte  (header, offset+321, 81), $
;        expansion:      byte  (header, offset+402, 87) $
;}

;offset = 3489
;ycal = { $
;    offset:         double(header, offset), $
;    factor:         double(header, offset+8), $
;    current_unit:   byte  (header, offset+16), $
;    reserved1:      byte  (header, offset+17), $
;    string1:        byte  (header, offset+18, 40), $
;    reserved2:      byte  (header, offset+58, 40), $
;    calib_valid:    byte  (header, offset+98), $
;    input_unit:     byte  (header, offset+99), $
;    polynom_unit:   byte  (header, offset+100), $
;    polynom_order:  byte  (header, offset+101), $
;    calib_count:    byte  (header, offset+102), $
;    pixel_pos:      double(header, offset+103, 10), $
;    calib_value:    double(header, offset+183, 10), $
;    polynom_coeff:  double(header, offset+263, 6), $
;    laser_position: double(header, offset+311), $
;    reserved3:      byte  (header, offset+319), $
;    new_calib_flag: byte  (header, offset+320), $
;    calib_label:    byte  (header, offset+321, 81), $
;    expansion:      byte  (header, offset+402, 87) $
;}
;x_calibration = poly(findgen(nx), xcal.polynom_coeff(0:xcal.polynom_order))
;y_calibration = poly(findgen(ny), ycal.polynom_coeff(0:ycal.polynom_order))
 
;comments= byte  (header, 200, 80, 5) & comments=strtrim(string (comments),2)+' '
;date    = byte  (header, 20 , 10)    & date    = string(date)
;hour    = fix   (header, 30) & if swap then BYTEORDER,hour  ,/sswap
;minute  = fix   (header, 32) & if swap then BYTEORDER,minute,/sswap
;second  = fix   (header, 38) & if swap then BYTEORDER,second,/sswap
;date    = date + ":" + string(hour,   format='(i2.2)') $
;               + ":" + string(minute, format='(i2.2)') $
;               + ":" + string(second, format='(i2.2)')

x_calibration =       indgen(nx)+1
y_calibration =       indgen(ny)+1

offset  = 3566

user    = byte  (header, offset+0  ,10)  & user   =strtrim(string (user),2)
date    = byte  (header, offset+50 ,10)  & date   =strtrim(string (date),2)
time    = byte  (header, offset+60 ,10)  & time   =strtrim(string (time),2)
sample  = byte  (header, offset+70 ,10)  & sample =strtrim(string (sample) ,2)
comment = byte  (header, offset+80 ,50)  & comment=strtrim(string (comment),2)
Diffrac = byte  (header, offset+130)

Collima = byte  (header, offset+131,4 )  & if swap then Collima=reverse(Collima)
Collima = float (Collima,0,1)

Axname  = byte  (header, offset+169,100) & Axname=reform(Axname,10,10)
Axname  = strtrim(string (Axname),2)+' '


Omeg=fltarr(10)
for i=0,9 do begin
Omega   = byte  (header, offset+279+i*4,4 )  & if swap then Omega  =reverse(Omega)
Omega   = float (Omega  ,0,1) & Omeg(i)=Omega
endfor
if omeg(0) ne 0 then ZOB=omeg(0) else ZOB=0.0001

if comment eq "" then comment=MYFILE+' ('+sample+')'

      DATP={X:     x_calibration, X_TIT:'X detector',$
            Y:     y_calibration, Y_TIT:'Y detector',$
	    Z:     ZOB ,$
	    PAR_TXT: ['file number ',Axname  ,'Diffractometer ','Collimator (mm) '] ,$
	    P:       [ abc          , Omeg   , Diffrac         , Collima] ,$
            TIME:  date,$
            W_TIT: comment,$
            other_TIT:  MYFILE+' User:'+user+' Sample:'+sample+' Time:'+date+' '+time}
;     **********************  					

 read_err:  FREE_LUN,unit					;Free the unit number
 no_file:   IF unit lt 0 THEN print,!err_string, string(7b)
 
 RETURN, reverse(DATA,2)					;Return the data values
;************

 END
;Dids!!! Dialog_Message, spec2hdf have been commented

function sdep, DS=ds, PS=ps, VF=vf, VS=vs, W=w

;+
; NAME:
;	SDEP
;
; PURPOSE:
;	Returns several System DEPendent parameters, like OS family (default), 
;	directory separator, path separator, etc. 
;
; CATEGORY:
;	General utilities
;
; CALLING SEQUENCE:
; 
;	Result = SDEP()
;
; INPUTS:
;	None
;
; KEYWORD PARAMETERS:
;	DS:	(Directory Separator) When set, SDEP returns the directory 
;		separator (i.e. 
;		/ (slash) under Unix or \ (backslash) under Windows).
;	PS:	(Path Separator) When set, SDEP returns the path separator 
;		(i.e. :  under Unix or ; (backslash) under Windows).
;	VS:	(Version Short) returns the idl short-version (i.e. 
;		'5' for idl 5.0.2)
;	VF:	(Version Full) returns the idl full versiom (i.e. 
;		'5.0.2' for idl 5.0.2)
;	W:	(Widget allowed?) Returns 1 when widget are allowed (i.e. 
;		!d.nane is 'WIN','X' or 'MAC') otherwise returns 0 (i.e. 'PS').
;
; OUTPUTS:
;	This function returns (with no keywords) the !version.os_family
;	value in uppercase. If any keyword is set, the returned value
;	is changed to the one described below.
;
; RESTRICTIONS:
;	Never used under Mac
;
; PROCEDURE:
;	Straightforward
;
; EXAMPLE:
;	print,sdep()
;
; MODIFICATION HISTORY:
; 	Written by:	srio@esrf.fr and dejus@aps.anl.gov
;	Sept, 1997	
;	97/10/16 srio@esrf.fr adds /w keyword.
;	98/12/23 srio@esrf.fr tentative update for Mac
;-
; returns system dependent values
; returns osversion if no keywords are set, otherwise returns the
; requested separator (ds = directory separator, ps = path separator)
; srio@esrf.fr 97-09-15 and dejus@aps.anl.gov 09/15/97.

osversion = StrUpCase(!version.os_family)

if keyword_set(ds) then begin		; directory separator
  CASE osversion OF
    'UNIX': 	return,'/'
    'WINDOWS': 	return,'\'
    'MACOS': 	return,':'
    else:		return,''
  ENDCASE
endif

if keyword_set(ps) then begin		; path separator
  CASE osversion OF
    'UNIX': 	return,':'
    'WINDOWS':	return,';'
    'MACOS': 	return,','
     else:		return,''
  ENDCASE
endif

if keyword_set(vf) then return,!version.release

if keyword_set(vs) then return,strmid(!version.release,0,1)

if keyword_set(w) then begin		; path separator
  CASE !d.name OF
    'WIN': 	return,1
    'X':	return,1
    'MAC': 	return,1
     else:	return,0
  ENDCASE
endif

return, osversion
end ; sdep

; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function checks if the parameter is a valid handle to a Spec data file.
function __isaspechandle, handle
   a=size(handle)
   if a(2) ne 8 then return, 0
   a = tag_names(handle)
   if a(0) ne 'SPECFILE' then return, 0 else return, 1
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function returns the first token found in the string `line' and
; modifies the content of `line' to hold only the remainder of the string.
function __linecut, line
   line = strtrim(line, 1) + ' '
   len = strlen(line)
   p = strpos(line, ' ')
   aux = strmid(line, 0, p)
   p = p + 1
   line = strtrim(strmid(line, p, len - p), 2)
   return, aux
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function returns an array loaded with the tokens found in the input
; string `oldline'. Tokens are separated by a 1 or 2 white spaces according
; to the parameter `nspaces'. The function returns an error if the numbers
; of tokens found is less than `imin' or greater than `imax'. This feature
; can be cancelled by setting `imin' and/or `imax' to zero.
function __linesplit, oldline, nspaces, imin, imax
   case nspaces of
      1: begin
         line = strtrim(strcompress(' ' + oldline))
         pos = where(byte(line) eq 32b)
      end

      2: begin
         line = '  ' + strtrim(oldline, 2)
         aux0 = byte(line)
         aux = aux0 eq 32b
         pos = where(aux and [aux(1:*), 0b] and     $
                     not [0b, aux(0:n_elements(aux)-2)])
         aux0(pos) = 1B
         line = strcompress(string(aux0))
         pos = where(byte(line) eq 1B)
      end

      else: return, ''
   endcase

   n = n_elements(pos)
   if n eq 1 then begin
      list = strmid(line, nspaces, strlen(line) - nspaces)
   endif else begin
      length = [pos(1:*), strlen(line)] - pos - nspaces
      pos = pos + nspaces
      list = strarr(n)
      for i = 0, n-1 do list(i) = strmid(line, pos(i), length(i))
   endelse

   if imin gt 0 and n_elements(list) lt imin then      $
      message, 'Too few fields in <'+oldline+'>' 
   if imax gt 0 and n_elements(list) gt imax then      $
      message, 'Too many fields in <'+oldline+'>' 

   return, list
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This function makes up an error message.
function __cleanmsg, msg
   p = strpos(msg, ':')
   return, strtrim(strmid(msg, p+1, strlen(msg) - p), 2)
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure reads a new full logic line from the data file.
pro __readline, Unit, line
   readf, Unit, line
   p = strlen(line) - 1
   aux=''
   while strmid(line, p, 1) eq '\' do begin
      strput, line, ' ', p
      readf, Unit, aux
      line = line + aux
      p = strlen(line) - 1
   endwhile
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure loads `array' with the data in the string `line'. The data
; type depends on the initial type of array. If in `line' there are less data
; than the number of elements in `array', the remainder elements are filled
; with 0 or '' and the variable `error' is set to 1.
pro __reads, line, array, error
   if (size(array(0)))(1) ne 7 then begin
      array(*)=0
      on_ioerror, toofew
      !ERROR = 0
      reads, line, array
toofew: 
      on_ioerror, null
      if !ERROR eq 0 then error = 0 else error =1
   endif else begin
      array(*) = ''
      narr = n_elements(array)
      _line = strtrim(strcompress(' ' + line))
      pos = where(byte(_line) eq 32b)
      n = n_elements(pos)
      if n eq 1 then begin
         array(0) = strmid(_line, 1, strlen(_line) - 1)
      endif else begin
         length = [pos(1:*), strlen(_line)] - pos - 1
         nread = (narr < n)
         if n ge narr then error = 0 else error =1
         list = strarr(n)
         for i = 0, nread - 1 do begin
            array(i) = strmid(_line, pos(i) + 1, length(i))
         endfor
      endelse
   endelse
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure appends a scan `s' to the array `scanlist' and is only
; used by spec_access().
pro __addscan, scanlist, s, linect, range, scancounter
   s.headerlines =   linect(0)
   s.predatalines =  linect(1)
   s.datalines =     linect(2)
   s.postdatalines = linect(3)

   if scancounter eq 0 then scanlist = s else scanlist=[scanlist, s]

   scancounter = scancounter + 1 
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure produces and error if the parameter is not a valid handle.
pro __speccheck, handle
;Dids
   if not __isaspechandle(handle) then message, 'Variable is not a valid SPEC handle.'
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure loads in `handle' the information contained in the main header
; block that correspond to the current scan.
pro __headerload, handle 
   if handle.headerpt ne handle.scan(handle.currscan).headerpt then begin
      n = handle.scan(handle.currscan).headerlines
      motorlbl = handle.motornames
      motorlbl(*, *) = ''
      motor_no = handle.motor_no
      motor_no(*) = 0
      epoch = -1L
      nmotlines = -1
      if n gt 0 then begin
         openr, Unit, handle.specfile, /get_lun
         point_lun, Unit, handle.scan(handle.currscan).headerpt
         line = ''
         motline = 0
	 ; srio 98/08/25 places "nmotlines = -1" outside the "if" block
         ;nmotlines = -1
         for i = 1, n do begin
            __readline, Unit, line
            case strmid(line, 1, 1) of
               'E': begin
                  epoch=long(strmid(line, 2, strlen(line)-2))
               end

               'O': begin
                  aux = __linecut(line)
                  reads, aux, format='(2X,I)', motline
                  aux = __linesplit(line, 2, 0, 0)
                  if aux(0) eq '' then begin
                     motor_no(motline) = 0
                  endif else begin
                     motor_no(motline) = n_elements(aux)
                     motorlbl(motline, 0:n_elements(aux) - 1) = aux
                  endelse
                  if motline + 1 gt nmotlines then nmotlines = motline + 1
               end

               else:

            endcase
         endfor
         free_lun, Unit
      endif
      handle.headerpt = handle.scan(handle.currscan).headerpt
      handle.epoch = epoch
      handle.nmotorlines = nmotlines
      handle.motor_no = motor_no
      handle.motornames = motorlbl
   endif
end
; INTERNAL FUNCTIONS AND PROCEDURES
;___________________________________
;
; This procedure makes the scan specified by `scan_id' the current one.
pro __specload, handle, scan_id, errmsg, INDEX=idx

   aux = size(scan_id)
   if aux(0) ne 0 then begin
      message, 'Scan number must be a scalar value'
   endif

   n = handle.currscan
   if n ge 0 then begin
      curr_n = handle.scan(n).scan_n
      curr_ap = handle.scan(n).scan_ap
   endif else begin
      curr_n = -1
      curr_ap = -1
   endelse

   if aux(1) eq 0 then begin
   endif else if aux(1) eq 7 then begin
      Up_scan_id = strupcase(scan_id)
      case Up_scan_id of
         'CURRENT': begin
            if n lt 0 then begin
               errmsg = 'No current scan'
               !ERR = 1
               return 
            endif else begin
               goto, load
            endelse
         end

         'NEXT': begin
            if n ge 0 and n lt handle.total-1  then begin
               n = n + 1
               goto, load
            endif else begin
               errmsg = 'No next scan'
               !ERR = 1
               return 
            endelse
         end

         'FIRST': begin
            if handle.total gt 0  then begin
               n = 0 
               goto, load
            endif else begin
               errmsg = 'No first scan'
               !ERR = 1
               return 
            endelse
         end

         'LAST': begin
            if handle.total gt 0  then begin
               n = handle.total - 1 
               goto, load
            endif else begin
               errmsg = 'No last scan' 
               !ERR = 1
               return 
            endelse
         end

         else: begin
            s_no = 0
            on_ioerror, isastring
            s_no = fix(scan_id)
isastring:  on_ioerror, null
            p = strpos(scan_id, '.') + 1
            if p gt 0 then begin 
               s_ap = fix(strmid(scan_id, p, strlen(scan_id)-p))
            endif else begin
               s_ap = 0
            endelse
         end
      endcase
   endif else begin
      if aux(1) lt 1 or aux(1) gt 5 then begin
         errmsg = 'Not a valid scan number.'
         !ERR = 1
         return 
      endif
      s_no = fix(scan_id)
      s_ap = round(100*(scan_id - s_no)) 
   endelse

   if s_no eq 0 or (s_no lt 0 and not keyword_set(idx)) then begin
      errmsg = 'Not a valid scan number.'
      !ERR = 1
      return 
   end

   if keyword_set(idx) then begin
      if s_no lt 0 then s_no = handle.total + s_no + 1
      if s_no gt 0 and s_no le handle.total then begin
         n = s_no - 1
         goto, load
      endif else begin
         errmsg = 'Not enough scans in "' + handle.specfile + '".'
         !ERR = 1
         return 
      endelse
   endif else if s_no eq curr_n and (s_ap eq 0 or s_ap eq curr_ap) then begin
      goto, load
   endif 
   if s_ap eq 0 then begin
      if n ge 0 then begin
         for n = n, handle.total-1 do begin
            if handle.scan(n).scan_n eq s_no then goto, load 
         endfor
      endif
      s_ap=1
   endif
   for n = 0, handle.total-1 do begin
      if handle.scan(n).scan_n  eq s_no and           $
         handle.scan(n).scan_ap eq s_ap then begin
            goto, load
      endif
   endfor
   
   errmsg = 'Scan '+strtrim(string(s_no),2)+'['+strtrim(string(s_ap),2)+ $
            '] not found in "'+ handle.specfile + '".'
   !ERR = 1
   return 

LOAD:
   if n ne handle.currscan then begin
      handle.label(*)=''

      if handle.scan(n).n_col gt 0 and handle.scan(n).labelpt gt 0 then begin
         openr,Unit,handle.specfile,/get_lun
         point_lun, Unit, handle.scan(n).labelpt+2
         line=''
         __readline, Unit, line
         free_lun, Unit

         aux = __linesplit(line, 2, handle.scan(n).n_col, handle.scan(n).n_col)
         handle.label=aux 
      endif

      handle.currscan = n
   endif
   !ERR = 0
   end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_COLUMNS()
;
; PURPOSE:
;       This function returns the number of data columns of a particular scan
;       in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_COLUMNS(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       MCDATA: Set this keyword to return the number of channels in the
;               multichannel data lines instead of the number of standard
;               data columns.
;
; OUTPUT: 
;       The number of columns in the selected scan. If the MCDATA keyword is
;       not set the information is obtained from the `#N' line in the SPEC
;       data file and corresponds to the number of standard data columns.
;       When MCDATA is set, the returned value is the number of channels in
;       the multichannel data lines obtained from the `#@CHANN' line.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To print the number of data columns in the second occurrence of the
;       scan 150 in the file 'baddata', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'baddata')
;       PRINT, SPEC_COLUMNS(File1_handle, 150.02)
;______________________________________________________________________________
;-

function spec_columns, handle, scan_id, INDEX=idx, MCDATA=mcdata
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string) ;, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'
   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg

   if keyword_set(mcdata) then begin
      return, handle.scan(handle.currscan).n_chan
   endif else begin
      return, handle.scan(handle.currscan).n_col 
   endelse
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_DATA()
;
; PURPOSE:
;       This function returns an array with data from a scan in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_DATA(Handle, Scan_Id [, Columns])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; OPTIONAL INPUTS:
;       Columns  - Vector that describes the columns to be loaded in the output
;                  array. This vector can be of either numeric or string type.
;                  When numbers are used columns are selected by their relative
;                  position in the data file. When non-numeric strings are used
;                  they must match the labels of the columns to select. By
;                  using a string array it is possible to combine both
;                  selection methods.
;                  If negative numbers are used it is assumed that the column
;                  position is obtained by counting backwards from the last
;                  one: i.e. -1 means the last column, -2 the one before the
;                  last, and so on.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       MCDATA: Set this keyword to return data from the multichannel data
;               lines instead of the standard data columns.
;
;       LABELS: String vector to be filled with the labels of the returned
;               columns. This option can only be used if the MCDATA keyword
;               is not set.
;
;       OFFSET: Number of points that will be skipped before extracting the
;               required data. This value is defaulted to 0.
;
;       STEP:   Interval used to extract data points. Only the first one of
;               each group of STEP consecutive data points will be extracted.
;               The default value is 1.
;
;       NPOINTS: Maximum number of points that will be returned. If it is
;               zero or greater than the actual number of available data
;               points, this keyword has not any effect.
;
;       CHANNELS: Float vector to be filled with the channel numbers of the
;               multichannel data. It is not used if the MCDATA keyword is
;               not set.
;
;       CALIBRATED: Float vector to be filled with the calibrated values
;               (usually energy) of the channels in the multichannel data set.
;               It is not used if the MCDATA keyword is not set.
;
;       STRING: Set this keyword to force the output to be a string array. 
;
;       DOUBLE: Set this keyword to force the output to be a double-precision
;               array.
;
;       FLOAT:  Set this keyword to force the output to be a single-precision
;               floating-point array.
;
;       LONG:   Set this keyword to force the output to be a longword integer
;               array.
;
;       INT:    Set this keyword to force the output to be an integer array.
;
; OUTPUT: 
;       This function returns an array containing the data columns selected by
;       the Columns parameter. If no Columns parameter is given, all the
;       columns in the selected scan are returned. By default the output 
;       is a double-precision array for standard data and a long array for
;       multichannel data, but the output array can be forced to any type by
;       setting the proper keyword.
;       If a particular column does not exist in the SPEC file, the
;       corresponding column in the output array is filled with zeros.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To load the array GoodData with the position of the first column of the
;       scan 5, the monitor counts and the detector counts (that are assumed to
;       be in the last column of the file), enter:
;
;       Dummy = SPEC_ACCESS(File_handle, 'weakdata')
;       GoodData = SPEC_DATA(File_handle, 27, ['1', 'Monitor', '-1'])
;
;______________________________________________________________________________
;-

function spec_data, handle, scan_id, columns, INDEX=idx, MCDATA=mcdata,        $
                           LABELS=labels, OFFSET=offset, STEP=step,NPOINTS=np,$
                           CHANNELS=chann, CALIBRATED=calib,                  $
                           DOUBLE=dtype, FLOAT=ftype, LONG=ltype, INT=itype,  $
                           STRING=stype
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() lt 2 or N_PARAMS() gt 3 then  $
                                   message, 'Incorrect number of arguments.'
   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg

   if keyword_set(mcdata) and keyword_set(labels) then  $
                                   message, 'No labels in multichannel data.'
   if not keyword_set(offset) then offset = 0
   if not keyword_set(step) then step = 1
   if not keyword_set(np) then np = 0
   offset = long(offset)
   step = long(step)
   np = long(np)
   if offset lt 0 then message, 'OFFSET must be a positive value.'
   if step lt 1 then message, 'STEP must be >= 1.'
   if step lt 0 then message, 'NPOINTS must be >= 0.'

   if keyword_set(mcdata) then begin
      n = handle.scan(handle.currscan).n_chan
      npoints = handle.scan(handle.currscan).a_datapoints
   endif else begin
      n = handle.scan(handle.currscan).n_col
      npoints = handle.scan(handle.currscan).n_datapoints
   endelse
   if npoints le 0 then message, 'No data points.'
   if npoints le offset then message, 'Offset too big.'
   npoints = long((npoints - offset - 1)/step) + 1
   if np gt 0 and npoints gt np then npoints = np

   if N_PARAMS() eq 2 then begin
      ncols = n
      index = indgen(ncols)
   endif else begin
      aux = size(columns)
      if aux(0) gt 1 then message, 'Too many dimensions.'
      ncols= aux(aux(0) + 2)
      index=intarr(ncols)
      aux = aux(aux(0) + 1)
      if aux gt 0 and aux lt 6 then begin
         index = fix(columns)  
      endif else if aux eq 7 then begin
         for i=0, ncols-1 do begin
            c=0
            on_ioerror, isastring
            c=fix(columns(i)) 
isastring:  on_ioerror, null
            if c eq 0 then begin
               if keyword_set(mcdata) then begin
                  message, "Not labels allowed with multichannel data."
               endif
               for j=1, n do begin
                  if columns(i) eq handle.label(j-1) then begin
                     c=j 
                     goto, set
                  endif
               endfor
            endif 
set:        index(i)=c
         endfor
      endif else begin
         message, "Bad data type."
      endelse
      index = index * (index ge -n and index le n) - 1
      index = index + (n+1)*(index lt -1) 
   endelse

   aux = where(index lt 0)
   if aux(0) ne -1 then begin
      message, "Wrong column specification [" +                  $
                                    strtrim(string(columns(aux(0))),2) + "]."
   endif

   if keyword_set(stype) then begin
      data = strarr(ncols, npoints)
      datal = strarr(n)
      datatype = 2
   endif else if keyword_set(mcdata) and not keyword_set(ftype) and  $
                                      not keyword_set(dtype) then begin
      data = lonarr(ncols, npoints)
      datal = lonarr(n)
      datatype = 1
   endif else begin
      data = dblarr(ncols, npoints)
      datal = dblarr(n)
      datatype = 0
   endelse

   openr,Unit,handle.specfile,/get_lun
   point_lun, Unit, handle.scan(handle.currscan).datapt
   line=''
   point = -offset
   pt = 0L
   for i = 0L, handle.scan(handle.currscan).datalines -1 do begin
      if pt eq npoints then goto, done
      __readline, Unit, line
      ok = point ge 0 and (point mod step) eq 0
      found = 0
      case strmid(line, 0, 1) of
         '':  ; Empty line. Do nothing

         '#': ; Header or comment. Do nothing

         '@': begin
            if keyword_set(mcdata) and strmid(line, 1, 1) eq 'A' then begin
               found = 1
               if ok then begin
                  aux0 = __linecut(line)
                  __reads, line, datal
               endif
            endif
         end

         else: begin
            if not keyword_set(mcdata) then begin
               found = 1
               if ok then begin
                  __reads, line, datal
               endif
            endif
         end
      endcase
      if found then begin
         if ok then begin
            data(*, pt) = datal(index)
            pt = pt + 1
         endif
         point = point + 1
      endif
   endfor
done:
   if keyword_set(mcdata) then begin
      nchan = 0      ; integer
      chmin = 0.     ; float
      chmax = 0.     ; float
      Chreduc = 0    ; integer
      calA = 0.      ; float
      calB = 1.      ; float
      calC = 0.      ; float
      point_lun, Unit, handle.scan(handle.currscan).scanpt
      for i = 1, handle.scan(handle.currscan).predatalines do begin
         __readline, Unit, line
         if strmid(line, 0, 7) eq '#@CHANN' then begin
            line = strmid(line, 7, strlen(line)-7) + ' 0 0 0 0'
            reads, line, nchan, chmin, chmax, chreduc
            if chreduc eq 0 then chreduc = 1
            if chmin eq chmax and nchan gt 1 then begin
               chmax = chmin + (nchan - 1) * chreduc
            endif
         endif else if strmid(line, 0, 7) eq '#@CALIB' then begin
            line = strmid(line, 7, strlen(line)-7) + ' 0 0 0'
            reads, line, calA, calB, calC 
         endif
      endfor
      if nchan gt 1 then begin
         chann = chmin + findgen(nchan)*(chmax-chmin)/(nchan - 1)
      endif else begin
         chann = chmin
      endelse
      calib = calA + chann * (calB + chann * calC)
   endif
   free_lun, Unit

   if not keyword_set(mcdata) then begin
      aux = [handle.label, '']
      labels = aux(index)
   endif

   if keyword_set(stype) then return, data
   if keyword_set(ftype) then return, float(data)
   if keyword_set(itype) then return, fix(data)
   if keyword_set(ltype) then return, long(data)
   return, reform(data)
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_HEADERS()
;
; PURPOSE:
;       This function returns header lines from a particular scan in a SPEC
;       data file. Header lines begin by the '#' character and can be situated
;       before or after the block of data lines.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_HEADERS(Handle, Scan_Id [, Selec_Array])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; OPTIONAL INPUTS:
;       Selec_Array - Array that contains selectors to the header lines.
;                  A selector is a string with the first characters of the
;                  header lines that are wanted to be returned. A selector can
;                  include or not the first '#' character of the header lines.
;                  For instance, the string 'P' selects all the headers in the
;                  scan that contain motor positions (those that begin with 
;                  the '#P' characters) and the string '#G0' selects the 
;                  first line of geometry parameters.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       ALL:    Set this keyword to extend the scope of the search and include
;               the main block of header lines as well as comments embedded in
;               the data block.
;               In normal SPEC data files the main header block is placed at
;               the beginning of the file and includes the file name line ('#F')
;               the epoch line ('#E') and the motor names ('#O' lines). If 
;               there are more than one main header block in the file, the
;               function uses the last one before the given scan.
;               Comment lines appear embedded in the data block when a scan
;               is resumed after been aborted from SPEC.
;
; OUTPUT: 
;       This function returns a string array that contains all the header lines
;       that match the selection criteria. If Selec_Array is not specified
;       all the header lines are returned.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To load the string array NewHeaders with the header lines that contain
;       the positions of the first eight motors ('#P0' line) and the user
;       defined values ('#U' lines), enter:
;
;       Dummy = SPEC_ACCESS(FileHandle, 'baddata')
;       Nscans = SPEC_HEADERS(FileHandle, BestScan, ['#P0','U'])
;
;       (the file in this example is 'baddata' and the scan number is in the
;       variable called BestScan)
;______________________________________________________________________________
;-

function spec_headers, handle, scan_id, headers, ALL=all, INDEX=idx
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() lt 2 then message, 'Incorrect number of arguments.'
   if N_PARAMS() eq 2 then begin
      headers = ''
   endif
   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   if keyword_set(all) then begin
      __headerload, handle
      nlh = handle.scan(handle.currscan).headerlines 
   endif else begin
      nlh = 0L
   endelse

   aux = size(headers)
   if aux(aux(0) + 1) ne 7 or aux(0) gt 1 then begin
       message, 'Argument is not a valid header specification.'
   endif
   nheaders = aux(aux(0) + 2)
   _headers = strarr(nheaders)

   for i = 0L, nheaders - 1 do begin
      if strmid(headers(i), 0, 1) ne '#' then begin
         _headers(i) = '#' + headers(i)
      endif else begin
         _headers(i) = headers(i)
      endelse
   endfor
   headlen = strlen(_headers)

   nl0 = nlh + handle.scan(handle.currscan).predatalines 
   nl1 = nl0 + handle.scan(handle.currscan).datalines
   nlt = nl1 + handle.scan(handle.currscan).postdatalines

   openr,Unit,handle.specfile,/get_lun
   if nlh gt 0 then begin
      point_lun, Unit, handle.scan(handle.currscan).headerpt
   endif 
   line = ''
   ct = 0L
   for i = 1L, nlt do begin
      if i eq nlh + 1 then begin
         point_lun, Unit, handle.scan(handle.currscan).scanpt
      endif
      __readline, Unit, line
      if i le nl0 or i gt nl1 or keyword_set(all) then begin
         if line ne '' and strmid(line, 0, 1) eq '#' then begin
            for j = 0L, nheaders - 1 do begin
               if strmid(line, 0, headlen(j)) eq _headers(j) then begin
                  if ct eq 0 then begin
                     result = line
                  endif else begin
                     result = [result, line]
                  endelse
                  ct = ct + 1
                  goto, outfor
               endif
            endfor
outfor:
         endif
      endif
   endfor
   free_lun, Unit

   if ct eq 0 then begin
      return, ''
   endif else begin
      return, result
   endelse
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_LABELS()
;
; PURPOSE:
;       This function returns the labels of data columns of a particular scan
;       in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_LABELS(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
; OUTPUT: 
;       This function returns an string array that contains the labels of the
;       the data columns in the SPEC file. The information is extracted from
;       the '#L' line. The dimension of the array depends on the number of
;       columns of this particular scan.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To load the array NewLabels with the labels of the data columns of the
;       scan no. 27 from a file called 'karaoke', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'karaoke')
;       NewLabels = SPEC_LABELS(File1_handle, 27)
;______________________________________________________________________________
;-

function spec_labels, handle, scan_id, INDEX=idx
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   n=handle.scan(handle.currscan).n_col
   if n gt 0 then return, handle.label(0:n-1) else return, ''
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_MOTORS()
;
; PURPOSE:
;       This function returns the names or position of motors in a particular
;       scan in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_MOTORS(Handle, Scan_Id [, MotorList [, BadValue]])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; OPTIONAL INPUTS:
;       MotorList - String array that contains the names of the motors which
;                  position is requested.
;                  In addition to motor names, it is also possible to specify
;                  a motor by using a string with the format 'line,motor' where
;                  `line' in the number of the `#P' header line that includes
;                  the motor information, and `motor' is the relative position
;                  of the motor in that line. For instance, '2,1' refers to
;                  the first motor in the `#P2' line.
;
;       BadValue - Dummy value to be returned as a motor position if the
;                  corresponding motor is not found or when the headers are
;                  corrupted and the NOERROR ketword is set. This value is
;                  defaulted to 1E20.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       NOERROR: Set this keyword to not return an error when the file headers
;               are corrupted. 
;
; OUTPUT: 
;       If MotorList is specified this function returns the position of the
;       motors included in the list. Otherwise it returns a string array
;       that contains the names of all the motors associated to the given scan.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;       If the file was created with an old version of SPEC and a motor name
;       has more than 8 characters this function will not work. It will not
;       work if a motor name includes two or more consecutive white spaces.
;
; EXAMPLE:
;       To print the position of the motors 'Theta', 'Piezo 1' and the second
;       motor of the first `#P' line in the fifth scan of a file called
;       'baddata', enter:
;
;       Dummy = SPEC_ACCESS(HHH, 'baddata')
;       PRINT, SPEC_MOTORS(HHH, -5, ['Theta', 'Piezo 1', '0,2'])
;______________________________________________________________________________
;-
function spec_motors, handle, scan_id, motorlist, badvalue, INDEX=idx,   $
                                                           NOERROR=noerror
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() lt 2 or N_PARAMS() gt 4 then       $
                                    message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   __headerload, handle
 
   if N_PARAMS() ge 3 then begin
      aux = size(motorlist)
      if aux(aux(0) + 1) eq 7 then begin
         list = strtrim(motorlist, 2)
      endif else begin
         message, 'Argument is not a valid motor name list.'
      endelse
   endif

   if N_PARAMS() lt 4 then begin
      returnbadvalue = 0
      badvalue = 1E20
   endif else begin
      returnbadvalue = 1
   endelse

   headersP = spec_headers(handle, 'current', '#P')
   motorlines = n_elements(headersP)

   if motorlines eq 0 then begin
      rows = 0
   endif else begin
      for i = 0, motorlines - 1 do begin
         auxline = headersP(i)
         aux = __linecut(auxline)
         headersP(i) = auxline
         reads, aux, format='(2X,I)', motline
         mot = __linesplit(auxline, 1, 0, 0)
         if i eq 0 then begin
            linelist = motline
            motlist = n_elements(mot)
         endif else begin
            linelist = [linelist, motline]
            motlist = [motlist, n_elements(mot)]
         endelse
      endfor
      rows = max(linelist) + 1
      cols = intarr(rows)
      allmotpos = fltarr(rows, max(motlist))

      for i = 0, motorlines - 1 do begin
         motline = linelist(i)
         cols(motline) = motlist(i)
         mot = __linesplit(headersP(i), 1, 0, 0)
         allmotpos(motline, 0:cols(motline)-1) = float(mot(0:cols(motline)-1))
      endfor
   endelse

   if handle.nmotorlines ne rows then begin
      corrupted = 1
   endif else begin
      corrupted = 0
      for i = 0, rows - 1 do begin
         if cols(i) ne handle.motor_no(i) then begin
            corrupted = 1
         endif
      endfor
   endelse

   if corrupted and not keyword_set(noerror) then begin
      message, 'File headers corrupted'
   endif

   if N_PARAMS() eq 2 then begin
      motornames = ''
      if not corrupted then begin
         for i = 0, handle.nmotorlines - 1 do begin
            for j = 0, handle.motor_no(i) - 1 do begin
               if motornames(0) eq '' then begin
                  motornames = handle.motornames(i, j)
               endif else begin
                  motornames = [motornames, handle.motornames(i, j)]
               endelse
            endfor
         endfor
      endif
      return, motornames
   endif else begin
      for k = 0, n_elements(list) - 1 do begin
         pos = badvalue
         motfound = 0
         for i = 0, rows - 1 do begin
            for j = 0, cols(i) - 1 do begin
               if not corrupted then begin
                  if handle.motornames(i, j) eq list(k) then begin
                     pos = allmotpos(i, j)
                     motfound = 1
                     goto, found
                  endif
               endif
            endfor
         endfor
         if not motfound then begin
            p = strpos(list(k), ',')
            if p gt 0 then begin
               on_ioerror, arestrings
               x = fix(strmid(list(k), 0, p))
               y = fix(strmid(list(k), p+1, strlen(list(k))-p-1)) - 1
               if x ge 0 and x lt rows then begin
                  if y ge 0 and y le cols(x) then begin
                     pos = allmotpos(x, y)
                     motfound = 1
                  endif
               endif
arestrings:    on_ioerror, null
            endif
         endif
found:
         if motfound or returnbadvalue or keyword_set(noerror) then begin
            if k eq 0 then begin
               motorpos = pos
            endif else begin
               motorpos = [motorpos, pos]
            endelse
         endif else begin
            message, 'Motor "'+ list(k) +'" not found.'
         endelse
      endfor
      return, motorpos
   endelse

end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_NAME()
;
; PURPOSE:
;       This function returns the name of a particular scan in a SPEC file.
;       In most of the cases the name of a scan is the full macro that was
;       used to produce obtain the data.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_NAME(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts several syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
; OUTPUT: 
;       The name of the selected scan. The information is obtained from the
;       '#S' line.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To print the name of the scan 150 from a file called 'baddata', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'baddata')
;       PRINT, SPEC_NAME(File1_handle, 150)
;______________________________________________________________________________
;-

function spec_name, handle, scan_id, INDEX=idx
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg
   return, handle.scan(handle.currscan).name 
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_POINTS()
;
; PURPOSE:
;       This function returns the number of data points of a particular scan
;       in a SPEC file.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_POINTS(Handle, Scan_Id)
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       Scan_Id  - Scan identifier. This parameter can be a numeric or string
;                  scalar value that accepts various syntax and keywords as
;                  it is explained in the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). The simplest case is to use
;                  the SPEC scan number as Scan_Id.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret a numeric value in Scan_Id
;               as the index of the scan instead of the scan number.
;
;       MCDATA: Set this keyword to make the function return the number of
;               points with multichannel data (MCA, ...) instead of the 
;               conventional data. 
;
; OUTPUT: 
;       The number of data points in the scan specified by Scan_Id.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;       If Scan_Id does not represent a valid scan the function produces an
;       error.
;
; EXAMPLE:
;       To print the number of data points in the scan 999 from a file called
;       'sosada', enter:
;
;       Dummy = SPEC_ACCESS(File1_handle, 'sosada')
;       PRINT, SPEC_POINTS(File1_handle, 999)
;______________________________________________________________________________
;-

function spec_points, handle, scan_id, INDEX=idx, MCDATA=mcdata
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 then message, 'Incorrect number of arguments.'

   __speccheck, handle
   __specload, handle, scan_id, errmsg, INDEX=idx
   if !ERR then message, errmsg

   if keyword_set(mcdata) then begin
      npoints = handle.scan(handle.currscan).a_datapoints
   endif else begin
      npoints = handle.scan(handle.currscan).n_datapoints
   endelse
   return, npoints 
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_SCAN()
;
; PURPOSE:
;       This function returns a vector loaded with the numbers of a group of
;       scans in a SPEC file.
;       The values returned correspond to either the numbers ('#S' lines) of
;       the scans or their indexes (relative position in the file).
;       This function can be used to check if a scan or group of scans exist
;       in a SPEC data file before calling any other function of the library.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_SCAN(Handle, ScanList [, ErrMsg])
;
; INPUTS:
;       Handle   - Handle to the SPEC data file initialised by a previous call
;                  to SPEC_ACCESS().
;
;       ScanList - List of scans in the SPEC data file. ScanList can be a 
;                  scalar or an array. In the case of arrays all the elements 
;                  are included in the list. ScanList can also be of numeric
;                  or string type.
;                  When using character strings one can specify a group of
;                  consecutive scans in compressed form using the syntax
;                  `first-last'. If `first' or `last' are not specified they
;                  are defaulted to the first and last scan in the file. It is
;                  also possible to include several scans or groups of scans
;                  in a single string by using commas or white spaces as
;                  separators.
;                  The values in ScanList follow the same convention used for
;                  scan identifiers (see the `SCAN IDENTIFIERS' section at the
;                  beginning of this file). By default, numeric values are
;                  interpreted as SPEC scan numbers, but this behaviour is
;                  changed by the INDEX keyword.
;
; KEYWORDS:
;       INDEX:  Set this keyword to interpret the numeric values in ScanList
;               as the indexes of the scans instead of as scan numbers.
;               Care must be taken when using indexes in strings that specify
;               groups of scans. In order to allow the use of negative indexes
;               the sign of the index must be explicitly included when the
;               expression can be ambiguous. As an example compare the
;               following expressions when INDEX is set: 
;                  '-2'    represents the scan before the last one (index=-2).
;                  '--2'   represents the scans from the first to the one
;                           before the last (index=1 to index=-2).
;                  '-+2'   represents the first two scans in the file
;                           (index=1 to index=2).
;
;       RETURN_INDEX: Set this keyword to return the index of the scans instead
;               of the scan numbers.
;
;       OCCURRENCE: Set this keyword to return the scan number and the scan
;               occurrence in the format SSSS.OO as explained in the `SCAN
;               IDENTIFIERS' section at the beginning of this file). This 
;               keyword has not any effect if RETURN_INDEX is also set.
;
;       STRING: Set this keyword to force the output as a string vector instead
;               of float.
;
;       NO_EMPTY: Set this keyword to make the output value of the function
;               refer only to those scans that actually contain standard data
;               columns, excluding the empty ones.
;
;       MCDATA: Set this keyword to make the output value of the function
;               refer only to those scans that contain multichannel data.
;
;       NO_RANGE: Set this keyword to force the function to accept only 
;               single scans as input instead of lists.
;
; OUTPUT: 
;       If there is no error this function returns a vector that contains the
;       list of scans specified in ScanList. If any of the scans is not found
;       or any other error occurs, the function return -1.
;
; OPTIONAL OUTPUTS:
;
;       ErrMsg  - Error message if an error occurs.
;    
; SIDE EFFECTS:
;       The `current' scan is set to the last scan in the list.
;
; RESTRICTIONS:
;       This function requires a valid handle to a SPEC data file obtained by
;       a previous call to SPEC_ACCESS().
;
; EXAMPLE:
;       To print the number of most recently accessed scan, enter:
;
;       PRINT, SPEC_SCAN(OldHandle, 'current')
;______________________________________________________________________________
;-
function spec_scan, handle, scan_list, errmsg, INDEX=idx, RETURN_INDEX=rindex,$
                                               OCCURRENCE=occurr, STRING=str, $
                                               NO_EMPTY=noemp, MCDATA=mca,    $
                                               NO_RANGE=no_range
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string);, /traceback
   endif

   ; Check arguments
   if N_PARAMS() ne 2 and N_PARAMS() ne 3 then begin
      message, 'Incorrect number of arguments.'
   endif
   errmsg = ''

   __speccheck, handle

   aux = size(scan_list)
   nelem = n_elements(scan_list)
   isstring = (aux(aux(0)+1) eq 7)
   if keyword_set(no_range) then begin
      if nelem gt 1 then return, -1
      if isstring then begin
         if strpos(scan_list(0),',') ne -1 or strpos(scan_list(0),'-') ne -1 $
                                                   then return, -1
      endif
   endif

   if not isstring then begin
      for i=0, nelem - 1 do begin
         __specload, handle, scan_list(i), errmsg, INDEX=idx
         if !ERR then return, -1
         if i eq 0 then begin
            indexlist = handle.currscan
         endif else begin
            indexlist = [indexlist, handle.currscan]
         endelse
      endfor
   endif else begin
      _scan_list = scan_list(0)
      for i=1, nelem - 1 do _scan_list = _scan_list + ',' + scan_list(i)
      _scan_list = strcompress(_scan_list, /remove_all)
      p = strpos(_scan_list, ',')
      while p ge 0 do begin
         strput, _scan_list, ' ', p
         p = strpos(_scan_list, ',')
      endwhile
      _scan_list = __linesplit(strcompress(_scan_list), 1, 0, 0)
      ngroups = n_elements(_scan_list)
      if ngroups eq 1 and _scan_list(0) eq '' then return, -1
      for i=0, ngroups-1 do begin
         p = strpos(_scan_list(i), '-')
         if p eq 0 and keyword_set(idx) then begin
            nextchar = strmid(_scan_list(i), 1, 1)
            if nextchar ne '-' and nextchar ne '+' and nextchar ne '' then begin
               p = strpos(_scan_list(i), '-', 1) 
            endif
         endif
         if p ge 0 then begin
            scan0 = strmid(_scan_list(i), 0, p)
            if scan0 eq '' then scan0 = 'FIRST'
            scan1 = strmid(_scan_list(i), p + 1, strlen(_scan_list(i)) - p - 1)
            if scan1 eq '' then scan1 = 'LAST'
         endif else begin
            scan0 = _scan_list(i)
            scan1 = ''
         endelse
         __specload, handle, scan0, errmsg, INDEX=idx
         if !ERR then return, -1 
         firstscan = handle.currscan
         if i eq 0 then begin
            indexlist = firstscan
         endif else begin
            indexlist = [indexlist, firstscan]
         endelse
         if scan1 ne '' then begin
            __specload, handle, scan1, errmsg, INDEX=idx
            if !ERR then return, -1 
            if handle.currscan ge firstscan then delta = 1 else delta = -1
            for j = firstscan + delta, handle.currscan, delta do begin
               indexlist = [indexlist, j]
            endfor
         end
      endfor
   endelse

   if keyword_set(mca) then begin
      dpoints = handle.scan(indexlist).a_datapoints
   endif else if keyword_set(noemp) then begin
      dpoints = handle.scan(indexlist).n_datapoints
   endif else goto, NoFilter
   aux = where(dpoints gt 0)
   if aux(0) eq -1 then return, -1
   indexlist = indexlist(aux)

NoFilter:
   if keyword_set(rindex) then begin
      result = indexlist + 1
   endif else if keyword_set(occurr) then begin
      result = handle.scan(indexlist).scan_n +     $
               handle.scan(indexlist).scan_ap/100.
   endif else begin
      result = handle.scan(indexlist).scan_n 
   endelse

   return, result
end
;______________________________________________________________________________
;+
; NAME:
;       SPEC_SAVE()
;
; PURPOSE:
;       This function saves the data contained in a 2D numeric array into a file
;       following the SPEC data file format. If the file does not exist it is created.
;       I the file exits, it must be a valid SPEC data file and the data is appended
;       as a new scan. 
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_SAVE(Handle, Data [, File])
;
; INPUTS:
;       Handle - Handle to the SPEC data file. It is initialized, if necessary, and
;                updated after the data is saved.
;
;       Data   - Numeric array containing the data to be saved. The first dimension
;                correspond to the data columns in the SPEC file.
;
; OPTIONAL INPUT/OUTPUT
;       File   - If Handle is not a valid SPEC file handle, this is parameter is the
;                name of the file where the data will be saved. Otherwise File
;                specifies a named variable where the actual name of the file will be
;                returned.
;
; KEYWORDS:
;       COLUMNS: Vector that specifies the columns in the array Data that will be
;               saved. If this keyword is not set all the columns are saved.
;
;       LABELS: String vector that contains the labels for the data columns.
;
;       COMMENTS: String vector that contains comment lines that will be included
;               in the header section of the scan.
;
;       NAME:   String that will appear as scan name in the `#S' line.
;
;       OVERWRITE: Set this keyword to overwrite the file if it exists. By default
;               data is appended to existing files.
;
;       NO_CONFIRM: Set this keyword to not ask for confirmation when writting data
;               on existing files.
;
;       NO_ERROR: Set this keyword to not produce an IDL error if an error is found
;               when writting the data. 
;
;	DIALOG_PARENT: Set this keyword equal to a string that specifies the name 
;		of the parent widget (to be passed to Dialog_Message)
;
; OUTPUT: 
;       This function returns the scan number under which the data is saved in the
;       file. If the operation is cancelled, the function returns zero. If an error
;       happens and NO_ERROR is set the function returns -1 and the error message
;       is stored in the system variable !ERR_STRING.
;
; EXAMPLE:
;       To save the data in the array NewData in the file 'Newfile', enter:
;
;       PRINT, SPEC_SAVE(DummyHandle, NewData, 'Newfile')
;______________________________________________________________________________
;-
function spec_save, handle, data, file, COLUMNS=columns, LABELS=labels,      $
                     COMMENTS=comm, NAME=name, NO_ERROR=noerror,             $
                     OVERWRITE=overwrite, NO_CONFIRM=no_conf,                $
		     DIALOG_PARENT=dialog_parent
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      if keyword_set(noerror) then return, -1
      message, __cleanmsg(!err_string);, /traceback
   endif

   aux = size(data)
   if aux(0) ne 2 then begin
      message, 'Data is not a 2D array.'
   end
   totcol = aux(1)

   if n_elements(columns) eq 0 then columns = indgen(totcol)
   ncol = n_elements(columns)
   if min(columns) lt 0 or max(columns) ge totcol then begin
      message, 'Column values are out of range.'
   endif

   nlab = n_elements(labels)
   if nlab lt ncol then begin
      extralbl= ('Column'+strtrim(indgen(ncol),2))(nlab:ncol-1)
      if nlab eq 0 then begin
         labels = extralbl
      endif else begin
         labels = [labels, extralbl]
      endelse
   endif
   labels = labels(0:ncol-1)

   if not keyword_set(name) then name = ''
;Dids
   if not keyword_set(file) then begin
      if __isaspechandle(handle) then begin
         file = handle.specfile
      endif else return, 0
   endif

   ; Check if writable and if new or SPEC file 

   openw, Unit, file, /get_lun, /append, error=err
   if err then begin
      message, 'Cannot open "'+file+'" for writting.'
   endif
   status = fstat(Unit)
   if status.size gt 0 then begin
      if spec_access(handle, file) eq 0 then begin
         free_lun, Unit
         message, 'Exists and is not a SPEC file'
      endif else begin
         scan = spec_scan(handle, 'last') + 1
      endelse
   endif else begin
      scan = 1
   endelse

   if keyword_set(overwrite) then begin
      if not keyword_set(no_conf) and scan gt 1 then begin
        ;tmp = Dialog_Message('SPEC file exists, overwrite data ?', /default_no, $
        ;                     title='Writting data', /question, $
	;		      DIALOG_PARENT=dialog_parent)
	 tmp = 'Yes'
         if tmp eq 'No' then begin
            free_lun, Unit
            return, 0
         endif
      endif
      free_lun, Unit
      openw, Unit, file, /get_lun
      scan = 1
   endif else begin
      if not keyword_set(no_conf) and scan gt 1 then begin
        ;tmp = Dialog_Message('SPEC file exists, append data ?', /question, $
        ;                      title='Writting data',		       $
	;		       DIALOG_PARENT=dialog_parent)
	 tmp = 'Yes'
         if tmp eq 'No' then begin
            free_lun, Unit
            return, 0
         endif
      endif
   endelse

   ; Write the data

   if scan eq 1 then begin
      printf, Unit, '#F ',file
      printf, Unit, '#E',strcompress(long(systime(1)))
      printf, Unit, '#D ',systime(0)
   endif 
   printf, Unit, ''
   printf, Unit, '#S',strcompress(scan),' ',name
   printf, Unit, '#D ',systime(0)
   if keyword_set(comm) then printf, Unit, transpose('#C ' + comm)
   printf, Unit, format='("#N ", I2)' ,ncol
   printf, Unit, format= '("#L",'+string(ncol)+'("  ",A))', labels
   printf, Unit, format='('+string(ncol)+'(G0.6," "))', data(columns, *)
   free_lun, Unit

   return, scan
end
;Dids PRO spec2hdf,filein,fileout,GROUP=group
;Dids ;+
;Dids ; NAME:
;Dids ;       SPEC2HDF
;Dids ;
;Dids ; PURPOSE:
;Dids ;       This procedure reads a SPEC file and creates an HDF file
;Dids ;	with its contents.
;Dids ;
;Dids ; CATEGORY:
;Dids ;       Filters.
;Dids ;
;Dids ; CALLING SEQUENCE:
;Dids ;       SPEC2HDF [, infile, outfile] 
;Dids ;
;Dids ; OPTIONAL INPUTS:
;Dids ;       infile - Name of the input file.
;Dids ;       outfile - Name of the output file.
;Dids ;	(if infile and/or outfile are not input, a dialog window 
;Dids ;	will appear to define them).
;Dids ;
;Dids ; KEYWORDS:
;Dids ;       GROUP: Set this keyword to the widget ID of an existing widget
;Dids ;               that serves as "group leader".
;Dids ;
;Dids ; OUTPUT:
;Dids ;
;Dids ; PROCEDURE:
;Dids ;	Uses SPECACCESS and HDF routines.
;Dids ;
;Dids ; EXAMPLE:
;Dids ;
;Dids ; MODIFICATION HISTORY:
;Dids ;       00-10-26  Written by M. Sanchez del Rio (srio@esrf.fr)
;Dids ;-
;Dids ;
;Dids ;=====================================================================
;Dids ;
;Dids COMMON spec2hdf_paths,pathIn,pathOut
;Dids 
;Dids On_Error,2
;Dids 
;Dids IF N_Elements(pathIn) EQ 0 THEN pathIn = ''
;Dids IF N_Elements(pathOut) EQ 0 THEN pathOut = ''
;Dids 
;Dids IF SDep(/w) NE 1 AND N_Params() LT 2 THEN Message,$
;Dids   'Usage: spec2hdf,filein,fileout'
;Dids 
;Dids IF N_Params() EQ 0 THEN BEGIN
;Dids   filein = Dialog_Pickfile(/READ,DIALOG_PARENT=group, $
;Dids      GET_PATH=pathin,PATH=pathIn)
;Dids   IF filein EQ '' THEN RETURN
;Dids   fileout=filein+'.hdf'
;Dids   fileout = Dialog_Pickfile(/WRITE,DIALOG_PARENT=group,FILE=fileout, $
;Dids     GET_PATH=pathOut,PATH=pathOut)
;Dids   IF fileout EQ '' THEN RETURN
;Dids ENDIF
;Dids IF N_Params() EQ 1 THEN BEGIN
;Dids   fileout = Dialog_Pickfile(/WRITE,DIALOG_PARENT=group,FILE=filein+'.hdf',$
;Dids     GET_PATH=pathOut,PATH=pathOut)
;Dids   IF fileout EQ '' THEN RETURN
;Dids ENDIF
;Dids 
;Dids Message,/Info,'Scanning file: '+filein
;Dids n=spec_access(h,filein)
;Dids hdffile=fileout
;Dids 
;Dids hdfhandle = HDF_SD_START(hdffile, /CREATE)
;Dids IF hdfhandle EQ 0 THEN message,'Error opening HDF file: '+hdffile
;Dids 
;Dids inormal = spec_scan(h,'-',/return_index)
;Dids imcdata = spec_scan(h,'-',/mcdata,/return_index)
;Dids 
;Dids ;
;Dids ; file header
;Dids ;
;Dids IF inormal[0] NE -1 THEN txt = spec_headers(h,1,/index,/all)  ELSE $
;Dids                          txt = spec_headers(h,1,/index,/all,/mcdata) 
;Dids 
;Dids igood = where(strmid(StrCompress(txt,/Remove_All),0,2) EQ '#S')
;Dids IF igood[0] NE -1 THEN BEGIN
;Dids   headerfile = txt[0:igood[0]-1]
;Dids   ihandle = HDF_SD_CREATE(hdfhandle,'File header',[0])
;Dids   FOR j=0L,N_ELEMENTS(headerfile)-1 DO BEGIN
;Dids         tmp = headerfile[j]
;Dids         HDF_SD_ATTRSET,ihandle,headerfile[j],headerfile[j]
;Dids   ENDFOR
;Dids ENDIF
;Dids 
;Dids ;
;Dids ; normal scans
;Dids ;
;Dids n = n_elements(inormal)
;Dids IF inormal[0] NE -1 THEN BEGIN
;Dids   Message,/Info,'Writing '+StrCompress(n,/Remove_All)+' normal scans...  '
;Dids   FOR i=0,n-1 DO BEGIN
;Dids     iscan = inormal[i]
;Dids     txt = spec_headers(h,iscan,/index,all=iall) 
;Dids     npoints = spec_points(h,iscan,/index)
;Dids     IF npoints GT 0 THEN BEGIN
;Dids       data = spec_data(h,iscan,/index)
;Dids       name = spec_headers(h,iscan,'S',/index)
;Dids       nx = (size(data))[1]
;Dids       ny = (size(data))[2]
;Dids       nn=[nx,ny]
;Dids       ihandle = HDF_SD_CREATE(hdfhandle,name,[nx,ny],/float)
;Dids       HDF_SD_ADDDATA,ihandle,data
;Dids       FOR j=0,n_elements(txt)-1 DO BEGIN
;Dids         HDF_SD_ATTRSET,ihandle,txt[j],txt[j]
;Dids       ENDFOR
;Dids     ENDIF
;Dids   ENDFOR
;Dids ENDIF
;Dids 
;Dids ;
;Dids ; mcdata scans
;Dids ;
;Dids n = n_elements(imcdata)
;Dids IF imcdata[0] NE -1 THEN BEGIN
;Dids   Message,/Info,'Writing '+StrCompress(n,/Remove_All)+' MCA scans...  '
;Dids   FOR i=0,n-1 DO BEGIN
;Dids     iscan = imcdata[i]
;Dids     txt = spec_headers(h,iscan,/index,all=iall) 
;Dids     npoints = spec_points(h,iscan,/index)
;Dids     IF npoints GT 0 THEN BEGIN
;Dids       data = spec_data(h,iscan,/index,/mcdata)
;Dids       name = spec_headers(h,iscan,'S',/index)
;Dids       nx = (size(data))[1]
;Dids       ny = (size(data))[2]
;Dids       nn=[nx,ny]
;Dids       ihandle = HDF_SD_CREATE(hdfhandle,name+' [MCDATA]',[ny,nx],/float)
;Dids       HDF_SD_ADDDATA,ihandle,data,/noreverse
;Dids       FOR j=0,n_elements(txt)-1 DO BEGIN
;Dids         HDF_SD_ATTRSET,ihandle,txt[j],txt[j]
;Dids       ENDFOR
;Dids     ENDIF
;Dids   ENDFOR
;Dids ENDIF
;Dids 
;Dids 
;Dids ; HDF_CLOSE,hdfhandle
;Dids HDF_SD_END,hdfhandle
;Dids Message,/Info,'File written to disk: '+fileout
;Dids 
;Dids END
; Version  3.00beta  10/10/1995
; European Synchrotron Radiation Facility (ESRF)
;______________________________________________________________________________
;+
; FILE: `spec_access.pro'
;
; OVERVIEW:
;       Set of IDL functions to read and write SPEC data files. These functions
;       provide information about the SPEC file (number of scans, scan list,
;       etc...) or about a particular scan (scan data, motor positions, header
;       information ...).
;       In order to speed up the access to the data, a file must be open by the
;       function SPEC_ACCESS() before any other operation is performed. This
;       function returns a handle to the file that has to be used in all
;       subsequent file access. The handle is a variable used to transfer
;       information internally between different functions and must not be
;       modified by the main program. A handle is associated to each individual
;       file and therefore several SPEC files can be accessed by managing
;       different handles.
;       All the functions require at least a file handle as parameter. If the
;       file handle has not been previously initialized, the functions call
;       internally SPEC_ACCESS() and prompt the user for a file name.
;       Most of the functions require also a scan identifier (see below). If 
;       the scan identifier is missing the functions call to XSPECSCAN that
;       is an utility procedure that displays the available scans in the data
;       file and lets the user select one.
;
; SCAN IDENTIFIERS
;       A scan identifier is an expression that designates a particular scan
;       in the data file. It must be a numeric or string scalar. Numeric values
;       can be expressed as strings by using their alphanumeric representation.
;       A scan identifier must be of one of the following three types:
;
;       Scan Number - A non-zero positive number that corresponds to the SPEC
;                     scan number included in the `#S' line in the data file.
;                     A mechanism has been provided to deal with files that
;                     include scans with repeated numbers: if a scan identifier
;                     is expressed as a decimal number SSSS.OO, it refers to
;                     the OOth occurrence of the scan SSSS in the data file.
;                     Special care must be taken when using this feature with
;                     number-valued expressions because the first two decimal
;                     places are always considered. For instance, the
;                     identifier 12.02 refers to the second occurrence of the
;                     scan 12, while 12.2 refers to the 20th occurrence of the
;                     same scan. This problem does not arise when string
;                     expressions are involved: the identifiers '12.02' and
;                     '12.2' refer both to the same scan in the data file.
;
;       Scan Index  - A non-zero integer number that indicates the position of
;                     the scan in the data file. Positive indexes correspond
;                     to the position of scan from the beginning of the file,
;                     the first scan in the file has an index 1. Negative
;                     indexes indicate the position of the scan by counting
;                     backwards from the end: -1 is the last scan in the file,
;                     -2 is the one before the last, and so on.
;                     When an index is used as a scan identifier, the INDEX
;                     keyword must be set in the function call in order to
;                     avoid ambiguities with scan numbers.
;
;       Descriptor  - One of the following words:
;                     'FIRST'  : refers to the first scan in the file.
;                     'LAST'   : refers to the last scan in the file.
;                     'CURRENT': refers to the scan that has been most
;                                recently accessed by any of the functions
;                                of this library.
;                     'NEXT'   : refers to the scan immediately after the
;                                `current' scan.
;       
;       
; FUNCTION LIST:
;       SPEC_ACCESS()  - Returns the number of scans in the file or a scan list.
;       SPEC_COLUMNS() - Returns the number of data columns in a given scan.
;       SPEC_DATA()    - Returns the data from a given scan.
;       SPEC_HEADERS() - Returns headers from a given scan.
;       SPEC_LABELS()  - Returns the column labels in a given scan.
;       SPEC_MOTORS()  - Returns the positions or names of the motors in a scan.
;       SPEC_NAME()    - Returns the name of a given scan.
;       SPEC_POINTS()  - Returns the number of data points in a given scan.
;       SPEC_SAVE()    - Saves data in a SPEC data file.
;       SPEC_SCAN()    - Returns the numbers or the indexes of a list of scans.
;
; MODIFICATION HISTORY:
;       1.00 March/95,  Written by P. Fajardo.
;                       based on 'spec_analyzer.pro' from M. Sanchez del Rio
;       2.00  June/95,  Added support for Multichannel Data (P. Fajardo).
;       2.01  5/07/95,  SPEC_DATA() modified to speed up data access. Default
;                       return data type is no longer string. New __reads
;                       procedure and __linesplit() function.
;                       Now the error handling routines return to the caller
;                       when an error is found (P. Fajardo).
;       2.02 21/08/95,  Fixed a bug in the handling of split lines. New CHANNELS
;                       and CALIBRATED keywords in SPEC_DATA() (P. Fajardo).
;       2.03 29/09/95,  New NO_EMPTY, MCDATA and FILENAME keywords in
;                       SPEC_ACCESS(). New NO_EMPTY, MCDATA and NO_RANGE
;                       keywords in SPEC_SCAN() (P. Fajardo).
;       3.00  --------
;       3.01 16/12/96,  Some elements of file handles changed from integer to
;                       long to cope with very long files.
;       3.02 01/10/97,  srio@esrf.fr places the function spec_access() at
;			the end of the file to allow idl to resolve all
;			names (for use in xop).
;______________________________________________________________________________
;-



;______________________________________________________________________________
;+
; NAME:
;       SPEC_ACCESS()
;
; PURPOSE:
;       This function returns the number of scans in a SPEC data file or
;       optionally the list of scans. The first time that it is called or if
;       the datafile is modified it reads the file and creates an internal
;       index to speed up the subsequent access to the data.
;       This function must be called before any other function of the library.
;
; CATEGORY:
;       Input/Output.
;
; CALLING SEQUENCE:
;       Result = SPEC_ACCESS(Handle [, SPECfile])
;
; INPUTS:
;       Handle   - Variable used as a handle to the file. This variable is
;                  modified internally by the function and must be used in
;                  all subsequent function calls to access the data file.
;                  If the variable used is not a valid handle to the file in
;                  SPECfile or if the length of the file has changed, the
;                  internal index is rebuilt. 
;                  If the variable used is a valid handle that has been 
;                  initialised in a previous call to SPEC_ACCESS(), the
;                  function checks if the current size of the file is the
;                  same than in the previous call. If so, the internal index
;                  is not rebuilt. 
;
; OPTIONAL INPUTS:
;       SPECfile - String that contains the name of the data file. This
;                  parameter is only optional in the case that Handle is a
;                  valid SPEC file handle initialised in a previous call to
;                  SPEC_ACCESS().
;
;
; KEYWORDS:
;       LIST:   Set this keyword to produce a list of the scans in the file.
;               By default the list is a vector that contains all the numbers
;               of the scans in the file. This behaviour can be changed by
;               the COMPRESS and STRING keywords.
;
;       COMPRESS: Set this keyword to return the scan list in a compressed
;               format. In a compressed list the scans with consecutive numbers
;               are grouped in blocks. Each block is described by the numbers
;               of its first and last scan. If the STRING keyword is not set
;               the result is an array with two dimensions where the element
;               (0, i) is the number of the first scan in the group i, and the
;               element (1, i) is the number of the last scan in the group.
;               This keyword has no effect if the LIST keyword is not set.
;
;       STRING: Set this keyword to format the result as a character string
;               rather than as a number, vector or array. If the result is a
;               compressed list, the groups in the output string are separated
;               by commas (',') and the first and last scan number of each
;               group are separated by a minus sign ('-').
;
;       READALWAYS: Set this keyword to force the function to read the file
;               and build the internal index even in the case that Handle is a
;               valid handle to the same file and the size of the file has not
;               changed. If READALWAYS is set, the parameters SPECfile must
;               be specified.
;
;       NOREAD: Set this keyword to force the function not to read again the
;               file even in the case that its size has changed.
;
;       NO_EMPTY: Set this keyword to make the output value of the function
;               refer only to those scans that actually contain standard data
;               columns, excluding the empty ones.
;
;       MCDATA: Set this keyword to make the output value of the function
;               refer only to those scans that contain multichannel data.
;
;       FILENAME: Variable to be loaded with the name of the Spec data file.
;               This keyword is only useful when the function is called with
;               a previously initialized SPEC file handle and the file name
;               is not known.
;
; OUTPUT: 
;       If the LIST keyword is not set this function returns the total number
;       of scans in the SPEC data file. If the LIST keyword is set, it returns
;       a list of the scans.
;
; SIDE EFFECTS:
;       When the internal index is built the `current' scan is set to the
;       first scan in the file.
;
; RESTRICTIONS:
;       This function only works with ASCII files that follow the conventions
;       used by the program SPEC to generate data files.
;
; EXAMPLE:
;       To create an internal index of the SPEC data file 'data.run23' and
;       load the variable Nscans with the total number of scans in the file,
;       enter:
;
;       Nscans = SPEC_ACCESS(File1_handle, "data.run23")
;
;       The variable File1_handle should not be modified by the main program.
;       It may be used to access information from the same file by other
;       function calls.
;______________________________________________________________________________
;-
function spec_access, handle, file, LIST=list, STRING=str, COMPRESS =compress,$
                                    READALWAYS=rall,  NOREAD=noread, $
                                    FILENAME=file0, MCDATA=mca, NO_EMPTY=noemp
   catch, error_status
   if error_status ne 0 then begin
      catch, /cancel
      on_error, 2
      message, __cleanmsg(!err_string) ;, /traceback
   endif

; Check arguments
   if N_PARAMS() eq 0 then begin
      message, 'Incorrect number of arguments.'
   endif

;Dids
   if N_PARAMS() eq 1 then begin
      if not __isaspechandle(handle) then message, 'No file selected.' $
      else begin
         file = handle.specfile
      endelse
   endif 

   file0 = file

   if keyword_set(noread) then begin
      goto, result
   endif

; Open SPEC data file
;
; srio changed these lines *porting to Windows* 97/01/13
;   file=(findfile(file))(0)
;   if file eq '' then message, 'File not found'
   if (findfile(file))(0) eq '' then message, 'File not found'
   openr, Unit, file, /get_lun
   status = fstat(Unit)

   if not keyword_set(rall) and __isaspechandle(handle) then begin
      if handle.specfile eq file and handle.filesize eq status.size then begin
         goto, close
      endif 
   endif

   scancounter = 0
   scanlist = 'no scans'

   line = ''
   name = ''
   range = 0B
   linect=lonarr(4)
   n_colmax = 1                              
   n_motlinesmax = 0
   n_motperlinemax = 0
   maxnumber = 0

   s = {scan,                $
          scan_n: 0L,        $
          scan_ap: 0L,       $
          name: '',          $
          predatalines: 0L,  $
          datalines: 0L,     $
          postdatalines: 0L, $
          scanpt: 0L,        $
          labelpt: -1L,      $
          datapt: 0L,        $
          n_col: -1L,        $
          n_chan: -1L,       $
          n_datapoints: 0L,  $
          a_datapoints: 0L,  $
          headerpt: 0L,      $
          headerlines: 0L    $
       }
;
; Start a loop to identify all the scans in the file 
;
   linect(0) = -1
   while (not EOF(Unit)) do begin
      point_lun,-Unit,memory_pointer
      __readline,Unit,line
      linect(range)=linect(range)+1

      if strmid(line,0,1) eq '#' then begin
         if range eq 2 then range = 3

         case strmid(line,1,1) of
            'S': begin
               scan_n=-1
               aux = strmid(line, 2, strlen(line)-2)+' '
               reads, aux, scan_n, name       ; read scan no.
               if strmid(line,2,1) eq ' ' and scan_n gt 0 then begin
                  if range gt 0 then begin
                     __addscan, scanlist, s, linect, range, scancounter
                  endif

                  range = 1
                  linect([1, 2, 3]) = 0
                  if scan_n gt maxnumber then maxnumber = scan_n
                  s.scan_n = scan_n
                  s.name = strtrim(name, 2)
                  s.scanpt = memory_pointer
                  s.n_col = -1
                  s.n_datapoints = 0
                  s.a_datapoints = 0
                  s.datapt = 0L
                  s.labelpt=-1L
               end
            end 

            'N': begin
               ; get no. of data columns
               s.n_col=fix(strmid(line, 2, strlen(line)-2))      
               if s.n_col gt n_colmax then n_colmax = s.n_col
            end

            'L': begin
               s.labelpt=memory_pointer
            end

            'F': begin
               if range gt 0 then begin
                  __addscan, scanlist, s, linect, range, scancounter
                  range = 0
                  s.headerpt = memory_pointer
                  linect(0) = 0
               endif
            end

            'E': begin
               if range gt 0 then begin
                  __addscan, scanlist, s, linect, range, scancounter
                  range = 0
                  s.headerpt = memory_pointer
                  linect(0) = 0
               endif
            end

            'O': begin
               if range gt 0 then begin
                  __addscan, scanlist, s, linect, range, scancounter
                  range = 0
                  s.headerpt = memory_pointer
                  linect(0) = 0
               endif

               aux = __linecut(line)
               reads, aux, format='(2X,I)', aux        ;get no. of motor lines
               if aux + 1 gt n_motlinesmax then n_motlinesmax = aux + 1

               aux = n_elements(__linesplit(line, 2, 0, 0))
               if aux gt n_motperlinemax then n_motperlinemax = aux
            end

            '@': begin
               if strmid(line, 2, 5) eq 'CHANN' then begin
                  reads, line + ' -1', format='(7X,I)', aux
                  s.n_chan = aux
               end
            end

            else: 

         endcase
      endif else if line ne '' then begin
         if range eq 1 then begin
            s.datapt = memory_pointer
            range = 2
         endif else if range eq 3 then begin
            linect(2) = linect(2) + linect(3)
            linect(3) = 0
            range = 2
         endif

         if range eq 2 then begin
            if strmid(line, 0, 2) eq '@A' then begin
               s.a_datapoints = s.a_datapoints + 1
            endif else begin
               s.n_datapoints = s.n_datapoints + 1
            endelse
         endif
      endif
   endwhile

   if range gt 0 then begin
      linect(range)=linect(range)+1
      __addscan, scanlist, s, linect, range, scancounter
   endif

   index = intarr(maxnumber + 1)
   for i = 0, scancounter - 1 do begin
      aux = scanlist(i).scan_n
      index(aux) = index(aux) + 1
      scanlist(i).scan_ap = index(aux)
   endfor

   if n_motlinesmax eq 0 or n_motperlinemax eq 0 then begin
      n_motlinesmax = 1
      n_motperlinemax = 1
   endif 

   handle = {                   $
      SPECfile: file,           $  ;SPEC filename
      filesize: status.size,    $  ;filesize in bytes
      total: scancounter,       $  ;total no. of scans
      scan: scanlist,           $  ;individual scan information
                                $
      currscan: -1,             $  ;current scan 
      label: strarr(n_colmax),  $  ;column labels for currscan
                                $
      headerpt: -1L,            $  ;pointer to last loaded header 
      epoch: -1L,               $  ;epoch value in main header block
      nmotorlines: 0,           $  ;no. motor lines in the main header block
      motor_no: intarr(n_motlinesmax),                     $
                                $  ;motors per line in the main header block
      motornames: strarr(n_motlinesmax, n_motperlinemax)   $
                                $  ;motor names in the main header block
   }

   __specload, handle, 1, /INDEX

close:
   free_lun, Unit

result:
   if handle.total gt 0 then begin
      if keyword_set(mca) and keyword_set(noemp) then begin
         aux = where(handle.scan(*).a_datapoints gt 0 or    $
                     handle.scan(*).n_datapoints gt 0)
         if aux(0) ne -1 then fulllist = handle.scan(aux).scan_n
      endif else if keyword_set(mca) then begin
         aux = where(handle.scan(*).a_datapoints gt 0)
         if aux(0) ne -1 then fulllist = handle.scan(aux).scan_n
      endif else if keyword_set(noemp) then begin
         aux = where(handle.scan(*).n_datapoints gt 0)
         if aux(0) ne -1 then fulllist = handle.scan(aux).scan_n
      endif else begin
         fulllist = handle.scan(*).scan_n
      endelse
   endif
   totsize = n_elements(fulllist)

   if totsize eq 0 then  begin
      if keyword_set(str) then begin
         return, ''
      endif else begin
         return, 0
      endelse
   endif
   ncols = 1
   ngroups = 1
   if keyword_set(list) then begin
      if not keyword_set(compress) then begin
         list = fulllist
         ngroups = totsize
      endif else begin
         ncols = 2
         list = [fulllist(0), fulllist(0)]
         for i = 1L, totsize - 1 do begin
            n = fulllist(i)
            if n eq list(1, ngroups - 1) + 1 then begin
               list(1, ngroups - 1) = n
            endif else begin
               list = [[list], [n, n]]
               ngroups = ngroups + 1
            endelse
         endfor
      endelse
   endif else begin
      list = totsize
   endelse

   
   if not keyword_set(str) then begin
      return, list
   endif else begin
      str=''
      for i = 0, ngroups - 1 do begin 
         if ncols eq 1 then begin
            str0 = strtrim(string(list(i)), 2)
         endif else if list(0, i) eq list(1, i) then begin
            str0 = strtrim(string(list(0, i)), 2)
         endif else begin
            str0 = strtrim(string(list(0, i)), 2) + '-'  $
                 + strtrim(string(list(1, i)), 2)
         endelse

         if i eq 0 then str = str0 else str = str + ', ' + str0
      endfor
      return, str 
   endelse
end

;*******************************************************************************************
;*******************************************************************************************
;*******************************************************************************************

pro spec_wplot,event, runtxt
;** **********
;**
common c_rdspec, c_hand, c_fil, c_siz, c_inor, c_imcd, c_ot, c_list, c_lz, c_fifi, c_bas

runtxt=''
index =event.index
txt   = c_list(index)
i     = strpos(txt,'.')
if (i gt 0) and (i lt 8) then begin    ;runtxt=c_fifi+'{'+strtrim(strmid(txt,0,i),2)+'}'
	r1 = strtrim(string(c_hand.scan(index).scan_n ),2)
	r2 = strtrim(string(c_hand.scan(index).scan_ap),2)
	runtxt=c_fifi+'{'+r1+'.'+r2+'}'
endif
if n_elements(c_list) ne c_lz then SPEC_WLIST
end

pro spec_wlist,lbase
;** **********
;**
common c_rdspec, c_hand, c_fil, c_siz, c_inor, c_imcd, c_ot, c_list, c_lz, c_fifi, c_bas

c_lz =n_elements(c_list)
if n_elements(lbase) eq 1 then $
     c_bas=widget_list(lbase,xsize=20,ysize=c_lz,value=c_list,uvalue=[-88,569,0,-1,0]) $
else if c_bas gt 0 then widget_control,bad_id=ii,c_bas,set_value=c_list
end

function read_spec, INST , PATH , FILENAME , STATUS , DATP
;******* *********
;**
;**	Standard call for a data-read function interfacing LAMP.

common c_rdspec, c_hand, c_fil, c_siz, c_inor, c_imcd, c_ot, c_list, c_lz, c_fifi, c_bas

if n_elements(INST) eq 0 then return,1

STATUS=11
DATA  =0

CATCH,stat & if stat ne 0 then begin CATCH,/cancel & print,!err_string & return,DATA & endif

;Check for scan number
;---------------------
FileN=FILENAME(0)
if n_elements(FILENAME) gt 1 then immg=FILENAME(1) else immg=1
ac=0
i =strpos(FileN,'{')                     & if i lt 0 then i=strpos(FileN,'[')
if i gt 1 then begin j=strpos(FileN,'}') & if j lt 0 then j=strpos(FileN,']')
                     ac=1
                     if j gt i+1  then immg=strmid(FileN,i+1,j-i-1)
		     FileN=strmid(FileN,0,i) & endif
c_fifi=FileN
FileN =PATH+FileN
img= 1 & imm=1   & simg = str_sep(string(immg),'.')
ON_IOERROR,mismg &  img = long(simg(0))>1
if n_elements(simg) eq 2 then imm=long(simg(1))>1
mismg:
imgs=strtrim(string(img),2)+'.'+strtrim(string(imm),2)
if not ac then FILENAME(0)=FILENAME(0)+'{'+imgs+'}'

;Check for file
;--------------
if n_elements(c_fil) eq 0 then begin c_fil='' & c_bas=0L & endif
if c_fil eq FileN         then new=0 else begin new=1 & c_fil=FileN & endelse

ON_IOERROR ,misfil
OPENR, Unit, FileN, /get_lun & S=fstat(Unit) & free_lun,unit
STATUS=13

if not new then if c_siz ne S.size then new=1

;Initialize Handel
;-----------------
if new  then begin print,'Initialising input file ....'
   n=spec_access(c_hand,FileN)
   if n le 0 then  return,DATA
   c_inor = spec_scan(c_hand,'-',/no_empty)
   c_imcd = spec_scan(c_hand,'-',/mcdata)
   c_fil  = FileN
   c_siz  = S.size
   HEAD   = spec_headers(c_hand,1,/ALL,/INDEX)
   F='' & D='' & C=''
   for i=n_elements(HEAD)-1,0,-1 do begin HD=strcompress(HEAD(i))
	a = strmid(HEAD(i),0,2)
	if a eq '#F' then F=' Origin:...'+strmid(HD,(strlen(HD)-20)>3,20)
	if a eq '#D' then D=' Start:'    +strmid(HD,3,25)
	if a eq '#C' then C=' Sample:'   +strmid(HD,3,50)
   endfor
   c_ot   = C+D+F

   inor   = spec_scan(c_hand,'-',/return_index)-1
   imcd   = spec_scan(c_hand,'-',/return_index,/mcdata)-1
   c_list = '<none>'
   if  inor(0) ge 0 then c_list= strtrim(string(c_hand.scan(inor).scan_n),2)+'. '   + $
                                 c_hand.scan(inor).name
   if  imcd(0) ge 0 then begin
    if inor(0) ge 0 then c_list=[c_list,'  ----','MCdata-> '+strtrim(string(c_hand.scan(imcd).scan_n),2)+' '+ $
                                 c_hand.scan(imcd).name]
    if inor(0) lt 0 then c_list= strtrim(string(c_hand.scan(imcd)),2)+'. MC '+ $
                                 c_hand.scan(imcd).name
   endif
   c_lz =0
   P_MAC_EVENT,0,[-88,570,0,-1]
   if n_elements(c_list) ne c_lz then SPEC_WLIST
endif
STATUS=9

;Check if scan number is there
;-----------------------------
mcd=0 & nor=0
idx=where(c_inor eq img) & if idx(0) ge 0 then nor=1
idx=where(c_imcd eq img) & if idx(0) ge 0 then mcd=1
if mcd+nor eq 0 then return,DATA
STATUS=14

;Prepare all variables
;---------------------
P_TXT=spec_headers(c_hand,imgs)+'  '
P_TXT=[P_TXT,FileN+'{'+imgs+'} points--> in PVi variable of Lamp  ']
P    =intarr(n_elements(P_TXT))
PV=0
X =0 & Y =img & Z =img
E =0
N =0
WT='' & XT='' & YT='' & ZT='' & OT=c_ot

T=0. & M=0. & Q='' & Tp=''
For i=n_elements(P_TXT)-1,0,-1 do begin
	a = strmid(P_TXT(i),0,2)
	if a eq '#S' then WT=strmid(strcompress(P_TXT(i)),3,100)
	if a eq '#Q' then Q =' (hkl:' +strmid(strcompress(P_TXT(i)),3,50)+')'
	if a eq '#X' then Tp=' Temp:'+strmid(strcompress(P_TXT(i)),3,50)
	if a eq '#T' then reads,strmid(P_TXT(i),2,20), T
	if a eq '#M' then reads,strmid(P_TXT(i),2,20), M
endfor
WT=WT+Tp     ;+Q
N =[[M],[T]]

;Read the data
;-------------
STATUS=0
if nor then begin
		PV   =spec_data(c_hand,imgs,LABELS=LABL)
		
		if not mcd then begin
		 YT   =LABL(n_elements(LABL)-1)
		 XT   =LABL(0)
		 sz   =SIZE(PV)
		 if sz(0) eq 2 then begin
		   DATA=reform(PV(sz(1)-1,*))
		   MONI=reform(PV(sz(1)-2,*))
		   X  =0 & ok=-1
		   for i=0,sz(1)-3 do begin
			if ok lt 0 then if PV(i,0) ne PV(i,sz(2)-1) then begin
				X=reform(PV(i,*)) & ok=i & endif
		   endfor
		   if ok ge 0 then XT=LABL(ok)
		   E=sqrt(DATA)
		   if N(0,1) gt 0 then begin N=fltarr(sz(2),2) & N(*,0)=MONI & N(*,1)=T
		   endif else $
		   if N(0,0) gt 0 then begin N=fltarr(sz(2),2) & N(*,0)=M & N(*,1)=MONI & endif
		 endif else begin
		   DATA=PV
		 endelse
		endif
endif
if mcd then begin
		DATA =spec_data(c_hand,imgs,/MCDATA,CHANNELS=X,CALIBRATED=calib)
		sz=SIZE(DATA)
		XT='Channels'
		Nt=N
		N =fltarr(sz(1),3) & N(*,0)=M & N(*,1)=T & N(*,2)=calib
		Y =indgen(sz(2))
		if nor then begin
		 sz   =SIZE(PV)
		 YT   =LABL(0)
		 if sz(0) eq 2 then begin
		   ok=-1
		   for i=0,sz(1)-2 do begin
			if ok lt 0 then if PV(i,0) ne PV(i,sz(2)-1) then begin
				Y=reform(PV(i,*)) & ok=i & endif
		   endfor
		   if ok ge 0 then YT=LABL(ok)
		 endif
		endif
endif

;Return every thing
;------------------
DATP={X:      x   , Y:y , Z:z , E:e , N:n   ,$
      W_TIT:  wt  , X_TIT:xt  , Y_TIT:yt    ,$
      Z_TIT:  zt  , OTHER_TIT:ot            ,$
      P:      p   ,    $
      PAR_TXT:p_txt,   $
      PV:     pv       }


misfil: RETURN, DATA
;       ************
 END
pro setpar_txt, inst_val,wi
;** **********
@lamp.cbk
     		par_txt(wi,0) ='X Dectector size (pixels)         ='
     		par_txt(wi,1) ='Y Dectector size (pixels)         ='

		if (inst_val eq 'in15') then begin
     		   par_txt(wi,2) ='Time of Flight if 1               ='
     		   par_txt(wi,3) ='Preset Monitor if 1 , time if 2   ='
     		   par_txt(wi,4) ='Wave lenght                       ='
     		   par_txt(wi,5) ='TOF Channel resolution            ='
     		   par_txt(wi,6) ='TOF Channel width                 ='
     		   par_txt(wi,7) ='TOF Delay                         ='
     		   par_txt(wi,8) ='???                               ='
;**
		 endif else if (inst_val eq 'd19')  then begin
     		   par_txt(wi,2) ='Acquisition number (>0 for scan ) ='
     		   par_txt(wi,3) ='Starting points                   ='
     		   par_txt(wi,4) ='Scan angle (2=omega 3=chi 4=phi)  ='
     		   par_txt(wi,5) ='Scan angle 1 value                ='
     		   par_txt(wi,6) ='Non  Scan  angle phi              ='
     		   par_txt(wi,7) ='Non  Scan  angle chi              ='
     		   par_txt(wi,8) ='Non  Scan  angle omega            ='
     		   par_txt(wi,9) ='Non  Scan  angle 2 theta          ='
     		   par_txt(wi,10)='Monitor 1                         ='
     		   par_txt(wi,11)='Time 1                            ='
;**
  		 endif else if (inst_val eq 'db21') then begin
     		   par_txt(wi,2) ='Acquisition number (>0 for scan ) ='
     		   par_txt(wi,3) ='Starting points                   ='
     		   par_txt(wi,4) ='Scan angle (2=omega 3=chi 4=phi)  ='
     		   par_txt(wi,5) ='Scan angle 1 value                ='
     		   par_txt(wi,6) ='Non  Scan  angle phi              ='
     		   par_txt(wi,7) ='Non  Scan  angle chi              ='
     		   par_txt(wi,8) ='Non  Scan  angle omega            ='
     		   par_txt(wi,9) ='Non  Scan  angle 2 theta          ='
     		   par_txt(wi,10)='Monitor 1                         ='
     		   par_txt(wi,11)='Time 1                            ='
;**
		 endif
return
end

pro rpcill, inst_val,run,wi,wstr,status
;** ******
;   Used by ILL only
@lamp.cbk

	instru =long(0)
	ttp    ='=lonarr'
	
	if inst_val eq 'espace'  then inst_val='d19'  else $
	if inst_val eq 'in5sgi'  then inst_val='in5'  else $
	if inst_val eq 'in6sgi'  then inst_val='in6'  else $
	if inst_val eq 'in10sgi' then inst_val='in10' else $
	if inst_val eq 'd7sgi'   then inst_val='d7'   else $
	if inst_val eq 'd19sgi'  then inst_val='d19'  else $
	if inst_val eq 'db21sgi' then inst_val='db21'
	
;	if inst_val eq 'in4'     then instru=long(1)    else $
;	if inst_val eq 'in5'     then instru=long(2)    else $
;	if inst_val eq 'in6'     then instru=long(3)    else $
;	if inst_val eq 'in15'    then instru=long(5)    else $
;	if inst_val eq 'in10'    then instru=long(4)    else $
;	if inst_val eq 'in16'    then instru=long(6)    else $
;	if inst_val eq 'd7'      then instru=long(7)    else $
	if inst_val eq 'd9'      then instru=long(8)    else $
;	if inst_val eq 'd11'     then instru=long(9)    else $
;	if inst_val eq 'd17'     then instru=long(10)   else $
	if inst_val eq 'd19'     then begin
				      instru=long(11) & ttp='=intarr' & endif else $
	if inst_val eq 'd22'     then instru=long(12)   else $
	if inst_val eq 'db21'    then begin
				      instru=long(13) & ttp='=intarr' & endif
	
    if  (instru    gt   0) and $
       ((lamp_data eq 'hostvms') or (lamp_data eq 'idol')) then begin

        status =3
	run    =long(run)
	channel=long(0) & spect=long(0) & np=long(0) & text=bytarr(512) & param=fltarr(512)

	entri=sys_dep('ENTRY')   ;lamp_entry
	com1='status=call_external(lamp_exec,entri,instru,get,run,channel,spect,np,text,param,0,0)'
	com2='status=call_external(lamp_exec,entri,instru,get,run,channel,spect,np,text,param,nppar,'$
				   +'w'+wstr+')'
	stat=0 & iii=1
      	catch,stat
      	if (stat eq 0) and (iii eq 1) then begin
;**	Get the parameters
;**	*** *** **********
	    get=long(0)
      	    iii=execute(com1)
      	    status=get
      	    if iii ne 1 then status=23
      	    if (status eq 0) then begin 
      	      w0  =0
      	      full=0
      	      if (wi gt 0) and (wi le 20+3) then iii=execute('w'+wstr+'=0') else full=-1

	      if (np gt 201) then np=201
      	      if (full ge 0) and (np ge 0) then begin
;**	Allocate all spaces
;**	******** *** ******
		if (inst_val eq 'd11') or (inst_val eq 'd17') or (inst_val eq 'd22') then $
		    if (channel ge 64.*64.) and (spect  le 1) then begin channel=long(sqrt(channel))
		    							 spect  =channel & endif
      	    	if np gt 0 then nppar=fltarr(15,2,np) else nppar=0
      	    	if spect le 1 then iii=execute('w'+wstr+ttp+'(channel)')     else $
      	    	if np    le 1 then iii=execute('w'+wstr+ttp+'(channel,spect)'   ) $
      	    		      else iii=execute('w'+wstr+ttp+'(channel,spect,np)')

;**	Get the data
;**	*** *** ****
      	    	get    =long(1)
      	    	iii=execute(com2)
      	    	status=get
      	        if iii ne 1 then status=23
	      endif 	    else status=8
;**	Must be positive
;**	**** ** ********
	      if (status eq 0) and (ttp eq '=intarr') then begin
	      	  mini=0 & iii=execute('mini=min(w'+wstr+')')
	      	  if mini lt 0 then begin
	      	  	hhs=0 & iii=execute('hhs=where(w'+wstr+' lt 0)')
	      	  	iii=execute('w'+wstr+'=long(w'+wstr+')')
	      	  	iii=execute('w'+wstr+'(hhs)=65536+w'+wstr+'(hhs)')
	      endif & endif

;**	Place all parameters
;**	***** *** **********
		clearpar, wi,wstr
		
		npar=n_elements(param) & if npar gt npars then npar=npars
		iii =execute('p' +wstr+'= param(0:npar-1)')       
      	    	w_numor(wi)	 = strtrim(string(run),2)

     	        w_tit(wi)	 =strcompress(string(text(0:59)))
     	        x_tit(wi)	 ='Channels'   
     	        y_tit(wi)	 ='Spectra'   
     	        if np gt 1 then z_tit(wi) ='Points' else  z_tit(wi) ='Counts' 
     	        other_tit(wi)	 =w_numor(wi)+' '+strcompress(string(text(60:79))) $
     	        			     +' '+strcompress(string(text(80:159)))
     	        head_tit (wi,*)  =''
     	        head_tit (wi,2)  =inst_value
;**
		if (inst_val eq 'in15') or (inst_val eq 'd19') or (inst_val eq 'db21') then begin
     	         w_tit(wi)	=strcompress(string(text(36:107)))
     	         head_tit (wi,4)=				string(text(4:13))
     	         other_tit(wi)  =string(text(0:3))   +' Date '+ string(text(4:13))  +' Time '+ $
     	        		 string(text(14:21)) +' User '+ string(text(24:29)) +' '     + $
     	        		 string(text(30:35)) +' Run ' + w_numor(wi)
                 x_tit(wi)	='Detector X'   
     	         y_tit(wi)	='Detector Y'
		 setpar_txt, inst_val,wi
		  
		 if (inst_val eq 'in15') then begin
    	           iii=execute('p' +wstr+'= [param(0:3),param(33:37)]')       
    	           iii=execute('pv'+wstr+'=  nppar')       
;**
		 endif else if (inst_val eq 'd19')  then begin
     		   ptmp= [param(0:1),param(6),param(17),param(26),nppar(0,1,0),$
     		   	  param(36),param(37),param(38),param(39),nppar(0,0,0),$
     		   	  nppar(1,0,0)]
    	           iii=execute('p' +wstr+'= ptmp')       
    	           iii=execute('n' +wstr+'=[[nppar(0,0,0:np-1)],[nppar(1,0,0:np-1)]]')       
    	           iii=execute('z' +wstr+'=[ nppar(0,1,0:np-1)]')       
;     	           iii=execute('pv'+wstr+'=[ nppar(1,1,0:np-1)]')       
;** 	
  		 endif else if (inst_val eq 'db21') then begin
     		   ptmp= [param(0:1),param(6),param(17),param(26),nppar(0,1,0),$
     		   	  param(36),param(37),param(38),param(39),nppar(0,0,0),$
     		   	  nppar(1,0,0)]
    	           iii=execute('p' +wstr+'= ptmp')       
    	           iii=execute('n' +wstr+'=[[nppar(0,0,0:np-1)],[nppar(1,0,0:np-1)]]')       
    	           iii=execute('z' +wstr+'=[ nppar(0,1,0:np-1)]')
    	         endif       

 		endif else begin
 		   mic,1
		   P_MIC_SETRUN, run,wi,text,param
		endelse
      	      endif
      	    endif else begin catch,/cancel
			     P_MUS,'mus_cannon'
      	    		     status=23 & endelse
      	endif else begin
		bz   ='Current Cycle'
		idx=strpos(lamp_ali,inst_val)
		idx=where (idx ge 0)
		if  idx(0) ge 0 then bz=lamp_ali(idx(0))
		CYCLE=''
		RDSET , BASE=bz
		p_did_getrun, run,wi,status
	endelse
return
end
function rec_tom, data,angles ,DISTANCE=dist ,OUT_SIN=dataf ,TRACE=widg  ,CENTER=cent,$
                               PIXSIZE=pxsz  ,STRIPES =stri ,FILTER=filt ,FILPAR=filp,$
                               DIVERGENCE=divg ,MODCENTER=mcen, AIR=air  ,FILSIZ=filk
;******* *******
;**
sw=SIZE(data) & sa=SIZE(angles) & sz=1 & sx=sw(1) & sy=sw(2) & trc=0 & sxv=sx
wout=0
if (sw(0) lt 2) or (sw(0) gt 3) then begin print,'Data dimensions incorrect !!!'  & return,0 & endif
if (sy ne sa(1))                then begin print,'Angle dimension incorrect !!!'  & return,0 & endif
if (n_elements(widg) eq 6)      then if widg(0)*widg(1)*widg(3)*widg(4) gt 0 then trc=1
if (n_elements(stri) ne 1)      then stri=0
if (n_elements(cent) ne 1)      then cent=0
if (n_elements(filt) ne 1)      then filt=0
if (n_elements(dist) ne 1)      then dist=0
if (n_elements(pxsz) ne 1)      then pxsz=0
if (n_elements(divg) ne 1)      then divg=0
if (n_elements(air)  ne 1)      then air =0
if (n_elements(filp) ne 1)      then filp=1.
if (n_elements(filk) ne 1)      then filk=32
if (sw(0) eq 3)                 then begin sz=sw(3) & wout=fltarr(sx,sy,sz) & endif

Cx   =sx/2 & if Cx*2 eq sx then Cx=Cx-0.5 & kpCX=Cx
if mcen eq 3 then Cx=cent  else cent=Cx
Anglr=angles*!Pi/180.
Rei  =fltarr (sx,sx)
rho  =findgen(sx)

if dist*pxsz*divg ne 0   then begin divb=1
				 np=rho-Cx
				 db=ATAN(np*pxsz/dist/10000.)*180./!Pi
			 endif else divb=0

if mcen eq 1  then begin ling=rho+1
                         grav=fltarr (sy) & weight=fltarr(sy)+1.   & endif
if filt gt 0  then begin
                         filk=filk>3<(sx/3) & half = fix(filk)/2   & zfil=2*half+1 
                         x  = findgen(zfil) - half & filp=filp>0.1 & filter=[1.0]
                         x(half) = .01
                         tmp= fltarr (sx+2*zfil)                   & endif

FOR j=0,sz-1  do  begin
   ;FILTERS
   ;*******
   	dataf=fltarr(sx,sy)
	if sz   gt 1 then dataf(0,0)=data(*,*,j) else dataf(0,0)=data

	;LINEARITY SLICES
	;********* ******
	if air gt 0 then begin
		tat =reform(total(dataf(0:air-1,*),1)+total(dataf(sx-air:sx-1,*),1))/(2.*air)
		avg =tat/(total(tat)/sy)
		FOR i=0,sy-1 DO dataf(0,i)=dataf(*,i)/avg(i)
	endif

	;LINEARITY DETECTOR
	;********* ********
	if air gt 0  then begin
		totL = total(dataf(0:air-1    ,*)) / (sy*air)
		totR = total(dataf(sx-air:sx-1,*)) / (sy*air)
		incr =(totR-totL)/(sx-air)
		airN = totL-incr*(air/2.) + rho*incr + 1
		airF = total(airN)/sx/airN
		FOR i=0,sy-1 do dataf(0,i)=dataf(*,i)*airF
	endif

	;STRIPES
	;*******
	if stri ge 3 then begin
		tot =total(dataf,2)/sy & if !Version.release lt '4.1' then edg='' else edg=',/edge'
		ii  =execute('smo=smooth(tot,stri'+edg+')') & dif=(tot-smo)>0
		for i=0,sy-1 do dataf(0,i)=dataf(*,i)-dif
	endif

	;CENTER
	;******
	if mcen eq 1 then begin
		FOR i=0,sy-1 do begin temp=dataf(*,i)
			grav(i) = total(temp*ling)/total(temp)
		ENDFOR
		mxx=max(grav,min=mii)
		A=[Cx,(mxx-mii)/2.,0.] ;estimate center,amplitude,phase
		fit=curvefit(Anglr, grav, weight, A, sigm, function_name='wavoid')
		Cx = a(0)-1.5 & Cent=Cx
	endif
		kpCX=fix(kpCX-Cx)

	;DIVERGENCE
	;**********
	if divb ne 0 then begin
		for i=0,sx-1 do dataf(i,*)=INTERPOL(reform(dataf(i,*)),angles,angles-db(i))
	endif

	;CONVOLUTION
	;***********
	if filt gt 0 then begin
	   if filt eq 1 then begin a=0.5
		filtrA=-sin(!pi*x/2)^2 / (!pi^2 * x^2 * filp)           ; *** Gen-Hamming ***
		filtrA(half)  = 1./(4.*filp)                            ; *** Gen-Hamming ***
		filtrB=-sin(!pi*(x-1.)/2)^2 / (!pi^2 * (x-1.)^2 * filp) ; *** Gen-Hamming ***
		filtrB(half+1)= 1./(4.*filp)                            ; *** Gen-Hamming ***
		filtrC=-sin(!pi*(x+1.)/2)^2 / (!pi^2 * (x+1.)^2 * filp) ; *** Gen-Hamming ***
		filtrC(half-1)= 1./(4.*filp)                            ; *** Gen-Hamming ***
		filter= a * filtrA + ((1.-a)/2) * (filtrB+filtrC)       ; *** Gen-Hamming ***
	   endif
	   if filt eq 2 then begin
		d = !pi^2 * filp * (1.-4.*x^2)                          ; *** Shepp_Logan ***
		filter=2./d                                             ; *** Shepp_Logan ***
	   endif
	   if filt eq 3 then begin
		filter=-sin(!pi*x/2)^2 / (!pi^2 * x^2 * filp)           ; ***    Ramlak   ***
		filter(half)  = 1./(4.*filp)                            ; ***    Ramlak   ***
	   endif
	   if filt eq 4 then begin
		filtrA=-sin(!pi*(x-.5)/2)^2 / (!pi^2 * (x-.5)^2 * filp) ; ***  lp-cosine  ***
		filtrB=-sin(!pi*(x+.5)/2)^2 / (!pi^2 * (x+.5)^2 * filp) ; ***  lp-cosine  ***
		filter=0.5*(filtrA+filtrB)                              ; ***  lp-cosine  ***
	   endif
	   FOR i=0, sy-1 do begin
		tmp(0 :zfil-1) = dataf(0,i)
		tmp   (zfil)   = dataf(*,i)
		tmp(sx+zfil-1 :sx+2*zfil-1) = dataf(sx-1,i)
		tmp = convol(tmp,filter)
		dataf(0,i) = tmp(zfil : zfil+sx-1)
	   ENDFOR
	endif

   ;SHOW SINOGRAM
   ;**** ********
	if trc then begin Vei=dataf
			if air gt 0 then begin mxx=max(Vei,min=mii) & mxi=mii+(mxx-mii)/3.
				Vei(0:air-1    ,*)=Vei(0:air-1    ,*) + mxi
				Vei(sx-air:sx-1,*)=Vei(sx-air:sx-1,*) + mxi & endif
			wset,widg(0) & tvscl,congrid(Vei,widg(3),widg(4)) & endif

   ;RECONSTRUCTION
   ;**************
	if sys_dep('VERSION') ge 5.4 then begin rho=rho-cx
	     ii=execute('Rei=RADON (transpose(dataf),theta=anglr,/BACKPROJECT,nx=sx,ny=sx,/LINEAR,rho=rho)')
	endif else $
	if sys_dep('VERSION') lt 4.0 then begin if kpCX ne 0 then dataf=shift(dataf,kpCX)
	   for i=0,sy-1 do RIEMANN, dataf, Rei, anglr(i), /BACKPROJECT, ROW=i, /BILINEAR
	endif else $
	   for i=0,sy-1 do RIEMANN, dataf, Rei, anglr(i), /BACKPROJECT, ROW=i, /BILINEAR, CENTER=Cx

   ;AFTER FILTER
   ;**** *******
	if filt gt 0 then begin
	endif
	if sz gt 1  then  wout(0,0,j)=Rei else wout=Rei

   ;SHOW RESULT
   ;**** ******
	if trc then begin wset,widg(1) & tvscl,congrid(Rei ,widg(3),widg(3))
			if (sz eq 1) and (widg(5) gt 0) then jj=widg(5) else jj=j
			widget_control,widg(2),bad_id=ii,set_value=jj & endif
ENDFOR
return,wout
end

pro wavoid, xx, a, fy, pder
;** ******
;** by Mark Rivers.(Chicago)
;** a(0) = rotation center  ; a(1) = amplitude  ; a(2) = phase
	fy = a(0) + a(1)*sin(xx + a(2))
	pder = fltarr(n_elements(xx), n_elements(a))
	pder(*,0) = 1.
	pder(*,1) = sin(xx + a(2))
	pder(*,2) = a(1)*cos(xx + a(2))
end

function strst,st & return,strtrim(string(st),2) & end
;******* *****

function Wuval,uv1, FIX=fix
;******* *****
val=0.
	widget_control,bad_id=ii, uv1, get_value = sval
	on_ioerror,misval & val=float(sval(0))   & misval:
	if keyword_set(fix) then  val=fix(val)
	widget_control,bad_id=ii, uv1, set_value = strst(val)
return, val
end

pro tomo_event_parser, ev,uv
;** *****************
;**
@lamp.cbk
common cw_tomo, b_tom, b_sinr, b_slir, b_sinf, b_rcon, b_slic, b_siz , b_all ,$
                w_idx, w_ang,  w_numr, w_numf, w_numc, w_sinr, w_sinf, w_rcon, w_all, $
                f_dis, f_psiz, f_cent, f_stri, f_filt, f_filp, f_air , f_linr, f_trans, $
                f_div, f_stp , f_logc, f_filk, f_fils

case uv(2) of
1:	begin	kp_w=!D.window & wset ,b_rcon & erase
		if uv(4) ge 0 then begin
		  widget_control,uv(3),get_value=wnum  & wnum=wnum(0)        ;Load Sinogram
		  i =strpos (wnum,'W') & w_numr=strtrim(strmid(wnum,i+1,4),2);*************
		  ii=execute('w_sinr=float(w'+w_numr+')') & sw=SIZE(w_sinr)
		  ii=execute('w_ang =float(y'+w_numr+')') & sy=SIZE(w_ang)
		endif else begin
		  n =101L & m =101L & nv=101 & k =ceil(sqrt(n^2+m^2))        ;Load a square test
		  w_rcon = FLTARR(N, M) & w_rcon(N/2:N/2+25,M/2:M/2+25)= 10. ;******************
		  w_rcon(N/2-15:N/2-10, M/2-15:M/2-10)=11.
		  w_sinr = FLTARR(K, nv)       & sw=SIZE(w_sinr)
		  w_ang  = findgen(nv)*180/nv  & sy=SIZE(w_ang)
		  r_rand = randomu(s,nv) +0.5
		  r_linr = findgen(k)/(k-1) +0.5
		  
		  if sys_dep('VERSION') ge 5.4 then begin    w_ang=w_ang*!Pi/180.
	             ii=execute('w_sinr=RADON (w_rcon, nrho=K, theta=w_ang, /LINEAR)')
		         w_sinr=transpose(w_sinr)   &        w_ang=w_ang/!Pi*180.
		  endif else $
		  FOR I=0, nv-1   DO  RIEMANN, w_sinr, w_rcon, w_ang(i)*!Pi/180., ROW=i

		  w_sinr=shift(w_sinr,5,0) +1.
		  FOR I=0, k-1,10 DO w_sinr(i,*)  =w_sinr(i,*)+50.
		  FOR I=0, nv-1   DO w_sinr(0,i)  =w_sinr(*,i)*r_linr
		  FOR I=0, nv-1   DO w_sinr(0,i)  =w_sinr(*,i)*r_rand(i)
		  tvscl,congrid(w_rcon,b_siz(0),b_siz(0))
		endelse
		if (sw(0) lt 2) or (sw(0) gt 3) then begin w_sinr=dist(32) & sw=SIZE(w_sinr) & endif
		if (sw(2) ne sy(1)) then w_ang=findgen(sw(2))/(sw(2)-1)*180.
		if (sw(0) eq 3)     then begin w_idx=w_idx<(sw(3)-1)
				widget_control,bad_id=ii,b_slir,set_slider_max=sw(3)-1
				widget_control,bad_id=ii,b_slic,set_slider_max=sw(3)-1
				widget_control,bad_id=ii,b_slir,set_value=w_idx,sensitive=1
				widget_control,bad_id=ii,b_slic,set_value=w_idx,sensitive=1
				widget_control,bad_id=ii,b_all ,                sensitive=1
				w_sinf=w_sinr(*,*,w_idx) & w_rcon=fltarr(sw(1),sw(2),sw(3))
		endif	else	begin  w_idx=0
				widget_control,bad_id=ii,b_slir,sensitive=0
				widget_control,bad_id=ii,b_slic,sensitive=0
				widget_control,bad_id=ii,b_all ,sensitive=0
				w_sinf=w_sinr            & if uv(4) ge 0 then w_rcon=fltarr(sw(1),sw(2))
				endelse
		wset ,b_sinr
		tvscl,congrid(w_sinr(*,*,w_idx),b_siz(0),b_siz(1))
		if kp_w gt 0 then wset ,kp_w
	end
2:	begin
		widget_control,uv(3),get_value=wnum  & wnum=wnum(0)      ;Write Reconstruction
		i=strpos(wnum,'W') & w_numc=strtrim(strmid(wnum,i+1,4),2);********************
		XICUTER,'w'+w_numc+'=get_tom(w'+w_numr+',/back_pro)'
	end
3:	begin
		widget_control,uv(3),get_value=wnum  & wnum=wnum(0)      ;Write Filtered Signal
		i=strpos(wnum,'W') & w_numf=strtrim(strmid(wnum,i+1,4),2);*********************
		XICUTER,'w'+w_numf+'=get_tom(w'+w_numr+',/out_sin)'
	end
4:	begin	f_dis = Wuval(uv(3))                                     ;Do the work ......
		                                                         ;******************
		f_psiz= Wuval(uv(4))

		f_stp = Wuval(uv(5),/fix) & if f_stri then f_ker=f_stp else f_ker=0

		r_cent= Wuval(uv(6))

		f_air = Wuval(uv(7),/fix) & if f_linr then f_are=f_air else f_are=0

		f_filk= Wuval(uv(8),/fix)

		f_filp= Wuval(uv(9))

		kp_w=!D.window    & trace=[b_sinf,b_rcon,b_slic,b_siz,w_idx]

		if ((SIZE(w_sinr))(0) eq 3) and (not w_all) $
		 then w_rcon(w_idx)=REC_TOM(w_sinr(*,*,w_idx),w_ang, DIV=f_div, TRACE=trace, OUT=w_sinf,$
		                      CENTER =r_cent, STRIP=f_ker, FILTER=f_filt, FILPAR=f_filp,FILSIZ=f_filk ,$
					    PIXSIZE=f_psiz, DISTANCE=f_dis, MODCENTER=f_cent, AIR=f_are)      $
		 else w_rcon       =REC_TOM(w_sinr           ,w_ang, DIV=f_div, TRACE=trace, OUT=w_sinf,$
		                      CENTER =r_cent, STRIP=f_ker, FILTER=f_filt, FILPAR=f_filp,FILSIZ=f_filk ,$
					    PIXSIZE=f_psiz, DISTANCE=f_dis, MODCENTER=f_cent, AIR=f_are)
					    
		widget_control,uv(6),set_value=strst(r_cent)
		if kp_w gt 0 then wset ,kp_w
	end
5:	begin w_sinr=0 & w_sinf=0 & w_rcon=0 & widget_control,ev.top,/destroy
	end
6:	begin w_all=ev.select                                          ;for all
	end                                                            ;*******
7:	begin widget_control,b_slir,get_value=w_idx                    ;sinogram index
		kp_w=!D.window  & wset ,b_sinr                         ;**************
		tvscl,congrid(w_sinr(*,*,w_idx),b_siz(0),b_siz(1))
		if kp_w gt 0 then wset ,kp_w
	end
8:	begin widget_control,b_slic,get_value=rc_idx                   ;reconstruction index
		kp_w=!D.window  & wset ,b_rcon                         ;********************
		tvscl,congrid(w_rcon(*,*,rc_idx),b_siz(0),b_siz(0))
		if kp_w gt 0 then wset ,kp_w
	end
9:	begin f_cent=uv(3)                                             ;for center
	end                                                            ;**********
10:	begin f_stri=ev.select                                         ;for stripes
	end                                                            ;***********
11:	begin f_filt=uv(3)                                             ;for filter
	      widget_control,ev.id,get_value=sval                      ;**********
	      widget_control,uv(4),set_value=sval
	end
12:	begin f_div =ev.select                                         ;for divergence
	end                                                            ;**************
13:	begin f_linr=ev.select                                         ;for linearity
	      widget_control,uv(3),sensitive=f_linr                    ;*************
	end
14:	begin f_log =ev.select                                         ;for log convertion
	end                                                            ;******************
else:
endcase
end

function get_tom, W,  out_sin=out_sin  ,back_pro=back_pro
;******* *******
;**
@lamp.cbk
common cw_tomo
	s=SIZE(W)
	if keyword_set(back_pro) then begin id=fix(w_numc)
		other_tit(id)='BACK PROJECTION'
		  x_tit(id)  ='X direction (angle '+string(w_ang(0))
		  y_tit(id)  ='Y'
		ii=execute('x'+w_numc+'=indgen(s(1))+1')
		ii=execute('y'+w_numc+'=indgen(s(2))+1')
		return,w_rcon
	endif else begin                    id=fix(w_numf)
		other_tit(id)='FILTERED SINOGRAM'
		ii=execute('x'+w_numf+'=indgen(s(1))+1')
		ii=execute('y'+w_numf+'=w_ang')
		return,w_sinf
	endelse
end

pro tomography, NW=nw
;** **********
;**
@lamp.cbk
common cw_tomo

if keyword_set(nw) then return

i=xregistered('Tomogra')
if i le 0 then begin

 if n_elements(b_tom) eq 0 then begin             ;** SET FIXED PARAMETERS
	w_idx =0  & w_rcon=0 & w_numr='1'  & w_numf='3' & w_numc='2' & b_siz=[256,360]
	w_sinr=dist(32) &  w_sinf=w_sinr  & w_rcon=findgen(32,32)   & w_ang=findgen(32)/31*180.
	w_all =0  & f_dis=720. & f_cent=0 & f_stri=0 & f_filt=0 & f_filp=1. & f_air=12 & f_linr=0
	f_trans=0 & f_psiz=360 & f_div =0 & f_stp=9  & f_logc=0 & f_filk=40
	f_fils=[" no-filter ","Gen-Hamming","Shepp-Logan","Ramlak","LP_Cosine"]
 endif
 if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0
 b_tom =widget_base  (title='Tomography... V1.02',/row,group_leader=lamp_b1,resource_name="lamp")
 bas1  =widget_base  (b_tom ,/column)
 bas2  =widget_base  (b_tom ,/column)
 bas3  =widget_base  (b_tom ,/column)
 basx  =[bas1,bas2,bas3]
 labx  =["Sinogram","Re-construct","Filtered Signal",$
         "load W "+w_numr,"write W "+w_numc,"write W "+w_numf]
 For j =0,2 do begin
	b_r0  =widget_base (basx(j),/row)
	lab  =Widget_label (b_r0   ,font=ft_b_normal,value=labx(j))
	b_r0l=widget_button(b_r0   ,font=ft_smaller ,value='<-')
	b_r0m=widget_button(b_r0   ,font=ft_propor  ,value=labx(j+3))
	b_r0r=widget_button(b_r0   ,font=ft_smaller,value='->')
	widget_control,b_r0l,set_uvalue=[-88,310    ,b_r0m,1]
	widget_control,b_r0m,set_uvalue=[-88,359,j+1,b_r0m,0]
	widget_control,b_r0r,set_uvalue=[-88,311    ,b_r0m,1]
 ENDFOR
 b_sinr=widget_draw  (bas1  ,xsize=b_siz(0) ,ysize=b_siz(1))
 b_slir=widget_slider(bas1  ,xsize=b_siz(0) ,Font=ft_b_normal,title=''  ,uvalue=[-88,359,7])
 bid   =widget_label (bas1  ,value='Input has a background subtracted'      ,Font=ft_b_normal)
 bid   =widget_label (bas1  ,value='and is calibrated by the white signal.' ,Font=ft_b_normal)
  bido  =widget_base (bas1  ,/row)
  bid   =widget_label(bido  ,value='Source -> Detector (Cm)'           ,Font=ft_b_normal)
  b_dis =widget_text (bido  ,value=strst(f_dis) ,xsize=6+cap,/editable ,Font=ft_propor)
  bido  =widget_base (bas1  ,/row)
  bid   =widget_label(bido  ,value='Detect. pixel size (Micron)'       ,Font=ft_b_normal)
  b_psz =widget_text (bido  ,value=strst(f_psiz),xsize=6+cap,/editable ,Font=ft_propor)

  b_11 =widget_base  (bas1  ,/row) & put_logo,b_11
  bid  =widget_button(b_11  ,value='Test',Font=ft_b_normal,uvalue=[-88,359,1,0L,-1])
  bid  =widget_button(b_11  ,value='Done',Font=ft_b_normal,uvalue=[-88,359,5])

 b_rcon=widget_draw  (bas2  ,xsize=b_siz(0) ,ysize=b_siz(0))
 b_slic=widget_slider(bas2  ,xsize=b_siz(0) ,Font=ft_b_normal,title=''  ,uvalue=[-88,359,8])
 bas22 =widget_base  (bas2  ,/column,frame=2)
  lab  =widget_label (bas22 ,value='... Filters ...' ,Font=ft_b_bigger)
  b_21 =widget_base  (bas22 ,/row)
  b_2b =widget_button(widget_base(b_21,/nonexclusive),value="linearity using air values->",Font=ft_b_normal,uvalue=[-88,359,13])
  b_air=widget_text  (b_21  ,value=strst(f_air),xsize=2+cap ,Font=ft_propor,/editable)
  widget_control,b_2b,set_button=f_linr ,set_uvalue=[-88,359,13,b_air]
  if not f_linr then widget_control,b_air,sensitive=0

  b_22 =widget_base  (bas22 ,/row,/nonexclusive)
   but0=widget_button(b_22  ,value='Intensities -log(transmit$/air)',Font=ft_b_normal,uvalue=[-88,359,14])
   widget_control,b_22,set_button=f_logc,sensitive=0
 
  b_23 =widget_base  (bas22 ,/row)
  b_231=widget_base  (b_23 ,/nonexclusive)
   but1=widget_button(b_231 ,value='remove Stripes. Kern='   ,Font=ft_b_normal  ,uvalue=[-88,359,10])
  b_stp=widget_text  (b_23  ,value=strst(f_stp),xsize=3+cap,Font=ft_propor,/editable)

  b_23 =widget_base  (bas22 ,/row)
   bid =widget_label (b_23  ,value='Cx'         ,Font=ft_b_normal)
  b_231=widget_base  (b_23  ,/row,/exclusive)
   bct1=widget_button(b_231 ,value='find'       ,Font=ft_b_normal  ,uvalue=[-88,359,9,1])
   bct2=widget_button(b_231 ,value='mid'        ,Font=ft_b_normal  ,uvalue=[-88,359,9,2])
   bct3=widget_button(b_231 ,value='set'        ,Font=ft_b_normal  ,uvalue=[-88,359,9,3])
  b_cen=widget_text  (b_23  ,value=' 0 ',xsize=4+cap,Font=ft_propor,/editable)
   if f_cent eq 1 then widget_control,bct1 ,set_button=1 else $
   if f_cent eq 3 then widget_control,bct3 ,set_button=1      $
                  else widget_control,bct2 ,set_button=1
 
  b_24 =widget_base  (bas22 ,/row,/nonexclusive)
  b_div=widget_button(b_24  ,value='divergent Beam'   ,Font=ft_b_normal  ,uvalue=[-88,359,12])

  b_25 =widget_base  (bas22 ,/row)
  b_25m=widget_button(b_25  ,value=f_fils(f_filt) ,Font=ft_b_normal  ,menu=2)
   FOR i=0,n_elements(f_fils)-1 do $
   bid =widget_button(b_25m ,value=f_fils(i)      ,Font=ft_b_normal  ,uvalue=[-88,359,11,i,b_25m])
   bid =widget_label (b_25  ,value='Kern:'        ,Font=ft_b_normal)
  b_fik=widget_text  (b_25  ,value=strst(f_filk)  ,Font=ft_propor,xsize=2+cap,/editable)
   bid =widget_label (b_25  ,value='Step:'       ,Font=ft_b_normal)
  b_fip=widget_text  (b_25  ,value=strst(f_filp)  ,Font=ft_propor,xsize=3+cap,/editable)

 b_sinf=widget_draw  (bas3  ,xsize=b_siz(0),ysize=b_siz(1))
 bas32 =widget_base  (bas3  ,/row)
 bid   =widget_button(bas32 ,value='... Proceed ...',Font=ft_b_normal,$
                            uvalue=[-88,359,4,b_dis,b_psz,b_stp,b_cen,b_air,b_fik,b_fip])
 b_all =widget_button(widget_base(bas32,/nonexclusive),value='for all'  ,Font=ft_b_normal,uvalue=[-88,359,6])

 widget_control,b_slir,sensitive=0 
 widget_control,b_slic,sensitive=0 
 widget_control,b_all ,sensitive=0 , set_button=w_all
 widget_control,but0 ,set_button=f_trans
 widget_control,but1 ,set_button=f_stri
 widget_control,b_div,set_button=f_div
 widget_control,b_tom ,/realize    & put_logo
 widget_control,b_sinr,get_value=j & b_sinr=j
 widget_control,b_sinf,get_value=j & b_sinf=j
 widget_control,b_rcon,get_value=j & b_rcon=j

Xmanager,'Tomogra',b_tom,event_handler='LAMP_EVENT_PARSER',/just_reg

endif else widget_control,bad_id=i,b_tom,map=1
end
pro write_inx, o_file,w_buf ,XC=x_buf, YC=y_buf, PR=pmt_buf, E=e_buf ,$
                             ZC=z_buf,  N=n_buf, PV=pv,PAR_TXT=p_txt ,$
                             W_tit=wt  , X_tit=xt , Y_TIT=yt         ,$
                             Z_tit=zt  , OTHER_TIT=ot
;** *********
;**
; Dumps an INX file - parameters may be a bit odd

pi=!pi

if n_elements(pmt_buf) lt 22 then pmt_buf=fltarr(22)+1

; Prepare zones
   nzone=intarr(7)
   nzone(1)=1
   nzone(2)=2
   nzone(3:6)=0

   my_check=size(w_buf)

;
; What dimensions for the data?
      case my_check(0) of
         0: return
         1: begin
               nchans=my_check(1)
               nspecs=1
            end
         2: begin
               nchans=my_check(1)
               nspecs=my_check(2)
            end
	 else: return
      endcase
   
   if n_elements(w_buf) ne n_elements(e_buf) then e_buf=w_buf*0.
   if (size(y_buf))(0) eq 2 then y_buf=reform(y_buf(0,*))
   sx=(size(x_buf))(0)
   
; Get the parameters
      temp	=pmt_buf(11) 
      einc	=81.799/pmt_buf(21)/pmt_buf(21) 
      qinc	=2*pi/pmt_buf(21) 
      amass	=1.0
      nlines	=nchans+3
      deltatau	=pmt_buf(18)
      deltaen	=0.0
      deltak	=0.0
      isym	=0
      dumme	=0.0

      on_ioerror,pb_wrt  
      get_lun,ifile
      openw,ifile,o_file
				frmv='(5x,f10.5,e13.5,e12.4)'
       if max(y_buf) ge 10 then frmt='(x,f6.2,f8.3,f8.4,f9.3,f6.1,i2)' $
			   else frmt='(x,f6.4,f8.3,f8.4,f9.3,f6.1,i2)'
       for i=0,nspecs-1 do begin
	 printf ,ifile,nlines,nzone(1:6),nchans          ,format='(8i5)'
	 printf ,ifile,wt
	 printf ,ifile,y_buf(i),einc,qinc,temp,amass,isym,format=frmt
	 printf ,ifile,deltaen,deltatau,deltak           ,format='(16x,3f8.4)'
	 if sx eq 1 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j)  ,w_buf(j,i),e_buf(j,i)  ,format=frmv

	 if sx eq 2 then for j=0,nchans-1 do $
	  printf,ifile,x_buf(j,i),w_buf(j,i),e_buf(j,i)  ,format=frmv

       endfor
       pb_wrt:free_lun,ifile
    return
    end	    
      
function Unroll, w
;******* ******
;**
@lamp.cbk
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah
common destop , wit
common dexxl  , xxl1,xxl2

	wi=fix(b_ww) & wj=fix(b_wl) & s=size(b_arel)
	sd=(s(1)-1.)/2.

	if squar ne 0 then  begin ii=execute('x'+b_ww+'=(findgen(s(1))-sd)/sd * 3.1416')
			    ii=execute('x'+b_ww+'=x'+b_ww+'(xxl1:xxl2)')
	endif    else       ii=execute('x'+b_ww+'=(findgen(s(1))-sd)/sd * 3.1416*rr2')
	ii=execute('y'+b_ww+'= indgen (s(2))+rr1>1')
	if squar ne 0 then x_tit(wi)   ='UNROLLED RINGS. X axis: -Pi<--->Pi  ('+x_tit(wj)+')'  $
		      else x_tit(wi)   ='UNROLLED RINGS. X axis: -Pi*R<--->Pi*R  ('+x_tit(wj)+')'
	y_tit(wi)   ='RADIUS in pixels'
	
if squar ne 0 then return,b_arel(xxl1:xxl2,*) else return,b_arel
end

function Diagram, w
;******* *******
;**
@lamp.cbk
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah

        wi=fix(b_ww) & wj=fix(b_wl) & s=size(b_arel)
	ii=execute('x'+b_ww+'=b_xdia')
	x_tit(wi)   ='DIAGRAM 2*Theta ('+x_tit(wj)+')'
	y_tit(wi)   ='MEAN VALUES'
return,b_diam
end

pro wdiag_event, event,uv
;** ***********
;**
@lamp.cbk
common c_trap,	trap_x1,trap_x2,trap_y1,trap_y2,trap_ws, trap_current
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah

if (uv(2) eq 1) or $
  ((b_chg ne b_on3) and ((uv(2) eq 3) or (uv(2) eq 4) or (uv(2) eq 5))) then begin
    b_chg =  b_on3
        if uv(2) eq 1 then begin
           widget_control,uv(3),get_value=wnum  & wnum=wnum(0)      ;Load
           i =strpos(wnum,'W') & b_wl=strtrim(strmid(wnum,i+1,4),2)
           wsdiag & endif
        s =0 & ii=execute('s=size(w'+b_wl+')')
        if s(0) eq 2 then begin
           sw=b_z(0) & pi=1. & pj=1.
           if PIXH lt PIXV then pi=PIXH/PIXV else pj=PIXV/PIXH
           b_p  =[1+ ((PIXV/PIXH)-1)/2. , 1+ ((PIXH/PIXV)-1)/2.]

           b_f1 =float(sw)/(s(1)) & b_f2=float(sw)/(s(2))
           if b_f1 lt b_f2 then b_f2=b_f1 else b_f1=b_f2
           b_f1=b_f1*pi  & b_f2=b_f2*pj
           si=round(s(1)*b_f1) & sj=round(s(2)*b_f2)
           ii=execute ('b_area=congrid(w'+b_wl+',si,sj)')
           if b_on3 then b_area=alog((temporary(b_area)>0)+1)
           b_area=bytscl(temporary(b_area))
        endif
    if uv(2) eq 1 then begin b_new=1 & uv(2)=3
    endif else if (size(b_arel))(0) eq 2 then begin
           b_areu=congrid( b_arel,b_z(0),b_z(0))
           if b_on3 then b_areu=alog((temporary(b_areu)>0)+1)
           b_areu=bytscl(temporary(b_areu))
    endif
endif

if uv(2) eq 11 then if (event.type eq 0) and (b_show eq 1) then begin;Mouse for Center & Ray
   if event.press eq 1 then begin                                    ;Center
	cti=event.X / b_f1  + 0.5
	ctj=event.Y / b_f2  + 0.5
	if (cti gt long(cti)+ 0.25) and (cti lt long(cti)+ 0.75) then cti=long(cti)+0.5 else cti=round(cti)
	if (ctj gt long(ctj)+ 0.25) and (ctj lt long(ctj)+ 0.75) then ctj=long(ctj)+0.5 else ctj=round(ctj)
	widget_control,b_t(0),set_value=strtrim(string(cti),2)
	widget_control,b_t(1),set_value=strtrim(string(ctj),2)
   endif else begin                                                  ;Ray
	nn1=event.X / (b_f1+b_f2) *2.
	nn2=event.Y / (b_f1+b_f2) *2.
	rr2=round(sqrt((abs(nn1-cti)+1)^2 + (abs(nn2-ctj)+1)^2))
	widget_control,b_t(6),set_value=strtrim(string(rr2),2)
   endelse
   uv(2)=3 & b_new=1
endif

case uv(2) of
2: begin widget_control,event.id,get_value=wnum  & wnum=wnum(0)      ;Write
        i =strpos(wnum,'W') & b_ww=strtrim(strmid(wnum,i+1,4),2)
        if b_show eq 2 then XICUTER,'w'+b_ww+'=Unroll (w'+b_wl+')'
        if b_show eq 3 then XICUTER,'w'+b_ww+'=Diagram(w'+b_wl+')'
   end
3: begin wsdiag  & wset,b_win(2) & erase,255 & tvscl,b_area & b_show=1 ;input Data
        sw=b_z(0) & sh=b_z(1) & sw1=sw-1
        ctx=cti-0.5 & cty=ctj-0.5
        ccx=ctx*b_f1 & ccy=cty*b_f2 & nn1=rr1*(b_f1+b_f2)/2 & nn2=rr2*(b_f1+b_f2)/2

        tx1=round([ccx-nn2,ccx+nn2])>0<sw1 & ty1=round([ccy,ccy])>0<sw1
        tx2=round([ccx,ccx])>0<sw1         & ty2=round([ccy-nn2,ccy+nn2])>0<sw1
        tx3=round([ccx-nn1,ccx+nn1])>0<sw1 & ty3=round([ccy,ccy])>0<sw1
        tx4=round([ccx,ccx])>0<sw1         & ty4=round([ccy-nn1,ccy+nn1])>0<sw1
        plots,tx2,ty2,/device,color=255   & plots,tx1,ty1,/device,color=255
        plots,tx3,ty3,/device,color=0     & plots,tx4,ty4,/device,color=0

        plots,tx1,ty1-1,/device,color=0   & plots,tx1,ty1+1,/device,color=0
        plots,tx2-1,ty2,/device,color=0   & plots,tx2+1,ty2,/device,color=0
        plots,tx3,ty3-1,/device,color=255 & plots,tx3,ty3+1,/device,color=255
        plots,tx4-1,ty4,/device,color=255 & plots,tx4+1,ty4,/device,color=255

	nn2 = nn2-1 & n = round(nn2 * 100./256.)>20
	ceri=(findgen(n)-(n-1)/2.) / ((n-1)/2.) * !pi
	cery=(sin(ceri)*nn2 + ccy) >0<sw1 & cerx=(cos(ceri)*nn2 + ccx) >0<sw1
	plots,cerx,cery,/device,color=0
	nn2 = nn2+1 & n = round(nn2 * 100./256.)>20
	ceri=(findgen(n)-(n-1)/2.) / ((n-1)/2.) * !pi
	cery=(sin(ceri)*nn2 + ccy) >0<sw1 & cerx=(cos(ceri)*nn2 + ccx) >0<sw1
	plots,cerx,cery,/device,color=255

	n = round(nn1 * 100./256.)>20
	ceri=(findgen(n)-(n-1)/2.) / ((n-1)/2.) * !pi
	cery=(sin(ceri)*nn1 + ccy) >0<sw1 & cerx=(cos(ceri)*nn1 + ccx) >0<sw1
	plots,cerx,cery,/device,color=0

	if b_new then begin s=0
	   ii=execute('s =size(w'+b_wl+')')    & td=0    & tr=b_z(1)/10
	   nn2=rr2*b_p(0)
	   si=(cti+nn2-5)>0<(s(1)-1) & sj=(cti+nn2+4)>0<(s(1)-1)
	   ii=execute('td=w'+b_wl+'(si:sj,*)') & wset,b_win(4) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),sd(1)*tr,round(sd(2)*b_f2))
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,0,0
	      tp1=[0,((ctx+nn2-si)>0<(s(1)-1))*tr]
	      plots,tp1,ty1  ,/device,color=255 & plots,tp1,ty1+1,/device,color=0
	      plots,tp1,ty1-1,/device,color=0
	      endif
	   si=(cti-nn2+5)>0<(s(1)-1) & sj=(cti-nn2-4)>0<(s(1)-1)
	   ii=execute('td=w'+b_wl+'(sj:si,*)') & wset,b_win(0) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),sd(1)*tr,round(sd(2)*b_f2))
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,b_z(1)-sd(1)*tr,0
	      tp1=[-((si-ctx+nn2)>0<(s(1)-1))*tr,0]+b_z(1)-1
	      plots,tp1,ty1  ,/device,color=255 & plots,tp1,ty1+1,/device,color=0
	      plots,tp1,ty1-1,/device,color=0
	      endif
	   nn2=rr2*b_p(1)
	   si=(ctj+nn2-5)>0<(s(2)-1) & sj=(ctj+nn2+4)>0<(s(2)-1)
	   ii=execute('td=w'+b_wl+'(*,si:sj)') & wset,b_win(1) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),round(sd(1)*b_f1),sd(2)*tr)
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,0,0
	      tp1=[0,((cty+nn2-si)>0<(s(2)-1))*tr]
	      plots,tx2  ,tp1,/device,color=255 & plots,tx2+1,tp1,/device,color=0
	      plots,tx2-1,tp1,/device,color=0
	      endif
	   si=(ctj-nn2+5)>0<(s(2)-1) & sj=(ctj-nn2-4)>0<(s(2)-1)
	   ii=execute('td=w'+b_wl+'(*,sj:si)') & wset,b_win(3) & erase,255
	   td=reform(td) & sd=size(td) & if sd(0) eq 2 then begin
	      td=congrid(temporary(td),round(sd(1)*b_f1),sd(2)*tr)
	      if b_on3 then td=alog((temporary(td)>0)+1)
	      td=bytscl(temporary(td)) & tvscl,td,0,b_z(1)-sd(2)*tr
	      tp1=[0,-((si-cty+nn2)>0<(s(2)-1))*tr]+b_z(1)-1
	      plots,tx2  ,tp1,/device,color=255 & plots,tx2+1,tp1,/device,color=0
	      plots,tx2-1,tp1,/device,color=0
	      endif
	endif
   end
4: begin wsdiag  & if b_new then begin tAV=AV & tAH=AH & ii=execute( $
       'depli, w'+b_wl+',rr1,rr2, b_arel,b_diam,b_xdia,b_red,tAV,tAH')       ;diagram
                  endif
        b_new=0 & wset,b_win(2) & b_show=3
        titx ='DIAGRAM 2*Theta'
        if b_on3 then tity ='MEAN (Log)' else tity='MEAN'
        trap_current=!D.window
        if b_on3 then $
           plot,b_xdia,alog(b_diam>.5),xtitle=titx,ytitle=tity,background=255,color=0 else $
           plot,b_xdia,     b_diam    ,xtitle=titx,ytitle=tity,background=255,color=0
   end
5: begin wsdiag  & if b_new then begin tAV=AV & tAH=AH & ii=execute( $
                 'depli, w'+b_wl+',rr1,rr2, b_arel,b_diam,b_xdia,b_red,tAV,tAH')       ;unroll
		  yf=(size(b_arel))(2)
		  if yf le b_z(0)/4 then yf=yf*4   else $
		  if yf le b_z(0)/3 then yf=yf*3   else $
		  if yf le b_z(0)/2 then yf=yf*2 & yf=yf<b_z(0)
                  b_areu=congrid( b_arel,b_z(0),yf)
                  if b_on3  then  b_areu=alog((temporary(b_areu)>0)+1)
                  b_areu=bytscl(temporary(b_areu))
		endif else yf= (size(b_areu))(2)
        b_new=0 & wset,b_win(2) & erase,255 & tvscl,b_areu,0,(b_z(0)-yf)/2 & b_show=2
        if b_win(5) gt 0 then begin
           nic  =n_elements(b_diam)
           mind =min(b_diam)
           b_dia=b_diam(2:nic-3)
           idx  =where(b_dia ne 0)
           if idx(0) ge 0 then b_dia=b_dia(idx) else b_dia=[0]
           mine =total(b_dia)/n_elements(b_dia)

           indi1=((b_diam - shift(b_diam, 2)))
           indi2=((b_diam - shift(b_diam,-2)))
           indil= (indi1<0) * (indi2<0)
           indih= (indi1>0) * (indi2>0)
           indil(0:1)=0 & indil(nic-2:*)=0
           indih(0:1)=0 & indih(nic-2:*)=0

           idx  =where(indil>0)
           if idx(0) ge 0 then indil=b_diam(idx) else indil=mine
           idx  =where(indih>0)
           if idx(0) ge 0 then indih=b_diam(idx) else indih=mine
           indih=(total(indih)/n_elements(indih))
           indil=(total(indil)/n_elements(indil))
           indid=1./((indih-indil)>0.01)
           tit="Value to be minimized: "+strtrim(string(indid),2)
           wset,b_win(5)
           trap_current=!D.window
           plot,b_xdia,b_diam,color=0,xstyle=5,ystyle=5,subtitle="",title=tit,background=255,$
                xmargin=[0,0],ymargin=[0,2],charsize=1.5,charthick=2,font=-1,/nodata
           polyfill,[b_xdia(0),b_xdia,b_xdia(nic-1)],[mind,b_diam,mind],color=100,/data
           oplot,b_xdia,b_diam,color=0
        endif
   end
6: begin b_on1=event.select & widget_control,b_t(21),map=b_on1       ;Distortion
   end
7: begin b_on2=event.select & widget_control,b_t(22),map=b_on2       ;Plate angle
   end
8: begin b_on3=event.select                                          ;Log
   end
9: begin b_arel=0 & b_area=0 & b_areu=0 & b_diam=0 & b_xdia=0        ;destroy
         widget_control,event.top,/destroy
   end
10:begin b_red=event.select & b_new=1                                ;Reduce
   end
12:begin                                                             ;Mouse Stop
   end
13:begin shape=uv(3)        & b_new=1                                ;Shapes
   end
14:begin squar=0 & b_new=1  & end                                    ;Raw
15:begin squar=1 & b_new=1  & end                                    ;Squared (keep total intensity)
16:begin squar=2 & b_new=1  & end                                    ;Square  (keep pixel intensity)

else:
endcase

end

pro wgdiag, idx
;** ******
;**
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar

tmp='0' & widget_control,bad_id=ii,b_t(idx),get_value=tmp & tmp=tmp(0)
flg= 1  & on_ioerror,misflt & val=0. & val=float(tmp) & flg=0 & misflt:
if idx eq 2  then val=val>0.1
if idx ge 3  then val=val>0.
if idx eq 6  then val=val>1.
b_v(idx)=val
b_s(idx)=strtrim(string(b_v(idx)),2)
if flg then widget_control,bad_id=ii,b_t(idx),set_value=b_s(idx)
end

pro wsdiag
;** ******
;**
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common deplo  , rr1,rr2, av,ah

for idx=0,n_elements(b_t)-3 do wgdiag, (idx)

if (not b_new) then  $
if (b_v(0)  ne cti)  or (b_v(1)  ne ctj)  or (b_v(2)  ne DIS)  or (b_v(3)  ne PIXV) or (b_v(4)  ne PIXH) or $
   (b_v(5)  ne rr1)  or (b_v(6)  ne rr2)  or (b_v(7)  ne a1 )  or (b_v(8)  ne a2 )  or (b_v(9)  ne FQ )  or $
                                             (b_v(14) ne PHI)  then b_new=1
if (b_on1)  then     if (b_v(12) ne dxt)  or (b_v(13) ne dyt)  or $
                        (b_v(10) ne FCTX) or (b_v(11) ne FCTY) then b_new=1
if (b_on2)  then     if (b_v(15) ne av )  or (b_v(16) ne ah)   or (b_v(17) ne lhl)  or (b_v(18) ne lhr)  or $
                        (b_v(19) ne lvu)  or (b_v(20) ne lvd)  then b_new=1

	cti =b_v(0)   &  ctj =b_v(1)
	lvu =b_v(19)  &  lvd =b_v(20)
	lhl =b_v(17)  &  lhr =b_v(18)
	PIXH=b_v(3)   &  PIXV=b_v(4)
	FCTX=b_v(10)  &  FCTY=b_v(11) ;** Spacial distortion center %.

	dxt =b_v(12)  &  dyt =b_v(13) ;** Spacial distortion factors.
	a1  =b_v(7)   &  a2  =b_v(8)  ;** Sector to analyse.
	DIS =b_v(2)                   ;** Sample to Detector distance in Cm.
	FQ  =b_v(9)                   ;** Spacial distortion parameters.
	PHI =b_v(14)

	rr1  =b_v(5)  &  rr2  =b_v(6) & av=b_v(15) & ah=b_v(16)

	if (not b_on1) then begin dxt=0 & dyt=0 & endif
	if (dxt eq 0)  and (dyt eq 0) then begin  FCTX=-1. & FCTY=-1.  & endif
	if (not b_on2) then begin lvu=0 & lvd=0 & lhl=0 & lhr=0 & av=0 & ah=0 & endif
end

;pro DECOR, cti_,ctj_,a1_,a2_,DIS_,PIXV_,PIXH_,shap,squa, LVu_,LVd_,LHl_,LHr_,FQ_,PHI_,DXT_,DYT_,FCTX_,FCTY_
;;** *****
;;**
;common depli,cti,ctj, a1,a2, DIS,PIXV,PIXH, shape,squar, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
;
;	cti=cti_ & ctj=ctj_ & a1=a1_   & a2=a2_       & DIS=DIS_   & PIXV=PIXV_ & PIXH=PIXH_
;	LVu=LVu_ & LVd=LVd_ & LHl=LHl_ & LHr=LHr_     & FQ=FQ_     & PHI=PHI_
;	DXT=DXT_ & DYT=DYT_ & FCTX=FCTX_ & FCTY=FCTY_ & shape=shap & squar=squa
;WDIAG, /nw
;end

pro DEPLI,  area, ry1,ry2 ,arel,diam,xdiam,b_red, AV,AH
;** *****
;** INPUT
;** Image plate                 ->	area
;** Radius limits               ->	ry1 ,ry2	(pixels)
;** Known plate angles (else 0) ->	AV,AH		(0  ,0 )

;** OUTPUT
;** Pyramid & diagram & x coord.-> 	arel,diam,xdiam
;** Calculated plate angles     -> 	AV,AH

;** Vertical   decal	LVu ,LVd
;** Horizontal decal	LHl ,LHr
;** Vert. pixel resol.  PIXV
;** Hori. pixel resol.  PIXH
;** Distortion center   FCTX,FCTY
;** Distance sample(cm)	DIS
;** Center		cti ,ctj
;** Sector limits	a1  ,a2
;** Spacial distortion parameters FQ,PHI
;** Spacial distortion factors  DXT,DYT

common depli,cti,ctj,aa1,aa2,DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common destop , wit
common dexxl  , xxl1,xxl2
common rad_tmp, i1,i2,it,j1,j2,jt,nz,r,ta,tt,ra1,ra2,ii1,ii2,ii3,ii4,$
                jj1,jj2,jj3,jj4,ki,kj
;**
;float jt,r,ra1,ra2
;
vsiz =size(area)
if vsiz(0) eq 2 then begin
	cx   =cti
	cy   =ctj
	ci   =float(cti-1)
	cj   =float(ctj-1)

;**	Allocate memory
;**	-------- ------
	r1   =ry1 & if r1 le 0  then r1= 1
	r2   =ry2 & if r2 lt r1 then r2=r1
	pii  =!pi
	dpi  =pii/2
	pf   =round (r2/2000 + 1)
	if n_elements(b_red) eq 1 then pf=pf*(b_red+1)
	if n_elements(AV)    ne 1 then AV=0
	if n_elements(AH)    ne 1 then AH=0
	sx   =long (pii*r2*2/pf)+ 3
	sx1  =sx-1
	sy   =round(r2-r1+1)
	sy1  =sy-1
	arel =fltarr(sx,sy)
	arec =fltarr(sx,sy)
	diam =fltarr(sy)
	xdiam=fltarr(sy)
	
	rad_6	 = 6.2832
	rad_57	 = 57.2956

	a1=aa1 & a2=aa2
	if ((a1 eq 0.)    and (a2 eq 360.)) or $
	   ((a1 eq 1.)    and (a2 eq 360.)) or $
	   ((a1 eq -180.) and (a2 eq 180.)) or $
	    (a1 eq a2)    then ta=0 else ta=1

;**	Calculate limit index
;**	--------- ----- -----
	ra1=a1*pii/180.
	ra2=a2*pii/180.
	csa1=cos(ra1)
	csa2=cos(ra2)
	sna1=sin(ra1)
	sna2=sin(ra2)
;
	ii1=ci+csa1*r1
	ii2=ci+csa1*r2
	ii3=ci+csa2*r1
	ii4=ci+csa2*r2
	same=1-ta & if a1 ge a2 then if (a1/90 eq a2/90) then same=1

	if ((sna1 gt 0) and (sna2 lt 0)) or (same eq 1) then i1 =long (ci-r2) $
					else i1 =long (min([ii1,ii2,ii3,ii4]))
	if ((sna1 lt 0) and (sna2 gt 0)) or (same eq 1) then i2 =round(ci+r2) $
					else i2 =round(max([ii1,ii2,ii3,ii4]))
	if i1 lt 0       then i1=long(0)
	if i2 ge vsiz(1) then i2=vsiz(1)-1
	i1=long(i1)
;
	jj1=cj-sna1*r1
	jj2=cj-sna1*r2
	jj3=cj-sna2*r1
	jj4=cj-sna2*r2
	if ((csa1 gt 0) and (csa2 lt 0)) or (same eq 1) then j1 =long (cj-r2) $
					else j1 =long (min([jj1,jj2,jj3,jj4]))
	if ((csa1 lt 0) and (csa2 gt 0)) or (same eq 1) then j2 =round(cj+r2) $
					else j2 =round(max([jj1,jj2,jj3,jj4]))

	if j1 lt 0       then j1=long(0)
	if j2 ge vsiz(2) then j2=vsiz(2)-1
	j1=long(j1)

;**	Initialise all correctors
;**	---------- --- ----------
	ra1=-0.01+a1
	ra2= 0.01+a2

;	Correctors for pixel resolution
;	********** *** ***** **********
	DPIX= 1+ ((PIXV/PIXH)-1)/2.
	DPIY= 1+ ((PIXH/PIXV)-1)/2.

;	Correctors for scanner spacial distortion
;	********** *** ******* ******* **********
	cpx  =(vsiz(1)-1)*FCTX			& cpy  =(vsiz(2)-1)*FCTY
	if (FCTX eq -1) and (FCTY eq -1) then begin cpx=ci & cpy=cj & endif
	pci  =ci  -cpx				& pcj  =cpy -  cj

	if pcj ne 0 then ang  =atan(pcj,pci) else ang=0.

	nci  =pci* (1+ DXT*cos(FQ* ang +PHI))	& ncj  =pcj* (1+ DYT*cos(FQ* ang +PHI))

	p_u  =cpy -(cj-LVu) 			& p_d  =cpy -((vsiz(2)-1) - (cj+LVd))
	p_l  =cpx -(ci-LHl) 			& p_r  =cpx -((vsiz(1)-1) - (ci+LHr))

	if p_u ne 0 then angu =atan (p_u,pci)	  else angu=0.
	if p_d ne 0 then angd =atan (p_d,pci)	  else angd=0.
	puj  =p_u* (1+ DYT*cos(FQ*angu +PHI))	& pdj  =p_d* (1+ DYT*cos(FQ*angd +PHI))
	if pcj ne 0 then angl =atan (pcj,p_l)     else angl=0.
	if pcj ne 0 then angr =atan (pcj,p_r)     else angr=0.
	pli  =p_l* (1+ DXT*cos(FQ*angl +PHI))	& pri  =p_r* (1+ DXT*cos(FQ*angr +PHI))
	
	IF LVu gt 0 then begin
	LVu  =sqrt ((LVu + p_u - puj)^2 + (pci-nci)^2)
	LVd  =sqrt ((LVd + p_d - pdj)^2 + (pci-nci)^2)
	LHl  =sqrt ((LHl + p_l - pli)^2 + (pcj-ncj)^2)
	LHr  =sqrt ((LHr + p_r - pri)^2 + (pcj-ncj)^2)
	endif else begin
	LVu=1. & LVd=1. & LHl=1. & LHr=1. & endelse

;	Correctors for plate angle
;	********** *** ***** *****
	P=1.        ;& if vsiz(1) gt 2000 then P=2.
	DISV= 10000.*DIS/PIXV/P			& DISH= 10000.*DIS/PIXH/P   & DISM=(DISV+DISH)/2
	if (AV eq 0) and (AH eq 0) then begin
	 DV  = float (LVd-LVu)			& DH  = float (LHr-LHl)
	 AV  = 1.5   & CSAV=0.07 & SNAV=0.99	& AH  = 1.5   & CSAH=0.07 & SNAH=0.99
	 SNAV= (DISV * DV) / (2  * LVu *LVd  )	& SNAH= (DISH * DH) / (2  * LHl *LHr  )
	 if (SNAV le 1)   and (SNAV ge -1) then   AV  = asin(SNAV)
	 if (SNAH le 1)   and (SNAH ge -1) then   AH  = asin(SNAH)
	endif else begin
	     SNAV=sin(av)
	     SNAH=sin(ah)
	endelse

	if (AV   lt 1.5) then CSAV=cos(AV)
	if (AH   lt 1.5) then CSAH=cos(AH)
	DCSV=  DISV * CSAV			& DCSH=  DISH * CSAH
;
;MAIN LOOP: PYRAMID CONSTRUCTION
;*********
	ci2=round(ci*2) & r2b=r2+.5
	ci1=ci-1
	ab =1
	mid=(sx)/2. -1
	ofx=cx-long(cx) & ofy=cy-long(cy)
	pox=cpx-ofx     & poy=cpy+ofy
	j3 =j2+sy1      & if shape eq 1 then j3=j3+sy1

	FOR j =j1,j2 DO BEGIN
	    pj= poy-j

	    for i=i1,i2 do begin
		pi = i-pox

;	        Scanner distortion
;		------- ----------
		if pj ne 0 then ang=atan(pj,pi) else ang=0.
		tcs=cos(FQ*ang+PHI)

		ki =pi * (1+ DXT*tcs) - nci
		kj =pj * (1+ DYT*tcs) - ncj

;	    	Horizontal,Vertical Correction angle
;		------------------- ---------- -----
	    	ki=DCSH * ki / (DISH+ki*SNAH)
		kj=DCSV * kj / (DISV-kj*SNAV)

;		Pixel size correction
;		----- ---- ----------
		ki=ki*DPIX
		kj=kj*DPIY
;		Shape detector correction (not used)
;		----- -------- ----------

;		Intensity  correction (not used)
;		---------  ----------
		r =sqrt(kj^2 + ki^2)
		
		it=round(r)
		if  (it ge r1)  then begin
		 if (it le r2b) then begin
		     if kj ne 0 then ang=atan(kj,ki) else ang=0.
		     if  ta  eq 1 then begin
		         if ang lt 0 then vtm= (rad_6 + ang)*rad_57 else vtm= ang*rad_57
		         if a2 ge a1 then begin
		           if (vtm ge ra1) and (vtm le ra2) then ab=1 else ab=0
		         endif else $
		           if (vtm ge ra1) or  (vtm le ra2) then ab=1 else ab=0
		     endif
		     if ab eq 1 then begin
		       val=area(i,j)
		       if val ge 0 then begin
			cir=abs(r-r1)
			if ang le dpi	then xir=(it*(ang+dpi    )/pf +mid) $
					else xir=(it*(ang-dpi-pii)/pf +mid)   
			xil=long(xir) & xid=(xil+1)<sx1
			cil=long(cir) & cid=(cil+1)<sy1

			fcx=1.-(xir-xil) & fcy=1.-(cir-cil)

			fc =fcx*fcy
			arel(xil,cil)=arel(xil,cil)+val*fc & arec(xil,cil)=arec(xil,cil)+fc
			fc =(1.-fcx)*(1.-fcy)
			arel(xid,cid)=arel(xid,cid)+val*fc & arec(xid,cid)=arec(xid,cid)+fc
			fc =(1.-fcx)*(fcy)
			arel(xid,cil)=arel(xid,cil)+val*fc & arec(xid,cil)=arec(xid,cil)+fc
			fc =(fcx)*(1.-fcy)
			arel(xil,cid)=arel(xil,cid)+val*fc & arec(xil,cid)=arec(xil,cid)+fc
		       endif
		     endif
		 endif  else if i ge ci  then i=i2+ 1 $
		 	else if i eq i1  then begin if kj ne 0 then ang=atan(kj,ki) else ang=0.
						    i=i1+ (long((r2-it)/cos(ang))-1)>0 & endif
		endif   else if i lt ci1 then i=ci2-i-1

	    endfor 
	    if n_elements(wit) ge 1 then $
	    if RDSTOP(j1,j3,(j),win=wit) then begin j=j2+1 & j3=0 & endif
	ENDFOR

;**	DIAGRAM
;**	*******
	arel =temporary(arel)/(arec>.0001)
	diam =reform (total ( (arec)/(arec>.0001),1))

;		         Pi*d       *             theta/360              /   pixelsize(mm)
;		ii= (!pi*DIS*2*10.) * (atan((i+r1)/DISM)*180/!pi) / 360. / ((PIXV+PIXH)/2./1000)
;		ii=      DIS*2*10.  *  atan((i+r1)/DISM)*180      / 360. /  (PIXV+PIXH)*2.*1000
;		ii=      DIS*2      *  atan((i+r1)/DISM)/2. /  (PIXV+PIXH)*2.*10000.
;		ii=      DIS*2      *  atan((i+r1)/DISM)    /  (PIXV+PIXH)   *10000.

	if shape eq 1 then begin
	   arc  =     DIS*2    / (PIXV+PIXH) *10000.
	   nip  =     arc      * (atan(     r1 /DISM)) 
	   ni   =     arc      * (atan((sy1+r1)/DISM)) - nip
	   fdiam= fltarr(sy)
	   endif

	arex=total(arec,2) & idx=where(arex gt 0)
	xxl1=idx(0)>0 & xxl2=idx(n_elements(idx)-1)>0

	sr1=pii*2./pf & sr2 =sr1*r2
	aret=arel(*,0)
	arev=aret
	mi1=long(mid) & mi2=round(mid)

	if j3 gt 0 then $
	for i =sy1 ,0,-1 do begin 
	    if squar ne 0 then  begin sr=sr2/(sr1*(i+r1)) & srd=(sr-1.)/2.
	                        aret=aret*0. & arev=arev*0. & endif
	    j=mi1
	    while (j gt 0) and (arec(j,i) eq 0) do j=j-1
	    while  j gt 0 do begin
	        if arec(j,i) eq 0 then if (arec(j-1,i) ne 0) and (arec(j+1,i) ne 0) $
	                          then begin arel(j,i)=(arel(j-1,i)+arel(j+1,i) )  / 2.
	                                     diam(i)=diam(i)+1
	                          endif
	        if squar ne 0 then begin
			nwi=mid-(mid-j)*sr
			nw1=round(nwi-srd)>xxl1 & nw2=round(nwi+srd)<xxl2
			for k=nw1,nw2 do begin aret(k)=aret(k)+arel(j,i)
			                       arev(k)=arev(k)+sr & endfor
	        endif
	        j=j-1
	    endwhile

	    j=mi2
	    while (j lt sx1) and (arec(j,i) eq 0) do j=j+1
	    while  j lt sx1 do begin
	        if arec(j,i) eq 0 then if (arec(j-1,i) ne 0) and (arec(j+1,i) ne 0) $
	                          then begin arel(j,i)=(arel(j-1,i)+arel(j+1,i) )  / 2.
	                                     diam(i)=diam(i)+1
	                          endif
	        if squar ne 0 then begin
			nwi=mid+(j-mid)*sr
			nw1=round(nwi-srd)>xxl1 & nw2=round(nwi+srd)<xxl2
			for k=nw1,nw2 do begin aret(k)=aret(k)+arel(j,i)
			                       arev(k)=arev(k)+sr & endfor
	        endif
	        j=j+1
	    endwhile

	    if diam(i) gt 0 then  diam(i)=total(arel(*,i))/diam(i)

	    if squar ne 0 then  begin aret=aret/(arev>1) & totl=total(arel(*,i))
	    			if squar eq 2 then aret=aret*sr
	    			arel(*,i)=aret & from=xxl1 & to=xxl2>xxl1
	                        idx=where(aret(from:to) eq 0)
	                        if idx(0) ge 0 then $
	                        for k=n_elements(idx)-1,0,-1 do begin kd=idx(k)+from
				    if kd gt from then ia=aret(kd-1) else ia=0
				    if kd lt to   then ib=aret(kd+1) else ib=0
				    if ia eq 0 then arel(kd,i)=ib else if ib ne 0 then arel(kd,i)=(ia+ib)/2. else arel(kd,i)=ia
	                            ;  print,'trou=',i,kd
	                        endfor
				if squar eq 1 then begin
					tott=total(arel(*,i)) & arel(*,i)=arel(*,i) * (totl/tott) & endif
	    		  endif

	   ;if squar ne 0 then begin idx=where(arev gt sr) & if idx(0) ge 0 then print,'coli=',i,sr,idx & endif

	    theta=atan((i+r1)/DISM)

	    if shape eq 1 then fdiam(i)= arc * theta -nip

;	    if diam(i) gt 0 then  diam(i)=total(arel(*,i))/diam(i)
	    xdiam(i)=theta
	    if n_elements(wit) ge 1 then $
	    if RDSTOP(j1,j3,(j2+sy1-i),win=wit) then begin i=i-sy1 & j3=0 & endif
	endfor

;	Shape detector correction
;	----- -------- ----------
	if j3    gt 0  then $
	if shape eq 1  then begin
	   arec =arec *0.
	   diat =diam *0.
	   xdiat=xdiam*0. & xdiot=xdiat
	   for i=0,sy1 do begin
		i1=long(fdiam(i)) & i2=(i1+1)<sy1 & b1=1.-(fdiam(i)-i1)
		                                    b2=1.-b1
		arec(*,i1)=arel (*,i)*b1 +  arec (*,i1)
		arec(*,i2)=arel (*,i)*b2 +  arec (*,i2)
		diat(  i1)=diam (  i)*b1 +  diat (  i1)
		diat(  i2)=diam (  i)*b2 +  diat (  i2)
		xdiat( i1)=xdiam(  i)*b1 +  xdiat(  i1) & xdiot(i1)=xdiot(i1)+b1
		xdiat( i2)=xdiam(  i)*b2 +  xdiat(  i2) & xdiot(i2)=xdiot(i2)+b2

	       if n_elements(wit) ge 1 then $
	       if RDSTOP(j1,j3,(j2+sy1+i),win=wit) then begin i=i+sy1 & j3=0 & endif
	   endfor
	   ni=long(ni)
	   arel=arec(*,1:ni) & diam=diat(1:ni) & xdiam=xdiat(1:ni)/(xdiot(1:ni)>.0001)
	   arec=0            & diat=0          & xdiat=0   & xdiot=0   & fdiam=0
	endif
;	-------------------------
	xdiam=xdiam*180/pii * 2.
	if pf ne 1 then arel=temporary(arel)*pf
	if squar ne 0 then begin arex=total(arel,2) & idx=where(arex gt 0)
				 xxl1=idx(0)>0 & xxl2=idx(n_elements(idx)-1)>0 & endif
endif
;
return
end

pro wdiag, NW=nw
;** *****
;**
@lamp.cbk
common cw_diag, b_rol, b_win, b_t, b_v, b_s, b_new, b_wl, b_ww, b_arel, b_diam, b_xdia,b_p,$
                b_area,b_areu,b_show  , b_z, b_on1, b_on2,b_on3,b_red , b_chg , b_f1, b_f2
common depli  , cti,ctj, a1,a2, DIS,PIXV,PIXH, LVu,LVd,LHl,LHr, FQ,PHI,DXT,DYT ,FCTX,FCTY, shape,squar
common destop , wit

if keyword_set(nw) then return

i=xregistered('Unroll')
if i le 0 then begin

 if n_elements(b_rol) eq 0 then begin             ;** SET FIXED PARAMETERS
 ;** Position of beam center                   -> centx,centy [first value in the file is at (1,1)]
 ;** For a ring: constated radius at angle  90 -> rVu	[0]
 ;               constated radius at angle -90 -> rVd	[0]
 ;** For a ring: constated radius at angle   0 -> rHr	[0]
 ;               constated radius at angle 180 -> rVl	[0]
 ;** Vertical    pixel resolution (micron)     -> pixsv  [150 or 75]
 ;** Horizontal  pixel resolution (micron)     -> pixsh  [150 or 75]
 ;** Horizontal  distortion center factor      -> tcx    [ .5]
 ;** Vertical    distortion center factor      -> tcy    [ .5]

	b_win  =lonarr(8) & b_t=lonarr(23) & b_v=float(b_t)
	b_v(2) =100       & b_v(3) =150    & b_v(4) =150
	b_v(5) =1         & b_v(6) =10     & b_v(7) =0        & b_v(8) =360
	b_v(9) =4         & b_v(10)=0.5    & b_v(11)=0.5
	b_s    =strtrim(string(b_v),2)
	b_wl   ='1'       & b_ww   ='2'    & b_new  =1        & b_area=[[0,0],[0,0]]
	b_areu =b_area    & b_show = 0     & b_z    =[512,30] & b_on1 =0 & b_on2=0
	b_on3  =0         & b_chg  =b_on3  & b_red  =0        & shape =0 & squar=0
 endif
 
 if sys_dep('MACHINE') eq 'win' then cap=3 else cap=0
 b_rol=widget_base  (title='Unrolling...',/row,group_leader=lamp_b1,resource_name="lamp")
 sw=b_z(0) & sh=b_z(1)
 b_l0 =widget_base  (b_rol,/column)
 b_l  =widget_base  (b_l0 ,/row)
 b_r  =widget_base  (b_rol,/column)
 b_l1 =widget_base  (b_l  ,/column)
     bmp0    =widget_base(b_l1,map=0)
     bmap    =widget_draw(bmp0,xsize=sh,ysize=sh)
     bmap    =widget_base(b_l1)
     b_win(0)=widget_draw(bmap,xsize=sh,ysize=sw)
     bmp1    =widget_base(b_l1,map=0)
     bmap    =widget_draw(bmp1,xsize=sh,ysize=sh)
 b_l2 =widget_base  (b_l  ,/column)
     bmap    =widget_base(b_l2)
     b_win(1)=widget_draw(bmap,xsize=sw,ysize=sh)
     bmap    =widget_base(b_l2)
     b_win(2)=widget_draw(bmap,xsize=sw,ysize=sw,/button_events,uvalue=[-88,378,11])
     bmap    =widget_base(b_l2)
     b_win(3)=widget_draw(bmap,xsize=sw,ysize=sh)
 b_l3 =widget_base  (b_l  ,/column)
     bmp2    =widget_base(b_l3,map=0)
     bmap    =widget_draw(bmp2,xsize=sh,ysize=sh)
     bmap    =widget_base(b_l3)
     b_win(4)=widget_draw(bmap,xsize=sh,ysize=sw)
     bmp3    =widget_base(b_l3,map=0)
     bmap    =widget_draw(bmp3,xsize=sh,ysize=sh)

 if lamp_siz gt 750 then b_win(5) =widget_draw(b_l0,xsize=595,ysize=160,/button_events,uvalue=[-88,378,12]) $
 else begin bil     =widget_base(title="Diagram",group_leader=b_rol)
            b_win(5)=widget_draw(bil,xsize=595,ysize=160,/button_events,uvalue=[-88,378,12])
            widget_control,bil,/realize & endelse

 b_r0 =widget_base  (b_r  ,/row)
	b_r0l=widget_button(b_r0  ,font=ft_smaller ,value='<-')
	b_r0m=widget_button(b_r0  ,font=ft_propor  ,value='load W ' +b_wl)
	b_r0r=widget_button(b_r0  ,font=ft_smaller,value='->')
	widget_control,bad_id=i,b_r0l,set_uvalue=[-88,310  ,b_r0m,1]
	widget_control,bad_id=i,b_r0m,set_uvalue=[-88,378,1,b_r0m  ]
	widget_control,bad_id=i,b_r0r,set_uvalue=[-88,311  ,b_r0m,1]

	b_don=widget_button(b_r0  ,font=ft_b_normal,value="Done"         ,uvalue=[-88,378,9])

	b_r9l=widget_button(b_r0  ,font=ft_smaller ,value='<-')
	b_r9m=widget_button(b_r0  ,font=ft_propor  ,value='write W '+b_ww,uvalue=[-88,378,2])
	b_r9r=widget_button(b_r0  ,font=ft_smaller,value='->')
	widget_control,bad_id=i,b_r9l,set_uvalue=[-88,310,b_r9m,1]
	widget_control,bad_id=i,b_r9r,set_uvalue=[-88,311,b_r9m,1]

 b_r1 =widget_base  (b_r  ,/column,/frame,resource_name="mic")
     blab    =widget_label (widget_base(b_r1,/row),value="CONSTANTS",font=ft_b_normal)
     bid     =widget_base  (b_r1 ,/row)
     blab    =widget_label (bid  ,value="Cx"                    ,font=ft_propor)
     b_t(0)  =widget_text  (bid  ,value=b_s(0),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="Cy"                    ,font=ft_propor)
     b_t(1)  =widget_text  (bid  ,value=b_s(1),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="Center in pixel"       ,font=ft_b_normal)
     bid     =widget_base  (b_r1 ,/row)
     blab    =widget_label (bid  ,value="Sd"                    ,font=ft_propor)
     b_t(2)  =widget_text  (bid  ,value=b_s(2),xsize=7+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Sample to Detector distance in Cm.",font=ft_b_normal)
     bid     =widget_base  (b_r1 ,/row)
     blab    =widget_label (bid  ,value="Px"                    ,font=ft_propor)
     b_t(3)  =widget_text  (bid  ,value=b_s(3),xsize=7+cap,/editable,uvalue=[-88,378,1,b_r0m],font=ft_propor)
     blab    =widget_label (bid  ,value="Py"                    ,font=ft_propor)
     b_t(4)  =widget_text  (bid  ,value=b_s(4),xsize=7+cap,/editable,uvalue=[-88,378,1,b_r0m],font=ft_propor)
     blab    =widget_label (bid  ,value="Pixel size in micron"  ,font=ft_b_normal)

 b_r2 =widget_base  (b_r  ,/column,/frame,resource_name="did")
     blab    =widget_label (widget_base(b_r2,/row),value="REPRESENTATION",font=ft_b_normal)
     bid     =widget_base  (b_r2 ,/row)
     blab    =widget_label (bid  ,value="Ra"                    ,font=ft_propor)
     b_t(5)  =widget_text  (bid  ,value=b_s(5),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="Rb"                    ,font=ft_propor)
     b_t(6)  =widget_text  (bid  ,value=b_s(6),xsize=7+cap,/editable,uvalue=[-88,378,3],font=ft_propor)
     blab    =widget_label (bid  ,value="in,out Radius in pixel",font=ft_b_normal)
     bid     =widget_base  (b_r2 ,/row)
     blab    =widget_label (bid  ,value="Sa"                    ,font=ft_propor)    ;    270
     b_t(7)  =widget_text  (bid  ,value=b_s(7),xsize=7+cap,/editable,font=ft_propor);180     0,360
     blab    =widget_label (bid  ,value="Sb"                    ,font=ft_propor)    ;     90
     b_t(8)  =widget_text  (bid  ,value=b_s(8),xsize=7+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="deg. Sector"           ,font=ft_b_normal)
     widget_control,b_t(7),sensitive =0,set_value='0.'
     widget_control,b_t(8),sensitive =0,set_value='360.'
     bido   =widget_base   (b_r2 ,/row)
     bid     =widget_button(bido ,value="input data"    ,font=ft_b_normal,uvalue=[-88,378,3])
     bid     =widget_button(bido ,value="diagram"       ,font=ft_b_normal,uvalue=[-88,378,4])
     blab    =widget_label (bido ,value="   ",font=ft_b_normal) & put_logo,bido
     lilu    =widget_base  (bido,/nonexclusive,/row)
     bidu    =widget_button(lilu ,value="log"    ,uvalue=[-88,378,8] ,font=ft_b_normal)
     bid     =widget_button(lilu ,value="reduce" ,uvalue=[-88,378,10],font=ft_b_normal)
     bido    =widget_base  (b_r2 ,/row)
     bid     =widget_button(bido ,value="show unrolled rings",font=ft_b_normal,uvalue=[-88,378,5])
     blab    =widget_label (bido ,value="   ",font=ft_b_normal)
     lilu    =widget_base  (bido,/exclusive,/row)
     bid1    =widget_button(lilu ,value="raw"     ,uvalue=[-88,378,14],font=ft_b_normal,/no_release)
     bid2    =widget_button(lilu ,value="dilated" ,uvalue=[-88,378,15],font=ft_b_normal,/no_release)
     bid3    =widget_button(lilu ,value="squared"  ,uvalue=[-88,378,16],font=ft_b_normal,/no_release) & bid123=[bid1,bid2,bid3]
     widget_control,bidu         ,set_button=b_on3
     widget_control,bid123(squar),set_button=1

 b_r3 =widget_base  (b_r  ,/column,/frame,resource_name="don")
     blab    =widget_label (widget_base(b_r3,/row),value="DETECTOR SHAPE",font=ft_b_normal)
     bid     =widget_base  (b_r3  ,/row,/exclusive)
     bidu    =widget_button(bid   ,value="sphere"               ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,0])
     bid1    =widget_button(bid   ,value="plate"                ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,1])
     bida    =widget_button(bid   ,value="y cylinder"           ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,2])
     bidb    =widget_button(bid   ,value="x cyl."               ,font=ft_b_normal,/no_release,uvalue=[-88,378,13,3])
     widget_control,bidu,set_button=1
     widget_control,bida,sensitive =0
     widget_control,bidb,sensitive =0
 b_r4 =widget_base  (b_r  ,/column,/frame)
     bid     =widget_base  (b_r4 ,/row)
     blab    =widget_label (bid  ,value="SCANNER DISTORTION",font=ft_b_normal)
     bid1    =widget_button(widget_base(bid,/nonexclusive),value="on/off",font=ft_b_normal,$
                                                          uvalue=[-88,378,6])
     blab    =widget_button(bid  ,value="!",font=ft_smaller)
     b_r44   =widget_base  (b_r4 ,/column,resource_name="ben")
     bid     =widget_base  (b_r44,/row)
     blab    =widget_label (bid  ,value="Tx"                    ,font=ft_propor)
     b_t(10) =widget_text  (bid  ,value=b_s(10),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Ty"                    ,font=ft_propor)
     b_t(11) =widget_text  (bid  ,value=b_s(11),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Frequ"                 ,font=ft_propor)
     b_t(9)  =widget_text  (bid  ,value=b_s(9) ,xsize=3+cap,/editable,font=ft_propor)
     bid     =widget_base  (b_r44,/row)
     blab    =widget_label (bid  ,value="Fx"                    ,font=ft_propor)
     b_t(12) =widget_text  (bid  ,value=b_s(12),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Fy"                    ,font=ft_propor)
     b_t(13) =widget_text  (bid  ,value=b_s(13),xsize=5+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Phase"                 ,font=ft_propor)
     b_t(14) =widget_text  (bid  ,value=b_s(14),xsize=3+cap,/editable,font=ft_propor)
     widget_control,b_r44,map=0

 b_r5 =widget_base  (b_r  ,/column,/frame)
     bid     =widget_base  (b_r5 ,/row)
     blab    =widget_label (bid  ,value="PLATE DELTA ANGLE",font=ft_b_normal)
     bid1    =widget_button(widget_base(bid,/nonexclusive),value="on/off",font=ft_b_normal,$
                                                          uvalue=[-88,378,7])
     blab    =widget_button(bid  ,value="!",font=ft_smaller)
     b_r55   =widget_base  (b_r5 ,/column,resource_name="ben")
     bid     =widget_base  (b_r55,/row)
     blab    =widget_label (bid  ,value="Av"                    ,font=ft_propor)
     b_t(15) =widget_text  (bid  ,value=b_s(15),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Ah"                    ,font=ft_propor)
     b_t(16) =widget_text  (bid  ,value=b_s(16),xsize=4+cap,/editable,font=ft_propor)
     bid     =widget_base  (b_r55,/row)
     blab    =widget_label (bid  ,value="Lr"                    ,font=ft_propor)
     b_t(17) =widget_text  (bid  ,value=b_s(17),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Rr"                    ,font=ft_propor)
     b_t(18) =widget_text  (bid  ,value=b_s(18),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Ur"                    ,font=ft_propor)
     b_t(19) =widget_text  (bid  ,value=b_s(19),xsize=4+cap,/editable,font=ft_propor)
     blab    =widget_label (bid  ,value="Dr"                    ,font=ft_propor)
     b_t(20) =widget_text  (bid  ,value=b_s(20),xsize=4+cap,/editable,font=ft_propor)
     widget_control,b_r55,map=0
 
 b_t(21)=b_r44 & b_t(22)=b_r55
 widget_control,b_rol,/realize & put_logo
 wsdiag
 b_win(6)=b_win(2)
 b_win(7)=b_win(5)
 for  i=0,4       do   begin widget_control,b_win(i),get_value=j & b_win(i)=j & endfor
 if b_win(5) gt 0 then begin widget_control,b_win(5),get_value=j & b_win(5)=j & endif

 wit=[b_win(7),b_win(5),592,160]

 Xmanager,'Unroll',b_rol,event_handler='LAMP_EVENT_PARSER',/just_reg

endif else widget_control,bad_id=i,b_rol,map=1
end
PRO rdid_d2b, INST,numor,nvers,text,exper,scan,cnt,nd,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                 WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE


common calibration
common calibrotion
common c_rdid

                   print, 'RDID_D2B on pcmrjohnson'

;                      *** data will be (number of detectors, height, number of points) ***
;                      *** WOUT will be 2D (nt*nj,nh), ZZ contains angles               ***
;                      *** for calibration ...                                          ***

;                      *** set physical height of detector (30cm)                       ***
		   h=30.0

		   D2TH = param(36) ;& print, '   D2TH  ', D2TH
		   nj  = ROUND(n_elements(WOUT)/(nd)) ; number of points in scan
		   nt  = 128                          ; number of detector tubes
                   nh  = nd/nt                        ; number of height pixels for 128 detector tubes
;		       *** rewrite WOUT in matrix form (nh, nt, nj) ***
	   	   WOUT= reform(WOUT, nh, nt ,nj ,/overwrite) ;& print, size(WOUT,/dimensions)
                   print, 'first reform'
;		   NN  = WOUT(0,0) ; set monitor
;			*** set titles ***
   	   	   YT  ='height'
		   XT  ='2*Theta'

;		   *** definition of new calibration arrays (default: equal to old)
		   newzon_d2b=zon_d2b ;& print, zon_d2b
		   newcal_d2b=cal_d2b
		   newang_d2b=ang_d2b ;& print, newang_d2b
		   newd=nd

		      print, 'linear interpolation of data'
;		   *** now we have risers and falls for the detector ***
;		   *** interpolate data onto 128 (nh) channels       ***
;		   *** reverse the data in the second tube           ***
		   rise1=intarr(nt/2) & fall1=intarr(nt/2) & rise2=intarr(nt/2) & fall2=intarr(nt/2)
		   rise1(*)=newzon_d2b(0,*) & fall1(*)=newzon_d2b(1,*) & rise2(*)=newzon_d2b(2,*) & fall2(*)=newzon_d2b(3,*)
;		   rise1(*)=0 & fall1(*)=127 & rise2(*)=128 & fall2(*)=255 ; default values - commented!!!
		   FOR j=0,nj-1 DO BEGIN  ; loop thro scan points nj
		      FOR i=0,nt/2-1 DO BEGIN ;
			 WONE2 = [WOUT(*,i*2,j),WOUT(*,i*2+1,j)] ; put pairs of tubes together again
		         WOUT(*,i*2,  j)=CONGRID(WONE2(rise1(i):fall1(i)),nh,/INTERP)
		         WOUT(*,i*2+1,j)=REVERSE(CONGRID(WONE2(rise2(i):fall2(i)),nh,/INTERP))
		      ENDFOR
		   ENDFOR

;		   *** if calibration available, calibrate by MULTIPLYING ***
		   IF n_elements(cal_d2b) eq nh*nt THEN BEGIN             ;if calibration file exists
                     print, 'CALIBRATING'
                     WOUT=float(WOUT)
                     FOR i=0,nj-1 DO WOUT(*,*,i)=WOUT(*,*,i)*newcal_d2b   ;newcal has dimension nh*nt i.e. resolution per pixel
                     fct=1.                                               ;factor set to 1 to preserve angles in ang_d2b
		     OT=OT+' /'+inf_d2b(0) ; set sub-title
;		        *** fct*newang_d2b always newd values spaced by ~ -1.25 ***
		   ENDIF ELSE BEGIN                                       ;calibration does not exist, generate angles
		     if n_elements(newang_d2b) ne nt then newang_d2b=127.0-findgen(nt)
                     fct = -1.25
		   ENDELSE

;                  *** find and remove dud detectors
;                  *** find detectors with efficiency too different from 1, work with detector number=index+1
		   cal_1d=cal_d2b(0,*) ;& print, cal_1d; 1 efficiency per tube
		   if n_elements(pzip) eq 1 then seuil=pzip else seuil=1.5 & print,'cutoff=',seuil
		   ezap=0
		   ;for i=0,nt-1 do begin
		   ;  if (cal_1d(i) gt seuil) or (cal_1d(i) lt 1/seuil) then ezap=[ezap,i+1]
		   ;endfor
		   rseuil=1./seuil
		   idx=where((cal_1d gt seuil) or (cal_1d lt rseuil)) & if idx(0) ge 0 then ezap=idx+1

;		   *** combine dzap and ezap
		   zap=[dzap,ezap]
		   zap=zap[uniq(zap,sort(zap))]

;		   *** test if zap contains real detectors **
		   idz=where(zap ge 1 and zap le 128)
;		   *** in case, eliminate spurious values ***
		   if idz(0) ne -1 then zap=zap(idz) else zap=0
;		   *** is there something left? ***
		   SD=SIZE(zap)


;		   *** if zap has something, remove corresponding detector tubes from WOUT ***
		   if SD(0) gt 0 then BEGIN
		     print, 'removing dud detectors'
;		     *** set all dud values and angles to -999 ***
		     WOUT(*,zap-1,*)=-999
		     newang_d2b(zap-1)=-999
;		     *** good values are those which do not contain -999 ***
		     GOOD=where(WOUT ne -999)
;		     if GOOD(0) eq -1 then return, GOOD(0)

;		     *** cut out dud values from WOUT and angles, not calibration as already done ***
		     WOUT=WOUT(GOOD)
		     newang_d2b=ang_d2b(where(newang_d2b ne -999))
;		     *** redefine the number of detectors
		     nt=(nt-n_elements(zap)) & print,n_elements(zap),'  detectors removed   '
;		     *** reform WOUT to proper format
		     WOUT=reform(WOUT, nh, nt, nj ,/overwrite) ;& print, size(WOUT,/dimensions)
		   ENDIF

;                  *** set tubes positions for first detector position
;                   newang_d2b=nt-1-newang_d2b ;turn angles around
		   if nj gt 1 then XX=fct*newang_d2b+ZZ(0) else XX=1.25*findgen(nh) ; angle not picked up for one point scan

;		   *** reform WOUT to be 2D (nt*nj,nh), transpose first to put nt&nj together ***
		   if nj gt 1 then WOUT= transpose(WOUT,[1,2,0]) else WOUT= transpose(WOUT,[1,0]) ; WOUT looses 3rd dimension in one point scan
		   WOUT= reform(WOUT,nt*nj,nh,/overwrite)
                   print, 'second reform'

                   print, 'concatenating detector positions '
;			*** do the following if there are at least 2 points in scan ***
;			*** create a XX array by adding up all 2th for all dets **
;			*** in the same order as in WOUT
		   IF nj gt 1 then BEGIN                                     ; i.e. not single point scan
					 FOR i=1,nj-1 do  XX=[XX , fct*newang_d2b+ZZ(i)]
;			*** sort the XX and WOUT arrays, preserve 2D of latter (idx is the index array) ***
		   			 idx=sort (XX) &  XX =XX(idx) & WOUT=WOUT(idx,*)
;			*** XR contains the 2th's rounded to the nearest step size ***
		   			 XR =round(XX/D2TH) & XR=XR*D2TH
;			*** GRID contains the fractional indices of XR into XX ***
					 GRID=(XR-XX)/D2TH+findgen(n_elements(XX))
;			*** for each height do a 1D interpolation using WOUT_1D and reassign WOUT***
					 FOR i=0,nh-1 DO BEGIN
					   WOUT_1D=WOUT(*,i)
					   WOUT(*,i)=interpolate(WOUT_1D,GRID,CUBIC=-0.5)
					 ENDFOR
;			*** reassign XX and WOUT
					 XX=XR
;			*** YY is the height, EE the error
					 YY = findgen(nh)*h/(nh-1) - h/2.0
		   			 ZZ = param(46)
					 WOUT=WOUT>0
                 	 EE = SQRT(WOUT)
		   ENDIF

END
;*********** D2B => Paolo Radaelli ******************

pro dud, dets=d, pts=p, cutoff=c


common c_rdid, dzap, pzap, pzip

if n_elements(d) gt 0 then dzap=d
if n_elements(p) gt 0 then pzap=p
if n_elements(c) gt 0 then pzip=c


end
;-----------------------------------------------------------------------------	
	
	PRO FR_calculate, n_buf , j, ratio, dRatio

	IF n_buf(2,j + 1) EQ 0. THEN BEGIN
		ratio = 999. & dratio = 0.
		RETURN
	ENDIF

	nonflip  = n_buf(2,j)     / n_buf(1,j)
	flip     = n_buf(2,j + 1) / n_buf(1,j + 1)
	ratio    = nonflip/flip
	dnonflip = SQRT(n_buf(2,j)/n_buf(1,j)^2 + n_buf(2,j)^2/n_buf(1,j)^3)
	dflip    = SQRT(n_buf(2,j + 1)/n_buf(1,j + 1)^2 + n_buf(2,j + 1)^2/n_buf(1,j + 1)^3)
	dratio   = SQRT((dnonflip/flip)^2 + (nonflip*dflip/flip^2)^2)
	
	RETURN
	END

;-------------------------------------------------------------------------------
;*******************************************************************************
;
	PRO rdid_d7, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param, $
		     par1,par2,par3,par4,par5,WT ,XT ,YT ,ZT ,OT,DATE,PP,PTXT,$
		     XX ,YY ,ZZ ,NN ,PV ,EE

;LAMP data-read interface for D7 data (ILL format) called from rdid.pro
;**********************************************************************
;
; Reads 3 versions of D7 data:
;	Version 0: Up to and including cycle 961
;	Version 1: 2nd half of cycle 965 up to and including cycle 024
;	Version 2: From cycle 031 onwards
;
; Doesn't read D7 data in cycles 962-964 and the beginning of cycle
; 965 corresponding to run numbers #7002 - #9583 which were 
; badly formatted.  This data may be read with the macro "read_d7_96.pro"
;
;
;Parameters to return
;********************
;WOUT             (modified data)
;WT,XT,YT,ZT,OT   (titles)
;PP,PTXT          (parameter floatting table and textarea)
;XX,YY,ZZ         (coordinates)
;NN               (monitors)
;PV               (supplement parameter table of any dimension)
;EE               (errors from WOUT)
;
;							JRS 4/4/03
;-------------------------------------------------------------------------------
;*******************************************************************************
;
	iprint = 0

;Useful input parameters from rdid
;*********************************

	IF iprint THEN BEGIN
		HELP, INST 	& PRINT, INST
		HELP, numor 	& PRINT, numor
		HELP, nvers 	& PRINT, nvers
		HELP, text 	& PRINT, text
		HELP, exper 	& PRINT, exper
		HELP, scan 	& PRINT, scan
		HELP, cnt 	& PRINT, cnt
		HELP, WOUT
		HELP, vparm 	& PRINT, vparm
		HELP, param 	& PRINT, param   
		HELP, par1 	& PRINT, par1
		HELP, par2	& IF (N_ELEMENTS(par2) GT 0) THEN PRINT, par2
	ENDIF

	IF iprint THEN PRINT,'rdid_d7: starting'
	PRINT,'Reading run',numor

;-------------------------------------------------------------------------
;*************************************************************************

	CASE nvers OF

;-------------------------------------------------------------------------

	0: BEGIN

		IF iprint THEN PRINT,'D7:  Old data format -> 1996'

		inst   = STRMID(text,0 ,4)
		numexp = STRMID(text,4 ,10)
		date   = STRMID(text,14,18)
		main_title = numexp
		sub_title  = main_title
		start_time = date

	;      -------------------------------
	;      MONITOR VALUES in n
	;      -------------------------------      

		n_buf = FLTARR(4,7)

		n_buf(*,0) = 0.			; first line is zeros
		n_buf(0,1) = par1(14)		; Time      Z up-up    
		n_buf(0,2) = par1(114)	 	; Time      Z up-down
		n_buf(0,3) = param(0)  	 	; Time      X up-up    
		n_buf(0,4) = param(12)     	; Time      X up-down
		n_buf(0,5) = param(24)		; Time      Y up-up 
		n_buf(0,6) = param(36)		; Time      Y up-down
		n_buf(1,1) = par1(3)    	; Monitor 1 Z up-up
		n_buf(1,2) = par1(103) 		; Monitor 1 Z up-down 
		n_buf(1,3) = par1(117) 		; Monitor 1 X up-up
		n_buf(1,4) = param(1)		; Monitor 1 X up-down
		n_buf(1,5) = param(13)		; Monitor 1 Y up-up 
		n_buf(1,6) = param(25)		; Monitor 1 Y up-down
		n_buf(2,1) = par1(12)    	; Monitor 2 Z up-up
		n_buf(2,2) = par1(112)	 	; Monitor 2 Z up-down 
		n_buf(2,3) = par1(126) 		; Monitor 2 X up-up
		n_buf(2,4) = param(10)		; Monitor 2 X up-down
		n_buf(2,5) = param(22)		; Monitor 2 Y up-up 
		n_buf(2,6) = param(34)		; Monitor 2 Y up-down
		n_buf(3,1) = par1(13)		; Handshake Z up-up
		n_buf(3,2) = par1(113)		; Handshake Z up-down
		n_buf(3,3) = par1(127)		; Handshake X up-up
		n_buf(3,4) = param(11)		; Handshake X up-down
		n_buf(3,5) = param(23)		; Handshake Y up-up
		n_buf(3,6) = param(35)		; Handshake Y up-down

		IF n_buf(0,2) EQ 0. THEN BEGIN
			ratioZ = 0.
			ratioX = 0.
			ratioY = 0.
		ENDIF ELSE IF n_buf(0,3) EQ 0. THEN BEGIN
			IF n_buf(2,2) EQ 0. THEN ratioZ = 999. ELSE $
			ratioZ = (n_buf(2,1)/n_buf(1,1)) / (n_buf(2,2)/n_buf(1,2))
			ratioX = 0.
			ratioY = 0.
		ENDIF ELSE BEGIN
			IF n_buf(2,2) EQ 0. THEN ratioZ = 999. ELSE $
			ratioZ = (n_buf(2,1)/n_buf(1,1)) / (n_buf(2,2)/n_buf(1,2))
			IF n_buf(2,4) EQ 0. THEN ratioX = 999. ELSE $
			ratioX = (n_buf(2,3)/n_buf(1,3)) / (n_buf(2,4)/n_buf(1,4))
			IF n_buf(2,6) EQ 0. THEN ratioY = 999. ELSE $
			ratioY = (n_buf(2,5)/n_buf(1,5)) / (n_buf(2,6)/n_buf(1,6))
		ENDELSE

		nspectra = 64
		IF scan EQ 1 THEN BEGIN					; No TOF
			TOF       = 0
			nchannels = 1
			IF n_buf(0,2) EQ 0. THEN BEGIN			; no PA
				nphases = 1
			ENDIF ELSE IF (n_buf(0,3) EQ 0.) THEN BEGIN 	; only Z-PA
				nphases = 2
			ENDIF ELSE BEGIN				; full XYZ-PA
				nphases = 6
			ENDELSE

			x_buf = par1(23:86)	; x-axis is scattering angle
			y_buf = INDGEN(nphases)
			z_buf = x_buf
			w_buf = FLTARR(nspectra,nphases)
			FOR iphase=0, nphases - 1 DO $
				w_buf(*,iphase) = WOUT(80*iphase : 80*iphase + nspectra - 1)
			chel   = 0.
			nb_chn = 1
			nb_spc = nspectra
		ENDIF ELSE BEGIN
			TOF       = 1
			nchannels = cnt
			nphases   = scan/nspectra
			x_buf     = INDGEN(nchannels)+1 		; x-axis is channel number
			y_buf     = FLTARR(scan)	  		; y-axis is scattering angle
			FOR iphase=0, nphases - 1 DO $
				y_buf(iphase*nspectra : iphase*nspectra + nspectra - 1) = par1(23:86)
			z_buf     = y_buf
			w_buf     = FLTARR(nchannels,scan)
			ispec     = INDGEN(scan)
			w_buf(*,ispec) = WOUT(*,ispec)
			w_tmp     = FLTARR(nchannels)
			FOR i = 1, scan, 2 DO w_tmp = w_tmp + w_buf(*,i)
			Imax = MAX(w_tmp,ichel)
			chel = FLOAT(ichel)
		ENDELSE

		lambda = par1(15)
		IF (lambda GT 4.5) AND (lambda LE 5.0) THEN lambda=4.8 $
		ELSE IF (lambda LT 3.5) THEN lambda=3.1
		IF (lambda GT 5.0) THEN lambda=5.7

	;      -------------------------------
	;      PARAMETER ASSIGNMENT IN Pn
	;      -------------------------------      
		npar        = 34
		p_buf       = FLTARR(npar)
		par_txt_buf = STRARR(npar)

		p_buf(0)  = numor	& par_txt_buf(0)  = ' 0 Numor			='
		p_buf(1)  = nspectra	& par_txt_buf(1)  = ' 1 Number of spectra	='
		p_buf(2)  = nphases	& par_txt_buf(2)  = ' 2 Number of phases	='
		p_buf(3)  = 1.		& par_txt_buf(3)  = ' 3 Number of runs  	='
		p_buf(4)  = lambda	& par_txt_buf(4)  = ' 4 Wavelength (A)  	='
		p_buf(5)  = 0.		& par_txt_buf(5)  = ' 5 Chopper Speed (rpm)	='
		p_buf(6)  = nchannels	& par_txt_buf(6)  = ' 6 Number of Time Channels ='
		p_buf(7)  = par1(17)	& par_txt_buf(7)  = ' 7 Channel Width (mcs)	='
		p_buf(8)  = TOF		& par_txt_buf(8)  = ' 8 TOF mode (0/1)  	='
		p_buf(9)  = chel	& par_txt_buf(9)  = ' 9 Elastic Peak Channel	='
		p_buf(10) = 0.		& par_txt_buf(10) = '10 Set-pt Temp Start	='
		p_buf(11) = 0.		& par_txt_buf(11) = '11 Set-pt Temp End 	='
		p_buf(12) = 0.		& par_txt_buf(12) = '12 Regul Temp Start	='
		p_buf(13) = 0.		& par_txt_buf(13) = '13 Regul Temp End  	='
		p_buf(14) = 0.		& par_txt_buf(14) = '14 Sample Temp Start	='
		p_buf(15) = par1(16)	& par_txt_buf(15) = '15 Sample Temp End 	='
		p_buf(16) = 0.		& par_txt_buf(16) = '16 Bank1 Position  	='
		p_buf(17) = 0.		& par_txt_buf(17) = '17 Bank2 Position  	='
		p_buf(18) = 0.		& par_txt_buf(18) = '18 Bank3 Position  	='
		p_buf(19) = 0.		& par_txt_buf(19) = '19 Bank4 Position  	='
		p_buf(20) = 0.		& par_txt_buf(20) = '20 Lower Sample Rotation	='
		p_buf(21) = par1(22)	& par_txt_buf(21) = '21 Upper Sample Rotation	='
		p_buf(22) = 0.		& par_txt_buf(22) = '22 Z Flipper Current	='
		p_buf(23) = 0.		& par_txt_buf(23) = '23 Z Correction Current	='
		p_buf(24) = 0.		& par_txt_buf(24) = '24 X Flipper Current	='
		p_buf(25) = 0.		& par_txt_buf(25) = '25 X Correction Current	='
		p_buf(26) = 0.		& par_txt_buf(26) = '26 Y Flipper Current	='
		p_buf(27) = 0.		& par_txt_buf(27) = '27 Y Correction Current	='
		p_buf(28) = ratioZ	& par_txt_buf(28) = '28 Z Flipping Ratio	='
		p_buf(29) = ratioX	& par_txt_buf(29) = '29 X Flipping Ratio	='
		p_buf(30) = ratioY	& par_txt_buf(30) = '30 Y Flipping Ratio	='
		p_buf(31) = 0.		& par_txt_buf(31) = '31 Run Time (seconds)	='
		p_buf(32) = 0.		& par_txt_buf(32) = '32 Start time (hours)	='
		p_buf(33) = 0.		& par_txt_buf(33) = '33 End Time (hours)	='

	END

;------------------------------------------------------------------------
	
	1: BEGIN

	datasource=0	; 0 => take data from appropriate counters
			; 1 => take data from hytec counters always
			; 2 => take data from tof counters always

	IF iprint THEN PRINT,'D7: Data format 1 -> 1996 - 2002'
	
	inst         = STRMID(text,0,4)
	save_time    = STRMID(text,14,18)
	main_title   = STRTRIM(exper(0),2)
	sub_title    = STRTRIM(exper(1),2)
	IF (numor GE 9609 AND numor LE 10318) OR $
	   (numor GE 10327 AND numor LE 11062) THEN BEGIN	
		user         = STRMID(exper(3),0,8)
		local_contact= STRMID(exper(3),8,8)
		start_time   = ''
		stop_time    = ''
		scan_type    = ''
		pol_mode     = ''
		Time_mode    = ''	
	ENDIF ELSE BEGIN
		user         = STRMID(exper(2),0,8)
		local_contact= STRMID(exper(2),8,8)
		start_time   = STRMID(exper(3),0,18)
		stop_time    = STRMID(exper(3),20,18)
		scan_type    = STRMID(exper(3),38,9)
		pol_mode     = STRMID(exper(3),47,5)
		Time_mode    = STRMID(exper(3),52,6)
	ENDELSE

	IF iprint THEN BEGIN
		PRINT,'inst          = ',inst
		PRINT,'main_title    = ',main_title
		PRINT,'sub_title     = ',sub_title
		PRINT,'user          = ',user
		PRINT,'local_contact = ',local_contact
		PRINT,'start_time    = ',start_time
		PRINT,'stop_time     = ',stop_time
		PRINT,'save_time     = ',save_time
		PRINT,'scan_type     = ',scan_type
		PRINT,'pol_mode      = ',pol_mode
		PRINT,'Time_mode     = ',Time_mode
	ENDIF

;------------------------------------
;	Monitor Values in n
;------------------------------------

	n_buf      = FLTARR(4,7)		
	n_buf(*,0) = 0.			; first line is zeros
	n_buf(0,1) = par1(13)		; Time      Z up-up    
	n_buf(0,2) = par1(22)	 	; Time      Z up-down
	n_buf(0,3) = par1(31)   	; Time      X up-up    
	n_buf(0,4) = par1(40)     	; Time      X up-down
	n_buf(0,5) = par1(49)		; Time      Y up-up 
	n_buf(0,6) = par1(58)		; Time      Y up-down
	n_buf(1,1) = par1(15)    	; Monitor 1 Z up-up
	n_buf(1,2) = par1(24) 		; Monitor 1 Z up-down 
	n_buf(1,3) = par1(33) 		; Monitor 1 X up-up
	n_buf(1,4) = par1(42)		; Monitor 1 X up-down
	n_buf(1,5) = par1(51)		; Monitor 1 Y up-up 
	n_buf(1,6) = par1(60)		; Monitor 1 Y up-down
	n_buf(2,1) = par1(16)    	; Monitor 2 Z up-up
	n_buf(2,2) = par1(25)	 	; Monitor 2 Z up-down 
	n_buf(2,3) = par1(34) 		; Monitor 2 X up-up
	n_buf(2,4) = par1(43)		; Monitor 2 X up-down
	n_buf(2,5) = par1(52)		; Monitor 2 Y up-up 
	n_buf(2,6) = par1(61)		; Monitor 2 Y up-down
	n_buf(3,1) = par1(14)		; Handshake Z up-up
	n_buf(3,2) = par1(23)		; Handshake Z up-down
	n_buf(3,3) = par1(32)		; Handshake X up-up
	n_buf(3,4) = par1(41)		; Handshake X up-down
	n_buf(3,5) = par1(50)		; Handshake Y up-up
	n_buf(3,6) = par1(59)		; Handshake Y up-down

	IF iprint THEN PRINT,'monitors assigned OK'

;--------------------------------
;	Calculate Flipping Ratios
;--------------------------------

	IF n_buf(0,2) EQ 0. THEN BEGIN				;NOP
		ratioZ = 0.	& dratioZ = 0.
		ratioX = 0.	& dratioX = 0.
		ratioY = 0.	& dratioY = 0.
	ENDIF ELSE IF n_buf(0,3) EQ 0. THEN BEGIN		;ZPO
		FR_calculate, n_buf, 1, ratioZ, dratioZ
		ratioX = 0. & dratioX = 0.
		ratioY = 0. & dratioY = 0.
	ENDIF ELSE BEGIN					;XYZ
		FR_calculate, n_buf, 1, ratioZ, dratioZ
		FR_calculate, n_buf, 3, ratioX, dratioX
		FR_calculate, n_buf, 5, ratioY, dratioY
	ENDELSE
	IF iprint THEN PRINT,'Flipping Ratios OK'

;------------------------------
;	Calculate Running Times
;------------------------------

	h1=LONG(0)	& m1=LONG(0)	& s1=LONG(0)
	h2=LONG(0)	& m2=LONG(0)	& s2=LONG(0)
	IF (start_time NE '') AND (stop_time NE '') THEN BEGIN
		READS, start_time, FORMAT = '(I2,8X,I2,1X,I2,1X,I2)', da1, h1, m1, s1
		READS, stop_time,  FORMAT = '(I2,8X,I2,1X,I2,1X,I2)', da2, h2, m2, s2
		time1 = FLOAT(3600*h1+60*m1+s1)/3600.+24.*da1
		time2 = FLOAT(3600*h2+60*m2+s2)/3600.+24.*da2
		IF (h2 GE h1) THEN run_time = FLOAT(3600*(h2-h1)+60*(m2-m1)+(s2-s1)) $
			      ELSE run_time = FLOAT(3600*(24+h2-h1)+60*(m2-m1)+(s2-s1))
	ENDIF ELSE BEGIN
		time1     = 0.
		time2     = 0.
		run_time  = 0.
	ENDELSE

;--------------------------------
;	Counts
;--------------------------------

	nspectra  = 64
	shytec    = SIZE(param)
	c_hytec   = param
	nsp_hytec = shytec(1)
	nph_hytec = nsp_hytec/nspectra
	nphases   = nph_hytec

	IF (scan EQ 1) THEN TOFformat=0 ELSE TOFformat=1

	IF (NOT TOFformat) AND (datasource NE 1) THEN BEGIN	; no TOF
		IF iprint THEN PRINT,'non-TOF data'
		TOF       = 0
		nsp_tof   = cnt
		nph_tof   = cnt/nspectra
		nchannels = 1
		c_tof     = WOUT
	ENDIF ELSE IF (datasource EQ 1) THEN TOF=0 ELSE BEGIN	; with TOF
		IF iprint THEN PRINT,'TOF data'

; mon1 and mon2 tof channels added as dets 65 and 66 from #42356 (23/11/99)

		IF (numor GE 42356) THEN nspectra=66 
		TOF       = 1
		nsp_tof   = scan
		nph_tof   = scan/nspectra
		nchannels = FIX(par2(2))
		c_tof     = WOUT
	ENDELSE

	IF iprint THEN PRINT,'nsp=',nsp_tof,' nph=',nph_tof,' nchannels=',nchannels
	IF iprint THEN PRINT,'nphases=',nphases, 'nspectra=',nspectra

	TOFfactor = FLTARR(6)	& TOFfactor(*) = 1.
	IF (TOF EQ 0) THEN BEGIN
		IF iprint THEN PRINT,'TOF = 0'
		IF (datasource EQ 2) THEN w_buf=reform(c_tof,nspectra,nphases) $
			ELSE w_buf=reform(c_hytec,nspectra,nphases)
		x_buf = par2(6:69)
		IF (nphases EQ 1) THEN y_buf = LONG(numor) $
				  ELSE y_buf = INDGEN(nphases)
		z_buf = x_buf
		chel  = 0.
		norm  = 1.
	ENDIF ELSE BEGIN
		IF iprint THEN PRINT,'TOF=1'
		w_buf = c_tof
		x_buf = INDGEN(nchannels)+1
		y_buf = FLTARR(nsp_tof)
		FOR iph = 0, nph_tof - 1 DO y_buf(iph*nspectra:iph*nspectra + 63) = par2(6:69)
		z_buf = y_buf
		w_tmp = LONARR(nchannels)	& w_tmp(*) = 0
		FOR i = 1, nsp_tof, 2 DO w_tmp(*) = w_tmp(*) + w_buf(*,i)
		Imax = MAX(w_tmp,ichel)
		chel = FLOAT(ichel)
		FOR iphase = 0, nphases - 1 DO BEGIN
			lowlim  =  iphase*64
			highlim = (iphase*63) + 63 + iphase
			sumh    = TOTAL(c_hytec(lowlim:highlim))
			tott    = TOTAL(FLOAT(c_tof),1)
			lowlim  = iphase*66
			highlim = (iphase*65) + 63 + iphase
			sumt    = TOTAL(tott(lowlim:highlim))
			IF (sumh EQ 0) THEN sumh = sumt
			TOFfactor(iphase) = sumt/sumh
		ENDFOR
		IF iprint THEN PRINT,'sumh=',sumh,' sumt=',sumt
	ENDELSE

	IF iprint THEN PRINT,'scattering angles and chel OK'

;-------------------------
;	Parameters
;-------------------------

	lambda = par2(0)
	IF (lambda GT 3.5) AND (lambda LE 5.0) THEN lambda=4.838 $
	ELSE IF (lambda LT 3.5) THEN lambda=3.12
	IF (lambda GT 5.0) THEN lambda=5.9
	IF (numor GE 8434 AND numor LT 73568) THEN lambda=3.02
	IF iprint THEN PRINT,'lambda=',lambda

	p_buf=FLTARR(50)
	par_txt_buf=STRARR(50)
	p_buf(0)  = numor	  & par_txt_buf(0)  = ' 0 Numor 		  ='
	p_buf(1)  = nspectra	  & par_txt_buf(1)  = ' 1 Number of spectra	  ='
	p_buf(2)  = nph_hytec	  & par_txt_buf(2)  = ' 2 Number of phases	  ='
	p_buf(3)  = 1.  	  & par_txt_buf(3)  = ' 3 Number of runs	  ='
	p_buf(4)  = lambda	  & par_txt_buf(4)  = ' 4 Wavelength (A)	  ='
	p_buf(5)  = par2(1)	  & par_txt_buf(5)  = ' 5 Chopper Speed (rpm)	  ='
	p_buf(6)  = par2(2)	  & par_txt_buf(6)  = ' 6 Number of Time Channels ='
	p_buf(7)  = par2(3)	  & par_txt_buf(7)  = ' 7 Channel Width (mcs)	  ='
	p_buf(8)  = TOF 	  & par_txt_buf(8)  = ' 8 TOF mode (0/1)	  ='
	p_buf(9)  = chel	  & par_txt_buf(9)  = ' 9 Elastic Peak Channel    ='
	p_buf(10) = par1(0)	  & par_txt_buf(10) = '10 Set-pt Temp Start	  ='
	p_buf(11) = par1(3)	  & par_txt_buf(11) = '11 Set-pt Temp End	  ='
	p_buf(12) = par1(1)	  & par_txt_buf(12) = '12 Regul Temp Start	  ='
	p_buf(13) = par1(4)	  & par_txt_buf(13) = '13 Regul Temp End	  ='
	p_buf(14) = par1(2)	  & par_txt_buf(14) = '14 Sample Temp Start	  ='
	p_buf(15) = par1(5)	  & par_txt_buf(15) = '15 Sample Temp End	  ='
	p_buf(16) = par2(76)	  & par_txt_buf(16) = '16 Bank1 Position	  ='
	p_buf(17) = par2(77)	  & par_txt_buf(17) = '17 Bank2 Position	  ='
	p_buf(18) = par2(78)	  & par_txt_buf(18) = '18 Bank3 Position	  ='
	p_buf(19) = par2(79)	  & par_txt_buf(19) = '19 Bank4 Position	  ='
	p_buf(20) = par2(80)	  & par_txt_buf(20) = '20 Upper Sample Rotation   ='
	p_buf(21) = par2(81)	  & par_txt_buf(21) = '21 Lower Sample Rotation   ='
	p_buf(22) = par1(17)	  & par_txt_buf(22) = '22 Z Flipper Current	  ='
	p_buf(23) = par1(18)	  & par_txt_buf(23) = '23 Z Correction Current    ='
	p_buf(24) = par1(35)	  & par_txt_buf(24) = '24 X Flipper Current	  ='
	p_buf(25) = par1(36)	  & par_txt_buf(25) = '25 X Correction Current    ='
	p_buf(26) = par1(53)	  & par_txt_buf(26) = '26 Y Flipper Current	  ='
	p_buf(27) = par1(54)	  & par_txt_buf(27) = '27 Y Correction Current    ='
	p_buf(28) = ratioZ	  & par_txt_buf(28) = '28 Z Flipping ratio	  ='
	p_buf(29) = ratioX	  & par_txt_buf(29) = '29 X Flipping ratio	  ='
	p_buf(30) = ratioY	  & par_txt_buf(30) = '30 Y Flipping ratio	  ='
	p_buf(31) = run_time	  & par_txt_buf(31) = '31 Run Time (seconds)	  ='
	p_buf(32) = time1	  & par_txt_buf(32) = '32 Start time (hours)	  ='
	p_buf(33) = time2	  & par_txt_buf(33) = '33 End Time (hours)	  ='
	p_buf(34) = par2(70)	  & par_txt_buf(34) = '34 Mono1 (psiA)  	  ='
	p_buf(35) = par2(71)	  & par_txt_buf(35) = '35 Mono2 (psiB)  	  ='
	p_buf(36) = par2(72)	  & par_txt_buf(36) = '36 Mono3 (psiC)  	  ='
	p_buf(37) = par2(73)	  & par_txt_buf(37) = '37 Mono4 (thetaA)	  ='
	p_buf(38) = par2(74)	  & par_txt_buf(38) = '38 Mono5 (thetaB)	  ='
	p_buf(39) = par2(75)	  & par_txt_buf(39) = '39 Mono6 (thetaC)	  ='
	p_buf(40) = TOFfactor(0)  & par_txt_buf(40) = '40 Z  TOFfactor  	  ='
	p_buf(41) = TOFfactor(1)  & par_txt_buf(41) = '41 Z1 TOFfactor  	  ='
	p_buf(42) = TOFfactor(2)  & par_txt_buf(42) = '42 X  TOFfactor  	  ='
	p_buf(43) = TOFfactor(3)  & par_txt_buf(43) = '43 X1 TOFfactor  	  ='
	p_buf(44) = TOFfactor(4)  & par_txt_buf(44) = '44 Y  TOFfactor  	  ='
	p_buf(45) = TOFfactor(5)  & par_txt_buf(45) = '45 Y1 TOFfactor  	  ='
	p_buf(46) = dratioZ	  & par_txt_buf(46) = '46 Z dFlipping ratio	  ='
	p_buf(47) = dratioX	  & par_txt_buf(47) = '47 X dFlipping ratio	  ='
	p_buf(48) = dratioY	  & par_txt_buf(48) = '48 Y dFlipping ratio	  ='
	p_buf(49) = par2(82)	  & par_txt_buf(49) = '49 Polariser Angle	  ='
	
	IF (iprint GT 0) THEN PRINT,'parameters assigned OK'

; 22/9/98 Problem with bank4 - recabled using coder 5 cables. Result is 10.21 
; degree shift in coder reading
; 15/10/98 Looking at magnetic Bragg peak in UCu5, another 1.2 degree shift is
; required to bring bank4 peak into agreement with bank1

	IF (numor GE 30721 AND numor LE 31064) THEN p_buf(19) = p_buf(19) + 10.21 - 1.2

	END

;-----------------------------------------------------------------------------

	2: BEGIN

	IF (iprint GT 0) THEN PRINT,'D7: Data format 2 -> 2003 ->'

	inst          = STRMID(text,0,4)
	save_time     = STRMID(text,14,18)
	main_title    = STRTRIM(exper(0),2)
	sub_title     = STRTRIM(exper(1),2)
	user          = STRMID(exper(2),0,8)
	local_contact = STRMID(exper(2),8,8)
	start_time    = STRMID(exper(3),0,18)
	stop_time     = STRMID(exper(3),20,18)
	scan_type     = STRMID(exper(3),38,9)
	pol_mode      = STRMID(exper(3),47,5)
	Time_mode     = STRMID(exper(3),52,6)


	IF iprint THEN BEGIN
		PRINT, 'inst         = ', inst
		PRINT, 'main_title   = ', main_title
		PRINT, 'sub_title    = ', sub_title
		PRINT, 'user         = ', user
		PRINT, 'local_contact= ', local_contact
		PRINT, 'start_time   = ', start_time
		PRINT, 'stop_time    = ', stop_time
		PRINT, 'save_time    = ', save_time
		PRINT, 'scan_type    = ', scan_type
		PRINT, 'pol_mode     = ', pol_mode
		PRINT, 'Time_mode    = ', Time_mode
	ENDIF

	CASE pol_mode OF
		' NOP ': nphases = 1
		'  ZP ': nphases = 2
		'XYZP ': nphases = 6
	ENDCASE

	nspectra = cnt/nphases

	IF (scan EQ 1) THEN TOFformat=0 ELSE TOFformat=1

	IF (NOT TOFformat) THEN BEGIN			; no TOF
		IF iprint THEN PRINT,'non-TOF data'
		TOF       = 0
		nspectra  = cnt/nphases
		nchannels = 1
		c_tof     = WOUT
	ENDIF ELSE BEGIN	; with TOF
		TOF       = 1
		nsp_tof   = scan
		nph_tof   = nphases
		nspectra  = nsp_tof/nphases
		nchannels = FIX(par1(2))
		c_tof     = WOUT
	ENDELSE

	IF iprint THEN PRINT,'nspectra=',nspectra,' nphases=',nphases,' nchannels=',nchannels
	IF iprint THEN PRINT,'Data read OK from ', nspectra, 'detectors'

;------------------------------------
;	Monitor Values in n
;------------------------------------

	n_buf      = FLTARR(4,7)
	n_buf(*,0) = 0.			; first line is zero
	n_buf(0,1) = param(14)		; Time      Z up-up    
	n_buf(0,2) = param(24)	 	; Time      Z up-down
	n_buf(0,3) = param(34)   		; Time      X up-up    
	n_buf(0,4) = param(44)     	; Time      X up-down
	n_buf(0,5) = param(54)		; Time      Y up-up 
	n_buf(0,6) = param(64)		; Time      Y up-down
	n_buf(1,1) = param(16)    	; Monitor 1 Z up-up
	n_buf(1,2) = param(26) 		; Monitor 1 Z up-down 
	n_buf(1,3) = param(36) 		; Monitor 1 X up-up
	n_buf(1,4) = param(46)		; Monitor 1 X up-down
	n_buf(1,5) = param(56)		; Monitor 1 Y up-up 
	n_buf(1,6) = param(66)		; Monitor 1 Y up-down
	n_buf(2,1) = param(17)    	; Monitor 2 Z up-up
	n_buf(2,2) = param(27)	 	; Monitor 2 Z up-down 
	n_buf(2,3) = param(37) 		; Monitor 2 X up-up
	n_buf(2,4) = param(47)		; Monitor 2 X up-down
	n_buf(2,5) = param(57)		; Monitor 2 Y up-up 
	n_buf(2,6) = param(67)		; Monitor 2 Y up-down
	n_buf(3,1) = param(15)		; Handshake Z up-up
	n_buf(3,2) = param(25)		; Handshake Z up-down
	n_buf(3,3) = param(35)		; Handshake X up-up
	n_buf(3,4) = param(45)		; Handshake X up-down
	n_buf(3,5) = param(55)		; Handshake Y up-up
	n_buf(3,6) = param(65)		; Handshake Y up-down

	IF iprint THEN PRINT,'monitor assigned OK'

;--------------------------------
;	Calculate Flipping Ratios
;--------------------------------

	IF n_buf(0,2) EQ 0. THEN BEGIN				;NOP
		ratioZ = 0.	& dratioZ = 0.
		ratioX = 0.	& dratioX = 0.
		ratioY = 0.	& dratioY = 0.
	ENDIF ELSE IF n_buf(0,3) EQ 0. THEN BEGIN		;ZPO
		FR_calculate, n_buf, 1, ratioZ, dratioZ
		ratioX = 0. & dratioX = 0.
		ratioY = 0. & dratioY = 0.
	ENDIF ELSE BEGIN					;XYZ
		FR_calculate, n_buf, 1, ratioZ, dratioZ
		FR_calculate, n_buf, 3, ratioX, dratioX
		FR_calculate, n_buf, 5, ratioY, dratioY
	ENDELSE
	IF iprint THEN PRINT,'Flipping Ratios OK'

;------------------------------
;	Calculate Running Times
;------------------------------

	h1=LONG(0)	& m1=LONG(0)	& s1=LONG(0)
	h2=LONG(0)	& m2=LONG(0)	& s2=LONG(0)
	IF (start_time NE '' AND stop_time NE '') THEN BEGIN
		READS, start_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', da1, h1, m1, s1
		READS, stop_time, FORMAT='(I2,8X,I2,1X,I2,1X,I2)', da2, h2, m2, s2
		time1=FLOAT(3600*h1+60*m1+s1)/3600.+24.*(da1 - 1)
		time2=FLOAT(3600*h2+60*m2+s2)/3600.+24.*(da2 - 1)
		IF (h2 GE h1) THEN run_time=FLOAT(3600*(h2-h1)+60*(m2-m1)+(s2-s1)) $
			      ELSE run_time=FLOAT(3600*(24+h2-h1)+60*(m2-m1)+(s2-s1))
	ENDIF ELSE BEGIN
		time1=0.
		time2=0.
		run_time=0.
	ENDELSE

;------------------------------

	IF (TOF EQ 0) THEN BEGIN
		IF iprint THEN PRINT,'TOF = 0'
		w_buf = reform(c_tof,nspectra,nphases) 
		x_buf = par1(6:nspectra + 5)
		IF (nphases EQ 1) THEN y_buf = LONG(numor) $
				  ELSE y_buf = INDGEN(nphases)
		z_buf = x_buf
		chel  = 0.
		norm  = 1.
	ENDIF ELSE BEGIN
		IF iprint THEN PRINT,'TOF = 1'
		w_buf = c_tof
		x_buf = INDGEN(nchannels) + 1
		y_buf = FLTARR(nsp_tof)
		FOR iph = 0, nphases - 1 DO $
		y_buf(iph*nspectra:iph*nspectra + nspectra - 3) = par1(6:nspectra + 3)
		z_buf = y_buf
		w_tmp = LONARR(nchannels)
		FOR i = 0, nspectra - 1 DO w_tmp(*) = w_tmp(*) + w_buf(*,i)
		Imax = MAX(w_tmp,ichel)
		chel = FLOAT(ichel)
	ENDELSE

	IF iprint THEN PRINT,'scattering angles and chel OK'

;-------------------------
;	Parameters
;-------------------------

	lambda=par1(0)
	IF (lambda GT 3.5) AND (lambda LE 5.0) THEN lambda=4.838
	IF (lambda LT 3.5) THEN lambda=3.12
	IF (lambda GT 5.0) THEN lambda=5.98

	IF (iprint GT 0) THEN PRINT,'lambda=',lambda

	p_buf       = FLTARR(47)
	par_txt_buf = STRARR(47)
	
	p_buf(0)  = numor	  & par_txt_buf(0)  = ' 0 Numor 			 ='
	p_buf(1)  = nspectra	  & par_txt_buf(1)  = ' 1 Number of spectra		 ='
	p_buf(2)  = nphases	  & par_txt_buf(2)  = ' 2 Number of phases		 ='
	p_buf(3)  = 1.  	  & par_txt_buf(3)  = ' 3 Number of runs		 ='
	p_buf(4)  = lambda	  & par_txt_buf(4)  = ' 4 Wavelength (A)		 ='
	p_buf(5)  = par1(1)	  & par_txt_buf(5)  = ' 5 Chopper Speed (rpm)		 ='
	p_buf(6)  = par1(2)	  & par_txt_buf(6)  = ' 6 Number of Time Channels	 ='
	p_buf(7)  = par1(3)	  & par_txt_buf(7)  = ' 7 Channel Width (mcs)		 ='
	p_buf(8)  = TOF 	  & par_txt_buf(8)  = ' 8 TOF mode (0/1)		 ='
	p_buf(9)  = chel	  & par_txt_buf(9)  = ' 9 Elastic Peak Channel  	 ='
	p_buf(10) = param(0)	  & par_txt_buf(10) = '10 Set-pt Temp Start		 ='
	p_buf(11) = param(3)	  & par_txt_buf(11) = '11 Set-pt Temp End		 ='
	p_buf(12) = param(1)	  & par_txt_buf(12) = '12 Regul Temp Start		 ='
	p_buf(13) = param(4)	  & par_txt_buf(13) = '13 Regul Temp End		 ='
	p_buf(14) = param(2)	  & par_txt_buf(14) = '14 Sample Temp Start		 ='
	p_buf(15) = param(5)	  & par_txt_buf(15) = '15 Sample Temp End		 ='
	p_buf(16) = par1(86)	  & par_txt_buf(16) = '16 Bank1 Position		 ='
	p_buf(17) = par1(87)	  & par_txt_buf(17) = '17 Bank2 Position		 ='
	p_buf(18) = par1(88)	  & par_txt_buf(18) = '18 Bank3 Position		 ='
	p_buf(19) = par1(89)	  & par_txt_buf(19) = '19 Bank4 Position		 ='
	p_buf(20) = par1(90)	  & par_txt_buf(20) = '20 Upper Sample Rotation 	 ='
	p_buf(21) = par1(91)	  & par_txt_buf(21) = '21 Lower Sample Rotation 	 ='
	p_buf(22) = param(18)	  & par_txt_buf(22) = '22 Z Flip Current		 ='
	p_buf(23) = param(19)	  & par_txt_buf(23) = '23 Z Cor_Z Current		 ='
	p_buf(24) = param(23)	  & par_txt_buf(24) = '24 Z Cor_X Current		 ='
	p_buf(25) = param(38)	  & par_txt_buf(25) = '25 X Flip Current		 ='
	p_buf(26) = param(39)	  & par_txt_buf(26) = '26 X Cor_Z Current		 ='
	p_buf(27) = param(43)	  & par_txt_buf(27) = '27 X Cor_X Current		 ='
	p_buf(28) = param(58)	  & par_txt_buf(28) = '28 Y Flip Current		 ='
	p_buf(29) = param(59)	  & par_txt_buf(29) = '29 Y Cor_Z Current		 ='
	p_buf(30) = param(63)	  & par_txt_buf(30) = '30 Y Cor_X Current		 ='
	p_buf(31) = ratioZ	  & par_txt_buf(31) = '31 Z Flipping ratio		 ='
	p_buf(32) = ratioX	  & par_txt_buf(32) = '32 X Flipping ratio		 ='
	p_buf(33) = ratioY	  & par_txt_buf(33) = '33 Y Flipping ratio		 ='
	p_buf(34) = run_time	  & par_txt_buf(34) = '34 Run Time (seconds)		 ='
	p_buf(35) = time1	  & par_txt_buf(35) = '35 Start (hrs since 1st of month) ='
	p_buf(36) = time2	  & par_txt_buf(36) = '36 End	(hrs since 1st of month) ='
	p_buf(37) = par1(80)	  & par_txt_buf(37) = '37 Mono1 (psiA)  		 ='
	p_buf(38) = par1(81)	  & par_txt_buf(38) = '38 Mono2 (psiB)  		 ='
	p_buf(39) = par1(82)	  & par_txt_buf(39) = '39 Mono3 (psiC)  		 ='
	p_buf(40) = par1(83)	  & par_txt_buf(40) = '40 Mono4 (thetaA)		 ='
	p_buf(41) = par1(84)	  & par_txt_buf(41) = '41 Mono5 (thetaB)		 ='
	p_buf(42) = par1(85)	  & par_txt_buf(42) = '42 Mono6 (thetaC)		 ='
	p_buf(43) = dratioZ	  & par_txt_buf(43) = '43 Z dFlipping ratio		 ='
	p_buf(44) = dratioX	  & par_txt_buf(44) = '44 X dFlipping ratio		 ='
	p_buf(45) = dratioY	  & par_txt_buf(45) = '45 Y dFlipping ratio		 ='
	p_buf(46) = par1(92)	  & par_txt_buf(46) = '46 Polariser Angle		 ='
	
	IF iprint THEN PRINT,'parameters assigned OK'

	END

;-----------------------------------------------------------------------------
	
	ENDCASE

;-----------------------------------------------------------------------------
;*****************************************************************************

	WOUT = w_buf
	PP   = p_buf
	PTXT = par_txt_buf
	NN   = n_buf
	XX   = x_buf
	YY   = y_buf
	ZZ   = z_buf
	WT   = sub_title
	OT   = inst+' '+main_title
	
	IF (TOF EQ 0) THEN BEGIN
		XT = 'Scattering Angle'
		IF (nphases EQ 1) THEN YT = 'Counts' $
		ELSE BEGIN
			YT = 'Phase'
			ZT = 'Counts'
		ENDELSE
	ENDIF ELSE BEGIN
		XT = 'Time Channels'
		YT = 'Scattering Angle'
		ZT = 'Counts'
	ENDELSE

	IF iprint THEN PRINT,'rdid_d7: finished'

	RETURN
	END
	
PRO rdid_d20, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
	                 WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE

common calibration, pathcal, cal_d19 , cal_d2b , ang_d2b , cal_d1a , ang_d1a , cal_in13 $
		  	   , cal_d16 , cal_in5 , idx_in5 , shf_in5 , cal_in6 , idx_in6  $
			   , shf_in6 , cal_d20 , ang_d20 ,inf_d20 $
			   , inf_d2b , inf_d1a , inf_in13, inf_d16 , inf_in5 , inf_in6
  common d20, bad_d20 ,flag_d20, wav_d20, psd_d20  

  if !version.release ge '5.0' then ii=execute('FORWARD_FUNCTION RDDAT')

  WOUT=WOUT>0
  nd=cnt
  DATI     = strmid(exper(5),20,18)
  IF strpos(DATI,'Stop',0) GE 0 THEN BEGIN
    DATI='16-Apr-02 20:00:00'
  ENDIF
  day      = strmid(DATI,0,2)
  month    = strmid(DATI,3,3)
  year     = strmid(DATI,7,2)
  hour     = strmid(DATI,10,2)
  minute   = strmid(DATI,13,2)
  second   = strmid(DATI,16,2)
  charpos=0
  IF  STRMID(year,0,1) GT '9' OR  STRMID(year,0,1) LT '0'  OR STRMID(year,1,1) GT '9' OR  STRMID(year,1,1) LT '0' THEN BEGIN 
			  	charpos=strpos(text(0),':',0)-2
			  	hour=strmid(text(0),charpos,2)
		  		hour=strmid('00'+hour,strlen(hour),2)
				charpos=charpos+3
			  	secpos=strpos(text(0),':',charpos)
				minute=strmid(text(0),charpos,secpos-charpos)
			  	minute=strmid('00'+minute,strlen(minute),2)
			  	second=strmid(text(0),secpos+1,2)
			  	second=strmid('00'+second,strlen(second),2)
			  	charpos=strpos(text(0),' ',secpos)+1
		  		secpos=strpos(text(0),'-',charpos)
				day=strmid(text(0),charpos,secpos-charpos)
			  	day=strmid('00'+day,strlen(day),2)
			  	charpos=secpos+1
		 	        secpos=strpos(text(0),"-",charpos)
			  	month=strmid(text(0),charpos,secpos-charpos)
			  	month=strmid('   '+month,strlen(month),3)
			  	charpos=secpos+1
			  	year=strmid(text(0),charpos,2)
			  	year=strmid('00'+year,strlen(year),2)
				DATI=day+"-"+month+"-"+year+" "+hour+":"+minute+":"+second
  ENDIF ELSE BEGIN
  	hour     = strmid(DATI,10,2)
  	minute   = strmid(DATI,13,2)
  	second   = strmid(DATI,16,2)
  ENDELSE
  IF nd EQ 1600 THEN BEGIN
	IF total(WOUT(128:1599,*)) EQ 0 AND year EQ "96" THEN BEGIN     ; old PSD 128 cells
            	WOUT  =  WOUT(0:127,*)
            	nd=128
            	if n_elements(vparm) lt 26.*scan then vparm=fltarr(26,scan)
  	ENDIF
  ENDIF
  WOUT=float(WOUT)
  IF N_ELEMENTS(vparm) GE  1 THEN vparm=vparm(*,0:N_elements(WOUT(0,*))-1)
  nj = N_ELEMENTS(wout(0,*))
  EE  = WOUT/sqrt(1+WOUT)
  IF n_elements(par5) eq 0 THEN BEGIN                          ; Numor bug fix
	       par5=par4
	       par4=par3
	       par3=0
  ENDIF
  IF year GT 60 THEN par1(51)=par1(51)/1000000.                ; CntTime in sec (raw data before 2000: microsec)
  IF n_elements(par5) eq 25 THEN BEGIN                         ; Numor bug fix
	   	par5=[par5(0:19),0.,0.,0.,0.,0.,par5(20:24)]
       	param=[0.,param]
     	FOR i=0,nj-1 Do wout(*,i)=[wout(nd-1,i),wout(0:nd-2,i)] 
  ENDIF
  CntTime  = par1(51)
  proposal = strmid(exper(2),20 ,9)
  WT  =  ' '+strcompress(strmid(exper(0),20,40)) $
   	    +' '+strcompress(strmid(exper(3),20,40))
  OT = INST(0)  +' '+ DATI $
     	        +' User '+strmid(exper(1),20,8)$
     	  	    +' L.C.' +strmid(exper(4),20,7)$
		        +' Run'  +strcompress(string(numor)) 
  CASE month OF
       'Jan':  MON=1
       'Feb':  MON=2
       'Mar':  MON=3
       'Apr':  MON=4
       'May':  MON=5
       'Jun':  MON=6
       'Jul':  MON=7
       'Aug':  MON=8
       'Sep':  MON=9
       'Oct':  MON=10
       'Nov':  MON=11
       'Dec':  MON=12
  ENDCASE					
  IF par5(25) LT 963 THEN BEGIN                                  ; evt. missing reactor cycle
	  	par5(25)=year*10+ROUND(((mon-1.)*30.5+(day-1.))/366.*5.)
  ENDIF
  CYCLE = long(par5(25))
  IF N_ELEMENTS(inf_d20) EQ 0 THEN BEGIN
      IF CYCLE NE long(year*10+1+ROUND(((mon-1.)*30.5+(day-1.))/366.*4.)) THEN PRINT,"Cycle is",cycle," but probably should be",long(year*10+1+ROUND(((mon-1.)*30.5+(day-1.))/366.*4.))
  ENDIF
  if year le 60 then century=20 else century=19
  jul_day=julday(mon,day,century*100+year)-julday(1,1,1970)
  jul_sec=hour*3600.0+minute*60.0+second
  ;****** CHECK WAVELENGTH ************
  IF ROUND(10*par5(3)) LE 99 AND ROUND(10*par5(3)) GE 25 THEN BEGIN
      wav=2.41
      IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
        IF ROUND(par5(1)) NE   1 THEN PRINT,'2.52A, HOPG-Monochromator, Filters should be in but they are not'
        IF ROUND(par5(4)) NE  44 THEN PRINT,'2.52A, HOPG-Monochromator, TakeOff should be 44deg but it is at',ROUND(par5(4))
        IF ROUND(par5(5)) NE 120 THEN PRINT,'2.52A, HOPG-Monochromator, MonoChanger should be 120deg but it is at',ROUND(par5(5))
      ENDIF
  ENDIF ELSE BEGIN
      IF ROUND(10*par5(3)) LE 24 AND ROUND(10*par5(3)) GE  20 THEN BEGIN
        wav=2.41
        IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
          IF ROUND(par5(1)) NE   1 THEN PRINT,'2.41A, HOPG-Monochromator, Filters should be in but they are not'
          IF ROUND(par5(4)) NE  42 THEN PRINT,'2.41A, HOPG-Monochromator, TakeOff should be 42 deg but it is at',ROUND(par5(4))
          IF ROUND(par5(5)) NE 120 THEN PRINT,'2.41A, HOPG-Monochromator, MonoChanger should be 120 deg but it is at',ROUND(par5(5))
        ENDIF
      ENDIF ELSE BEGIN
        IF ROUND(10*par5(3)) LE 19 AND ROUND(10*par5(3)) GE 14 THEN BEGIN
          wav=1.30
          IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
            IF ROUND(par5(1)) NE   0 THEN PRINT,'1.36A, Cu-Monochromator, Filters should be out but they are not'
            IF ROUND(par5(4)) NE  44 THEN PRINT,'1.36A, Cu-Monochromator, TakeOff should be 44 deg but it is at',ROUND(par5(4))
            IF ROUND(par5(5)) NE 210 THEN PRINT,'1.36A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
          ENDIF
        ENDIF ELSE BEGIN
          IF ROUND(10*par5(3)) LE 13 AND ROUND(10*par5(3)) GE 10 THEN BEGIN
            wav=1.30
            IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
              IF ROUND(par5(1)) NE   0 THEN PRINT,'1.30A, Cu-Monochromator, Filters should be out but they are not'
              IF ROUND(par5(4)) NE  42 THEN PRINT,'1.30A, Cu-Monochromator, TakeOff should be 42 deg but it is at',ROUND(par5(4))
              IF ROUND(par5(5)) NE 210 THEN PRINT,'1.30A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
            ENDIF
          ENDIF ELSE BEGIN
            IF ROUND(100*par5(3)) LE 99 AND ROUND(100*par5(3)) GE 91 THEN BEGIN
              wav=0.94
              IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                IF ROUND(par5(1)) NE   0 THEN PRINT,'0.94A, Cu-Monochromator, Filters should be out but they are not'
                IF ROUND(par5(4)) NE  30 THEN PRINT,'0.94A, Cu-Monochromator, TakeOff should be 30 deg but it is at',ROUND(par5(4))
                IF ROUND(par5(5)) NE 210 THEN PRINT,'0.94A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
              ENDIF
            ENDIF ELSE BEGIN
              IF ROUND(100*par5(3)) LE 90 AND ROUND(100*par5(3)) GE 85 THEN BEGIN
                wav=0.88
                IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                  IF ROUND(par5(1)) NE   0 THEN PRINT,'0.88A, Cu-Monochromator, Filters should be out but they are not'
                  IF ROUND(par5(4)) NE  28 THEN PRINT,'0.88A, Cu-Monochromator, TakeOff should be 28 deg but it is at',ROUND(par5(4))
                  IF ROUND(par5(5)) NE 210 THEN PRINT,'0.88A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
                ENDIF
              ENDIF ELSE BEGIN
                IF ROUND(100*par5(3)) LE 84 AND ROUND(100*par5(3)) GE 70 THEN BEGIN
                  wav=0.82
                  IF N_ELEMENTS(inf_d20) LE 1 THEN BEGIN
                    IF ROUND(par5(1)) NE   0 THEN PRINT,'0.82A, Cu-Monochromator, Filters should be out but they are not'
                    IF ROUND(par5(4)) NE  26 THEN PRINT,'0.82A, Cu-Monochromator, TakeOff should be 28 deg but it is at',ROUND(par5(4))
                    IF ROUND(par5(5)) NE 210 THEN PRINT,'0.82A, Cu-Monochromator, MonoChanger should be 210 deg but it is at',ROUND(par5(5))
                  ENDIF
                ENDIF ELSE BEGIN
                  IF N_ELEMENTS(inf_d20) LE 1 THEN PRINT,'Do you really have a wavelength of',par5(3),' Angstroem?'
                ENDELSE
              ENDELSE
            ENDELSE
          ENDELSE
        ENDELSE
      ENDELSE
  ENDELSE
  ;WIDGET_CONTROL,wid1,/APPEND,SET_VALUE='Reading Flags'
  ;########VVVVVVV Reading several flags form rdid.flag VVVVVVV######################
  IF N_ELEMENTS(flag_d20) LT 8 THEN flag,/noprint,old=flag_d20
		bad_flag=     flag_d20(0)
		interpol_flag=flag_d20(1)
		ang_flag=     flag_d20(2)
		wav_flag=     flag_d20(3)
		normalize=    flag_d20(4)
		float_flag=   flag_d20(5)
		eff_flag  =   flag_d20(6)
		cor_flag=     flag_d20(7)
  ;########VVVVVV EFFICIENCY/Angle CALIBRATION VVVVVVVV######################
  IF N_ELEMENTS(inf_d20) EQ 0 THEN BEGIN
      inf_d20='autod20.cal'
  ENDIF ELSE IF N_ELEMENTS(inf_d20) EQ 1 THEN IF STRCOMPRESS(inf_d20,/RE) EQ '0' THEN inf_d20 ='autod20.cal'
  IF N_ELEMENTS(cal_d20) EQ 0 THEN BEGIN
      cal_d20=0
  ENDIF  
  default_cal = 0
  IF n_elements(inf_d20) EQ 0 THEN BEGIN
  		default_cal=1 
  ENDIF ELSE BEGIN
  	IF inf_d20(0) EQ 'autod20.cal' THEN BEGIN
		default_cal=1
  	ENDIF ELSE BEGIN
		IF N_ELEMENTS(inf_d20) GE 3 THEN BEGIN
			IF inf_d20(2) EQ 'autod20.cal' THEN BEGIN
				default_cal=1
			ENDIF
		ENDIF
  	ENDELSE
  ENDELSE
  IF default_cal EQ 1 AND (ang_flag EQ 1 OR eff_flag EQ 1) THEN BEGIN
	IF N_ELEMENTS(inf_d20) EQ 0 THEN inf_d20=['autod20.cal','not loaded','autod20.cal']
	count=N_ELEMENTS(inf_d20)
	IF count LT 4 THEN BEGIN
    	PRINT,'Looking up for calibration files in ',PATHCAL
		tmf     =PATHCAL
		current_dir=''
		cd,current=current_dir,tmf
		tmp     =findfile(inst(0)+'_????_??_??????.???',count=tmc) 
		cd,current_dir
		IF tmc GT 0 THEN filelist=strmid(tmp,strpos(tmp(0),inst(0)),22) else print,"Are you really on the right workstation (d20sgi.ill.fr)?"
		IF N_ELEMENTS(filelist) LE 0 THEN BEGIN
			PRINT,'NO auto-calibration file found!'
			inf_d20=['','','']
			default_cal=0
			filelist=''
		ENDIF else print,'Files in ~lambda/CALIBRATION ',filelist
        IF N_ELEMENTS(inf_d20) LT 2 THEN inf_d20=['autod20.cal','']
		inf_d20=[inf_d20(0:1),'autod20.cal',STRING(filelist)]
	ENDIF ELSE filelist= inf_d20(3:count-1)  ; NEW calibration file naming
    tmplist=filelist	
    tmp=where(STRMID(filelist,strlen(inst(0))+16,3) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3),count)
    IF count LE 0 THEN tmp=where(STRMID(filelist,strlen(inst(0))+16,2) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,2),count)
    IF count le 0 then BEGIN
    	tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,1),count)
        IF count le 0 then tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*((wav+1)<9))),1,1),count)
        IF count le 0 then tmp=where(STRMID(filelist,strlen(inst(0))+16,1) EQ STRMID(STRING(f='(I4)',1000+ROUND(100*((wav-1)>0))),1,1),count)
    ENDIF
    IF count gt 0 then begin
    	tmplist=filelist(tmp)
    	tmp=where(tmplist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3),count)
    ENDIF
	IF count GT 0 THEN tmp=MAX(tmplist(tmp)) ELSE BEGIN
      	PRINT,'Apparently there is no calibration for ',wav,' Angstroem ',STRMID(STRING(f='(I4)',1000+ROUND(100*wav)),1,3)
		tmp=WHERE(filelist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+STRMID(STRING(f='(I4)',1000+ROUND(100*par5(3))),1,3),count)
		IF count GT 0 THEN tmp=MAX(filelist(tmp)) ELSE tmp=MIN(filelist)
        PRINT,tmp,' will be taken for calibration'
    ENDELSE
	calfile=STRCOMPRESS(tmp,/re)
  ENDIF
  ON_IOERROR,badmisread
		IF bad_flag EQ 1  OR  bad_flag NE 1 THEN BEGIN
			count=N_ELEMENTS(psd_d20)
			;help,psd_d20
			IF count LT 1 THEN psd_d20=['empty']
			IF count LT 2 THEN BEGIN
				tmf     =PATHCAL ; P_LAMBDA(0)+'/BAD_CELLS/'
				cd,current=current_dir,tmf
				tmp     =findfile(tmf+inst(0)+'_????_??_??????.bad',count=tmc) ; NEW  file names
				cd,current_dir
				if tmc gt 0 then badlist=strmid(tmp,strpos(tmp(0),inst(0)),22) else print,"Are you really on the right workstation (d20sgi.ill.fr)?"
				IF N_ELEMENTS(badlist) LE 0 THEN BEGIN
					PRINT,'NO bad cells file found!'
					psd_d20=['empty']
					bad_flag=0
					badlist=''
				ENDIF ELSE BEGIN
            		IF bad_flag EQ 1 THEN print,'Creating new bad cells filelist'
            		IF bad_flag EQ 1 THEN PRINT,' ',badlist
          		ENDELSE
				psd_d20=[string(psd_d20(0)),badlist]
				;help,psd_d20
			ENDIF ELSE badlist=psd_d20(1:count-1)
       		tmp=where(badlist LE inst(0)+'_'+strcompress(string(century),/re)+strcompress(string(year),/re)+'_'+STRMID(STRING(f='(I3)',100+mon),1,2)+'_'+STRMID(STRING(f='(I7)',1000000+numor),1,6)+'.'+'bad',count)
			IF count GT 0 THEN tmp=MAX(badlist(tmp)) ELSE  tmp=MIN(badlist)
 			IF psd_d20(0) NE tmp THEN BEGIN
            	psd_d20(0)=tmp
            	IF bad_flag EQ 1 THEN print,'data       : ',PATHCAL+psd_d20(0)
				bad_d20=rddat('data',PATHCAL,psd_d20(0),rddat_status,rddat_datp)
				PRINT,'Bad_cells file loaded : ',psd_d20(0)
            	IF bad_flag EQ 1 THEN print,'Bad cells: ',STRCOMPRESS(ROUND(bad_d20))
       		ENDIF
		ENDIF
  badmisread:
		IF wav_flag EQ 1 THEN BEGIN
	    count=N_ELEMENTS(wav_d20)
  	 	IF count LT 1 THEN wav_d20=[0.,0.,0.]
  	 	IF count LT 4 THEN BEGIN
					p_lambda,plambda
				    	tmf     =PLAMBDA+'/RIETVELD/'
					cd,current=current_dir,tmf
				    	tmp     =findfile(tmf+'?????????.d20',count=tmc)
					cd,current_dir
				    	if tmc gt 0 then filelist=LONG(strmid(tmp,strpos(tmp(0),'.d20')-9,9))
					    IF N_ELEMENTS(filelist) LE 0 THEN BEGIN
						    		  PRINT,'NO wavelength/zeroshift file found!'
					  	  				wav_d20=[0.,0.,0.]
					  	  				bad_flag=0
										    filelist=''
					  	 ENDIF else print,'Creating newwavelength/zeroshift file list',filelist
					  	 wav_d20=[wav_d20(0:2),filelist]
				ENDIF ELSE filelist=wav_d20(1:count-1)
				tmp=WHERE(filelist LE LONG(cycle)*1000000+numor,count)
				IF count GT 0 THEN tmp=MAX(filelist(tmp)) ELSE tmp=MIN(filelist)
				wav_d20(0)=LONG(tmp)
				OPENR,tmp,tmf+STRING(STRCOMPRESS(wav_d20(0),/REMOVE_ALL))+'.d20',/get_lun
				READF,tmp,line
				READF,tmp,wav_d20(1:2)
				FREE_LUN,tmp
		ENDIF
  ;help,inf_d20
  ;print,inf_d20
		IF N_ELEMENTS(inf_d20) ge 3 THEN IF N_ELEMENTS(calfile) GE 1 THEN IF calfile NE inf_d20(0) THEN IF inf_d20(2) EQ 'autod20.cal' THEN BEGIN
         inf_d20(2) = 'autochoice'
         P_DID_CALOD, INST(0),calfile, flg 
         inf_d20(2) = 'autod20.cal'
  ENDIF
  IF N_ELEMENTS(inf_d20) GE 2 THEN BEGIN
    IF STRMID(inf_d20(1),37,8) LT '3' THEN wavelength=FLOAT(STRMID(inf_d20(1),37,8)) 
  ENDIF ELSE wavelength=0
  ;####### Efficiency Correction by MULTIPLICATION with efficiency-CORRECTION data! ###########
  IF float_flag EQ 1 THEN WOUT=FLOAT(WOUT)
  IF n_elements(cal_d20(*,0)) eq nd AND eff_flag EQ 1 THEN BEGIN 
         OT=OT+'*'+inf_d20(0)
         FOR i=0,nj-1 DO FOR j=0,nd-1 DO BEGIN 
           wout(j,i)=wout(j,i)*cal_d20(j,0) 
           EE(j,i)= EE(j,i)*cal_d20(j,0) 
         ENDFOR 
  ENDIF
  IF n_elements(cal_d20(*,0)) eq 0 THEN cal_d20=0
  IF float_flag NE 1 THEN BEGIN
      IF eff_flag EQ 1 OR normalize GT 0 THEN PRINT,'Attention : Workspace is NOT floating point, but it should be!'
  ENDIF
  SequenceType    = par1(0) 
  StroboType      = par1(40) 
  NbOfSegments    = par1(1)  
	 PV = fltarr(31,scan)
	 NN = fltarr(scan)
	 FOR i=0,scan-1 DO BEGIN
	       PV(0:4,i)   = par1(0:4)	
	       PV(5,i)     = par1(51)		    				; CntTime in sec.
	       PV(6:7,i)   = par5(26:27)	  					; RtrPower,D19
	       PV(8,i)     = par5(14)		    				; OS
	       PV(9:19,i)  = param(0:10) 	 					; SampEnv,TempValues,MotorValues,Voltmeter1
	       PV(20,i)    = (par5(12)<30)+(par5(13)<30) 	 	; hor.  MonoSlits
	       PV(21,i)    = (par5(10)<140)+(par5(11)<140) 	 	; vert. MonoSlits
	       PV(22,i)    = par5(18)+par5(19) 	 				; hor.  SampleSlits
	       PV(23,i)    = par5(16)+par5(17) 	 				; vert. SampleSlits
	       PV(24,i)    = 0.0		         				; TimeStep
	       PV(25:27,i) = par1(45:47)	  					; TimeSlice,TimeDelay,TimeWindow
	       PV(28,i)    = i             						; Slice_No or sub-numor, for scans it will contain the inner stepwidth (later on ...)
	       PV(29,i)    = numor
	       PV(30,i)    = par1(50)      						; monitor
	       NN(i)       = par1(50)
	   ENDFOR
	   IF nj LE 1 THEN NN = par1(50)
	   IF N_ELEMENTS(vparm) GE 1 THEN BEGIN
       IF N_ELEMENTS(vparm(*,0)) GE 26 THEN BEGIN                                 ; NOT Stroboscopie
	    PV(0:4,*)  = vparm(0:4,*) 
        PV(5:20,*) = vparm(6:21,*) 
        PV(5,*)    = PV(5,*)/1000000.                          ; CntTime in sec (not microsec)
		NN(*)= (vparm(5,*) EQ 0.)*NN(*)+vparm(5,*)
		PV(30,*)=nn(*)
      ENDIF ELSE BEGIN 
        IF N_ELEMENTS(vparm(*,0)) GE 5 THEN BEGIN
	         PV(25:27,*)= vparm(0:2,*)  
	         PV(5,*)    = vparm(4,*) /1000000.                          ; time in sec (not microsec)
		        NN(*)= (vparm(3,*) EQ 0.)*NN(*)/PV(5,0)*PV(5,*)+vparm(3,*) ; tot.monitor if slice-mon. zero 
          IF vparm(4,0) LT vparm(3,0) THEN BEGIN                     ; Monitor-time confusion in the reading of the 51st scaler
		          PV(5,*)    = vparm(3,*) /1000000.                        ; time in sec (not microsec)
					       NN(*)      = vparm(4,*)
            IF nvers EQ 2 THEN BEGIN
              brico=indgen(nj)*3
		  						  		brico=brico(WHERE(brico LT nj))
		            PV(26:27,brico)= vparm(0:1,brico)                                ; even more confusions
		            PV(25,brico)   = vparm(2,brico)                                  ; even more confusions
              brico=indgen(nj)*3+1
								    		brico=brico(WHERE(brico LT nj))
		            PV(25:26,brico)= vparm(1:2,brico)                                ; even more confusions
		            PV(27,brico)   = vparm(0,brico)                                  ; even more confusions
					  	    ENDIF
					  	  ENDIF
		        PV(30,*)=nn(*)
				    ENDIF
				  ENDELSE
				ENDIF
    IF cor_flag EQ 1 THEN IF Cycle LE 974 THEN IF cycle GE 973 THEN IF numor LE 20200 THEN IF numor GE 8451 THEN BEGIN
      IF StroboType EQ 0 THEN IF scan EQ 1 OR SequenceType NE 0 THEN BEGIN
	    p_lambda,plambda
        corname =PLAMBDA+'/MONITOR/'+STRCOMPRESS(STRING(LONG(cycle)), /REMOVE_ALL)+'.cor'
        OPENR,cor,corname,/get_lun
        READF,cor,corrections
        IF corrections GT 0 THEN BEGIN
	      cornum=fltarr(3,corrections)
	      READF,cor,cornum
		ENDIF
		FREE_LUN,cor
		corind=WHERE(cornum(0,*) EQ numor,corrections)
		IF corrections EQ 1 THEN BEGIN
			PRINT,'Corrections will be applied: ',corname
			cornum=cornum(1:2,corind)
        	PV(30,*)=PV(30,*)-cornum(0)
        	NN      =NN      -cornum(0)
        	PV(5,*) =PV(5,*) -cornum(1)
		ENDIF ELSE PRINT,'Looked for corrections but found nothing',corrections
      ENDIF
	ENDIF
	MotPar=fltarr(6)
	MotTxt=['2*Theta/deg.     ','Omega  /deg.     ',$
	        'Chi    /deg.     ','Phi    /deg.     ',$
		    'Tr.1   /mm (horz)','Tr.2   /mm (vert)']
	FOR i=0,5 DO BEGIN 
		IF par1(12+i*5) EQ 0.0 THEN BEGIN
	       MotPar(i)=param(4+i) 
	       MotTxt(i)=MotTxt(i)+'       '
	    ENDIF ELSE BEGIN
	       MotPar(i)=par1(12+i*5)
	       MotTxt(i)=MotTxt(i)+'       '
      	ENDELSE
	ENDFOR
    step_or_sub='Sub-Numor or Slice-No.  '
    ScanText=   'Unknown Scan Type       '                        
    IF  SequenceType eq  0 THEN ScanText='Single Data Acquisition '
    IF  SequenceType eq  1 THEN ScanText='Sequential Acquisition  '
    IF  SequenceType eq  2 THEN ScanText='Temperature Scan        '
    IF  SequenceType eq  3 THEN ScanText='2Theta Scan             '
    IF  SequenceType eq  4 THEN ScanText='Omega Scan              '
    IF  SequenceType eq  5 THEN ScanText='Chi Scan                '
    IF  SequenceType eq  6 THEN ScanText='Phi Scan                '
    IF  SequenceType eq  7 THEN ScanText='Translation 1 Scan      '
    IF  SequenceType eq  8 THEN ScanText='Translation 2 Scan      '
    IF  SequenceType eq  9 THEN ScanText='Other Scan              '
				inner=long(SequenceType)-2
    IF  SequenceType gt 10 THEN BEGIN
             ScanTextArray=['Sing.','Sequ.','Temp.','2Th. ','Omega','Chi  ','Phi  ','Tr.1 ','Tr.2 ','Seven','Else ']
             ScanText=ScanTextArray((long(SequenceType) /   10)<10)
             outertext=ScanText
             outer=(long(SequenceType)  /  10) - 2
             ScanText=ScanTextArray((long(SequenceType) mod   10)<10)
             innertext=ScanText
             inner=(long(SequenceType) mod 10) - 2
             ScanText=outerText+'/'+innertext+'coupled Scan '
    ENDIF
    IF inner GE 0 THEN BEGIN
				  PV(28,*)=par1(7+inner*5) 
						step_or_sub='Sub-Numor or Slice-No.  '
						step_or_sub='(inner) Scan Step-Width '
    ENDIF
	   PP  =[PV(0:30),par5(0:1),par5(3),$                   
		        StroboType,$      
		        par1(41),0,0,0,0]
    IF CntTime EQ 0.0 THEN BEGIN            ; IF Real Counting Time not measured
				  CntTime=PV(25,0)*PP(35)/8000000.      ; missing 51st scaler, 1 ACQ = 1 Slice (before modification)
						PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.)
				ENDIF
    IF CntTime LT 0.0 THEN BEGIN            ; Real Counting Time GE 1 hour: Value becomes negative
				  CntTime=PV(25,0)*PP(35)/8000000.*2.   ; 51st scaler present, 1 ACQ = 2 Slices (after modification)
						IF StroboType eq 0 THEN PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.*2.) ELSE PV(5,*)=PV(5,*)>(PV(25,*)*PP(35)/8000000.)
				ENDIF
				PP(5)=TOTAL(PV(5,*))                    ; Total counting time in fixed parameter 
				CntTime=PP(5)
    IF charpos NE 0 THEN BEGIN
				  day  = STRCOMPRESS(STRING(LONG(day)   -   LONG(CntTime)  /  86400),/remove_all)
				  hour  =STRCOMPRESS(STRING(LONG(hour)  -  (LONG(CntTime) MOD 86400)  /  3600),/remove_all)
				  minute=STRCOMPRESS(STRING(LONG(minute)- ((LONG(CntTime) MOD 86400) MOD 3600)  /  60),/remove_all)
				  second=STRCOMPRESS(STRING(LONG(second)-(((LONG(CntTime) MOD 86400) MOD 3600) MOD 60)),/remove_all)
      IF LONG(second) LT 0 THEN BEGIN
						  second = STRCOMPRESS(STRING(LONG(second)+60),/remove_all)
							 minute = STRCOMPRESS(STRING(LONG(minute)- 1),/remove_all)
						ENDIF
      IF LONG(minute) LT 0 THEN BEGIN
						  minute = STRCOMPRESS(STRING(LONG(minute)+60),/remove_all)
							 hour   = STRCOMPRESS(STRING(LONG(hour  )- 1),/remove_all)
						ENDIF
      IF LONG(hour  ) LT 0 THEN BEGIN
						  hour   = STRCOMPRESS(STRING(LONG(hour  )+60),/remove_all)
							 day    = STRCOMPRESS(STRING(LONG(day   )- 1),/remove_all)
						ENDIF
      IF LONG(day   ) LT 0 THEN BEGIN
						  second = STRCOMPRESS(STRING(0),/remove_all)
						  minute = STRCOMPRESS(STRING(0),/remove_all)
						  hour   = STRCOMPRESS(STRING(0),/remove_all)
							 day    = STRCOMPRESS(STRING(1),/remove_all)
						ENDIF
      day='00'+day
      day=strmid(day,strlen(day)-2,2)
      hour='00'+hour
      hour=strmid(hour,strlen(hour)-2,2)
      minute='00'+minute
      minute=strmid(minute,strlen(minute)-2,2)
      second='00'+second
      second=strmid(second,strlen(second)-2,2)
						DATI=day+"-"+month+"-"+year+""+hour+":"+minute+":"+second
      OT = INST(0)   +' '+ DATI $
     	   +' User '+strmid(exper(1),20,8)$
     	  	+' L.C.' +strmid(exper(4),20,7);$
		       ;+' Run'  +strcompress(string(numor)) 
				ENDIF
    PTXT=[$
                  ScanText   $
                 ,'Number of Segments      ','Segment Number          '$
                 ,'Number of Data Sets     ','Data Set Number         '$
                 ,'TOTAL Counting Time/s   ','Reactor Power / MW      '$
                 ,'D19 State               ','OS closed/open (0/1)    '$
                 ,'Sample Environment      ','Set Temperature         '$
                 ,'Regulation Temperature  ','Sample Temperature      '$
                 , MotTxt(0:5)$
                 ,'Voltmeter1              ','hor. MonoSlits / mm     '$
                 ,'vert. MonoSlits / mm    ','hor. SampleSlits / mm   '$
                 ,'vert. SampleSlits / mm  ','Time Step               '$
                 ,'Time Slice              ','Time Delay              '$
                 ,'Time Window             ', step_or_sub              $
                 ,'Numor                   ','Original Monitor Counts '$
                 ,'Incid. divergence alpha1','HOPG Filters IN/OUT     '$
                 ,'Wavelength / Angstroem  '$
                 ,'Stroboscopic Mode       ','Number of strob. Cycles '$
                 ,'Calibration Wavelength/A','Raw Data TwoTheta Offset'$
                 ,'Correction Eff./Ang./Bad','Normalisation Mon./Time '$
                 ,'Monochromator TakeOff   ','Monochromator Changer   '$
                 ,'Monochromator Rocking   ','Monochromator Tilt      '$
                 ,'Monochromator Bending   ','Lead Blocks             '$
                 ,'Monochromator Slit Top  ','Monochromator Slit Bottm'$
                 ,'Monochromator Slit Left ','Monochromator Slit Right'$
                 ,'Vacuum tube pressure    '$
                 ,'Sample Slit Top         ','Sample Slit Bottom      '$
                 ,'Sample Slit Left        ','Sample Slit Right       '$
                 ,'ReactorCycle            ','Magnetic Field          '$
		 ,'Julian Days since 1970  ','Seconds since noon      ']
           mag=0.0
           IF N_ELEMENTS(param) GE 16 THEN mag=param(15)
	PP=[PP,par5(4:13),par5(15:19),par5(25),mag,jul_day,jul_sec]
	FOR i=0,N_ELEMENTS(PP)-1 DO PTXT(i)=PTXT(i)+' ('+STRMID(STRCOMPRESS(100+i,/RE),1,2)+')'
	IF N_ELEMENTS(PV(0,*)) GT 1 THEN BEGIN
		PV_tmp=PV
		old_dim=N_ELEMENTS(PV(*,0))
		PV=FLTARR(N_ELEMENTS(PP),N_ELEMENTS(PV(0,*)))
		PV(0:old_dim-1,*)=PV_tmp(0:old_dim-1,*)
		FOR i=0,scan-1 DO PV(old_dim:N_ELEMENTS(PP)-1,i)=PP(old_dim:N_ELEMENTS(PP)-1)	
	ENDIF ELSE BEGIN
		PV=[PV,PP(N_ELEMENTS(PV):N_ELEMENTS(PP)-1)]
	ENDELSE
	if n_elements(pv(*,0) ge 55) then IF N_ELEMENTS(vparm(*,0)) GE 35 THEN BEGIN
			pv(51:54,*)=vparm(26:29,*)
			pv(41,*)=vparm(31,*)
			pv(42,*)=vparm(30,*)
			pv(43,*)=vparm(32,*)
			pv(44,*)=vparm(34,*)
			pv(32,*)=vparm(33,*)
	endif
	IF year GT 60 THEN twotheta_offset=-32.2 ELSE twotheta_offset=0.0  
    tmparr=FINDGEN(nd)/10.
	   PP(38)= (n_elements(cal_d20) eq nd AND eff_flag EQ 1) 
	   IF ang_flag NE 0 AND n_elements(ang_d20) EQ nd AND n_elements(cal_d20) EQ nd THEN BEGIN 
	       PP(38)= PP(38)+2 
			     twotheta_offset = ang_d20(0)
        tmparr=ang_d20-twotheta_offset
        PP(38)= PP(38)+2*(n_elements(ang_d20) eq nd) 
        IF wav_flag NE 0 THEN IF Wavelength NE 0 THEN PP(36)=Wavelength
    ENDIF
    IF (TwoTheta_OffSet+PP(13) GE 10 AND nd EQ 1600) THEN TwoTheta_Offset=TwoTheta_Offset-66.666667
    PV(13,*)=TwoTheta_OffSet+PV(13,*)
    PP(13)  =TwoTheta_OffSet+PP(13)
    PP(37)  =TwoTheta_Offset
    XX      =PV(13,0)+tmparr
				tmp     =WHERE([SequenceType,long(SequenceType)/10,long(SequenceType) mod 10] eq 3,count)
	   IF count GE 1 THEN BEGIN
             XX=fltarr(nd,scan)
             FOR i=0,nd-1 DO XX(i,*)=PV(13,*)+tmparr(i)
    ENDIF
    XT  ='2*Theta'
    IF scan gt 1 THEN BEGIN 
             YY=findgen(scan) 
             IF StroboType le 0 THEN BEGIN
                IF (SequenceType) mod 10 GE  2 AND long(SequenceType) mod 10 LE 8 THEN YY(*) = PV(10+long(SequenceType) mod 10,*)
             ENDIF
    ENDIF ELSE YY = round(numor)
	   IF StroboType le 0 THEN YT='Steps' ELSE YT='Slices'
    IF scan le 1 THEN BEGIN
        YT = 'Counts' 
        IF normalize NE 0 THEN YT=YT+'*'+STRCOMPRESS(STRING(ROUND(normalize/PP(30))),/remove_all)+')'
    ENDIF ELSE BEGIN
        IF StroboType le 0 THEN YT=ScanText
	       IF MAX(YY)-MIN(YY) eq 0.0 THEN BEGIN
	         YY=indgen(scan)
	         IF StroboType le 0 THEN YT='Steps' ELSE YT='Slices'
        ENDIF
    ENDELSE
    IF  SequenceType gt 10 THEN BEGIN
             YT='Steps'
             YY=indgen(scan)
    ENDIF
	   IF scan le 1 THEN BEGIN
      ZT = 'Counts' 
      IF normalize NE 0 THEN ZT=ZT+'('+STRCOMPRESS(STRING(normalize),/remove_all)+')'
    ENDIF ELSE ZT  ='Numor' & ZZ=PV
    DATE=DATI

  w=wout

  zerocounters=WHERE(TOTAL(REFORM(wout,N_ELEMENTS(wout(*,0)),N_ELEMENTS(wout(0,*))),2) LE 0)
  tmp=N_ELEMENTS(ZeroCounters)
		NbOfZeroCounters=tmp
;  print,''
;  IF NbOfZeroCounters GE 1 THEN PRINT,' Zero ',STRMID(ZeroCounters(0:13<N_ELEMENTS(ZeroCounters)-1),8,4)
  tmp=0*ZeroCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN FOR i=0,NbOfZeroCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ ZeroCounters(i) THEN tmp(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfZeroCounters GE 1 THEN BEGIN
    ind=where(tmp,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(ZeroCounters(ind),8,4)
  ENDIF
  tmp=TOTAL(REFORM(w,N_ELEMENTS(w(*,0)),N_ELEMENTS(w(0,*))),2)
  ind=findgen(N_ELEMENTS(tmp)-4)+2

  smoothed=tmp
  smoothed(ind)=2./3.*(tmp(ind-1)+tmp(ind-1))-(tmp(ind-2)+tmp(ind-2))/6.>0

  tmp0=TOTAL(REFORM(EE,N_ELEMENTS(EE(*,0)),N_ELEMENTS(EE(0,*))),2)/SQRT(N_ELEMENTS(EE(0,*)))
  tmp1=tmp-tmp0
  tmp2=tmp+tmp0

  MCounters=2+WHERE(tmp2(ind) LT (tmp1(ind-2)+tmp1(ind+2))/2./1.06 AND tmp1(ind-1)/1.02 GT (3.*tmp2(ind-2)+tmp2(ind+2))/4. AND tmp1(ind+1)/1.02 GT (tmp2(ind-2)+3.*tmp2(ind+2))/4.,NbOfMCounters)
  IF NbOfMCounters GE 2 THEN MCounters=MCounters(SORT((tmp(MCounters+2)+tmp(MCounters+1)+tmp(MCounters)+tmp(MCounters-1)+tmp(MCounters-2))/((tmp(MCounters+1)+tmp(MCounters-1))/2.-tmp(MCounters))))
;  IF NbOfMCounters GE 1 THEN PRINT,' "M"  ', STRMID(MCounters(0:13<N_ELEMENTS(MCounters)-1),8,4)
  tmp0=0*MCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN FOR i=0,NbOfMCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ MCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfMCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(MCounters(ind0),8,4)
  ENDIF

  WCounters=2+WHERE(tmp1(ind)/1.06 GT (tmp2(ind-2)+tmp2(ind+2))/2. AND tmp2(ind-1) LT (3.*tmp1(ind-2)+tmp1(ind+2))/4./1.02 AND tmp2(ind+1) LT (tmp1(ind-2)+3.*tmp1(ind+2))/4./1.02,NbOfWCounters)
  IF NbOfWCounters GE 2 THEN WCounters=WCounters(SORT((tmp(WCounters+2)+tmp(WCounters+1)+tmp(WCounters)+tmp(WCounters-1)+tmp(WCounters-2))/(tmp(WCounters)-(tmp(WCounters+1)+tmp(WCounters-1))/2.)))
;  IF NbOfWCounters GE 1 THEN PRINT,' "W"  ', STRMID(WCounters(0:13<N_ELEMENTS(WCounters)-1),8,4)
  tmp0=0*WCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN FOR i=0,NbOfWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ WCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
 ;   IF count GE 1 THEN PRINT,' excl.', STRMID(WCounters(ind0),8,4)
  ENDIF

  ind=findgen(N_ELEMENTS(tmp)-4)+2

  LowCounters =2+WHERE(tmp(ind) LT (smoothed(ind)-4.*SQRT(smoothed(ind)>0))-ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.-ABS(tmp(ind-1)-tmp(ind+1))/2. AND tmp(ind) GT 0,NbOfLowCounters)
  IF NbOfLowCounters GE 2 THEN LowCounters=LowCounters(SORT(smoothed(LowCounters)/(smoothed(LowCounters)-tmp(LowCounters))))
;  IF NbOfLowCounters GE 1 THEN PRINT,' Low  ', STRMID(LowCounters(0:13<N_ELEMENTS(LowCounters)-1),8,4)
  tmp0=0*LoWCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN FOR i=0,NbOfLoWCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ LoWCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfLoWCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(LoWCounters(ind0),8,4)
  ENDIF

  HighCounters =2+WHERE(tmp(ind) GT (smoothed(ind)+4.*SQRT(smoothed(ind)>0))+ABS(2.*smoothed(ind)-tmp(ind-1)-tmp(ind+1))/1.+ABS(tmp(ind-1)-tmp(ind+1))/2.,NbOfHighCounters)
  IF NbOfHighCounters GE 2 THEN HighCounters=HighCounters(SORT(smoothed(HighCounters)/tmp((HighCounters)-smoothed(HighCounters))))
;  IF NbOfHighCounters GE 1 THEN PRINT,' High ', STRMID(HighCounters(0:13<N_ELEMENTS(HighCounters)-1),8,4)
  tmp0=0*HighCounters
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN FOR i=0,NbOfHighCounters-1 DO BEGIN
    FOR j=0,N_ELEMENTS(bad_d20)-1 DO BEGIN
      IF bad_d20(j) EQ HighCounters(i) THEN tmp0(i)=1 
    ENDFOR
  ENDFOR
  IF N_ELEMENTS(bad_d20) GE 1 AND NbOfHighCounters GE 1 THEN BEGIN
    ind0=where(tmp0,count)
;    IF count GE 1 THEN PRINT,' excl.', STRMID(HighCounters(ind0),8,4)
  ENDIF

    good_cells           =indgen(nd)
    IF bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1 THEN BEGIN
      PP(38)= PP(38)+4 
      good_cells(bad_d20)=-1
      good_cells           =good_cells(WHERE(good_cells GE 0))
    ENDIF
    IF (bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1) THEN BEGIN
        ZZ=[bad_d20]
    ENDIF ELSE ZZ=[0]
    IF N_ELEMENTS(bad_d20) GE 1 THEN ZZ=[bad_d20] ELSE ZZ=[0]
    IF interpol_flag EQ 1 THEN BEGIN
      IF (bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1) THEN BEGIN
        ;PRINT,'Bad cells will be excluded AND interpolated, numbers of bad cells in Z'
						  IF (N_ELEMENTS(ang_d20) NE nd OR ang_flag EQ 0 OR N_ELEMENTS(cal_d20) NE nd) THEN BEGIN ;noang
          PP(38)= PP(38)+8 
          IF N_ELEMENTS(WOUT(0,*)) GE N_ELEMENTS(XX(0,*)) THEN BEGIN  
            FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO BEGIN
								      WOUT(bad_d20,i)=interpol(WOUT(good_cells,i),XX(good_cells),XX(bad_d20))
								      EE  (bad_d20,i)=interpol(EE  (good_cells,i),XX(good_cells),XX(bad_d20))
						    		ENDFOR
          ENDIF ELSE BEGIN
						      WOUT(bad_d20,*)=interpol(WOUT(good_cells,*),XX(good_cells),XX(bad_d20))
						      EE  (bad_d20,*)=interpol(EE  (good_cells,*),XX(good_cells),XX(bad_d20))
						    ENDELSE
								ENDIF 
      ENDIF 
	     IF N_ELEMENTS(ang_d20) EQ nd AND N_ELEMENTS(cal_d20) EQ nd AND ang_flag EQ 1 THEN BEGIN
          PP(38)= PP(38)+8 
          IF N_ELEMENTS(WOUT(0,*)) GE N_ELEMENTS(XX(0,*)) THEN BEGIN
										  XXold=XX(good_cells)
												XX=XX(0)+findgen(nd)/10.
            FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO BEGIN
						    		  WOUT(*,i)=interpol(WOUT(good_cells,i),XXold,XX)
						    		  EE  (*,i)=interpol(EE  (good_cells,i),XXold,XX)
						    		ENDFOR
          ENDIF ELSE BEGIN
										  XXold=XX(good_cells)
												FOR i=0,N_ELEMENTS(WOUT(0,*))-1 DO XX(*,i)=XX(0,i)+findgen(nd)/10.
						      WOUT=interpol(WOUT,XXold,XX)
						      EE  =interpol(EE  ,XXold,XX)
					    	ENDELSE

								ENDIF;ang
				ENDIF ELSE BEGIN ; NO interpolation
				  IF bad_flag EQ 1 AND N_ELEMENTS(bad_d20) GE 1 THEN BEGIN
        ;PRINT,'Bad cells will be excluded and NOT interpolated, numbers of BAD cells in Z!'
        ;PRINT,'Attention, some macros may fail on irregular data (missing cells)!'
						  WOUT=WOUT(good_cells,*)
						  XX  =XX  (good_cells,*)
						  EE  =EE  (good_cells,*)
				  ENDIF
				ENDELSE
			 IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
						FOR i=0,scan-1 DO BEGIN
						  WOUT(*,i)=      WOUT(*,i)/ NN(i)*normalize
						  EE  (*,i)=      EE  (*,i) /NN(i)*normalize								
						ENDFOR
      par1(54)=par1(54)/par1(50)*normalize ; 2nd monitor
      normalization_factor=NN
      normalization_factor=NN/normalize
      normalization_factor=1./normalization_factor
						NN=NN*0+normalize
						PP(39)=normalize
      normalization_factor=NN/normalize
				ENDIF
    IF N_ELEMENTS(pv(0,*)) GT 1 THEN BEGIN
      ;help,NN
	  IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
        NN=[[REFORM(NN,1,1,N_ELEMENTS(NN))],[REFORM(PV(5,*)*normalization_factor,1,1,N_ELEMENTS(PV(5,*)))],[REFORM(PV(5,*)*0.+par1(54)*normalization_factor,1,1,N_ELEMENTS(PV(5,*)))]]
      ENDIF ELSE BEGIN
        NN=[[REFORM(NN,1,1,N_ELEMENTS(NN))],[REFORM(PV(5,*),1,1,N_ELEMENTS(PV(5,*)))],[REFORM(PV(5,*)*0.+par1(54),1,1,N_ELEMENTS(PV(5,*)))]]
      ENDELSE
    ENDIF ELSE BEGIN
	  IF normalize GT 0 AND MIN(NN) GT 0 THEN BEGIN
        NN=[[NN],[PV(5,*)*normalization_factor],[par1(54)*normalization_factor]]
        ; Mod. 4/2/98 Hansen: 2nd monitor
      ENDIF ELSE BEGIN
        NN=[[NN],[PV(5,*)],[par1(54)]] ; Mod. 4/2/98 Hansen: 2nd monitor
      ENDELSE
    ENDELSE
    IF float_flag EQ 0 THEN WOUT=LONG(WOUT)
	;HELP,PTXT,PP,PV
	;PRINT,'CouCou'
  RETURN
END
	PRO rdid_d17, INST,numor,nvers,text,exper,scan,cnt,WOUT,vparm,param,par1,par2,par3,par4,par5,$
             	     WT ,XT ,YT ,ZT ,OT ,DATE ,PP ,PTXT ,XX ,YY ,ZZ ,NN ,PV ,EE

	iprint=0


;LAMP data-read interface for D17 data (ILL format) called from rdid.pro
;**********************************************************************
;
;							JRS,RC 9/5/00
;
;Parameters to return
;********************
;WOUT             (modified data)
;WT,XT,YT,ZT,OT   (titles)
;PP,PTXT          (parameter floatting table and textarea)
;XX,YY,ZZ         (coordinates)
;NN               (monitors)
;PV               (supplement parameter table of any dimension)
;EE               (errors from WOUT)



;Useful input parameters from rdid
;*********************************

	IF (iprint GT 0) THEN BEGIN
		HELP, INST 	& PRINT, INST
		HELP, numor 	& PRINT, numor
		HELP, nvers 	& PRINT, nvers
		HELP, text 	& PRINT, text
		HELP, exper 	& PRINT, exper
		HELP, scan 	& PRINT, scan
		HELP, cnt 	& PRINT, cnt
		HELP, WOUT
		HELP, vparm 	& PRINT, vparm
		HELP, param 	& PRINT, param   
		HELP, par1 	& PRINT, par1
		HELP, par2	& IF (N_ELEMENTS(par2) GT 0) THEN PRINT, par2
	ENDIF
		

;Parameters to return
;********************
;WOUT             (modified data)
;WT,XT,YT,ZT,OT   (titles)
;PP,PTXT          (parameter floatting table and textarea)
;XX,YY,ZZ         (coordinates)
;NN               (monitors)
;PV               (supplement parameter table of any dimension)
;EE               (errors from WOUT)

	IF (iprint GT 0) THEN PRINT,'rdid_d17: starting'
	PRINT,'Reading run',numor

	inst       = STRMID(text,0,4)
	user       = STRMID(text,4,12)

	IF (iprint GT 0) THEN BEGIN
		PRINT, 'inst =',inst
		PRINT, 'user =',user
	ENDIF

	user=STRMID(exper(0),0,10)
	main_title=STRMID(exper(0),10,39)
	prop=STRMID(exper(0),49,9)
	sub_title=STRMID(exper(0),60,20)

	IF (iprint GT 0) THEN BEGIN
		PRINT,'user =',user
		PRINT,'main_title =',main_title
		PRINT,'prop =',prop
		PRINT,'sub_title =',sub_title
	ENDIF

;------------------------------------
;	Assign Parameter block
;
	open_req=45.-(param(43)-param(41))
	open_act=45.-(param(47)-param(45))
	period=60./param(44)
	delay_ang=(285.-open_act)/2.
	delay_tim=(delay_ang/360.)*period

	npars=29
	p_buf=FLTARR(npars)
	par_txt_buf=STRARR(npars)

	p_buf(0)=numor 		& par_txt_buf(0)  =' 0  Numor            ='
	p_buf(1)=par1(94)	& par_txt_buf(1)  =' 1  Time Channels    ='
	p_buf(2)=par1(97)	& par_txt_buf(2)  =' 2  X1               ='
	p_buf(3)=par1(98)	& par_txt_buf(3)  =' 3  X2               ='
	p_buf(4)=par1(99)	& par_txt_buf(4)  =' 4  Y1               ='
	p_buf(5)=par1(100)	& par_txt_buf(5)  =' 5  Y2               ='
	p_buf(6)=par1(95)	& par_txt_buf(6)  =' 6  Channel width    ='
	p_buf(7)=par1(96)	& par_txt_buf(7)  =' 7  Electr TOF delay ='
	p_buf(8)=par1(101)	& par_txt_buf(8)  =' 8  NX               ='
	p_buf(9)=par1(102)	& par_txt_buf(9)  =' 9  NY               ='
	p_buf(10)=param(40)	& par_txt_buf(10) =' 10 chop 1 speed req ='
	p_buf(11)=param(41)	& par_txt_buf(11) =' 11 chop 1 phase req ='
	p_buf(12)=param(42)	& par_txt_buf(12) =' 12 chop 2 speed req ='
	p_buf(13)=param(43)	& par_txt_buf(13) =' 13 chop 2 phase req ='
	p_buf(14)=param(44)	& par_txt_buf(14) =' 14 chop 1 speed act ='
	p_buf(15)=param(45)	& par_txt_buf(15) =' 15 chop 1 phase act ='
	p_buf(16)=param(46)	& par_txt_buf(16) =' 16 chop 2 speed act ='
	p_buf(17)=param(47)	& par_txt_buf(17) =' 17 chop 2 phase act ='
	p_buf(18)=open_req	& par_txt_buf(18) =' 18 chop opening req ='
	p_buf(19)=open_act	& par_txt_buf(19) =' 19 chop opening act ='
	p_buf(20)=period	& par_txt_buf(20) =' 20 chop period      ='
	p_buf(21)=delay_ang	& par_txt_buf(21) =' 21 chop delay angle ='
	p_buf(22)=delay_tim	& par_txt_buf(22) =' 22 chop delay time  ='
	p_buf(23)=param(15)	& par_txt_buf(23) =' 23 sam-det distance ='
	p_buf(24)=param(2)	& par_txt_buf(24) =' 24 sample angle     ='
	p_buf(25)=param(16)	& par_txt_buf(25) =' 25 detector angle   ='
	p_buf(26)=par1(2)/10.	& par_txt_buf(26) =' 26 run time         ='
	p_buf(27)=param(8)	& par_txt_buf(27) =' 27 slity thing      ='
	p_buf(27)=par1(4)	& par_txt_buf(28) =' 27 monitor          ='	

	IF (iprint GT 0) THEN PRINT,'parameters assigned OK'

;------------------------------------
	
	tot=cnt
	tsize=LONG(par1(94))
	xsize=LONG(par1(98)-par1(97)+1)
	ysize=LONG(par1(100)-par1(99)+1)

	;IF (tot ne ((xsize*ysize*tsize))) THEN PRINT,'read_d17: Error in data array dimensions'
	IF (iprint GT 0) THEN BEGIN	
		PRINT,'tsize= ',tsize,' detector size= ',xsize*ysize
		PRINT,'xsize= ',xsize,' ysize= ',ysize,' tot1= ',xsize*ysize*tsize,' tot2= ',tot
	ENDIF

	w_buf=WOUT(0:xsize*ysize*tsize-1)
	;if tsize gt 1 then mo=WOUT(xsize*ysize*tsize:cnt-1)	
	mon=par1(4)
        ;if mon le 0. then begin 
	  ;mon=total(mo)
          ;mo=WOUT(xsize*ysize*tsize:cnt-1)
	  ;print,'Using old monitor format'
	;endif
	det=REFORM(w_buf,ysize,xsize,tsize)
	w_buf=FLTARR(xsize,ysize,tsize)
	FOR i=0,tsize-1 DO w_buf(*,*,i)=ROTATE(det(*,*,i),3) 
	x_buf=INDGEN(xsize)+par1(97)
	y_buf=INDGEN(ysize)+par1(99)
	z_buf=INDGEN(tsize)
	n_buf=mon


;------------------------------------
	WOUT=w_buf
	PP=p_buf
	PTXT=par_txt_buf
	NN=n_buf
	XX=x_buf
	YY=y_buf
	ZZ=z_buf
	WT=sub_title
	OT=inst+' '+user+' '+main_title
	XT='X pixels'
	YT='Y pixels'
	ZT='Time channels'
	
;correction for binning
if ysize eq 1 then begin
  y_buf=z_buf
  YT=ZT
end

	IF (iprint GT 0) THEN PRINT,'rdid_d17: finished'

	RETURN
	END
